{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tusb_conf_desc_t UDC_DESC_STORAGE *p = desc;\n\n\twhile (p->bLength) {\n\t\tif (p->bDescriptorType == desc_id) {\n\t\t\treturn p;\n\t\t}\n\t\tp = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) p +\n\t\t\t\tp->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 33.68471050867339}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tuint8_t *p = (uint8_t *) desc;\n\tuint8_t *p_end = (uint8_t *) desc + desc->wTotalLength;\n\n\twhile (p < p_end) {\n\t\tif (*p == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 33.93083763738929}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t\n\t\t\t\tUDC_DESC_STORAGE *) desc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 33.913734927073016}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tbool found = false;\n\tuint8_t *p_desc;\n\tuint8_t *p_desc_end;\n\tuint8_t *p_desc_end_config;\n\tuint8_t *p_desc_end_config_temp;\n\tuint8_t *p_desc_end_config_temp_2;\n\tuint8_t *p_desc_end_config_temp_3;\n\tuint8_t *p_desc_end_config_temp_4;\n\tuint8_t *p_desc_end_config_temp_5;\n\tuint8_t *p_desc_end_config_temp_6;\n\tuint8_t *p_desc_end_config_temp_7;\n\tuint8_t *p_desc_end_config_temp_8;\n\tuint8_t *p_desc_end_config_temp_9;\n\tuint8_t *p_desc_end_config_temp_10;\n\tuint8_t *p_desc_end_config_temp_11;\n\tuint8_t *p_desc_end_config_temp_12;\n\tuint8_t *p_desc_end_config_temp_13;\n\tuint8_t *p_desc_end_config_temp_14;\n\tuint8_t *p_desc_end_config_temp_15;\n\tuint8_t *p_desc_end_config_temp_16;\n\tuint8_t *p_desc_end_config_temp_17;\n\tuint8_t *p_desc_end_config_temp_18;\n\tuint8_t *p_desc_end_config_temp_19;\n\tuint8_t *p_desc_end_config_temp_20;\n\tuint8_t *p_desc_end_config_temp_21;\n\tuint8_t *p_desc_end_config_temp_22;\n\tuint8_t *p_desc_end_config_temp_23;\n\tuint8_t *p_desc_end_config_temp_2", "CodeBleu_score": 6.828186018927056}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t i;\n\tuint8_t *p_desc = udc_desc_buf;\n\tuint16_t desc_len;\n\tuint8_t desc_type;\n\tuint8_t iface_num_tmp;\n\tuint8_t setting_num_tmp;\n\n\t//- Verify that there is a valid configuration\n\tif (udc_config_num == 0) {\n\t\treturn false;\n\t}\n\n\t//- Verify that the interface number is within bounds\n\tif (iface_num > udc_iface_count) {\n\t\treturn false;\n\t}\n\n\t//- Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\t//- and check each one to see if it matches the specified interface number and setting number\n\tfor (i = 0; i < udc_config_desc_len; i += desc_len) {\n\t\t//- Get the length of the descriptor\n\t\tdesc_len = p_desc[0];\n\t\t//- Get the descriptor type\n\t\tdesc_type = p_desc[1];\n\n\t\t//- Check if the descriptor is an interface descriptor\n\t\tif (desc_type == UDC_DESC_TYPE_IFACE) {\n\t\t\t//- Get the interface number\n\t\t\tiface_num_tmp = p_desc[2];\n\t\t\t//- Get the setting number\n\t\t\tsetting_num_tmp = p_desc[4];\n\n\t\t\t//- Check if the interface number and setting number match\n\t\t\tif (iface_num_tmp == iface_num && setting_num_tmp == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t//- Increment the pointer to the next descriptor\n\t\tp_desc += desc_len;\n\t}\n\n\t//- If we get here, we didn't find a matching interface descriptor\n\treturn false;\n}", "CodeBleu_score": 32.521527260579106}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tif (udc_config_num == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_num) {\n\t\treturn false;\n\t}\n\n\tuint8_t *desc_ptr = udc_config_desc;\n\tuint8_t *desc_end = udc_config_desc + udc_config_desc_size;\n\twhile (desc_ptr < desc_end) {\n\t\tuint8_t desc_type = desc_ptr[1];\n\t\tuint8_t desc_length = desc_ptr[0];\n\t\tif (desc_type == UDC_DESC_TYPE_IFACE) {\n\t\t\tif (desc_ptr[2] == iface_num && desc_ptr[4] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc_ptr += desc_length;\n\t}\n\treturn false;\n}", "CodeBleu_score": 32.71601513371628}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\tif (le16_to_cpu(req->wLength) != 2) {\n\t\treturn false;\n\t}\n\n\tudd_ep_status_t ep_status;\n\tudd_ep_status(ep, &ep_status);\n\n\tif (ep_status.is_halted) {\n\t\tudd_g_ep_control_payload_put(0x0001);\n\t} else {\n\t\tudd_g_ep_control_payload_put(0x0000);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 20.628760105455108}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tif (req->wLength != 2) {\n\t\treturn false;\n\t}\n\tudd_ep_status_t status;\n\tif (udd_ep_is_halted(g_ctrlreq.wIndex & USB_EP_ADDR_MASK)) {\n\t\tstatus = UDD_EP_HALTED;\n\t} else {\n\t\tstatus = UDD_EP_OK;\n\t}\n\tudd_set_setup_payload(0, status);\n\treturn true;\n}", "CodeBleu_score": 33.909944687513686}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udd_g_ctrlreq.req.wLength != sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\tudd_g_ctrlreq.payload_size = sizeof(uint16_t);\n\tudd_g_ctrlreq.payload = &udd_ep_is_halted;\n\tudd_ep_is_halted = udd_ep_is_halted(udd_g_ctrlreq.req.wIndex);\n\tudd_g_ctrlreq.payload_size = 0;\n\treturn true;\n}", "CodeBleu_score": 36.85619207690079}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tiface_num = udc_setup_req->wIndex & 0xFF;\n\tsetting_num = udc_setup_req->wValue & 0xFF;\n\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tif (false == udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\tif (false == udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\treturn udi_api_t::g_apis[udc_ptr_iface->bInterfaceSubClass]->setup();\n}", "CodeBleu_score": 65.33892175023206}, {"code": "static bool udc_req_iface(void){\n\tbool b_req_handled = false;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (udc_ptr_setup->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(udc_ptr_setup->wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(udc_ptr_setup->wIndex,\n\t\t\tudc_ptr_setup->wValue)) {\n\t\treturn false;\n\t}\n\n\t// Forward the request to the corresponding USB Device Interface (UDI) handler\n\tif (udc_ptr_iface->bInterfaceClass <= UDC_IFACE_CLASS_MAX) {\n\t\tif (udc_ptr_iface->bInterfaceClass == UDC_IFACE_CLASS_HID) {\n\t\t\tb_req_handled = udi_hid_setup();\n\t\t}\n\t}\n\n\treturn b_req_handled;\n}", "CodeBleu_score": 59.51016606504802}, {"code": "static bool udc_req_iface(void){\n\tbool b_req_handled = false;\n\tusb_iface_desc_t UDC_DESC_STORAGE *ptr_iface_desc;\n\tusb_ep_desc_t UDC_DESC_STORAGE *ptr_ep_desc;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (udc_ptr_setup->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Start at the beginning of configuration descriptor\n\tptr_iface_desc = (UDC_DESC_STORAGE usb_iface_desc_t *)\n\t\t\tudc_ptr_conf->desc;\n\n\t// Check the end of configuration descriptor\n\twhile (udc_get_eof_conf() >\n\t\t\t(UDC_DESC_STORAGE usb_conf_desc_t *) ptr_iface_desc) {\n\t\tif (USB_DT_INTERFACE == ptr_iface_desc->bDescriptorType) {\n\t\t\t// A interface descriptor is found\n\t\t\t// Check interface and alternate setting number\n\t\t\tif ((udc_ptr_setup->wIndex ==\n\t\t\t\t\tptr_iface_desc->bInterfaceNumber) &&\n\t\t\t\t\t(0 ==\n\t\t\t\t\tptr_iface_desc->bAlternateSetting)) {\n\t\t\t\t// Update the interface descriptor to the default setting\n\t\t\t\tudc_ptr_iface = ptr_iface_desc;\n\t\t\t\tif (udc_update_iface_desc(\n\t\t\t\t\t\tudc_ptr_setup->wIndex, 0)) {\n\t\t\t\t\t// Update the interface descriptor to the current alternate setting\n\t\t\t\t\tudc_ptr_iface = ptr_iface_desc;\n\t\t\t\t\tif (udc_update_iface_desc(\n\t\t\t\t\t\t\tudc_ptr_setup->wIndex,\n\t\t\t\t\t\t\tudc_ptr_setup->wValue", "CodeBleu_score": 53.5481862528738}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t// Initialize internal variables\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_sense_valid = false;\n  udi_msc_b_csw_invalid = false;\n  udi_msc_b_csw_error = false;\n  udi_msc_b_csw_error_bit7 = false;\n  udi_msc_b_csw_error_bit14 = false;\n  udi_msc_b_csw_error_bit15 = false;\n  udi_msc_b_csw_error_bit2 = false;\n  udi_msc_b_csw_error_bit12 = false;\n  udi_msc_b_csw_error_bit13 = false;\n  udi_msc_b_csw_error_bit1 = false;\n  udi_msc_b_csw_error_bit3 = false;\n  udi_msc_b_csw_error_bit11 = false;\n  udi_msc_b_csw_error_bit4 = false;\n  udi_msc_b_csw_error_bit5 = false;\n  udi_msc_b_csw_error_bit6 = false;\n  udi_msc_b_csw_error_bit9 = false;\n  udi_msc_b_csw_error_bit10 = false;\n  udi_msc_b_csw_error_bit8 = false;\n  udi_msc_b_csw_error_bit16 = false;\n  udi_msc_b_csw_error_bit17 = false;\n  udi_msc_b_csw_error_bit18 = false;\n  udi_msc_b_csw_error_bit19 = false;\n  udi_msc_b_csw_error_bit20 = false;\n  udi_msc_b_csw_error_bit21 = false;\n  udi_msc", "CodeBleu_score": 10.346551491335102}, {"code": "bool udi_msc_enable(void){\n\t// Check if the USB device is enumerated\n  if (!udc_is_enum())\n    return false;\n\n  // Check if the interface is supported by the USB host\n  if (!udc_iface_is_claimed(UDI_MSC_IFACE_NUMBER))\n    return false;\n\n  // Initialize the state of the MSC interface\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_cbw_wait_csw = false;\n  udi_msc_b_cbw_wait_reset = false;\n  udi_msc_b_cbw_wait_reset_after_csw = false;\n  udi_msc_b_cbw_wait_reset_after_csw_no_data = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_in = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_out = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_in_last = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_out_last = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_in_underflow = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_out_underflow = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_in_overflow = false;\n  udi_msc_b_cbw_wait_reset_after_csw_data_out_overflow = false;\n  udi_msc_b_cbw_wait_reset_after_csw_phase_error = false;\n  udi_msc_b_cbw_wait_reset_after_csw_phase_error_data_in = false;\n  udi_msc_b_cbw_wait_reset_after_csw", "CodeBleu_score": 25.56811821921448}, {"code": "bool udi_msc_enable(void){\n\t// Initialize flags\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_cbw_invalid_no_stall = false;\n  udi_msc_b_cbw_invalid_out_of_range = false;\n  udi_msc_b_cbw_invalid_not_ready = false;\n  udi_msc_b_cbw_invalid_not_write_protected = false;\n  udi_msc_b_cbw_invalid_write_protected = false;\n  udi_msc_b_cbw_invalid_data_phase_error = false;\n  udi_msc_b_cbw_invalid_command_unknown = false;\n  udi_msc_b_cbw_invalid_command_unsupported = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_fail = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase_error = false;\n  udi_msc_b_cbw_invalid_command_phase", "CodeBleu_score": 15.644774811444556}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Transfer error\n    // then STALL next request from USB host on corresponding endpoint\n    if (UDI_MSC_EP_IN == ep)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    return;\n  }\n  if (UDI_MSC_EP_IN == ep) {\n    // In case of IN transfer, the CSW is sent\n    udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PASS;\n    udi_msc_csw_process();\n  } else {\n    // In case of OUT transfer, the CSW is received\n    udi_msc_csw_receive();\n  }\n}", "CodeBleu_score": 63.24002828625921}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Transfer failed\n    if (UDD_EP_TRANSFER_STALL == status) {\n      // Stall sent by USB host\n      udi_msc_cbw_invalid();\n      return;\n    }\n    // NAK received\n    if (UDI_MSC_EP_OUT == ep) {\n      // OUT endpoint\n      // Stall sent to USB host\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n      udi_msc_cbw_invalid();\n      return;\n    }\n    // IN endpoint\n    // Stall sent to USB host\n    udd_ep_set_halt(UDI_MSC_EP_IN);\n    udi_msc_cbw_invalid();\n    return;\n  }\n  // Transfer successful\n  if (UDI_MSC_EP_OUT == ep) {\n    // OUT endpoint\n    // Update CSW data residue\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n  }\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 63.638843679377764}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Transfer error\n    udi_msc_cbw_abort();\n    return;\n  }\n  // Update residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 71.43811548454013}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t// If there is a non-zero data residue,\n  if (udi_msc_cbw.dCBWDataTransferLength) {\n    // stall the next request from the USB host on the appropriate endpoint\n    // based on the direction of the Command Block Wrapper (CBW).\n    if (udi_msc_cbw.bmCBWFlags & 0x80) {\n      // IN direction\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    } else {\n      // OUT direction\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    }\n  }\n  // Prepare CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 68.765206016956}, {"code": "static void udi_msc_csw_process(void){\n\t// If there is a non-zero data residue\n  if (udi_msc_cbw.dCBWDataTransferLength) {\n    // Stall next request from USB host on appropriate endpoint based on direction of CBW\n    if (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    } else {\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    }\n  }\n  // Prepare CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 70.12158266248221}, {"code": "static void udi_msc_csw_process(void){\n\tif (udi_msc_cbw.dCBWDataTransferLength) {\n    if (udi_msc_cbw.bmCBWFlags & 0x80) {\n      // IN transfer\n      // Stall next IN request\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    } else {\n      // OUT transfer\n      // Stall next OUT request\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare CSW\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 68.70922254778809}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (port >= USB_CDC_NUM_PORTS) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tcancelReset(port);\n\t} else {\n\t\tif (usb_cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\tinitiateReset(port);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.14810792736872}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n        cancelReset();\n    } else {\n        if (usb_task_cdc_get_baudrate(port) == 1200) {\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 33.886318297789316}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n        cancelReset();\n    } else if (usb_task_cdc_get_baud_rate(port) == 1200) {\n        initiateReset();\n    }\n}", "CodeBleu_score": 31.70325845868898}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\tbool retVal;\n\tuint8_t request_index;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tuint16_t wLength;\n\tuint8_t *data_ptr;\n\tuint8_t *data_ptr_next;\n\tuint16_t size;\n\tuint16_t size_next;\n\tuint16_t size_remaining;\n\tuint16_t size_remaining_next;\n\tuint8_t *data_ptr_next_next;\n\tuint16_t size_next_next;\n\tuint16_t size_remaining_next_next;\n\tuint8_t *data_ptr_next_next_next;\n\tuint16_t size_next_next_next;\n\tuint16_t size_remaining_next_next_next;\n\tuint8_t *data_ptr_next_next_next_next;\n\tuint16_t size_next_next_next_next;\n\tuint16_t size_remaining_next_next_next_next;\n\tuint8_t *data_ptr_next_next_next_next_next;\n\tuint16_t size_next_next_next_next_next;\n\tuint16_t size_remaining_next_next_next_next_next;\n\tuint8_t *data_ptr_next_next_next_next_next_next;\n\tuint16_t size_next_next_next_next_next_next;\n\tuint16_t size_remaining_next_next_next_next_next_next;\n\tuint8_t *data_ptr_next_next_next_next_next_next_next;\n\tuint16_t size_next_next_next_next_next_next_next;\n\tuint16_t size_remaining_next_next_next_next_next_next_next;\n\tuint8_t *data_ptr_next_next_next_next_next_next_next_next;\n\tuint16_t size_next_next_next_next", "CodeBleu_score": 4.2507434535952955}, {"code": "bool usb_task_other_requests(void){\n\tif (usb_setup.Type == USB_SETUP_TYPE_VENDOR) {\n\t\tif (usb_setup.bRequest == USB_SETUP_VENDOR_REQUEST_GET_ID) {\n\t\t\tif (usb_setup.wIndex == 0x04) {\n\t\t\t\tusb_setup.wIndex = 0x00;\n\t\t\t\tusb_setup.wLength = 0x0008;\n\t\t\t\tusb_setup.wValue = 0x0000;\n\t\t\t\tusb_setup.bRequest = 0x06;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (usb_setup.wIndex == 0x05) {\n\t\t\t\tusb_setup.wIndex = 0x00;\n\t\t\t\tusb_setup.wLength = 0x0008;\n\t\t\t\tusb_setup.wValue = 0x0001;\n\t\t\t\tusb_setup.bRequest = 0x06;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.297429260393017}, {"code": "bool usb_task_other_requests(void){\n\tif (USB_BMREQUESTTYPE_TYPE_VENDOR == setup.bmRequestType &&\n        USB_BMREQUESTTYPE_RECIPIENT_DEVICE == setup.bmRequestType) {\n        if (0x04 == setup.bRequest) {\n            setup.wIndex = 0x04;\n            setup.wLength = 0x04;\n            setup.wValue = 0x0000;\n            return true;\n        } else if (0x05 == setup.bRequest) {\n            setup.wIndex = 0x05;\n            setup.wLength = 0x04;\n            setup.wValue = 0x0000;\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 15.532121312719255}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\n    if (nbyte == 0) {\n        return;\n    }\n\n    for (i = 0; i < nbyte - 1; i++) {\n        spiSend(0x00);\n        buf[i] = spiRec();\n    }\n\n    spiSend(0x00);\n    buf[i] = spiRecLast();\n}", "CodeBleu_score": 51.096072179637574}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n    uint8_t dummy;\n\n    if (nbyte == 0) return;\n\n    // Send dummy byte to SPI transmit data register\n    SPI_PCS = 0;\n    SPI_TDR = 0xff;\n    dummy = SPI_RDR;\n\n    for (i = 0; i < nbyte - 1; i++) {\n        dummy = SPI_RDR;\n        buf[i] = dummy;\n        SPI_PCS = 0;\n        SPI_TDR = 0xff;\n    }\n\n    // Read last byte\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 47.99122685512366}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n  uint8_t j;\n\n  if (nbyte == 0) {\n    return;\n  }\n\n  for (i = 0; i < (nbyte - 1); i++) {\n    SPI_TXBUF = 0xFF;\n    while (!(SPI_STATUS & SPI_RX_FULL)) {\n      ;\n    }\n    buf[i] = SPI_RXBUF;\n  }\n  j = spiRec();\n  buf[i] = j;\n}", "CodeBleu_score": 47.40026557322858}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tCRITICAL_SECTION_VAR();\n\tCRITICAL_SECTION_START\n\t\tuint32_t *relocated_vectors = get_relocated_table_addr();\n\t\tpfnISR_Handler oldHandler = (pfnISR_Handler)relocated_vectors[irq + 16];\n\t\trelocated_vectors[irq + 16] = (uint32_t)newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 57.60881321932481}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = NULL;\n    uint32_t *relocated_table_addr = get_relocated_table_addr();\n\n    CRITICAL_SECTION_START\n    oldHandler = relocated_table_addr[irq + 16];\n    relocated_table_addr[irq + 16] = (uint32_t)newHandler;\n    CRITICAL_SECTION_END\n\n    return oldHandler;\n}", "CodeBleu_score": 60.84397971060363}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n\n  CRITICAL_SECTION_START\n  oldHandler = get_relocated_table_addr()->vectors[irq + 16];\n  get_relocated_table_addr()->vectors[irq + 16] = newHandler;\n  CRITICAL_SECTION_END\n\n  return oldHandler;\n}", "CodeBleu_score": 61.51779837905116}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (udi_cdc_is_rx_ready()) {\n    uint8_t c = udi_cdc_getc();\n    if (c == '\\r') return '\n';\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 27.429643959884853}, {"code": "int MarlinSerialUSB::peek(){\n\tif (udi_cdc_is_rx_ready()) {\n    uint8_t c = udi_cdc_getc();\n    if (emergency_parser.enabled) emergency_parser.update(c);\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 31.01743609554606}, {"code": "int MarlinSerialUSB::peek(){\n\tint c = -1;\n  if (usb_task_cdc_isenabled()) {\n    c = udi_cdc_getc();\n    if (c >= 0) {\n      if (emergency_parser.enabled) emergency_parser.update(c);\n      if (c == '\n' || c == '\\r') {\n        TERN_(EMERGENCY_PARSER, emergency_parser.reset());\n        TERN_(HOST_ACTION_COMMANDS, host_action.reset());\n      }\n    }\n  }\n  return c;\n}", "CodeBleu_score": 48.40701464287146}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (rx_buffer_index_r != rx_buffer_index_w) {\n    // If there is a pending character, return it\n    const uint8_t c = rx_buffer[rx_buffer_index_r];\n    rx_buffer_index_r = (rx_buffer_index_r + 1) % RX_BUFFER_SIZE;\n    return c;\n  }\n\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  const uint8_t c = udi_cdc_getc();\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n\n  return c;\n}", "CodeBleu_score": 44.42806138393296}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_rx_count) return pending_rx_buffer[--pending_rx_count];\n  if (!udi_cdc_is_rx_ready(0)) return -1;\n  if (!usb_task_cdc_isenabled()) return -1;\n  int c = udi_cdc_getc(0);\n  if (c < 0) return -1;\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n  return c;\n}", "CodeBleu_score": 46.499979210598326}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_rx_count) return pending_rx_buffer[--pending_rx_count];\n  if (!USB_SERIAL_ISR_ENABLED()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  return udi_cdc_getc();\n}", "CodeBleu_score": 27.213542008191105}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (usb_rx_available()) return usb_rx_available();\n  return usb_task_cdc_isenabled() ? 0 : -1;\n}", "CodeBleu_score": 36.55794849228625}, {"code": "int MarlinSerialUSB::available(){\n\tif (usb_bytes_available()) return usb_bytes_available();\n  return usb_task_cdc_isenabled();\n}", "CodeBleu_score": 35.77627188011584}, {"code": "int MarlinSerialUSB::available(){\n\tif (usb_task_cdc_available()) return usb_task_cdc_get_char();\n  return 0;\n}", "CodeBleu_score": 17.578842144441058}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t * const p = value;\n  uint8_t c;\n  LOOP_L_N(i, size) {\n    c = ee_Read(pos);\n    if (writing) *p++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 64.55859510809383}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t c;\n  while (size--) {\n    c = ee_Read(pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 75.40954163582015}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t c;\n  while (size--) {\n    c = ee_Read(pos, writing);\n    if (crc) crc16(crc, &c, 1);\n    if (value) *value++ = c;\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 59.470023849492115}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return; // Not a hardware PWM pin!\n\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // No hardware PWM channel available, use software PWM\n  if (!pwm_count) {\n    // Start the software PWM timer\n    pwm_timer = timerBegin(0, 80, true);\n    timerAttachInterrupt(pwm_timer, &pwm_irq, true);\n    timerAlarmWrite(pwm_timer, 1000000 / PWM_FREQUENCY, true);\n    timerAlarmEnable(pwm_timer);\n  }\n\n  // Find an existing slot for this pin\n  for (uint8_t i = 0; i < PWM_MAX_CHANNELS; i++) {\n    if (pwm_state[i].pin == pin) {\n      pwm_state[i].value = value;\n      return;\n    }\n  }\n\n  // No existing slot found, allocate a new one\n  for (uint8_t i = 0; i < PWM_MAX_CHANNELS; i++) {\n    if (pwm_state[i].pin == 0) {\n      pwm_state[i].pin = pin;\n      pwm_state[i].value = value;\n      pwm_count++;\n      return;\n    }\n  }\n}", "CodeBleu_score": 58.65098587147464}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin < 0) return; // Invalid pin\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n  // Software PWM\n  if (pin < 0) return; // Invalid pin\n  uint8_t slot = 0;\n  for (uint8_t i = 0; i < PWM_SLOT_NUM; i++) {\n    if (pwm_slot[i].pin == pin) {\n      slot = i;\n      break;\n    }\n  }\n  if (slot == 0) {\n    for (uint8_t i = 0; i < PWM_SLOT_NUM; i++) {\n      if (pwm_slot[i].pin == 0) {\n        slot = i;\n        break;\n      }\n    }\n  }\n  if (slot == 0) return; // No available PWM slots\n\n  // Set PWM parameters\n  pwm_slot[slot].pin = pin;\n  pwm_slot[slot].freq = freq;\n  pwm_slot[slot].res = res;\n  pwm_slot[slot].value = value;\n  pwm_slot[slot].timer = 0;\n  pwm_slot[slot].phase = 0;\n\n  // Start the timer if this is the first PWM pin used\n  if (pwm_count == 0) {\n    pwm_slot[slot].timer = timerBegin(0, 80, true);\n    timerAttachInterrupt(pwm_slot[slot].timer, &pwm_isr, true);\n    timerAlarmWrite(pwm_slot[slot].timer, 1000000 / freq, true);\n    timerAlarmEnable(pwm_", "CodeBleu_score": 61.51470671695813}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n\n  // Software PWM\n  if (pin < 1) return;\n\n  // Find existing slot\n  for (uint8_t i = 0; i < PWM_NUM_CHANNELS; i++) {\n    if (pwm_info[i].pin == pin) {\n      pwm_info[i].value = value;\n      return;\n    }\n  }\n\n  // Find a free slot\n  for (uint8_t i = 0; i < PWM_NUM_CHANNELS; i++) {\n    if (pwm_info[i].pin == 0) {\n      pwm_info[i].pin = pin;\n      pwm_info[i].value = value;\n      pwm_info[i].freq = freq;\n      pwm_info[i].res = res;\n      pwm_info[i].timer = 0;\n      return;\n    }\n  }\n}", "CodeBleu_score": 60.76604040418998}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(\n    sizeof(servo_delays) == NUM_SERVOS,\n    \"SERVO_DELAYS must be an array of NUM_SERVOS elements\"\n  );\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 54.36162929276147}, {"code": "void Servo::move(const int value){\n\tstatic_assert(\n    COUNT(servo_delay) == NUM_SERVOS,\n    \"SERVO_DELAY must be an array of NUM_SERVOS elements\"\n  );\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 60.383935207595684}, {"code": "void Servo::move(const int value){\n\tstatic_assert(\n    sizeof(servo_delays) / sizeof(servo_delays[0]) == NUM_SERVOS,\n    \"SERVO_DELAYS must be an array of NUM_SERVOS elements\"\n  );\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 59.4603338145789}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\tuint8_t i;\n    uint8_t pwm_pin_mask = 0;\n    uint8_t pwm_pin_mask_next = 0;\n    uint8_t pwm_pin_mask_prev = 0;\n    uint8_t pwm_pin_mask_next_prev = 0;\n    uint8_t pwm_pin_mask_prev_next = 0;\n    uint8_t pwm_pin_mask_next_next = 0;\n    uint8_t pwm_pin_mask_prev_prev = 0;\n    uint8_t pwm_pin_mask_prev_next_next = 0;\n\n    // Check if any PWM pins are active\n    for (i = 0; i < NUM_PWM_PINS; i++) {\n        if (pwm_pin_duty_cycles[i] > 0) {\n            pwm_pin_mask |= 1 << i;\n        }\n    }\n\n    // If there are active PWM pins, update the PWM states for each pin\n    if (pwm_pin_mask > 0) {\n        // Check if any PWM pins are active in the next cycle\n        for (i = 0; i < NUM_PWM_PINS; i++) {\n            if (pwm_pin_duty_cycles[i] > 0 && pwm_pin_duty_cycle_ticks[i] == 0) {\n                pwm_pin_mask_next |= 1 << i;\n            }\n        }\n\n        // If any PWM pins are active in the next cycle, update the PWM states for each pin\n        if (pwm_pin_mask_next > 0) {\n            // Check if any PWM pins are active in the previous cycle\n            for (i = 0; i < NUM_PWM_PINS; i++) {\n                if (pwm_pin_duty_cycles[i] > 0 && pwm_pin_duty_cycle", "CodeBleu_score": 36.152917861088554}, {"code": "void i2s_push_sample(){\n\tuint8_t i;\n  for (i = 0; i < NUM_PINS; i++) {\n    if (pins[i].duty_cycle) {\n      if (pins[i].tick_count == 0) {\n        pins[i].tick_count = pins[i].duty_cycle;\n        pins[i].state = !pins[i].state;\n      }\n      pins[i].tick_count--;\n      port_data[i] = pins[i].state;\n    } else {\n      port_data[i] = 0;\n    }\n  }\n  i2s_write_buffer(I2S_NUM, &port_data[0], 1, &bytes_written, 1000 / portTICK_RATE_MS);\n}", "CodeBleu_score": 34.98927546739331}, {"code": "void i2s_push_sample(){\n\tuint32_t i;\n    for (i = 0; i < NUM_PINS; i++) {\n        if (pwm_ticks[i] == 0) {\n            if (pins[i].state == LOW) {\n                pins[i].state = HIGH;\n            } else {\n                pins[i].state = LOW;\n            }\n            pwm_ticks[i] = pwm_period[i];\n        }\n        pwm_ticks[i]--;\n        i2s_buffer[i2s_buffer_pos] = pins[i].state;\n        i2s_buffer_pos++;\n    }\n}", "CodeBleu_score": 32.96797462843998}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t counter_value = 0;\n    timer_config_t *config = NULL;\n\n    if (timer_num >= HAL_TIMER_MAX) {\n        return 0;\n    }\n\n    config = &g_timer_config[timer_num];\n    if (config->timer_type == HAL_TIMER_TYPE_FREE_RUNNING) {\n        counter_value = timer_get_counter_value(config->timer_group, config->timer_idx);\n    }\n    return counter_value;\n}", "CodeBleu_score": 49.49611746274146}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t timer_count;\n    uint32_t timer_count_value;\n\n    if (timer_num == 0) {\n        timer_count_value = TIMER0->CNT;\n    } else if (timer_num == 1) {\n        timer_count_value = TIMER1->CNT;\n    } else if (timer_num == 2) {\n        timer_count_value = TIMER2->CNT;\n    } else if (timer_num == 3) {\n        timer_count_value = TIMER3->CNT;\n    } else {\n        timer_count_value = 0;\n    }\n\n    timer_count = timer_count_value;\n\n    return timer_count;\n}", "CodeBleu_score": 42.57900688360242}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t count;\n\n  if (timer_num >= HAL_TIMER_MAX) {\n    return 0;\n  }\n\n  count = timer_get_counter_value(timer_num);\n\n  return count;\n}", "CodeBleu_score": 35.40252659652858}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t c;\n  LOOP_L_N(i, size) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 52.76722237152593}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tdo {\n    uint8_t c;\n    if (eeprom_is_ready()) {\n      c = eeprom_read_byte((uint8_t*)pos);\n      if (writing) *value = c;\n      crc16(crc, &c, 1);\n      pos++;\n    }\n    else\n      return true;\n  } while (--size);\n  return false;\n}", "CodeBleu_score": 48.38134619150873}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t c;\n  for (size_t i = 0; i < size; i++) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 74.6635195347735}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tuint32_t status;\n    uint32_t retryCount;\n    uint32_t retryMax = 10;\n\n    CORE_ASSERT(handle != NULL);\n    CORE_ASSERT(src != NULL);\n\n    // Try to write the block\n    status = SDCARD_WriteBlocks(handle, src, block, 1);\n\n    // Retry if the write failed\n    for (retryCount = 0; (status != kStatus_Success) && (retryCount < retryMax); retryCount++) {\n        status = SDCARD_WriteBlocks(handle, src, block, 1);\n    }\n\n    // If the write operation was successful, return \"true\"\n    if (status == kStatus_Success) {\n        return true;\n    }\n\n    // If all retries failed, print an error message and return \"false\"\n    else {\n        printf(\"Failed to write block %lu\n\", block);\n        return false;\n    }\n}", "CodeBleu_score": 46.10735068399802}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (sdio_handle == NULL || src == NULL) {\n        printf(\"SDIO_WriteBlock: Invalid handle or source pointer.\n\");\n        return false;\n    }\n\n    /* Attempt to write the block. */\n    WITH_RETRY(SDCARD_WriteBlocks(sdio_handle, src, block, 1));\n\n    return true;\n}", "CodeBleu_score": 26.477877481251372}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(SDIO_Handle != NULL);\n    CORE_ASSERT(src != NULL);\n\n    uint32_t status;\n\n    WITH_RETRY(status = SDCARD_WriteBlocks(SDIO_Handle, src, block, 1)) {\n        if (status == kStatus_Success) {\n            return true;\n        }\n        else {\n            printf(\"Error: Failed to write block %lu. Status: 0x%08lX\n\", block, status);\n            return false;\n        }\n    }\n}", "CodeBleu_score": 38.20610255855657}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tCORE_DEBUG_PRINTF(\"HAL_timer_start(timer_num=%d, frequency=%d)\n\", timer_num, frequency);\n  CORE_ASSERT(timer_num < TIMER_CHANNEL_COUNT);\n\n  if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n    // Set the temperature timer prescale\n    timer_num->setPrescale(TEMPERATURE_TIMER_PRESCALE);\n\n    // Set the temperature timer callback priority\n    timer_num->setCallbackPriority(TEMPERATURE_TIMER_CALLBACK_PRIORITY);\n  }\n  else if (timer_num == TIMER_CHANNEL_STEPPER) {\n    // Set the stepper timer prescale\n    timer_num->setPrescale(STEPPER_TIMER_PRESCALE);\n\n    // Set the stepper timer callback priority\n    timer_num->setCallbackPriority(STEPPER_TIMER_CALLBACK_PRIORITY);\n  }\n  else {\n    // If the timer channel is invalid, trigger an assertion failure\n    CORE_ASSERT_FAIL();\n  }\n\n  // Start the timer with the given frequency\n  timer_num->start(frequency);\n}", "CodeBleu_score": 49.291379771615325}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tCORE_DEBUG_PRINTF(\"HAL_timer_start(timer_num=%d, frequency=%d)\n\", timer_num, frequency);\n  CORE_ASSERT_FAIL(timer_num >= 0 && timer_num <= 3);\n\n  switch (timer_num) {\n    case TEMP_TIMER:\n      timer_num->setCallbackPriority(TEMP_TIMER_PRIORITY);\n      timer_num->setFrequency(frequency, TEMP_TIMER_PRESCALE);\n      timer_num->start();\n      break;\n    case STEP_TIMER:\n      timer_num->setCallbackPriority(STEP_TIMER_PRIORITY);\n      timer_num->setFrequency(frequency, STEP_TIMER_PRESCALE);\n      timer_num->start();\n      break;\n    default:\n      CORE_ASSERT_FAIL(false);\n      break;\n  }\n}", "CodeBleu_score": 49.812736493568025}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tCORE_DEBUG_ASSERT(timer_num < TIMER_CHANNELS);\n    CORE_DEBUG_ASSERT(frequency > 0);\n    CORE_DEBUG_ASSERT(frequency < 1000000);\n    CORE_DEBUG_ASSERT(frequency <= F_CPU / 1000);\n\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n        timer_num->setOverflow(F_CPU / (TEMPERATURE_TIMER_PRESCALE * frequency));\n    } else if (timer_num == TIMER_CHANNEL_STEPPER) {\n        timer_num->setCallbackPriority(TIMER_CALLBACK_PRIORITY_STEPPER);\n        timer_num->setOverflow(F_CPU / (STEPPER_TIMER_PRESCALE * frequency));\n    } else {\n        CORE_ASSERT_FAIL();\n    }\n\n    timer_num->start();\n}", "CodeBleu_score": 54.52636410495371}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tconst char * const fname = \"eeprom.dat\";\n  const int erase_value = 0xFF;\n  const int eeprom_size = E2END + 1;\n\n  if (eeprom_file) return true;\n\n  eeprom_file = fopen(fname, \"rb\");\n  if (!eeprom_file) return false;\n\n  size_t size = fread(eeprom_buffer, 1, eeprom_size, eeprom_file);\n  if (size < eeprom_size) {\n    memset(eeprom_buffer + size, erase_value, eeprom_size - size);\n    size = eeprom_size;\n  }\n  fclose(eeprom_file);\n  eeprom_file = NULL;\n  return true;\n}", "CodeBleu_score": 50.173652591803084}, {"code": "bool PersistentStore::access_start(){\n\tif (!file) {\n    file = fopen(filename, \"rb\");\n    if (!file) return false;\n  }\n  fseek(file, 0, SEEK_END);\n  const uint32_t flen = ftell(file);\n  if (flen < EEPROM_OFFSET + sizeof(eeprom)) {\n    fclose(file);\n    file = fopen(filename, \"wb\");\n    if (!file) return false;\n    fseek(file, EEPROM_OFFSET, SEEK_SET);\n    fwrite(eeprom, sizeof(eeprom), 1, file);\n    fclose(file);\n    file = fopen(filename, \"rb\");\n    if (!file) return false;\n  }\n  fseek(file, EEPROM_OFFSET, SEEK_SET);\n  fread(eeprom, sizeof(eeprom), 1, file);\n  return true;\n}", "CodeBleu_score": 47.727404377725755}, {"code": "bool PersistentStore::access_start(){\n\tchar * const p = (char *)data;\n  const size_t size = sizeof(data);\n  if (eeprom_file) fclose(eeprom_file);\n  eeprom_file = fopen(eeprom_filename, \"rb\");\n  if (!eeprom_file) return false;\n  if (fread(p, size, 1, eeprom_file) != 1) {\n    fclose(eeprom_file);\n    eeprom_file = NULL;\n    return false;\n  }\n  const size_t file_size = ftell(eeprom_file);\n  if (file_size < size) {\n    memset(p + file_size, 255, size - file_size);\n  }\n  fclose(eeprom_file);\n  eeprom_file = NULL;\n  return true;\n}", "CodeBleu_score": 53.678180671745594}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tuint8_t i = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tdelaySPIFunc();\n\t\tHAL_SPI_STM32_SpiWrite_Mode_3(b & 0x80);\n\t\tr = r << 1;\n\t\tr |= HAL_SPI_STM32_SpiRead_Mode_3();\n\t\tb = b << 1;\n\t}\n\treturn r;\n}", "CodeBleu_score": 31.837235489879323}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t bit;\n    uint8_t byte = 0;\n\n    // Loop through each bit in the byte\n    for (bit = 0; bit < 8; bit++) {\n        // Set clock low\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\n        // Check the most significant bit\n        if (b & 0x80) {\n            // Set MOSI high\n            HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n        } else {\n            // Set MOSI low\n            HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n        }\n\n        // Toggle the clock high\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\n        // Read the bit from MISO\n        if (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n            byte |= 0x01;\n        }\n\n        // Shift the byte left\n        byte <<= 1;\n\n        // Toggle the clock low\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n    }\n\n    // Introduce a small delay\n    delaySPIFunc();\n\n    // Return the received byte\n    return byte;\n}", "CodeBleu_score": 40.497460917674445}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t i, j;\n  uint8_t ret = 0;\n  for (i = 0; i < 8; i++) {\n    // Set clock pin low\n    HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n    // Write most significant bit to MOSI pin\n    if ((b & 0x80) == 0x80) {\n      HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n    } else {\n      HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n    }\n    // Toggle clock pin high\n    HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n    // Read bit from MISO pin\n    if (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n      ret |= 1;\n    }\n    // Shift byte left\n    ret <<= 1;\n    // Toggle clock pin low\n    HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n  }\n  // Delay to allow for clock signal to settle\n  delaySPIFunc(SPI_DELAY_NS);\n  return ret;\n}", "CodeBleu_score": 37.55295520140861}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  if (NewState != DISABLE) {\n    /* Enable the selected AHB peripheral clock */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    /* Disable the selected AHB peripheral clock */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 79.77090318797755}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 79.90054709524316}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 79.77090318797755}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = serial_getc(obj);\n  if (c == _EMPTY_CHAR) {\n    // ignore parity errors\n    return;\n  }\n\n  if (rx_buffer.head == rx_buffer.tail) {\n    // error: receive buffer is full\n    return;\n  }\n\n  rx_buffer.buffer[rx_buffer.head] = c;\n  rx_buffer.head = (rx_buffer.head + 1) % RX_BUFFER_SIZE;\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n}", "CodeBleu_score": 39.429371616269684}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = uart_getc(obj);\n  if (c == _DC1) {\n    // emergency stop\n    emergency_parser.update(c);\n    if (emergency_parser.is_detected()) {\n      SERIAL_ERROR_START();\n      SERIAL_ECHOLNPGM(\"Emergency stop!\");\n      kill(HAL_kill_reason_t::KILL_EMERGENCY_PARSER);\n    }\n  }\n  else if (c == _DCS) {\n    // command successful\n    SERIAL_ECHOPGM(\"ok", "CodeBleu_score": 31.229810548250946}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tconst uint8_t c = serial_getc(obj);\n\n  // If the byte received isn't the XON/XOFF character,\n  // update the emergency parser\n  if (emergency_parser.enabled && c != XON_CHAR && c != XOFF_CHAR)\n    emergency_parser.update(c);\n\n  // If no parity error has occurred...\n  if (!serial_get_parity_error(obj)) {\n    // ...get the head index\n    uint8_t i = rx_buffer_head;\n\n    // Increment the head index\n    rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\n    // If the head index has not been updated, there is no space in the buffer\n    if (rx_buffer_head == i) return;\n\n    // Store the new index\n    rx_buffer[i] = c;\n\n    // Call the user-defined callback\n    if (rx_buffer_callback) rx_buffer_callback(c);\n  }\n}", "CodeBleu_score": 35.764843567087546}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num]->hasInterrupt) return;\n\tif (!HAL_timer_initialized(timer_num)) return;\n\ttimer_instance[timer_num]->attachInterrupt(timer_instance[timer_num]->getHandle(), timer_instance[timer_num]->getHandle());\n\ttimer_instance[timer_num]->hasInterrupt = true;\n}", "CodeBleu_score": 51.099337452890545}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_instance[timer_num] != NULL) {\n        if (!timer_instance[timer_num]->hasInterrupt()) {\n            if (timer_num == MF_TIMER_STEP) {\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n            }\n            else if (timer_num == MF_TIMER_TEMP) {\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n            }\n        }\n    }\n}", "CodeBleu_score": 59.82249863767949}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t// Check if the timer is initialized and lacks an interrupt\n  if (timer_instance[timer_num]->hasInterrupt() == false) {\n\n    // Attach the appropriate interrupt handler\n    if (timer_num == MF_TIMER_STEP) {\n      timer_instance[timer_num]->attachInterrupt(Step_Handler);\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n      timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n    }\n  }\n}", "CodeBleu_score": 59.25861836589611}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tvar hash, pow uint32\n\thash, pow = HashStrRev(sep)\n\tvar n = len(s)\n\tvar h uint32\n\tfor i := n - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t\tif i < n-len(sep) {\n\t\t\th -= pow * uint32(s[i+len(sep)])\n\t\t}\n\t\tif h == hash && Equal(s[i-len(sep)+1:i+1], sep) {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.48147756268936}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\thashSep, pow := HashStrRev[T](sep)\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\thash := uint32(0)\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(s[i])\n\t\tif i < len(sep) - 1 {\n\t\t\tcontinue\n\t\t}\n\t\tif hash == hashSep && Equal(s[i-len(sep)+1:i+1], sep) {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t\thash -= pow * uint32(s[i-len(sep)+1])\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.87552787635455}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\th := uint32(0)\n\tfor i := len(s) - 1; i >= len(sep); i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t\th -= pow * uint32(s[i-len(sep)])\n\t\tif h == hash && Equal(s[i-len(sep)+1:i+1], sep) {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 43.984703055961}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable\nif usbcdc.txBuffer.Get() {\nusbcdc.SendUSBInPacket\n} else {\nusbcdc.waitTxc = false\n}\ninterrupt.Restore\n}", "CodeBleu_score": 40.549894903591735}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.185294207890394}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore(interrupt.Global)\n}", "CodeBleu_score": 48.82653934706925}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag\n\ti2c.crReg.Set(i2c.base, I2C_CR_IF_Msk)\n\t// Send a start condition\n\ti2c.crReg.Set(i2c.base, I2C_CR_STA_Msk)\n\t// Wait for the start condition to be transmitted\n\tfor i2c.crReg.HasBits(i2c.base, I2C_CR_IF_Msk) == 0 {\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus\n\ti2c.writeByte(address<<1 | uint8(b2i(write)))\n}", "CodeBleu_score": 39.45749097923862}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.Set(i2c.base, I2C_CR_START | I2C_CR_STOP)\n\ti2c.crReg.ClearBits(i2c.base, I2C_CR_INTEN)\n\ti2c.crReg.Set(i2c.base, I2C_CR_INTEN)\n\ti2c.crReg.Set(i2c.base, I2C_CR_START)\n\tfor !i2c.crReg.HasBits(i2c.base, I2C_CR_START) {\n\t}\n\ti2c.writeByte(address << 1)\n\ti2c.writeByte(0)\n}", "CodeBleu_score": 34.077522013942385}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.Set(i2c.crReg.Clear(I2C_CR_IF))\n\ti2c.crReg.Set(I2C_CR_STA)\n\n\tfor !i2c.crReg.HasBits(I2C_CR_IF) {\n\t}\n\n\ti2c.writeByte(address << 1 | (1 - uint32(write)))\n}", "CodeBleu_score": 34.921117545937804}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif len <= 0 {\n\t\treturn nil\n\t}\n\tif start+len > f.BlockCount() {\n\t\treturn errors.New(\"start + len out of range\")\n\t}\n\tif start < 0 {\n\t\treturn errors.New(\"start out of range\")\n\t}\n\tif len < 0 {\n\t\treturn errors.New(\"len out of range\")\n\t}\n\tif f.EraseBlockSize() == 0 {\n\t\treturn errors.New(\"erase block size is 0\")\n\t}\n\tif f.EraseBlockSize() > f.BlockSize() {\n\t\treturn errors.New(\"erase block size is larger than block size\")\n\t}\n\tif f.EraseBlockSize()%f.BlockSize() != 0 {\n\t\treturn errors.New(\"erase block size is not a multiple of block size\")\n\t}\n\tif f.EraseBlockSize()%f.ProgramPageSize() != 0 {\n\t\treturn errors.New(\"erase block size is not a multiple of program page size\")\n\t}\n\tif f.EraseBlockSize()%f.EraseBlockSize() != 0 {\n\t\treturn errors.New(\"erase block size is not a multiple of erase block size\")\n\t}\n\tif f.ProgramPageSize() == 0 {\n\t\treturn errors.New(\"program page size is 0\")\n\t}\n\tif f.ProgramPageSize() > f.BlockSize() {\n\t\treturn errors.New(\"program page size is larger than block size\")\n\t}\n\tif f.ProgramPageSize()%f.BlockSize() != 0 {\n\t\treturn errors.New(\"program page size is not a multiple of block size\")\n\t}\n\tif f.ProgramPageSize()%f.ProgramPageSize() != 0 {\n\t\treturn errors.New(\"program page size is not a multiple of program page size\")\n\t}\n\tif f.ProgramPageSize()%f.EraseBlockSize() != 0 {\n\t\treturn errors.New(\"program page size is not a multiple of erase block size\")\n\t}\n\tif f.BlockSize() == 0 {\n\t\treturn", "CodeBleu_score": 20.138254019983197}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || len <= 0 || start+len > int64(f.BlockCount()) {\n\t\treturn errors.New(\"invalid parameters\")\n\t}\n\n\tvar err error\n\n\t// Calculate the start address.\n\taddr := f.BlockStartAddress(start)\n\n\t// Configure the flash for erasing.\n\tnrf.NVMC.SetCONFIG_WEN()\n\twaitWhileFlashBusy()\n\tnrf.NVMC.SetCONFIG_EEN()\n\twaitWhileFlashBusy()\n\n\t// Erase the blocks.\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(addr))\n\t\twaitWhileFlashBusy()\n\t\taddr += int64(f.EraseBlockSize())\n\t}\n\n\t// Set the flash back to read mode.\n\tnrf.NVMC.SetCONFIG_WEN()\n\twaitWhileFlashBusy()\n\n\treturn err\n}", "CodeBleu_score": 49.41721469967958}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif f.EraseBlockSize() == 0 {\n\t\treturn errors.New(\"EraseBlockSize is zero\")\n\t}\n\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"negative values\")\n\t}\n\tif start+len > int64(f.Size()) {\n\t\treturn errors.New(\"out of range\")\n\t}\n\tif start&(f.EraseBlockSize()-1) != 0 {\n\t\treturn errors.New(\"unaligned start\")\n\t}\n\tif len&(f.EraseBlockSize()-1) != 0 {\n\t\treturn errors.New(\"unaligned length\")\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tnrf.NVMC.ERASEPAGE.Set\n\tfor i := int64(0); i < len; i += f.EraseBlockSize() {\n\t\twaitWhileFlashBusy\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\treturn nil\n}", "CodeBleu_score": 41.59254808986856}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off >= int64(f.Size) {\n\t\treturn 0, errors.New(\"WriteAt: offset out of range\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > int64(f.Size) {\n\t\treturn 0, errors.New(\"WriteAt: length out of range\")\n\t}\n\tif off%int64(f.WriteBlockSize) != 0 {\n\t\treturn 0, errors.New(\"WriteAt: offset must be aligned to a write block size\")\n\t}\n\tif len(p)%f.WriteBlockSize != 0 {\n\t\treturn 0, errors.New(\"WriteAt: length must be aligned to a write block size\")\n\t}\n\tn = len(p)\n\tp = f.pad(p, f.WriteBlockSize)\n\tstart := int(off / int64(f.WriteBlockSize))\n\tend := start + len(p)/f.WriteBlockSize\n\tfor i := start; i < end; i++ {\n\t\tnrf.NVMC.SetCONFIG_WEN()\n\t\tbinary.LittleEndian.PutUint32(f.flash[i*f.WriteBlockSize:], *(*uint32)(unsafe.Pointer(&p[i*f.WriteBlockSize])))\n\t\twaitWhileFlashBusy()\n\t}\n\treturn\n}", "CodeBleu_score": 31.897778088725286}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Check if write operation exceeds the flash memory bounds.\n\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, errors.New(\"write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\taddr := f.BaseAddr + uintptr(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tp = padByteSlice(p, f.WriteBlockSize)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN()\n\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Write the block.\n\t\tbinary.LittleEndian.PutUint32((*uint32)(unsafe.Pointer(addr)), uint32(p[0]))\n\t\taddr += 4\n\t\tp = p[4:]\n\n\t\t// Wait for the flash memory to be ready.\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 32.15120560487472}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, io.EOF\n\t}\n\n\tif f.pad != 0 {\n\t\tp = pad(p, f.pad)\n\t}\n\n\tnrf.NVMC.SetCONFIG_WEN()\n\tstart := f.addr + uintptr(off)\n\tfor len(p) > 0 {\n\t\tblock := p\n\t\tif len(block) > f.WriteBlockSize {\n\t\t\tblock = block[:f.WriteBlockSize]\n\t\t}\n\t\tnrf.NVMC.SetCONFIG_WEN()\n\t\tfor i := 0; i < len(block); i += 4 {\n\t\t\t*(*uint32)(unsafe.Pointer(start + uintptr(i))) = binary.LittleEndian.Uint32(*(*uint32)(unsafe.Pointer(&block[i])))\n\t\t}\n\t\tnrf.NVMC.SetCONFIG_WEN()\n\t\twaitWhileFlashBusy()\n\t\tp = p[len(block):]\n\t\tstart += uintptr(len(block))\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 39.44855290687297}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Open the directory.\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 79.68262971112318}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tvar err error\n\tvar dir *syscall.Dir\n\tvar dupfd syscallFd\n\tvar errno syscall.Errno\n\tvar errmsg string\n\n\t// Duplicate the file descriptor.\n\tdupfd, err = syscall.Dup(fd)\n\tif err != nil {\n\t\terrno = err.(syscall.Errno)\n\t\terrmsg = fmt.Sprintf(\"dup error: %s\", errno.Error())\n\t\treturn 0, errmsg, err\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err != nil {\n\t\t\terrno = err.(syscall.Errno)\n\t\t\tif errno != syscall.EINTR {\n\t\t\t\terrmsg = fmt.Sprintf(\"fdopendir error: %s\", errno.Error())\n\t\t\t\tsyscall.Close(dupfd)\n\t\t\t\treturn 0, errmsg, err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 43.247152475240306}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// First, duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Then, repeatedly attempt to open the directory using \"syscall.Fdopendir\" until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\t// If an error occurs, it closes the duplicated file descriptor and returns the error message; otherwise, it returns the directory pointer with no error.\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 74.32247082768653}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tesp_image_header_t image_header;\n  esp_partition_t *running_partition = esp_ota_get_running_partition();\n  if (!running_partition) {\n    return 0;\n  }\n  if (esp_ota_get_partition_description(running_partition, &image_header) != ESP_OK) {\n    return 0;\n  }\n  if (response == FREE_SKETCH_SPACE) {\n    return running_partition->size - image_header.image_size;\n  }\n  return image_header.image_size;\n}", "CodeBleu_score": 46.67676338190535}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tesp_image_header_t fhdr;\n  const esp_partition_t* part;\n  part = esp_ota_get_running_partition();\n  if (part == NULL) {\n    return 0;\n  }\n  if (esp_ota_get_partition_description(part, &fhdr) != ESP_OK) {\n    return 0;\n  }\n  if (response == FREE_SKETCH_SPACE) {\n    return part->size - (fhdr.image.data_len + fhdr.image.header_len);\n  } else {\n    return fhdr.image.data_len + fhdr.image.header_len;\n  }\n}", "CodeBleu_score": 46.47494489142263}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tesp_image_header_t fhdr;\n  const esp_partition_t *part = esp_ota_get_running_partition();\n  if (part == NULL) {\n    return 0;\n  }\n  if (part->type != ESP_PARTITION_TYPE_APP) {\n    return 0;\n  }\n  if (esp_ota_get_partition_description(part, &fhdr) == ESP_OK) {\n    if (response == true) {\n      return part->size - (fhdr.image.data_len + fhdr.image.header_len);\n    } else {\n      return fhdr.image.data_len + fhdr.image.header_len;\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 47.996371038121936}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    log_e(\"Failed to calculate total sectors\");\n    return false;\n  }\n  msc_disk = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk) {\n    log_e(\"Failed to allocate RAM disk\");\n    return false;\n  }\n  log_d(\"Allocated %uKB RAM disk\", (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  fat_file_system_type fs_type = mcs_is_fat16 ? FAT_TYPE_16 : FAT_TYPE_12;\n  fat_add_boot_sector(msc_disk, DISK_SECTOR_SIZE, total_sectors, fs_type, volume_label, serial_number);\n  fat_add_table(msc_disk, DISK_SECTOR_SIZE, total_sectors, fs_type, msc_table_sectors);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk, DISK_SECTOR_SIZE, total_sectors, fs_type, msc_table_sectors, \"firmware.bin\", fw_size);\n  }\n  return true;\n}", "CodeBleu_score": 44.76393280512486}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    log_e(\"Failed to calculate required disk sectors\");\n    return false;\n  }\n  msc_disk_size = total_sectors * DISK_SECTOR_SIZE;\n  msc_disk = calloc(msc_disk_size, 1);\n  if (msc_disk == NULL) {\n    log_e(\"Failed to allocate memory for disk\");\n    return false;\n  }\n  fat_file_system_type fs_type = mcs_is_fat16 ? FAT_TYPE_16 : FAT_TYPE_12;\n  if (!fat_add_boot_sector(msc_disk, msc_disk_size, fs_type, volume_label, serial_number, 0)) {\n    log_e(\"Failed to add boot sector\");\n    return false;\n  }\n  if (!fat_add_table(msc_disk, msc_disk_size, fs_type, total_sectors, msc_table_sectors, 0)) {\n    log_e(\"Failed to add file allocation table\");\n    return false;\n  }\n  if (msc_run_partition) {\n    if (!fat_add_root_file(msc_disk, msc_disk_size, fs_type, msc_run_partition->label, fw_size, 0)) {\n      log_e(\"Failed to add root file\");\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 40.48487071103112}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tuint32_t total_sectors = msc_update_get_required_disk_sectors();\n  uint32_t data_sectors = total_sectors - msc_table_sectors - 2;\n  if (total_sectors == 0) {\n    log_e(\"No partition found. Cannot setup disk\");\n    return false;\n  }\n  if (total_sectors > 0xFF4) {\n    log_e(\"Disk size too large. Cannot setup disk\");\n    return false;\n  }\n  msc_disk = calloc(1, total_sectors * DISK_SECTOR_SIZE);\n  if (msc_disk == NULL) {\n    log_e(\"Cannot allocate memory for disk\");\n    return false;\n  }\n  fat_file_system_type fs_type = mcs_is_fat16 ? fat_file_system_type_fat16 : fat_file_system_type_fat12;\n  fat_add_boot_sector(msc_disk, fs_type, volume_label, serial_number, data_sectors, msc_table_sectors);\n  fat_add_table(msc_disk, fs_type, data_sectors, msc_table_sectors);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk, fs_type, msc_run_partition->label, msc_run_partition->address, fw_size);\n  }\n  return true;\n}", "CodeBleu_score": 41.12622305463029}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase partition %d\", err);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write partition %d\", err);\n        return err;\n    }\n    return err;\n}", "CodeBleu_score": 65.43095684710639}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed at 0x%x\", offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Write failed at 0x%x\", offset);\n    }\n    return err;\n}", "CodeBleu_score": 63.78982619941205}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err = ESP_OK;\n    uint32_t start_addr = partition->address + offset;\n    uint32_t sector_size = (uint32_t)esp_partition_get_sector_size(partition);\n    uint32_t sector_start = start_addr / sector_size * sector_size;\n    uint32_t sector_end = sector_start + sector_size;\n    uint32_t aligned_start = start_addr;\n    uint32_t aligned_end = start_addr + size;\n    uint32_t aligned_size = size;\n    uint32_t write_size = 0;\n    uint32_t write_offset = 0;\n    uint32_t erase_size = 0;\n    uint32_t erase_offset = 0;\n    uint32_t erase_start = 0;\n    uint32_t erase_end = 0;\n\n    if (offset % sector_size != 0) {\n        ESP_LOGE(TAG, \"Write offset is not aligned with sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (start_addr % sector_size != 0) {\n        ESP_LOGE(TAG, \"Write start address is not aligned with sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (size % sector_size != 0) {\n        ESP_LOGE(TAG, \"Write size is not aligned with sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (start_addr < sector_start || start_addr >= sector_end) {\n        ESP_LOGE(TAG, \"Write start address is not aligned with sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (aligned_end > sector_end) {\n        aligned_end = sector_end;\n    }\n\n    if (aligned_end > aligned_start) {\n        erase_start = aligned_start;\n        erase_end = aligned_end;\n        er", "CodeBleu_score": 40.09773222527573}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  while (*in && len < maxlen) {\n    uint8_t h = hex_char_to_byte(*in++);\n    if (h == 0x10) {\n      // skip non-hexadecimal character\n      continue;\n    }\n    uint8_t l = hex_char_to_byte(*in++);\n    if (l == 0x10) {\n      // skip non-hexadecimal character\n      continue;\n    }\n    *out++ = (h << 4) | l;\n    len++;\n  }\n  return len;\n}", "CodeBleu_score": 45.68908677780873}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n  while (in[i] != 0 && j < maxlen) {\n    uint8_t c = hex_char_to_byte(in[i]);\n    if (c < 0x10) {\n      if (i + 1 < strlen(in)) {\n        c = (c << 4) | hex_char_to_byte(in[i + 1]);\n        i++;\n      }\n      out[j] = c;\n      j++;\n    }\n    i++;\n  }\n  return j;\n}", "CodeBleu_score": 49.653359035820785}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  while (*in && len < maxlen) {\n    uint8_t h = hex_char_to_byte(*in++);\n    if (h > 0x0f) {\n      continue;\n    }\n    uint8_t l = hex_char_to_byte(*in++);\n    if (l > 0x0f) {\n      continue;\n    }\n    out[len++] = (h << 4) | l;\n  }\n  return len;\n}", "CodeBleu_score": 44.97695840560634}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tint ret;\n\n\tif (!m_tx_ring_buffer || !m_tx_ring_buffer_lock) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(m_tx_ring_buffer_lock, 100) == pdTRUE) {\n\t\tret = xRingbufferGetCurFreeSize(m_tx_ring_buffer);\n\t\txSemaphoreGive(m_tx_ring_buffer_lock);\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 49.43532065375963}, {"code": "int HWCDC::availableForWrite(void){\n\tint size = 0;\n\tif (m_ringBuffer && m_ringBufferLock) {\n\t\tif (xSemaphoreTake(m_ringBufferLock, 1000) == pdTRUE) {\n\t\t\tsize = xRingbufferGetCurFreeSize(m_ringBuffer);\n\t\t\txSemaphoreGive(m_ringBufferLock);\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 41.03435091452747}, {"code": "int HWCDC::availableForWrite(void){\n\tint ret = 0;\n\n\tif (m_pTxRingBuf == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(m_pTxRingBuf->m_pMutex, 1000) == pdTRUE) {\n\t\tret = xRingbufferGetCurFreeSize(m_pTxRingBuf->m_pRingBuf);\n\t\txSemaphoreGive(m_pTxRingBuf->m_pMutex);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 45.19368325331303}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t// Locking the serial mutex\n  HSERIAL_MUTEX_LOCK\n\n  // Assigning the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n\n  // Configuring the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    // If the \"onlyOnTimeout\" is true, then the receive timeout behavior is set to \"only on timeout\"\n    uartSetRxFIFOFull(_uart_nr, 0);\n  } else {\n    // If the \"onlyOnTimeout\" is false, then the receive timeout behavior is set to \"on timeout and full\"\n    uartSetRxFIFOFull(_uart_nr, 1);\n  }\n\n  // If the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist\n  if (function != NULL) {\n    // Setting the FIFO full threshold\n    uartSetRxFIFOFullThresh(_uart_nr, _rx_buffer_size - 1);\n    // Creating an event task if it does not already exist\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n\n  // Unlocking the serial mutex\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 48.64504730939993}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uartSetRxFIFOFull(_uart_nr, _rx_buffer_size);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 39.763764499076245}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (_onReceiveCB) {\n    uartSetRxFIFOFull();\n    _createEventTask();\n  }\n  if (onlyOnTimeout) {\n    _rxTimeout = true;\n  } else {\n    _rxTimeout = false;\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 37.448029836130026}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (1) {\n    int c = timedRead();\n    if (c < 0 || c == terminator || index == length - 1) {\n      buffer[index] = 0;\n      return index;\n    }\n    buffer[index++] = (char)c;\n  }\n}", "CodeBleu_score": 74.97456878089663}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer = (char)c;\n    index++;\n    buffer++;\n  }\n  *buffer = 0;\n  return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 85.54644389024926}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  char *end = buffer + length - 1;\n  while (buffer < end) {\n    int c = timedRead();\n    *buffer = (char)c;\n    if (c < 0 || *buffer == terminator) {\n      break;\n    }\n    buffer++;\n  }\n  *buffer = 0;\n  return buffer - (char *)buffer;\n}", "CodeBleu_score": 65.18323120852638}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_e(\"Tone: %d, %d, %d\", pin, frequency, duration);\n  if (_tone_pin == 0) {\n    _tone_pin = pin;\n    tone_msg_t msg = {\n      .pin = pin,\n      .freq = frequency,\n      .duration = duration\n    };\n    if (xQueueSend(_tone_queue, &msg, 0) != pdPASS) {\n      log_e(\"Could not send tone message\");\n    }\n  } else {\n    if (_tone_pin != pin) {\n      log_e(\"Pin %d is in use\", _tone_pin);\n    } else {\n      log_e(\"Tone is already playing on pin %d\", _tone_pin);\n    }\n  }\n}", "CodeBleu_score": 58.431561304397675}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"Tone on pin %d, freq %d, duration %d\", pin, frequency, duration);\n  if (pin_in_use(pin)) {\n    log_e(\"Pin %d is in use\", pin);\n    return;\n  }\n  tone_init();\n  pin_set_mode(pin, OUTPUT);\n  pin_set_state(pin, LOW);\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.freq = frequency;\n  msg.duration = duration;\n  msg.cmd = TONE_CMD_START;\n  xQueueSend(_tone_queue, &msg, portMAX_DELAY);\n}", "CodeBleu_score": 47.16673565790997}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"Tone: pin=%d, freq=%d, duration=%d\", pin, frequency, duration);\n  if (pin == 0 || pin > 255) {\n    log_e(\"Invalid pin %d\", pin);\n    return;\n  }\n  if (frequency == 0) {\n    log_e(\"Invalid frequency %d\", frequency);\n    return;\n  }\n  if (duration == 0) {\n    log_e(\"Invalid duration %d\", duration);\n    return;\n  }\n  if (_tone_pin_in_use[pin]) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n  _tone_pin_in_use[pin] = true;\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.freq = frequency;\n  msg.duration = duration;\n  msg.cmd = TONE_CMD_START;\n  xQueueSend(_tone_queue, &msg, portMAX_DELAY);\n}", "CodeBleu_score": 50.72477623026606}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_usbStarted) {\n    _webUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (_usbVersion < 0x0210) {\n      _usbVersion = 0x0210;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 56.83711283519005}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (enabled) {\n    if (usb_version < 0x0210) {\n      usb_version = 0x0210;\n      ESPUSB::begin();\n    }\n    webusb_enabled = true;\n  } else {\n    webusb_enabled = false;\n  }\n  return !usb_started;\n}", "CodeBleu_score": 58.22510973517524}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_usbStarted) {\n    _webUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (_usbVersion < 0x0210) {\n      _usbVersion = 0x0210;\n      USBDevice.setVersion(_usbVersion);\n    }\n  }\n  USBDevice.setWebUSBEnabled(enabled);\n  return false;\n}", "CodeBleu_score": 52.83352473254676}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\tuint8_t buf[64];\n\tuint32_t len = tud_cdc_n_available(0);\n\tif (len > 0) {\n\t\tlen = tud_cdc_n_read(0, buf, len);\n\t\tif (len > 0) {\n\t\t\tuint32_t dropped = 0;\n\t\t\tfor (uint32_t i = 0; i < len; i++) {\n\t\t\t\tif (!xQueueSend(_rxQueue, &buf[i], 0)) {\n\t\t\t\t\tdropped++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dropped > 0) {\n\t\t\t\tlog_e(\"USBCDC: %d bytes dropped\", dropped);\n\t\t\t\tarduino_usb_event_post(USBCDC_EVENT_RX_OVERFLOW, dropped);\n\t\t\t}\n\t\t\tarduino_usb_event_post(USBCDC_EVENT_RX, len);\n\t\t}\n\t}\n}", "CodeBleu_score": 26.578565994326464}, {"code": "void USBCDC::_onRX(){\n\t// read available bytes\n  uint32_t count = tud_cdc_n_available(_usb_cdc_instance);\n\n  if (count > 0) {\n    // read bytes from USB CDC\n    uint8_t buf[count];\n    count = tud_cdc_n_read(_usb_cdc_instance, buf, count);\n\n    // write bytes to receive queue\n    for (uint32_t i = 0; i < count; i++) {\n      if (!xQueueSend(_rx_queue, &buf[i], 0)) {\n        // overflow\n        _overflow_count++;\n        log_e(\"Receive queue overflowed\");\n      }\n    }\n\n    // post receive event\n    if (count > 0) {\n      log_v(\"Received %u bytes\", count);\n      EventLoop::post(this, USBCDC_EVENT_RX, count);\n    }\n  }\n}", "CodeBleu_score": 32.199243303611674}, {"code": "void USBCDC::_onRX(){\n\t// read data\n    uint8_t buf[CDC_BUFSIZE];\n    uint32_t len = tud_cdc_n_read(_cdc_instance, buf, sizeof(buf));\n\n    // if there's no data, do nothing\n    if (len == 0) {\n        return;\n    }\n\n    // attempt to send each byte to the receive queue\n    for (uint32_t i = 0; i < len; i++) {\n        // if the queue is full, post an overflow event and log an error\n        if (xQueueSend(_rx_queue, &buf[i], 0) != pdPASS) {\n            log_e(\"Receive queue overflowed, dropping %u bytes\", len - i);\n            arduino_usb_event_post(USB_EVENT_CDC_RX_OVERFLOW, len - i);\n            break;\n        }\n    }\n\n    // if we made it to the end, post a receive event\n    arduino_usb_event_post(USB_EVENT_CDC_RX_COMPLETE, len);\n}", "CodeBleu_score": 29.84502561626683}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL path\n\trobotName := req.URL.Path[len(\"/robot/\"):]\n\n\t// Check if a robot with the given name exists\n\tvar robot *gobot.Robot\n\ta.master.Robots().Each(func(r *gobot.Robot) {\n\t\tif r.Name == robotName {\n\t\t\trobot = r\n\t\t}\n\t})\n\n\t// If a robot with the given name was found, return the JSON representation of its devices\n\tif robot != nil {\n\t\t// Gather the robot's devices into a JSON format\n\t\tvar devices []map[string]interface{}\n\t\trobot.Devices().Each(func(name string, device gobot.Device) {\n\t\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\t\"name\":   name,\n\t\t\t\t\"driver\": device.Driver().Name(),\n\t\t\t\t\"conn\":   device.Connection().Name(),\n\t\t\t})\n\t\t})\n\n\t\t// Write the JSON response\n\t\ta.writeJSON(res, devices)\n\t} else {\n\t\t// If no robot with the given name was found, return a JSON response with an error message\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t}\n}", "CodeBleu_score": 51.81044689757465}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tname := req.URL.Query().Get(\":robot\")\n\n\tvar robot *gobot.Robot\n\ta.master.Robots().Each(func(r *gobot.Robot) {\n\t\tif r.Name == name {\n\t\t\trobot = r\n\t\t}\n\t})\n\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\":\\\"No robot found with name %s\\\"}\", name)))\n\t\treturn\n\t}\n\n\tdevices := make([]map[string]interface{}, 0)\n\trobot.Devices().Each(func(device gobot.Device) {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\": device.Name(),\n\t\t\t\"type\": reflect.TypeOf(device).String(),\n\t\t})\n\t})\n\n\tres.WriteHeader(http.StatusOK)\n\ta.writeJSON(res, map[string]interface{}{\"devices\": devices})\n}", "CodeBleu_score": 49.482822411707176}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tname := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"no robot found with the specified name\"}`))\n\t\treturn\n\t}\n\n\tdevices := []map[string]interface{}{}\n\trobot.Devices().Each(func(name string, device gobot.Device) {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\": name,\n\t\t\t\"type\": reflect.TypeOf(device).Elem().Name(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 52.14439111997209}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"No robot with name \" + robotName + \" found.\"})\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, 0)\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":   c.Name(),\n\t\t\t\"type\":   c.Type(),\n\t\t\t\"driver\": c.Driver(),\n\t\t\t\"port\":   c.Port(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 51.871292592434834}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\tname := req.URL.Query().Get(\":name\")\n\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with name \" + name))\n\t\treturn\n\t}\n\n\tconnections := make([]*gobot.Connection, 0)\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c)\n\t})\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 46.898723500112524}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\tname := req.URL.Query().Get(\":name\")\n\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with the name %q was found\n\", name)\n\t\treturn\n\t}\n\n\tconnections := []interface{}{}\n\trobot.Connections().Each(func(name string, conn gobot.Connection) {\n\t\tconnections = append(connections, conn.Name())\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 51.02656025762784}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\tif req.Method != \"POST\" {\n\t\thttp.Error(res, \"POST method required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := req.ParseForm(); err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\tDevice(req.URL.Query().Get(\":device\")).(gobot.Commander), req.Form); err != nil {\n\t\ta.writeJSON(res, err.Error(), http.StatusBadRequest)\n\t}\n}", "CodeBleu_score": 57.41818809667314}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, 404, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, 404, map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(device, req.URL.Query().Get(\":command\")); err != nil {\n\t\ta.writeJSON(res, 400, map[string]string{\"error\": err.Error()})\n\t}\n}", "CodeBleu_score": 56.24404088397217}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\tif req.Method != \"POST\" {\n\t\tres.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif a.master.Robot(req.URL.Query().Get(\":robot\")).Device(req.URL.Query().Get(\":device\")) == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(req.URL.Query().Get(\":robot\"), req.URL.Query().Get(\":device\"), req.Body); err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t}\n}", "CodeBleu_score": 56.331888003891684}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\t// Proceed to handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.85011542411366}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Proceed to the next handler\n\t}\n}", "CodeBleu_score": 56.061426695235525}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 49.37551233907266}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.sensorCfg.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"AnalogSensorDriver: %s does not support analog reading\", a.sensorCfg.connection.Name())\n\t}\n\n\traw, err := a.sensorCfg.connection.AnalogRead(a.sensorCfg.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastReadTime = time.Now()\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.99360282415433}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection == nil || !a.Connection().AnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading is not supported on this connection\")\n\t}\n\n\traw, err := a.Pin.AnalogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRead = scaled\n\ta.lastRaw = raw\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.14211102690277}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRead = time.Now()\n\ta.lastValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.48548759240635}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\tconn: a,\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\td.name = option.(string)\n\t\tcase []int:\n\t\t\td.calibration = option.([]int)\n\t\t}\n\t}\n\n\td.mutex = &sync.Mutex{}\n\n\treturn d\n}", "CodeBleu_score": 37.90652689119292}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector: &gobot.AnalogConnector{\n\t\t\tAnalogReader: a,\n\t\t},\n\t\tpin: pin,\n\t\tinterval: time.Millisecond * 10,\n\t\tmutex: &sync.Mutex{},\n\t}\n\n\tfor _, option := range opts {\n\t\tif o, ok := option.(gobot.Option); ok {\n\t\t\to(d)\n\t\t}\n\t}\n\n\td.AddEvent(SoundEvent)\n\n\treturn d\n}", "CodeBleu_score": 37.32762976768577}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tg := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector: &gobot.DigitalReader{\n\t\t\tname: \"GroveSoundSensor\",\n\t\t\tpin:  pin,\n\t\t\tsysfs: a,\n\t\t},\n\t\tcurrentValue: 0,\n\t\tvalue:        0,\n\t}\n\n\tg.AddEvent(SoundEvent)\n\n\tfor _, option := range opts {\n\t\tif s, ok := option.(string); ok {\n\t\t\tg.name = s\n\t\t}\n\t}\n\n\tgobot.RegisterDriver(g)\n\n\treturn g\n}", "CodeBleu_score": 35.52976206720258}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByteData(CommandReg, SoftResetCommand)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readByteData(CommandReg)&0x80 > 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.654065251188204}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByteData(CommandReg, SoftResetCommand)\n\ttime.Sleep(SoftResetTime)\n\tif d.readByteData(CommandReg)&PowerDown != 0 {\n\t\treturn fmt.Errorf(\"MFRC522: Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.853725863253047}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeByteData(CommandReg, SoftResetCommand)\n\ttime.Sleep(time.Millisecond * 100)\n\tif d.readByteData(CommandReg)&0x80 > 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 23.44398614098621}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Check the length of the data available in the FIFO\n\t// The MFRC522 does not provide a command to read the length of the data in the FIFO, so we need to read the control register.\n\t// Bits 0 to 3 in ControlReg contain the FIFO length.\n\t// The FIFO can contain 64 bytes at most.\n\tvar n uint8\n\tn, err := d.readControlReg()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn &= 0x0f\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"MFRC522: Expected %d bytes, got %d\", len(backData), n)\n\t}\n\t// Read the data from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Get the error bits from the last call\n\treturn n, nil\n}", "CodeBleu_score": 42.455339044562784}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Read the number of bytes currently in the FIFO\n\tvar nbBytes uint8\n\tvar err error\n\tif nbBytes, err = d.readByte(RegFIFOLevelReg); err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: readByte failed: %v\", err)\n\t}\n\t// Check if the requested number of bytes are available in the FIFO\n\tif nbBytes < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: FIFO has only %d bytes available, expected %d\", nbBytes, len(backData))\n\t}\n\t// Read the bytes from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tif backData[i], err = d.readByte(RegFIFODataReg); err != nil {\n\t\t\treturn 0, fmt.Errorf(\"readFifo: readByte failed: %v\", err)\n\t\t}\n\t}\n\t// Read the last bits from the control register\n\tvar value uint8\n\tif value, err = d.readByte(RegControlReg); err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: readByte failed: %v\", err)\n\t}\n\treturn value & 0x07, nil\n}", "CodeBleu_score": 48.35672620685523}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tvar length uint8\n\tvar status uint8\n\tvar i uint8\n\n\t// Check number of bytes available in FIFO\n\tstatus, err := d.readByteData(d.dev, FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tlength = status & 0x7F\n\n\t// Check for error in FIFO level reg.\n\tif status&0x80 != 0 {\n\t\treturn 0, fmt.Errorf(\"Error in FIFO level reg. (0x%02x)\", status)\n\t}\n\n\t// Read out data from the FIFO\n\tif length != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"Mismatch in expected number of bytes (%d) and bytes available in FIFO (%d).\", len(backData), length)\n\t}\n\n\tfor i = 0; i < length; i++ {\n\t\tbackData[i], err = d.readByteData(d.dev, FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read out last bits from control register\n\tstatus, err = d.readByteData(d.dev, ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn status, nil\n}", "CodeBleu_score": 52.492759949289436}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\td.logDebug(\"piccHalt\")\n\tcmd := []byte{0x50, 0x0}\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc[0], crc[1])\n\t_, err := d.write(cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending halt command: %v\", err)\n\t}\n\terr = d.expectError(0x15)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error halting PICC: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.129028692519356}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\tif d.debug {\n\t\td.log.Debug(\"Halting PICC\")\n\t}\n\tcmd := []byte{d.CommandHaltA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0", "CodeBleu_score": 13.177823654203936}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\td.log(\"piccHalt\")\n\tcmd := []uint8{0x50, 0x01}\n\tif err := d.sendData(cmd, 0, 0); err != nil {\n\t\treturn fmt.Errorf(\"failed to send data: %w\", err)\n\t}\n\tif _, err := d.receiveData(0, 0, 0); err != nil {\n\t\treturn fmt.Errorf(\"failed to receive data: %w\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.58570346383428}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Build read command.\n\tcmd := make([]byte, 2)\n\tcmd[0] = PICC_READ\n\tcmd[1] = block\n\t// Calculate CRC.\n\tcrc := d.calculateCRC(cmd, 2)\n\t// Append CRC to command.\n\tcmd = append(cmd, crc...)\n\t// Send command.\n\tif err := d.communicateWithPICC(cmd); err != nil {\n\t\treturn nil, err\n\t}\n\t// Read response.\n\tresponse := make([]byte, 18)\n\tif err := d.communicateWithPICC(nil); err != nil {\n\t\treturn nil, err\n\t}\n\t// Check response.\n\tif response[0]&0x0F != 0x0A {\n\t\treturn nil, fmt.Errorf(\"piccRead: response[0]: %02x\", response[0])\n\t}\n\t// Return data.\n\treturn response[1:17], nil\n}", "CodeBleu_score": 41.40745415149056}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Prepare the command\n\tcmd := []byte{\n\t\t0x00, // PICC_READ\n\t\tblock,\n\t}\n\n\t// Calculate the CRC\n\tcmdCRC := d.calculateCRC(cmd)\n\t// Append the CRC\n\tcmd = append(cmd, cmdCRC[:]...)\n\n\t// Send the command\n\terr := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the data\n\tdata, err := d.readFromRegister(0x00, 16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 40.539282605167145}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Prepare the command\n\tcmd := make([]byte, 2)\n\tcmd[0] = PICC_READ\n\tcmd[1] = block\n\t// Calculate CRC\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC\n\tcmd = append(cmd, crc...)\n\t// Send the command\n\terr := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Retrieve response\n\tresponse, err := d.communicateWithPICC(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check response\n\tif len(response) != 16 {\n\t\treturn nil, fmt.Errorf(\"piccRead: unexpected response length: %d\", len(response))\n\t}\n\treturn response, nil\n}", "CodeBleu_score": 35.90280509943556}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Checks if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clears specific bits in the collision register.\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// For certain request modes, it sets the transmission to use only 7 bits of the last byte.\n\tswitch reqMode {\n\tcase 0x02, 0x04, 0x07, 0x08:\n\t\td.writeRegister(TxModeReg, 0x70)\n\tdefault:\n\t\td.writeRegister(TxModeReg, 0x00)\n\t}\n\n\t// Communicates with the PICC using the transceive command.\n\treturn d.communicateWithPICC(reqMode, answer)\n}", "CodeBleu_score": 33.766846762344514}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\td.clearRegisterBitMask(CollReg, 0x80) // Clear the CRC error bit\n\td.clearRegisterBitMask(ErrorReg, 0x1B) // Clear all error bits\n\td.clearRegisterBitMask(Status2Reg, 0x08) // Clear the buffer overflow bit\n\n\t// Build the request\n\tvar req []byte\n\tif reqMode == ModeTransfer {\n\t\treq = []byte{PiccCmdTransfer, 0x00}\n\t} else {\n\t\treq = []byte{PiccCmdReqA, 0x00}\n\t}\n\tif reqMode == ModeTransfer || reqMode == ModeTransferRec\n\t\td.setRegisterBitMask(BitFramingReg, 0x80) // Use only 7 bits of last byte\n\t}", "CodeBleu_score": 41.08790713518884}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Prepare values for BitFramingReg\n\td.clearRegisterBitMask(BitFramingReg, 0x80) // Clear the CRC_Append bit\n\n\tswitch reqMode {\n\tcase PICC_REQIDL:\n\t\t// Idle mode - do nothing\n\tcase PICC_REQALL:\n\t\td.setRegisterBitMask(BitFramingReg, 0x80) // Set the CRC_Append bit\n\tcase PICC_REQ12:\n\t\td.setRegisterBitMask(BitFramingReg, 0x80) // Set the CRC_Append bit\n\t\td.clearRegisterBitMask(BitFramingReg, 0x70) // Clear the MSB of the AFI_Check_Byte register\n\tcase PICC_REQ18:\n\t\td.setRegisterBitMask(BitFramingReg, 0x80) // Set the CRC_Append bit\n\t\td.setRegisterBitMask(BitFramingReg, 0x70) // Set the MSB of the AFI_Check_Byte register\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid request mode\")\n\t}\n\n\t// Build request command\n\tvar buf []byte\n\tswitch reqMode {\n\tcase PICC_REQIDL:\n\t\tbuf = []byte{PICC_CMD_REQA, 0x26}\n\tcase PICC_REQALL:\n\t\tbuf = []byte{PICC_CMD_REQA, 0x52}\n\tcase PICC_REQ12:\n\t\tbuf = []byte{PICC_CMD_REQA, 0x44}\n\tcase PICC_REQ18:\n\t\tbuf = []byte{PICC_CMD_REQA, 0x74}\n\t}\n\n\t// Send request command\n\tif err := d.communicateWithPICC(buf, answer); err != nil {", "CodeBleu_score": 46.930450675540705}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.35784667845527}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a step\n\td.digitalWrite(d.stepPin, LOW)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, HIGH)\n\n\t// Increment or decrement the step number\n\tif d.direction == FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.52357964680629}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\n\tif d.direction == 0 {\n\t\td.stepNumber--\n\t} else {\n\t\td.stepNumber++\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.35784667845527}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor(d.name)\n\treturn nil\n}", "CodeBleu_score": 40.62275498626719}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor(\"continuous\")\n\treturn nil\n}", "CodeBleu_score": 40.88238965047942}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo d.distanceMonitor(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 40.62275498626719}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\t// Calculate the distance in millimeters\n\t\t\tduration := (time.Now().Sub(startTimestamp)).Microseconds()\n\t\t\tdistance := duration / 58\n\t\t\td.sendEvent(distance, \"distance\")\n\t\t}\n\t}\n}", "CodeBleu_score": 42.102172122351554}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\tduration := (time.Now().Sub(startTimestamp)).Microseconds()\n\t\t\td.durationChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 41.108704861471054}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTimestamp time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, id uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\td.send(float64(time.Since(startTimestamp).Microseconds()))\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.13228372565914}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.emitTrigger(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// Measurement completed\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// Timeout occurred\n\t\treturn fmt.Errorf(\"timeout occurred while waiting for measurement to complete\")\n\t}\n}", "CodeBleu_score": 53.097858338135055}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\terr := d.emitTrigger()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.distance = d.waitForEcho()\n\tif d.distance == 0 {\n\t\treturn fmt.Errorf(\"distance measurement timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.911506561637154}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t// Lock the mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\td.trigger.Low()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.High()\n\n\t// Wait for the echo to go high (representing the start of the first pulse)\n\terr := d.waitForPulse(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo to go low (representing the end of the first pulse)\n\terr = d.waitForPulse(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Store the measured time\n\td.distance = d.pulseDuration.Microseconds()\n\n\treturn nil\n}", "CodeBleu_score": 52.15819051494619}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\tif \"X-Auth-Token\" in self.headers:\n        return self.headers[\"X-Auth-Token\"]\n\n    if self.is_authorized():\n        return self.get_state_item(\"access_token\")\n\n    if self.is_refreshable():\n        self.refresh_authentication_token()\n        return self.get_state_item(\"access_token\")\n\n    raise AccountNotAuthorized(\n        \"No valid authentication token found. Please call 'authenticate' first.\"\n    )\n\n", "CodeBleu_score": 21.72433220304571}, {"code": "def fetch_authentication_token(self)\n\t# Check if the token is available in the environment variables\n    token = os.environ.get(\"AUTHENTICATION_TOKEN\")\n    if token:\n        return token\n\n    # Check if the token is available in the local state\n    token = self.get_local_authentication_token()\n    if token:\n        return token\n\n    # Check if the refresh token is available in the local state\n    refresh_token = self.get_local_refresh_token()\n    if refresh_token:\n        # Fetch a new access token using the refresh token\n        token = self.refresh_authentication_token(refresh_token)\n        if token:\n            # Update the local state with the new authentication data\n            self.set_local_authentication_token(token)\n            return token\n\n    # Raise an exception if all methods fail\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 19.73335926083308}, {"code": "def fetch_authentication_token(self)\n\ttry:\n        return os.environ[\"AUTHENTICATION_TOKEN\"]\n    except KeyError:\n        pass\n    try:\n        data = self.get_authentication_data()\n        if data[\"access_token_expires_at\"] > time.time():\n            return data[\"access_token\"]\n        if data[\"refresh_token\"]:\n            self.refresh_authentication_token(data[\"refresh_token\"])\n            return self.get_authentication_data()[\"access_token\"]\n    except KeyError:\n        pass\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 23.12450864376548}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\trefresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\"/v1/logout\", method=\"POST\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 50.07483276018117}, {"code": "def logout(self)\n\trefresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 53.35835511519525}, {"code": "def logout(self)\n\tif self.is_logged_in():\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        try:\n            self.fetch_json_data(\"/v1/logout\", method=\"POST\", data={\"refresh_token\": refresh_token})\n        except AccountError:\n            pass\n    return True\n\n", "CodeBleu_score": 76.1147148223393}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tresult = []\n    for name, spec in self.packages.items():\n        if self.options.get(name, {}).get('optional', False):\n            continue\n        pkg = self.get_package(name, spec)\n        items = [name, pkg.version]\n        if pkg.is_external:\n            items.append(pkg.source_url)\n        result.append(items)\n    return result\n\n", "CodeBleu_score": 36.7252349942574}, {"code": "def dump_used_packages(self)\n\tpackages = []\n    for pkg in self.pm.get_packages():\n        if pkg.optional:\n            continue\n        data = {\n            \"name\": pkg.name,\n            \"version\": pkg.version,\n            \"source\": pkg.source,\n        }\n        if pkg.external:\n            data[\"source\"] = pkg.source\n        packages.append(data)\n    return packages\n\n", "CodeBleu_score": 32.87132875851416}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for name, pkg in self.packages.items():\n        if not pkg.optional:\n            items = {\n                \"name\": name,\n                \"version\": pkg.version,\n            }\n            if pkg.metadata.get(\"external\", False):\n                items[\"source\"] = pkg.metadata[\"source\"]\n            result.append(items)\n    return result\n\n", "CodeBleu_score": 37.542044710072275}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t# TODO: Add type hints\n    # TODO: Add docstring\n    # TODO: Add tests\n    # TODO: Add examples\n    # TODO: Add logging\n    # TODO: Add benchmarking\n    # TODO: Add versioning\n    # TODO: Add debugging\n    # TODO: Add profiling\n    # TODO: Add coverage\n    # TODO: Add authorship\n    # TODO: Add copyright\n    # TODO: Add license\n    # TODO: Add warnings\n    # TODO: Add type hints\n    # TODO: Add docstring\n    # TODO: Add tests\n    # TODO: Add examples\n    # TODO: Add logging\n    # TODO: Add benchmarking\n    # TODO: Add versioning\n    # TODO: Add debugging\n    # TODO: Add profiling\n    # TODO: Add coverage\n    # TODO: Add authorship\n    # TODO: Add copyright\n    # TODO: Add license\n    # TODO: Add warnings\n    # TODO: Add type hints\n    # TODO: Add docstring\n    # TODO: Add tests\n    # TODO: Add examples\n    # TODO: Add logging\n    # TODO: Add benchmarking\n    # TODO: Add versioning\n    # TODO: Add debugging\n    # TODO: Add profiling\n    # TODO: Add coverage\n    # TODO: Add authorship\n    # TODO: Add copyright\n    # TODO: Add license\n    # TODO: Add warnings\n    # TODO: Add type hints\n    # TODO: Add docstring\n    # TODO: Add tests\n    # TODO: Add examples\n    # TODO: Add logging\n    # TODO: Add benchmarking\n    # TODO: Add versioning\n    # TODO: Add debugging\n    # TODO: Add profiling\n    # TODO: Add coverage\n    # TODO: Add authorship\n    # TODO: Add copyright\n    # TODO: Add license\n    # TODO: Add warnings\n    # TODO: Add type hints\n    # TODO: Add docstring\n    # TODO: Add tests\n    # TODO: Add examples\n    # TODO: Add logging\n    # TODO: Add benchmarking\n    # TODO: Add versioning\n    # TODO: Add debugging\n    # TODO: Add profiling\n    # TODO: Add coverage\n    # TODO: Add authorship\n    # TODO: Add copyright", "CodeBleu_score": 5.256410256410256}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise exception.UndefinedEnvPlatformError(\n            \"The environment name is not specified\"\n        )\n\n    env_platform = cls.config.get(env, \"platform\", default=None)\n    if not env_platform:\n        raise exception.UndefinedEnvPlatformError(\n            \"The platform specification is not defined for the environment '%s'\"\n            % env\n        )\n\n    p = cls(env_platform, autoinstall)\n    p.set_env(env)\n    p.configure_project_packages(targets)\n    return p", "CodeBleu_score": 35.686451398132114}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise exception.MissingEnvError()\n    env_platform = cls.get_env_platform(env)\n    if not env_platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    p = cls(env_platform, autoinstall)\n    p.configure_project_packages(env, targets)\n    return p\n\n", "CodeBleu_score": 41.91208684636224}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 76.09796338116259}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 76.09796338116259}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.48483205243677}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        uint8_t buf = Read8bit(0x33);\n        buf         = (uint8_t)(time_in_us >> 24) | (buf & 0xF8);\n        Write1Byte(0x33, buf);\n        buf = Read8bit(0x34);\n        buf = (uint8_t)(time_in_us >> 16) | (buf & 0xF8);\n        Write1Byte(0x34, buf);\n        buf = Read8bit(0x35);\n        buf = (uint8_t)(time_in_us >> 8) | (buf & 0xF8);\n        Write1Byte(0x35, buf);\n        buf = Read8bit(0x36);\n        buf = (uint8_t)(time_in_us) | (buf & 0xF8);\n        Write1Byte(0x36, buf);\n        Write1Byte(0x32, 0x80);\n    } else {\n        Write1Byte(0x32, 0x00);\n    }\n    Write1Byte(0x90, 0x00);\n    Write1Byte(0x12, 0x09);\n    // Write1Byte(0x12, 0x00);\n    Write1Byte(0x12, Read8bit(0x12) & 0xA1);  // Disable all outputs but DCDC1\n    Write1Byte(0x90, 0x00);\n    Write1Byte(0x12, 0x09);\n    // Write1Byte(0x12, 0x00);\n    Write1Byte(0x12, Read8bit(0x12) & 0xA1);  // Disable all outputs but DCDC1\n    esp_sleep_enable_timer_wakeup(time_in_us);\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 56.716937757389516}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.3181116932034}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.3181116932034}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y_start = y_scroll;\n  uint16_t y_end = y_scroll + TEXT_HEIGHT;\n  if (tteBar) {\n    y_start += TOP_FIXED_AREA;\n    y_end += TOP_FIXED_AREA;\n  }\n  tft.fillRect(0, y_start, TFT_WIDTH, TEXT_HEIGHT, color);\n  y_scroll += TEXT_HEIGHT;\n  if (y_scroll > TFT_HEIGHT - BOTTOM_FIXED_AREA) {\n    y_scroll = TOP_FIXED_AREA;\n  }\n  scrollAddress(y_scroll);\n  return y_start;\n}", "CodeBleu_score": 29.358751531537465}, {"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y = yStart;\n  if (tteBar) {\n    y = yStartBar;\n  }\n  tft.fillRect(0, y, tft.width(), y + tft.fontHeight(), color);\n  y += tft.fontHeight();\n  if (y >= (tft.height() - tft.fontHeight())) {\n    y = yStart;\n  }\n  scrollAddress(y);\n  return y;\n}", "CodeBleu_score": 15.751234287583765}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n    // Store current starting y-coordinate\n    int y_old = y_scroll;\n    // Fill a rectangle at this coordinate with the specified color\n    tft.fillRect(0, y_scroll, TFT_WIDTH, TFT_HEIGHT - y_scroll, color);\n    // Increment y-coordinate by the height of a text line\n    y_scroll += TEXT_HEIGHT;\n    // Wrap around if it exceeds the display boundaries minus the bottom fixed area\n    if (y_scroll >= TFT_HEIGHT - TOP_FIXED_AREA) {\n      y_scroll = TOP_FIXED_AREA;\n    }\n    // If a specific condition (tteBar) is met, it uses alternative top fixed area coordinates\n    if (tteBar) {\n      y_scroll = TOP_FIXED_AREA_BAR;\n    }\n    // Update the scroll address\n    scrollAddress(y_scroll);\n    // Return the previous y-coordinate\n    return y_old;\n  #endif\n}", "CodeBleu_score": 28.384980368482438}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (this->setAPs() && this->setHtml()) {\n    this->startPortal();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 58.55328650478368}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t// set APs\n  if (!this->setAPs(ssids, access_points)) {\n    return false;\n  }\n\n  // set HTML\n  if (!this->setHtml()) {\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 69.54235921985835}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setAPs()) {\n    Serial.println(\"[EvilPortal] Failed to set access points\");\n    return false;\n  }\n\n  if (!this->setHtml()) {\n    Serial.println(\"[EvilPortal] Failed to set HTML content\");\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 55.23351463365527}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n        // if the queue is already enabled, ensure that the queue, text, and text_in are initialized\n        if (!queue_init_flag) {\n            // initialize the queue\n            queue = new std::queue<std::string>;\n            text = new std::string;\n            text_in = new std::string;\n            queue_init_flag = true;\n        }\n    } else {\n        // if the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 16.61293423333413}, {"code": "void GpsInterface::enable_queue(){\n\tif (!this->queue_enabled_flag) {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 18.0462719046108}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n        if (queue == NULL) {\n            queue = new Queue();\n            text = new std::string();\n            text_in = new std::string();\n        }\n    } else {\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 17.2511515404439}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue != NULL) {\n\t\tthis->new_queue = new std::queue<std::string>;\n\t\tdelete this->queue;\n\t} else {\n\t\tthis->new_queue = new std::queue<std::string>;\n\t}\n\tthis->queue = this->new_queue;\n}", "CodeBleu_score": 17.703363549951355}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif(this->queue_nmea != NULL) {\n\t\tthis->new_queue_nmea = new Queue<NmeaSentence*>();\n\t\twhile(!this->queue_nmea->empty()) {\n\t\t\tNmeaSentence* sentence = this->queue_nmea->front();\n\t\t\tthis->new_queue_nmea->push(sentence);\n\t\t\tthis->queue_nmea->pop();\n\t\t}\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = this->new_queue_nmea;\n\t\tthis->new_queue_nmea = NULL;\n\t} else {\n\t\tthis->queue_nmea = new Queue<NmeaSentence*>();\n\t}\n}", "CodeBleu_score": 42.320234311704354}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->queue_nmea != NULL) {\n        delete this->queue_nmea;\n    }\n    this->queue_nmea = new Queue<string>();\n}", "CodeBleu_score": 19.31238460879627}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*The most important function to create a display driver.\n     * 1. Get the address of the display\n     * 2. Get the X and Y coordinates of the area to be updated\n     * 3. Get the pointer to the color data to be updated\n     * 4. Update the display*/\n\n    /*Get the address of the display*/\n    tft_t *tft = (tft_t *)disp->user_data;\n\n    /*Get the X and Y coordinates of the area to be updated*/\n    int32_t x1 = area->x1;\n    int32_t y1 = area->y1;\n    int32_t x2 = area->x2;\n    int32_t y2 = area->y2;\n\n    /*Get the pointer to the color data to be updated*/\n    lv_color_t * color = color_p;\n\n    /*Update the display*/\n    tft->startWrite();\n    tft->setAddrWindow(x1, y1, (x2 - x1 + 1), (y2 - y1 + 1));\n\n    for (int y = y1; y <= y2; y++) {\n      for (int x = x1; x <= x2; x++) {\n        tft->writeColor(color->full);\n        color++;\n      }\n    }\n\n    tft->endWrite();\n\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 54.134916991464465}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*Get the start address of the display buffer*/\n    uint16_t buf_start = disp->buffer->area.y1 * disp->buffer->width;\n\n    /*Get the display width*/\n    uint16_t disp_w = disp->buffer->width;\n\n    /*Get the display height*/\n    uint16_t disp_h = disp->buffer->height;\n\n    /*Get the display buffer*/\n    uint16_t *buf = (uint16_t *)disp->buffer->buf;\n\n    /*Get the X and Y coordinates of the area to be updated*/\n    uint16_t x1 = area->x1;\n    uint16_t y1 = area->y1;\n    uint16_t x2 = area->x2;\n    uint16_t y2 = area->y2;\n\n    /*Get the width and height of the area to be updated*/\n    uint16_t w = x2 - x1 + 1;\n    uint16_t h = y2 - y1 + 1;\n\n    /*Get the index of the first pixel to be updated*/\n    uint32_t i = y1 * disp_w + x1;\n\n    /*Start a write transaction*/\n    display_obj.tft.startWrite();\n\n    /*Set the address window to the area to be updated*/\n    display_obj.tft.setAddrWindow(x1, y1, x2, y2);\n\n    /*Iterate through each pixel in the area to be updated*/\n    for (uint16_t y = 0; y < h; y++) {\n      for (uint16_t x = 0; x < w; x++) {\n        /*Write the pixel to the display buffer*/\n        display_obj.tft.writeColor(color_p->full, 1);\n\n        /*Increment the color buffer index*/\n        color_p++;\n\n        /*Increment the display buffer index*/\n        i++;\n      }\n\n      /*Increment the display buffer index by the width of the display minus the width of the area to be updated*/\n      i += disp_w - w;\n    }", "CodeBleu_score": 45.027022657161766}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*Write the memory array of the raw buffer to the display. (transmit data)*/\n    uint32_t size = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n    uint32_t i = 0;\n    uint32_t color32;\n    uint8_t color8[3];\n    uint32_t x;\n    uint32_t y;\n\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    for(i = 0; i < size; i++) {\n      color32 = color_p[i].full;\n      color8[0] = (uint8_t)(color32 >> 16);\n      color8[1] = (uint8_t)(color32 >> 8);\n      color8[2] = (uint8_t)(color32);\n      display_obj.tft.writeColor(color8[0], color8[1], color8[2]);\n    }\n    display_obj.tft.endWrite();\n\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 60.2349937490039}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tSerial.print(F(\"menu->list->get(\"));\n  Serial.print(layer);\n  Serial.println(F(\")\"));\n  Serial.print(menu->list->get(layer));\n  Serial.println();\n  Serial.print(F(\"menu->list->size\"));\n  Serial.println();\n  Serial.print(menu->list->size);\n  Serial.println();\n}", "CodeBleu_score": 43.274218024360025}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tSerial.print(menu->getMenuName());\n  Serial.print(\":\");\n  Serial.print(menu->getMenuID());\n  Serial.print(\":\");\n  Serial.print(layer);\n  Serial.print(\":\");\n  Serial.println(menu->list->size());\n  for (int i = 0; i < menu->list->size(); i++) {\n    Serial.print(menu->list->get(i)->getMenuName());\n    Serial.print(\":\");\n    Serial.print(menu->list->get(i)->getMenuID());\n    Serial.print(\":\");\n    Serial.print(layer);\n    Serial.print(\":\");\n    Serial.println(menu->list->get(i)->list->size());\n    showMenuList(menu->list->get(i), layer + 1);\n  }\n  Serial.println();\n}", "CodeBleu_score": 57.870503367456315}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tSerial.print(F(\"menu->list->get\"));\n  Serial.print(F(\"(\"));\n  Serial.print(F(\"menu\"));\n  Serial.print(F(\", \"));\n  Serial.print(F(\"layer\"));\n  Serial.print(F(\")\"));\n  Serial.print(F(\": \"));\n  Serial.print(menu->list->get(menu, layer));\n  Serial.print(F(\"\n\"));\n  Serial.print(F(\"menu->list->size\"));\n  Serial.print(F(\"(\"));\n  Serial.print(F(\"menu\"));\n  Serial.print(F(\")\"));\n  Serial.print(F(\": \"));\n  Serial.print(menu->list->size(menu));\n  Serial.print(F(\"\n\"));\n  Serial.print(F(\"\n\"));\n}", "CodeBleu_score": 35.618414191150364}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tssids->clear();\n  for (int i = 0; i < count; i++) {\n    char essid[7];\n    for (int j = 0; j < 6; j++) {\n      essid[j] = (char)random(97, 123);\n    }\n    essid[6] = 0;\n    Serial.println(essid);\n    ssids->add(essid);\n  }\n  return ssids->size();\n}", "CodeBleu_score": 35.4946313476089}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\n  char essid[6];\n  int channel;\n  byte mac[6];\n\n  for (i = 0; i < count; i++) {\n    // Generate random SSID\n    for (int j = 0; j < 6; j++) {\n      essid[j] = (char)random(97, 122);\n    }\n    // Generate random channel\n    channel = random(1, 14);\n    // Generate random MAC address\n    for (int j = 0; j < 6; j++) {\n      mac[j] = (byte)random(0, 255);\n    }\n\n    // Add SSID to list\n    ssids->add(new SSID(essid, channel, mac));\n\n    // Print SSID to serial output\n    Serial.print(\"SSID: \");\n    Serial.print(essid);\n    Serial.print(\", Channel: \");\n    Serial.print(channel);\n    Serial.print(\", MAC: \");\n    Serial.println(mac);\n  }\n\n  return count;\n}", "CodeBleu_score": 45.72669464819275}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\n  for (i = 0; i < count; i++) {\n    char essid[7];\n    randomESSID(essid);\n    Serial.print(i);\n    Serial.print(\": \");\n    Serial.print(essid);\n    Serial.print(\" (\");\n    Serial.print(random(1, 13));\n    Serial.print(\")\");\n    Serial.print(\" (\");\n    Serial.print(randomMAC());\n    Serial.println(\")\");\n    ssids->add(essid);\n  }\n  return i;\n}", "CodeBleu_score": 30.08602513457359}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\t# [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 90.9582225300981}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t# Set the issued time to the current UTC time\n    issued_time = datetime.datetime.utcnow()\n    # Set the expiration time to one hour later\n    expiration_time = issued_time + datetime.timedelta(hours=1)\n    # Create a JWT payload\n    payload = {\n        'iat': issued_time,\n        'exp': expiration_time,\n        'aud': project_id\n    }\n    # Read the private key file\n    with open(private_key_file, 'rb') as f:\n        private_key = f.read()\n    # Create a JWT using the payload and the private key\n    jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    # Return the encoded JWT\n    return jwt\n\n", "CodeBleu_score": 53.287246521710244}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t# The JWT is an encoded JSON object that consists of a header,\n    # a payload, and a signature.\n    # The header contains the type of the token, which is JWT,\n    # and the encryption algorithm being used, such as RS256.\n    # The payload contains the claims.\n    # The claims are the data we want to put into the JWT.\n    # In this case, we are using the claims to identify the project ID\n    # and the expiration time.\n    header = {\n        'typ': 'JWT',\n        'alg': algorithm\n    }\n\n    # The payload contains the claims.\n    # In this case, we are using the claims to identify the project ID\n    # and the expiration time.\n    payload = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create a JWT encoder.\n    # Use the claims to create the JWT.\n    # Use the private key to sign the JWT.\n    # Use the algorithm specified in the header.\n    # Encode the JWT to a string.\n    jwt_encoder = jwt.encode(payload, private_key, algorithm)\n    return jwt_encoder.decode('utf-8')\n\n\n\n\n", "CodeBleu_score": 72.58419797034819}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t# [START iot_create_jwt]\n    import datetime\n    import jwt\n    import json\n    import os\n    from google.oauth2 import service_account\n\n    # Set the environment variable \"GOOGLE_APPLICATION_CREDENTIALS\" to point to your service account key file\n    # Use the service account key file to create the JWT\n    # The file can be downloaded from the Google Cloud Console\n    # https://console.cloud.google.com/apis/credentials\n    #\n    # The service account key file is a JSON file that contains the private key.\n    # It is used to create a JWT that is signed with the private key.\n    # The JWT is then used to authenticate to the Google Cloud IoT Core service.\n\n    # Set the environment variable \"GOOGLE_APPLICATION_CREDENTIALS\" to point to your service account key file\n    # The service account key file is downloaded from the Google Cloud Console\n    # https://console.cloud.google.com/apis/credentials\n    #\n    # The service account key file is a JSON file that contains the private key.\n    # It is used to create a JWT that is signed with the private key.\n    # The JWT is then used to authenticate to the Google Cloud IoT Core service.\n\n    # Set the environment variable \"GOOGLE_APPLICATION_CREDENTIALS\" to point to your service account key file\n    # The service account key file is downloaded from the Google Cloud Console\n    # https://console.cloud.google.com/apis/credentials\n    #\n    # The service account key file is a JSON file that contains the private key.\n    # It is used to create a JWT that is signed with the private key.\n    # The JWT is then used to authenticate to the Google Cloud IoT Core service.\n\n    # Set the environment variable \"GOOGLE_APPLICATION_CREDENTIALS\" to point to your service account key file\n    # The service account key file is downloaded from the Google Cloud Console\n    # https://console.cloud.google.com/apis/credentials\n    #\n    # The service account key file is a JSON file that contains the private key", "CodeBleu_score": 3.265858962298988}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        message.payload.decode('utf-8'), message.topic, str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        print('Turning on the camera.')\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        print('Uploading image to Cloud Storage.')\n        blob = upload_file(path, args.bucket_name)\n        print('Publishing image URL to topic \\'{}\\'.'.format(\n            args.event_topic))\n        payload = '{{\"image_url\": \"{}\"}}'.format(blob)\n        mqtt_client.publish(args.event_topic, payload, qos=1)\n        print('Published message \\'{}\\' to topic \\'{}\\''.format(\n            payload, args.event_topic))\n    else:\n        print('Turning off the camera.')\n\n", "CodeBleu_score": 49.173959945582816}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n            message.payload.decode('utf-8'), message.topic, message.qos))\n    if message.payload.decode('utf-8') == 'on':\n        print('Turning on the camera')\n        path = '/home/pi/image.jpg'\n        preview_capture(path)\n        print('Uploading file')\n        blob = upload_file(path, args.bucket_name)\n        print('Publishing message')\n        unused_client.publish(\n                '/devices/{}/events'.format(args.device_id),\n                blob,\n                qos=1)\n    elif message.payload.decode('utf-8') == 'off':\n        print('Turning off the camera')\n    else:\n        print('Received unexpected message')\n\n", "CodeBleu_score": 47.12719581325333}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload.decode('utf-8'), message.topic, message.qos))\n    if message.payload.decode('utf-8') == 'on':\n        print('Turning on camera')\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print(url)\n        payload = '{{\"url\": \"{}\"}}'.format(url)\n        print(payload)\n        unused_client.publish(args.event_topic, payload, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 49.42227644732261}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Identifier of the Google Cloud project where the PubSub topic exists.')\n    parser.add_argument(\n        '--subscription_name',\n        help='Name of the PubSub subscription to listen on.')\n    parser.add_argument(\n        '--registry_id',\n        help='Cloud IoT Core registry id.')\n    parser.add_argument(\n        '--device_id',\n        help='Cloud IoT Core device id.')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region.')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help='Ind", "CodeBleu_score": 31.71216663821978}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        '--project_id',\n        help='GCP cloud project name',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\n        '--registry_id',\n        help='GCP IoT Core registry name',\n        default='my-registry')\n    parser.add_argument(\n        '--device_id',\n        help='GCP IoT Core device name',\n        default='my-device')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region',\n        default='us-central1')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help='Indicates whether the message to be published is a '\n        'telemetry event or a device state message (i.e. reported '\n        'property).')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=2", "CodeBleu_score": 32.24270799038428}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        default=\"my-registry\",\n        help=\"Cloud IoT registry ID\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        default=\"my-device\",\n        help=\"Cloud IoT device ID\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        default=8883,\n        type=int,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=60,\n        type=int,\n        help=\"Expiration time", "CodeBleu_score": 35.407290250810576}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t# The scopes below are needed for the device manager and registry manager\n    # Cloud IoT Core service.\n    # See: https://developers.google.com/identity/protocols/googlescopes\n    # For more information on managing access to Google APIs, see:\n    # https://cloud.google.com/docs/authentication/getting-started\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n    # The version of the API to use. This can be changed to use a different\n    # version.\n    api_version = \"v1\"\n    # The discovery URL for Cloud IoT Core API.\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    # Load credentials and create a Cloud IoT Core V1 service object.\n    # If you have not set up authentication, see:\n    # https://cloud.google.com/docs/authentication/getting-started\n    # Note: Google Application Credentials is now the recommended way to\n    # authenticate with Google Cloud services.\n    # See: https://cloud.google.com/docs/authentication/getting-started\n    # This sample uses Application Default Credentials through a JSON service\n    # account key for simplicity.\n    # To use Application Default Credentials with this sample, add the\n    # following to your environment:\n    # GOOGLE_APPLICATION_CREDENTIALS=<path to service account JSON file>\n    # See: https://developers.google.com/identity/protocols/application-default-credentials\n    # For more information on Application Default Credentials, see:\n    # https://cloud.google.com/docs/authentication/production\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    service = discovery.build(\n        \"cloudiot\", api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url\n    )\n    return service\n\n", "CodeBleu_score": 26.10312280956611}, {"code": "def get_client(service_account_json)\n\t# Define the necessary API scopes and discovery URL.\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # Load the service account credentials and define the necessary scopes.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    # Use the credentials and scopes to build the Cloud IoT Core client.\n    return discovery.build('cloudiot', 'v1', credentials=scoped_credentials,\n                           discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 24.70487483482672}, {"code": "def get_client(service_account_json)\n\t# The scopes below are necessary for the Google Cloud IoT Core device manager\n    # and registry manager.\n    # See: https://cloud.google.com/iot/docs/concepts/security#oauth\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    # The version of the API to use. This will change as the API evolves.\n    VERSION = 'v1'\n    # The discovery URL for the API. This will change as the API evolves.\n    DISCOVERY_URL = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # The name of the service used to create and list devices. This will change\n    # as the API evolves.\n    DEVICE_MANAGER_SERVICE_NAME = 'cloudiot'\n    # The name of the service used to create and list registries. This will\n    # change as the API evolves.\n    REGISTRY_MANAGER_SERVICE_NAME = 'cloudiot'\n    # Create the service object. The 'service' variable will be used to\n    # interact with the Cloud IoT Core API.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=SCOPES)\n    service = discovery.build(\n        DEVICE_MANAGER_SERVICE_NAME, VERSION, credentials=credentials,\n        discoveryServiceUrl=DISCOVERY_URL)\n    return service\n\n", "CodeBleu_score": 41.63017321212295}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\thash_method_asn1 = hash_method_asn1_code(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_hash_method_asn1 = hash_method_asn1 + hash_value\n\n    # Pad the hash value with ASN1 code and 00\n    padded_hash_value = _pad_for_signing(hash_value_with_hash_method_asn1, 128)\n\n    # Encrypt the padded hash value with the private key\n    signature = priv_key.blinded_encrypt(padded_hash_value)\n\n    return signature\n\n", "CodeBleu_score": 33.8875346312098}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\tif hash_method == 'sha256':\n        hash_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha384':\n        hash_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'sha512':\n        hash_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    padded_hash = _pad_for_signing(hash_code + hash_value, priv_key.byte_size)\n\n    return priv_key.blinded_encrypt(padded_hash)\n\n\n", "CodeBleu_score": 22.446221498526274}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\thash_method = hash_method.lower()\n    if hash_method == 'sha1':\n        hash_asn1 = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'sha256':\n        hash_asn1 = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha384':\n        hash_asn1 = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'sha512':\n        hash_asn1 = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    padded_hash = _pad_for_signing(hash_value, 128)\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash)\n\n    return encrypted_signature\n\n", "CodeBleu_score": 24.559495281110003}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t# convert signature to integer\n    signature = transform.bytes2int(signature)\n    # decrypt signature\n    clearsig = core.decrypt_int(signature, pub_key)\n    # determine hash method\n    hashname = _find_method_hash(clearsig)\n    # compute hash\n    hashed = compute_hash(message, hashname)\n    # reconstruct padded hash\n    padded = _pad_for_signing(hashed, core.byte_size(signature))\n    # compare with clear signature\n    if padded != clearsig:\n        raise VerificationError('Verification failed')\n    # return hash method name\n    return hashname", "CodeBleu_score": 22.569582384389967}, {"code": "def verify(message, signature, pub_key)\n\t# Convert the signature to an integer\n    sig_int = transform.bytes2int(signature)\n\n    # Decrypt the signature with the public key\n    clearsig = core.decrypt_int(sig_int, pub_key)\n\n    # Find the hash method\n    hashname = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hashed = compute_hash(message, hashname)\n\n    # Reconstruct the expected padded hash\n    expected = _pad_for_signing(hashed, common.byte_size(sig_int))\n\n    # Check if the expected padded hash matches the clear signature\n    if expected != clearsig:\n        raise VerificationError('Verification failed')\n\n    # Return the hash method name\n    return hashname\n\n\n", "CodeBleu_score": 23.927669465016905}, {"code": "def verify(message, signature, pub_key)\n\t# TODO: This function is too long.\n    # TODO: Rename this function to something more descriptive.\n    # TODO: Add type annotations to the function arguments.\n    # TODO: Add type annotations to the local variables.\n    # TODO: Add docstrings to the local functions.\n    # TODO: Add comments explaining the non-obvious parts.\n    # TODO: Refactor this function to be more readable.\n    # TODO: Add more tests.\n    # TODO: Add comments explaining the non-obvious parts.\n\n    # TODO: Find out why the first 2 bytes of the signature are 00 01.\n\n    # TODO: Find out why the last 6 bytes of the signature are 00.\n\n    # TODO: Find out why the 2nd to last byte of the signature is 00.\n\n    # TODO: Find out why the first 2 bytes of the signature are 00 01.\n\n    # TODO: Find out why the last 6 bytes of the signature are 00.\n\n    # TODO: Find out why the 2nd to last byte of the signature is 00.\n\n    # TODO: Find out why the first 2 bytes of the signature are 00 01.\n\n    # TODO: Find out why the last 6 bytes of the signature are 00.\n\n    # TODO: Find out why the 2nd to last byte of the signature is 00.\n\n    # TODO: Find out why the first 2 bytes of the signature are 00 01.\n\n    # TODO: Find out why the last 6 bytes of the signature are 00.\n\n    # TODO: Find out why the 2nd to last byte of the signature is 00.\n\n    # TODO: Find out why the first 2 bytes of the signature are 00 01.\n\n    # TODO: Find out why the last 6 bytes of the signature are 00.\n\n    # TODO: Find out why the 2nd to last byte of the signature is 00.\n\n    # TODO: Find out why the first 2 bytes of the signature are 00 01.\n\n    # TODO: Find out why the last 6 bytes", "CodeBleu_score": 1.8790849673202614}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\ttime_t now;\n   time(&now);\n   debug_printInfo(\"Time: %s\", ctime(&now));\n   if (now < UNIX_OFFSET) {\n      debug_printError(\"Time is not set\");\n      return;\n   }\n   updateJWT(now);\n   debug_printInfo(\"MQTT: Connecting to %s\", mqttHost);\n   MQTT_CLIENT_connect(mqttHost, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttSubscribeTopic, mqttQos);\n}", "CodeBleu_score": 42.27276926229862}, {"code": "static void connectMQTT(){\n\ttime_t epoch = time(NULL);\n   if (epoch < 0) {\n      debug_printError(\"Time: %s\", strerror(errno));\n   } else {\n      updateJWT(epoch);\n   }\n   MQTT_CLIENT_connect();\n   sendSubscribe = true;\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 33.6276284819305}, {"code": "static void connectMQTT(){\n\tdebug_printInfo(\"MQTT: Connecting...\");\n   time_t t = time(NULL);\n   if (t < 0) {\n      debug_printError(\"MQTT: Time is invalid. Please set the time.\");\n      return;\n   }\n   updateJWT(t);\n\n   MQTT_CLIENT_connect();\n   sendSubscribe = true;\n}", "CodeBleu_score": 35.941869192632744}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = str[i];\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        n = n * 10 + c - '0';\n    }\n    *num = n;\n    return str + width;\n}", "CodeBleu_score": 26.2425993268659}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = str[i];\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        n = n * 10 + c - '0';\n    }\n    *num = n;\n    return str + width;\n}", "CodeBleu_score": 26.2425993268659}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9')\n            return str;\n        n = n * 10 + (c - '0');\n    }\n    *num = n;\n    return str;\n}", "CodeBleu_score": 23.938436494675514}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t *cert_ptr = build_state->cert;\n    size_t cert_size = build_state->cert_size;\n    const atcacert_def_t *cert_def = build_state->cert_def;\n    uint8_t *cert_template_ptr = build_state->cert_template;\n    size_t cert_template_size = build_state->cert_template_size;\n    uint8_t *cert_template_max = cert_template_ptr + cert_template_size;\n    uint8_t *cert_template_next_free = cert_template_ptr;\n    size_t cert_template_next_free_size = cert_template_size;\n    uint8_t *cert_max = cert_ptr + cert_size;\n    uint8_t *cert_next_free = cert_ptr;\n    size_t cert_next_free_size = cert_size;\n    uint8_t *cert_next_free_max = cert_ptr + cert_size;\n    size_t cert_elem_size = 0;\n    uint8_t *cert_elem_data = NULL;\n    uint8_t *cert_elem_data_next_free = NULL;\n    size_t cert_elem_data_next_free_size = 0;\n    uint8_t *cert_elem_data_max = NULL;\n    uint8_t *cert_elem_data_next_free_max = NULL;\n    uint8_t *cert_elem_data_ptr = NULL;\n    size_t cert_elem_data_size = 0;\n    uint8_t *cert_elem_data_max_ptr = NULL;\n    uint8_t *cert_elem_data_next_free_max_ptr = NULL;\n    uint8_t *cert_elem_data_ptr_max = NULL;\n    uint8_t *cert_elem_data_next_free_max_ptr_max = NULL;\n    uint8_t *cert_elem_data_ptr_max_ptr = NULL;\n    uint8_t *cert_elem_data_next_free", "CodeBleu_score": 17.629697155137446}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    size_t i = 0;\n    size_t cert_size = 0;\n    uint8_t* cert = NULL;\n    atcacert_def_t* cert_def = NULL;\n    atcacert_device_loc_t device_loc;\n    atcacert_device_loc_t ca_public_key_loc;\n    atcacert_device_loc_t ca_comp_cert_loc;\n    atcacert_device_loc_t device_private_key_loc;\n    atcacert_device_loc_t device_public_key_loc;\n    atcacert_device_loc_t device_sn_loc;\n    uint8_t* device_sn = NULL;\n    uint8_t* device_public_key = NULL;\n    uint8_t* device_private_key = NULL;\n    uint8_t* ca_public_key = NULL;\n    uint8_t* ca_comp_cert = NULL;\n    uint8_t* cert_sig = NULL;\n    uint8_t* cert_sig_size = NULL;\n    uint8_t* cert_sig_size_size = NULL;\n    uint8_t* cert_sig_size_pos = NULL;\n    uint8_t* cert_sig_pos = NULL;\n    uint8_t* cert_sig_max = NULL;\n    uint8_t* cert_max = NULL;\n    uint8_t* cert_pos = NULL;\n    uint8_t* cert_start = NULL;\n    uint8_t* cert_end = NULL;\n    uint8_t* cert_sn = NULL;\n    uint8_t* cert_sn_size = NULL;\n    uint8_t* cert_sn_size_size = NULL;\n    uint8_t* cert_sn_size_pos = NULL;\n    uint8_t* cert_sn_pos = NULL;\n    uint8_t* cert_sn_max = NULL;\n    uint8_t* cert_sn_end = NULL;\n    uint8_t* cert_expire_date = NULL;", "CodeBleu_score": 14.118335073704358}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    size_t cert_size = 0;\n    uint8_t cert[1024];\n    atcacert_tm_utc_t issue_date;\n    atcacert_tm_utc_t expire_date;\n    uint8_t cert_sn[32];\n    uint8_t cert_sn_size = 0;\n    size_t cert_sn_offset = 0;\n    uint8_t cert_sn_count = 0;\n    uint8_t cert_sn_count_max = 0;\n    uint8_t cert_sn_count_pos = 0;\n    uint8_t cert_sn_count_pos_size = 0;\n    uint8_t cert_sn_count_pos_offset = 0;\n    uint8_t cert_sn_count_pos_count = 0;\n    uint8_t cert_sn_count_pos_count_size = 0;\n    uint8_t cert_sn_count_pos_count_offset = 0;\n    uint8_t cert_sn_count_pos_count_count = 0;\n    uint8_t cert_sn_count_pos_count_count_size = 0;\n    uint8_t cert_sn_count_pos_count_count_offset = 0;\n    uint8_t cert_sn_count_pos_count_count_count = 0;\n    uint8_t cert_sn_count_pos_count_count_count_size = 0;\n    uint8_t cert_sn_count_pos_count_count_count_offset = 0;\n    uint8_t cert_sn_count_pos_count_count_count_count = 0;\n    uint8_t cert_sn_count_pos_count_count_count_count_size = 0;\n    uint8_t cert_sn_count_pos_count_count_count_count_offset = 0;\n    uint8_t cert_sn_count_pos_count_count_count_count_count = 0;\n    uint8_t cert_", "CodeBleu_score": 10.078590876784887}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the signature\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the signature\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 83.45090434091446}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    size_t signature_size = sizeof(signature);\n    uint8_t ca_comp_key[64];\n    uint8_t ca_comp_temp_key[32];\n    size_t ca_comp_temp_key_size = sizeof(ca_comp_temp_key);\n    uint8_t ca_comp_key_size = sizeof(ca_comp_key);\n    atcacert_device_loc_t ca_public_key_dev_loc;\n    atcacert_device_loc_t ca_comp_key_dev_loc;\n    atcacert_device_loc_t ca_comp_temp_key_dev_loc;\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device_loc(cert_def, cert, cert_size, &ca_public_key_dev_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device_loc(cert_def, cert, cert_size, &ca_comp_key_dev_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device_loc(cert_def, cert, cert_size, &ca_comp_temp", "CodeBleu_score": 73.7027042405781}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                    ret = 0;\n    uint8_t                tbs_digest[32];\n    uint8_t                signature[64];\n    atcacert_device_loc_t  ca_public_key_loc;\n    atcacert_device_loc_t  tbs_digest_loc;\n    atcacert_device_loc_t  signature_loc;\n    size_t                 tbs_digest_size = sizeof(tbs_digest);\n    size_t                 signature_size = sizeof(signature);\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_device_loc(cert_def, &ca_public_key_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_digest_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device_loc(cert_def, &tbs_digest_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device_loc(cert_def, &signature_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern(tbs_digest, tbs_digest_loc.offset, ca_public_key, ca_public_key_loc", "CodeBleu_score": 70.7054832594235}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *current = list;\n    while (*current != NULL)\n    {\n        if (*current == timer)\n        {\n            *current = timer->next;\n            return true;\n        }\n        current = &(*current)->next;\n    }\n    return false;\n}", "CodeBleu_score": 21.68265538463715}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *current = list;\n        while (*current != NULL)\n        {\n            if (*current == timer)\n            {\n                *current = timer->next;\n                return true;\n            }\n            current = &(*current)->next;\n        }\n        return false;\n    }", "CodeBleu_score": 23.239070997093318}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (*list == NULL)\n        {\n            return false;\n        }\n        if (*list == timer)\n        {\n            *list = timer->next;\n            return true;\n        }\n        timerStruct_t *prev = *list;\n        while (prev->next != NULL)\n        {\n            if (prev->next == timer)\n            {\n                prev->next = timer->next;\n                return true;\n            }\n            prev = prev->next;\n        }\n        return false;\n    }", "CodeBleu_score": 39.21948226153703}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint ret = SOCK_ERR_INVALID_ARG;\n\ttstrSocket *pstrSock;\n\t\n\tret = SOCKET_REQUEST(SOCKET_CMD_CLOSE, (uint8*)&socket, sizeof(int), NULL,0, 0);\n\tif(ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tret = SOCK_ERR_INVALID;\n\t}\n\t\n\treturn ret;\n}", "CodeBleu_score": 19.138952407014365}, {"code": "int BSD_close(int socket){\n\tint\ts8Ret = BSD_ERROR;\n\t\n\tif (socket >= 0 && (gastrSockets[socket].bIsUsed == 1)) {\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tgastrSockets[socket].u16SessionID =0;\n\t\ts8Ret = close(socket);\n\t\tif (s8Ret != SOCK_ERR_NO_ERROR) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_SUCCESS);\n\t\t\ts8Ret = BSD_SUCCESS;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 33.32098186368441}, {"code": "int BSD_close(int socket){\n\tint s8Ret = BSD_ERROR;\n\ttstrSocket *pstrSock;\n\tif((socket >= 0) && (socket < MAX_SOCKET) && (gastrSockets[socket].bIsUsed == 1)) {\n\t\tpstrSock = &gastrSockets[socket];\n\t\tpstrSock->bIsUsed = 0;\n\t\tpstrSock->u16SessionID = 0;\n\t\tif(pstrSock->u8SSLFlags & SSL_FLAGS_ACTIVE) {\n\t\t\ts8Ret = close(socket);\n\t\t} else {\n\t\t\ts8Ret = close(socket);\n\t\t}\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t} else {\n\t\t\ts8Ret = BSD_SUCCESS;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 42.306239750285656}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint ret = BSD_ERROR;\n\tsint8 s8Err = SOCK_ERR_NO_ERROR;\n\n\ts8Err = listen(socket, backlog);\n\tif(s8Err == SOCK_ERR_NO_ERROR)\n\t{\n\t\tret = BSD_SUCCESS;\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(s8Err);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 30.1007557521037}, {"code": "int BSD_listen(int socket, int backlog){\n\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret != SOCK_ERR_NO_ERROR) {\n\t\tBSD_setErrno(ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 26.831645870351228}, {"code": "int BSD_listen(int socket, int backlog){\n\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tret = BSD_ERROR;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 23.244168148552006}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 12.182170557362593}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint\t\t\t\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\tstruct sockaddr_in\t\t\t\tstSockAddr;\n\tstruct bsd_sockaddr_in\t\t\tstBSDSockAddr;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(addr != NULL)\n\t\t{\n\t\t\tif(addrlen != NULL)\n\t\t\t{\n\t\t\t\tif(gastrSockets[socket].u8Protocol == BSD_SOCK_STREAM)\n\t\t\t\t{\n\t\t\t\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t}\n\t}\n\t\n\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t{\n\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t\n\t\tmemset(&stSockAddr, 0, sizeof(struct sockaddr_in));\n\t\tstSockAddr.sin_family = gastrSockets[socket].u8Domain;\n\t\tstSockAddr.sin_port = gastrSockets[socket].u16DataPort;\n\t\tstSockAddr.sin_addr.s_addr = gastrSockets[socket].u32IPAddr;\n\t\t\n\t\ts8Ret = accept(socket, (struct sockaddr *)&stSockAddr, (uint8 *)addrlen);\n\t\t\n\t\tif(s8Ret >= 0)\n\t\t{\n\t\t\tstBSD", "CodeBleu_score": 39.79754641561296}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(gastrSockets[socket].u8Protocol == SOCK_PROTO_TCP)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 21.490482004795822}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch = time(NULL);\n   if (epoch == 0) {\n      debug_printError(\"MQTT: Time is not valid\");\n      return;\n   }\n   updateJWT(epoch);\n   MQTT_CLIENT_connect(&mqttClient, mqttServer, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttSubscribeTopic, mqttQoS, mqttKeepAliveInterval);\n   debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttServer, mqttPort);\n   mqttSubscribe = true;\n}", "CodeBleu_score": 51.01256781460046}, {"code": "static void connectMQTT(){\n\tuint32_t epoch;\n   uint8_t res = time(&epoch);\n   if (res == 0) {\n      debug_printInfo(\"MQTT: time is valid\");\n   } else {\n      debug_printError(\"MQTT: time is invalid\");\n   }\n   updateJWT(epoch);\n\n   MQTT_CLIENT_connect(mqttClient, mqttPassword, mqttServer, mqttPort, mqttTopic, mqttSubscribe);\n   debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttServer, mqttPort);\n}", "CodeBleu_score": 43.12116712156452}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = time(NULL);\n   if (epoch < UNIX_OFFSET) {\n      debug_printError(\"MQTT: Time is invalid\");\n      return;\n   }\n   updateJWT(epoch);\n   debug_printInfo(\"MQTT: Connecting...\");\n   MQTT_CLIENT_connect(MQTT_CLIENT_connect_callback, (void*)&mqttConnected);\n}", "CodeBleu_score": 50.69798970039716}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tdebug_printInfo(\"Disconnecting from cloud service\");\n   if (mqttState == CONNECTED) {\n      MQTT_GetClientConnectionInfo(&mqttConnectionInfo);\n      MQTT_Disconnect(&mqttConnectionInfo);\n   }\n}", "CodeBleu_score": 52.08822911734754}, {"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      MQTT_GetClientConnectionInfo(&connectionInfo);\n      MQTT_Disconnect(&connectionInfo);\n      debug_printError(\"MQTT disconnected\");\n   }\n}", "CodeBleu_score": 54.82681507462364}, {"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      MQTT_GetClientConnectionInfo(&clientConnectionInfo);\n      MQTT_Disconnect(&clientConnectionInfo);\n   }\n   debug_printError(\"disconnected from cloud\");\n}", "CodeBleu_score": 52.58572048594324}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8 ret = M2M_ERR_FAIL;\n\tm2m_wifi_default_connect();\n\tif (passed_wifi_creds) {\n\t\tm2m_wifi_connect(ssid, strlen(ssid), WIFI_SEC_WPA_PSK, pass, M2M_WIFI_CH_ALL);\n\t}\n\telse {\n\t\tm2m_wifi_connect(ssid, strlen(ssid), WIFI_SEC_WPA_PSK, pass, M2M_WIFI_CH_ALL);\n\t}\n\twhile (1) {\n\t\tm2m_wifi_handle_events(NULL);\n\t\tif ((wifi_status == M2M_WIFI_CONNECTED) || (wifi_status == M2M_WIFI_DISCONNECTED)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (wifi_status == M2M_WIFI_CONNECTED) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.23479383280007}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8\t\t\t\t\t\ts8Ret;\n\tm2m_wifi_init_param_t\t\tparam;\n\tm2m_wifi_default_param_t\tdefault_param;\n\tuint8_t\t\t\t\t\t\tu8IsDefaultCreds = 0;\n\t\n\tif (passed_wifi_creds == 0) {\n\t\t// Use default credentials\n\t\tu8IsDefaultCreds = 1;\n\t}\n\t\n\t/* Initialize the Wi-Fi parameters structure. */\n\tm2m_memset((uint8_t*)&param, 0, sizeof(param));\n\t\n\t/* Initialize the Wi-Fi default parameters structure. */\n\tm2m_memset((uint8_t*)&default_param, 0, sizeof(default_param));\n\t\n\t/* Set the Wi-Fi parameters structure members. */\n\tparam.pfAppWifiCb = wifi_cb;\n\t\n\t/* Set the Wi-Fi default parameters structure members. */\n\tdefault_param.strApId[0] = '\\0';\n\tdefault_param.strPassphrase[0] = '\\0';\n\t\n\tif (u8IsDefaultCreds) {\n\t\t/* Attempt to connect to the default access point. */\n\t\ts8Ret = m2m_wifi_default_connect(&default_param);\n\t\t\n\t\tif (s8Ret == M2M_ERR_MEM_ALLOC) {\n\t\t\t/* Error! No memory available. */\n\t\t\tdebug_printError(\"[wifi_connectToAp] ERROR! No memory available.", "CodeBleu_score": 41.623917006559864}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8 ret;\n\tif (passed_wifi_creds) {\n\t\tret = m2m_wifi_connect((char *)wifi_creds.ssid, (uint8)strlen((char *)wifi_creds.ssid), wifi_creds.security_type, (void *)wifi_creds.psk, M2M_WIFI_CH_ALL);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret != M2M_SUCCESS) {\n\t\tdebug_printError(\"[WiFi] Failed to connect to WiFi network. Error code: %d\", ret);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 57.757425408660936}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst client = generateClient();\n  const response = await client.graphql(\n    gql`\n      query {\n        listSensors {\n          items {\n            sensorId\n            sensorName\n            sensorDescription\n            sensorLat\n            sensorLong\n            sensorData\n            sensorDataType\n            sensorDataUnit\n            sensorLocation\n            sensorGeo {\n              latitude\n              longitude\n            }\n          }\n        }\n      }\n    `\n  );\n  if (response.data.listSensors.items) {\n    console.log(\"Retrieved sensors: \", response.data.listSensors.items);\n    response.data.listSensors.items.forEach((sensor) => {\n      CreateSensorMarker(map, sensor);\n    });\n  }\n}", "CodeBleu_score": 36.400366765679514}, {"code": "async function DisplaySensors(map){\n\t// Create an Apollo GraphQL client\n    const client = generateClient();\n    // Send a GraphQL query to retrieve sensor data\n    const response = await client.query({\n        query: gql`\n            query {\n                listSensors {\n                    id\n                    name\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        `\n    });\n    // Log the response\n    console.log(response);\n    // If the response contains data\n    if (response.data) {\n        // Log the retrieval of sensors\n        console.log(\"Retrieved sensors\");\n        // Iterate through each sensor\n        response.data.listSensors.forEach(sensor => {\n            // Create a marker\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n            // Add the marker to the map\n            new Marker({element: marker})\n                    .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                    .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 57.1782023078167}, {"code": "async function DisplaySensors(map){\n\tconst client = generateClient();\n  const response = await client.graphql(\n    gql`\n      query {\n        listSensors {\n          id\n          name\n          geo {\n            latitude\n            longitude\n          }\n        }\n      }\n    `\n  );\n  console.log(response.data.listSensors);\n  if (response.data.listSensors.length > 0) {\n    console.log(\"Sensors retrieved\");\n    response.data.listSensors.forEach((sensor) => {\n      const marker = document.createElement(\"div\");\n      marker.className = \"marker\";\n      marker.id = sensor.id;\n      marker.innerHTML = sensor.name;\n      new Marker({ element: marker })\n        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 59.111217014101925}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tlet marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = '1px solid black';\n  return marker;\n}", "CodeBleu_score": 44.66981919318431}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tlet marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = \"red\";\n    marker.style.border = \"2px solid black\";\n    return marker;\n}", "CodeBleu_score": 44.80498460306078}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensorMarker\";\n    marker.style.backgroundColor = sensor.color;\n    marker.style.border = \"1px solid black\";\n    return marker;\n}", "CodeBleu_score": 45.904279103669}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import mfa module %s: %s. Please install it with 'pip3 install %s'\",\n            module_name,\n            err,\n            module_path,\n        )\n        raise\n    if not hasattr(module, \"MFA_MODULE_REQUIREMENTS\"):\n        return module\n    if module.MFA_MODULE_REQUIREMENTS in MFA_MODULE_REQUIREMENTS:\n        return module\n    MFA_MODULE_REQUIREMENTS.add(module.MFA_MODULE_REQUIREMENTS)\n    try:\n        await requirements.async_process_requirements(\n            hass, module.MFA_MODULE_REQUIREMENTS, skip_pip=SKIP_PIP\n        )\n    except HomeAssistantError as err:\n        _LOGGER.error(\n            \"Unable to install the requirements for mfa module %s: %s\",\n            module_name,\n            err,\n        )\n        raise\n    return module\n\n", "CodeBleu_score": 48.79774472717082}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except (ModuleNotFoundError, ImportError) as err:\n        _LOGGER.error(\"Unable to import %s: %s\", module_path, err)\n        raise HomeAssistantError(\n            f\"Unable to import {module_name} module. See the log for details.\"\n        ) from err\n    if module.REQUIREMENTS:\n        if not hass.config.skip_pip:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n        if not hass.data.get(DATA_MFA_MODULES_IN_PROGRESS, set()).intersection(\n            module.REQUIREMENTS\n        ):\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n    return module\n\n", "CodeBleu_score": 51.69619520545255}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tif not hass.config.skip_pip:\n        if not hass.config.skip_ensure_config:\n            await hass.config_entries.flow.async_ensure_config_entry_domain(\n                domain=module_name, handler_domain=HANDLER_DOMAIN\n            )\n        if not hasattr(hass, \"data\"):\n            hass.data = {}\n        if not hasattr(hass.data, \"mfa_modules\"):\n            hass.data.mfa_modules = {}\n        if not hasattr(hass.data.mfa_modules, \"processed\"):\n            hass.data.mfa_modules.processed = set()\n        if not hasattr(hass.data.mfa_modules, \"processed_lock\"):\n            hass.data.mfa_modules.processed_lock = asyncio.Lock()\n        if not hasattr(hass.data.mfa_modules, \"processed_lock\"):\n            hass.data.mfa_modules.processed_lock = asyncio.Lock()\n        async with hass.data.mfa_modules.processed_lock:\n            if module_name in hass.data.mfa_modules.processed:\n                return await async_import_module(hass, module_name)\n        try:\n            requirements_file = f\"{module_name}/requirements.txt\"\n            reqs = await hass.async_add_executor_job(\n                requirements.check_config_file, requirements_file\n            )\n            if reqs:\n                await requirements.async_process_requirements(\n                    hass, module_name, reqs\n                )\n        except HomeAssistantError as err:\n            _LOGGER.error(\n                \"Error processing requirements for %s: %s\", module_name, err\n            )\n    return await async_import_module(hass, module_name)\n\n", "CodeBleu_score": 34.68318364015427}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t# Extract the PIN from the setup data\n    pin = setup_data.get(\"pin\")\n    # Check if the user already has an entry in the data list\n    if not self._data.get(user_id):\n        # If no entry exists, add a new entry with the user ID and PIN to the data list\n        self._data[user_id] = pin\n    else:\n        # If an entry exists, update the PIN\n        self._data[user_id] = pin", "CodeBleu_score": 31.514020387449794}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif user_id in self.data:\n        self.data[user_id] = setup_data.get(\"pin\")\n    else:\n        self.data[user_id] = setup_data.get(\"pin\")\n\n    return True", "CodeBleu_score": 32.41934118287629}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data\n    else:\n        self.data[user_id] = {\"pin\": setup_data}\n    return True\n\n\n\n\n", "CodeBleu_score": 31.058237379239902}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tif not self._user_settings:\n        if not (data := await self._store.async_load()):\n            data = {}\n        self._user_settings = {}\n        for user_id in data:\n            self._user_settings[user_id] = NotifySetting(\n                self.hass, user_id, data[user_id]\n            )\n\n", "CodeBleu_score": 25.3382255617916}, {"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._user_settings is None:\n            if not (data := await self._store.async_load()):\n                data = {}\n\n            self._user_settings = {}\n            for user_id, user_data in data.items():\n                self._user_settings[user_id] = NotifySetting(\n                    user_id,\n                    user_data.get(\"notify_mode\"),\n                    user_data.get(\"notify_mode_email\"),\n                    user_data.get(\"notify_mode_push\"),\n                    user_data.get(\"notify_mode_sms\"),\n                    user_data.get(\"notify_mode_sms_phone\"),\n                )\n\n", "CodeBleu_score": 34.178591600980205}, {"code": "async def _async_load(self) -> None\n\tif self._user_settings is not None:\n        return\n\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n\n        self._user_settings = {}\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = NotifySetting(\n                self.hass, user_id, user_data\n            )\n\n", "CodeBleu_score": 43.93618124448539}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load(user_id)\n    user_settings = self._users_data.get(user_id)\n    if not user_settings:\n        return False\n    return await async_add_executor_job(\n        self._validate, user_id, user_settings, user_input\n    )\n\n", "CodeBleu_score": 45.76007322230966}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t# Ensure user settings are loaded\n    await self.async_load()\n    # Retrieve the notification settings for the specified user\n    settings = self._users_data.get(user_id)\n    # If no settings are found for the user, return False\n    if not settings:\n        return False\n    # Validate the user input by verifying the OTP using an executor job\n    return await self._async_verify_otp(settings, user_input)\n\n", "CodeBleu_score": 36.187401215378515}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self.async_load(user_id)\n    user_settings = self._users_data.get(user_id)\n    if user_settings is None:\n        return False\n    return await self.async_validate_executor(user_id, user_input)\n\n", "CodeBleu_score": 40.68236473990675}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)", "CodeBleu_score": 64.3044905491215}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.3044905491215}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.devices.get(entity.device_id)\n    if device is None:\n        return None\n    area = perm_lookup.areas.get(device.area_id)\n    if area is None:\n        return None\n    return area_dict.get(area.id)\n\n\n\n\n", "CodeBleu_score": 60.06086611735524}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t# Merge multiple policies into one.\n    #\n    # If there are multiple policies with the same category, we recursively\n    # merge each key in the category.\n    #\n    # The most permissive policy wins.\n    #\n    # This means we order it like this:\n    # True > Dict > None\n    #\n    # True: allow everything\n    # Dict: specify more granular permissions\n    # None: no opinion\n    #\n    # If there are multiple sources with a dict as policy, we recursively\n    # merge each key in the source.\n\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for source in policies:\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 51.69311376678636}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tpolicy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for cat in p:\n            if cat in seen:\n                continue\n            seen.add(cat)\n            policy[cat] = _merge_policies([p[cat], policy.get(cat)])\n    return policy\n\n", "CodeBleu_score": 50.701817176917615}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn _merge_policies(policies)\n\n", "CodeBleu_score": 7.36791490198009}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, provider)\n    except (ModuleNotFoundError, ImportError):\n        _LOGGER.error(\n            \"Unable to find/import auth provider %s\",\n            provider,\n            exc_info=True,\n        )\n        raise HomeAssistantError(\n            f\"Unable to find/import auth provider {provider}\"\n        ) from None\n    if hasattr(module, \"REQUIREMENTS\"):\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, module.__name__\n        )\n    return module\n\n", "CodeBleu_score": 35.21128269153429}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to find provider %s. See the log above for \"\n            \"more information\",\n            provider,\n        )\n        raise HomeAssistantError() from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements.async_process_requirements(hass, module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 27.663777322402627}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, provider)\n    except (ModuleNotFoundError, ImportError) as err:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError() from err\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 30.635853343254215}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data", "CodeBleu_score": 94.95289363431134}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.normalize_username(username)\n    dummy_hash = b'$2b$12$' + ''.join([random.choice(string.ascii_letters + string.digits) for _ in range(53)])\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode('utf-8'), base64.b64decode(user.password)):\n                return\n            else:\n                raise InvalidAuth\n    if bcrypt.checkpw(password.encode('utf-8'), dummy_hash):\n        raise InvalidAuth\n\n\n\n\n", "CodeBleu_score": 39.52031096301374}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t# normalize the provided username\n    username = self.normalize_username(username)\n\n    # initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.kdf(\n        password=b\"\",\n        salt=self.salt,\n        desired_key_bytes=self.bcrypt_rounds,\n        hash_name=self.bcrypt_hasher,\n    )\n\n    # iterate through all users to find a matching username\n    for user in self.users:\n        if user.username == username:\n            # decode the stored password hash\n            stored_hash = base64.b64decode(user.password)\n\n            # use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                # if the passwords do not match, raise an \"InvalidAuth\" exception\n                raise InvalidAuth()\n\n    # if no matching user is found, perform a dummy hash check and raise an \"InvalidAuth\" exception\n    if not bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth()\n\n\n\n\n", "CodeBleu_score": 40.106078675183745}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.normalize_username(username)\n    dummy_hash = b'$2b$12$RwCg03ZYP6vD3bD38Q6sle'\n    for user in self.users:\n        if user['username'] == username:\n            stored_hash = user['password']\n            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n                return\n            else:\n                raise InvalidAuth\n    else:\n        if bcrypt.checkpw(password.encode('utf-8'), dummy_hash):\n            raise InvalidAuth\n        else:\n            raise InvalidAuth\n\n\n\n\n", "CodeBleu_score": 37.73829416451724}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tself.normalize_username(username)\n\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n\n    raise InvalidUser(\"user_not_found\")\n\n\n\n\n", "CodeBleu_score": 28.25081470979619}, {"code": "def async_remove_auth(self, username: str) -> None\n\tusername = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(self.messages[\"user_not_found\"])\n\n", "CodeBleu_score": 30.450166005959872}, {"code": "def async_remove_auth(self, username: str) -> None\n\tself.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(f\"{username} user not found\")\n\n\n\n\n", "CodeBleu_score": 27.61593536312977}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self._async_load_data()\n    if credentials.data[CONF_USERNAME] not in self._data:\n        return\n    del self._data[credentials.data[CONF_USERNAME]]\n    await self._async_save_data()\n\n", "CodeBleu_score": 47.513169824728855}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.data[\"username\"])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 54.80424260236948}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_initialize()\n\n    if credentials.id in self._data:\n        del self._data[credentials.id]\n\n    await self.async_save()\n\n", "CodeBleu_score": 41.47298938099835}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n            joined.add(thread)\n            continue\n        except RuntimeError:\n            pass\n        try:\n            ident = thread.ident\n        except AttributeError:\n            joined.add(thread)\n            continue\n        if ident is None:\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, ident)\n        try:\n            thread.join()\n            joined.add(thread)\n            continue\n        except RuntimeError:\n            pass\n        with contextlib.suppress(SystemExit):\n            async_raise(ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 49.36066072726756}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        try:\n            with contextlib.suppress(TypeError):\n                thread.join(timeout=timeout)\n            if not thread.is_alive():\n                joined.add(thread)\n                continue\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            thread.join()\n            joined.add(thread)\n        except Exception:\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 53.721673816837445}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            try:\n                thread.join(timeout)\n            except Exception:\n                pass\n            if not thread.is_alive():\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    with contextlib.suppress(Exception):\n        for thread in threads - joined:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 50.64299194813686}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t# Get all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if thread.is_alive() and not thread.daemon and thread is not threading.main_thread()]\n    # Calculate timeout for each thread\n    timeout = _DEADLOCK_SAFE_SHUTDOWN_TIMEOUT / len(threads)\n    # Join each thread\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            _LOGGER.warning(\"Failed to join thread %s\", thread)\n\n\n\n\n", "CodeBleu_score": 34.58686322087136}, {"code": "def deadlock_safe_shutdown() -> None\n\tshutdown_timeout: int = 30\n    threads = threading.enumerate()\n    threads = [thread for thread in threads if thread.is_alive() and not thread.daemon and thread is not threading.main_thread]\n    if not threads:\n        return\n    timeout = shutdown_timeout / len(threads)\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception:\n            _LOGGER.warning(\"Failed to join thread %s\", thread.name)\n\n\n\n\n", "CodeBleu_score": 46.382568454886346}, {"code": "def deadlock_safe_shutdown() -> None\n\t# Get the total shutdown timeout.\n    total_timeout: float = _get_total_timeout()\n    # Get the number of threads that are not the main thread and not daemon threads.\n    non_main_non_daemon_threads: int = _get_non_main_non_daemon_thread_count()\n    # Calculate the timeout for each thread.\n    timeout: float = total_timeout / non_main_non_daemon_threads\n    # Iterate over the non-main, non-daemon, alive threads.\n    for thread in threading.enumerate():\n        # If the thread is not the main thread and not daemon.\n        if not thread.is_alive() or thread is threading.main_thread() or thread.daemon:\n            # Skip the thread.\n            continue\n        # Try to join the thread within the timeout.\n        try:\n            thread.join(timeout=timeout)\n        # If the thread cannot be joined within the timeout.\n        except RuntimeError:\n            # Log a warning.\n            _LOGGER.warning(f\"Failed to join thread {thread.name} within {timeout} seconds.\")\n\n", "CodeBleu_score": 27.841499167808482}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started or self._remaining_setups:\n        async_dispatcher_send_internal(self._hass, self._signal, remaining_with_setup_started)\n    self._remaining_setups = remaining_with_setup_started", "CodeBleu_score": 54.101127092857524}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t# If there are setups remaining or the previous state was not empty,\n    # send an internal dispatcher signal with the remaining setups.\n    if remaining_with_setup_started or self._remaining_setups:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n\n    # Update the internal flag to reflect whether there are remaining setups.\n    self._remaining_setups = bool(remaining_with_setup_started)", "CodeBleu_score": 53.852614097266496}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started or self._remaining_setups:\n        self._remaining_setups = remaining_with_setup_started\n        async_dispatcher_send_internal(self._hass, self._signal)\n    else:\n        self._remaining_setups = None", "CodeBleu_score": 45.06845782398835}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif config.get(\"validate_bluetooth\", True):\n        integrations_to_validate = {\n            domain: integration\n            for domain, integration in integrations.items()\n            if integration.manifest.get(\"bluetooth\")\n        }\n\n        if integrations_to_validate:\n            current_content = fp.read(config.bluetooth_path)\n            new_content = generate_and_validate(integrations_to_validate)\n\n            if current_content != new_content:\n                config.add_error(\n                    \"bluetooth\",\n                    \"bluetooth.py is not up to date. Please run `python3 -m homeassistant bluetooth` to update it.\",\n                    fixable=True,\n                    fixer=lambda: fp.write(config.bluetooth_path, new_content),\n                )\n\n    else:\n        if not config.get(\"bluetooth_path\").exists():\n            config.add_error(\n                \"bluetooth\",\n                \"bluetooth.py is not found. Please run `python3 -m homeassistant bluetooth` to generate it.\",\n                fixable=True,\n                fixer=lambda: fp.write(config.bluetooth_path, generate_and_validate()),\n            )\n\n        else:\n            with open(config.bluetooth_path) as file:\n                current_content = file.read()\n\n            if current_content != generate_and_validate():\n                config.add_error(\n                    \"bluetooth\",\n                    \"bluetooth.py is not up to date. Please run `python3 -m homeassistant bluetooth` to update it.\",\n                    fixable=True,\n                    fixer=lambda: fp.write(config.bluetooth_path, generate_and_validate()),\n                )\n\n", "CodeBleu_score": 37.386366231829236}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif not config.get(\"validate_bluetooth\"):\n        return\n\n    generated_bluetooth = generate_and_validate(integrations)\n\n    # Check if the generated bluetooth.py file is different from the current one\n    bluetooth_file = os.path.join(config.root, \"homeassistant\", \"components\", \"bluetooth.py\")\n    if not os.path.exists(bluetooth_file):\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py file not found\",\n            \"The file bluetooth.py was not found in the Home Assistant components folder. Please check if you have the latest version of Home Assistant installed.\",\n        )\n        return\n\n    with open(bluetooth_file, \"r\") as fp:\n        current_bluetooth = fp.read()\n\n    if current_bluetooth != generated_bluetooth:\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date\",\n            \"The file bluetooth.py is not up to date. Please run `ha config bluetooth` to regenerate the file.\",\n            fixable=True,\n        )\n\n", "CodeBleu_score": 47.86410322069665}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif not config.get(\"validate_bluetooth\"):\n        return\n\n    bluetooth_file = config.get(\"bluetooth_file\")\n    if not bluetooth_file:\n        return\n\n    # Generate and validate\n    generated = generate_and_validate(integrations)\n\n    # Read and validate\n    with open(bluetooth_file, \"r\") as fp:\n        read = fp.read()\n\n    if read == generated:\n        return\n\n    # Add error\n    config.add_error(\n        \"bluetooth\",\n        f\"The content of {bluetooth_file} does not match the generated content.\",\n        fixable=True,\n        fixer=lambda: open(bluetooth_file, \"w\").write(generated),\n    )\n\n", "CodeBleu_score": 46.979945301079674}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tvar e struct {\n\t\tError string `json:\"error\"`\n\t}\n\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.DropboxTokenEndpoint)\n\n\tif e.Error != \"\" {\n\t\tlogger.Info(\"Dropbox refresh token request failed\",\n\t\t\tzap.String(\"error\", e.Error),\n\t\t\tzap.String(\"response\", resp.AccessToken),\n\t\t)\n\t\treturn errors.New(e.Error)\n\t}\n\n\td.AccessToken = resp.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 61.782793987179744}, {"code": "func (d *Dropbox) refreshToken() error{\n\tresp := oauth2.TokenResponse{}\n\te := base.ErrorResponse{}\n\terr := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.TokenURL)\n\tif err != nil {\n\t\tlogger.Info(fmt.Sprintf(\"An error occurred while refreshing the access token: %v\", err))\n\t\treturn err\n\t}\n\tif e.Error.Code != 0 {\n\t\tlogger.Info(fmt.Sprintf(\"An error occurred while refreshing the access token: %s\", e.Error.Message))\n\t\treturn err\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 64.79667872892841}, {"code": "func (d *Dropbox) refreshToken() error{\n\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.OAuth2TokenEndpoint); err != nil {\n\t\tlogger.Info(fmt.Sprintf(\"Failed to refresh access token for Dropbox: %v\", err))\n\t\treturn err\n\t}\n\td.AccessToken = resp.AccessToken\n\tlogger.Info(fmt.Sprintf(\"Refreshed access token for Dropbox: %s\", d.AccessToken))\n\treturn nil\n}", "CodeBleu_score": 60.98372977507911}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\treq := d.request(url, method, callback)\n\tif req == nil {\n\t\treturn nil, fmt.Errorf(\"request: %w\", base.ErrNotAuthorized)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\terr := req.Execute()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request: %w\", err)\n\t}\n\treturn req.Bytes(), nil\n}", "CodeBleu_score": 32.36229511580466}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\treq, err := d.newRequest(url, method, callback)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn d.doRequest(req, resp)\n}", "CodeBleu_score": 20.66760059208849}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\treq := d.client.R()\n\treq.SetError(GoogleDriveError{})\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-Offset\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-Checksum\", \"crc32c\")\n\treq.SetHeader(\"X-Goog-Upload-Checksum-Algorithm\", \"crc32c\")\n\treq.SetHeader(\"X-Goog-Upload-File-Name\", \"filename\")\n\treq.SetHeader(\"X-Goog-Upload-Raw-Size\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-Mime-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Goog-Upload-Chunk-Granularity\", \"1048576\")\n\treq.SetHeader(\"X-Goog-Upload-Metadata\", \"{\"+\n\t\t\"\\\"name\\\": \\\"\"+d.file.Name+\"\\\",\"+\n\t\t\"\\\"parents\\\": [\\\"\"+d.file.Parent+\"\\\"]\"+\n\t\t\"}\")\n\treq.SetHeader(\"X-Goog-Upload-Protocol\", \"resumable\")\n\treq.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\treq.SetHeader(\"X-Goog-Upload-Content-Length\", strconv.Itoa(d.file.Size))\n\treq.SetHeader(\"X-Goog-Upload-Offset\", \"0\")\n\treq.SetHeader(\"X-Goog-Upload-Checksum\", \"crc32c\")\n\treq.SetHeader(\"X-Goog-Upload-Checksum-Algorithm\", \"crc32c\")", "CodeBleu_score": 34.371437740350885}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn model.ErrCanceled\n\t\t}\n\t\treq := d.request(ctx, \"PATCH\", url, nil)\n\t\tif err := req.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx).Do(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t\tif finish >= stream.GetSize() {\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 48.741562357219784}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(1024 * 1024 * 5)\n\tfinish := int64(0)\n\tfor {\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn model.ErrCanceled\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request(ctx, \"PUT\", url, nil)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tif err := req.Do(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.08773755192466}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tif stream.GetSize() == 0 {\n\t\treturn errors.New(\"the file size is 0\")\n\t}\n\tchunkSize := int64(1024 * 1024 * 10)\n\tfinish := int64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif finish >= stream.GetSize() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\t\tchunkSize = stream.GetSize() - finish\n\t\t\t}\n\t\t\treq := d.request(http.MethodPut, url, nil).SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tif err := req.Do(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t}\n\t}\n}", "CodeBleu_score": 56.61635230365529}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req UmountStorageRequest\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(nil))\n}", "CodeBleu_score": 39.47926377621814}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn common_err.GetMsg(ctx, err.Error())\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(ctx, \"mount_point is empty\")\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn common_err.GetMsg(ctx, err.Error())\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn common_err.GetMsg(ctx, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 38.74975299846392}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBadRequest))\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBadRequest))\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess))\n}", "CodeBleu_score": 43.71363288459859}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrNoPath))\n\t}\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// Return the file\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.63738557619377}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.78814250136637}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filePath\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.958101017736105}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tvar msg map[string]string\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn common_err.GetMsg(ctx, err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, msg); err != nil {\n\t\treturn common_err.GetMsg(ctx, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"success\"})\n}", "CodeBleu_score": 48.48745099299702}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, make(map[string]string))\n}", "CodeBleu_score": 49.66166922271387}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 50.885609796443006}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Make sure the message sending service is running\n\tgo service.SendMeg()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Message type:\", ws.MessageType())\n\t\tfmt.Println(\"Message:\", string(msg))\n\t}\n}", "CodeBleu_score": 48.385671447219046}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections.\n\twsConnsMutex.Lock()\n\twsConns = append(wsConns, ws)\n\twsConnsMutex.Unlock()\n\n\t// Ensure the message sending service is running.\n\tgo service.SendMeg()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, p, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\n\", p)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\twsConnsMutex.Lock()\n\twsConns = wsConns[:len(wsConns)-1]\n\twsConnsMutex.Unlock()\n\n\t// Close the WebSocket connection.\n\terr = ws.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.39381504150719}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tupGrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool { return true },\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tservice.SendMeg <- ws\n\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error:\", err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"recv: %s\", msg)\n\t}\n}", "CodeBleu_score": 40.833952793790715}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Create a new \"System\" service and get the system hardware information.\n\tsystemService := service.MyService.System()\n\thardwareInfo, err := systemService.GetSystemHardwareInfo()\n\n\t// If there is an error, return the error message.\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Return the hardware information.\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}", "CodeBleu_score": 19.20305522371884}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tvar (\n\t\tcpuInfo []byte\n\t\terr     error\n\t)\n\n\tif cpuInfo, err = service.MyService.System().GetCpuInfo(); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(http.StatusInternalServerError, err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, struct {\n\t\tArchitecture string `json:\"architecture\"`\n\t\tModel        string `json:\"model\"`\n\t\tCpuInfo      string `json:\"cpu_info\"`\n\t}{\n\t\tArchitecture: runtime.GOARCH,\n\t\tModel:        runtime.GOOS,\n\t\tCpuInfo:      string(cpuInfo),\n\t})\n}", "CodeBleu_score": 34.07922676849691}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get system hardware information\n\tsystemHardwareInfo, err := service.MyService.System().GetSystemHardwareInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(ctx, err))\n\t}\n\n\t// Return system hardware information\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 19.53885401225367}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t// Get the services\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate the services based on running status\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\t// Return the results\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.15858310780028}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0, len(services))\n\tnotRunning := make([]string, 0, len(services))\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 69.62647770932301}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar runningServices []string\n\tvar notRunningServices []string\n\tfor _, service := range services {\n\t\tif service.Status == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 65.67391452273921}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Serialize message values to JSON strings\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message values to JSON strings\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), &messaging.PublishEventRequest{\n\t\tName: name,\n\t\tData: jsonMessage,\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response status code if it's not OK\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event to message bus\",\n\t\t\tzap.String(\"status_code\", response.StatusCode),\n\t\t\tzap.String(\"status\", response.Status),\n\t\t\tzap.Any(\"response\", response),\n\t\t)\n\t}\n}", "CodeBleu_score": 46.07006016888847}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tmessageBytes, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to marshal message\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), &notify.PublishEventWithResponseRequest{\n\t\tName:    name,\n\t\tMessage: messageBytes,\n\t})\n\tif err != nil {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.String(\"status\", response.Status), zap.String(\"body\", string(response.Body)))\n\t}\n}", "CodeBleu_score": 41.67314144437746}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tevent := &event.Event{\n\t\tName: name,\n\t\tData: message,\n\t}\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to serialize message\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), event)\n\tif err != nil {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.String(\"response_status\", response.Status), zap.String(\"response_body\", string(response.Body)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 45.36292140000538}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(c.ctx, c.client)\n}", "CodeBleu_score": 7.2526694871159}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Create a new client with responses.\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Attempt to retrieve the message bus address.\n\taddress, err := c.GetMessageBusAddress()\n\tif err != nil {\n\t\t// Set the server to the default error message.\n\t\tclient.Server = \"http://localhost:8080\"\n\t} else {\n\t\t// Set the server to the retrieved address.\n\t\tclient.Server = address\n\t}\n\n\t// Return the initialized client.\n\treturn client\n}", "CodeBleu_score": 34.484460962510575}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tclient := message_bus.NewClientWithResponses(c.config.MessageBus.URL, c.config.MessageBus.Token)\n\tif client.Server != nil {\n\t\treturn client\n\t}\n\n\tclient.Server = &message_bus.Server{\n\t\tAddress: \"http://localhost:8080\",\n\t\tToken:   \"no-token\",\n\t}\n\n\treturn client\n}", "CodeBleu_score": 33.44621269139931}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 59.20190775538}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 50.9153703683881}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != \"\" {\n\t\treturn strings.Split(ip, \",\")[0]\n\t}\n\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 55.08788623834875}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\tmodulesDirPath := filepath.Join(c.systemPath, \"modules\")\n\tentryFilePath := filepath.Join(c.systemPath, \"entry.json\")\n\tif !utils.IsExist(modulesDirPath) {\n\t\tlogger.Error(\"modules directory not exist\")\n\t\treturn\n\t}\n\tif !utils.IsExist(entryFilePath) {\n\t\terr := os.WriteFile(entryFilePath, []byte(\"[]\"), 0644)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"create entry file failed\")\n\t\t\treturn\n\t\t}\n\t}\n\tvar entryFile []byte\n\tentryFile, err := os.ReadFile(entryFilePath)\n\tif err != nil {\n\t\tlogger.Error(\"read entry file failed\")\n\t\treturn\n\t}\n\tvar entryList []map[string]interface{}\n\terr = json.Unmarshal(entryFile, &entryList)\n\tif err != nil {\n\t\tlogger.Error(\"unmarshal entry file failed\")\n\t\treturn\n\t}\n\tmoduleDirList, err := os.ReadDir(modulesDirPath)\n\tif err != nil {\n\t\tlogger.Error(\"read modules directory failed\")\n\t\treturn\n\t}\n\tfor _, moduleDir := range moduleDirList {\n\t\tif moduleDir.IsDir() {\n\t\t\tmoduleEntryFilePath := filepath.Join(modulesDirPath, moduleDir.Name(), \"entry.json\")\n\t\t\tif !utils.IsExist(moduleEntryFilePath) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar moduleEntryFile []byte\n\t\t\tmoduleEntryFile, err := os.ReadFile(moduleEntryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"read module entry file failed\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar moduleEntryList []map[string]interface{}\n\t\t\terr = json.Unmarshal(moduleEntryFile, &moduleEntryList)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"unmarshal module entry file failed\")\n\t\t\t\treturn", "CodeBleu_score": 44.78313235963139}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tmodulesPath := filepath.Join(c.config.Path, \"modules\")\n\tentryFilePath := filepath.Join(modulesPath, \"entry.json\")\n\n\tif err := file.IsNotExistCreateFile(entryFilePath); err != nil {\n\t\tc.logger.Error(fmt.Sprintf(\"Failed to create file %s: %s\", entryFilePath, err))\n\t\treturn\n\t}\n\n\tfiles, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tc.logger.Error(fmt.Sprintf(\"Failed to read modules directory %s: %s\", modulesPath, err))\n\t\treturn\n\t}\n\n\tvar modules []*Module\n\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tentryFilePath := filepath.Join(modulesPath, file.Name(), \"entry.json\")\n\t\t\tentryFile, err := os.ReadFile(entryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tc.logger.Error(fmt.Sprintf(\"Failed to read file %s: %s\", entryFilePath, err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar module Module\n\t\t\tif err := json.Unmarshal(entryFile, &module); err != nil {\n\t\t\t\tc.logger.Error(fmt.Sprintf(\"Failed to unmarshal file %s: %s\", entryFilePath, err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmodules = append(modules, &module)\n\t\t}\n\t}\n\n\tif len(modules) == 0 {\n\t\treturn\n\t}\n\n\tentryFile, err := json.Marshal(modules)\n\tif err != nil {\n\t\tc.logger.Error(fmt.Sprintf(\"Failed to marshal modules: %s\", err))\n\t\treturn\n\t}\n\n\tif err := os.WriteFile(entryFilePath, entryFile, 0644); err != nil {\n\t\tc.logger.Error(fmt.Sprintf(\"Failed to write file %s: %s\", entryFilePath, err))\n\t\treturn", "CodeBleu_score": 42.899014922609915}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tmodulesDirPath := filepath.Join(c.rootPath, \"modules\")\n\tentryFilePath := filepath.Join(c.rootPath, \"entry.json\")\n\tif !file.IsExist(modulesDirPath) {\n\t\tlogger.Error(fmt.Sprintf(\"modules dir %s is not exist\", modulesDirPath))\n\t\treturn\n\t}\n\tif !file.IsExist(entryFilePath) {\n\t\tlogger.Error(fmt.Sprintf(\"entry file %s is not exist\", entryFilePath))\n\t\treturn\n\t}\n\tvar entryArray []*models.Entry\n\tfiles, err := os.ReadDir(modulesDirPath)\n\tif err != nil {\n\t\tlogger.Error(\"read dir error\", zap.Error(err))\n\t\treturn\n\t}\n\tfor _, f := range files {\n\t\tif !f.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tentryFilePath := filepath.Join(modulesDirPath, f.Name(), \"entry.json\")\n\t\tif !file.IsExist(entryFilePath) {\n\t\t\tcontinue\n\t\t}\n\t\tentryBytes, err := os.ReadFile(entryFilePath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read entry file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tvar entry *models.Entry\n\t\terr = json.Unmarshal(entryBytes, &entry)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unmarshal entry file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tentryArray = append(entryArray, entry)\n\t}\n\tentryBytes, err := json.Marshal(entryArray)\n\tif err != nil {\n\t\tlogger.Error(\"marshal entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\terr = os.WriteFile(entryFilePath, entryBytes, 0644)\n\tif err != nil {\n\t\tlogger.Error(\"write entry file error\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 57.02131610019219}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t// Get a list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service.\n\tnames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names.\n\tfor _, i := range interfaces {\n\t\tfor _, name := range names {\n\t\t\t// If the interface name matches the network name,\n\t\t\t// return the MAC address.\n\t\t\tif i.Name == name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error.\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.73584519958825}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnames, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tfor _, n := range names {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching network interface found\")\n}", "CodeBleu_score": 69.71733158753285}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tfor _, n := range names {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 69.67083625182134}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\n    if (pRequest == NULL) {\n        TSC_DEBUG(\"registerRequest: Invalid request object.\n\");\n        return -1;\n    }\n\n    if (pTscObj == NULL) {\n        TSC_DEBUG(\"registerRequest: Invalid TSC object.\n\");\n        return -1;\n    }\n\n    if (pRequest->pTscObj != NULL) {\n        TSC_DEBUG(\"registerRequest: Request object already registered.\n\");\n        return -1;\n    }\n\n    if (pTscObj->pAppObj == NULL) {\n        TSC_DEBUG(\"registerRequest: TSC object has no application.\n\");\n        return -1;\n    }\n\n    // Add a reference to the request object.\n    if (taosAddRef(pRequest) != 0) {\n        TSC_DEBUG(\"registerRequest: Failed to add reference to request object.\n\");\n        return -1;\n    }\n\n    // Increment the request count for the TSC object.\n    pTscObj->requestCount++;\n\n    // Update the application's request summary.\n    pTscObj->pAppObj->totalRequestCount++;\n    pTscObj->pAppObj->currentRequestCount++;\n\n    // Update the request object's TSC object pointer.\n    pRequest->pTscObj = pTscObj;\n\n    TSC_DEBUG(\"registerRequest: Registered request %p for TSC %p.\n\", pRequest, pTscObj);\n\n    return rc;\n}", "CodeBleu_score": 39.648908842531725}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t ret = 0;\n    int32_t rc = 0;\n\n    if (pRequest == NULL) {\n        return -1;\n    }\n\n    if (pTscObj == NULL) {\n        return -1;\n    }\n\n    pRequest->pTscObj = pTscObj;\n    pRequest->pTscObj->requestCount++;\n    pRequest->requestCount = pRequest->pTscObj->requestCount;\n\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestCount++;\n        pTscObj->pAppInfo->currentRequestCount++;\n        pRequest->pTscObj->pAppInfo->currentRequestCount++;\n        pRequest->pTscObj->pAppInfo->requestCount++;\n        pRequest->pTscObj->pAppInfo->requestSummary =\n            (char *)realloc(pRequest->pTscObj->pAppInfo->requestSummary,\n                            (pRequest->pTscObj->pAppInfo->requestCount + 1) *\n                            sizeof(char));\n        if (pRequest->pTscObj->pAppInfo->requestSummary == NULL) {\n            return -1;\n        }\n        if (pRequest->pTscObj->pAppInfo->requestCount == 1) {\n            pRequest->pTscObj->pAppInfo->requestSummary[0] = '0';\n        } else {\n            pRequest->pTscObj->pAppInfo->requestSummary[pRequest->pTscObj->pAppInfo->requestCount - 2] = ',';\n        }\n        pRequest->pTscObj->pAppInfo->requestSummary[pRequest->pTscObj->pAppInfo->requestCount - 1] = '1';\n        pRequest->pTscObj->pAppInfo->requestSummary[pRequest->pTscObj->pAppInfo->requestCount] = '\\0';\n    }\n\n    rc = atomic_add_fetch_32(&pRequest->refCount, 1);\n    if (rc < 0) {\n        ret = -1;\n    }", "CodeBleu_score": 42.841596574502006}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t retVal = 0;\n    uint64_t timeNow = 0;\n    uint64_t timeDelta = 0;\n    uint64_t timeDelta2 = 0;\n    uint64_t timeDelta3 = 0;\n    uint64_t timeDelta4 = 0;\n    uint64_t timeDelta5 = 0;\n    uint64_t timeDelta6 = 0;\n    uint64_t timeDelta7 = 0;\n    uint64_t timeDelta8 = 0;\n    uint64_t timeDelta9 = 0;\n    uint64_t timeDelta10 = 0;\n    uint64_t timeDelta11 = 0;\n    uint64_t timeDelta12 = 0;\n    uint64_t timeDelta13 = 0;\n    uint64_t timeDelta14 = 0;\n    uint64_t timeDelta15 = 0;\n    uint64_t timeDelta16 = 0;\n    uint64_t timeDelta17 = 0;\n    uint64_t timeDelta18 = 0;\n    uint64_t timeDelta19 = 0;\n    uint64_t timeDelta20 = 0;\n    uint64_t timeDelta21 = 0;\n    uint64_t timeDelta22 = 0;\n    uint64_t timeDelta23 = 0;\n    uint64_t timeDelta24 = 0;\n    uint64_t timeDelta25 = 0;\n    uint64_t timeDelta26 = 0;\n    uint64_t timeDelta27 = 0;\n    uint64_t timeDelta28 = 0;\n    uint64_t timeDelta29 = 0;\n    uint64_t timeDelta30 = 0;\n    uint64_t timeDelta31 = 0;\n    uint64_t timeDelta32 = 0;\n    uint64_t timeDelta33 = 0;", "CodeBleu_score": 6.441560809874565}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar *pDb = pRequest->pDb;\n    char *pDbList = pRequest->pDbList;\n    char *pDbEnd = NULL;\n\n    if (pDb != NULL) {\n        if (strcmp(pDb, exceptDb) != 0) {\n            return true;\n        }\n    }\n\n    if (pDbList != NULL) {\n        while (pDbList != NULL) {\n            pDbEnd = strchr(pDbList, ',');\n            if (pDbEnd != NULL) {\n                *pDbEnd = '\\0';\n            }\n\n            if (strcmp(pDbList, exceptDb) != 0) {\n                return true;\n            }\n\n            pDbList = pDbEnd + 1;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 47.03778494386284}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (pRequest->pRequest->pDb) {\n        if (strcmp(pRequest->pRequest->pDb, exceptDb) != 0) {\n            return true;\n        }\n    }\n\n    if (pRequest->pRequest->pDbList) {\n        char* db = strtok(pRequest->pRequest->pDbList, \",\");\n        while (db) {\n            if (strchr(db, '.') != NULL) {\n                db = strtok(NULL, \",\");\n                continue;\n            }\n            if (strcmp(db, exceptDb) != 0) {\n                return true;\n            }\n            db = strtok(NULL, \",\");\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 47.637880566527045}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (strcmp(pRequest->pDb, exceptDb) != 0) {\n        return false;\n    }\n\n    for (int i = 0; i < pRequest->nDb; i++) {\n        if (strcmp(pRequest->pDbArray[i], exceptDb) != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 46.92150312092909}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\treturn (code == SYS_AGENT_NOT_AVAILABLE) &&\n           (msgType != TMSG_RPC_REPLY_DATA) &&\n           (msgType != TMSG_RPC_REPLY_ERROR);\n}", "CodeBleu_score": 30.216303771140584}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool redirect = false;\n\n    switch (code) {\n        case EREMOTE:\n            switch (msgType) {\n                case TMSG_COMMIT_CP:\n                case TMSG_ROLLBACK_CP:\n                case TMSG_XA_PREPARE:\n                case TMSG_XA_COMMIT:\n                case TMSG_XA_ROLLBACK:\n                case TMSG_XA_END:\n                case TMSG_XA_FORGET:\n                case TMSG_XA_RECOVER:\n                    redirect = true;\n                    break;\n                default:\n                    redirect = false;\n                    break;\n            }\n            break;\n        default:\n            redirect = false;\n            break;\n    }\n\n    return redirect;\n}", "CodeBleu_score": 25.310119349325017}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool ret = false;\n    if (code == RPC_ERR_NEED_REDIRECT) {\n        if (msgType != TMSG_RPC_REQ_READ_OBJ && msgType != TMSG_RPC_REQ_WRITE_OBJ) {\n            ret = true;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 34.06983061398967}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashObj *pRequest = NULL;\n    int64_t rid = 0;\n    int64_t count = 0;\n    int32_t ret = 0;\n\n    if (pRequests == NULL) {\n        return;\n    }\n\n    while ((pRequest = taosHashIterate(pRequests, pRequest)) != NULL) {\n        rid = (int64_t)pRequest->obj;\n        ret = acquireRequest(rid);\n        if (ret == 0) {\n            count++;\n            taos_stop_query(pRequest->query);\n            releaseRequest(rid);\n        }\n    }\n\n    if (count > 0) {\n        printf(\"[INFO] stop %ld requests\n\", count);\n    }\n}", "CodeBleu_score": 43.762305469770524}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashObj *pReqObj = NULL;\n    int32_t ret = 0;\n    int32_t i = 0;\n\n    if (pRequests == NULL) {\n        return;\n    }\n\n    for (i = 0; i < pRequests->size; i++) {\n        pReqObj = pRequests->obj[i];\n\n        while (pReqObj != NULL) {\n            ret = taos_stop_query(pReqObj->pData);\n            if (ret < 0) {\n                printf(\"taos_stop_query error: %s\n\", taos_errstr(ret));\n            }\n\n            releaseRequest(pReqObj->rid);\n            pReqObj = pReqObj->next;\n        }\n    }\n}", "CodeBleu_score": 39.206056780698695}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashIter *iter;\n  int64_t rid;\n  SRequest *pRequest;\n\n  if (pRequests == NULL)\n    return;\n\n  iter = sHashIterCreate(pRequests);\n  while (sHashIterHasNext(iter)) {\n    rid = sHashIterNext(iter);\n    pRequest = (SRequest *)sHashGetObj(pRequests, rid);\n    if (pRequest != NULL) {\n      if (pRequest->query != NULL) {\n        taos_stop_query(pRequest->query);\n        pRequest->query = NULL;\n      }\n      releaseRequest(rid);\n    }\n  }\n  sHashIterDestroy(iter);\n}", "CodeBleu_score": 46.60110164884165}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t// check if crash reporting is enabled\n    if (!tscIsCrashReportingEnabled()) {\n        return;\n    }\n\n    // attempt to set the clientStop flag to 1 using an atomic compare-and-exchange operation\n    int32_t expected = 0;\n    int32_t desired = 1;\n    int32_t result = atomic_val_compare_exchange_32(&clientStop, &expected, desired);\n\n    // if the operation fails, log a message indicating the crash report thread is already stopped and return\n    if (result != 0) {\n        tscPrintf(TSCPLN_MSG_CRASH_REPORT_THREAD_ALREADY_STOPPED);\n        return;\n    }\n\n    // wait in a loop until the clientStop flag becomes 0, indicating the thread has stopped\n    while (atomic_load_32(&clientStop) != 0) {\n        tscMsleep(100);\n    }\n}", "CodeBleu_score": 54.957419036713006}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (!atomic_val_compare_exchange_32(&tscClientStop, 0, 1)) {\n\t\ttscLog(\"tscStopCrashReport: Crash report thread already stopped.\n\");\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&tscClientStop)) {\n\t\ttscMsleep(100);\n\t}\n}", "CodeBleu_score": 66.42833067004558}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (!atomic_val_compare_exchange_32(&tscClientStop, 0, 1)) {\n\t\tTS_LOG_INFO(\"Crash report thread already stopped.\");\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&tscClientStop)) {\n\t\ttscMsleep(100);\n\t}\n}", "CodeBleu_score": 66.74552568915179}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t ret = 0;\n    int32_t viewCount = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t viewId = 0;\n    int32_t viewNameLen = 0;\n    int32_t colCount = 0;\n    int32_t colNameLen = 0;\n    int32_t colType = 0;\n    int32_t colLen = 0;\n    int32_t colPrecision = 0;\n    int32_t colScale = 0;\n    int32_t colNullable = 0;\n    int32_t colDefaultLen = 0;\n    int32_t colDefaultLenAlloc = 0;\n    char *viewName = NULL;\n    char *colName = NULL;\n    char *colDefault = NULL;\n    char *colDefaultAlloc = NULL;\n    int32_t colDefaultLenAllocOffset = 0;\n    struct SViewMeta *pViewMeta = NULL;\n    struct SViewMeta *pViewMetaTmp = NULL;\n    struct SViewMeta *pViewMetaTmp2 = NULL;\n    struct SViewMeta *pViewMetaTmp3 = NULL;\n    struct SViewMeta *pViewMetaTmp4 = NULL;\n    struct SViewMeta *pViewMetaTmp5 = NULL;\n    struct SViewMeta *pViewMetaTmp6 = NULL;\n    struct SViewMeta *pViewMetaTmp7 = NULL;\n    struct SViewMeta *pViewMetaTmp8 = NULL;\n    struct SViewMeta *pViewMetaTmp9 = NULL;\n    struct SViewMeta *pViewMetaTmp10 = NULL;\n    struct SViewMeta *pViewMetaTmp11 = NULL;\n    struct SViewMeta *pViewMetaTmp12 = NULL;\n    struct SViewMeta *pViewMetaTmp13 = NULL;\n    struct SViewMeta *pViewMetaTmp14 = NULL;\n    struct S", "CodeBleu_score": 11.515949811713053}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t rc = 0;\n    int32_t i = 0;\n    int32_t nViews = 0;\n    int32_t nCols = 0;\n    char *pViewName = NULL;\n    char *pColName = NULL;\n    char *pColType = NULL;\n    char *pColTypeLen = NULL;\n    char *pColTypePrecision = NULL;\n    char *pColTypeScale = NULL;\n    char *pColTypeIsArray = NULL;\n    char *pColTypeIsUnsigned = NULL;\n    char *pColTypeIsNotNull = NULL;\n    char *pColTypeIsPK = NULL;\n    char *pColTypeIsAutoInc = NULL;\n    char *pColTypeIsVirtual = NULL;\n    char *pColTypeIsSystem = NULL;\n    char *pColTypeIsHidden = NULL;\n    char *pColTypeIsConstant = NULL;\n    char *pColTypeIsDistKey = NULL;\n    char *pColTypeIsSortKey = NULL;\n    char *pColTypeIsForeignKey = NULL;\n    char *pColTypeIsShared = NULL;\n    char *pColTypeIsEnum = NULL;\n    char *pColTypeIsZipped = NULL;\n    char *pColTypeIsGeo = NULL;\n    char *pColTypeIsTime = NULL;\n    char *pColTypeIsIPAddr = NULL;\n    char *pColTypeIsJson = NULL;\n    char *pColTypeIsVirtualTyped = NULL;\n    char *pColTypeIsHiddenTyped = NULL;\n    char *pColTypeIsConstantTyped = NULL;\n    char *pColTypeIsDistKeyTyped = NULL;\n    char *pColTypeIsSortKeyTyped = NULL;\n    char *pColTypeIsForeignKeyTyped = NULL;\n    char *pColTypeIsSharedTyped = NULL;\n    char *pColTypeIsEnumTyped = NULL;\n    char *pColTypeIsZippedTyped = NULL;\n    char *pColTypeIsGeoTyped = NULL;\n    char *pColTypeIsTimeTyp", "CodeBleu_score": 9.800781275777744}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t i;\n  int32_t j;\n  int32_t err;\n  int32_t viewCount;\n  int32_t viewNameLen;\n  int32_t viewNameOffset;\n  int32_t viewColumnCount;\n  int32_t viewColumnNameLen;\n  int32_t viewColumnNameOffset;\n  int32_t viewColumnType;\n  int32_t viewColumnOffset;\n  int32_t viewColumnSize;\n  int32_t viewColumnNullable;\n  char *viewName;\n  char *viewColumnName;\n  struct SViewMeta *pViewMeta;\n  struct SViewMeta *pNewViewMeta;\n  struct SViewMeta *pCatalogViewMeta;\n  struct SViewMeta *pCatalogViewMetaTmp;\n  struct SViewMeta *pCatalogViewMetaTmp2;\n  struct SViewMeta *pCatalogViewMetaTmp3;\n  struct SViewMeta *pCatalogViewMetaTmp4;\n  struct SViewMeta *pCatalogViewMetaTmp5;\n  struct SViewMeta *pCatalogViewMetaTmp6;\n  struct SViewMeta *pCatalogViewMetaTmp7;\n  struct SViewMeta *pCatalogViewMetaTmp8;\n  struct SViewMeta *pCatalogViewMetaTmp9;\n  struct SViewMeta *pCatalogViewMetaTmp10;\n  struct SViewMeta *pCatalogViewMetaTmp11;\n  struct SViewMeta *pCatalogViewMetaTmp12;\n  struct SViewMeta *pCatalogViewMetaTmp13;\n  struct SViewMeta *pCatalogViewMetaTmp14;\n  struct SViewMeta *pCatalogViewMetaTmp15;\n  struct SViewMeta *pCatalogViewMetaTmp16;\n  struct SViewMeta *pCatalogViewMetaTmp17;\n  struct SViewMeta *pCatalogViewMetaTmp18;\n  struct SViewMeta *pCatalogViewMetaTmp19;\n  struct SViewMeta *pCatalog", "CodeBleu_score": 9.109643923032374}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status;\n    S3GetObjectHandler *handler = (S3GetObjectHandler *) callbackData;\n\n    /* Extract the content length from the response properties. */\n    status = properties->getContentLength(properties, &handler->contentLength);\n\n    /* If the content length from the response properties is greater than zero, update the content length in the callback data structure. */\n    if (status == S3StatusOK && handler->contentLength > 0) {\n        handler->contentLength = 0;\n    }\n\n    /* Set the content length to zero if the content length from the response properties is zero or negative. */\n    if (status == S3StatusOK && handler->contentLength <= 0) {\n        handler->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 54.56523853879428}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status;\n    S3ResponseHandler *handler = (S3ResponseHandler *) callbackData;\n    int64_t contentLength = 0;\n\n    status = S3_getx_int64(properties, \"content-length\", S3_AMZ_HEADER_PREFIX, &contentLength);\n    if (status != S3StatusOK) {\n        return status;\n    }\n\n    if (contentLength > 0) {\n        handler->contentLength = contentLength;\n    } else {\n        handler->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 58.00452161999041}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status;\n    S3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n    int64_t contentLength;\n\n    status = properties->getContentLength(properties, &contentLength);\n    if (status != S3StatusOK) {\n        return status;\n    }\n    if (contentLength > 0) {\n        data->contentLength = contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 58.68412942003262}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync\");\n  if (taosMkDir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] generate conf error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --port=%d --config=%srsync.conf\", tsCheckpointPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start rsync error, cmd:%s\", cmd);\n  } else {\n    uDebug(\"[rsync] start rsync success, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 56.25285271189109}, {"code": "void startRsync(){\n\tif (taosMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%srsync.conf\", tsCheckpointBackupDir);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start error, cmd:%s\", cmd);\n    return;\n  }\n\n  uInfo(\"[rsync] start success, cmd:%s\", cmd);\n}", "CodeBleu_score": 54.317948892937764}, {"code": "void startRsync(){\n\tif (taosMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, confDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port=%d --config=%s\", tsCheckpointBackupPort, confDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n  } else {\n    uInfo(\"[rsync] start success, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 73.2489545950352}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}", "CodeBleu_score": 72.23023010729904}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n\tdispatcher.shutdownNow();\n}", "CodeBleu_score": 62.544256177471524}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered.\");\n    }\n    dispatcher.shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 63.05093093322546}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tif (parent != null) {\n            TbActorRef parentRef = getOrCreateChildActor(parent);\n            if (parentRef != null) {\n                Map<TbActorId, TbActorRef> children = parentRef.getChildren();\n                if (children != null) {\n                    children.forEach((childId, childRef) -> {\n                        if (childFilter.test(childId)) {\n                            try {\n                                childRef.tell(msg, highPriority);\n                            } catch (Exception e) {\n                                log.warn(\"[{}] Failed to broadcast message to child actor: {}\", parent, childId, e);\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }", "CodeBleu_score": 47.2934402018369}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tif (parent != null) {\n        TbActorRef parentRef = getOrCreateRef(parent);\n        if (parentRef != null) {\n            Set<TbActorId> children = parentRef.getChildren();\n            if (children != null) {\n                for (TbActorId childId : children) {\n                    if (childFilter.test(childId)) {\n                        TbActorRef childRef = getOrCreateRef(childId);\n                        if (childRef != null) {\n                            childRef.tellWithHighPriority(msg, highPriority);\n                        } else {\n                            log.warn(\"[{}] Failed to send message to child actor [{}]. Actor is not registered.\", parent, childId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 43.90390777681205}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tList<TbActorId> children = actorToChildrenMap.get(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    try {\n                        tell(child, msg, highPriority);\n                    } catch (TbActorException e) {\n                        log.warn(\"[{}] Failed to broadcast message to child: {}\", parent, child, e);\n                    }\n                }\n            }\n        }\n    }", "CodeBleu_score": 58.14985038851203}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destructionInProgress.get()) {\n        if (highPriority && msg instanceof RuleNodeUpdatedMsg) {\n            tryInit(1);\n        } else {\n            msg.getSender().tell(new TbActorStopResponse(msg.getId()));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    }\n}", "CodeBleu_score": 41.73909633528911}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destructionInProgress.get()) {\n            if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n                tryInit(1);\n            } else {\n                msg.getCallback().onFailure(new TbActorDestroyedException());\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(false);\n        }\n    }", "CodeBleu_score": 48.14728640521553}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (log.isTraceEnabled()) {\n        log.trace(\"[{}] Enqueueing msg: {}\", selfId, msg);\n    }\n    if (ready.get() == DESTROYING) {\n        if (msg.getMsgType() == TbActorMsgType.RULE_NODE_UPDATED_MSG) {\n            tryInit(1);\n        } else {\n            msg.getCallback().onFailure(new IllegalStateException(\"Actor is being destroyed!\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    }\n}", "CodeBleu_score": 53.57491319895347}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ttry {\n            log.trace(\"[{}] Processing mailbox, highPriorityMsgs size: {}, normalPriorityMsgs size: {}\", selfId, highPriorityMsgs.size(), normalPriorityMsgs.size());\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                log.trace(\"[{}] Mailbox is empty, ready: {}\", selfId, ready.get());\n                if (ready.compareAndSet(READY, FREE)) {\n                    dispatcher.getExecutor().execute(this::tryProcessQueue);\n                }\n                return;\n            }\n            int throughput = getActorThroughput();\n            if (throughput == 0) {\n                log.trace(\"[{}] Mailbox is blocked, ready: {}\", selfId, ready.get());\n                if (ready.compareAndSet(READY, FREE)) {\n                    dispatcher.getExecutor().execute(this::tryProcessQueue);\n                }\n                return;\n            }\n            int i = 0;\n            while (i < throughput) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg != null) {\n                    execute(msg);\n                    i++;\n                } else {\n                    msg = normalPriorityMsgs.poll();\n                    if (msg != null) {\n                        execute(msg);\n                        i++;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                log.trace(\"[{}] Mailbox is empty, ready: {}\", selfId, ready.get());\n                if (ready.compareAndSet(READY, FREE)) {\n                    dispatcher.getExecutor().execute(this::tryProcessQueue);\n                }\n            } else {\n                log.trace(\"[{}] Mailbox is not empty, ready: {}\", selfId, ready.get());\n                if (ready.compareAndSet(READY, BUSY)) {\n                    dispatcher.getExecutor().execute(this::processMailbox);", "CodeBleu_score": 36.63209340146436}, {"code": "private void processMailbox(){\n\ttry {\n            if (destroyInProgress.get()) {\n                return;\n            }\n            if (ready.get() != READY) {\n                return;\n            }\n            int throughput = actor.getActorThroughput();\n            int processed = 0;\n            while (processed < throughput) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                } catch (TbActorInitFailure ex) {\n                    log.warn(\"[{}] Failed to init actor: {}\", selfId, ex);\n                    stopReason = TbActorStopReason.INIT_FAILURE;\n                    destroy(ex);\n                    return;\n                } catch (Throwable ex) {\n                    log.warn(\"[{}] Failed to process msg: {}\", selfId, ex);\n                    actor.onProcessFailure(msg, ex);\n                    if (actor.getProcessFailureStrategy() == TbActorProcessFailureStrategy.STOP) {\n                        stopReason = TbActorStopReason.PROCESS_FAILURE;\n                        destroy(ex);\n                        return;\n                    }\n                }\n                processed++;\n            }\n            if (processed == 0) {\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    ready.set(FREE);\n                    dispatcher.getExecutor().execute(this::tryProcessQueue);\n                } else {\n                    tryProcessQueue(false);\n                }\n            } else {\n                tryProcessQueue(false);\n            }\n        } catch (Throwable ex) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, ex);\n            stopReason = TbActorStopReason.PROCESS_FAILURE;\n            destroy(ex);\n        }\n    }", "CodeBleu_score": 44.92584504306144}, {"code": "private void processMailbox(){\n\ttry {\n            busy.set(FREE);\n            long throughputLimit = actor.getActorThroughput();\n            long startTime = System.currentTimeMillis();\n            long processedCount = 0;\n            while (processedCount < throughputLimit) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                } catch (Throwable e) {\n                    log.warn(\"[{}] Failed to process msg: {}\", selfId, msg, e);\n                    onProcessFailure(msg, e);\n                }\n                processedCount++;\n            }\n            long endTime = System.currentTimeMillis();\n            long duration = endTime - startTime;\n            actor.setActorThroughput(processedCount, duration);\n            tryProcessQueue(false);\n        } catch (Throwable e) {\n            log.warn(\"[{}] Failed to process mailbox\", selfId, e);\n            stopReason = TbActorStopReason.PROCESS_MAILBOX_FAILED;\n            destroy(e);\n        }\n    }", "CodeBleu_score": 47.38758780539097}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.66735696636148}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.66735696636148}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitType rateLimitType = profile.getRateLimitType();\n    if (rateLimitType == RateLimitType.DISABLED) {\n        return true;\n    }\n    RateLimitConfig rateLimitConfig = profile.getRateLimitConfig();\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    if (rateLimitConfig.isDisabled(api)) {\n        return true;\n    }\n    RateLimitRule rule = rateLimitConfig.getRateLimitRule(api);\n    if (rule == null) {\n        return true;\n    }\n    if (rule.isDisabled(level)) {\n        return true;\n    }\n    RateLimitUsage rateLimitUsage = rateLimitUsageService.get(tenantId, api);\n    if (rateLimitUsage == null) {\n        rateLimitUsage = new RateLimitUsage();\n        rateLimitUsage.setTenantId(tenantId);\n        rateLimitUsage.setApi(api);\n        rateLimitUsage.setLevel(level);\n        rateLimitUsage.setTimestamp(System.currentTimeMillis());\n        rateLimitUsage.setCount(1);\n        rateLimitUsageService.save(rateLimitUsage);\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    if (currentTime - rateLimitUsage.getTimestamp() < rule.getTimeWindow()) {\n        rateLimitUsage.setCount(rateLimitUsage.getCount() + 1);\n        rateLimitUsageService.save(rateLimitUsage);\n        if (rateLimitUsage.getCount() > rule.getLimit()) {\n            rateLimitUsage.setTimestamp(currentTime);\n            rateLimitUsageService.save(rateLimitUsage);\n            rateLimitNotificationService.processRateLimitNotification(tenantId, api, rateLimitUsage.getLevel());\n            return false;\n        }\n    } else {\n        rateLimitUsage.setCount(1);", "CodeBleu_score": 40.35864545171761}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitType type = RateLimitType.valueOf(api.name());\n    RateLimitConfig rateLimitConfig = profile.getRateLimits().get(type);\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    if (rateLimitConfig.getLimit() <= 0) {\n        return true;\n    }\n    boolean isRateLimitExceeded = checkRateLimit(rateLimitConfig, level);\n    if (isRateLimitExceeded) {\n        processRateLimitNotification(api, tenantId, type, rateLimitConfig);\n    }\n    return !isRateLimitExceeded;\n}", "CodeBleu_score": 45.5935683312036}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = get(tenantId);\n    if (tenantProfile == null && ignoreTenantNotFound) {\n        return true;\n    }\n    if (tenantProfile == null) {\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    TenantProfileData profileData = tenantProfile.getData();\n    RateLimitSettings rateLimitSettings = profileData.getRateLimitSettings();\n    if (rateLimitSettings == null) {\n        return true;\n    }\n    RateLimitType rateLimitType = rateLimitSettings.getType();\n    if (rateLimitType == null) {\n        return true;\n    }\n    String apiLimitLevel = getLimitLevelEntityName(api, level);\n    if (apiLimitLevel == null) {\n        return true;\n    }\n    Map<String, Long> apiLimits = rateLimitSettings.getApiLimit();\n    if (apiLimits == null) {\n        return true;\n    }\n    Long apiLimit = apiLimits.get(apiLimitLevel);\n    if (apiLimit == null) {\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    long apiLimitExpirationTime = rateLimitSettings.getApiLimitExpirationTime();\n    long apiLimitExpirationTimeInPast = currentTime - apiLimitExpirationTime;\n    long apiLimitExpirationTimeInFuture = currentTime + apiLimitExpirationTime;\n    long apiLimitResetTime = rateLimitSettings.getApiLimitResetTime();\n    long apiLimitResetTimeInPast = currentTime - apiLimitResetTime;\n    long apiLimitResetTimeInFuture = currentTime + apiLimitResetTime;\n    long apiLimitResetTimeInPastInMillis = apiLimitResetTimeInPast * 1000;\n    long apiLimitResetTimeInFutureInMillis = apiLimitResetTimeInFuture * 1000;\n    long apiLimitExpirationTimeInPastInMillis = apiLimitExpirationTimeInPast * 1000;\n    long apiLimitExpirationTime", "CodeBleu_score": 44.38599582281772}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - this.inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : this.sessions.entrySet()) {\n        DTLSSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            this.sessions.remove(entry.getKey());\n            this.trace.trace(String.format(\"Removing DTLS session %s due to inactivity timeout\", entry.getKey()));\n        }\n    }\n}", "CodeBleu_score": 41.951988056715585}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - mInactivityTimeout;\n    for (Map.Entry<Integer, DTLSRecordLayer> entry : mSessions.entrySet()) {\n        int key = entry.getKey();\n        DTLSRecordLayer dtlsRecordLayer = entry.getValue();\n        if (dtlsRecordLayer.getLastActivityTime() < expirationTime) {\n            mSessions.remove(key);\n            Log.d(TAG, \"Removed session with key \" + key + \" due to inactivity timeout\");\n        }\n    }\n}", "CodeBleu_score": 46.19766021126032}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tIterator<Map.Entry<String, DTLSSession>> iter = sessions.entrySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tMap.Entry<String, DTLSSession> entry = iter.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\titer.remove();\n\t\t\ttrace(\"Removed session with key: \" + entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 47.26105949847391}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries == null || timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n            timeseries.forEach((key, values) -> {\n                if (values != null && !values.isEmpty()) {\n                    values.forEach(value -> {\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n                    });\n                }\n            });\n            return result;\n        }\n    }", "CodeBleu_score": 47.55467617162855}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries == null || timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            return timeseries.entrySet().stream().flatMap(e -> {\n                List<TsKvEntry> result = new ArrayList<>(e.getValue().size());\n                for (JsonNode value : e.getValue()) {\n                    if (value.isContainerNode()) {\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(), new JsonDataEntry(e.getKey(), value.toString())));\n                    } else {\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(e.getKey(), value)));\n                    }\n                }\n                return result.stream();\n            }).collect(Collectors.toList());\n        }\n    }", "CodeBleu_score": 45.59198062195704}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!timeseries.isEmpty()) {\n            return timeseries.entrySet().stream().map(entry -> {\n                String key = entry.getKey();\n                List<JsonNode> values = entry.getValue();\n                if (values.isEmpty()) {\n                    throw new RuntimeException(EMPTY_TIMESERIES);\n                } else if (values.size() == 1) {\n                    return new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, values.get(0)));\n                } else {\n                    return new BasicTsKvEntry(System.currentTimeMillis(),\n                            new LongDataEntry(key, values.size()));\n                }\n            }).collect(Collectors.toList());\n        } else {\n            return Collections.emptyList();\n        }\n    }", "CodeBleu_score": 37.10157024705794}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tif (currentTimeMillis() >= refreshTokenExpTs) {\n            throw new RuntimeException(\"The refresh token has expired.\");\n        }\n        Map<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", refreshToken);\n        JsonNode tokenInfo = postForEntity(requestMap, \"/auth/refresh\", JsonNode.class);\n        setTokenInfo(currentTimeMillis(), tokenInfo);\n    }", "CodeBleu_score": 42.39599902901163}, {"code": "public void refreshToken(){\n\tMap<String, Object> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestMap, this.getHeaders());\n        ResponseEntity<JsonNode> responseEntity = this.restTemplate.postForEntity(this.authenticationUrl, requestEntity, JsonNode.class);\n        this.setTokenInfo(System.currentTimeMillis(), responseEntity.getBody());\n    }", "CodeBleu_score": 48.772370638987645}, {"code": "public void refreshToken(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> body = new HashMap<>();\n        body.put(\"refreshToken\", this.refreshToken);\n        body.put(\"clientId\", this.clientId);\n        body.put(\"clientSecret\", this.clientSecret);\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        HttpEntity<Map<String, String>> request = new HttpEntity<>(body, headers);\n        ResponseEntity<JsonNode> response = this.restTemplate.postForEntity(this.authUrl, request, JsonNode.class);\n        this.setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 43.712320854488816}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        JsonNode tokenInfo = postForEntity(\"/api/auth/login\", loginRequest, JsonNode.class).getBody();\n        setTokenInfo(ts, tokenInfo);\n    }", "CodeBleu_score": 55.329765558744306}, {"code": " private void doLogin(){\n\tlong ts = currentTimeMillis();\n        Map<String, String> loginRequestMap = new HashMap<>();\n        loginRequestMap.put(\"username\", username);\n        loginRequestMap.put(\"password\", password);\n        ResponseEntity<JsonNode> response = postForEntity(\"/api/auth/login\", loginRequestMap, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 56.45197766745203}, {"code": " private void doLogin(){\n\ttry {\n            long ts = System.currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", this.username);\n            loginRequest.put(\"password\", this.password);\n            JsonNode tokenInfo = this.postForEntity(\"/api/auth/login\", loginRequest);\n            this.setTokenInfo(ts, tokenInfo);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "CodeBleu_score": 61.80579423460858}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.ofNullable(restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId()).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 42.384060089430186}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.ofNullable(\n                restTemplate.getForEntity(\n                        \"/api/device/{deviceId}\",\n                        Device.class,\n                        deviceId.getValue())\n                        .getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 49.48793952368796}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\tResponseEntity<Device> response = restTemplate.getForEntity(\n            \"http://localhost:8080/api/device/{deviceId}\", Device.class, deviceId.getValue());\n    if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n        return Optional.empty();\n    }\n    return Optional.of(response.getBody());\n}", "CodeBleu_score": 49.888354921173615}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceCredentials> request = new HttpEntity<>(credentials);\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class, device.getId().toString());\n        if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 57.18861548418401}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<DeviceCredentials> request = new HttpEntity<>(credentials);\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(baseUrl + \"/device-with-credentials\", request, Device.class);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 65.10253998393593}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpEntity<Device> request = new HttpEntity<>(device, createHeadersWithToken(credentials.getAccessToken()));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 56.3774697160198}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[`${method}Callback`] = (collection, duration, callback) => {\n      if (typeof duration !== 'number') duration = 1000;\n      if (typeof callback !== 'function') callback = () => {};\n      const signals = [];\n      collection.forEach(i => {\n        signals.push(i[method](duration));\n      });\n      Promise.all(signals).then(callback);\n    };\n  });\n}", "CodeBleu_score": 35.52118997251772}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[`${method}CallbackReconciliation`] = (collection, duration, callback) => {\n      if (typeof duration !== 'number') {\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        throw new Error(`Callback must be a function, received ${callback}`);\n      }\n      let signals = [];\n      collection.forEach(i => {\n        signals.push(resolve(i[method], duration));\n      });\n      Promise.all(signals).then(callback);\n    };\n  });\n}", "CodeBleu_score": 38.60446930811657}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[method] = (collection, duration, callback) => {\n      if (typeof duration === 'function') {\n        callback = duration;\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        callback = () => {};\n      }\n      const signals = [];\n      collection.forEach(i => {\n        signals.push(this[method](i, duration));\n      });\n      Promise.all(signals).then(() => {\n        callback();\n      });\n    };\n  });\n}", "CodeBleu_score": 47.90430457294001}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.07023430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.07023430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.07023430593136}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint32_t needed_buffer_size = 0;\n\tuint32_t i;\n\n\tfor (i = 0; i < sequence->channels; ++i) {\n\t\tif (sequence->channels[i] < config->num_channels) {\n\t\t\t++active_channels;\n\t\t}\n\t}\n\n\tif (sequence->resolution == 12) {\n\t\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\t} else {\n\t\tneeded_buffer_size = active_channels * sizeof(uint32_t);\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size (%d < %d)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->active_channels = active_channels;\n\n\treturn 0;\n}", "CodeBleu_score": 39.26160469696743}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint16_t sample_size = 0;\n\tuint16_t buffer_size = 0;\n\n\tif (sequence->oversampling != 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != NULL) {\n\t\tfor (uint8_t i = 0; i < sequence->channels->len; i++) {\n\t\t\tif (sequence->channels->list[i] < config->num_channels) {\n\t\t\t\tactive_channels++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sequence->buffer != NULL) {\n\t\tsample_size = sizeof(uint16_t);\n\t\tbuffer_size = sample_size * active_channels;\n\n\t\tif (buffer_size > sequence->buffer_size) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.81595254508548}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size;\n\tuint8_t active_channels;\n\n\t/*\n\t * The buffer size is calculated based on the number of channels and the\n\t * size of each data sample.\n\t */\n\tbuffer_size = sequence->channels * sizeof(uint16_t);\n\n\t/*\n\t * The number of active channels is calculated based on the number of\n\t * channels in the sequence.\n\t */\n\tactive_channels = sequence->channels;\n\n\t/*\n\t * If the buffer size is insufficient, return an error code indicating\n\t * insufficient memory.\n\t */\n\tif (buffer_size > data->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.13720563790235}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tuint8_t channel_mask;\n\tuint8_t resolution;\n\tuint8_t buffer_size;\n\tuint8_t i;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tchannel_mask = sequence->channels;\n\tresolution = sequence->resolution;\n\tbuffer_size = sequence->buffer_size;\n\n\tfor (i = 0; i < config->num_channels; i++) {\n\t\tif (channel_mask & BIT(i)) {\n\t\t\tif (config->channels[i].channel_id != i) {\n\t\t\t\tLOG_ERR(\"invalid channel\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (adc_ad559x_validate_buffer_size(dev, sequence)) {\n\t\tLOG_ERR(\"buffer too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tadc_context_wait_for_completion(&data->ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 54.353157489884474}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint err;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err != 0) {\n\t\tLOG_ERR(\"buffer too small\");\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terr = adc_context_wait_for_completion(&data->ctx);\n\tif (err != 0) {\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.365544495584}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_dev_config *config = dev->config;\n\tint ret;\n\n\tif (sequence->resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~ADC_CHANNEL_MASK) {\n\t\tLOG_ERR(\"invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"buffer size too small\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tret = adc_context_wait_for_completion(&data->ctx);\n\tif (ret) {\n\t\tadc_context_release(&data->ctx, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.4170654233276}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct device *dev = ctx->dev;\n\tstruct adc_stm32_data *data = dev->driver_data;\n\tstruct adc_stm32_cfg *config = dev->config->config_info;\n\tADC_TypeDef *adc = config->base;\n\tu32_t mask = 0;\n\n\tfor (int i = 0; i < ctx->sequence.num_entries; i++) {\n\t\tint channel = ctx->sequence.entries[i].channel_id;\n\t\tint acq_time = ctx->sequence.entries[i].sampling_time;\n\n\t\tif (acq_time != ADC_ACQ_TIME_DEFAULT) {\n\t\t\tLOG_ERR(\"Selected sampling time is not valid\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (channel >= STM32_CHANNEL_COUNT) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn;\n\t\t}\n\n\t\tmask |= BIT(channel);\n\t}\n\n\tdata->channels = mask;\n\n\tadc_stm32_start_conversion(dev);\n}", "CodeBleu_score": 25.292173398326266}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tconst struct adc_config *config = ctx->config;\n\tstruct adc_sampling_data *sampling_data = ctx->sampling_data;\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tconst struct adc_channel_cfg *channels = sequence->channels;\n\tint i;\n\n\t/* Retrieve the data structure for the ADC device */\n\tconst struct device *dev = config->dev;\n\tstruct adc_data *data = dev->data;\n\n\t/* Set the channels to be sampled */\n\tdata->channels = sampling_data->channels;\n\tdata->buffer = sampling_data->buffer;\n\tdata->buffer_size = sampling_data->buffer_size;\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tsampling_data->repeat_buffer = data->buffer;\n\tsampling_data->repeat_buffer_size = data->buffer_size;\n\n\t/* Set the sampling delay */\n\tdata->sampling_delay = sequence->sampling_delay;\n\n\t/* Set the resolution */\n\tdata->resolution = sequence->resolution;\n\n\t/* Set the oversampling */\n\tdata->oversampling = sequence->oversampling;\n\n\t/* Set the calibration */\n\tdata->calibrate = sequence->calibrate;\n\n\t/* Set the callback function */\n\tdata->callback = sequence->callback;\n\n\t/* Set the callback reference */\n\tdata->callback_ref = sequence->callback_ref;\n\n\t/* Set the channels to be sampled */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tdata->channels[i] = channels[i].channel_id;\n\t}\n\n\t/* Release the semaphore to start sampling */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 46.02565152043782}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_stm32_data *data = ctx->data;\n\tuint8_t id = ctx->sequence.channels[0].channel_id;\n\n\tif (data->resolution == 8U) {\n\t\tdata->buffer = (uint8_t *)ctx->sequence.buffer;\n\t} else {\n\t\tdata->buffer = (uint16_t *)ctx->sequence.buffer;\n\t}\n\n\tdata->repeat_buffer = data->buffer;\n\n\tLL_ADC_REG_SetSequencerChannels(data->handle->Instance,\n\t\t\t\t\t(LL_ADC_CHANNEL_4 |\n\t\t\t\t\t LL_ADC_CHANNEL_13 |\n\t\t\t\t\t LL_ADC_CHANNEL_14 |\n\t\t\t\t\t LL_ADC_CHANNEL_15 |\n\t\t\t\t\t LL_ADC_CHANNEL_16 |\n\t\t\t\t\t LL_ADC_CHANNEL_17 |\n\t\t\t\t\t LL_ADC_CHANNEL_18 |\n\t\t\t\t\t LL_ADC_CHANNEL_5 |\n\t\t\t\t\t LL_ADC_CHANNEL_6 |\n\t\t\t\t\t LL_ADC_CHANNEL_7 |\n\t\t\t\t\t LL_ADC_CHANNEL_8 |\n\t\t\t\t\t LL_ADC_CHANNEL_9 |\n\t\t\t\t\t LL_ADC_CHANNEL_10 |\n\t\t\t\t\t LL_ADC_CHANNEL_11 |\n\t\t\t\t\t LL_ADC_CHANNEL_12 |\n\t\t\t\t\t LL_ADC_CHANNEL_VREFINT |\n\t\t\t\t\t LL_ADC_CHANNEL_TEMPSENSOR |\n\t\t\t\t\t LL_ADC_CHANNEL_VBAT |\n\t\t\t\t\t LL_ADC_CHANNEL_VOPAMP1 |\n\t\t\t\t\t LL_ADC_CHAN", "CodeBleu_score": 35.63531704017468}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data *adc_data = ctx->data;\n\n\tif (repeat_sampling) {\n\t\tadc_data->buffer_ptr = adc_data->repeat_buffer;\n\t} else {\n\t\tadc_data->buffer_ptr = adc_data->buffer;\n\t}\n}", "CodeBleu_score": 50.954680840156264}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data_container *container = (struct adc_data_container *)ctx->data_container;\n\n\tif (repeat_sampling) {\n\t\tcontainer->buffer = container->repeat_buffer;\n\t}\n}", "CodeBleu_score": 51.52796635740948}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n\t\tctx->data->buffer_ptr = ctx->data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 42.54846015270821}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_sequence *sequence;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tsequence = (struct adc_sequence *)ctx->sequence;\n\n\t\twhile (sequence->options) {\n\t\t\tfor (int i = 0; i < sequence->channels; i++) {\n\t\t\t\tuint8_t channel = sequence->channels_map[i];\n\n\t\t\t\tret = adc_ad559x_read_channel(dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %u (%d)\", channel, ret);\n\t\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsequence->buffer[i] = result;\n\t\t\t}\n\n\t\t\tadc_context_on_sampling_done(&data->ctx, ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.21873901791469}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tstruct adc_context *ctx = &data->ctx;\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint16_t val;\n\tint err;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Read all active channels */\n\t\tfor (int i = 0; i < ADC_CHANNELS; i++) {\n\t\t\tif (!(ctx->channels & BIT(i))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = adc_ad559x_read_channel(data->dev, i, &val);\n\t\t\tif (err < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", i, err);\n\t\t\t\tadc_context_complete(ctx, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadc_context_on_sampling_done(&data->ctx, i);\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_on_sampling_done(&data->ctx, ADC_CHANNELS);\n\t}\n}", "CodeBleu_score": 46.675628873328314}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_sequence *sequence;\n\tuint16_t result;\n\tint ret;\n\tint i;\n\n\twhile (1) {\n\t\t/* wait for the semaphore */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tsequence = ctx->sequence_pool[ctx->sequence_id];\n\t\tsequence->oversampling = 0U;\n\t\tsequence->resolution = 12U;\n\n\t\t/* read all the requested channels */\n\t\tfor (i = 0; i < sequence->channels; i++) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, sequence->channels[i], &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Channel %d read error: %d\", sequence->channels[i], ret);\n\t\t\t\tadc_context_complete(ctx, sequence->channels[i], ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadc_context_on_sampling_done(&data->ctx, sequence, i);\n\t\t}\n\n\t\tadc_context_complete(&data->ctx, 0, 0);\n\t}\n}", "CodeBleu_score": 44.566525247193326}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2];\n\tint rc;\n\tint ready_time = config->ready_time;\n\n\t/* Wait for the device to be ready */\n\tk_sleep(K_USEC(ready_time));\n\n\t/* Read the configuration register */\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* If the device is not ready, keep sleeping for 100 microseconds and check the status again */\n\twhile (!(reg_val[0] & ADS1112_CONFIG_RDY_MASK)) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.40561447812537}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\tint i = 0;\n\n\tk_sleep(config->ready_time);\n\n\tfor (i = 0; i < ADS1112_READY_RETRY; i++) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (!(reg_val & ADS1112_CONFIG_OS_MASK)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\treturn -EIO;\n}", "CodeBleu_score": 48.49733206438679}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\n\tk_sleep(K_USEC(config->data_ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val & ADS1112_CONFIG_DRDY)) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 69.77020857285459}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint buffer_size = sequence->buffer_size;\n\tint num_samplings = sequence->samplings;\n\tint num_extra_samplings = 0;\n\n\tif (sequence->options & ADC_SEQUENCE_EXECUTE_ONCE) {\n\t\tnum_extra_samplings++;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_START_CONTINUOUS) {\n\t\tnum_extra_samplings++;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_STOP_CONTINUOUS) {\n\t\tnum_extra_samplings++;\n\t}\n\n\tif (num_samplings + num_extra_samplings > buffer_size) {\n\t\tLOG_ERR(\"Buffer size is too small\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.43856728615668}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tif (sequence->oversampling == 0) {\n\t\tif (sequence->buffer_size < sequence->samplings) {\n\t\t\tLOG_ERR(\"Insufficient buffer size for %d samplings\", sequence->samplings);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (sequence->buffer_size < sequence->samplings * (1 + sequence->oversampling)) {\n\t\t\tLOG_ERR(\"Insufficient buffer size for %d samplings with oversampling %d\", sequence->samplings, sequence->oversampling);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 38.13218404434884}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tuint8_t extra_samplings = 0;\n\tuint8_t required_buffer_size = 0;\n\n\tif (sequence->options & ADC_SEQUENCE_ACQUIRE_CONTINUOUSLY) {\n\t\textra_samplings = 1;\n\t}\n\n\trequired_buffer_size = (sequence->samplings + extra_samplings) * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is too small. Required size: %d, given size: %d\", required_buffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.07429292810027}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tif (wait) {\n\t\tadc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.27893591515661}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tint err;\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Invalid resolution 0x%x\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(ctx, sequence);\n\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(ctx);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 57.32212405105733}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Invalid sequence\");\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 56.37818780773674}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\tint ret;\n\tstruct audio_codec_cfg cfg = {\n\t\t.i2s_num = 0,\n\t\t.i2s_cfg = NULL,\n\t\t.gpio_cfg = NULL,\n\t\t.dma_cfg = NULL,\n\t\t.irq_cfg = NULL,\n\t};\n\tconst struct audio_codec_driver_api *api;\n\tconst char *dev_name = argv[1];\n\n\tdev = device_get_binding(dev_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\tapi = (const struct audio_codec_driver_api *)dev->api;\n\tret = api->apply_properties(dev, &cfg);\n\n\treturn ret;\n}", "CodeBleu_score": 58.109993495167224}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *codec_dev;\n\tint ret;\n\tcodec_dev = device_get_binding(argv[1]);\n\tif (!codec_dev) {\n\t\tshell_error(sh, \"Audio codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\tret = audio_codec_apply_properties(codec_dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties to audio codec\");\n\t}\n\treturn ret;\n}", "CodeBleu_score": 63.74988712388716}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tint ret = 0;\n    const struct device *dev;\n    struct audio_codec_cfg codec_cfg = {0};\n\n    if (argc < 2) {\n        shell_error(sh, \"Too few arguments\");\n        return -EINVAL;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found\");\n        return -EINVAL;\n    }\n\n    if (argc > 2) {\n        codec_cfg.i2s_num = atoi(argv[2]);\n    }\n\n    if (argc > 3) {\n        codec_cfg.i2s_fmt = atoi(argv[3]);\n    }\n\n    if (argc > 4) {\n        codec_cfg.i2s_mclk_freq = atoi(argv[4]);\n    }\n\n    if (argc > 5) {\n        codec_cfg.i2s_bclk_freq = atoi(argv[5]);\n    }\n\n    if (argc > 6) {\n        codec_cfg.i2s_num_slots = atoi(argv[6]);\n    }\n\n    if (argc > 7) {\n        codec_cfg.i2s_slot_width = atoi(argv[7]);\n    }\n\n    ret = audio_codec_apply_properties(dev, &codec_cfg);\n    if (ret) {\n        shell_error(sh, \"Error %d while applying properties\", ret);\n    } else {\n        shell_print(sh, \"Properties applied successfully\");\n    }\n\n    return ret;\n}", "CodeBleu_score": 54.8169602979248}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_data *drv_data = dev->data;\n\tconst struct mpxxdtyy_cfg *cfg = dev->config;\n\tint ret;\n\n\t/* Check that the device is in the correct state for the command */\n\tif (cmd == DMIC_TRIGGER_START && drv_data->state != MPXXDTYY_STATE_CONFIGURED) {\n\t\tLOG_ERR(\"invalid state for start command (%d)\", drv_data->state);\n\t\treturn -EIO;\n\t}\n\tif (cmd == DMIC_TRIGGER_STOP && drv_data->state != MPXXDTYY_STATE_ACTIVE) {\n\t\tLOG_ERR(\"invalid state for stop command (%d)\", drv_data->state);\n\t\treturn -EIO;\n\t}\n\n\t/* Send the I2S command */\n\tret = i2s_trigger(cfg->i2s, I2S_DIR_RX, cmd);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"i2s_trigger failed (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Update the device state */\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tdrv_data->state = MPXXDTYY_STATE_ACTIVE;\n\t} else {\n\t\tdrv_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.40578455119815}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_dev_data *const dev_data = DEV_DATA(dev);\n    struct mpxxdtyy_dev_cfg *const dev_cfg = DEV_CFG(dev);\n    struct mpxxdtyy_i2s_dev_data *const i2s_dev_data = DEV_DATA(dev_cfg->i2s_dev);\n    struct mpxxdtyy_i2s_dev_cfg *const i2s_dev_cfg = DEV_CFG(dev_cfg->i2s_dev);\n    int ret;\n\n    switch (cmd) {\n    case DMIC_TRIGGER_START:\n        if (dev_data->state != DMIC_STATE_READY) {\n            LOG_ERR(\"Device not ready\");\n            return -ENODEV;\n        }\n\n        ret = i2s_write(dev_cfg->i2s_dev, &dev_cfg->i2s_cfg);\n        if (ret < 0) {\n            LOG_ERR(\"I2S write failed (%d)\", ret);\n            return ret;\n        }\n\n        dev_data->state = DMIC_STATE_ACTIVE;\n\n        break;\n    case DMIC_TRIGGER_STOP:\n        if (dev_data->state != DMIC_STATE_ACTIVE) {\n            LOG_ERR(\"Device not active\");\n            return -ENODEV;\n        }\n\n        ret = i2s_read(dev_cfg->i2s_dev, &dev_cfg->i2s_cfg);\n        if (ret < 0) {\n            LOG_ERR(\"I2S read failed (%d)\", ret);\n            return ret;\n        }\n\n        dev_data->state = DMIC_STATE_READY;\n\n        break;\n    default:\n        LOG_ERR(\"Invalid trigger command\");\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.06896780241798}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n\tstruct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n\tint ret;\n\tuint32_t i2s_cmd;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (dev_data->state != DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not in configured state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Set the I2S command to start the device */\n\t\ti2s_cmd = dev_cfg->i2s_start_cmd;\n\n\t\t/* Set the device state to active */\n\t\tdev_data->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (dev_data->state != DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not in active state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Set the I2S command to stop the device */\n\t\ti2s_cmd = dev_cfg->i2s_stop_cmd;\n\n\t\t/* Set the device state to configured */\n\t\tdev_data->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Send the I2S command */\n\tret = i2s_write(dev_data->i2s_dev, &i2s_cmd, sizeof(i2s_cmd));\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.196383571140586}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_MODE_CMD;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 68.60718111447991}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_MODE_CMD;\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_4_LINE) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_4_LINE_BIT;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_2_LINE) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_2_LINE_BIT;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_5x10) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_5x10_BIT;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_5x8) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_5x8_BIT;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_1x4) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_1x4_BIT;\n\t}\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_1x2) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_1x2_BIT;\n\t}\n\n\tif (config->cursor_mode == AUXDISPLAY_HD44780_CURSOR_MODE_BL", "CodeBleu_score": 57.166228924235185}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= (AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON |\n\t\t\tAUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON |\n\t\t\tAUXDISPLAY_HD44780_CMD_DISPLAY_MODE_BLINK_ON);\n\t} else {\n\t\tcmd &= ~(AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON |\n\t\t\t AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON |\n\t\t\t AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_BLINK_ON);\n\t}\n\n\tif (config->cursor_position_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_POSITION;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_POSITION;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_BLINK_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_BLINK_ON;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t} else {\n\t\tcmd &= ~AU", "CodeBleu_score": 57.89886737569845}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n    struct auxdisplay_itron_data *data = dev->data;\n\n    if (config->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 67.59040344162364}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *cfg = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (!cfg->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (ret) {\n\t\tdata->busy = true;\n\t} else {\n\t\tdata->busy = false;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 56.72672961440307}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\treturn gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 45.08593745501378}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tint ret;\n\tuint8_t buf[3];\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tbuf[0] = config->command_prefix;\n\tbuf[1] = command;\n\n\tret = i2c_write_dt(&config->i2c_dev, buf, 2);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to send special command to LCD: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(config->command_delay);\n\n\treturn 0;\n}", "CodeBleu_score": 59.59216543930948}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tint ret;\n\tuint8_t command_buffer[2];\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst struct auxdisplay_serlcd_driver_api *api = dev->api;\n\n\tcommand_buffer[0] = config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\tret = api->i2c_write_dt(dev, command_buffer, sizeof(command_buffer));\n\n\tif (ret == 0) {\n\t\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.25119362809497}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint result;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tresult = i2c_write_dt(config->i2c_dev, buffer, sizeof(buffer));\n\tif (result == 0) {\n\t\tk_sleep(config->special_command_delay_ms);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 64.31890007942413}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM emulator is in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (offset > data->size) {\n\t\tLOG_ERR(\"offset %zu exceeds BBRAM emulator size %zu\", offset, data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data->size) {\n\t\tLOG_ERR(\"offset %zu + size %zu exceeds BBRAM emulator size %zu\",\n\t\t\toffset, size, data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.87768436646765}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tint ret = 0;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data + offset, data + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 59.97664961812966}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data->mem + offset, data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 58.36163126669929}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tuint8_t *mem = data->mem;\n\tsize_t mem_size = data->mem_size;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&mem[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 53.47014446810658}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tuint8_t *mem = data->mem;\n\tsize_t mem_size = data->mem_size;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&mem[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 55.05920863068505}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tuint8_t *bbram_emul_mem = data->bbram_emul_mem;\n\tint ret = 0;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > BBR_SIZE) {\n\t\tLOG_ERR(\"Write size exceeds BBRAM size\");\n\t\treturn -EIO;\n\t}\n\n\tif (offset % 4 != 0) {\n\t\tLOG_ERR(\"Write offset must be 4-byte aligned\");\n\t\treturn -EIO;\n\t}\n\n\tif (size % 4 != 0) {\n\t\tLOG_ERR(\"Write size must be 4-byte aligned\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram_emul_mem[offset], data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 45.134166561871695}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Could not get %s device\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.78307618139071}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name missing\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 85.19027343564069}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name missing\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Cannot get binding to %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Cannot initialize %s (err %d)\", argv[1], ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 69.73529625823858}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tint err;\n\tint bytes_read;\n\tint bytes_remaining;\n\n\tbytes_remaining = h4_hdr_len - h4_hdr_read;\n\terr = uart_fifo_read(dev, h4_hdr + h4_hdr_read, bytes_remaining);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Failed to read header\");\n\t} else {\n\t\tbytes_read = err;\n\t\th4_hdr_read += bytes_read;\n\t}\n}", "CodeBleu_score": 39.899377938651256}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tint bytes_read;\n\tint bytes_to_read;\n\n\tbytes_to_read = H4_HDR_SIZE - hdr_read_count;\n\tbytes_read = uart_fifo_read(dev, hdr_buf + hdr_read_count, bytes_to_read);\n\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"Error reading from UART FIFO\");\n\t\treturn;\n\t}\n\n\thdr_read_count += bytes_read;\n}", "CodeBleu_score": 36.60132306624047}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct h4_dev *h4 = dev->data;\n\tconst struct uart_driver_api *api = dev->api;\n\tint bytes_read;\n\tu8_t *hdr_buf = h4->rx_buf;\n\tu8_t hdr_len = h4->rx_buf_len;\n\tu8_t hdr_rem = h4->rx_buf_len - h4->rx_buf_bytes_read;\n\n\tbytes_read = api->fifo_read(dev, hdr_buf + h4->rx_buf_bytes_read, hdr_rem);\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"UART FIFO read error\");\n\t\treturn;\n\t}\n\n\th4->rx_buf_bytes_read += bytes_read;\n}", "CodeBleu_score": 38.55656323927587}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tunsigned char tmp_buf[33];\n    size_t ret;\n    ret = uart_fifo_read(uart, tmp_buf, len);\n    if (ret != len) {\n        LOG_ERR(\"Failed to discard %zu bytes\", len);\n        return 0;\n    }\n    return ret;\n}", "CodeBleu_score": 52.68191502768881}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t read;\n\n    read = uart_fifo_read(uart, buf, len);\n    if (read < len) {\n        LOG_ERR(\"Failed to discard %zu bytes\", len - read);\n    }\n\n    return read;\n}", "CodeBleu_score": 49.38939835517273}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t rx;\n    int ret;\n\n    ret = uart_fifo_read(uart, buf, sizeof(buf), &rx);\n    if (ret != 0) {\n        LOG_ERR(\"Failed to read from UART (err %d)\", ret);\n        return 0;\n    }\n\n    return rx;\n}", "CodeBleu_score": 56.5473544458964}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tuint32_t highest_observer_prio = UINT32_MAX;\n\tstruct zbus_observer *observer;\n\tuint32_t observer_prio;\n\tuint32_t observer_enabled;\n\tuint32_t observer_prio_mask;\n\tuint32_t observer_enabled_mask;\n\n\tobserver_prio_mask = 0x000000ff;\n\tobserver_enabled_mask = 0x0000ff00;\n\n\tfor (observer = chan->observer_list; observer; observer = observer->next) {\n\t\tobserver_prio = (observer->flags & observer_prio_mask);\n\t\tobserver_enabled = (observer->flags & observer_enabled_mask) >> 8;\n\n\t\tif (observer_enabled && (observer_prio < highest_observer_prio)) {\n\t\t\thighest_observer_prio = observer_prio;\n\t\t}\n\t}\n\n\tchan->highest_observer_prio = highest_observer_prio;\n}", "CodeBleu_score": 35.65413814754886}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tu32_t obs_prio = 0U;\n\tstruct z_waitq_set *set = &chan->waitq_set;\n\n\tz_waitq_set_lock(set);\n\tfor (int i = 0; i < CONFIG_ZBUS_CHANNEL_OBSERVERS; i++) {\n\t\tstruct zbus_observer *obs = &chan->observers[i];\n\n\t\tif (obs->enabled && obs->prio < obs_prio) {\n\t\t\tobs_prio = obs->prio;\n\t\t}\n\t}\n\tchan->highest_obs_prio = obs_prio;\n\tz_waitq_set_unlock(set);\n}", "CodeBleu_score": 22.925946981839886}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tstruct zbus_observer *obs;\n    uint8_t highest_prio = 0xFF;\n    uint8_t obs_prio;\n\n    _spin_lock(&chan->lock);\n\n    for (obs = chan->observers; obs; obs = obs->next) {\n        if (obs->enabled) {\n            obs_prio = obs->priority;\n\n            if (obs_prio < highest_prio) {\n                highest_prio = obs_prio;\n            }\n        }\n    }\n\n    chan->highest_obs_prio = highest_prio;\n\n    _spin_unlock(&chan->lock);\n}", "CodeBleu_score": 28.81481726012578}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_slist.num_used;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.427252015319283}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tSTRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {\n\t\tif (observation->obs == obs) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.409433932409385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_observation_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_observation_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.0254989503102}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t_ZBUS_ASSERT(obs != NULL, -EINVAL);\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\n\t_ZBUS_ASSERT(k_is_in_isr() == 0, -EINVAL);\n\n\tobs->prio = k_thread_priority_get(k_current_get());\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 51.293328576780354}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tZBUS_ASSERT(obs != NULL, \"Observer is null\");\n\tZBUS_ASSERT(!k_is_in_isr(), \"Observer cannot be attached from an ISR\");\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_obs_lock);\n\tobs->priority = K_PRIO_COOP(CONFIG_NUM_COOP_PRIORITIES - 1);\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_obs_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 46.333004800001326}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t_ZBUS_ASSERT(obs != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n\n\tif (obs->prio != K_LOWEST_THREAD_PRIO) {\n\t\tobs->prio = K_LOWEST_THREAD_PRIO;\n\t\tupdate_all_channels_hop(obs);\n\t}\n\n\tk_spin_unlock(&zbus_spinlock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 49.200065070763166}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"zbus channel must not be NULL\");\n\n\tint prio = 0;\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 62.47224765501914}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tint prio;\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\tLOG_ERR(\"could not lock channel %s. Error code %d\", _ZBUS_CHAN_NAME(chan), err);\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 47.99679038285526}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tint err = 0;\n\tint prio = 0;\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\t/* If the timeout is infinite, the notification will be done in the next\n\t\t * execution of the zbus_vded_exec() function\n\t\t */\n\t\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* If the timeout is not infinite, the notification will be done in the next\n\t\t * execution of the zbus_vded_exec() function, but only if the timeout is not\n\t\t * expired\n\t\t */\n\t\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT) || sys_timepoint_is_expired(end_time)) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 65.55968971402505}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (enable) {\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            ETH->INTEN |= Int;\n        } else if (IS_ETH_INT_NORMAL(Int)) {\n            ETH->INTEN |= Int;\n        }\n    } else {\n        ETH->INTEN &= ~Int;\n    }\n}", "CodeBleu_score": 31.12822528732756}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t/* Check the parameters */\n    assert_param(IS_ETH_INT(Int));\n    assert_param(IS_BOOL(enable));\n    if (enable) {\n        /* Enable the selected interrupt */\n        ETH->INTEN |= Int;\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            /* Enable the selected abnormal interrupt */\n            ETH->INTENA |= Int;\n        }\n    } else {\n        /* Disable the selected interrupt */\n        ETH->INTEN &= ~Int;\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            /* Disable the selected abnormal interrupt */\n            ETH->INTENA &= ~Int;\n        }\n    }\n}", "CodeBleu_score": 44.02673125860475}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tuint32_t tmp = 0;\n    assert_param(IS_ETH_INT(Int));\n    assert_param(IS_BOOL(enable));\n\n    if (enable) {\n        if (Int & IS_ETH_INT_ABNORMAL) {\n            ETH->INT_EN |= (Int & IS_ETH_INT_ABNORMAL);\n        } else {\n            ETH->INT_EN |= (Int & IS_ETH_INT_NORMAL);\n        }\n    } else {\n        ETH->INT_EN &= ~Int;\n        tmp = ETH->INT_EN;\n        if (tmp & IS_ETH_INT_ABNORMAL) {\n            ETH->INT_EN = (tmp & IS_ETH_INT_ABNORMAL);\n        } else {\n            ETH->INT_EN = (tmp & IS_ETH_INT_NORMAL);\n        }\n    }\n}", "CodeBleu_score": 50.39974324396119}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc = (ETH_TX_DESC *)ETH_BASE_ADDR;\n    uint32_t txDescIndex = 0;\n    uint32_t txDescCount = 0;\n\n    while (1) {\n        if (pTxDesc->tdes0.bits.own == 0) {\n            break;\n        }\n\n        txDescIndex++;\n        if (txDescIndex == ETH_TX_DESC_CNT) {\n            txDescIndex = 0;\n        }\n\n        if (txDescCount++ == ETH_TX_DESC_CNT) {\n            return 0;\n        }\n\n        pTxDesc = (ETH_TX_DESC *)((uint32_t)pTxDesc + sizeof(ETH_TX_DESC));\n    }\n\n    return pTxDesc;\n}", "CodeBleu_score": 39.10811228817881}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n  uint32_t i;\n\n  pTxDesc = (ETH_TX_DESC *)ETH_DMA->TDLAR;\n  for (i = 0; i < ETH_TX_DESC_CNT; i++) {\n    if ((pTxDesc->Status & ETH_TDES_OWN) == 0) {\n      return pTxDesc;\n    }\n    pTxDesc++;\n  }\n  return 0;\n}", "CodeBleu_score": 35.61438527537429}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc = (ETH_TX_DESC *)ETH_TX_DESC_BASE;\n  uint32_t i;\n\n  for (i = 0; i < ETH_TX_DESC_CNT; i++) {\n    if ((pTxDesc->Status & ETH_TDES0_OWN) == 0) {\n      return pTxDesc;\n    }\n    pTxDesc++;\n  }\n  return 0;\n}", "CodeBleu_score": 36.151762916697415}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n    CY_CSDIDAC_OUTPUT_t cyp_dac_output;\n    CY_CSDIDAC_CHANNEL_t cyp_dac_channel;\n    CY_CSDIDAC_REF_t cyp_dac_ref;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n    cyp_dac_ref = CY_CSDIDAC_REF_VDDA;\n    cyp_dac_output.value = *value;\n    cyp_dac_output.ref = cyp_dac_ref;\n    cyp_dac_output.state = CY_CSDIDAC_OUTPUT_ENABLED;\n\n    LOG_D(\"cyp_adc_convert channel:%d, value:%d\", channel, *value);\n\n    if (Cy_CSDIDAC_OutputEnable((CY_CSDIDAC_T *)device->parent.user_data, cyp_dac_channel, &cyp_dac_output) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"cyp_adc_convert channel:%d, value:%d\", channel, *value);\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 51.25430660670811}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t ret = RT_EOK;\n    rt_uint32_t cyp_dac_channel = 0;\n    rt_uint32_t cyp_dac_value = 0;\n    cy_stc_csd_dac_config_t cyp_dac_config;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n    cyp_dac_value = *value;\n\n    cyp_dac_config.refSel = CY_CSDIDAC_VREF;\n    cyp_dac_config.outputMode = CY_CSDIDAC_OUTPUT_MODE_1X;\n    cyp_dac_config.gainSel = CY_CSDIDAC_GAIN_1X;\n    cyp_dac_config.deglitchMode = CY_CSDIDAC_DEGLITCH_DISABLE;\n    cyp_dac_config.outputSwingMode = CY_CSDIDAC_OUTPUT_SWING_DISABLE;\n    cyp_dac_config.outputBuffer = CY_CSDIDAC_OUTPUT_BUFFER_ENABLE;\n    cyp_dac_config.deepSleep = CY_CSDIDAC_DEEPSLEEP_DISABLE;\n\n    if (Cy_CSDIDAC_Init(device->parent.user_data, cyp_dac_channel, &cyp_dac_config) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Cy_CSDIDAC_Init error\");\n        ret = -RT_ERROR;\n    }\n    else\n    {\n        if (Cy_CSDIDAC_OutputEnable(device->parent.user_data, cyp_dac_channel, cyp_dac_value) != CY_CSDIDAC_SUCCESS)\n        {\n            LOG_E(\"Cy_CSDIDAC_OutputEnable", "CodeBleu_score": 47.43958544356741}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n    rt_uint32_t cyp_dac_channel;\n    rt_uint32_t cyp_dac_value;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    cyp_dac_value = *value;\n\n    if (cy_ret_status_success != Cy_CSDIDAC_OutputEnable(cyp_dac_channel, cyp_dac_value)) {\n        LOG_E(\"cyp_adc_convert failed\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 58.54636779342495}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tint i;\n\tint ret = RT_EOK;\n\tif (addr + size > FLASH_START_ADDR + FLASH_SIZE) {\n\t\tLOG_E(\"read out of flash range[0x%08X - 0x%08X]\", FLASH_START_ADDR, FLASH_START_ADDR + FLASH_SIZE);\n\t\tret = -RT_EINVAL;\n\t}\n\telse {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 47.133806695054496}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > IFX_FLASH_END_ADDR) {\n        LOG_E(\"Read operation would exceed flash memory end address! Address: 0x%08x, Size: %d\", addr, size);\n        return -RT_EINVAL;\n    }\n\n    for (int i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 50.185771055183025}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > FLASH_END_ADDRESS) {\n\t\tLOG_E(\"read out of flash range [0x%08x - 0x%08x]\", FLASH_START_ADDRESS, FLASH_END_ADDRESS);\n\t\treturn -RT_EINVAL;\n\t}\n\n\twhile (size) {\n\t\t*buf = *(rt_uint8_t *) (addr);\n\t\tbuf++;\n\t\taddr++;\n\t\tsize--;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.69588302660644}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    RT_ASSERT(timer->timer_device != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->timer_device;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 55.70146886762918}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    RT_ASSERT(timer->parent.user_data != RT_NULL);\n    return cyhal_timer_read((cyhal_timer_t *)timer->parent.user_data);\n}", "CodeBleu_score": 53.865396278766}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\tRT_ASSERT(obj != RT_NULL);\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 56.67416441010567}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t/* Acquire the lock. */\n    while (rt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER) != RT_EOK)\n        ;\n}", "CodeBleu_score": 20.623210086365066}, {"code": "void dfs_lock(void){\n\trt_mutex_take(dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.224544984631455}, {"code": "void dfs_lock(void){\n\tint result;\n    result = rt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 18.591029280933107}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n    int index;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        if (!fdt->fds[index])\n        {\n            return index;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, index);\n    if (fd >= 0)\n    {\n        return fd;\n    }\n\n    return -1;\n}", "CodeBleu_score": 42.9131963878673}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n    int index;\n\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        if (!fdt->fds[index])\n        {\n            return index;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, index);\n    if (fd < 0)\n    {\n        return -1;\n    }\n\n    return fd;\n}", "CodeBleu_score": 43.308591877268455}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, fd);\n    return fd;\n}", "CodeBleu_score": 31.85016348106386}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\trt_uint32_t index;\n    rt_uint32_t err_num;\n\n    err_num = (error < 0) ? -error : error;\n    for (index = 0; index < sizeof(error_desc) / sizeof(error_desc[0]); index++) {\n        if (err_num == error_desc[index].num) {\n            return error_desc[index].desc;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 51.05067255338245}, {"code": "const char *rt_strerror(rt_err_t error){\n\trt_int32_t index;\n    static const char *error_strings[] = {\n        \"EOK\",\n        \"ERROR\",\n        \"ENOMEM\",\n        \"EINVAL\",\n        \"EIO\",\n        \"ENOSYS\",\n        \"EBUSY\",\n        \"EINTR\",\n        \"EINVAL\",\n        \"ENODEV\",\n        \"EDEV_ALREADY_OPEN\",\n        \"EDEV_NOT_OPEN\",\n        \"EDEV_NOT_CLOSED\",\n        \"EDEV_NOT_INIT\",\n        \"EDEV_NOT_REGISTERED\",\n        \"EDEV_NOT_OPENED\",\n        \"EDEV_NOT_CLOSED\",\n        \"EDEV_NOT_READY\",\n        \"EDEV_NOT_RUNNING\",\n        \"EDEV_NOT_PAUSED\",\n        \"EDEV_NOT_STOPPED\",\n        \"EDEV_NOT_SUSPENDED\",\n        \"EDEV_NOT_RESUMED\",\n        \"EDEV_NOT_STARTED\",\n        \"EDEV_NOT_STOPPED\",\n        \"EDEV_NOT_SUSPENDED\",\n        \"EDEV_NOT_RESUMED\",\n        \"EDEV_NOT_STARTED\",\n        \"EDEV_NOT_STOPPED\",\n        \"EDEV_NOT_SUSPENDED\",\n        \"EDEV_NOT_RESUMED\",\n        \"EDEV_NOT_STARTED\",\n        \"EDEV_NOT_STOPPED\",\n        \"EDEV_NOT_SUSPENDED\",\n        \"EDEV_NOT_RESUMED\",\n        \"EDEV_NOT_STARTED\",\n        \"EDEV_NOT_STOPPED\",\n        \"EDEV_NOT_SUSPENDED\",\n        \"EDEV_NOT_RESUMED\",\n        \"EDEV_NOT_STARTED\",\n        \"EDEV_NOT_ST", "CodeBleu_score": 5.9017823298553065}, {"code": "const char *rt_strerror(rt_err_t error){\n\trt_uint32_t index;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (index = 0; index < sizeof(error_tab) / sizeof(error_tab[0]); index++) {\n        if (error_tab[index].errcode == error) {\n            return error_tab[index].errmsg;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 62.053092247803306}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t index;\n    rt_base_t temp;\n    rt_err_t result;\n\n    /* disable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* try to find an empty slot */\n    for (index = 0; index < RT_IDLE_HOOK_LIST_SIZE; index++) {\n        if (rt_idle_hook_list[index] == RT_NULL) {\n            rt_idle_hook_list[index] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* no empty idle hook entry */\n    if (index >= RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    return result;\n}", "CodeBleu_score": 62.61045461116679}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t index;\n    rt_err_t result = RT_EOK;\n    rt_thread_idle_t idle;\n\n    idle = &(rt_object_system.thread.idle);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* find an empty idle hook slot */\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_LIST_SIZE; index++) {\n        if (idle->idle_hook_list[index] == RT_NULL) {\n            idle->idle_hook_list[index] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (index == RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 54.80372485996384}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t lock;\n    rt_err_t result = RT_EOK;\n    struct rt_idle_hook *idle;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    lock = rt_spin_lock_irqsave(&rt_object_container[RT_Object_Class_IdleHook].lock);\n    idle = &rt_object_container[RT_Object_Class_IdleHook].object_list;\n    while (idle->next != idle) {\n        if (idle->next->hook == hook) {\n            result = -RT_EFULL;\n            break;\n        }\n\n        idle = idle->next;\n    }\n\n    if (result == RT_EOK) {\n        idle->next->hook = hook;\n    }\n\n    rt_spin_unlock_irqrestore(&rt_object_container[RT_Object_Class_IdleHook].lock, lock);\n\n    return result;\n}", "CodeBleu_score": 44.57984753883806}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_uint32_t i;\n    rt_err_t result = RT_EOK;\n\n    rt_enter_critical();\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_idle_hook_list[i] == hook) {\n            rt_idle_hook_list[i] = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_ERROR;\n    }\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 69.20104175465367}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_base_t index;\n    rt_err_t result = -RT_ERROR;\n\n    rt_spin_lock_irqsave(&_rt_thread_idle_lock);\n\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_LIST_SIZE; index++) {\n        if (_rt_thread_idle_hook_list[index] == hook) {\n            _rt_thread_idle_hook_list[index] = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 61.69674436773601}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_base_t level;\n    rt_err_t result = RT_EOK;\n    struct rt_thread *tid;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    tid = rt_thread_self();\n    if (tid->idle != RT_NULL) {\n        struct rt_idle_hook *idle;\n\n        idle = tid->idle;\n        while (idle != RT_NULL) {\n            if (idle->idle_hook == hook) {\n                idle->idle_hook = RT_NULL;\n                result = RT_EOK;\n                break;\n            }\n\n            idle = idle->next;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 43.32051007515865}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\tstruct rt_thread *thread;\n    rt_err_t result;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* ensure the scheduler is unlocked */\n    result = rt_enter_critical();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* resume thread */\n        rt_thread_resume(thread);\n        /* remove thread from suspended list */\n        rt_suspended_list_remove(thread);\n        /* set error code */\n        thread->error = thread_error;\n    }\n\n    /* release scheduler */\n    rt_exit_critical(result);\n\n    return RT_EOK;\n}", "CodeBleu_score": 38.71383239564875}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\tstruct rt_thread *thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    while (!rt_list_isempty(susp_list)) {\n        /* get thread entry */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* remove thread from suspended list */\n        rt_suspended_list_remove(thread);\n\n        /* resume thread */\n        rt_thread_resume(thread);\n\n        /* set error code */\n        thread->error = thread_error;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 42.47090157894464}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\tstruct rt_thread *thread;\n\n    /* ensure the scheduler is unlocked */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /*\n     * dequeue and wakeup all suspended thread in the list\n     * until the list is empty\n     */\n    while (!rt_list_isempty(susp_list)) {\n        /* get suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* remove thread from suspended list */\n        rt_suspended_list_remove(thread);\n\n        /* wakeup thread */\n        rt_thread_resume(thread);\n\n        /* set error code */\n        thread->error = thread_error;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 46.60021194538517}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console;\n    rt_device_t new_console;\n\n    old_console = rt_console_get_device();\n    if (old_console != RT_NULL) {\n        if (rt_strcmp(name, old_console->parent.name) == 0) {\n            return old_console;\n        }\n        rt_device_close(old_console);\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 54.092062377052876}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    RT_ASSERT(name != RT_NULL);\n\n    /* disable interrupt */\n    rt_base_t level;\n    level = rt_hw_interrupt_disable();\n\n    /* get old console device */\n    old_console = console_device;\n\n    /* find new console device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        rt_kprintf(\"can't find device: %s\n\", name);\n        goto __exit;\n    }\n\n    /* check if the new device is the same as the old device */\n    if (old_console == new_console) {\n        goto __exit;\n    }\n\n    /* close old console device */\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    /* open new console device */\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        rt_kprintf(\"open device: %s failed\n\", name);\n        goto __exit;\n    }\n\n    /* set new console device */\n    console_device = new_console;\n\n__exit:\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return old_console;\n}", "CodeBleu_score": 55.51951227502234}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) return RT_NULL;\n\n    /* disable interrupt */\n    rt_base_t level;\n    level = rt_hw_interrupt_disable();\n\n    /* save old console */\n    old_console = console_device;\n\n    /* find new console */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        rt_kprintf(\"Can't find device: %s\n\", name);\n        goto __exit;\n    }\n\n    /* close old console */\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    /* open new console */\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        rt_kprintf(\"Can't open device: %s\n\", name);\n        goto __exit;\n    }\n\n    /* set new console */\n    console_device = new_console;\n\n__exit:\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return old_console;\n}", "CodeBleu_score": 55.94351097543531}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint count = 0;\n    struct rt_object_information *information;\n\n    information = rt_object_get_information(type);\n    if (information != RT_NULL) {\n        rt_spin_lock_irqsave(&(information->object_list_lock));\n        rt_list_for_each_entry(information->object_list,\n                               struct rt_object,\n                               list) {\n            count++;\n        }\n        rt_spin_unlock_irqrestore(&(information->object_list_lock));\n    }\n\n    return count;\n}", "CodeBleu_score": 58.55467945734583}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tstruct rt_object_information *information;\n    struct rt_object *object;\n    int length = 0;\n    rt_base_t level;\n\n    information = rt_object_get_information(type);\n    if (information == RT_NULL) return 0;\n\n    level = rt_spin_lock_irqsave(&(information->object_list_lock));\n    rt_list_for_each_entry(object, &(information->object_list), list)\n    {\n        length++;\n    }\n    rt_spin_unlock_irqrestore(&(information->object_list_lock), level);\n\n    return length;\n}", "CodeBleu_score": 61.613762453705135}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint count = 0;\n\tstruct rt_object *object;\n\tstruct rt_object_information *information;\n\tregister rt_base_t temp;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL)\n\t\treturn 0;\n\n\t/* lock object list */\n\ttemp = rt_spin_lock_irqsave(&(information->object_list_lock));\n\n\t/* traverse the object list */\n\tobject = rt_list_first(&(information->object_list));\n\twhile (object != RT_NULL)\n\t{\n\t\tcount ++;\n\t\tobject = rt_list_next(&(object->list));\n\t}\n\n\t/* unlock object list */\n\trt_spin_unlock_irqrestore(&(information->object_list_lock), temp);\n\n\treturn count;\n}", "CodeBleu_score": 65.28468260770858}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\tregister rt_list_t *object_list;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* call object detach hook */\n    if (rt_object_is_systemobject(object))\n        RT_OBJECT_HOOK_CALL(object, detach);\n\n    /* get object list */\n    object_list = rt_object_get_information(object)->object_list;\n\n    /* remove object from object list */\n    rt_spin_lock_irqsave(rt_object_get_information(object)->object_lock);\n    rt_list_remove(&(object->list));\n    rt_spin_unlock_irqrestore(rt_object_get_information(object)->object_lock);\n\n    /* set object type */\n    object->type = 0;\n}", "CodeBleu_score": 43.88942419477764}, {"code": "void rt_object_detach(rt_object_t object){\n\tregister rt_base_t temp;\n    register rt_object_t *object_list;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* object type check */\n    RT_ASSERT(object->type != RT_Object_Class_Unknown);\n\n    /* call object detach hook */\n    RT_OBJECT_HOOK_CALL(object, detach);\n\n    /* get object information */\n    object->type = RT_Object_Class_Unknown;\n    object_list = &(RT_KERNEL->object_list[object->type]);\n\n    /* lock object list */\n    rt_spin_lock_irqsave(&(RT_KERNEL->lock));\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object list */\n    rt_spin_unlock_irqrestore(&(RT_KERNEL->lock));\n}", "CodeBleu_score": 50.4496488993754}, {"code": "void rt_object_detach(rt_object_t object){\n\tstruct rt_object_information *information;\n    register rt_base_t temp;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    information = (struct rt_object_information *)object;\n    RT_ASSERT(information != RT_NULL);\n\n    /* call object detach hook */\n    RT_OBJECT_HOOK_CALL(object, detach);\n\n    /* lock object */\n    rt_spin_lock_irqsave(&(information->object_lock));\n\n    /* remove object from object list */\n    rt_list_remove(&(information->object_list));\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&(information->object_lock));\n\n    /* set object type to null */\n    object->type = 0;\n}", "CodeBleu_score": 55.527467301346626}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t ret = RT_EOK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    if (custom_obj->destroy) {\n        ret = custom_obj->destroy(custom_obj);\n    }\n\n    rt_object_delete(obj);\n\n    return ret;\n}", "CodeBleu_score": 43.05255292599366}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n\n    /* parameter check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* call object destroy function */\n    if (obj->type == RT_Object_Class_Custom) {\n        if (obj->module_id != RT_NULL) {\n            result = ((rt_custom_destroy_t)(obj->module_id))(obj);\n        }\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 52.21874010872225}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n    struct rt_object_information *information;\n\n    RT_ASSERT(obj != RT_NULL);\n\n    information = rt_object_get_information((enum rt_object_class_type)obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    if (information->object_destroy != RT_NULL)\n        result = information->object_destroy(obj);\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 47.160539924700416}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* do schedule */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 63.68800825860068}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_scheduler_add_defunct_thread(thread);\n\n    /* do schedule */\n    rt_schedule();\n}", "CodeBleu_score": 56.693056738178704}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_schedule_lock();\n    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));\n    rt_schedule_unlock();\n\n    /* trigger scheduling */\n    rt_schedule();\n}", "CodeBleu_score": 36.155853581599644}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\n    /* thread check */\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (struct rt_thread *)parameter;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat != RT_THREAD_CLOSE);\n    RT_ASSERT(thread->stat != RT_THREAD_INIT);\n\n    /* thread is suspended? */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread timeout: 0x%08x\n\", thread));\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_sched_lock();\n    rt_sched_remove_thread(thread);\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 62.58048833589229}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    /* get thread */\n    thread = (struct rt_thread *)parameter;\n\n    /* thread checking */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* thread suspended? */\n    if (rt_schedulable(thread) == RT_FALSE)\n    {\n        /* set error number */\n        thread->error = -RT_ETIMEOUT;\n\n        /* remove from suspend list */\n        rt_sched_remove_thread(thread);\n\n        /* insert to schedule ready list */\n        rt_sched_insert_thread(thread);\n\n        /* reschedule */\n        rt_schedule();\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n}", "CodeBleu_score": 58.253397259150894}, {"code": "static void _thread_timeout(void *parameter){\n\trt_thread_t thread;\n\n    /* parameter check */\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (rt_thread_t)parameter;\n\n    /* lock scheduler */\n    rt_sched_lock();\n\n    /* thread check */\n    RT_ASSERT(rt_object_get_type(&thread->parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent));\n\n    /* thread suspend check */\n    RT_ASSERT(thread->stat & RT_THREAD_STAT_SUSPENDED);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to schedule ready list */\n    rt_sched_insert_thread(thread);\n\n    /* unlock scheduler */\n    rt_sched_unlock();\n\n    /* do a schedule */\n    rt_schedule();\n}", "CodeBleu_score": 54.089036018095015}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_base_t lock_state;\n    rt_mutex_t mutex;\n    rt_list_t *l;\n\n    lock_state = rt_spin_lock_irqsave(&thread->spinlock);\n\n    if (thread->pending_object != RT_NULL) {\n        /* waiting on an object */\n        if (rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex) {\n            mutex = (rt_mutex_t)thread->pending_object;\n            l = &(mutex->owner_list);\n\n            /* remove thread from mutex's waiting list */\n            rt_list_remove(&(thread->tlist));\n\n            /* remove thread from mutex's owner list */\n            if (rt_list_isempty(l)) {\n                /* no owner */\n                mutex->owner = RT_NULL;\n            }\n            else {\n                /* get next owner */\n                mutex->owner = rt_list_entry(l->next,\n                                             struct rt_thread,\n                                             tlist);\n            }\n\n            /* clear pending object */\n            thread->pending_object = RT_NULL;\n        }\n    }\n\n    /* release all mutexes */\n    while (thread->mutex_list != RT_NULL) {\n        mutex = rt_list_entry(thread->mutex_list,\n                              struct rt_mutex,\n                              parent.list);\n\n        rt_mutex_release(mutex);\n    }\n\n    rt_spin_unlock_irqrestore(&thread->spinlock, lock_state);\n}", "CodeBleu_score": 55.50390897759827}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_list_t *l;\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"detach thread:%s from mutex\n\", thread->name));\n\n    rt_spin_lock_irqsave(&thread->spinlock);\n\n    /* detach from mutex */\n    if (thread->pending_object != RT_NULL) {\n        mutex = (rt_mutex_t)thread->pending_object;\n\n        /* remove from suspended list */\n        l = &(mutex->suspended_list);\n        while (l->next != &(thread->tlist)) {\n            l = l->next;\n        }\n\n        /* remove thread from suspended list */\n        rt_list_remove(l);\n\n        /* set error code to RT_ERROR */\n        thread->error = -RT_ERROR;\n\n        /* clear suspended object */\n        thread->pending_object = RT_NULL;\n\n        /* resume thread */\n        rt_thread_resume(thread);\n    }\n\n    /* release all mutexes */\n    rt_mutex_release(thread);\n\n    rt_spin_unlock_irqrestore(&thread->spinlock);\n}", "CodeBleu_score": 48.520390342733464}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tstruct rt_mutex *mutex;\n    rt_list_t *node, *next;\n    rt_base_t lock_state;\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread detach from mutex\n\"));\n\n    /* get mutex spinlock */\n    lock_state = rt_spin_lock_irqsave(&thread->spinlock);\n\n    /* check if the thread is waiting on a mutex */\n    if (thread->pending_object != RT_NULL) {\n        /* check if the pending object is a mutex */\n        if (rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex) {\n            /* get mutex object */\n            mutex = (struct rt_mutex *)thread->pending_object;\n\n            /* remove thread from the mutex's waiting list */\n            rt_list_remove(&(thread->tlist));\n\n            /* clear pending object */\n            thread->pending_object = RT_NULL;\n\n            /* release mutex spinlock */\n            rt_spin_unlock_irqrestore(&(mutex->lock), lock_state);\n\n            /* resume thread */\n            rt_thread_resume(thread);\n        }\n        else {\n            /* release mutex spinlock */\n            rt_spin_unlock_irqrestore(&(thread->spinlock), lock_state);\n        }\n    }\n    else {\n        /* release mutex spinlock */\n        rt_spin_unlock_irqrestore(&(thread->spinlock), lock_state);\n    }\n\n    /* release all mutexes the thread has taken */\n    rt_mutex_release(thread);\n}", "CodeBleu_score": 50.56625224202476}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    error = rt_sched_thread_startup(thread);\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 49.42530978396682}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_startup(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.39617981948279}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n    rt_sched_lock_level_t slvl;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    rt_sched_lock(&slvl);\n\n    /* check thread state */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"startup thread: %s\n\", thread->name));\n\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* calculate priority attribute */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"startup thread: %s priority: %d\n\",\n                                   thread->name, thread->init_priority));\n\n    /* reset thread state */\n    thread->stat = RT_THREAD_READY;\n\n    /* insert to schedule ready queue */\n    rt_sched_insert_thread(thread);\n\n    /* if current thread is higher than the thread to be started,\n     * it will be rescheduled.\n     */\n    result = rt_sched_unlock_n_resched(slvl);\n\n    /* thread startup hook */\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return result;\n}", "CodeBleu_score": 52.868165799880785}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_list_t *l;\n    rt_timer_t timer;\n\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n\n    l = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next;\n    timer = rt_list_entry(l, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1].list);\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 68.1809357541318}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_err_t ret = RT_EOK;\n    rt_tick_t tick;\n    rt_list_t *timer_head;\n    struct rt_timer *timer;\n    rt_list_t *level;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    /* get the first timer list */\n    timer_head = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n    /* check if timer list is empty */\n    if (rt_list_isempty(timer_head)) {\n        ret = -RT_ETIMEOUT;\n        goto __exit;\n    }\n\n    /* get the first timer */\n    timer = rt_list_entry(timer_head, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    /* set the timeout tick */\n    tick = timer->timeout_tick;\n\n    /* check the timeout tick */\n    if (tick < *timeout_tick) {\n        *timeout_tick = tick;\n    }\n\n__exit:\n    return ret;\n}", "CodeBleu_score": 54.267118475491806}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_timer_t timer;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    if (rt_list_isempty(&timer_list[0])) {\n        return -RT_ERROR;\n    }\n\n    timer = rt_list_entry(timer_list[0].next, struct rt_timer, list);\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 53.48013757119697}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer object */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 63.361007651486425}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate timer */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 69.22957909191922}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer object */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* return timer object */\n    return timer;\n}", "CodeBleu_score": 57.55331387667868}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar rec *httptest.ResponseRecorder\n\tvar handler http.Handler\n\n\tfor _, handler = range a.handlers {\n\t\trec = httptest.NewRecorder()\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor key, values := range rec.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\t\tif rec.Code == 401 {\n\t\t\thttp.Error(res, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 50.55628709732628}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, handler := range a.handlers {\n\t\trec := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 91.09311747754766}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar (\n\t\trec = httptest.NewRecorder()\n\t\th   = a.handler\n\t)\n\tfor {\n\t\th.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif h = a.router; h == nil {\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 58.40141296760572}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tdata, err := Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\text := strings.Split(path, \".\")[1]\n\tswitch ext {\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(data)\n}", "CodeBleu_score": 59.13595283478587}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tasset, err := a.Assets.Get(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\text := strings.Split(asset.Name, \".\")[1]\n\tres.Header().Set(\"Content-Type\", \"text/\"+ext)\n\tres.Write(asset.Content)\n}", "CodeBleu_score": 40.02062839334323}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\text := strings.Split(path, \".\")\n\tswitch ext[len(ext)-1] {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tpanic(\"Unknown file type\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 61.43041809931198}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"robot '%s' not found\"}`, robotName)))\n\t\treturn\n\t}\n\n\tconnections := []map[string]interface{}{}\n\n\trobot.Connections().Each(func(name string, c gobot.Connection) {\n\t\tconnection := map[string]interface{}{\n\t\t\t\"name\": name,\n\t\t\t\"type\": c.Name(),\n\t\t}\n\n\t\tswitch c.(type) {\n\t\tcase *gobot.Adaptor:\n\t\t\tconnection[\"adaptor\"] = c.(*gobot.Adaptor).Name()\n\t\tcase *gobot.DigitalReader:\n\t\t\tconnection[\"pin\"] = c.(*gobot.DigitalReader).Pin()\n\t\tcase *gobot.DigitalWriter:\n\t\t\tconnection[\"pin\"] = c.(*gobot.DigitalWriter).Pin()\n\t\tcase *gobot.AnalogReader:\n\t\t\tconnection[\"pin\"] = c.(*gobot.AnalogReader).Pin()\n\t\tcase *gobot.AnalogWriter:\n\t\t\tconnection[\"pin\"] = c.(*gobot.AnalogWriter).Pin()\n\t\tcase *gobot.I2cDevice:\n\t\t\tconnection[\"address\"] = c.(*gobot.I2cDevice).Address()\n\t\t\tconnection[\"bus\"] = c.(*gobot.I2cDevice).Bus()\n\t\tcase *gobot.Servo:\n\t\t\tconnection[\"pin\"] = c.(*gobot.Servo).Pin()\n\t\tcase *gobot.Sphero:\n\t\t\tconnection[\"port\"] = c.(*gobot.Sphero).Port()\n\t\tcase *gobot.SpheroDriver:\n\t\t\tconnection[\"port\"] = c.(*g", "CodeBleu_score": 45.185491497719745}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, 0)\n\trobot.Connections().Each(func(name string, conn gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":    name,\n\t\t\t\"address\": conn.Address(),\n\t\t\t\"type\":    conn.Type(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 52.15694412380327}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":name\")\n\n\trobot := a.master.Robot(robotName)\n\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\":\\\"No robot with name %s found\\\"}\", robotName)))\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, 0)\n\n\trobot.Connections().Each(func(name string, c gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\": name,\n\t\t\t\"type\": reflect.TypeOf(c).String(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 51.092689221977025}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// If the request has an Authorization header, validate it.\n\t\tif auth := r.Header.Get(\"Authorization\"); auth != \"\" {\n\t\t\t// If the header is not valid, return an error.\n\t\t\tif !isBasicAuth(auth) {\n\t\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// If the header is valid, decode the username and password.\n\t\t\tdecoded, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Check if the username and password are valid.\n\t\t\tif !secureCompare(username, string(decoded[:len(decoded)-1])) ||\n\t\t\t\t!secureCompare(password, string(decoded[len(decoded)-1:])) {\n\t\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t// If the request does not have an Authorization header, set the WWW-Authenticate header and return a 401 status.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 50.90727409323017}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0] != username || pair[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\t// OK\n\t\tfmt.Fprintf(w, \"Authorized\n\")\n\t}\n}", "CodeBleu_score": 47.623471399625636}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 || s[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Invalid Authorization header\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.48443004994583}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 58.903842823269684}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t// Calculate the slope and intercept for the scaling transformation.\n\tslope := float64(toMax-toMin) / (fromMax-fromMin)\n\tintercept := toMin - slope*fromMin\n\n\t// Return a function that performs the scaling.\n\treturn func(input float64) int {\n\t\t// Clamp the input to the input range.\n\t\tif input < fromMin {\n\t\t\tinput = fromMin\n\t\t} else if input > fromMax {\n\t\t\tinput = fromMax\n\t\t}\n\n\t\t// Calculate the scaled value.\n\t\tvalue := int(slope*input + intercept)\n\n\t\t// Clamp the output to the output range.\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 55.868816637599764}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Min(math.Max(input*slope+intercept, float64(toMin)), float64(toMax)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 58.00406974322547}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"no connection\")\n\t}\n\n\tif !a.Connection().AnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"connection doesn't support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 55.96753233200826}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"no connection\")\n\t}\n\n\tif !a.Connection().AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection doesn't support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.36125262410839}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"no connection\")\n\t}\n\n\tif !a.Connection().AnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 56.260447399777426}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 49.009868241731986}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(in int) float64 {\n\t\tif in <= fromMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif in >= fromMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn m*float64(in) + n\n\t}\n}", "CodeBleu_score": 79.36510858200347}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - float64(fromMin) * m\n\treturn func(x int) float64 {\n\t\tif x < fromMin {\n\t\t\treturn toMin\n\t\t} else if x > fromMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn float64(x) * m + n\n\t}\n}", "CodeBleu_score": 74.9410913663822}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\toptions := NewGrovePiezoVibrationSensorDriverOptions()\n\tfor _, o := range opts {\n\t\tif o, ok := o.(func(*GrovePiezoVibrationSensorDriverOptions)); ok {\n\t\t\to(&options)\n\t\t}\n\t}\n\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname:   gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tvEvent: NewEvent(),\n\t\ta:      NewAnalogSensorDriver(a, pin, options.AnalogSensorDriverOptions),\n\t}\n\n\tg.a.On(g.a.Event(data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tg.vEvent.Publish(data)\n\t\t}\n\t})\n\n\treturn g\n}", "CodeBleu_score": 44.36347974670552}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tvibe: gobot.NewEvent(),\n\t\tconn: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.AddEvent(d.Event(\"Vibration\"))\n\n\td.conn.On(d.Event(\"Data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(\"Vibration\"), data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 44.68860906063456}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tconn: a,\n\t\tpin:  pin,\n\t}\n\n\td.AddEvent(VibrationEvent)\n\n\td.AddEvent(DataEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)\n\n\td.AddEvent(ErrorEvent)", "CodeBleu_score": 25.96868950482359}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz < 0 {\n\t\treturn errors.New(\"Invalid frequency: \" + strconv.FormatFloat(hz, 'f', -1, 64))\n\t}\n\n\tif duration < 0 {\n\t\treturn errors.New(\"Invalid duration: \" + strconv.FormatFloat(duration, 'f', -1, 64))\n\t}\n\n\tif hz == 0 {\n\t\treturn d.Off()\n\t}\n\n\tif duration == 0 {\n\t\treturn d.On()\n\t}\n\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := time.Duration(60.0 / (hz * d.BPM))\n\ttempo := time.Duration(duration * 1000.0)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < int(tempo/tonePeriod); i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(tonePeriod)\n\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(tonePeriod)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 53.19111802897329}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz < 0 {\n\t\treturn errors.New(\"BuzzerDriver.Tone: hz must be greater than 0\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"BuzzerDriver.Tone: duration must be greater than 0\")\n\t}\n\tif d.beatsPerMinute <= 0 {\n\t\treturn errors.New(\"BuzzerDriver.Tone: beatsPerMinute must be greater than 0\")\n\t}\n\n\t// Calculate the period of the tone in nanoseconds\n\tperiod := int64(time.Duration(1e9 / hz))\n\t// Calculate the duration of the tone in nanoseconds\n\tdurationNanoseconds := int64(time.Duration(duration * float64(time.Second)))\n\t// Calculate the number of beats per tone period\n\tbeatsPerPeriod := int64(float64(period) / float64(d.period))\n\t// Calculate the number of tones per tone period\n\ttonesPerPeriod := int64(float64(period) / float64(d.tonePeriod))\n\t// Calculate the number of periods in the tone\n\tperiods := int64(durationNanoseconds / period)\n\t// Calculate the number of beats in the tone\n\tbeats := int64(float64(periods) * float64(beatsPerPeriod))\n\t// Calculate the number of tones in the tone\n\ttones := int64(float64(periods) * float64(tonesPerPeriod))\n\n\t// Toggle the buzzer on and off at the appropriate intervals\n\tfor i := int64(0); i < tones; i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(d.tonePeriod))\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(period - d.tonePeriod))\n\t}\n\n\t// Toggle the buzzer on and off at the appropriate intervals\n\tfor i := int64(0); i < beats; i++ {\n\t\td", "CodeBleu_score": 35.07628841008441}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz <= 0 {\n\t\treturn errors.New(\"Invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Invalid duration\")\n\t}\n\tif d.tempo <= 0 {\n\t\treturn errors.New(\"Invalid tempo\")\n\t}\n\tif d.pin == 0 {\n\t\treturn errors.New(\"Invalid pin\")\n\t}\n\n\tperiod := time.Duration(1e9 / hz)\n\ttempo := time.Duration(60e9 / d.tempo)\n\n\td.On()\n\tfor i := 0; i < int(duration*float64(time.Second)/float64(tempo)); i++ {\n\t\ttime.Sleep(period)\n\t\td.Off()\n\t\ttime.Sleep(tempo - period)\n\t\td.On()\n\t}\n\td.Off()\n\n\treturn nil\n}", "CodeBleu_score": 32.12326014445574}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\tif !d.isRunning {\n\t\treturn fmt.Errorf(\"driver not running\")\n\t}\n\td.stop()\n\td.digitalWrite(d.sleepPin, 0)\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 35.14072289111252}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.02837441856197}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.659699622812788}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins Map Not Initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin := sysfs.NewAnalogPin(a.translate(id))\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 35.13054443251002}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin := a.translate(id)\n\n\tif pin == nil {\n\t\treturn nil, fmt.Errorf(\"Could not translate pin with ID: %s\", id)\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 47.611578384716935}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins not initialized, must call Init()\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp, err := a.NewAnalogPin(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 51.65651871764515}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, gpio.Out)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 76.20915659681624}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, gpio.Out)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := pin.Write(gpio.Level(val)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 67.3903546472673}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, system.WithPinDirectionOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = pin.Write(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 71.68557980554598}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif _, ok := a.pins[id]; !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin := a.NewDigitalPin(chip, line, opts...)\n\t\ta.pins[id] = pin\n\t\ta.initialize()\n\t} else {\n\t\ta.pins[id].ApplyOptions(opts...)\n\t}\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 47.442749536991954}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tif a.pins[id] == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = a.sys.NewDigitalPin(chip, line)\n\t\ta.pins[id].ApplyOptions(opts...)\n\t\tif err := a.initialize(a.pins[id]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\ta.pins[id].ApplyOptions(opts...)\n\t}\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 56.01434162812724}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tif a.pins[id] == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = a.sys.NewDigitalPin(chip, line)\n\t\tif err := a.initialize(a.pins[id]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin.ApplyOptions(a.pins[id], opts...)\n}", "CodeBleu_score": 54.14461630139024}]}
