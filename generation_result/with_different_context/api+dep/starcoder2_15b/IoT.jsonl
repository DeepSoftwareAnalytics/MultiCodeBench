{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id)\n\t\t\treturn desc;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.780813376423666}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * desc_ptr = desc;\n\twhile (desc_ptr->bLength!= 0) {\n\t\tif (desc_ptr->bDescriptorType == desc_id) {\n\t\t\treturn desc_ptr;\n\t\t}\n\t\tdesc_ptr = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc_ptr\n\t\t\t\t+ desc_ptr->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 40.60602861367023}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * desc_ptr = desc;\n\n\twhile (desc_ptr->bLength) {\n\t\tif (desc_ptr->bDescriptorType == desc_id) {\n\t\t\treturn desc_ptr;\n\t\t}\n\t\tdesc_ptr = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *)\n\t\t\t\tdesc_ptr + desc_ptr->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 40.43509742170272}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (g_cur_cfg == NULL) {\n\t\treturn false;\n\t}\n\tif (iface_num >= g_cur_cfg->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tuint8_t *desc = (uint8_t *)g_cur_cfg;\n\tuint8_t *end = desc + g_cur_cfg->wTotalLength;\n\tdesc += sizeof(usb_config_desc_t);\n\twhile (desc < end) {\n\t\tif (desc[0] == USB_DESC_INTERFACE) {\n\t\t\tusb_iface_desc_t *iface_desc = (usb_iface_desc_t *)desc;\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\tg_cur_iface_desc = iface_desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc += desc[0];\n\t}\n\treturn false;\n}", "CodeBleu_score": 41.50880940314081}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tstruct usb_desc_header *hdr = (struct usb_desc_header *)udc_get_config_desc();\n\tstruct usb_desc_header *hdr_end = (struct usb_desc_header *)udc_get_config_desc_end();\n\tstruct usb_desc_header *iface_hdr = NULL;\n\n\tif (!udc_is_valid_config()) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_get_num_ifaces()) {\n\t\treturn false;\n\t}\n\n\t/* Iterate through the descriptors, starting from the beginning of the configuration descriptor */\n\twhile (hdr < hdr_end) {\n\t\t/* Check if the descriptor is an interface descriptor */\n\t\tif (hdr->bDescType == UDESC_INTERFACE) {\n\t\t\tstruct usb_iface_desc *iface = (struct usb_iface_desc *)hdr;\n\n\t\t\t/* Check if the interface number and setting number match */\n\t\t\tif (iface->bInterfaceNumber == iface_num && iface->bAlternateSetting == setting_num) {\n\t\t\t\t/* Save the interface descriptor */\n\t\t\t\tiface_hdr = hdr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Advance to the next descriptor */\n\t\thdr = (struct usb_desc_header *)((uint8_t *)hdr + hdr->bLength);\n\t}\n\n\t/* Check if a matching interface descriptor was found */\n\tif (iface_hdr) {\n\t\t/* Save the interface descriptor */\n\t\tudc_set_iface_desc(iface_hdr);\n\t\treturn true;\n\t}\n\n\t/* No matching interface descriptor was found */\n\treturn false;\n}", "CodeBleu_score": 40.86894454331657}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = UDD_EP_ID_TO_NUM(udd_g_ctrlreq.req.wIndex);\n\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tudd_set_setup_payload(0x0001);\n\t} else {\n\t\tudd_set_setup_payload(0x0000);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.558812453858543}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status_t)) {\n\t\treturn false;\n\t}\n\tudd_ep_status_t ep_status = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tep_status = UDD_EP_STATUS_HALTED;\n\t}\n\tudd_set_setup_payload(ep_status);\n\treturn true;\n}", "CodeBleu_score": 44.50762932363843}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\tuint16_t status = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tstatus = 1;\n\t}\n\tudd_set_setup_payload(status);\n\treturn true;\n}", "CodeBleu_score": 30.046194474812854}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tbool status;\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tiface_num = udi_api->req->wIndex;\n\tsetting_num = udi_api->req->wValue;\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI\n\tstatus = udi_api->setup(iface_num, setting_num);\n\n\treturn status;\n}", "CodeBleu_score": 70.35205975028786}, {"code": "static bool udc_req_iface(void){\n\t\tbool result;\n\n\t// Check if the device is in a configured state\n\tif (UDC_STATE_CONFIGURED!= udc_get_state()) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\tif (usb_setup_req->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(usb_setup_req->wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(usb_setup_req->wIndex,\n\t\t\tusb_setup_req->wValue)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tresult = udi_api->setup();\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(usb_setup_req->wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(usb_setup_req->wIndex,\n\t\t\tusb_setup_req->wValue)) {\n\t\treturn false;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 60.00101543953378}, {"code": "static bool udc_req_iface(void){\n\t\tbool b_valid_request;\n\tbool b_valid_alternate;\n\n\t// Check if the device is configured\n\tif (UDC_STATE_CONFIGURED!= udc_device_state) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tif (usb_setup_req->wIndex > udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tb_valid_request = udc_update_iface_desc(usb_setup_req->wIndex, 0);\n\n\t// Update the interface descriptor to the current alternate setting\n\tb_valid_alternate = udc_update_iface_desc(usb_setup_req->wIndex,\n\t\t\tusb_setup_req->wValue);\n\n\t// Check if the interface descriptor has been updated\n\tif (b_valid_request && b_valid_alternate) {\n\t\t// Forward the SETUP request to the UDI\n\t\treturn udi_api->setup();\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.08335800811443}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t#ifdef UDI_MSC_ENABLE_EXT\n  if (!UDI_MSC_ENABLE_EXT()) {\n    return false;\n  }\n#endif\n  // Initialize internal values\n  udi_msc_cbw_received = false;\n  udi_msc_cbw_valid = false;\n  udi_msc_cbw_length = 0;\n  udi_msc_state = UDI_MSC_STATE_IDLE;\n  udi_msc_sub_state = UDI_MSC_SUB_STATE_IDLE;\n  udi_msc_lun = 0;\n  udi_msc_nb_lun = 0;\n  // Get number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n  // Check if at least one LUN is available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n  // Unload medium on each LUN\n  mem_unload();\n  // Wait CBW\n  udi_msc_cbw_wait();\n  return true;\n}", "CodeBleu_score": 45.21143683920233}, {"code": "bool udi_msc_enable(void){\n\t#if UDI_MSC_ENABLE_EXT\n  // Call external enable function\n  if (!udi_msc_enable_ext()) {\n    return false;\n  }\n#endif\n\n  // Initialize flags\n  udi_msc_b_cbw_received = false;\n  udi_msc_b_cbw_valid = false;\n  udi_msc_b_cbw_data_received = false;\n  udi_msc_b_cbw_data_valid = false;\n  udi_msc_b_csw_valid = false;\n  udi_msc_b_csw_sent = false;\n\n  // Get the number of LUNs\n  udi_msc_nb_lun = get_nb_lun();\n\n  // Check if there are LUNs available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload medium on each LUN\n  for (uint8_t lun_index = 0; lun_index < udi_msc_nb_lun; lun_index++) {\n    mem_unload(lun_index);\n  }\n\n  // Start the MSC process by waiting for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 57.206058139884206}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_DEBUG\n  debug_putstr_p(PSTR(\"udi_msc_data_sent\\r\n\"));\n#endif\n  if (status == UDD_EP_TRANSFER_ABORT) {\n    // Transfer aborted\n    // Wait for MSC setup reset to restart CBW reception\n    return;\n  }\n  if (status!= UDD_EP_TRANSFER_OK) {\n    // Transfer error\n    // Update sense data\n    udi_msc_set_sense(SCSI_SENSE_KEY_MEDIUM_ERROR, SCSI_ASC_WRITE_ERROR, 0);\n    // Decrease CSW residue\n    udi_msc_csw.dCSWDataResidue = cpu_to_le32(\n        le32_to_cpu(udi_msc_csw.dCSWDataResidue) - nb_sent);\n    // Process CSW\n    udi_msc_csw_process();\n    return;\n  }\n  // Transfer successful\n  // Update sense data\n  udi_msc_clear_sense();\n  // Decrease CSW residue\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(\n      le32_to_cpu(udi_msc_csw.dCSWDataResidue) - nb_sent);\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 51.02646215423372}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_DEBUG_LEVEL >= 2\n  printf(\"udi_msc_data_sent\n\");\n#endif\n  if (status!= UDD_EP_TRANSFER_OK) {\n    // Transfer not OK\n    // then wait for a MSC setup reset to restart CBW reception\n    udi_msc_wait_setup();\n    return;\n  }\n  // Transfer OK\n  // Update sense data\n  udi_msc_clear_sense();\n  // Decrease data residue in CSW by the amount of data sent\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(\n      le32_to_cpu(udi_msc_csw.dCSWDataResidue) - nb_sent);\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 47.69603406487267}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t", "CodeBleu_score": 15.883820043266303}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// Check if data residue is not zero\n\tif (udi_msc_cbw.dCBWDataTransferLength!= udi_msc_cbw.dCBWDataResidue) {\n\t\t// Stall next request on the appropriate endpoint\n\t\tif (UDI_MSC_CBW_DIRECTION(udi_msc_cbw.bmCBWFlags)) {\n\t\t\t// OUT direction\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t} else {\n\t\t\t// IN direction\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t}\n\t}\n\t// Prepare CSW\n\tudi_msc_csw.dCSWSignature = cpu_to_le32(UDI_MSC_CSW_SIGNATURE);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataResidue);\n\t// Send CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 64.88458189391989}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If there is a non-zero data residue\n\tif (udi_msc_cbw.dCBWDataTransferLength!= 0) {\n\t\t// Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\t// IN\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\t// OUT\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\n\t// Prepare the CSW by setting its tag and converting the data residue to little-endian format\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw.bCBWCB[0];\n\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 70.59800373621916}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Get the CBW data residue\n\tuint32_t residue = udi_msc_cbw.dCBWDataTransferLength;\n\n\t// Check if there is a non-zero data residue\n\tif (residue!= 0) {\n\t\t// Stall the next request on the appropriate endpoint based on the direction of the CBW\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\t// The CBW is for data transfer from the device to the host\n\t\t\t// Stall the next request on the OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t} else {\n\t\t\t// The CBW is for data transfer from the host to the device\n\t\t\t// Stall the next request on the IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t}\n\t}\n\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(residue);\n\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 64.25750020419592}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\tif (b_cdc_dtr_state[port] == false) {\n\t\t\tb_cdc_dtr_state[port] = true;\n\t\t\tif (cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\t\tscheduleReset();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (b_cdc_dtr_state[port] == true) {\n\t\t\tb_cdc_dtr_state[port] = false;\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 35.31501138260942}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\tif (usb_cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\t\tusb_task_cdc_schedule_reset();\n\t\t\t}\n\t\t} else {\n\t\t\tusb_task_cdc_cancel_reset();\n\t\t}\n\t}\n}", "CodeBleu_score": 26.93038886319729}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\t/* Enable DTR */\n\t\tif (usb_cdc_line_coding.dwDTERate == 1200) {\n\t\t\t/* Schedule reset */\n\t\t\tif (b_reset_scheduled == false) {\n\t\t\t\t/* Schedule a delayed system reset */\n\t\t\t\tb_reset_scheduled = true;\n\t\t\t\treset_controller_set_delay(RESET_DELAY_1000MS);\n\t\t\t\tinitiateReset();\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Disable DTR */\n\t\tif (b_reset_scheduled == true) {\n\t\t\t/* Cancel reset */\n\t\t\tb_reset_scheduled = false;\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 30.239784351642946}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tuint8_t* payload;\n\tuint16_t payload_size;\n\tbool processed = false;\n\n\t// Get the payload pointer and size\n\tpayload = usb_get_control_request_payload_buffer();\n\tpayload_size = usb_get_control_request_payload_size();\n\n\t// Check the request type\n\tif (usb_get_control_request_type() == USB_REQUEST_TYPE_VENDOR) {\n\t\t// Check the request index\n\t\tswitch (usb_get_control_request_index()) {\n\t\t\tcase 0x04:\n\t\t\t\t// Set the payload pointer and size for the Microsoft-compatible ID descriptor\n\t\t\t\tpayload = (uint8_t*)microsoft_compatible_id_descriptor;\n\t\t\t\tpayload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\tprocessed = true;\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\t// Set the payload pointer and size for the extended properties descriptor\n\t\t\t\tpayload = (uint8_t*)extended_properties_descriptor;\n\t\t\t\tpayload_size = sizeof(extended_properties_descriptor);\n\t\t\t\tprocessed = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Request index not recognized\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Update the control request payload and size\n\tusb_set_control_request_payload_buffer(payload);\n\tusb_set_control_request_payload_size(payload_size);\n\n\treturn processed;\n}", "CodeBleu_score": 23.59666357457202}, {"code": "bool usb_task_other_requests(void){\n\t\t// 0x04: Get Microsoft-compatible ID\n\tif (Udd_setup_request_type == Usb_setup_vendor_interface_request && Udd_setup_request_index == 0x04) {\n\t\t// Set up the payload and size for the Microsoft-compatible ID descriptor\n\t\tUdd_setup_payload = (uint8_t *)microsoft_compatible_id_descriptor;\n\t\tUdd_setup_payload_size = sizeof(microsoft_compatible_id_descriptor);\n\n\t\t// Return true to indicate that the request has been processed\n\t\treturn true;\n\t}\n\n\t// 0x05: Get extended properties\n\tif (Udd_setup_request_type == Usb_setup_vendor_interface_request && Udd_setup_request_index == 0x05) {\n\t\t// Set up the payload and size for the extended properties descriptor\n\t\tUdd_setup_payload = (uint8_t *)extended_properties_descriptor;\n\t\tUdd_setup_payload_size = sizeof(extended_properties_descriptor);\n\n\t\t// Return true to indicate that the request has been processed\n\t\treturn true;\n\t}\n\n\t// Return false to indicate that the request index is not recognized\n\treturn false;\n}", "CodeBleu_score": 20.566594920922057}, {"code": "bool usb_task_other_requests(void){\n\t\tswitch (usb_setup.bRequest) {\n\t\tcase 0x04:\n\t\t\tif (usb_setup.bmRequestType == 0x81) {\n\t\t\t\tusb_control_request.payload = (uint8_t*) &usb_ms_vendor_code;\n\t\t\t\tusb_control_request.size = sizeof(usb_ms_vendor_code);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tif (usb_setup.bmRequestType == 0x81) {\n\t\t\t\tusb_control_request.payload = (uint8_t*) &usb_ms_compat_id_descriptor;\n\t\t\t\tusb_control_request.size = sizeof(usb_ms_compat_id_descriptor);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn false;\n}", "CodeBleu_score": 17.10676162491758}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\twhile (nbyte--) {\n\t\tspiRec();\n\t\t*buf++ = spiRec();\n\t}\n\tspiRec();\n}", "CodeBleu_score": 25.47591068149092}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\twhile (nbyte--) {\n\t\tspiSend(DUMMY_BYTE);\n\t\tspiRec(buf++);\n\t}\n\tspiRec(buf);\n}", "CodeBleu_score": 24.681603406918615}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\twhile (nbyte--) {\n\t\tspiSend(0xFF);\n\t\twhile (!SPI_IFG & UCRXIFG)\n\t\t\t;\n\t\t*buf++ = UCRXBUF;\n\t}\n\tspiRec();\n}", "CodeBleu_score": 23.476723694160857}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t irq_index;\n\tuint32_t *p_vector_table;\n\n\t/* Get the address of the relocated interrupt vector table */\n\tp_vector_table = get_relocated_table_addr();\n\n\t/* Disable global interrupts */\n\t__disable_irq();\n\n\t/* Get the current handler for the specified IRQ */\n\toldHandler = (pfnISR_Handler)p_vector_table[irq];\n\n\t/* Replace the handler with the new handler */\n\tirq_index = (uint32_t)irq;\n\tp_vector_table[irq_index] = (uint32_t)newHandler;\n\n\t/* Re-enable global interrupts */\n\t__enable_irq();\n\n\t/* Return the original ISR handler */\n\treturn oldHandler;\n}", "CodeBleu_score": 48.720363042583394}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *pVectorTable;\n\tpfnISR_Handler oldHandler;\n\n\tpVectorTable = get_relocated_table_addr();\n\n\t__disable_irq();\n\toldHandler = (pfnISR_Handler)pVectorTable[irq];\n\tpVectorTable[irq] = (uint32_t)newHandler;\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 50.91772172448945}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tCRITICAL_SECTION_START\n\toldHandler = (pfnISR_Handler) relocated_vector_table[irq];\n\trelocated_vector_table[irq] = (uint32_t) newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 46.32350586311117}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tint c;\n\tif (udi_cdc_is_rx_ready()) {\n\t\tc = udi_cdc_getc();\n\t\tif (c!= -1) {\n\t\t\tif (emergency_parser.enabled)\n\t\t\t\temergency_parser.process(c);\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 42.957561580444356}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (!usb_task_cdc_isenabled()) return -1;\n\tif (!usb_configured()) return -1;\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\tuint8_t c = udi_cdc_getc();\n\tif (emergency_parser.enabled()) {\n\t\temergency_parser.process(c);\n\t\tif (emergency_parser.available()) {\n\t\t\treturn emergency_parser.get();\n\t\t}\n\t}\n\treturn c;\n}", "CodeBleu_score": 48.31236887616623}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_task_cdc_isenabled() && usb_cdc_is_rx_ready()) {\n\t\tint c = usb_cdc_getc();\n\t\tif (c!= -1) {\n\t\t\tif (emergency_parser.enabled) {\n\t\t\t\temergency_parser.process(c);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 38.21117778427321}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available())\n    return emergency_parser.read();\n#endif\n  if (usb_task_cdc_isenabled() && usb_task_cdc_isconfigured()) {\n    if (udi_cdc_is_rx_ready()) {\n      uint8_t c = udi_cdc_getc();\n      update();\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 43.979537341915744}, {"code": "int MarlinSerialUSB::read(){\n\t\t// check if there is a pending character\n\tif (pending_character) {\n\t\t// if there is, return the pending character\n\t\tchar temp = pending_character;\n\t\tpending_character = 0;\n\t\treturn temp;\n\t}\n\n\t// check if the USB CDC is enabled and configured\n\tif (!usb_task_cdc_isenabled()) {\n\t\t// if not, return -1\n\t\treturn -1;\n\t}\n\n\t// check if there are any bytes available to read from the PC\n\tif (!udi_cdc_is_rx_ready()) {\n\t\t// if not, return -1\n\t\treturn -1;\n\t}\n\n\t// if a byte is available, read the byte\n\tchar temp = udi_cdc_getc();\n\n\t// update the emergency parser if enabled\n\tif (emergency_parser) {\n\t\temergency_parser->update(temp);\n\t}\n\n\t// return the read character\n\treturn temp;\n}", "CodeBleu_score": 50.672152872035966}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (serial_rx_buffer.available()) {\n\t\treturn serial_rx_buffer.read();\n\t}\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn -1;\n\t}\n\tif (udi_cdc_is_rx_ready()) {\n\t\tchar c = udi_cdc_getc();\n\t\tif (emergency_parser.enabled) {\n\t\t\temergency_parser.update(c);\n\t\t}\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 46.156354376915054}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(SERIAL_USB)\n  if (usb_task_cdc_isenabled()) {\n    uint8_t c_char;\n    return usb_cdc_is_rx_ready()? usb_cdc_getc(&c_char) : 0;\n  }\n#endif\n  return 0;\n}", "CodeBleu_score": 39.454725206226705}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_configuration && usb_cdc_enabled) {\n\t\treturn usb_cdc_rx_length();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 17.433606900195876}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_configuration && usb_cdc_is_rx_ready()) {\n\t\treturn usb_cdc_get_rx_byte_count();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 19.251823487928036}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tif DEBUG\n  Serial.print(F(\"read_data: \"));\n  Serial.print(pos);\n  Serial.print(F(\", \"));\n  Serial.print(size);\n  Serial.print(F(\", \"));\n  Serial.print(crc);\n  Serial.print(F(\", \"));\n  Serial.println(writing);\n#endif\n\n  // Read data from persistent storage\n  for (size_t i = 0; i < size; i++) {\n    value[i] = ee_Read(pos);\n    if (writing)\n      crc16(crc, &value[i], 1);\n    pos++;\n  }\n\n  return false;\n}", "CodeBleu_score": 47.69481815733284}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t *ptr = value;\n\twhile (size--) {\n\t\t*ptr = ee_Read(pos++);\n\t\tif (writing)\n\t\t\tcrc16(crc, ptr, 1);\n\t\t++ptr;\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.77672542898136}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tifdef DEBUG\n  Serial.print(F(\"read_data(\"));\n  Serial.print(pos);\n  Serial.print(F(\", \"));\n  Serial.print((void *)value);\n  Serial.print(F(\", \"));\n  Serial.print(size);\n  Serial.print(F(\", \"));\n  Serial.print((void *)crc);\n  Serial.print(F(\", \"));\n  Serial.print(writing);\n  Serial.println(F(\")\"));\n#endif\n  while (size--) {\n    if (writing)\n      *value = ee_Read(pos);\n    if (crc)\n      crc16(crc, value, 1);\n    ++value;\n    ++pos;\n  }\n  return false;\n}", "CodeBleu_score": 50.08011694764121}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif 0\n  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return; // Not a hardware PWM pin!\n  int8_t cid = channel_for_pin(pin);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n  // not attached, is an empty timer slot avail?\n  for (int i = 0; i <= CHANNEL_MAX_NUM; i++) {\n    if (chan_pin[i] == 0) {\n      if (chan_pin[i ^ 0x1]!= 0) {\n        if (pwmInfo[i / 2].freq == freq && pwmInfo[i / 2].res == res) {\n          chan_pin[i] = pin; // Allocate PWM to this channel\n          ledcAttachPin(pin, i);\n          ledcWrite(i, value);\n          return;\n        }\n      }\n      else if (cid == -1)    // Pair of empty channels?\n        cid = i & 0xFE;      // Save lower channel number\n    }\n  }\n  // not attached, is an empty timer slot avail?\n  if (cid >= 0) {\n    chan_pin[cid] = pin;\n    pwmInfo[cid / 2].freq = freq;\n    pwmInfo[cid / 2].res = res;\n    ledcSetup(cid, freq, res);\n    ledcAttachPin(pin, cid);\n    ledcWrite(cid, value);\n  }\n#else\n  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return; // Not a hardware PWM pin!\n  int8_t cid = channel_for_pin(pin);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n  cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n#endif\n}", "CodeBleu_score": 50.2692597846475}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif defined(ESP32)\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n#endif\n  // Software PWM\n  for (int i = 0; i < MAX_PWM_PINS; i++) {\n    if (pwm_pin[i] == pin) {\n      pwm_value[i] = value;\n      return;\n    }\n  }\n  for (int i = 0; i < MAX_PWM_PINS; i++) {\n    if (pwm_pin[i] == 0) {\n      pwm_pin[i] = pin;\n      pwm_value[i] = value;\n      if (pwm_count == 0) {\n        pwm_timer.begin(freq);\n        pwm_timer.attachInterrupt(pwm_interrupt);\n      }\n      pwm_count++;\n      return;\n    }\n  }\n}", "CodeBleu_score": 59.34932256680733}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif defined(ESP8266)\n  if (pin >= 0 && pin <= MAX_PWM_IOPIN) {\n    if (value == 0) {\n      // Special case for 0% duty cycle, saves power\n      ledcWrite(pin, 0);\n      return;\n    }\n    uint8_t channel = get_pwm_channel(pin, freq, res);\n    if (channel >= 0) {\n      ledcWrite(channel, value);\n      return;\n    }\n  }\n#endif\n  // Software PWM\n  for (int i = 0; i < MAX_PWM_PINS; i++) {\n    if (pwm_pin[i] == pin) {\n      pwm_set(i, value);\n      return;\n    }\n  }\n  // Allocate a new slot\n  if (pwm_pin[MAX_PWM_PINS - 1] == 0) {\n    for (int i = 0; i < MAX_PWM_PINS; i++) {\n      if (pwm_pin[i] == 0) {\n        pwm_pin[i] = pin;\n        pwm_set(i, value);\n        return;\n      }\n    }\n  }\n}", "CodeBleu_score": 55.41749502124126}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= SERVO_COUNT\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must equal SERVO_COUNT\");\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n  }\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n}", "CodeBleu_score": 50.01663701063484}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= 12\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == 12, \"SERVO_DELAY_ARRAY_LENGTH must be 12\");\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 51.48163747717851}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= SERVO_CHANNELS\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNELS, \"SERVO_DELAY_ARRAY_LENGTH must be equal to SERVO_CHANNELS\");\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n#endif\n  }\n}", "CodeBleu_score": 49.95786727378914}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tuint8_t i;\n\tuint8_t *p = (uint8_t *)i2s_dma_buffer;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (i2s_pin_state[i] & I2S_PIN_PWM_ACTIVE) {\n\t\t\tif (i2s_pin_state[i] & I2S_PIN_PWM_TICK_COUNT) {\n\t\t\t\ti2s_pin_state[i]--;\n\t\t\t} else {\n\t\t\t\ti2s_pin_state[i] ^= I2S_PIN_PWM_STATE;\n\t\t\t\ti2s_pin_state[i] |= I2S_PIN_PWM_TICK_COUNT;\n\t\t\t}\n\t\t\t*p = i2s_pin_state[i] & I2S_PIN_PWM_STATE? 0xFF : 0x00;\n\t\t} else {\n\t\t\t*p = 0x00;\n\t\t}\n\t\tp++;\n\t}\n}", "CodeBleu_score": 25.9803643418283}, {"code": "void i2s_push_sample(){\n\t\t//uint8_t i;\n\tuint8_t *p = (uint8_t*) &i2s_dma_buffer[i2s_dma_buffer_pos];\n\tuint8_t *p_end = (uint8_t*) &i2s_dma_buffer[I2S_DMA_BUFFER_SIZE];\n\n\tif (p >= p_end) {\n\t\tp = (uint8_t*) &i2s_dma_buffer[0];\n\t}\n\ti2s_dma_buffer_pos = p - (uint8_t*) &i2s_dma_buffer[0];\n\n\t//uint8_t *p = (uint8_t*) &i2s_dma_buffer[i2s_dma_buffer_pos];\n\t//uint8_t *p_end = (uint8_t*) &i2s_dma_buffer[I2S_DMA_BUFFER_SIZE];\n\n\t//if (p >= p_end) {\n\t//\tp = (uint8_t*) &i2s_dma_buffer[0];\n\t//}\n\t//i2s_dma_buffer_pos = p - (uint8_t*) &i2s_dma_buffer[0];\n\n\tuint8_t port_data = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tif (i2s_pin_duty[i] > 0) {\n\t\t\tif (i2s_pin_ticks[i] == 0) {\n\t\t\t\ti2s_pin_ticks[i] = i2s_pin_duty[i];\n\t\t\t\ti2s_pin_state[i] =!i2s_pin_state[i];\n\t\t\t} else {\n\t\t\t\ti2s_pin_ticks[i]--;\n\t\t\t}\n\t\t}\n\t\tif (i2s_pin_state[i]) {\n\t\t\tport_data |= (1 << i);\n\t\t}\n\t}\n\t*p = port_data;\n}", "CodeBleu_score": 26.321562043893888}, {"code": "void i2s_push_sample(){\n\t\tuint32_t port_data = 0;\n\tfor (uint8_t i = 0; i < 16; i++) {\n\t\tif (i2s_pwm_duty_cycle[i] > 0) {\n\t\t\tif (i2s_pwm_tick_count[i] == 0) {\n\t\t\t\ti2s_pwm_tick_count[i] = i2s_pwm_duty_cycle[i];\n\t\t\t\tif (i2s_pwm_state[i] == 1) {\n\t\t\t\t\ti2s_pwm_state[i] = 0;\n\t\t\t\t\tport_data &= ~(1 << i);\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pwm_state[i] = 1;\n\t\t\t\t\tport_data |= (1 << i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti2s_pwm_tick_count[i]--;\n\t\t\t}\n\t\t}\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_pos++] = port_data;\n\tif (i2s_dma_buffer_pos == I2S_DMA_BUFFER_SIZE) {\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 30.143929810953544}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\t// Check if the timer is valid\n\tif (timer_num >= HAL_TIMER_MAX) {\n\t\treturn 0;\n\t}\n\n\t// Check if the timer is enabled\n\tif (!timer_config[timer_num].enabled) {\n\t\treturn 0;\n\t}\n\n\t// Check if the timer is counting\n\tif (!timer_config[timer_num].counting) {\n\t\treturn 0;\n\t}\n\n\t// Return the current counter value\n\treturn timer_config[timer_num].counter;\n}", "CodeBleu_score": 33.97831397825391}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer = hal_timer_get_config(timer_num);\n\treturn timer.count;\n}", "CodeBleu_score": 27.466517795413615}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_config;\n\ttimer_config.timer_num = timer_num;\n\ttimer_config.timer_value = HAL_timer_get_counter_value(timer_config);\n\treturn timer_config;\n}", "CodeBleu_score": 38.997055878627926}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (uint16_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos++);\n\t\tcrc16(crc, &value[i], 1);\n\t\tif (writing)\n\t\t\tEEPROM.write(pos, value[i]);\n\t}\n\treturn false;\n}", "CodeBleu_score": 56.82661783994229}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tifdef DEBUG\n  Serial.print(F(\"PersistentStore::read_data: pos=\"));\n  Serial.print(pos);\n  Serial.print(F(\", value=\"));\n  Serial.print((int)value);\n  Serial.print(F(\", size=\"));\n  Serial.print(size);\n  Serial.print(F(\", crc=\"));\n  Serial.print((int)crc);\n  Serial.print(F(\", writing=\"));\n  Serial.println(writing);\n#endif\n  for (int i = 0; i < size; i++) {\n    value[i] = EEPROM.read(pos);\n    if (writing) {\n#ifdef DEBUG\n      Serial.print(F(\"PersistentStore::read_data: value[\"));\n      Serial.print(i);\n      Serial.print(F(\"]=\"));\n      Serial.println(value[i]);\n#endif\n    }\n    crc16(crc, &value[i], 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 47.94146501934867}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (pos >= EEPROM_SIZE) return false;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos++);\n\t\tif (writing) crc16(crc, &value[i], 1);\n\t}\n\treturn true;\n}", "CodeBleu_score": 56.67907432901123}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(sdcard.handle);\n\tCORE_ASSERT(src);\n\tfor (int i = 0; i < SDCARD_MAX_WRITE_RETRIES; i++) {\n\t\tif (HAL_SD_WriteBlocks(&sdcard.handle, (uint8_t *) src, block, 1, 1000) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tSDCARD_ERROR(\"SDIO_WriteBlock failed\");\n\treturn false;\n}", "CodeBleu_score": 34.244482901580994}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(src!= NULL);\n\tCORE_ASSERT(SDIO_Handle!= NULL);\n\tCORE_ASSERT(SDIO_Handle->State == HAL_SDIO_STATE_READY);\n\tCORE_ASSERT(SDIO_Handle->ErrorCode == HAL_SDIO_ERROR_NONE);\n\n\tfor (int i = 0; i < WITH_RETRY; i++) {\n\t\tif (HAL_SD_WriteBlocks(SDIO_Handle, (uint8_t*) src, block, 1, 1000)\n\t\t\t\t== HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tSDCARD_Error(\"SDIO_WriteBlock\");\n\treturn false;\n}", "CodeBleu_score": 42.0079278505898}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(src);\n\tCORE_ASSERT(sdcard_handle);\n\n\tif (HAL_SD_WriteBlocks(sdcard_handle, (uint8_t*) src, block, 1, SDCARD_TIMEOUT) == HAL_OK) {\n\t\treturn true;\n\t}\n\n\t// If the write operation failed, retry up to a defined number of times\n\tfor (int i = 0; i < SDCARD_WRITE_RETRY; i++) {\n\t\tif (HAL_SD_WriteBlocks(sdcard_handle, (uint8_t*) src, block, 1, SDCARD_TIMEOUT) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// If all retries fail, print an error message and return false\n\tprintf(\"Error writing block %d to SD card\n\", block);\n\treturn false;\n}", "CodeBleu_score": 44.10857694562558}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\t// Check if the timer channel is valid\n\tCORE_ASSERT(timer_num < NUM_TIMERS);\n\n\t// Check if the timer channel is not already running\n\tCORE_ASSERT(!timers[timer_num].running);\n\n\t// Check if the frequency is valid\n\tCORE_ASSERT(frequency > 0);\n\n\t// Check if the timer channel is the temperature timer\n\tif (timer_num == TEMP_TIMER_NUM) {\n\t\t// Start the temperature timer with the given frequency and temperature timer prescale\n\t\ttimers[timer_num].running = true;\n\t\ttimers[timer_num].frequency = frequency;\n\t\ttimers[timer_num].prescale = TEMP_TIMER_PRESCALE;\n\t\ttimers[timer_num].timer = timerBegin(TEMP_TIMER_NUM, TEMP_TIMER_PRESCALE, true);\n\t\ttimerAlarmWrite(TEMP_TIMER_NUM, TEMP_TIMER_PRESCALE / frequency, true);\n\t\ttimerAlarmEnable(TEMP_TIMER_NUM);\n\t\t// Set the callback priority for temperature\n\t\ttimer_num->setCallbackPriority(TEMP_TIMER_PRIORITY);\n\t}\n\t// Check if the timer channel is the step timer\n\telse if (timer_num == STEP_TIMER_NUM) {\n\t\t// Start the step timer with the given frequency and stepper timer prescale\n\t\ttimers[timer_num].running = true;\n\t\ttimers[timer_num].frequency = frequency;\n\t\ttimers[timer_num].prescale = STEP_TIMER_PRESCALE;\n\t\ttimers[timer_num].timer = timerBegin(STEP_TIMER_NUM, STEP_TIMER_PRESCALE, true);\n\t\ttimerAlarmWrite(STEP_TIMER_NUM, STEP_TIMER_PRESCALE / frequency, true);\n\t\ttimerAlarmEnable(STEP_TIMER_NUM);\n\t\t// Set the callback priority for stepper\n\t\ttimer_num->setCallbackPriority(STEP_TIMER_PRIORITY);\n\t}\n\t// If the timer channel is invalid, trigger an assertion failure\n\telse {\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 55.19200159608506}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t", "CodeBleu_score": 2.9267475901190156}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMPERATURE_TIMER) {\n\t\t// Start the temperature timer with the given frequency and temperature timer prescale\n\t\tHAL_timer_start(TEMPERATURE_TIMER, TEMPERATURE_TIMER_FREQUENCY, TEMPERATURE_TIMER_PRESCALE);\n\t\t// Set the callback priority for temperature\n\t\tHAL_timer_setCallbackPriority(TEMPERATURE_TIMER, TEMPERATURE_TIMER_PRIORITY);\n\t} else if (timer_num == STEPPER_TIMER) {\n\t\t// Start the stepper timer with the given frequency and stepper timer prescale\n\t\tHAL_timer_start(STEPPER_TIMER, STEPPER_TIMER_FREQUENCY, STEPPER_TIMER_PRESCALE);\n\t\t// Set the callback priority for stepper\n\t\tHAL_timer_setCallbackPriority(STEPPER_TIMER, STEPPER_TIMER_PRIORITY);\n\t} else {\n\t\t// Invalid timer channel, trigger an assertion failure\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 38.90096039524813}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (file_opened) {\n\t\treturn true;\n\t}\n\tif (file_name == NULL) {\n\t\treturn false;\n\t}\n\tfile = fopen(file_name, \"r+b\");\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\tfile_opened = true;\n\tint file_size = fread(buffer, 1, buffer_size, file);\n\tif (file_size < buffer_size) {\n\t\tmemset(&buffer[file_size], default_erase_value, buffer_size - file_size);\n\t}\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 38.42526297638033}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open EEPROM file\n\tFILE *fp = fopen(EEPROM_FILE, \"r+\");\n\tif (fp == NULL) {\n\t\t// File does not exist or cannot be opened\n\t\treturn false;\n\t}\n\t// Check file size\n\tfseek(fp, 0, SEEK_END);\n\tint file_size = ftell(fp);\n\tif (file_size < EEPROM_SIZE) {\n\t\t// File is smaller than expected EEPROM size\n\t\t// Fill remainder of buffer with default erase value\n\t\tmemset(buffer + file_size, EEPROM_ERASE_VALUE, EEPROM_SIZE - file_size);\n\t}\n\t// Read file contents into buffer\n\tfseek(fp, 0, SEEK_SET);\n\tfread(buffer, 1, EEPROM_SIZE, fp);\n\t// Close file and return true\n\tfclose(fp);\n\treturn true;\n}", "CodeBleu_score": 41.80743160648758}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open EEPROM file\n\tfile = fopen(file_name, \"r+b\");\n\tif (file == NULL) {\n\t\t// If the file does not exist, create it\n\t\tfile = fopen(file_name, \"w+b\");\n\t\tif (file == NULL) {\n\t\t\t// If the file cannot be created, return false\n\t\t\treturn false;\n\t\t}\n\t\t// Fill the buffer with default erase value\n\t\tmemset(buffer, 0xFF, buffer_size);\n\t\t// Write the buffer to the file\n\t\tfwrite(buffer, 1, buffer_size, file);\n\t\t// Close the file\n\t\tfclose(file);\n\t\t// Re-open the file\n\t\tfile = fopen(file_name, \"r+b\");\n\t\tif (file == NULL) {\n\t\t\t// If the file cannot be opened, return false\n\t\t\treturn false;\n\t\t}\n\t}\n\t// Get the file size\n\tfseek(file, 0, SEEK_END);\n\tlong file_size = ftell(file);\n\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with default erase value\n\tif (file_size < buffer_size) {\n\t\tmemset(buffer + file_size, 0xFF, buffer_size - file_size);\n\t}\n\t// Read the file's contents into the buffer\n\tfseek(file, 0, SEEK_SET);\n\tfread(buffer, 1, buffer_size, file);\n\t// Close the file\n\tfclose(file);\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 43.81495935470445}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t ret = 0;\n\tuint8_t bit;\n\tfor (i = 0; i < 8; i++) {\n\t\tbit = (b & 0x80)? 1 : 0;\n\t\tb <<= 1;\n\t\tHAL_SPI_STM32_Set_Clock_Pin(0);\n\t\tHAL_SPI_STM32_Set_MOSI_Pin(bit);\n\t\tHAL_SPI_STM32_Set_Clock_Pin(1);\n\t\tret = (ret << 1) | HAL_SPI_STM32_Get_MISO_Pin();\n\t}\n\tdelaySPIFunc(SPI_DELAY_NS);\n\treturn ret;\n}", "CodeBleu_score": 42.41341033935826}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t received = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\t// Set clock pin low\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\t// Write the most significant bit of the byte to the MOSI pin\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\t// Toggle the clock pin high\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\t// Read the bit from the MISO pin\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n\t\t\treceived |= 1 << (7 - i);\n\t\t}\n\t\t// Shift the byte left and incorporate the read bit\n\t\tb <<= 1;\n\t}\n\t// Introduce a small delay before returning the received byte\n\tdelaySPIFunc(SPI_DELAY_NS);\n\treturn received;\n}", "CodeBleu_score": 38.24277673616344}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t received = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n\t\t\treceived |= 0x01;\n\t\t}\n\t\treceived <<= 1;\n\t}\n\treceived >>= 1;\n\tdelaySPIFunc(SPI_DELAY_NS);\n\treturn received;\n}", "CodeBleu_score": 37.94554652626444}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73126554935065}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->serial.rx_pin!= NC) {\n\t\tuint8_t c = obj->serial.rxd;\n\t\tif (obj->serial.format & SERIAL_CONFIG_PARITY) {\n\t\t\tif (obj->serial.format & SERIAL_CONFIG_PARITY_ODD) {\n\t\t\t\tif (c & 0x01)\n\t\t\t\t\tc = 0xff;\n\t\t\t} else {\n\t\t\t\tif (!(c & 0x01))\n\t\t\t\t\tc = 0xff;\n\t\t\t}\n\t\t\tc >>= 1;\n\t\t}\n\t\tif (obj->rx_buffer.head!= ((obj->rx_buffer.tail + 1) & (RX_BUFFER_SIZE - 1))) {\n\t\t\tobj->rx_buffer.buffer[obj->rx_buffer.head] = c;\n\t\t\tobj->rx_buffer.head = (obj->rx_buffer.head + 1) & (RX_BUFFER_SIZE - 1);\n\t\t}\n\t\tif (obj->rx_buffer.head == obj->rx_buffer.tail) {\n\t\t\tobj->rx_buffer.overflow = true;\n\t\t}\n\t\tif (obj->rx_buffer.head!= obj->rx_buffer.tail) {\n\t\t\tif (obj->parser_callback) {\n\t\t\t\tobj->parser_callback(c);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.162492790730404}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Get the byte from the UART peripheral\n\tuint8_t rx_byte = UART_RX_REG(obj);\n\t// Check for parity errors\n\tif (UART_STATUS_REG(obj) & UART_STATUS_PE) {\n\t\t// If a parity error occurs, discard the received byte and set the parity error flag\n\t\t_parity_error = true;\n\t\treturn;\n\t}\n\t// Store the received byte in the receive buffer if there is space available\n\tif (rx_buffer_tail!= (rx_buffer_head + 1) % RX_BUFFER_SIZE) {\n\t\trx_buffer[rx_buffer_head] = rx_byte;\n\t\trx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\t}\n\t// If enabled, update the emergency parser with the received byte\n\tif (emergency_parser.enabled) {\n\t\temergency_parser.update(rx_byte);\n\t}\n}", "CodeBleu_score": 32.58027679871554}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Read the byte and store it in the buffer if there is space available\n\tuint8_t c = obj->regs->RXDATA;\n\tuint8_t i = rx_buffer_head;\n\tif (i < RX_BUFFER_SIZE) {\n\t\trx_buffer[i] = c;\n\t\ti++;\n\t\trx_buffer_head = i;\n\t}\n\t// Update the emergency parser with the received byte\n\tif (emergency_parser_enabled)\n\t\temergency_parser.update(c);\n}", "CodeBleu_score": 27.406757418358158}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\tif (timer_instance[timer_num]->initialized) {\n\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 73.64701211591024}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\ttimer_instance[timer_num]->attachInterrupt(timer_interrupt[timer_num]);\n\ttimer_instance[timer_num]->hasInterrupt = true;\n}", "CodeBleu_score": 39.86614622861271}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (!HAL_timer_initialized[timer_num]) {\n\t\treturn;\n\t}\n\n\tif (!timer_instance[timer_num]->hasInterrupt()) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 59.077668125051886}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\tsepHash, pow := HashStrRev(sep)\n\thash := uint32(0)\n\tfor i := 0; i < m; i++ {\n\t\thash = hash*PrimeRK + uint32(s[n-m+i])\n\t}\n\tif hash == sepHash && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash *= PrimeRK\n\t\thash += uint32(s[i])\n\t\thash -= pow * uint32(s[i+m])\n\t\tif hash == sepHash && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 49.3909953660846}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thashsep, pow := HashStrRev(sep)\n\tvar h uint32 = 0\n\tfor i := m - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && s[:m] == sep {\n\t\treturn 0\n\t}\n\tfor i := m; i < n; i++ {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-m])\n\t\tif h == hashsep && s[i-m+1:i+1] == sep {\n\t\t\treturn i - m + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 57.93620702654563}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn, m := len(s), len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif n < m {\n\t\treturn -1\n\t}\n\thsep, pow := HashStrRev(sep)\n\thash := uint32(0)\n\tfor i := n - m; i >= 0; i-- {\n\t\tif i < n-m {\n\t\t\thash -= pow * uint32(s[i])\n\t\t}\n\t\thash = hash*PrimeRK + uint32(s[i+m-1])\n\t\tif hash == hsep && Equal(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 43.656216747848745}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data available, so set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tinterrupt.Restore()\n}", "CodeBleu_score": 47.722446509407945}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Available() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 47.965041579977516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.04282649496233}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag\n\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.Bits(i2c.crReg.Bits() & ^i2c.crReg.Bits(i2c.crReg.I2C_CR_STO | i2c.crReg.I2C_CR_SI))))\n\t// Send start condition\n\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.Bits(i2c.crReg.Bits() | i2c.crReg.I2C_CR_STA)))\n\t// Wait for start condition to be transmitted\n\tfor!i2c.crReg.HasBits(i2c.crReg.I2C_CR_SI) {\n\t}\n\t// Write 7-bit shifted peripheral address to bus\n\ti2c.writeByte(address<<1 | uint8(i2c.crReg.I2C_CR_RD))\n\t// Wait for address to be transmitted\n\tfor!i2c.crReg.HasBits(i2c.crReg.I2C_CR_SI) {\n\t}\n\t// Clear interrupt flag\n\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.Bits(i2c.crReg.Bits() & ^i2c.crReg.Bits(i2c.crReg.I2C_CR_SI))))\n\t// Set read flag if needed\n\tif!write {\n\t\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.I2C_CR_RD))\n\t}\n}", "CodeBleu_score": 32.94292115276928}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(i2c.crReg.ClearBits | i2c.crReg.HasBits)\n\ti2c.crReg.Set(i2c.crReg.HasBits | i2c.crReg.Start)\n\ti2c.crReg.Set(i2c.crReg.HasBits)\n\tfor!i2c.isrReg.HasBits(i2c.isrReg.StartF) {\n\t}\n\ti2c.writeByte(address<<1 | (uint8(write)<<0))\n}", "CodeBleu_score": 35.599846614444694}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.Bits.ClearIrq, i2c.crReg.Bits.Start, i2c.crReg.Bits.Enable))\n\tfor!i2c.irqReg.HasBits(i2c.irqReg.Bits.Start) {\n\t}\n\ti2c.writeByte((uint16(address) << 1) | (uint16(!write) << 0))\n}", "CodeBleu_score": 39.044208099217975}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len <= 0 {\n\t\treturn errors.New(\"invalid arguments\")\n\t}\n\tif start+len > f.NumBlocks {\n\t\treturn errors.New(\"out of range\")\n\t}\n\taddr := uintptr(f.EraseBlockSize * start)\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.SetCONFIG_WEN\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set\n\t\taddr += uintptr(f.EraseBlockSize)\n\t\twaitWhileFlashBusy()\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy()\n\tnrf.NVMC.ERASEPAGE.Clear\n\twaitWhileFlashBusy()\n\treturn nil\n}", "CodeBleu_score": 48.4428387848631}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len <= 0 {\n\t\treturn errors.New(\"invalid arguments\")\n\t}\n\tstartAddr := uintptr(start) * uintptr(f.EraseBlockSize)\n\tendAddr := startAddr + uintptr(len)*uintptr(f.EraseBlockSize)\n\tif endAddr > uintptr(f.Size) {\n\t\treturn errors.New(\"invalid arguments\")\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tfor addr := startAddr; addr < endAddr; addr += uintptr(f.EraseBlockSize) {\n\t\tnrf.NVMC.ERASEPAGE.Set\n\t\tuint32\n\t\tuintptr\n\t\taddr\n\t\twaitWhileFlashBusy\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\treturn nil\n}", "CodeBleu_score": 43.41168884108707}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"invalid argument\")\n\t}\n\tif start+len > f.NumBlocks {\n\t\treturn errors.New(\"out of range\")\n\t}\n\taddr := f.StartAddress + uintptr(start*f.EraseBlockSize)\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set\n\t\tuint32\n\t\tuintptr\n\t\twaitWhileFlashBusy\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\treturn nil\n}", "CodeBleu_score": 38.05258237141924}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"nrf: negative offset\")\n\t}\n\tif off > FlashDataEnd {\n\t\treturn 0, errors.New(\"nrf: offset exceeds flash memory bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tstartAddr := uintptr(FlashDataStart + off)\n\tp = f.pad(p)\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor len(p) > 0 {\n\t\tnrf.NVMC.SetERASEPAGE(startAddr)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetERASEICR0\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetERASEALL\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetERASEUICR\n\t\twaitWhileFlashBusy()\n\t\tfor i := 0; i < len(p)/f.WriteBlockSize; i++ {\n\t\t\tnrf.NVMC.SetWRITEU32(startAddr, binary.LittleEndian.Uint32(p))\n\t\t\tp = p[f.WriteBlockSize:]\n\t\t\tstartAddr += f.WriteBlockSize\n\t\t\twaitWhileFlashBusy()\n\t\t}\n\t}\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn len(p), nil\n}", "CodeBleu_score": 34.927068554610855}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"out of bounds\")\n\t}\n\tstart := uintptr(unsafe.Pointer(f.start)) + uintptr(off)\n\tp = f.pad(p)\n\tf.nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor len(p) > 0 {\n\t\tf.nrf.NVMC.SetERASEPAGE(false)\n\t\tf.nrf.NVMC.SetERASEPCR0(false)\n\t\tf.nrf.NVMC.SetERASEALL(false)\n\t\tf.nrf.NVMC.SetERASEPCR1(false)\n\t\t*(*uint32)(unsafe.Pointer(start)) = binary.LittleEndian.Uint32(p)\n\t\twaitWhileFlashBusy()\n\t\tstart += f.WriteBlockSize\n\t\tp = p[f.WriteBlockSize:]\n\t}\n\tf.nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn len(p), nil\n}", "CodeBleu_score": 40.77430472182922}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off > FlashDataEnd {\n\t\treturn 0, ErrFlashWriteOutOfBounds\n\t}\n\tstart := uintptr(FlashDataStart) + uintptr(off)\n\tdata := make([]byte, f.WriteBlockSize)\n\tcopy(data, p)\n\tf.pad(data)\n\tf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor len(data) > 0 {\n\t\t(*uint32)(unsafe.Pointer(start)).Write(binary.LittleEndian.Uint32(data))\n\t\twaitWhileFlashBusy()\n\t\tstart += f.WriteBlockSize\n\t\tdata = data[f.WriteBlockSize:]\n\t}\n\treturn len(p), nil\n}", "CodeBleu_score": 35.97469729658974}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Attempt to open the directory.\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn dir, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 56.74583922016488}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory.\n\tvar dir uintptr\n\tvar errStr string\n\tfor {\n\t\tdir, errStr, err = syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Clean up.\n\tsyscall.Close(dupFd)\n\n\t// Return the result.\n\tif err!= nil {\n\t\treturn 0, errStr, err\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 66.23808699229502}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdir, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdirp, err := syscall.Fdopendir(dir)\n\t\tif err == nil {\n\t\t\treturn dirp, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(dir)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 54.06495495465353}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_image_metadata_t metadata;\n\tesp_partition_t *running_partition = esp_ota_get_running_partition();\n\tesp_image_verify(running_partition, ESP_IMAGE_VERIFY, &metadata);\n\tesp_image_get(running_partition, &app_desc);\n\tif (response == true) {\n\t\treturn running_partition->size - app_desc.image_len;\n\t} else {\n\t\treturn app_desc.image_len;\n\t}\n}", "CodeBleu_score": 47.53136598632956}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tesp_ota_img_states_t ota_state;\n\tesp_err_t err = esp_ota_get_state_partition(running, &ota_state);\n\tif (err!= ESP_OK) {\n\t\tif (response) {\n\t\t\tESP_LOGE(TAG, \"esp_ota_get_state_partition failed (%s)\", esp_err_to_name(err));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ota_state == ESP_OTA_IMG_PENDING_VERIFY) {\n\t\t// run verification\n\t\tesp_err_t err = esp_ota_verify_image_partition(running);\n\t\tif (err!= ESP_OK) {\n\t\t\tif (response) {\n\t\t\t\tESP_LOGE(TAG, \"esp_ota_verify_image_partition failed (%s)\", esp_err_to_name(err));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (response) {\n\t\treturn running->size - running->data_start_offset;\n\t} else {\n\t\treturn running->data_end_offset - running->data_start_offset;\n\t}\n}", "CodeBleu_score": 49.6697783703844}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_image_verify(ESP_IMAGE_VERIFY, &app_desc);\n\tif (response == true) {\n\t\treturn app_desc.image_len - app_desc.image_spi_size;\n\t} else {\n\t\treturn app_desc.image_spi_size;\n\t}\n}", "CodeBleu_score": 28.089552538567187}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t#if CONFIG_MSC_UPDATE_MAX_SECTORS == 0\n  size_t required_sectors = msc_update_get_required_disk_sectors();\n  if (required_sectors > 0xFF4) {\n    log_e(\"Too many sectors for FAT12\");\n    return false;\n  }\n#else\n  size_t required_sectors = CONFIG_MSC_UPDATE_MAX_SECTORS;\n#endif\n  log_d(\"MSC update setup disk\");\n  msc_disk = calloc(required_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk) {\n    log_e(\"Failed to allocate %uKB for disk\", (required_sectors * DISK_SECTOR_SIZE) / 1024);\n    return false;\n  }\n  msc_disk_sectors = required_sectors;\n  fat_add_boot_sector(msc_disk, volume_label, serial_number);\n  fat_add_table(msc_disk, msc_table_sectors);\n  if (msc_run_partition) {\n    fat_add_root_file(msc_disk, fw_size, \"firmware.bin\");\n  }\n  return true;\n}", "CodeBleu_score": 44.83444098616419}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tsize_t disk_sectors = msc_update_get_required_disk_sectors();\n\tif (disk_sectors == 0) {\n\t\treturn false;\n\t}\n\tmsc_disk_sectors = disk_sectors;\n\tmsc_disk_size = msc_disk_sectors * DISK_SECTOR_SIZE;\n\tmsc_disk = calloc(msc_disk_size, 1);\n\tif (!msc_disk) {\n\t\tlog_e(\"Failed to allocate %u bytes for disk\", msc_disk_size);\n\t\treturn false;\n\t}\n\tlog_d(\"Disk allocated at %p\", msc_disk);\n\tif (!fat_add_boot_sector(msc_disk, volume_label, serial_number, msc_disk_sectors)) {\n\t\tlog_e(\"Failed to add boot sector\");\n\t\treturn false;\n\t}\n\tif (!fat_add_table(msc_disk, msc_disk_sectors, msc_table_sectors)) {\n\t\tlog_e(\"Failed to add FAT table\");\n\t\treturn false;\n\t}\n\tif (msc_run_partition) {\n\t\tif (!fat_add_root_file(msc_disk, msc_disk_sectors, \"firmware.bin\", fw_size)) {\n\t\t\tlog_e(\"Failed to add root file\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.24819497725325}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % SPI_FLASH_SEC_SIZE!= 0) {\n\t\tESP_LOGE(TAG, \"Update write offset is not aligned to sector size!\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, offset, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%x!\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 48.21629962258613}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGV(TAG, \"msc_update_write: partition: %s, offset: %d, size: %d\", partition->label, offset, size);\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"Update write offset is not aligned with the sector size!\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size > partition->size - offset) {\n\t\tESP_LOGE(TAG, \"Update write size is too large!\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size == 0) {\n\t\treturn ESP_OK;\n\t}\n\n\tif (esp_partition_erase_range(partition, offset, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase the partition!\");\n\t\treturn ESP_FAIL;\n\t}\n\n\tif (esp_partition_write(partition, offset, data, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to the partition!\");\n\t\treturn ESP_FAIL;\n\t}\n\n\treturn ESP_OK;\n}", "CodeBleu_score": 44.57180070677232}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"%s\", __FUNCTION__);\n\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector\");\n\t\treturn err;\n\t}\n\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 52.59386151874027}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i, j;\n\tuint8_t c;\n\n\tfor (i = 0, j = 0; in[i]!= '\\0' && j < maxlen; i++) {\n\t\tc = hex_char_to_byte(in[i]);\n\t\tif (c == 0x10) continue;\n\t\tif (i % 2 == 0) {\n\t\t\tout[j] = c << 4;\n\t\t} else {\n\t\t\tout[j] |= c;\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn j;\n}", "CodeBleu_score": 41.2888193031139}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = 0;\n\tunsigned char c;\n\tunsigned char c1;\n\twhile (*in && len < maxlen) {\n\t\tc = (unsigned char)*in++;\n\t\tif (c == '\n')\n\t\t\tcontinue;\n\t\tif (c =='' || c == '\\t')\n\t\t\tcontinue;\n\t\tif (c == '\\r')\n\t\t\tcontinue;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tc1 = c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tc1 = c - 'a' + 10;\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tc1 = c - 'A' + 10;\n\t\telse\n\t\t\tcontinue;\n\t\tc1 <<= 4;\n\t\tc = (unsigned char)*in++;\n\t\tif (c == '\n')\n\t\t\tcontinue;\n\t\tif (c =='' || c == '\\t')\n\t\t\tcontinue;\n\t\tif (c == '\\r')\n\t\t\tcontinue;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tc1 |= c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tc1 |= c - 'a' + 10;\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tc1 |= c - 'A' + 10;\n\t\telse\n\t\t\tcontinue;\n\t\t*out++ = c1;\n\t\t++len;\n\t}\n\treturn len;\n}", "CodeBleu_score": 30.133121966556153}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t out_len = 0;\n\tuint8_t c;\n\tuint8_t c_hi;\n\tuint8_t c_lo;\n\n\twhile (*in && out_len < maxlen) {\n\t\tc_hi = hex_char_to_byte(*in++);\n\t\tc_lo = hex_char_to_byte(*in++);\n\t\tif (c_hi == 0x10 || c_lo == 0x10) {\n\t\t\tbreak;\n\t\t}\n\t\tc = (c_hi << 4) | c_lo;\n\t\tout[out_len++] = c;\n\t}\n\treturn out_len;\n}", "CodeBleu_score": 35.379337807666076}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (txRingBuffer == NULL || txLock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(txLock, 1000) == pdTRUE) {\n\t\tint freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n\t\txSemaphoreGive(txLock);\n\t\treturn freeSize;\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 65.40280042248759}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_tx_buffer == NULL || m_tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(m_tx_lock, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\n\t\tsize_t free_size = xRingbufferGetCurFreeSize(m_tx_buffer);\n\t\txSemaphoreGive(m_tx_lock);\n\t\treturn free_size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 67.4316182836957}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (txRingbuffer == NULL || txLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(txLock, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\n\t\tint size = xRingbufferGetCurFreeSize(txRingbuffer);\n\t\txSemaphoreGive(txLock);\n\t\treturn size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 66.94581449499368}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (_onReceiveCB) {\n\t\tuartSetRxFIFOFull(uart_num, 1);\n\t\tif (!_eventTask) {\n\t\t\t_createEventTask(NULL);\n\t\t}\n\t}\n\t_rxTimeout = onlyOnTimeout;\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 30.71735534529993}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (_onReceiveCB!= NULL) {\n\t\tif (onlyOnTimeout) {\n\t\t\tuartSetRxFIFOFull(UART_NUM_0, 1);\n\t\t\t_rxTimeout = 0;\n\t\t} else {\n\t\t\tuartSetRxFIFOFull(UART_NUM_0, 1);\n\t\t\t_rxTimeout = 100;\n\t\t}\n\t\tif (_eventTask == NULL) {\n\t\t\t_createEventTask(NULL);\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 46.98213155192184}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (_onReceiveCB!= NULL) {\n\t\t// Set the FIFO full threshold to 1 byte\n\t\tuartSetRxFIFOFull(_uart_nr, 1);\n\t\t// Create event task if it does not already exist\n\t\tif (_eventTask == NULL) {\n\t\t\t_createEventTask(this);\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 30.080736843637524}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\t*buffer = 0;\n\treturn index;\n}", "CodeBleu_score": 79.80678988405427}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) return index;\n\t\tchar c_char = (char)c;\n\t\tif (c_char == terminator) break;\n\t\t*buffer++ = c_char;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 68.83884936739122}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) break;\n\t\tchar c_char = (char)c;\n\t\tbuffer[index] = c_char;\n\t\tindex++;\n\t\tif (c_char == terminator) break;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 66.7017099378248}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"Tone: %d, %d, %d\", pin, frequency, duration);\n\tif (pin == 255) {\n\t\ttone_stop(0);\n\t\treturn;\n\t}\n\tif (tone_get_pin_state(pin) == TONE_STATE_IN_USE) {\n\t\tlog_e(\"Tone: Pin %d is in use\", pin);\n\t\treturn;\n\t}\n\ttone_init();\n\ttone_set_pin_state(pin, TONE_STATE_IN_USE);\n\ttone_msg_t msg;\n\tmsg.pin = pin;\n\tmsg.frequency = frequency;\n\tmsg.duration = duration;\n\tmsg.command = TONE_CMD_START;\n\txQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 45.84563941524309}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"Tone %d %d %d\", pin, frequency, duration);\n\tif (!tone_init()) {\n\t\treturn;\n\t}\n\tif (pin >= NUM_PINS) {\n\t\tlog_e(\"Pin %d is not a valid pin\", pin);\n\t\treturn;\n\t}\n\tif (_pin_state[pin]!= PIN_STATE_FREE) {\n\t\tlog_e(\"Pin %d is already in use\", pin);\n\t\treturn;\n\t}\n\t_pin_state[pin] = PIN_STATE_TONE;\n\ttone_msg_t msg;\n\tmsg.cmd = TONE_CMD_START;\n\tmsg.pin = pin;\n\tmsg.frequency = frequency;\n\tmsg.duration = duration;\n\tif (xQueueSend(_tone_queue, &msg, portMAX_DELAY)!= pdPASS) {\n\t\tlog_e(\"Could not send tone start message\");\n\t\t_pin_state[pin] = PIN_STATE_FREE;\n\t\treturn;\n\t}\n}", "CodeBleu_score": 47.29816834277148}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone(%d, %d, %d)\", pin, frequency, duration);\n\n\tif (pin >= 16) {\n\t\tlog_e(\"Pin %d is not a PWM pin\", pin);\n\t\treturn;\n\t}\n\n\tif (_tone_pins[pin]!= 0) {\n\t\tlog_e(\"Pin %d is already in use\", pin);\n\t\treturn;\n\t}\n\n\t_tone_pins[pin] = 1;\n\ttone_msg_t msg;\n\tmsg.pin = pin;\n\tmsg.frequency = frequency;\n\tmsg.duration = duration;\n\tmsg.command = TONE_START;\n\txQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 43.78118805836462}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usb_started) {\n\t\twebusb_enabled = enabled;\n\t\tif (enabled && usb_version < 0x0210) usb_version = 0x0210;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 64.69819003851211}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_started) {\n\t\treturn false;\n\t}\n\twebusb_enabled = enabled;\n\tif (enabled) {\n\t\tusb_version = 0x0210;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.791446230392864}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_started) {\n\t\treturn false;\n\t}\n\tusb_web_usb = enabled;\n\tif (enabled) {\n\t\tusb_version = 0x0210;\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.635320947656005}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[64];\n\tuint32_t read_len;\n\tuint32_t i;\n\tuint32_t num_dropped = 0;\n\tbool overflow = false;\n\n\t// read data from the USB CDC interface\n\tread_len = tud_cdc_n_read(0, buf, sizeof(buf));\n\n\t// attempt to send each byte to the receive queue\n\tfor (i = 0; i < read_len; i++) {\n\t\tif (xQueueSend(rx_queue, &buf[i], 0)!= pdTRUE) {\n\t\t\tnum_dropped++;\n\t\t\toverflow = true;\n\t\t}\n\t}\n\n\t// post overflow event if necessary\n\tif (overflow) {\n\t\t_usb_cdc_event_post(USB_CDC_EVENT_RX_OVERFLOW, num_dropped);\n\t\tlog_e(\"USB CDC RX queue overflow: %d bytes dropped\n\", num_dropped);\n\t}\n\n\t// post receive event\n\tif (read_len > 0) {\n\t\t_usb_cdc_event_post(USB_CDC_EVENT_RX_COMPLETE, read_len);\n\t}\n}", "CodeBleu_score": 31.795795648755398}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[64];\n\tuint32_t cnt = tud_cdc_n_read(0, buf, sizeof(buf));\n\tif (cnt == 0) return;\n\n\tuint32_t len = 0;\n\tfor (uint32_t i = 0; i < cnt; i++) {\n\t\tif (xQueueSend(rxQueue, &buf[i], 0) == pdTRUE) len++;\n\t\telse {\n\t\t\toverflowCount++;\n\t\t\tarduino_usb_event_post(USB_EVENT_CDC_RX_OVERFLOW, overflowCount);\n\t\t\tlog_e(\"RX queue full, dropped %d bytes\", cnt - len);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > 0) arduino_usb_event_post(USB_EVENT_CDC_RX, len);\n}", "CodeBleu_score": 32.36298456922944}, {"code": "void USBCDC::_onRX(){\n\t\t// read data into buffer\n\tuint8_t buf[64];\n\tuint32_t len = tud_cdc_n_read(0, buf, sizeof(buf));\n\n\t// if no data was read, return\n\tif (!len) return;\n\n\t// attempt to send each byte to the receive queue\n\tfor (uint32_t i = 0; i < len; i++) {\n\t\t// if the queue is full, log an error and post an overflow event\n\t\tif (xQueueSend(rxQueue, &buf[i], 0)!= pdPASS) {\n\t\t\tlog_e(\"RX queue full (%d bytes dropped)\", len - i);\n\t\t\tarduino_usb_event_post(USB_CDC_EVENT_RX_OVERFLOW, len - i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// post a receive event with the length of the received data\n\tarduino_usb_event_post(USB_CDC_EVENT_RX, len);\n}", "CodeBleu_score": 24.644320794467433}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"missing name\"})\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\tdevices := []map[string]interface{}{}\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\": d.Name(),\n\t\t\t\"type\": d.Connection().Type(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 50.1977290575935}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL\n\trobotName := req.URL.Query().Get(\"robot\")\n\t// Check if a robot with the given name exists\n\trobot, ok := a.master.Robot(robotName)\n\tif!ok {\n\t\t// If the robot does not exist, return an error message\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"No robot found with name \" + robotName})\n\t\treturn\n\t}\n\t// If the robot exists, gather its devices into a JSON format\n\tdevicesJSON := make([]map[string]interface{}, len(robot.Devices()))\n\tfor i, device := range robot.Devices() {\n\t\tdevicesJSON[i] = device.JSON()\n\t}\n\t// Write the JSON response to the HTTP response writer\n\ta.writeJSON(res, http.StatusOK, devicesJSON)\n}", "CodeBleu_score": 46.86315515476627}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"missing name\"})\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found\"})\n\t\treturn\n\t}\n\tdevices := []map[string]interface{}{}\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\": d.Name(),\n\t\t\t\"type\": d.Connection().Type(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 49.71873041377579}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := a.req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"Robot '%s' not found\", robotName)})\n\t\treturn\n\t}\n\n\tvar connections []interface{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c.Connection())\n\t})\n\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 51.3571629071434}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(name)\n\tif robot!= nil {\n\t\tconnections := make(map[string]interface{})\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections[c.Name()] = c.Connection()\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeError(res, fmt.Sprintf(\"No robot with name %s was found\", name))\n\t}\n}", "CodeBleu_score": 42.234441095632306}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(name)\n\tif robot!= nil {\n\t\tconnections := []map[string]interface{}{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\t\"name\":    c.Name(),\n\t\t\t\t\"type\":    c.ConnectionType(),\n\t\t\t\t\"adaptor\": c.ConnectionAdaptor(),\n\t\t\t})\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"No robot with name '%s' found\", name),\n\t\t})\n\t}\n}", "CodeBleu_score": 52.10810243835109}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tcommandName := req.URL.Query().Get(\":command\")\n\trobot := a.master.Robot(robotName)\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Device not found.\"})\n\t\treturn\n\t}\n\tif err := device.(gobot.Commander).Command(commandName); err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t} else {\n\t\ta.writeJSON(res, http.StatusOK, map[string]string{\"status\": \"OK\"})\n\t}\n}", "CodeBleu_score": 51.37712259691446}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tcommandName := req.URL.Query().Get(\":command\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Robot not found\"})\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Device not found\"})\n\t\treturn\n\t}\n\n\tcommander, ok := device.(gobot.Commander)\n\tif!ok {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Device does not support commands\"})\n\t\treturn\n\t}\n\n\terr := commander.Command(commandName)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"status\": \"OK\"})\n}", "CodeBleu_score": 48.73731878023633}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\terr := fmt.Errorf(\"device %s not found\", req.URL.Query().Get(\":device\"))\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\tif err := robot.Device(req.URL.Query().Get(\":device\")).\n\t\t(gobot.Commander).\n\t\tCommand(req.URL.Query().Get(\":command\")); err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"status\": \"ok\"})\n}", "CodeBleu_score": 50.97040463350755}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.944149553853194}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.944149553853194}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.08841964175017}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.Connection().AnalogSensor() {\n\t\treturn 0, 0, fmt.Errorf(\"%s is not an analog sensor\", a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.673481071620486}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.Connection().(gobot.AnalogReader).AnalogReadSupported() {\n\t\treturn 0, 0, errors.New(\"AnalogRead not supported\")\n\t}\n\n\traw, err := a.Connection().(gobot.AnalogReader).AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastValue = raw\n\ta.lastScaledValue = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 53.16459539678598}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.Connection().(gobot.AnalogReader).AnalogReadSupported() {\n\t\treturn 0, 0, errors.New(\"AnalogRead not supported\")\n\t}\n\traw, err := a.Connection().(gobot.AnalogReader).AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRead = raw\n\ta.lastReadScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.847230959014695}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tgobot.ValidateIntOption(opts, \"Threshold\", 0)\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\treturn g\n}", "CodeBleu_score": 59.80263922186953}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, PCD_RESETPHASE)\n\ttime.Sleep(10 * time.Microsecond)\n\tif d.readByteData(CommandReg)&(1<<5)!= 0 {\n\t\treturn fmt.Errorf(\"softReset: Failed to reset\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.499686557608054}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, PCD_RESETPHASE)\n\ttime.Sleep(10 * time.Millisecond)\n\tif (d.readByteData(CommandReg)&(1<<4))!= 0 {\n\t\treturn fmt.Errorf(\"reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.722302763085516}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset\n\tif err := d.writeByteData(commandReg, pcdReset); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the power down bit in CommandReg to be cleared\n\tfor i := 0; i < 255; i++ {\n\t\tif err := d.writeByteData(commandReg, pcdReset); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(10 * time.Microsecond)\n\t\tif err := d.readByteData(commandReg, &d.buf[0]); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif (d.buf[0] & (1 << 4)) == 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"MFRC522: softReset failed\")\n}", "CodeBleu_score": 52.451307463511874}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, fmt.Errorf(\"readFifo: no data provided\")\n\t}\n\tif len(backData) > 64 {\n\t\treturn 0, fmt.Errorf(\"readFifo: data slice is too long\")\n\t}\n\tn, err := d.readRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: %w\", err)\n\t}\n\tif int(n)!= len(backData) {\n\t\treturn 0, fmt.Errorf(\"readFifo: expected %d bytes but FIFO contains %d\", len(backData), n)\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, fmt.Errorf(\"readFifo: %w\", err)\n\t\t}\n\t}\n\tn, err = d.readRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: %w\", err)\n\t}\n\treturn n & 0x07, nil\n}", "CodeBleu_score": 45.427206139944346}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Get the number of bytes available in the FIFO buffer\n\tfifoLevel, err := d.readRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes available in the FIFO buffer matches the expected length of the byte slice\n\tif uint8(len(backData))!= fifoLevel {\n\t\treturn 0, fmt.Errorf(\"expected %d bytes in FIFO buffer, got %d\", len(backData), fifoLevel)\n\t}\n\n\t// Read each byte from the FIFO buffer into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Return the last bits received and any errors encountered\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 50.48297597702518}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, nil\n\t}\n\tn := d.readRegister(FIFOLevelReg)\n\tif n > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: number of bytes available in FIFO (%d) is greater than the expected length of the byte slice (%d)\", n, len(backData))\n\t}\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i] = d.readByteData()\n\t}\n\treturn d.readRegister(ControlReg), nil\n}", "CodeBleu_score": 38.91872989096318}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\n\tcmd := []byte{PICC_CMD_HALT_A, 0}\n\td.calculateCRC(cmd)\n\terr := d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 25.94641951955189}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"Halt PICC\")\n\t}\n\tcmd := []byte{PICC_HALT_A}\n\tcmd = append(cmd, byte(0))\n\tcmd = append(cmd, d.calculateCRC(cmd)...)\n\t_, err := d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"Halt PICC failed: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.4200394731607}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Printf(\"piccHalt()\")\n\t}\n\n\tcmd := []byte{PICC_CMD_HALT}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crc[0], d.crc[1])\n\tif err := d.communicateWithPICC(cmd, 0, nil); err!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: %w\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.68511150924666}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif block > 63 {\n\t\treturn nil, errors.New(\"Invalid block number\")\n\t}\n\n\tcmd := []byte{PICC_READ, block}\n\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crc[0], d.crc[1])\n\n\tdata, err := d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif len(data) < 18 {\n\t\treturn nil, errors.New(\"Invalid response length\")\n\t}\n\n\tif data[0]!= PICC_READ {\n\t\treturn nil, errors.New(\"Invalid response\")\n\t}\n\n\tif data[1]!= STATUS_OK {\n\t\treturn nil, errors.New(\"Invalid status\")\n\t}\n\n\tif data[2]!= 16 {\n\t\treturn nil, errors.New(\"Invalid data length\")\n\t}\n\n\treturn data[3:19], nil\n}", "CodeBleu_score": 42.39933368755939}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build the command to read a block\n\tcommand := []byte{PICC_READ, block}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(command)\n\n\t// Append the CRC to the command\n\tcommand = append(command, crc[0], crc[1])\n\n\t// Send the command to the RFID card\n\tresponse, err := d.communicateWithPICC(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif len(response) < 2 || response[0]!= PICC_READ {\n\t\treturn nil, errors.New(\"invalid response from PICC\")\n\t}\n\n\t// Extract the data from the response\n\tdata := response[1 : len(response)-2]\n\n\treturn data, nil\n}", "CodeBleu_score": 39.59368709992261}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif block > 0x3F {\n\t\treturn nil, errors.New(\"Invalid block number\")\n\t}\n\n\t// Build the command buffer\n\tcmd := []byte{PICC_CMD_MF_READ, block}\n\td.calculateCRC(cmd)\n\tcmd = append(cmd, d.crc[0], d.crc[1])\n\n\t// Send the command and receive the response\n\tresp, err := d.communicateWithPICC(cmd, 16)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif len(resp)!= 16 {\n\t\treturn nil, errors.New(\"Invalid response length\")\n\t}\n\n\t// Check if the CRC is valid\n\tif!d.checkCRC(resp[len(resp)-2:]) {\n\t\treturn nil, errors.New(\"Invalid CRC\")\n\t}\n\n\t// Return the data\n\treturn resp[:len(resp)-2], nil\n}", "CodeBleu_score": 39.6557288828683}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(d.CollReg, 0x80) // ValuesAfterColl=0 => Bits received after collision are cleared.\n\n\t// Set the request mode bit rates required.\n\treqMode &= 0x50 // Mask out unused bits.\n\tif reqMode == d.PICC_REQIDL {\n\t\treqMode |= 0x20 // BitRateReqA = 1, BitRateReqB = 0.\n\t}\n\n\tanswer[0] = d.PICC_CMD_REQA\n\tanswer[1] = reqMode\n\treturn d.communicateWithPICC(d.PCD_Transceive, answer, 2, answer)\n}", "CodeBleu_score": 40.338614069905844}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(MFRC522_CollReg, 0x80)\n\n\tif reqMode == MFRC522_PICC_REQIDL {\n\t\td.writeRegister(MFRC522_BitFramingReg, 0x07)\n\t} else {\n\t\td.writeRegister(MFRC522_BitFramingReg, 0x00)\n\t}\n\n\tanswer[0] = reqMode\n\tanswer[1] = 0x00\n\treturn d.communicateWithPICC(MFRC522_PCD_Transceive, answer, 2)\n}", "CodeBleu_score": 37.13752888041388}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too short\")\n\t}\n\n\t// Clear bit mask of bits in register\n\td.clearRegisterBitMask(d.CollReg, d.BitCollReg)\n\n\t// Set the transmission to use only 7 bits of the last byte\n\tif reqMode == d.PICC_REQALL {\n\t\td.setRegisterBitMask(d.BitFramingReg, d.Bit7Bits)\n\t} else {\n\t\td.clearRegisterBitMask(d.BitFramingReg, d.Bit7Bits)\n\t}\n\n\t// Set the request mode\n\tanswer[0] = reqMode\n\n\t// Send the request\n\terr := d.communicateWithPICC(d.PCD_Transceive, answer, 1, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// If the received answer is empty, the PICC is not in the state that it should be\n\tif answer[0] == 0 {\n\t\treturn fmt.Errorf(\"piccRequest: empty answer\")\n\t}\n\n\t// If the received answer is not 2 bytes long, the PICC is not in the state that it should be\n\tif answer[0]!= 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer length is %d instead of 2\", answer[0])\n\t}\n\n\t// If the received answer is not 0x0000, the PICC is not in the state that it should be\n\tif (answer[1] & 0x0F)!= 0 {\n\t\treturn fmt.Errorf(\"piccRequest: answer is not 0x0000\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.49898844399517}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.digitalWrite(d.stepPin, false); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, true); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == 0 {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\treturn nil\n}", "CodeBleu_score": 70.45427298294133}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.digitalWrite(d.stepPin, false); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, true); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\treturn nil\n}", "CodeBleu_score": 69.56288425307883}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, false); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, true); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 70.14769883998729}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running for '%s'\", d.name)\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", d.name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 76.20429908018413}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 75.08010773393553}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor is already running for '%s'\", d.name)\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", d.name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 78.24125275553445}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, pulseDuration uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if state == \"falling\" {\n\t\t\td.duration <- durationToMicroseconds(timestamp - startTimestamp)\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 44.421743356975476}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := uint32(0)\n\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := d.calculateDuration(startTimestamp, timestamp)\n\t\t\td.durationChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 45.074387894625175}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\treturn func(pin int, timestamp time.Duration, edge string, counter uint32, value uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if edge == \"falling\" {\n\t\t\td.durationChannel <- timestamp.Sub(startTimestamp)\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 42.59538003207365}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.emitTrigger()\n\tselect {\n\tcase <-d.measureChannel:\n\t\td.lastMeasuredTime = time.Now()\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"Timeout measuring distance\")\n\t}\n}", "CodeBleu_score": 38.481345496851574}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\tselect {\n\tcase <-d.measureChan:\n\t\td.measuredTime = time.Now().Sub(d.measureStartTime)\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout measuring distance\")\n\t}\n}", "CodeBleu_score": 38.775509834663445}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\tselect {\n\tcase <-d.measureDone:\n\t\td.measureTime = time.Since(d.measureStart).Microseconds()\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n}", "CodeBleu_score": 39.90972431171053}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = os.getenv(\"CORTEX_TOKEN\")\n    if token:\n        return token\n    else:\n        state = self.get_state_item(\"auth\")\n        if state and state.get(\"expires_at\") and state.get(\"access_token\"):\n            if state[\"expires_at\"] > time.time():\n                return state[\"access_token\"]\n            elif state.get(\"refresh_token\"):\n                try:\n                    response = self.fetch_json_data(\n                        \"https://api.cortex.insights.ai/v1/auth/token\",\n                        method=\"POST\",\n                        headers={\"Content-Type\": \"application/json\"},\n                        body=json.dumps({\"refresh_token\": state[\"refresh_token\"]}),\n                    )\n                    self.set_state_item(\n                        \"auth\",\n                        {\n                            \"access_token\": response[\"access_token\"],\n                            \"refresh_token\": response[\"refresh_token\"],\n                            \"expires_at\": time.time() + response[\"expires_in\"],\n                        },\n                    )\n                    return response[\"access_token\"]\n                except HTTPClientError as exc:\n                    raise AccountNotAuthorized(exc) from exc\n        raise AccountNotAuthorized()\n\n", "CodeBleu_score": 41.954758196852495}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\"SPOTIFY_AUTH_TOKEN\"]\n    except KeyError:\n        try:\n            state = app.get_state_item(self.state_key)\n            if state[\"expires_at\"] < time.time():\n                if state[\"refresh_token\"]:\n                    try:\n                        data = self.fetch_json_data(\n                            \"https://accounts.spotify.com/api/token\",\n                            method=\"POST\",\n                            headers={\n                                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                                \"Authorization\": \"Basic \" + base64.b64encode(\n                                    (self.client_id + \":\" + self.client_secret).encode(\"ascii\")\n                                ).decode(\"ascii\"),\n                            },\n                            body=urlencode(\n                                {\n                                    \"grant_type\": \"refresh_token\",\n                                    \"refresh_token\": state[\"refresh_token\"],\n                                }\n                            ),\n                        )\n                        self.update_local_session(data)\n                        return data[\"access_token\"]\n                    except HTTPClientError as exc:\n                        if exc.status_code == 401:\n                            raise AccountNotAuthorized(\"Invalid refresh token\") from exc\n                        raise exc\n                else:\n                    raise AccountNotAuthorized(\"No refresh token available\")\n            else:\n                return state[\"access_token\"]\n        except KeyError:\n            raise AccountNotAuthorized(\"No access token available\")\n\n", "CodeBleu_score": 36.38584279757392}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.getenv(\"TOKEN\")\n    if token:\n        return token\n    local_state = self.get_local_state()\n    if local_state.get(\"expires_at\") and local_state.get(\"expires_at\") < time.time():\n        raise AccountNotAuthorized(\"Token expired\")\n    if local_state.get(\"refresh_token\"):\n        try:\n            token = self.fetch_json_data(\n                \"https://auth.api.riotgames.com/oauth-token\",\n                method=\"POST\",\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": local_state[\"refresh_token\"],\n                },\n            )[\"access_token\"]\n            self.update_local_state(\n                {\n                    \"access_token\": token,\n                    \"expires_at\": time.time() + 3600,\n                    \"refresh_token\": local_state[\"refresh_token\"],\n                }\n            )\n            return token\n        except HTTPClientError as exc:\n            raise AccountNotAuthorized(exc) from exc\n    raise AccountNotAuthorized(\"No token available\")\n\n", "CodeBleu_score": 43.02331869451659}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 56.03516848881591}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"POST\",\n            f\"{self.BASE_URL}/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 52.19790743230084}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 71.39441244887978}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.pm.packages:\n        if not package.optional:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": package.source_url if package.external else None,\n                }\n            )\n    return result\n\n", "CodeBleu_score": 26.17972329279868}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.is_optional:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": package.source_url if package.is_external else None,\n                }\n            )\n    return result\n\n", "CodeBleu_score": 24.617219006788773}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, package in self.pm.packages.items():\n        if package.optional:\n            continue\n        spec = self.get_package_spec(name)\n        package = self.get_package(name, spec=spec)\n        if not package:\n            continue\n        metadata = package.metadata\n        if not metadata:\n            continue\n        if metadata.get('external'):\n            spec = metadata.get('source')\n        result.append((name, spec))\n    return result\n", "CodeBleu_score": 44.97312451979758}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.get_platform(env)\n    if platform is None:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls.new(platform, autoinstall=autoinstall)\n    instance.set_project(cls)\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 26.593964482387346}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    return cls.new(platform_spec, autoinstall=autoinstall).configure_project_packages(\n        env, targets\n    )\n", "CodeBleu_score": 24.419834976046296}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.get_platform(env)\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    return cls.new(platform, autoinstall=autoinstall).configure(env, targets=targets)\n", "CodeBleu_score": 21.002030248386998}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(AXP192_ADDR);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 64.47332335487037}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(AXP192_ADDR);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 64.47332335487037}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(AXP192_ADDR);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(AXP192_ADDR, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 66.97266786367173}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 54.77349151030913}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#if defined(AXP192_DEBUG)\n    Serial.print(F(\"DeepSleep: \"));\n    Serial.println(time_in_us);\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 72.69632327811564}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = tft.getCursorY();\n\ttft.fillRect(0, y, tft.width(), textsize*8, color);\n\ty += textsize*8;\n\tif (y >= tft.height()-bottom_fixed_area) {\n\t\ty = top_fixed_area;\n\t}\n\tscrollAddress(y);\n\treturn y;\n}", "CodeBleu_score": 13.44247080128704}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_old = y;\n\tif (y < tft.height() - (tteBar? TTE_FIXED_AREA_TOP : 0) - TTE_FIXED_AREA_BOTTOM) {\n\t\ty += tteLineHeight;\n\t} else {\n\t\ty = tteBar? TTE_FIXED_AREA_TOP : 0;\n\t}\n\ttft.fillRect(0, y_old, tft.width(), tteLineHeight, color);\n\tscrollAddress(y);\n\treturn y_old;\n}", "CodeBleu_score": 21.0915845215238}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t y_old = y_coord;\n\tif (y_coord >= tft.height() - (tteBar? 12 : 0)) {\n\t\ty_coord = (tteBar? 12 : 0);\n\t}\n\ttft.fillRect(0, y_coord, tft.width(), 12, color);\n\ty_coord += 12;\n\tscrollAddress(y_coord);\n\treturn y_old;\n}", "CodeBleu_score": 15.301330487264725}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set the ssid list\n\tthis->ssids = ssids;\n\t// set the access point list\n\tthis->access_points = access_points;\n\t// set the html\n\tthis->setHtml();\n\t// start the portal\n\treturn this->startPortal();\n}", "CodeBleu_score": 48.90891239572751}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(ssids, access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml()) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 72.40003004294124}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->setAP(ssids, access_points);\n\tthis->setHtml();\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 53.93429455304519}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue_init_flag == false) {\n\t\t\tthis->queue_init_flag = true;\n\t\t\tthis->queue.clear();\n\t\t\tthis->text = \"\";\n\t\t\tthis->text_in = \"\";\n\t\t}\n\t} else {\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->queue_init_flag = true;\n\t\tthis->queue.clear();\n\t\tthis->text = \"\";\n\t\tthis->text_in = \"\";\n\t}\n}", "CodeBleu_score": 20.773256319674445}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == true) {\n\t\tif (this->queue.size() == 0) {\n\t\t\tthis->queue.push(this->text);\n\t\t\tthis->text = \"\";\n\t\t}\n\t\tif (this->text_in.size() == 0) {\n\t\t\tthis->text_in.push(this->text);\n\t\t\tthis->text = \"\";\n\t\t}\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 26.489426387875366}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->queue = \"\";\n\t\tthis->text = \"\";\n\t\tthis->text_in = \"\";\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 22.95172689852788}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tdelete this->queue_nmea;\n\t}\n\tthis->queue_nmea = new std::queue<std::string>();\n}", "CodeBleu_score": 14.805039773581557}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tif (this->queue_nmea->size > 0) {\n\t\t\tthis->new_queue_nmea = new Queue(this->queue_nmea->size);\n\t\t\tdelete this->queue_nmea;\n\t\t\tthis->queue_nmea = this->new_queue_nmea;\n\t\t\tthis->new_queue_nmea = NULL;\n\t\t}\n\t} else {\n\t\tthis->queue_nmea = new Queue(10);\n\t}\n}", "CodeBleu_score": 17.100012783330097}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tif (this->queue_nmea->size > 0) {\n\t\t\tthis->new_queue_nmea = new Queue();\n\t\t\tdelete this->queue_nmea;\n\t\t\tthis->queue_nmea = this->new_queue_nmea;\n\t\t\tthis->new_queue_nmea = NULL;\n\t\t} else {\n\t\t\tdelete this->queue_nmea;\n\t\t\tthis->queue_nmea = NULL;\n\t\t}\n\t} else {\n\t\tthis->queue_nmea = new Queue();\n\t}\n}", "CodeBleu_score": 18.660587181748994}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t c;\n\tdisplay_obj.tft.startWrite();\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n\tfor (uint16_t y = area->y1; y <= area->y2; y++) {\n\t\tfor (uint16_t x = area->x1; x <= area->x2; x++) {\n\t\t\tc = color_p->full;\n\t\t\tdisplay_obj.tft.writeColor(c, 1);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tdisplay_obj.tft.endWrite();\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 86.59972021361986}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t c;\n\n\tdisplay_obj.tft.startWrite(); /* Start new TFT transaction */\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1)); /* set the working window */\n\tfor (int y = area->y1; y <= area->y2; y++) {\n\t\tfor (int x = area->x1; x <= area->x2; x++) {\n\t\t\tc = color_p->full;\n\t\t\tdisplay_obj.tft.writeColor(c, 1);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tdisplay_obj.tft.endWrite(); /* terminate TFT transaction */\n\tlv_disp_flush_ready(disp); /* tell lvgl that flushing is done */\n}", "CodeBleu_score": 87.41909564961585}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tif (menu->list == NULL) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"\\t\");\n\t\t}\n\t\tSerial.print(i);\n\t\tSerial.print(\": \");\n\t\tSerial.println(menu->list->get(i)->name);\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 67.6016236660106}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu->list!= NULL) {\n\t\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\t\tMenu * node = menu->list->get(i);\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tSerial.print(\"  \");\n\t\t\t}\n\t\t\tSerial.print(node->name);\n\t\t\tSerial.println();\n\t\t\tshowMenuList(node, layer + 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 60.3977666999038}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu->list == NULL) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tMenu * node = menu->list->get(i);\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\" \");\n\t\t}\n\t\tSerial.println(node->name);\n\t\tshowMenuList(node, layer + 1);\n\t}\n\tSerial.println(\"\");\n}", "CodeBleu_score": 59.189374319999914}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tString ssid;\n\tfor (i = 0; i < count; i++) {\n\t\tssid = generateSSID();\n\t\tSerial.print(\"Generated SSID: \");\n\t\tSerial.println(ssid);\n\t\tssids->add(ssid);\n\t}\n\treturn i;\n}", "CodeBleu_score": 21.185422846461293}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tint c = random(65, 91);\n\t\t\tssid.concat(char(c));\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 12; j++) {\n\t\t\tint c = random(0, 16);\n\t\t\tif (c < 10) {\n\t\t\t\tmac.concat(char(c + 48));\n\t\t\t} else {\n\t\t\t\tmac.concat(char(c + 55));\n\t\t\t}\n\t\t}\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" \");\n\t\tSerial.print(channel);\n\t\tSerial.print(\" \");\n\t\tSerial.println(mac);\n\t\tssids->add(new WiFiScanResult(ssid, channel, mac));\n\t}\n\treturn i;\n}", "CodeBleu_score": 41.3520661613009}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid.concat(random(26) + 'a');\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac.concat(String(random(256), HEX));\n\t\t\tif (j!= 5) {\n\t\t\t\tmac.concat(\":\");\n\t\t\t}\n\t\t}\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" \");\n\t\tSerial.print(channel);\n\t\tSerial.print(\" \");\n\t\tSerial.println(mac);\n\t\tssids->add(new WiFiScanResult(ssid, channel, mac));\n\t}\n\treturn count;\n}", "CodeBleu_score": 48.16461416996093}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n    with open(private_key_file) as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 42.807950614686376}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n    with open(private_key_file) as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 42.807950614686376}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return encoded_jwt\n\n", "CodeBleu_score": 54.95417502730753}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode('utf-8'))\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'\\\n         .format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        preview_capture('image.jpg')\n        url = upload_file('image.jpg', 'iot-test-bucket-2020')\n        print(url)\n        unused_client.publish('projects/iot-test-2020/topics/image_url', url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 38.727517439716244}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        preview_capture('image.jpg')\n        url = upload_file('image.jpg', args.bucket_name)\n        print('Image uploaded to {}'.format(url))\n        unused_client.publish('events', url, qos=1)\n    else:\n        print('off')", "CodeBleu_score": 42.11182037619447}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        unused_client.publish('projects/{}/topics/events'.format(args.project_id), url, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 45.57640036077661}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection via MQTT.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region.\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        default=\"my-registry\",\n        help=\"Cloud IoT Core registry ID.\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        default=\"my-node-device\",\n        help=\"Cloud IoT Core device ID.\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help='Indicates whether the message to be published is a \"event\" or a \"state\".',\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help='Indicates whether the message to be published is a \"event\" or a \"state\".',\n    )\n    parser.add_argument(\n        \"--message_data\",\n        default=\"Hello world\",\n        help='The message data to publish. If not", "CodeBleu_score": 35.54173311289433}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT Core MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        default=\"projects/{}/subscriptions/{}\".format(\n            os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), \"my-subscription\"\n        ),\n        help=\"Pub/Sub subscription name\",\n    )\n    parser.add_argument(\n        \"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Which encryption algorithm to use to generate the JWT.\"\n    )\n    parser.add_argument(\n        \"--ca_certs\", default=\"roots.pem\", help=\"CA root from https://pki.google.com/roots.pem\"\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--client_id\", help=\"MQTT client id, defaults to 'gcloud-iot-example'\"\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT Core registry id\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT Core device id\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help='Indicates whether the message to be published is a \"event\" or a \"state\".',\n    )\n    parser.add_argument", "CodeBleu_score": 37.21071748665031}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        default=os.environ.get(\"GOOGLE_CLOUD_IOT_DEVICE_PRIVATE_KEY_FILE\"),\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default=os.environ.get(\"GOOGLE_CLOUD_IOT_CA_ROOT_CERT_FILE\"),\n        help='Path to root certificate file.')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        type=int,\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Whether the message to be published is a \"event\" or a \"state\".')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        type=int,\n        default=20,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument(\n        '--service_account_json',\n        default=os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\"),\n        help='Path to service account json file.')\n    return parser.parse_args()\n\n\n", "CodeBleu_score": 39.8037775895297}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # The following scopes are necessary for the Google Cloud IoT Core service:\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/pubsub\",\n    ]\n\n    # Define the API endpoint and version\n    api_endpoint = \"https://cloudiot.googleapis.com/\"\n    api_version = \"v1\"\n\n    # Define the discovery URL\n    discovery_url = \"{}/{}/$discovery/rest\".format(api_endpoint, api_version)\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Scope the credentials to the necessary API scopes\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    # Build and return the client for the Google Cloud IoT Core service\n    return discovery.build(\n        \"cloudiot\", api_version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url\n    )\n\n", "CodeBleu_score": 42.65412784230478}, {"code": "def get_client(service_account_json)\n\t\n    # Load the service account JSON file\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    # Define the necessary API scopes, version, and discovery URL\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # Scopes the credentials appropriately\n    scoped_credentials = credentials.with_scopes(scopes)\n    # Build and return the client for the Cloud IoT Core service using the discovery API URL\n    return discovery.build('cloudiot', version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n", "CodeBleu_score": 21.47047561179294}, {"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(['https://www.googleapis.com/auth/cloud-platform'])\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    return discovery.build('cloudiot', 'v1', credentials=scoped_credentials, discoveryServiceUrl=discovery_api_url)\n", "CodeBleu_score": 18.95290844873099}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   try:\n        asn1_code = HASH_ASN1_CODES[hash_method]\n    except KeyError:\n        raise ValueError('Unknown hash method: %s' % hash_method)\n\n    # ASN1 code is 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00\n    # ASN1 code is 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00\n    # ASN1 code is 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00\n    # ASN1 code is 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00\n    # ASN1 code is 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0", "CodeBleu_score": 14.397062468475557}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  hash_asn1 = {\n       'sha1': b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14',\n       'sha224': b'\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c',\n       'sha256': b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20',\n       'sha384': b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30',\n       'sha512': b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40',\n       'sha3_224': b'\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x05\\x05\\x00\\x04\\x1c',\n       'sha3_256': b'\\", "CodeBleu_score": 5.335459864498713}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  asn1_code = hash_method_codes.get(hash_method)\n    if not asn1_code:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_with_asn1 = b''.join([asn1_code, hash_value])\n    padded_hash = _pad_for_signing(hash_value_with_asn1, priv_key.modulus_length)\n    return priv_key.blinded_encrypt(padded_hash)\n\n\n", "CodeBleu_score": 27.24982281029317}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t  if not isinstance(pub_key, PublicKey):\n        raise TypeError('pub_key must be an instance of PublicKey')\n\n    if not isinstance(signature, bytes):\n        raise TypeError('signature must be bytes')\n\n    if not isinstance(message, bytes):\n        raise TypeError('message must be bytes')\n\n    # Convert signature to an integer\n    clearsig = pub_key.decrypt_int(signature)\n\n    # Determine the hash method used\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hash_method = HASH_METHODS[method_name]\n    hasher = hash_method()\n    hasher.update(message)\n    message_hash = hasher.digest()\n\n    # Reconstruct the expected padded hash\n    expected_clearsig = _pad_for_signing(message_hash, hasher.digest_size)\n\n    # Verify the signature\n    if clearsig!= expected_clearsig:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 44.06837532505449}, {"code": "def verify(message, signature, pub_key)\n\t  if not isinstance(signature, (bytes, bytearray)):\n        raise TypeError('Signature must be bytes')\n\n    if not isinstance(pub_key, RSAKey):\n        raise TypeError('pub_key must be an RSAKey')\n\n    # convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # decrypt the signature to obtain the clear signature\n    clearsig = core.decrypt_int(signature_int, pub_key)\n\n    # find the hash method\n    method_name = _find_method_hash(clearsig)\n\n    # compute the hash of the message\n    hash = compute_hash(message, method_name)\n\n    # reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(hash, len(clearsig))\n\n    if not expected_hash == clearsig:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 50.356520122420214}, {"code": "def verify(message, signature, pub_key)\n\t # Convert the signature to an integer\n    signature_int = bytes_to_int(signature)\n\n    # Decrypt the signature to obtain the clear signature\n    clearsig = pub_key.decrypt(signature_int)\n\n    # Determine the hash method used\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(message_hash, pub_key.size_in_bytes())\n\n    # Compare the expected padded hash with the clear signature\n    if clearsig!= expected_hash:\n        raise VerificationError('Verification failed')\n\n    # If the verification is successful, return the hash method name\n    return method_name\n", "CodeBleu_score": 25.731223546736725}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint ret;\n\tstruct timeval tv;\n\tuint32_t epoch;\n\n\tgettimeofday(&tv, NULL);\n\tepoch = tv.tv_sec;\n\tif (epoch > 1577836800) {\n\t\tupdateJWT(epoch);\n\t\tret = MQTT_CLIENT_connect();\n\t\tif (ret == 0) {\n\t\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\t\tmqttConnected = true;\n\t\t\tmqttSubscribed = false;\n\t\t} else {\n\t\t\tdebug_printError(\"MQTT: Connection failed\");\n\t\t\tmqttConnected = false;\n\t\t}\n\t} else {\n\t\tdebug_printError(\"MQTT: Invalid time\");\n\t\tmqttConnected = false;\n\t}\n}", "CodeBleu_score": 19.413864163694118}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tuint8_t res = 0;\n\ttime_t t;\n\tstruct tm *tm;\n\n\tdebug_printInfo(\"MQTT: connectMQTT\");\n\n\tepoch = getTime();\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tres = MQTT_CLIENT_connect();\n\t\tif (res == 0) {\n\t\t\tdebug_printInfo(\"MQTT: connectMQTT: connected\");\n\t\t\tmqtt_subscribe = 1;\n\t\t} else {\n\t\t\tdebug_printInfo(\"MQTT: connectMQTT: failed to connect\");\n\t\t\tmqtt_subscribe = 0;\n\t\t}\n\t} else {\n\t\tdebug_printInfo(\"MQTT: connectMQTT: failed to get time\");\n\t}\n}", "CodeBleu_score": 42.27443420357817}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tif (time_getEpoch(&epoch) == 0) {\n\t\tupdateJWT(epoch);\n\t\tMQTT_CLIENT_connect(cid, mqttPassword, mqttTopic, &mqttConnected);\n\t} else {\n\t\tdebug_printError(\"MQTT: Failed to get epoch time\");\n\t}\n}", "CodeBleu_score": 41.015767143119874}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 26.22892502452124}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif ((str[i] < '0') || (str[i] > '9')) {\n\t\t\treturn str;\n\t\t}\n\t\tresult = (result * 10) + (str[i] - '0');\n\t}\n\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 25.631462027053242}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tif (!is_digit(str[i])) {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + (str[i] - '0');\n\t}\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 23.927924645063975}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ATCA_CERT_VERIFY_FAILED;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 70.22980610062788}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tsize_t signature_size = 0;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn atcab_verify_extern(tbs_digest, signature, ca_public_key);\n}", "CodeBleu_score": 67.01593129511252}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tsize_t signature_size;\n\n\t// Check parameters\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the TBS digest\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the signature\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the TBS digest against the signature\n\tret = atcab_verify_extern(ca_public_key, 0, tbs_digest, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 71.23166232764942}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#line 225 \"C:/Users/Daniel/Documents/MPLABX/projects_eagle/firmware/src/timeout.c\"\n    if(timer == NULL)\n    {\n        return false;\n    }\n\n    if(timer->next == timer)\n    {\n        timer->next = NULL;\n        return true;\n    }\n\n    timerStruct_t *previous = timer->next;\n\n    while(previous->next!= timer)\n    {\n        previous = previous->next;\n    }\n\n    previous->next = timer->next;\n    timer->next = NULL;\n    return true;\n}", "CodeBleu_score": 28.47252213845603}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    if(timer == NULL)\n    {\n        return false;\n    }\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    if(timer->next == NULL)\n    {\n        return false;\n    }\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    timer->next->prev = timer->prev;\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    timer->prev->next = timer->next;\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    if(timer == listHead)\n    {\n        listHead = timer->next;\n    }\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    if(timer == listTail)\n    {\n        listTail = timer->prev;\n    }\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    timer->next = NULL;\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    timer->prev = NULL;\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n    return true;\n\n#line 223 \"timeout.c\"\n\n#line 223 \"timeout.c\"\n}", "CodeBleu_score": 30.000324869778865}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#line 137 \"c:\\\\users\\\\sofia\\\\desktop\\\\git repo\\\\sw-dp9_dpx\\\\modules\\\\atcacert\\\\atcacert\\\\src\\\\atcacert_client.c\"\n    timerStruct_t * volatile *prev = list;\n\n    while (*prev!= NULL)\n    {\n        if (*prev == timer)\n        {\n            *prev = timer->next;\n            timer->next = NULL;\n            return true;\n        }\n        prev = &(*prev)->next;\n    }\n    return false;\n}", "CodeBleu_score": 24.839737345863195}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\ttstrSocket *pstrSocket = NULL;\n\tsint8 ret = BSD_SUCCESS;\n\tif ((socket < 0) || (socket >= BSD_MAX_SOCKETS)) {\n\t\tbsd_setErrNo(BSD_ERROR_INVALID_SOCKET);\n\t\tret = BSD_ERROR;\n\t} else {\n\t\tpstrSocket = &gastrSockets[socket];\n\t\tif (pstrSocket->bIsUsed == 0) {\n\t\t\tbsd_setErrNo(BSD_ERROR_INVALID_SOCKET);\n\t\t\tret = BSD_ERROR;\n\t\t} else {\n\t\t\tpstrSocket->bIsUsed = 0;\n\t\t\tret = close(socket);\n\t\t\tif (ret!= SOCK_ERR_NO_ERROR) {\n\t\t\t\tbsd_setErrNo(BSD_ERROR_INVALID_SOCKET);\n\t\t\t\tret = BSD_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 34.983096897892395}, {"code": "int BSD_close(int socket){\n\tsint8 ret;\n\ttstrSocket *pstrSocket = NULL;\n\tif (socket < 0 || socket >= MAX_BSD_SOCKETS) {\n\t\tbsd_setErrNo(BSD_ERROR_INVALID);\n\t\treturn BSD_ERROR;\n\t}\n\tpstrSocket = &gastrSockets[socket];\n\tif (pstrSocket->bIsUsed == 0) {\n\t\tbsd_setErrNo(BSD_ERROR_INVALID);\n\t\treturn BSD_ERROR;\n\t}\n\tpstrSocket->bIsUsed = 0;\n\tret = close(socket);\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t} else {\n\t\tif (ret == SOCK_ERR_INVALID_ARG) {\n\t\t\tbsd_setErrNo(BSD_ERROR_INVALID);\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_ERROR_OTHER);\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 44.367048913204634}, {"code": "int BSD_close(int socket){\n\t", "CodeBleu_score": 1.4458552095808714}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ttstrListenCmd\t\tstrListen;\n\n\t\tstrListen.sock = socket;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\n\t\ts8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 36.196049460483856}, {"code": "int BSD_listen(int socket, int backlog){\n\t", "CodeBleu_score": 4.893994777977414}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8 ret = listen(socket, backlog);\n\tif(ret!= SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 22.482362991539922}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tuint8_t res = 0;\n\tif (time_getUnixEpoch(&epoch)) {\n\t\tdebug_printInfo(\"MQTT: epoch=%d\", epoch);\n\t\tupdateJWT(epoch);\n\t\tres = MQTT_CLIENT_connect(epoch);\n\t}\n\tif (res) {\n\t\tdebug_printError(\"MQTT: Failed to connect to MQTT broker\");\n\t}\n\telse {\n\t\tdebug_printInfo(\"MQTT: Connected to MQTT broker\");\n\t\tmqtt_subscribe = 1;\n\t}\n}", "CodeBleu_score": 38.84389199702127}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tif (TIME_CLIENT_getUnixTime(&epoch) && epoch!= 0) {\n\t\tupdateJWT(epoch);\n\t\tif (MQTT_CLIENT_connect(mqttBroker, mqttPort, clientId, cid, mqttUsername, mqttPassword)) {\n\t\t\tdebug_printInfo(\"MQTT: Connected to %s:%d\", mqttBroker, mqttPort);\n\t\t\tmqttSubscribe = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.26392309485906}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tif (CRYPTO_CLIENT_getTime(&epoch)) {\n\t\tupdateJWT(epoch);\n\t\tdebug_printInfo(\"MQTT: Connecting to %s:%d\", mqttBroker, mqttPort);\n\t\tMQTT_CLIENT_connect(mqttBroker, mqttPort, cid, mqttUsername, mqttPassword);\n\t\tMQTT_CLIENT_setSubscribe(true);\n\t}\n}", "CodeBleu_score": 37.60393024044021}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tmqttCurrentState mqttState = MQTT_GetConnectionState();\n\tmqttClientConnectionInfo mqttConnectionInfo;\n\n\tif (mqttState == CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo(&mqttConnectionInfo);\n\t\tMQTT_Disconnect(&mqttConnectionInfo);\n\t}\n\tdebug_printError(DEBUG_ERROR, \"MQTT Disconnected\");\n}", "CodeBleu_score": 47.64742692011618}, {"code": "void CLOUD_disconnect(void){\n\t\tmqttCurrentState mqttState;\n\tmqttClientInfo clientInfo;\n\n\tmqttState = MQTT_GetConnectionState();\n\tif (mqttState == CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo(&clientInfo);\n\t\tMQTT_Disconnect(&clientInfo);\n\t\tdebug_printError(\"MQTT_Disconnect\", \"Disconnected from the cloud service\");\n\t}\n}", "CodeBleu_score": 47.97153256622166}, {"code": "void CLOUD_disconnect(void){\n\t\tmqttClientConnectionInfo_t clientConnectionInfo;\n\tmqttCurrentState = MQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\n\tif (mqttCurrentState == CONNECTED) {\n\t\tMQTT_Disconnect(&clientConnectionInfo);\n\t\tdebug_printError(\"MQTT Disconnected\");\n\t}\n}", "CodeBleu_score": 47.440829154541134}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret = 0;\n\tif (passed_wifi_creds) {\n\t\tret = m2m_wifi_connect((char*)gstrM2mWifiConn.au8SSID, gstrM2mWifiConn.u8SsidLen, gstrM2mWifiConn.u8SecType, (void*)gstrM2mWifiConn.au8Password, gstrM2mWifiConn.u16Ch);\n\t}\n\telse {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret!= M2M_SUCCESS) {\n\t\tdebug_printError(\"Failed to connect to AP\");\n\t\tnetworking_error_status = NETWORKING_ERROR_STATUS_WIFI_CONNECT_FAILED;\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 53.73253371466667}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tif(passed_wifi_creds) {\n\t\tret = m2m_wifi_connect(wifi_ssid, strlen((char *)wifi_ssid), wifi_security, (void *)wifi_password, wifi_channel);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif(ret!= M2M_SUCCESS) {\n\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_connect failed with error %d\n\", ret);\n\t\tnetworking_error = true;\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 58.73527527999497}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tif (passed_wifi_creds) {\n\t\tret = m2m_wifi_connect(wifi_ssid, strlen((char *)wifi_ssid), wifi_security, (void *)wifi_password, wifi_channel);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret!= M2M_SUCCESS) {\n\t\tdebug_printError(ret, __LINE__, __FILE__);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 55.10689992623006}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tnst client = await generateClient();\n\tconst response = await client.graphql({\n\t\tquery: `query { listSensors { id name geo { latitude longitude } } }`,\n\t});\n\tconsole.log(response);\n\tif (response.data.listSensors) {\n\t\tconsole.log(\"Retrieved sensors:\");\n\t\tresponse.data.listSensors.forEach((sensor) => {\n\t\t\tconst marker = CreateSensorMarker(sensor);\n\t\t\tnew mapboxgl.Marker({element: marker})\n\t\t\t\t.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 50.31221031257576}, {"code": "async function DisplaySensors(map){\n\t Generate a client\n\tconst client = new ApolloClient({\n\t\turi: \"https://api.spacex.land/graphql/\",\n\t});\n\t// Send a GraphQL query to fetch sensor data\n\tconst response = await client.query({\n\t\tquery: gql`\n\t\t\tquery {\n\t\t\t\tlistSensors {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tgeo {\n\t\t\t\t\t\tlatitude\n\t\t\t\t\t\tlongitude\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t});\n\t// Log the API response\n\tconsole.log(response);\n\t// If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n\tif (response.data.listSensors) {\n\t\tconsole.log(\"Retrieved sensors:\");\n\t\tresponse.data.listSensors.forEach((sensor) => {\n\t\t\t// Create a marker\n\t\t\tconst marker = document.createElement(\"div\");\n\t\t\tmarker.className = \"marker\";\n\t\t\t// Place the marker on the map at the sensor's geographical coordinates\n\t\t\tnew mapboxgl.Marker({element: marker})\n\t\t\t\t.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 44.501478015769905}, {"code": "async function DisplaySensors(map){\n\tst client = generateClient();\nconst response = await client.graphql({query: CreateSensorMarker});\nconsole.log(response.data);\nif (response.data.listSensors) {\nconsole.log(\"Retrieved Sensors\");\nresponse.data.listSensors.forEach((sensor) => {\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\nnew mapboxgl.Marker({element: marker})\n.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n.addTo(map);\n});\n}\n}", "CodeBleu_score": 48.48377375732895}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = '2px solid'+ sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 47.14487758513569}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = '#ff0000';\n\tmarker.style.border = '2px solid #ffffff';\n\treturn marker;\n}", "CodeBleu_score": 42.63622048995457}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"grey\";\n\tmarker.style.border = \"1px solid black\";\n\treturn marker;\n}", "CodeBleu_score": 41.86821791920606}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, module_name)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to import module %s\", module_name)\n        raise\n    if not hasattr(module, \"requirements\"):\n        return module\n    if not hass.config.skip_pip:\n        processed = hass.data.setdefault(DATA_MFA_REQUIREMENTS_PROCESSED, set())\n        if module.requirements and module.requirements not in processed:\n            await async_process_requirements(hass, module.requirements)\n            processed.add(module.requirements)\n    return module", "CodeBleu_score": 41.732241034896745}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Unable to load MFA module %s: %s\", module_path, err)\n        raise HomeAssistantError(\n            f\"Unable to load MFA module {module_path}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"requirements\"):\n        return module\n\n    if not hass.config.skip_pip:\n        processed = hass.data.setdefault(DATA_MFA_REQUIREMENTS_PROCESSED, set())\n        if module.requirements not in processed:\n            await async_process_requirements(hass, module.requirements)\n            processed.add(module.requirements)\n\n    return module", "CodeBleu_score": 57.740692839343}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.auth.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        if err.name!= module_path:\n            raise\n        _LOGGER.error(\n            \"Unable to import the %s multi-factor authentication (MFA) module. Please check your configuration\",\n            module_name,\n        )\n        raise\n    if not module.REQUIREMENTS:\n        return module\n    if not hass.config.skip_pip:\n        requirements = await async_process_requirements(hass, module.REQUIREMENTS)\n        processed = hass.data.setdefault(DATA_REQUIREMENTS_PROCESSED, set())\n        for requirement in requirements:\n            if requirement in processed:\n                continue\n            try:\n                await async_import_module(hass, requirement)\n            except ModuleNotFoundError as err:\n                if err.name!= requirement:\n                    raise\n                _LOGGER.error(\n                    \"Unable to import the %s requirement for the %s multi-factor authentication (MFA) module. Please check your configuration\",\n                    requirement,\n                    module_name,\n                )\n                raise\n            processed.add(requirement)\n    return module", "CodeBleu_score": 45.03042132676433}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if \"pin\" not in setup_data:\n        raise InvalidSetupDataError(\"No PIN provided.\")\n    pin = setup_data[\"pin\"]\n    if not isinstance(pin, str):\n        raise InvalidSetupDataError(\"PIN must be a string.\")\n    if not pin.isnumeric():\n        raise InvalidSetupDataError(\"PIN must be numeric.\")\n    if len(pin)!= 4:\n        raise InvalidSetupDataError(\"PIN must be 4 digits.\")\n    data = await self.async_get_data()\n    if user_id in data:\n        data[user_id] = pin\n    else:\n        data[user_id] = pin\n    await self.async_set_data(data)\n    return pin\n\n", "CodeBleu_score": 34.50914753403701}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if \"pin\" not in setup_data:\n        return None\n\n    pin = setup_data[\"pin\"]\n\n    if user_id in self._data:\n        self._data[user_id] = pin\n    else:\n        self._data.append(user_id, pin)\n\n    return pin\n\n", "CodeBleu_score": 44.1345894188177}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not isinstance(setup_data, str):\n        raise InvalidSetupDataError(\"Invalid setup data type\")\n    if not setup_data.isnumeric():\n        raise InvalidSetupDataError(\"Invalid setup data\")\n    pin = setup_data\n    if user_id in self.data:\n        self.data[user_id] = pin\n    else:\n        self.data[user_id] = pin\n    return pin\n", "CodeBleu_score": 29.92169359834831}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        if not (data := await self._store.async_load()):\n            data = {}\n\n        self._data = data\n        self._loaded = True\n\n        for user_id, user_data in data.items():\n            self._settings[user_id] = NotifySetting(user_id, user_data)\n\n", "CodeBleu_score": 32.817925327004424}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings:\n            return\n\n        if not (data := await self._store.async_load()):\n            data = {}\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id=user_id,\n                enabled=data.get(user_id, {}).get(\"enabled\", True),\n                notify_type=data.get(user_id, {}).get(\"notify_type\", \"push\"),\n                push_token=data.get(user_id, {}).get(\"push_token\"),\n                push_token_type=data.get(user_id, {}).get(\"push_token_type\"),\n                push_sound=data.get(user_id, {}).get(\"push_sound\"),\n                push_service=data.get(user_id, {}).get(\"push_service\"),\n                push_category=data.get(user_id, {}).get(\"push_category\"),\n                push_topic=data.get(user_id, {}).get(\"push_topic\"),\n                push_message_title=data.get(user_id, {}).get(\"push_message_title\"),\n                push_message_title_template=data.get(user_id, {}).get(\n                    \"push_message_title_template\"\n                ),\n                push_message_body=data.get(user_id, {}).get(\"push_message_body\"),\n                push_message_body_template=data.get(user_id, {}).get(\n                    \"push_message_body_template\"\n                ),\n                push_data=data.get(user_id, {}).get(\"push_data\"),\n                push_data_template=data.get(user_id, {}).get(\"push_data_template\"),\n                push_url=data.get(user_id, {}).get(\"push_url\"),\n                push_url_template=data.get(user_id, {}).get(\"push_url_template\"),\n                email_address=data.get(user_id, {}).get(\"email_address\"),\n                email_address_template=data.get(user_id, {}).get(\n                    \"email_address_template\"\n                ),\n                email_message=data.get(user_id, {}).get(\"email_message\"),\n                email_message_template=data.get(user_id, {}).", "CodeBleu_score": 23.27187410880812}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings:\n            return\n\n        data = await self._store.async_load()\n        if not data:\n            data = {}\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                data.get(user_id, {}).get(ATTR_ENABLED, True),\n                data.get(user_id, {}).get(ATTR_NOTIFIERS, []),\n            )\n            for user_id in self._users\n        }\n\n", "CodeBleu_score": 45.34124862256852}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load()\n    settings = self.user_input.get(user_id)\n    if settings is None:\n        return False\n    return await self._async_validate(settings, user_input)\n", "CodeBleu_score": 38.35173907986784}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    settings = await self.async_get_settings(user_id)\n    if not settings:\n        return False\n    return await self._async_validate(settings, user_input)\n", "CodeBleu_score": 36.484962996373206}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load()\n    settings = await self.async_get(user_id)\n    if settings is None:\n        return False\n    try:\n        return await self.hass.async_add_executor_job(\n            settings.validate, user_input[ATTR_OTP]\n        )\n    except ValueError:\n        return False\n", "CodeBleu_score": 44.82147479716344}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entity_registry.async_get(entity_id)\n    if entity is None:\n        return None\n\n    device = perm_lookup.device_registry.async_get(entity.device_id)\n    if device is None or device.area_id is None:\n        return None\n\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 63.2318721716725}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity_entry(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.get_device_entry(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.55753742398315}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = entity_entry.device_entry\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 54.50449199589082}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category in p:\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies([p[category]] + [p2[category] for p2 in policies if p2!= p])\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 59.91521036916251}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            policy[category] = _merge_policies([policy_.get(category) for policy_ in policies])\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 65.39757529182296}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for source in policies:\n        for category in source:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [src.get(category) for src in policies]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 63.555909938673615}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Failed to import auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(f\"Failed to import auth provider {provider}\") from err\n\n    if not hasattr(module, \"REQUIREMENTS\") or not module.REQUIREMENTS:\n        return module\n\n    await async_process_requirements(hass, module.REQUIREMENTS)\n    processed.add(f\"auth_provider.{provider}\")\n    return module", "CodeBleu_score": 39.53856787751802}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to import authentication provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider}: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\") or not module.REQUIREMENTS:\n        return module\n    processed = hass.data.setdefault(DATA_AUTH_PROVIDER_REQUIREMENTS, set())\n    await async_process_requirements(\n        hass, module.REQUIREMENTS, processed, \"auth provider\"\n    )\n    return module\n\n", "CodeBleu_score": 45.544517196352906}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to import authentication provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import authentication provider {provider}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    requirements = module.REQUIREMENTS\n    if not requirements:\n        return module\n\n    processed = hass.data.setdefault(DATA_PROCESSED_REQUIREMENTS, set())\n    if not processed:\n        await async_process_requirements(hass, requirements)\n    else:\n        for requirement in requirements:\n            processed.add(requirement)\n\n    return module", "CodeBleu_score": 54.210844426486815}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = {\"users\": []}\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data", "CodeBleu_score": 56.38042222988173}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), base64.b64decode(user.password)):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n", "CodeBleu_score": 39.10839305316066}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash)\n            if not bcrypt.checkpw(password.encode(), password_hash):\n                raise InvalidAuth(\"Invalid username or password\")\n            return\n    raise InvalidAuth(\"Invalid username or password\")\n", "CodeBleu_score": 41.758928495533944}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password.encode()):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    bcrypt.checkpw(b\"dummy\", dummy_hash)\n    raise InvalidAuth(\"Invalid username\")", "CodeBleu_score": 38.79573546854769}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(index)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 35.598833594105635}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.pop(self.users.index(username))\n    except ValueError:\n        raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 25.807271448837092}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(user_not_found)\n", "CodeBleu_score": 35.83773863732588}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        self._data.async_remove_auth(credentials.username)\n        await self.async_save()\n    except InvalidAuth:\n        pass\n", "CodeBleu_score": 48.217831300937384}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n\n    try:\n        self._data.async_remove_auth(credentials.username)\n    except KeyError:\n        pass\n\n    await self.async_save()\n", "CodeBleu_score": 52.17458864311189}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        await self._store.async_remove_auth(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass\n", "CodeBleu_score": 47.63564049531686}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 57.98861344294033}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive:\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        join_timeout = timeout / len(threads)\n        thread.join(join_timeout)\n        if thread.is_alive:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 58.45178043601527}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        thread.join(timeout)\n        if thread.is_alive():\n            async_raise(thread.ident, SystemExit)\n        joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 55.27430322562276}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    remaining_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()\n    ]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(remaining_threads)\n    # Attempt to join each thread within the calculated timeout\n    for thread in remaining_threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}: {e}\")", "CodeBleu_score": 46.54998280424728}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    non_main_non_daemon_alive_threads = [\n        thread\n        for thread in threading.enumerate()\n        if not thread.is_daemon()\n        and thread is not threading.main_thread()\n        and thread.is_alive()\n    ]\n\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(non_main_non_daemon_alive_threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in non_main_non_daemon_alive_threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                f\"Failed to join thread {thread.name} within the timeout of {timeout} seconds\"\n            )", "CodeBleu_score": 37.968416528438794}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()\n    ]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception:\n            _LOGGER.warning(f\"Failed to join thread {thread.name} within the timeout of {timeout} seconds\")\n\n", "CodeBleu_score": 41.32254477253861}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_setups_with_setup_started:\n        self._remaining_setups_with_setup_started = remaining_with_setup_started\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_setups_with_setup_started = bool(remaining_with_setup_started)\n\n", "CodeBleu_score": 40.99744357355563}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self.async_send_signal(\n            signal_name=self._async_dispatcher_signal_name,\n            signal_data=remaining_with_setup_started,\n        )\n    else:\n        self._remaining_with_setup_started = None\n\n", "CodeBleu_score": 39.58904076000978}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_setups or self._previous_state:\n        self.hass.async_create_task(\n            self._async_dispatcher_send_internal(remaining_with_setup_started)\n        )\n    self._remaining_setups = False\n    self._previous_state = False\n\n", "CodeBleu_score": 40.693038996168255}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    validate_content = generate_and_validate(integrations)\n    config.cache.store(\"bluetooth\", validate_content)\n\n    if config.is_fixing:\n        return\n\n    if config.cache.get(\"bluetooth\")!= validate_content:\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            fixable=True,\n            fixer=lambda: generate_and_validate(integrations),\n        )", "CodeBleu_score": 35.52437448053359}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.options.validate_config:\n        return\n\n    generate_and_validate(integrations)\n\n    try:\n        with open(config.config_dir / \"bluetooth.py\") as fp:\n            if fp.read() == config.config.get(\"BLUETOOTH\"):\n                return\n    except FileNotFoundError:\n        pass\n\n    config.add_error(\n        {\n            \"domain\": \"bluetooth\",\n            \"message\": \"The generated bluetooth.py file is not up to date.\",\n            \"fixable\": True,\n            \"suggestion\": \"Run `hassfest validate --config-dir /path/to/config/dir` to update the file.\",\n        }\n    )\n\n", "CodeBleu_score": 38.37455570256563}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    generated = generate_and_validate(integrations)\n\n    if config.cache.bluetooth_py_content is None:\n        config.cache.bluetooth_py_content = generated\n    elif generated!= config.cache.bluetooth_py_content:\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            fixable=True,\n            fix_message=\"Run'scripts/gen_bluetooth.py'\",\n        )", "CodeBleu_score": 33.32140776965067}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}{}\n\te := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.API.TokenURL)\n\tif e!= nil {\n\t\tlogger.Info(\"refreshToken\", zap.Error(e))\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 65.60827975857396}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tScope       string `json:\"scope\"`\n\t}\n\tvar e error\n\t_, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif e!= nil {\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\td.TokenType = resp.TokenType\n\td.ExpiresIn = resp.ExpiresIn\n\td.Scope = resp.Scope\n\tlogger.Info(\"refresh token success\", zap.String(\"access_token\", d.AccessToken))\n\treturn nil\n}", "CodeBleu_score": 62.81302337808889}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}{}\n\te := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(tokenEndpoint).Error()\n\tif e!= nil {\n\t\tlogger.Info(e.Error())\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 58.66320492834407}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.restyClient.R()\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetQueryParam(\"corpora\", \"allDrives\")\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif res.StatusCode()!= 200 {\n\t\treturn nil, fmt.Errorf(\"failed to execute request, status code: %d, body: %s\", res.StatusCode(), res.Body())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 64.38655451475178}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R().\n\t\tSetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken)).\n\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\").\n\t\tSetQueryParam(\"includeItemsFromAllDrives\", \"true\").\n\t\tSetError(new(GoogleDriveError)).\n\t\tSetResult(resp)\n\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif res.IsError() {\n\t\tif res.StatusCode() == 401 {\n\t\t\tif err := d.refreshToken(); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\n\t\terr := res.Error().(*GoogleDriveError)\n\t\treturn nil, fmt.Errorf(\"failed to make request to %s: %s\", url, err.Error)\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 61.259137431048075}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R().\n\t\tSetHeader(\"Authorization\", \"Bearer \"+d.accessToken).\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\").\n\t\tSetQueryParam(\"includeItemsFromAllDrives\", \"true\").\n\t\tSetQueryParam(\"corpora\", \"allDrives\")\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\terr := d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif res.StatusCode()!= 200 {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d, body: %s\", res.StatusCode(), res.Body())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 64.10327305803662}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 5 * 1024 * 1024 // 5 MB\n\ttotalSize := stream.GetSize()\n\tfinish := int64(0)\n\tfor finish < totalSize {\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif finish+chunkSize > totalSize {\n\t\t\tchunkSize = totalSize - finish\n\t\t}\n\t\treq := d.request.Post(url).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tresp, err := req.Context(ctx).End()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode!= 200 {\n\t\t\treturn errors.New(resp.Status)\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 57.41807747944057}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(25 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request(ctx).Post(url).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tresp, err := req.EndStruct(nil)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode!= http.StatusOK {\n\t\t\treturn errors.New(\"failed to upload file\")\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 60.35233790623211}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(5 * 1024 * 1024)\n\tif stream.GetSize() < chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\tfinish := int64(0)\n\tfor finish < stream.GetSize() {\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request(ctx, \"PATCH\", url).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tresp, err := req.Send()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode!= 308 {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t\t}\n\t\tfinish += chunkSize\n\t\tchunkSize = int64(5 * 1024 * 1024)\n\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 60.97724253216563}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn common_err.ClientError(err.Error())\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn common_err.ClientError(\"mount point is empty\")\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err!= nil {\n\t\treturn common_err.ServiceError(err.Error())\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err!= nil {\n\t\treturn common_err.ServiceError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 37.070924293343936}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err!= nil {\n\t\treturn common_err.ClientError(err)\n\t}\n\n\t// Check if the mount point is empty\n\tif data.MountPoint == \"\" {\n\t\treturn common_err.ClientError(errors.New(\"mount point is empty\"))\n\t}\n\n\t// Unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err!= nil {\n\t\treturn common_err.ServiceError(err)\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(strings.ReplaceAll(data.MountPoint, \"/\", \"_\")); err!= nil {\n\t\treturn common_err.ServiceError(err)\n\t}\n\n\t// Return success response\n\treturn ctx.JSON(http.StatusOK, common_err.SuccessResponse(\"storage unmounted successfully\"))\n}", "CodeBleu_score": 38.88144569663955}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err!= nil {\n\t\treturn common_err.ClientError(ctx, err)\n\t}\n\n\t// Validate mount point\n\tif data.MountPoint == \"\" {\n\t\treturn common_err.ClientError(ctx, errors.New(\"mount point is empty\"))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err!= nil {\n\t\treturn common_err.ServiceError(ctx, err)\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(strings.ReplaceAll(data.MountPoint, \"/\", \"\")); err!= nil {\n\t\treturn common_err.ServiceError(ctx, err)\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Storage unmounted successfully\"})\n}", "CodeBleu_score": 42.304034355551835}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.575179573536964}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"File path is missing\"))\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(\"File not found\"))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 34.495678311619976}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingFilePath))\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.60786562767268}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message[\"message\"]); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"success\"))\n}", "CodeBleu_score": 60.47615262136252}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Notification sent\")\n}", "CodeBleu_score": 51.89317153378935}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParam, err.Error()))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess, \"success\"))\n}", "CodeBleu_score": 58.843499128537324}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running.\n\tgo service.SendMeg()\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\n\", msg)\n\t}\n\t// Close the WebSocket connection.\n\tws.Close()\n\treturn nil\n}", "CodeBleu_score": 41.47209187284276}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tc := &connection{send: make(chan []byte, 256), ws: ws}\n\th.register <- c\n\tdefer func() { h.unregister <- c }()\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Message Type: %v\n\", message)\n\t\tfmt.Printf(\"Message: %s\n\", message)\n\t\tfmt.Printf(\"Error: %v\n\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.61735571769716}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running.\n\tif!running {\n\t\trunning = true\n\t\tgo service.SendMeg()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Println(\"Received message:\", msgType, string(msg), err)\n\t}\n\n\t// Close the WebSocket connection.\n\tws.Close()\n\treturn nil\n}", "CodeBleu_score": 45.209678607953784}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar drive = \"\"\n\tvar arch = runtime.GOARCH\n\tvar cpuInfo = \"\"\n\tvar err error\n\n\tif arch == \"amd64\" {\n\t\tdrive = \"x86_64\"\n\t} else if arch == \"386\" {\n\t\tdrive = \"x86\"\n\t} else if arch == \"arm\" {\n\t\tdrive = \"arm\"\n\t} else if arch == \"arm64\" {\n\t\tdrive = \"arm64\"\n\t}\n\n\tif cpuInfo, err = GetCpuInfo(); err!= nil {\n\t\tcpuInfo = \"\"\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"msg\":       common_err.GetMsg(common_err.Success),\n\t\t\"drive\":     drive,\n\t\t\"cpu_info\":  cpuInfo,\n\t\t\"cpu_count\": runtime.NumCPU(),\n\t})\n}", "CodeBleu_score": 25.012363727094943}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar cpuInfo *service.CpuInfo\n\tvar err error\n\tvar msg string\n\tvar driveModel string\n\tvar arch string\n\n\tdriveModel, err = service.GetDriveModel()\n\tif err!= nil {\n\t\tmsg = \"Error getting drive model: \" + err.Error()\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(msg))\n\t}\n\n\tarch, err = service.GetArch()\n\tif err!= nil {\n\t\tmsg = \"Error getting architecture: \" + err.Error()\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(msg))\n\t}\n\n\tcpuInfo, err = service.GetCpuInfo()\n\tif err!= nil {\n\t\tmsg = \"Error getting CPU info: \" + err.Error()\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(msg))\n\t}\n\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"CPU information not available\"))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"driveModel\": driveModel,\n\t\t\"arch\":       arch,\n\t\t\"cpuInfo\":    cpuInfo,\n\t})\n}", "CodeBleu_score": 28.091643952829592}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar err error\n\n\t// Get drive model and architecture.\n\tdriveModel, driveArch := common_err.GetDriveModelAndArch()\n\n\t// Get CPU information.\n\tcpuInfo := service.MyService.System().GetCpuInfo()\n\n\t// Check if CPU information is available.\n\tif len(cpuInfo) == 0 {\n\t\t// If not, return \"nil\".\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(err, \"nil\"))\n\t}\n\n\t// If CPU information is available, return the data with a success message.\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(err, map[string]interface{}{\n\t\t\"driveModel\": driveModel,\n\t\t\"driveArch\":  driveArch,\n\t\t\"cpuInfo\":    cpuInfo,\n\t}))\n}", "CodeBleu_score": 31.58621088523767}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(s.client)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tvar running, notRunning []string\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 78.48561525281998}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tvar running, notRunning []string\n\tfor _, service := range services {\n\t\tif service.SubState == \"running\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 78.66808539578012}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := &[]string{}\n\tnotRunning := &[]string{}\n\n\tfor _, service := range services {\n\t\tif service.SubState == \"running\" {\n\t\t\t*running = append(*running, service.Name)\n\t\t} else {\n\t\t\t*notRunning = append(*notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  running,\n\t\tfalse: notRunning,\n\t}, nil\n}", "CodeBleu_score": 58.703973881798376}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message values to JSON strings\n\tmessageJSON := make(map[string]string)\n\tfor k, v := range message {\n\t\tb, err := json.Marshal(v)\n\t\tif err!= nil {\n\t\t\ti.logger.Error(\"Failed to marshal message value\", zap.String(\"key\", k), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tmessageJSON[k] = string(b)\n\t}\n\n\t// Publish the event to the message bus\n\tctx := context.Background()\n\tresponse, err := i.MyService.MessageBus().PublishEventWithResponse(ctx, name, messageJSON)\n\tif err!= nil {\n\t\ti.logger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response status code if it is not OK\n\tif response.StatusCode!= http.StatusOK {\n\t\ti.logger.Error(\"Event response status code is not OK\", zap.String(\"name\", name), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 53.10754297690467}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\ti.logger.Error(\"Failed to marshal message\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse := i.messageBus.PublishEventWithResponse(context.Background(), name, jsonMessage)\n\tif response.StatusCode!= http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.String(\"response\", response.Status))\n\t}\n}", "CodeBleu_score": 38.573779383735435}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\ti.logger.Error(\"failed to serialize message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := i.MyService.MessageBus().PublishEventWithResponse(context.Background(), \"notify\", name, jsonMessage)\n\tif err!= nil {\n\t\ti.logger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log any errors that occur during publishing.\n\tif response.StatusCode!= http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\", zap.Int(\"status_code\", response.StatusCode), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 42.98047956308723}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\taddress, err := c.external.GetMessageBusAddress()\n\tif err!= nil {\n\t\tclient.SetServer(err.Error())\n\t} else {\n\t\tclient.SetServer(address)\n\t}\n\treturn client\n}", "CodeBleu_score": 26.983136536177167}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tif address, err := c.external.GetMessageBusAddress(); err == nil {\n\t\tclient.SetServer(address)\n\t} else {\n\t\tclient.SetServer(err.Error())\n\t}\n\treturn client\n}", "CodeBleu_score": 27.064493571361066}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\taddress, err := c.GetMessageBusAddress()\n\tif err!= nil {\n\t\tclient.Server = err.Error()\n\t} else {\n\t\tclient.Server = address\n\t}\n\treturn client\n}", "CodeBleu_score": 32.07930786837008}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.60912513305412}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.HasPrefix(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.54829618234008}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.60912513305412}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define paths for the modules directory and the entry file\n\tmodulesDir := filepath.Join(c.config.ModulesDir, \"system\", \"entry\")\n\tentryFile := filepath.Join(c.config.ModulesDir, \"system\", \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\tif err := os.WriteFile(entryFile, []byte(\"[]\"), 0644); err!= nil {\n\t\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tfiles, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read module directory\", zap.Error(err))\n\t}\n\n\tvar entries []byte\n\tfor _, f := range files {\n\t\t// Read the entry.json file\n\t\tentry, err := os.ReadFile(filepath.Join(modulesDir, f.Name(), \"entry.json\"))\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t}\n\n\t\t// Concatenate the entry.json content into a single JSON array\n\t\tentries = append(entries, entry...)\n\t\tentries = append(entries, []byte(\",\")...)\n\t}\n\n\t// Remove the trailing comma from the entries\n\tentries = entries[:len(entries)-1]\n\n\t// Write the concatenated entries to the entry file path\n\tif err := os.WriteFile(entryFile, entries, 0644); err!= nil {\n\t\tlogger.Error(\"Failed to write entries to entry file\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 49.24661368639222}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define paths for the modules directory and the entry file\n\tmodulesPath := filepath.Join(c.config.ModulesPath, \"system\", \"entry.json\")\n\tentryPath := filepath.Join(c.config.ModulesPath, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\tif err := os.Create(entryPath); err!= nil {\n\t\t\tc.logger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tfiles, err := os.ReadDir(modulesPath)\n\tif err!= nil {\n\t\tc.logger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Concatenate the content of each entry.json file into a single JSON array\n\tvar entries []string\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tentryPath := filepath.Join(modulesPath, file.Name(), \"entry.json\")\n\t\t\tcontent, err := os.ReadFile(entryPath)\n\t\t\tif err!= nil {\n\t\t\t\tc.logger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tentries = append(entries, string(content))\n\t\t}\n\t}\n\n\t// Write the concatenated JSON array to the entry file path\n\tentry := \"[\" + strings.Join(entries, \",\") + \"]\"\n\tif err := os.WriteFile(entryPath, []byte(entry), 0644); err!= nil {\n\t\tc.logger.Error(\"Failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\tc.logger.Info(\"Successfully generated system entry\")\n}", "CodeBleu_score": 43.75254104081981}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.ModulesPath, \"modules\")\n\tentryPath := filepath.Join(modulesPath, \"entry.json\")\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\tos.Create(entryPath)\n\t}\n\tfiles, err := os.ReadDir(modulesPath)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\tvar entries []map[string]interface{}\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tentryPath := filepath.Join(modulesPath, file.Name(), \"entry.json\")\n\t\t\tdata, err := os.ReadFile(entryPath)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"failed to read entry file\", zap.String(\"path\", entryPath), zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar entry map[string]interface{}\n\t\t\terr = json.Unmarshal(data, &entry)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"failed to unmarshal entry file\", zap.String(\"path\", entryPath), zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tentries = append(entries, entry)\n\t\t}\n\t}\n\tdata, err := json.Marshal(entries)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to marshal entries\", zap.Error(err))\n\t\treturn\n\t}\n\terr = os.WriteFile(entryPath, data, 0644)\n\tif err!= nil {\n\t\tlogger.Error(\"failed to write entry file\", zap.String(\"path\", entryPath), zap.Error(err))\n\t}\n}", "CodeBleu_score": 49.223813004352415}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagUp!= 0 {\n\t\t\tif addrs, err := iface.Addrs(); err == nil {\n\t\t\t\tfor _, addr := range addrs {\n\t\t\t\t\tvar ip net.IP\n\t\t\t\t\tswitch v := addr.(type) {\n\t\t\t\t\tcase *net.IPNet:\n\t\t\t\t\t\tip = v.IP\n\t\t\t\t\tcase *net.IPAddr:\n\t\t\t\t\t\tip = v.IP\n\t\t\t\t\t}\n\t\t\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tip = ip.To4()\n\t\t\t\t\tif ip == nil {\n\t\t\t\t\t\tcontinue // not an ipv4 address\n\t\t\t\t\t}\n\t\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"are you connected to the network?\")\n}", "CodeBleu_score": 55.167906182606075}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tnetworks, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, network := range networks {\n\t\t\tif iface.Name == network {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 60.64781034848211}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.NetworkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 60.06156833236358}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc;\n\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\tpRequest->pAppInfo = pTscObj->pAppInfo;\n\t\trc = updateAppRequestSummary(pRequest, 1);\n\t\tif (rc!= TSDB_CODE_SUCCESS) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = atomic_add_fetch_32(&pTscObj->reqCount, 1);\n\tif (rc < 0) {\n\t\treturn TSDB_CODE_INTERNAL_ERROR;\n\t}\n\n\tpRequest->pTscObj = pTscObj;\n\n\tif (pTscObj->pLogger!= NULL) {\n\t\tlogDebug(pTscObj->pLogger, \"register request %p, pTscObj %p, reqCount %d\", pRequest, pTscObj, pTscObj->reqCount);\n\t}\n\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 44.145471345998025}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\t// Add a reference to the request object.\n\ttaosAddRef(pRequest);\n\n\t// Add the request to the TSC object.\n\tif (atomic_add_fetch_32(&pTscObj->requestCount, 1) == 0) {\n\t\t// The first request.\n\t\tpTscObj->pFirstRequest = pRequest;\n\t} else {\n\t\t// Not the first request.\n\t\tpTscObj->pLastRequest->pNext = pRequest;\n\t}\n\n\tpTscObj->pLastRequest = pRequest;\n\n\t// Update the application request count.\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\tpTscObj->pAppInfo->requestCount++;\n\t\tpTscObj->pAppInfo->currentRequestCount++;\n\t}\n\n\t// Log the new request.\n\ttscDebug(pTscObj, \"New request: %s\", pRequest->statement);\n\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 32.85059402641814}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tSSchemaObj *pSchema;\n\tchar *pDbName;\n\n\tif (pRequest->pSchema!= NULL) {\n\t\tpSchema = pRequest->pSchema;\n\t\tpDbName = pSchema->name;\n\t\tif (pDbName!= NULL && strcmp(pDbName, exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (pRequest->pSchemaList!= NULL) {\n\t\tpSchema = pRequest->pSchemaList;\n\t\twhile (pSchema!= NULL) {\n\t\t\tpDbName = pSchema->name;\n\t\t\tif (pDbName!= NULL && strcmp(pDbName, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tpSchema = pSchema->next;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 40.06456628576519}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->db!= NULL && strcmp(pRequest->db, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tSRequestDb *pDb = pRequest->pDbList;\n\twhile (pDb!= NULL) {\n\t\tchar *p = strchr(pDb->db, '.');\n\t\tif (p!= NULL) {\n\t\t\tp++;\n\t\t} else {\n\t\t\tp = pDb->db;\n\t\t}\n\n\t\tif (strcmp(p, exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tpDb = pDb->next;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 45.23557154426668}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->primaryDb!= NULL && strcmp(pRequest->primaryDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->dbList!= NULL) {\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->dbList->size; i++) {\n\t\t\tchar *db = (char *) taosArrayGet(pRequest->dbList, i);\n\t\t\tif (db!= NULL && strcmp(db, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 50.90087005258099}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif ((code == RPC_NEED_REDIRECT) && (msgType!= TMSG_RPC_REQUEST_NO_RESP) && (msgType!= TMSG_RPC_REQUEST) && (msgType!= TMSG_RPC_REQUEST_NO_RESP_NO_RETRY)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 35.462010335427394}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == ERR_NEED_REDIRECT) {\n\t\tswitch (msgType) {\n\t\t\tcase TMSG_RPC_REQUEST:\n\t\t\tcase TMSG_RPC_REQUEST_NO_RESP:\n\t\t\tcase TMSG_RPC_REQUEST_RESP:\n\t\t\tcase TMSG_RPC_REQUEST_RESP_NO_RESP:\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.82243307891367}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\treturn (code == RPC_NEED_REDIRECT_ERROR && msgType!= tmsg_t::RPC_REQUEST && msgType!= tmsg_t::RPC_REQUEST_REPLY && msgType!= tmsg_t::RPC_REQUEST_ERROR);\n}", "CodeBleu_score": 27.170543373317045}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pHashObj = NULL;\n\tSRequest *pRequest = NULL;\n\tint64_t rid;\n\tint32_t rc;\n\n\tif (pRequests == NULL) return;\n\n\tpHashObj = pRequests->pFirst;\n\twhile (pHashObj!= NULL) {\n\t\trid = *(int64_t *)pHashObj->pKey;\n\t\tpRequest = (SRequest *)pHashObj->pValue;\n\n\t\tif (pRequest!= NULL) {\n\t\t\trc = acquireRequest(rid);\n\t\t\tif (rc == TSDB_CODE_SUCCESS) {\n\t\t\t\tif (pRequest->query!= NULL) {\n\t\t\t\t\ttaos_stop_query(pRequest->query);\n\t\t\t\t}\n\t\t\t\treleaseRequest(rid);\n\t\t\t}\n\t\t}\n\n\t\tpHashObj = pHashObj->pNext;\n\t}\n}", "CodeBleu_score": 38.443840492912074}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) return;\n\n\tint64_t rid;\n\tSRequest *pRequest;\n\ttaosHashForeach(pRequests, rid, pRequest) {\n\t\tif (acquireRequest(rid, pRequest) == TSDB_CODE_SUCCESS) {\n\t\t\tif (pRequest->pQuery!= NULL) {\n\t\t\t\ttaos_stop_query(pRequest->pQuery);\n\t\t\t}\n\t\t\treleaseRequest(rid);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.87846062474971}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) return;\n\n\tfor (int i = 0; i < pRequests->capacity; i++) {\n\t\tSHashNode *pNode = pRequests->table[i];\n\t\twhile (pNode!= NULL) {\n\t\t\tSRequest *pRequest = (SRequest *)pNode->data;\n\t\t\tif (pRequest!= NULL) {\n\t\t\t\tint64_t rid = pRequest->rid;\n\t\t\t\tif (acquireRequest(rid) == TAOS_SUCCESS) {\n\t\t\t\t\tif (pRequest->pQuery!= NULL) {\n\t\t\t\t\t\ttaos_stop_query(pRequest->pQuery);\n\t\t\t\t\t}\n\t\t\t\t\treleaseRequest(rid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpNode = pNode->next;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.31851305209325}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&tscClientStop, 0, 1)) {\n\t\twhile (tscClientStop) {\n\t\t\ttscMsleep(10);\n\t\t}\n\t} else {\n\t\ttscDebug(\"Crash report thread is already stopped.\");\n\t}\n}", "CodeBleu_score": 54.22137279799436}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (!atomic_val_compare_exchange_32(&tscClientStop, 0, 1)) {\n\t\ttscDebug(\"tscStopCrashReport: Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&tscClientStop)!= 0) {\n\t\ttaosMsleep(100);\n\t}\n}", "CodeBleu_score": 74.6346525056119}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&tscClientStop, 0, 1)) {\n\t\twhile (tscClientStop) {\n\t\t\ttaosMsleep(100);\n\t\t}\n\t} else {\n\t\ttaosLogInfo(NULL, \"tscStopCrashReport\", \"Crash report thread is already stopped\");\n\t}\n}", "CodeBleu_score": 53.93751593583175}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3CallbackData *data = (S3CallbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 77.087868488297}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3CallbackData *data = (S3CallbackData *) callbackData;\n\tdata->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}", "CodeBleu_score": 50.03661528172263}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\t//printf(\"responsePropertiesCallback\n\");\n\t//printf(\"properties->contentLength = %s\n\", properties->contentLength);\n\tif (properties->contentLength && (atoi(properties->contentLength) > 0)) {\n\t\t((CallbackData *)callbackData)->contentLength = atoi(properties->contentLength);\n\t} else {\n\t\t((CallbackData *)callbackData)->contentLength = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 56.73439685706393}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n  if (taosMulMkDir(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --no-detach --port=%d --config=%srsync.conf\", tsCheckpointBackupPort,\n           tsCheckpointBackupDir);\n  uDebug(\"[rsync] start rsync server, cmd:%s\", cmd);\n  int ret = system(cmd);\n  if (ret < 0) {\n    uError(\"[rsync] start rsync server error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server success, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 60.96293585227528}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n  if (taosMulMkDir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupConf) < 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupConf, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --no-detach --port=%d --config=%s\", tsCheckpointBackupPort, tsCheckpointBackupConf);\n  uDebug(\"[rsync] start cmd:%s\", cmd);\n  int ret = system(cmd);\n  if (ret < 0) {\n    uError(\"[rsync] start error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start success, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 61.030926354714744}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#else\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#endif\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%s/rsyncd.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir)!= 0) return;\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --no-detach --port %d --config %s\", tsCheckpointBackupPort, confDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret!= 0) {\n    uError(\"[rsync] start rsync server error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n    return;\n  }\n  uInfo(\"[rsync] start rsync server success, cmd:%s\", cmd);\n}", "CodeBleu_score": 60.143120931853346}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).getExecutor().shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n}", "CodeBleu_score": 48.193756632363474}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).getExecutor().shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered.\");\n\t}\n}", "CodeBleu_score": 49.43148784763222}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t// get the dispatcher\n\tDispatcher dispatcher = getDispatcher(dispatcherId);\n\t// remove the dispatcher from the collection\n\tdispatchers.remove(dispatcherId);\n\t// shutdown the dispatcher\n\tdispatcher.shutdownNow();\n}", "CodeBleu_score": 29.812809994938185}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        Map<TbActorId, TbActor> children = actorRegistry.getChildren(parent);\n//        if (children!= null) {\n//            children.keySet().stream().filter(childFilter).forEach(child -> {\n//                TbActor childActor = actorRegistry.getActor(child);\n//                if (childActor!= null) {\n//                    tell(child, msg, highPriority);\n//                } else {\n//                    log.warn(\"Child actor not found: {}\", child);\n//                }\n//            });\n//        }\n//    }", "CodeBleu_score": 13.361017427649136}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        TbActorId parent = getActorId();\n        Map<TbActorId, TbActor> children = getChildren(parent);\n        if (children == null) {\n            log.warn(\"No children for parent: \" + parent);\n            return;\n        }\n        children.keySet().stream().filter(childFilter).forEach(child -> {\n            if (child!= null) {\n                tell(child, msg, highPriority);\n            } else {\n                log.warn(\"Child is null\");\n            }\n        });\n    }", "CodeBleu_score": 51.81145640493142}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t", "CodeBleu_score": 13.361017427649136}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (ready.get()!= DESTROYED) {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttryProcessQueue(true);\n\t} else if (msg.getMsgType() == TbActorMsg.MsgType.RULE_NODE_UPDATED_MSG) {\n\t\tlog.trace(\"[{}] Actor is destroyed, try reinitialize\", selfId);\n\t\tif (ready.compareAndSet(DESTROYED, INIT)) {\n\t\t\ttryInit(0);\n\t\t}\n\t} else {\n\t\tmsg.notifyActorStopped();\n\t}\n}", "CodeBleu_score": 48.858554611545024}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (ready.get()!= DESTROYED) {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttryProcessQueue(true);\n\t} else if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n\t\ttryInit(0);\n\t} else {\n\t\tmsg.onTbActorStopped();\n\t}\n}", "CodeBleu_score": 43.59478350778376}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (destroyInProgress.get() && msg.getMsgType()!= TbActorMsg.MsgType.RULE_NODE_UPDATED_MSG) {\n\t\tmsg.onTbActorStopped();\n\t\treturn;\n\t}\n\tif (highPriority) {\n\t\thighPriorityMsgs.add(msg);\n\t} else {\n\t\tnormalPriorityMsgs.add(msg);\n\t}\n\ttryProcessQueue(true);\n}", "CodeBleu_score": 38.62515658136131}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\tnt processed = 0;\n\twhile (processed < throughput) {\n\t\tTbActorMessage<?> msg = null;\n\t\ttry {\n\t\t\tif (!highPriorityMsgs.isEmpty()) {\n\t\t\t\tmsg = highPriorityMsgs.poll();\n\t\t\t} else if (!normalPriorityMsgs.isEmpty()) {\n\t\t\t\tmsg = normalPriorityMsgs.poll();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (msg!= null) {\n\t\t\t\tprocessed++;\n\t\t\t\ttry {\n\t\t\t\t\tactor.process(msg);\n\t\t\t\t} catch (InitializationFailureException e) {\n\t\t\t\t\tstopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n\t\t\t\t\tdestroy(e);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tlog.warn(\"[{}] Failed to process message: {}\", selfId, e);\n\t\t\t\t\tactor.onProcessFailure(msg, e);\n\t\t\t\t\tif (actor.isStop(e)) {\n\t\t\t\t\t\tstopReason = TbActorStopReason.PROCESS_FAILURE;\n\t\t\t\t\t\tdestroy(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tlog.warn(\"[{}] Failed to process message: {}\", selfId, e);\n\t\t\tactor.onProcessFailure(msg, e);\n\t\t\tif (actor.isStop(e)) {\n\t\t\t\tstopReason = TbActorStopReason.PROCESS_FAILURE;\n\t\t\t\tdestroy(e);\n\t\t\t}\n\t\t}\n\t}\n\tif (processed > 0) {\n\t\tbusy.set(FREE);\n\t\ttryProcessQueue(false);\n\t} else {\n\t\tlog.trace(\"[{}] Mailbox is empty\", selfId);\n\t}\n}", "CodeBleu_score": 41.5769006043665}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\t// If the tenant ID corresponds to the system tenant, it always returns true.\n\tif (tenantId.isSysTenantId()) {\n\t\treturn true;\n\t}\n\t// It retrieves the tenant's profile; if not found and ignoring missing tenants is allowed, it returns true, otherwise, it throws a TenantProfileNotFoundException.\n\tTenantProfile profile = profileService.getProfile(tenantId);\n\tif (profile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t\t}\n\t}\n\t// It fetches the rate limit configuration from the tenant profile and checks the rate limit.\n\tRateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\n\tif (rateLimitConfiguration == null) {\n\t\treturn true;\n\t}\n\tRateLimit limit = rateLimitConfiguration.getLimit(api, level);\n\tif (limit == null) {\n\t\treturn true;\n\t}\n\t// If the rate limit is exceeded, it processes a rate limit notification.\n\tif (!rateLimiter.checkRateLimit(tenantId, limit)) {\n\t\tprocessRateLimitNotification(tenantId, api, level);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.9226568512646}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\t// Retrieve the tenant's profile\n\tProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId);\n\tif (profileConfiguration == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\n\t// Fetch the rate limit configuration from the tenant profile\n\tRateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n\tif (rateLimitConfiguration == null) {\n\t\treturn true;\n\t}\n\n\t// Check the rate limit\n\tRateLimit rateLimit = rateLimitConfiguration.getRateLimit(api, level);\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\n\t// Process a rate limit notification\n\tif (!rateLimit.check()) {\n\t\tprocessRateLimitNotification(tenantId, api, level);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 38.25150739294168}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tfor (Iterator<Map.Entry<String, DtlsSession>> it = sessions.entrySet().iterator(); it.hasNext();) {\n\t\tMap.Entry<String, DtlsSession> entry = it.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlogger.trace(\"Removing DTLS session for client {} due to inactivity\", entry.getKey());\n\t\t\tit.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 37.427791766902374}, {"code": "public void evictTimeoutSessions(){\n\t\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlog.trace(\"Removed DTLS session for peer \" + entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 46.989837668642885}, {"code": "public void evictTimeoutSessions(){\n\t\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlogger.trace(\"Removing session for \" + entry.getKey() + \" due to inactivity\");\n\t\t\tsessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 46.66251522015771}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tList<KvEntry> kvEntries = values.stream()\n\t\t\t\t.map(value -> parseValue(key, value))\n\t\t\t\t.collect(Collectors.toList());\n\t\ttsKvEntries.add(new TsKvEntry(key, kvEntries));\n\t}\n\treturn tsKvEntries;\n}", "CodeBleu_score": 41.0458654828869}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries!= null &&!timeseries.isEmpty()) {\n\t\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\t\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tList<JsonNode> values = entry.getValue();\n\t\t\tList<KvEntry> kvEntries = new ArrayList<>();\n\t\t\tfor (JsonNode value : values) {\n\t\t\t\tkvEntries.add(parseValue(key, value));\n\t\t\t}\n\t\t\ttsKvEntries.add(new TsKvEntry(key, kvEntries));\n\t\t}\n\t\treturn tsKvEntries;\n\t}\n\treturn Collections.emptyList();\n}", "CodeBleu_score": 34.37004010540979}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>(timeseries.size());\n\ttimeseries.forEach((key, value) -> {\n\t\tList<KvEntry> entries = value.stream().map(v -> parseValue(key, v)).collect(Collectors.toList());\n\t\tresult.add(new TsKvEntry(key, entries));\n\t});\n\treturn result;\n}", "CodeBleu_score": 44.450491337973574}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> reqMap = new HashMap<>();\n\treqMap.put(\"refreshToken\", this.refreshToken);\n\tResponseEntity<JsonNode> response = postForEntity(this.authEndpoint, reqMap, JsonNode.class);\n\tsetTokenInfo(System.currentTimeMillis(), response.getBody());\n}", "CodeBleu_score": 42.78544452635472}, {"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<>();\n\trequest.put(\"refreshToken\", refreshToken);\n\tResponseEntity<JsonNode> response = restTemplate.postForEntity(authEndpoint, request, JsonNode.class);\n\tsetTokenInfo(System.currentTimeMillis(), response.getBody());\n}", "CodeBleu_score": 46.739066972037676}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", refreshToken);\n\tResponseEntity<JsonNode> response = restTemplate.postForEntity(authEndpoint, requestMap, JsonNode.class);\n\tsetTokenInfo(System.currentTimeMillis(), response.getBody());\n}", "CodeBleu_score": 46.63804942443503}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", this.username);\n\tloginRequest.put(\"password\", );\n\tResponseEntity<JsonNode> response = restTemplate.postForEntity(this.authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n\tsetTokenInfo(ts, response.getBody());\n}", "CodeBleu_score": 73.55861332586129}, {"code": " private void doLogin(){\n\t//        log.info(\"Performing login operation...\");\n        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", );\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 84.68513332313587}, {"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, Object> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\tResponseEntity<JsonNode> response = restTemplate.postForEntity(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n\tJsonNode tokenInfo = response.getBody();\n\tsetTokenInfo(ts, tokenInfo);\n}", "CodeBleu_score": 78.52692885214574}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn Optional.ofNullable(restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId())\n\t\t\t.getBody());\n}", "CodeBleu_score": 13.078593548736455}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 62.77797130829504}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(deviceUrl + \"/\" + deviceId.getId(), Device.class);\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 62.01875338590024}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(\n\t\t\t\tbaseUrl + \"/api/device-with-credentials\",\n\t\t\t\tHttpMethod.POST,\n\t\t\t\tnew HttpEntity<>(new DeviceWithCredentials(device, credentials)),\n\t\t\t\tDevice.class);\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpStatusCodeException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 59.99037595754644}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn ofNullable(postForEntity(apiUrl + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class))\n\t\t.map(ResponseEntity::getBody)\n\t\t.map(Optional::ofNullable)\n\t\t.orElse(empty());\n}", "CodeBleu_score": 18.657443573209225}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\t// create the request object\n\tRequestEntity<Object> request = RequestEntity.post(URI.create(baseUrl + \"/api/device-with-credentials\"))\n\t\t\t.contentType(MediaType.APPLICATION_JSON)\n\t\t\t.body(new DeviceWithCredentials(device, credentials));\n\t// send the request and get the response\n\tResponseEntity<Device> response = restTemplate.exchange(request, Device.class);\n\t// check the status code\n\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\treturn Optional.empty();\n\t} else if (response.getStatusCode()!= HttpStatus.OK) {\n\t\tthrow new RuntimeException(\"Error saving device: \" + response.getStatusCode());\n\t}\n\t// return the saved device\n\treturn Optional.ofNullable(response.getBody());\n}", "CodeBleu_score": 54.27563955966688}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t\nif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.25413551466566}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tval = addr;\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 95.67310060368143}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\n  bound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\n  if (this[key] && typeof this[key] === \"function\") {\n    bound[key] = this[key].bind(this, addr);\n  }\n});\nreturn bound;\n}", "CodeBleu_score": 97.50366938393864}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tconst resolve = (promise, resolve, reject) => {\n\t\ttry {\n\t\t\tresolve(promise)\n\t\t} catch (e) {\n\t\t\treject(e)\n\t\t}\n\t}\n\tconst resolveAll = (promises, resolve, reject) => {\n\t\tPromise.all(promises).then(resolve).catch(reject)\n\t}\n\tconst callbackReconciliation = (method, duration) => {\n\t\treturn function(callback) {\n\t\t\tconst signals = []\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function')\n\t\t\t}\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(this[i][method]())\n\t\t\t\t\t}, duration)\n\t\t\t\t})\n\t\t\t\tsignals.push(promise)\n\t\t\t}\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tresolveAll(signals, () => {\n\t\t\t\t\tcallback()\n\t\t\t\t\tresolve()\n\t\t\t\t}, reject)\n\t\t\t})\n\t\t}\n\t}\n\tfor (let i = 0; i < methods.length; i++) {\n\t\tconst method = methods[i]\n\t\ttarget[method] = callbackReconciliation(method, 1000)\n\t}\n}", "CodeBleu_score": 34.57662231893235}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (!callback) {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function');\n\t\t\t}\n\t\t\tconst signals = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method](duration));\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback);\n\t\t}\n\t});\n}", "CodeBleu_score": 45.0629272266038}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration\n\t\t\t\tduration = 1000\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tcallback = () => {}\n\t\t\t}\n\t\t\tconst signals = []\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method](duration))\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback)\n\t\t}\n\t})\n}", "CodeBleu_score": 44.15761755390456}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tstate = priv.get(this);\nlet input = \"\";\nthis.io.serialRead(state.portId, data => {\ninput += new Buffer(data).toString(\"ascii\");\nconst sentences = input.split(\"\\r\n\");\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 71.39343831946645}, {"code": "listen(){\n\t", "CodeBleu_score": 1.3029767937853085}, {"code": "listen(){\n\tstate\nconst state = priv.get(this);\n//initialize input string\nlet input = \"\";\n//start read loop\nthis.io.serialRead(state.portId, data => {\n//append data to input string\ninput += new Buffer(data).toString(\"ascii\");\n//split input string into sentences\nconst sentences = input.split(\"\\r\n\");\n//process complete sentences\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\n//retain incomplete sentence for next read\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 88.39968517876883}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tint num_channels = 0;\n\tint buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id!= ADC_CHANNEL_ID_UNUSED) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels > config->num_channels) {\n\t\tLOG_ERR(\"Number of channels %d is larger than the number of available channels %d\",\n\t\t\tnum_channels, config->num_channels);\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size = num_channels * sizeof(uint16_t);\n\n\tif (buffer_size > sequence->options->buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is smaller than the needed buffer size %d\",\n\t\t\tsequence->options->buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.04933503808019}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 8.153997662966383}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *config = dev->config;\n\tint num_channels = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id!= ADC_CHANNEL_ID_UNUSED) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < num_channels * sizeof(uint16_t)) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.86815423238598}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= config->channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\tadc_context_wait_for_completion(&data->ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 72.75103042680004}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *ctx = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels!= config->num_channels) {\n\t\tLOG_ERR(\"Invalid number of channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tctx->buffer = sequence->buffer;\n\tctx->buffer_size = sequence->buffer_size;\n\tctx->channel_id = 0U;\n\tctx->channels = sequence->channels;\n\tctx->resolution = sequence->resolution;\n\tctx->repeat_buffer = false;\n\n\tadc_context_start_read(ctx);\n\tadc_context_wait_for_completion(ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 60.33313003490658}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= ADC_RESOLUTION_12BIT) {\n\t\tLOG_ERR(\"Unsupported resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= BIT(config->channel)) {\n\t\tLOG_ERR(\"Unsupported channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\tadc_context_wait_for_completion(&data->ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 65.80591020935378}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tstruct device *dev = data->dev;\n\tstruct adc_channel_cfg *channels = data->channels;\n\tu32_t i;\n\n\tfor (i = 0; i < ctx->channels; i++) {\n\t\tchannels[i].input_positive = data->channels_array[i];\n\t}\n\n\tdata->repeat_buffer = ctx->repeat_buffer;\n\tdata->repeat_buffer_size = ctx->repeat_buffer_size;\n\n\tdata->result_buffer = ctx->buffer;\n\tdata->result_buffer_size = ctx->buffer_size;\n\n\tdata->result_buffer_index = 0;\n\n\tdata->repeat_buffer_index = 0;\n\n\tdata->result_buffer_is_full = 0;\n\n\tdata->result_buffer_is_half_full = 0;\n\n\tdata->result_buffer_is_empty = 0;\n\n\tdata->result_buffer_is_half_empty = 0;\n\n\tadc_context_set_channels(dev, channels, ctx->channels);\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 30.333562846667643}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n\n\tdata->channels = ctx->channels;\n\tdata->repeat_buffer = ctx->buffer;\n\tdata->repeat_buffer_length = ctx->buffer_size;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 69.9262273885488}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = ctx->adc_data_container;\n\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 37.29658080393017}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data *adc_data = CONTAINER_OF(ctx, struct adc_data, adc_context);\n\tif (repeat_sampling) {\n\t\tctx->buffer = adc_data->repeat_buffer;\n\t} else {\n\t\tctx->buffer = adc_data->buffer;\n\t}\n}", "CodeBleu_score": 49.262625727645236}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = CONTAINER_OF(ctx, struct adc_data_container, adc_context);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 44.59296613623026}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint16_t result;\n\tint ret;\n\tint i;\n\n\twhile (1) {\n\t\t/* Wait for semaphore */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Read all channels */\n\t\tfor (i = 0; i < config->channel_count; i++) {\n\t\t\tif (!adc_context_is_channel_enabled(ctx, i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, i, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d read error %d\", i, ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->buffer[i] = result;\n\t\t}\n\n\t\t/* Signal sampling done */\n\t\tadc_context_on_sampling_done(ctx, true);\n\t}\n}", "CodeBleu_score": 50.60666234178126}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channel;\n\tuint16_t value;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channel_count; channel++) {\n\t\t\tif (!data->channels[channel].enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &value);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tadc_context_complete(dev, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->channels[channel].buffer[data->channels[channel].index] = value;\n\t\t\tdata->channels[channel].index = (data->channels[channel].index + 1) %\n\t\t\t\t\t\t      data->channels[channel].buffer_size;\n\t\t}\n\n\t\tadc_context_on_sampling_done(dev);\n\t}\n}", "CodeBleu_score": 48.454676742256}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\ttruct adc_context *ctx = &data->ctx;\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct k_sem *sem = &data->acquisition_sem;\n\tuint16_t result;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for semaphore to be released */\n\t\tk_sem_take(sem, K_FOREVER);\n\n\t\t/* Iterate through active channels */\n\t\tfor (channel = 0; channel < config->channel_count; channel++) {\n\t\t\tif (ctx->channel_mask & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = result;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tadc_context_on_sampling_done(ctx, true);\n\t}\n}", "CodeBleu_score": 49.0100261467276}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc;\n\tint32_t ready_time;\n\n\tready_time = config->ready_time;\n\n\tk_sleep(K_USEC(ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val[0] & ADS1112_REG_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.81461008758897}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc;\n\n\tk_sleep(config->ready_time);\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t} while (!(reg_val & ADS1112_CFG_OS));\n\n\treturn 0;\n}", "CodeBleu_score": 38.529653966715145}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\n\tk_sleep(K_MSEC(config->ready_time_ms));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val & ADS1112_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.88665075488176}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size_required = 0;\n\tint extra_samplings = 0;\n\tint num_samplings = sequence->resolution * sequence->channels;\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERSAMPLING_MASK) {\n\t\textra_samplings = sequence->options & ADC_SEQ_OPT_OVERSAMPLING_MASK;\n\t\textra_samplings = (extra_samplings >> ADC_SEQ_OPT_OVERSAMPLING_SHIFT) + 1;\n\t\textra_samplings *= num_samplings;\n\t}\n\n\tbuffer_size_required = num_samplings + extra_samplings;\n\n\tif (buffer_size_required > sequence->buffer_size) {\n\t\tESP_LOGE(TAG, \"Buffer size is too small for the given ADC sequence\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.22989207578834}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint8_t num_samplings = sequence->options & ADC_SEQ_OPT_COUNT_MASK;\n\tuint8_t num_extra_samplings = 0;\n\n\tif (sequence->options & ADC_SEQ_OPT_USE_CALIB) {\n\t\tnum_extra_samplings++;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERWRITE) {\n\t\tnum_extra_samplings++;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERSAMPLE) {\n\t\tnum_extra_samplings++;\n\t}\n\n\tif (num_samplings + num_extra_samplings > ADC_BUFFER_SIZE) {\n\t\tESP_LOGE(TAG, \"Buffer size is not sufficient for ADC sequence\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.02381976154943}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tif (sequence->resolution == 16) {\n\t\tif (sequence->extra_samplings > 0) {\n\t\t\treturn sequence->buffer_size >= sequence->channels * (sequence->extra_samplings + 1) * 2;\n\t\t} else {\n\t\t\treturn sequence->buffer_size >= sequence->channels * 2;\n\t\t}\n\t} else {\n\t\tif (sequence->extra_samplings > 0) {\n\t\t\treturn sequence->buffer_size >= sequence->channels * (sequence->extra_samplings + 1);\n\t\t} else {\n\t\t\treturn sequence->buffer_size >= sequence->channels;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.443722595762146}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (!sequence->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution > 16) {\n\t\tLOG_ERR(\"Resolution %d is not supported\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to start read (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\treturn adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.089758659626746}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= 12) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, wait);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.802272242618926}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint result;\n\n\tresult = ads1112_validate_sequence(dev, sequence);\n\tif (result!= 0) {\n\t\treturn result;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tresult = adc_context_start_read(&data->ctx, sequence);\n\tif (result!= 0) {\n\t\treturn result;\n\t}\n\n\tif (wait) {\n\t\tresult = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 67.55025040420794}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device '%s' not found\", argv[1]);\n\t\treturn -ENOEXEC;\n\t}\n\n\terr = audio_codec_apply_properties(dev);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn err;\n\t}\n\n\tshell_print(sh, \"Properties applied\");\n\n\treturn 0;\n}", "CodeBleu_score": 56.20005004610565}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint err;\n\tstruct audio_codec_apply_properties prop;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tprop.id = atoi(argv[2]);\n\tprop.value = atoi(argv[3]);\n\n\terr = device_set_config(dev, &prop);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to set config\");\n\t\treturn -ENOEXEC;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.500900866061265}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *i2s_data = dev->data;\n\tstruct mpxxdtyy_i2s_config *i2s_cfg = dev->config;\n\n\tint ret = 0;\n\n\t/* Check if the device is already in the desired state */\n\tif ((cmd == DMIC_TRIGGER_START) && (i2s_data->state == I2S_STATE_CONFIGURED)) {\n\t\t/* Set the I2S command to start */\n\t\ti2s_data->i2s_cmd = I2S_CMD_START;\n\t\t/* Set the device state to active */\n\t\ti2s_data->state = I2S_STATE_ACTIVE;\n\t} else if ((cmd == DMIC_TRIGGER_STOP) && (i2s_data->state == I2S_STATE_ACTIVE)) {\n\t\t/* Set the I2S command to stop */\n\t\ti2s_data->i2s_cmd = I2S_CMD_STOP;\n\t\t/* Set the device state to configured */\n\t\ti2s_data->state = I2S_STATE_CONFIGURED;\n\t} else {\n\t\t/* Log an error if the device is not in the desired state */\n\t\tLOG_ERR(\"Device is not in the desired state\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Send the I2S command */\n\tret = i2s_trigger(i2s_cfg->i2s_dev, i2s_data->i2s_cmd);\n\tif (ret < 0) {\n\t\t/* Log an error if the I2S command failed */\n\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 41.43512958925791}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tstruct mpxxdtyy_i2s_config *cfg = dev->config;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t\tret = mpxxdtyy_i2s_set_i2s_cmd(dev, MPXXDTYY_I2S_CMD_START);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to set I2S command to START\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_WRN(\"Device already in active state\");\n\t\t} else {\n\t\t\tLOG_ERR(\"Device not in configured state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t\tret = mpxxdtyy_i2s_set_i2s_cmd(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to set I2S command to STOP\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tLOG_WRN(\"Device already in configured state\");\n\t\t} else {\n\t\t\tLOG_ERR(\"Device not in active state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 34.767249616847195}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tstruct mpxxdtyy_i2s_config *cfg = dev->config;\n\tint ret = 0;\n\n\tif (data->state == MPXXDTYY_I2S_STATE_DISABLED) {\n\t\tLOG_ERR(\"Device not initialized\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (data->state == MPXXDTYY_I2S_STATE_CONFIG) {\n\t\tLOG_ERR(\"Device not configured\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_cmd_send(dev, MPXXDTYY_I2S_CMD_START);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to send START command\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_IDLE) {\n\t\t\tLOG_ERR(\"Device already idle\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_cmd_send(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to send STOP command\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_IDLE;\n\t} else {\n\t\tLOG_ERR(\"Invalid command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.996692532781715}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF | AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF_DISPLAY_ON;\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF_CURSOR_ON;\n\t}\n\n\tif (config->blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF_DISPLAY_ON;\n\t} else {\n\t\tcmd &= ~AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 65.28994402921502}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_CURSOR_BLINK;\n\t} else if (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_CURSOR;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_DISPLAY;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 63.69573443906933}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON_OFF;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_BLINK;\n\t}\n\n\tif (config->cursor_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 65.53146955813342}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_gpios.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpios);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 75.42640398296454}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tbool busy;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio, &busy);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn busy;\n}", "CodeBleu_score": 69.256542388387}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tstruct gpio_dt_spec spec;\n\n\tif (config->busy_gpios == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tspec = *config->busy_gpios;\n\n\tret = gpio_pin_get_dt(&spec);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO pin status\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 68.27407920279892}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2] = {AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX,\n\t\t\t     (uint8_t)command};\n\n\treturn i2c_write_dt(config->i2c, buffer, sizeof(buffer),\n\t\t\t    config->i2c_address);\n}", "CodeBleu_score": 51.52779800780013}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2] = { config->special_command_prefix, command };\n\tint ret;\n\n\tret = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 72.04295193434861}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\t/* Construct the buffer to send */\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\t/* Send the buffer */\n\tret = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Wait for the device to process the command */\n\tk_msleep(config->special_command_delay);\n\n\treturn 0;\n}", "CodeBleu_score": 67.34740045981908}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbdata = dev->data;\n\n\tif (size > bbdata->size) {\n\t\tbbdata->status.is_invalid = true;\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > bbdata->size) {\n\t\tbbdata->status.is_invalid = true;\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &bbdata->mem[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 49.974381462228145}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tsize_t mem_size = bbram_data->mem_size;\n\n\tif (offset > mem_size || size > mem_size ||\n\t    offset + size > mem_size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &bbram_data->mem[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 55.76188201090122}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tint err = 0;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_data->mem + offset, size);\n\n\treturn err;\n}", "CodeBleu_score": 62.10543269019417}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *bb_data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > bb_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > bb_data->size - size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bb_data->data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 54.89523808877917}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tstruct bbram_emul_config *bbram_config = dev->config;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > bbram_config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram_data->data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.05753279891734}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *d = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > d->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&d->mem[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.244207004504474}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 82.16428064579104}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing required argument: %s\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.56813776986935}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing required argument\");\n\t\treturn -ENOENT;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.00713796965894}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct uart_h4_data *const data = dev->data;\n\tstruct uart_h4_fifo *const fifo = &data->fifo;\n\tuint8_t *buf = fifo->buf;\n\tconst uint8_t *const end = buf + fifo->size;\n\tuint8_t *const hdr = data->hdr;\n\tconst uint8_t *const hdr_end = hdr + sizeof(data->hdr);\n\tuint8_t *p = hdr + fifo->count;\n\tint ret;\n\n\twhile (p < hdr_end) {\n\t\tret = uart_fifo_read(dev, p, hdr_end - p);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read header from UART FIFO\");\n\t\t\tbreak;\n\t\t}\n\n\t\tp += ret;\n\t}\n\n\tfifo->count = p - hdr;\n}", "CodeBleu_score": 34.63164834076821}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_context *h4 = dev->data;\n\tint remaining = H4_HDR_SIZE - h4->hdr_count;\n\tint bytes_read;\n\n\tbytes_read = uart_fifo_read(dev, &h4->hdr[h4->hdr_count], remaining);\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"Failed to read header from UART\");\n\t\treturn;\n\t}\n\n\th4->hdr_count += bytes_read;\n\tremaining -= bytes_read;\n\n\tif (remaining > 0) {\n\t\tLOG_ERR(\"Failed to read full header from UART\");\n\t}\n}", "CodeBleu_score": 40.33235235141253}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_dev_data *data = dev->data;\n\tint ret;\n\n\t/*\n\t * If we have not read the header yet, we need to read the header\n\t * first.\n\t */\n\tif (data->remaining_bytes == data->hdr_len) {\n\t\tret = uart_fifo_read(dev, data->hdr, data->hdr_len);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read header\");\n\t\t\treturn;\n\t\t}\n\n\t\tdata->remaining_bytes -= ret;\n\t}\n}", "CodeBleu_score": 42.20131534315056}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t n = 0;\n\n\twhile (n < len) {\n\t\tsize_t chunk = MIN(len - n, sizeof(buf));\n\n\t\tif (uart_fifo_read(uart, buf, chunk)!= chunk) {\n\t\t\tLOG_ERR(\"Failed to read from FIFO\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tn += chunk;\n\t}\n\n\treturn n;\n}", "CodeBleu_score": 42.31053358067376}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t cnt = 0;\n\n\twhile (len > 0) {\n\t\tsize_t n = len > 32? 32 : len;\n\t\tint ret = uart_fifo_read(uart, buf, n);\n\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Error reading from UART: %d\", ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= ret;\n\t\tcnt += ret;\n\t}\n\n\treturn cnt;\n}", "CodeBleu_score": 38.65046347274439}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tstruct h4_uart_data *data = DEV_DATA(uart);\n\tsize_t discarded = 0;\n\tuint8_t buf[33];\n\n\twhile (discarded < len) {\n\t\tsize_t to_read = MIN(len - discarded, sizeof(buf));\n\t\tint ret = uart_fifo_read(uart, buf, to_read);\n\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read from FIFO: %d\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tdiscarded += ret;\n\t}\n\n\treturn discarded;\n}", "CodeBleu_score": 40.840730965984704}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *cd = chan->data;\n\tuint8_t hop = 0;\n\tint i;\n\tint count = 0;\n\tstruct zbus_observer *obs;\n\n\tSYS_SPIN_LOCK(cd->lock);\n\tfor (i = 0; i < ZBUS_MAX_OBSERVERS; i++) {\n\t\tobs = &cd->observers[i];\n\t\tif (obs->enabled && obs->priority > hop) {\n\t\t\thop = obs->priority;\n\t\t\tcount++;\n\t\t}\n\t}\n\tcd->highest_observer_priority = hop;\n\tSYS_SPIN_UNLOCK(cd->lock);\n}", "CodeBleu_score": 27.74374998973275}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint32_t highest_priority = 0;\n\n\t/*\n\t * Lock the channel data\n\t */\n\tzbus_chan_lock(chan);\n\n\t/*\n\t * Iterate through the observers, checking each observer's priority and whether it is enabled\n\t */\n\tfor (size_t i = 0; i < chan->num_observers; i++) {\n\t\t/*\n\t\t * If an observer has a higher priority (lower numerical value) than the current highest,\n\t\t * update the highest observer priority\n\t\t */\n\t\tif (chan->observers[i].priority < highest_priority) {\n\t\t\thighest_priority = chan->observers[i].priority;\n\t\t}\n\t}\n\n\t/*\n\t * Set the channel's highest observer priority to the determined value\n\t */\n\tchan->highest_observer_priority = highest_priority;\n\n\t/*\n\t * Unlock the channel data\n\t */\n\tzbus_chan_unlock(chan);\n}", "CodeBleu_score": 21.149935704432814}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tstruct zbus_observer *obs_end;\n\tuint32_t highest = 0;\n\n\tzbus_channel_lock(chan);\n\tobs = chan->obs;\n\tobs_end = obs + chan->obs_len;\n\tfor (; obs < obs_end; obs++) {\n\t\tif (obs->enabled && obs->priority > highest) {\n\t\t\thighest = obs->priority;\n\t\t}\n\t}\n\tchan->highest_observer_priority = highest;\n\tzbus_channel_unlock(chan);\n}", "CodeBleu_score": 23.36732348238665}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tSTRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, observation->idx, &observation_mask);\n\n\t\tif (observation->obs == obs) {\n\t\t\tif (observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.982288364034986}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tSTRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {\n\t\tif (observation->obs == obs) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.409433932409385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tSTRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, observation->idx, &observation_mask);\n\n\t\tif (observation->obs == obs) {\n\t\t\tif (observation_mask->enabled) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 28.280277319375678}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tk_spinlock_key_t key;\n\tint ret = 0;\n\n\tZBUS_ASSERT(obs!= NULL, \"Observer is null\");\n\tZBUS_ASSERT(!k_is_in_isr(), \"Cannot attach observer from ISR\");\n\n\tkey = k_spin_lock(&obs->lock);\n\n\tobs->priority = k_thread_priority_get(k_current_get());\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn ret;\n}", "CodeBleu_score": 53.210719962514965}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tint ret;\n\n\tZBUS_ASSERT(obs!= NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_obs_lock);\n\n\tret = k_is_in_isr()? -EPERM : 0;\n\tif (ret == 0) {\n\t\tobs->priority = k_thread_priority_get(k_current_get());\n\t\tupdate_all_channels_hop(obs);\n\t}\n\n\tk_spin_unlock(&zbus_obs_lock, key);\n\n\treturn ret;\n}", "CodeBleu_score": 34.81301098411894}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t_ZBUS_SPINLOCK\n\tk_is_in_isr\n\t_ZBUS_ASSERT\n\tupdate_all_channels_hop\n\n\treturn 0;\n}", "CodeBleu_score": 9.166983718118365}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_timeout(timeout);\n\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 50.56766745068503}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"chan must be not NULL\");\n\n\tk_timepoint_t end_time = sys_timepoint_timeout(timeout);\n\n\tint prio = 0;\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 46.17500852778651}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout_isr(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 52.25611342378515}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int == ETH_INT_NORMAL) {\n\t\tif (enable) {\n\t\t\tETH_REG->ETH_INTEN |= ETH_INTEN_INTEN;\n\t\t} else {\n\t\t\tETH_REG->ETH_INTEN &= ~ETH_INTEN_INTEN;\n\t\t}\n\t} else if (Int == ETH_INT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH_REG->ETH_INTEN |= ETH_INTEN_ABORTIEN;\n\t\t} else {\n\t\t\tETH_REG->ETH_INTEN &= ~ETH_INTEN_ABORTIEN;\n\t\t}\n\t} else {\n\t\tassert_param(IS_ETH_INT(Int));\n\t}\n}", "CodeBleu_score": 37.93295040111738}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\n\tif (enable) {\n\t\tif (Int & ETH_INT_ABNORMAL) {\n\t\t\tETH->INT_MASK |= ETH_INT_ABNORMAL;\n\t\t} else {\n\t\t\tETH->INT_MASK |= Int;\n\t\t}\n\t} else {\n\t\tETH->INT_MASK &= ~Int;\n\t\tif (ETH->INT_MASK & ETH_INT_ABNORMAL) {\n\t\t\tETH->INT_MASK |= ETH_INT_ABNORMAL;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.31708039880214}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\n\tif (enable) {\n\t\tif (Int & (ETH_INT_NORMAL | ETH_INT_ABNORMAL)) {\n\t\t\tETH->IMR |= Int;\n\t\t} else {\n\t\t\tETH->IER |= Int;\n\t\t}\n\t} else {\n\t\tETH->IER &= ~Int;\n\t\tif (ETH->IER == 0) {\n\t\t\tETH->IMR &= ~(ETH_INT_NORMAL | ETH_INT_ABNORMAL);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.16596167705932}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txdesc;\n\tunsigned int descaddr;\n\tunsigned int i;\n\n\t/* Get the current Tx descriptor */\n\tdescaddr = ETH->ETH_TDES0;\n\n\t/* Search for a free descriptor */\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\ttxdesc = (ETH_TX_DESC *) descaddr;\n\t\tif ((txdesc->status & ETH_TDES0_OWN) == 0) {\n\t\t\treturn txdesc;\n\t\t}\n\t\tdescaddr = (descaddr == (unsigned int) &tx_desc_tab[ETH_TX_DESC_CNT - 1])?\n\t\t\t\t(unsigned int) &tx_desc_tab[0] : descaddr + sizeof(ETH_TX_DESC);\n\t}\n\n\t/* No free descriptor found */\n\treturn 0;\n}", "CodeBleu_score": 45.64161087436146}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t next_tx_desc_addr;\n\tuint32_t current_tx_desc_addr;\n\tuint32_t start_tx_desc_addr;\n\tuint32_t end_tx_desc_addr;\n\tuint32_t current_tx_desc_status;\n\n\t/* Get the current transmit descriptor address */\n\tcurrent_tx_desc_addr = ETH->TXDESC_TAIL;\n\n\t/* Get the start and end addresses of the transmit descriptor list */\n\tstart_tx_desc_addr = ETH->TXDESC_BASE;\n\tend_tx_desc_addr = ETH->TXDESC_BASE + (ETH_TX_DESC_CNT * sizeof(ETH_TX_DESC));\n\n\t/* Search for a free descriptor */\n\tdo {\n\t\t/* Get the current transmit descriptor */\n\t\ttx_desc = (ETH_TX_DESC *)current_tx_desc_addr;\n\n\t\t/* Check if the descriptor is owned by the device */\n\t\tcurrent_tx_desc_status = tx_desc->status;\n\t\tif ((current_tx_desc_status & ETH_TX_DESC_STATUS_OWN) == 0) {\n\t\t\t/* Free descriptor found */\n\t\t\treturn tx_desc;\n\t\t}\n\n\t\t/* Get the next transmit descriptor address */\n\t\tnext_tx_desc_addr = (current_tx_desc_addr + sizeof(ETH_TX_DESC)) & (end_tx_desc_addr - 1);\n\n\t\t/* Check if the next transmit descriptor address is the start address */\n\t\tif (next_tx_desc_addr == start_tx_desc_addr) {\n\t\t\t/* No free descriptor found */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Set the current transmit descriptor address to the next transmit descriptor address */\n\t\tcurrent_tx_desc_addr = next_tx_desc_addr;\n\t} while (1);\n}", "CodeBleu_score": 42.78084903609877}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t desc_addr;\n\tuint32_t start_addr;\n\n\tdesc_addr = ETH->ETH_TDES0;\n\tstart_addr = desc_addr;\n\n\t/* Get the current transmit descriptor address */\n\twhile (1) {\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((desc_addr & ETH_TDES0_OWN) == 0) {\n\t\t\t/* Return the descriptor */\n\t\t\treturn (ETH_TX_DESC *) desc_addr;\n\t\t}\n\n\t\t/* Get the next descriptor address */\n\t\tdesc_addr = *(uint32_t *) (desc_addr & ETH_TDES0_ADDR);\n\n\t\t/* Check if the descriptor looped back to the start address */\n\t\tif (desc_addr == start_addr) {\n\t\t\t/* No free descriptor found */\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.77326116624628}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_uint32_t cyp_dac_channel = 0;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyp_dac_channel = cyp_dac_get_channel(channel);\n\n\tCy_CSDIDAC_OutputEnable(CY_CSDIDAC_BASE, cyp_dac_channel, *value);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.59043092949033}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device!= RT_NULL);\n\tcy_stc_csd_idac_context_t *dac_context = (cy_stc_csd_idac_context_t *) device->parent.user_data;\n\trt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\trt_err_t result = RT_EOK;\n\n\tif (Cy_CSDIDAC_OutputEnable(dac_context, cyp_dac_channel, *value) == CY_CSDIDAC_SUCCESS) {\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_ERROR;\n\t\tLOG_E(\"Failed to enable DAC output\");\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 51.58188895125213}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device!= RT_NULL);\n\n\tcy_stc_csdidac_context_t *dac_context = device->parent.user_data;\n\tRT_ASSERT(dac_context!= RT_NULL);\n\n\trt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n\tif (Cy_CSDIDAC_OutputEnable(dac_context, cyp_dac_channel, *value)!= CY_CSDIDAC_SUCCESS) {\n\t\tLOG_E(\"Failed to enable DAC output for channel %d\", channel);\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 55.046392975602465}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t end_addr = addr + size;\n\n\tif (end_addr > FLASH_32K_END_ADDR) {\n\t\tIFX_LOG_E(\"ERROR: Invalid address 0x%x\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.5643695025014}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t end_addr;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tend_addr = addr + size;\n\tif (end_addr > IFX_FLASH_END_ADDR) {\n\t\tIFX_LOG_E(\"Invalid read address 0x%08X or size %d\", addr, size);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) addr;\n\t\taddr++;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 51.91129726065298}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint i;\n\tif (addr + size > FLASH_MEM_SIZE) {\n\t\tIFX_LOG_E(\"Invalid argument: addr + size > FLASH_MEM_SIZE\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 44.64386126086839}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tCYHAL_TIMER_DECLARE_STRUCT(cyhal_timer_obj, timer);\n\tCYHAL_TIMER_ASSERT\n\treturn cyhal_timer_read(&cyhal_timer_obj);\n}", "CodeBleu_score": 12.204690169708025}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 29.825080229112366}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\tRT_ASSERT(obj!= RT_NULL);\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 28.053318071056555}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.59057861658449}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.219493466892985}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.219493466892985}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tif (startfd >= fdt->maxfd)\n\t{\n\t\tif (fd_slot_expand(fdt, startfd) < 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (index = startfd; index < fdt->maxfd; index++)\n\t{\n\t\tif (fdt->fds[index] == NULL)\n\t\t{\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* no empty slot found */\n\tfd = fdt->maxfd;\n\tif (fd_slot_expand(fdt, fd) < 0)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 47.66882298197122}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\t/* expand the fd table if necessary */\n\tif (startfd >= fdt->maxfd) {\n\t\tif (fd_slot_expand(fdt, startfd) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* search for an empty slot */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* expand the fd table if necessary */\n\tif (fd_slot_expand(fdt, fdt->maxfd) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* search for an empty slot again */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 46.9992585564282}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tif (startfd >= fdt->maxfd) {\n\t\treturn -1;\n\t}\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tif (fd_slot_expand(fdt, fdt->maxfd) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 43.66640802935847}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t err;\n\tconst char *err_str;\n\tint i;\n\n\terr = (error < 0)? -error : error;\n\terr_str = \"EUNKNOW\";\n\n\tfor (i = 0; i < sizeof(err_tbl) / sizeof(err_tbl[0]); i++) {\n\t\tif (err == err_tbl[i].num) {\n\t\t\terr_str = err_tbl[i].str;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err_str;\n}", "CodeBleu_score": 50.60436956327457}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint index = 0;\n\tint err = (int)error;\n\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\n\twhile (error_strings[index].err!= 0) {\n\t\tif (error_strings[index].err == err) {\n\t\t\treturn error_strings[index].str;\n\t\t}\n\t\tindex++;\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 39.63312400652384}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\trt_err_t err;\n\n\terr = error < 0? -error : error;\n\n\tfor (i = 0; i < sizeof(err_table) / sizeof(err_table[0]); i++) {\n\t\tif (err_table[i].num == err) {\n\t\t\treturn err_table[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 57.193626761804474}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\tregister rt_base_t temp;\n\tstruct rt_thread_idle_hook *idle_hook;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\ttemp = rt_hw_interrupt_disable();\n\tidle_hook = rt_thread_idle_hook_get();\n\tif (idle_hook!= RT_NULL)\n\t{\n\t\tidle_hook->hook = hook;\n\t\trt_hw_interrupt_enable(temp);\n\n\t\treturn RT_EOK;\n\t}\n\telse\n\t{\n\t\trt_hw_interrupt_enable(temp);\n\n\t\treturn -RT_EFULL;\n\t}\n}", "CodeBleu_score": 20.479028722896608}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\tstruct rt_thread_idle_hook *idle_hook;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find an empty slot */\n\tidle_hook = _rt_thread_idle_hook_get();\n\tif (idle_hook!= RT_NULL) {\n\t\tidle_hook->hook = hook;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 21.52309675314415}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check idle hook list */\n\tif (rt_list_isempty(&rt_thread_idle_hook))\n\t{\n\t\tresult = -RT_EFULL;\n\t}\n\telse\n\t{\n\t\t/* get idle hook */\n\t\tstruct rt_thread_idle_hook *idle_hook;\n\t\tidle_hook = rt_list_entry(rt_thread_idle_hook.next, struct rt_thread_idle_hook, list);\n\n\t\t/* set hook */\n\t\tidle_hook->hook = hook;\n\n\t\t/* set result */\n\t\tresult = RT_EOK;\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 26.335537939246258}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = -RT_ENOSYS;\n\trt_base_t level;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\t/* find hook */\n\tif (rt_thread_idle_sethook(hook) == RT_EOK) {\n\t\t/* remove it */\n\t\tresult = RT_EOK;\n\t}\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 23.10034411137833}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove from idle hook */\n\tif (rt_list_isempty(&idle_hook_list)) {\n\t\t/* idle hook list is empty */\n\t\tresult = -RT_ERROR;\n\t} else {\n\t\tstruct rt_thread_idle_hook *node;\n\n\t\t/* search hook and delete it */\n\t\trt_list_foreach(node, &idle_hook_list, struct rt_thread_idle_hook) {\n\t\t\tif (node->hook == hook) {\n\t\t\t\t/* found it */\n\t\t\t\trt_list_remove(&idle_hook_list, &node->list);\n\t\t\t\tnode->hook = RT_NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 28.72905937814341}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove hook */\n\tif (rt_list_isempty(&idle_hook_list))\n\t{\n\t\tresult = -RT_ENOSYS;\n\t}\n\telse\n\t{\n\t\tstruct rt_list_node *node;\n\t\tstruct idle_hook *idle_hook;\n\n\t\trt_list_for_each(node, &idle_hook_list)\n\t\t{\n\t\t\tidle_hook = rt_list_entry(node, struct idle_hook, list);\n\t\t\tif (idle_hook->hook == hook)\n\t\t\t{\n\t\t\t\trt_list_remove(node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 28.209552095922678}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\n\t/* ensure the scheduler is unlocked */\n\trt_enter_critical();\n\n\t/* dequeue and wake up each suspended thread from the list one by one until the list is empty */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* remove thread from suspension list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* set error number and resume thread */\n\t\tthread->error = thread_error;\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* leave critical */\n\trt_exit_critical();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.92144993453362}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_thread_t thread;\n\n\t/* ensure the scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* resume all threads */\n\twhile ((thread = rt_list_entry(susp_list->next, rt_thread_t, tlist))!= RT_NULL) {\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t\t/* set thread error */\n\t\tthread->error = thread_error;\n\t}\n\n\t/* ensure the scheduler is locked */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.310620053436374}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tregister rt_base_t level;\n\n\t/* ensure the scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* resume all threads */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\trt_thread_t thread;\n\n\t\t/* get the first thread from the suspension list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* resume the thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* set the error code */\n\t\tthread->error = thread_error;\n\t}\n\n\t/* resume scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.423341176189325}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console;\n\trt_device_t new_console;\n\n\told_console = rt_console_get_device();\n\tif (old_console!= RT_NULL)\n\t{\n\t\trt_device_close(old_console);\n\t}\n\n\tnew_console = rt_device_find(name);\n\tif (new_console!= RT_NULL && new_console!= old_console)\n\t{\n\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)\n\t\t{\n\t\t\trt_console_device_set(new_console);\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 49.29306047618163}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console;\n\n\t/* save the old console */\n\told_console = rt_console_get_device();\n\n\t/* find the new console */\n\tif (name!= RT_NULL) {\n\t\trt_console_device = rt_device_find(name);\n\t} else {\n\t\trt_console_device = RT_NULL;\n\t}\n\n\t/* if the new console is different from the old one, close the old one and set the new one */\n\tif (rt_console_device!= old_console) {\n\t\t/* close the old console */\n\t\tif (old_console!= RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\n\t\t/* open the new console */\n\t\tif (rt_console_device!= RT_NULL) {\n\t\t\trt_device_open(rt_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 50.51421804463059}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old = RT_NULL;\n\trt_device_t new = RT_NULL;\n\n\tRT_ASSERT(name!= RT_NULL);\n\n\t/* save the old console device */\n\told = rt_console_device;\n\n\t/* find the new console device */\n\tnew = rt_device_find(name);\n\tif (new!= RT_NULL && new!= old) {\n\t\t/* close the old console device if it is not the same as the new one */\n\t\tif (old!= RT_NULL) {\n\t\t\trt_device_close(old);\n\t\t}\n\n\t\t/* open the new console device */\n\t\tif (rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t/* set the new console device */\n\t\t\trt_console_device = new;\n\t\t} else {\n\t\t\t/* the new console device can not be opened */\n\t\t\tnew = RT_NULL;\n\t\t}\n\t}\n\n\treturn old;\n}", "CodeBleu_score": 54.0588331527335}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tint length = 0;\n\trt_spin_lock_irqsave(&rt_object_class_type_lock);\n\tinformation = rt_object_get_information(type);\n\tif (information!= RT_NULL) {\n\t\tlength = rt_list_len(&information->object_list);\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_class_type_lock);\n\treturn length;\n}", "CodeBleu_score": 36.5253009409237}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tint length = 0;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\trt_spin_lock_irqsave(&(information->list_lock));\n\n\trt_list_for_each(&(information->object_list), length);\n\n\trt_spin_unlock_irqrestore(&(information->list_lock));\n\n\treturn length;\n}", "CodeBleu_score": 46.24455437885582}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object_information *information;\n\trt_base_t level;\n\n\tinformation = rt_object_get_information(type);\n\tif (information!= RT_NULL) {\n\t\tlevel = rt_spin_lock_irqsave(&(information->object_list_lock));\n\n\t\t/* count the number of objects */\n\t\trt_list_for_each(&(information->object_list), count);\n\n\t\trt_spin_unlock_irqrestore(&(information->object_list_lock), level);\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 51.01602269261165}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tif (information->object_hook!= RT_NULL) {\n\t\tinformation->object_hook(RT_OBJECT_HOOK_DETACH, object);\n\t}\n\n\trt_spin_lock_irqsave(&information->list_lock);\n\trt_list_remove(&(object->list));\n\trt_spin_unlock_irqrestore(&information->list_lock);\n\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 58.16800167042189}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call hook function */\n\tRT_OBJECT_HOOK_CALL(object);\n\n\t/* get object information */\n\tinformation = object->type->information;\n\n\t/* lock object */\n\trt_spin_lock_irqsave(&(information->list_lock));\n\n\t/* remove object from list */\n\trt_list_remove(&(object->list));\n\n\t/* unlock object */\n\trt_spin_unlock_irqrestore(&(information->list_lock));\n\n\t/* set object type to zero */\n\tobject->type = RT_NULL;\n}", "CodeBleu_score": 43.735142807703596}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* call hook function */\n\tif (information->object_hook!= RT_NULL) {\n\t\tinformation->object_hook(RT_OBJECT_HOOK_DETACH, object);\n\t}\n\n\t/* remove object from list */\n\trt_spin_lock_irqsave(&information->list_lock);\n\trt_list_remove(&(object->list));\n\trt_spin_unlock_irqrestore(&information->list_lock);\n\n\t/* set object type to 0 */\n\tobject->type = RT_Object_Class_None;\n}", "CodeBleu_score": 58.17228416185705}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result = RT_EOK;\n\n\t/* check if the object is valid */\n\tif (obj!= RT_NULL) {\n\t\t/* check if the object is a custom object */\n\t\tif (obj->type == RT_Object_Class_Custom) {\n\t\t\t/* check if the object has a destroy method */\n\t\t\tif (obj->destroy!= RT_NULL) {\n\t\t\t\t/* call the destroy method */\n\t\t\t\tresult = obj->destroy(obj);\n\t\t\t}\n\n\t\t\t/* delete the object */\n\t\t\trt_object_delete(obj);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 46.53714958530551}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\tstruct rt_object_information *information;\n\n\t/* object check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\t/* check if object is a custom object */\n\tinformation = rt_object_get_information(obj->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* call destroy method if available */\n\tif (information->destroy!= RT_NULL) {\n\t\tresult = information->destroy(obj);\n\t\tif (result!= RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 45.17745909388859}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result = RT_EOK;\n\tif (obj!= RT_NULL && obj->type == RT_Object_Class_Custom) {\n\t\tif (obj->destroy!= RT_NULL) {\n\t\t\tresult = obj->destroy(obj);\n\t\t}\n\t\trt_object_delete(obj);\n\t}\n\treturn result;\n}", "CodeBleu_score": 49.393044086119154}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tthread_t thread;\n\trt_base_t level;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* leave critical */\n\trt_hw_interrupt_enable(level);\n\n\t/* schedule */\n\trt_schedule();\n}", "CodeBleu_score": 32.441769656835994}, {"code": "static void _thread_exit(void){\n\tthread_t thread;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\trt_enter_critical();\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* enqueue to defunct list */\n\trt_thread_defunct_enqueue(thread);\n\n\t/* leave critical */\n\trt_exit_critical_safe();\n\n\t/* schedule */\n\trt_schedule();\n}", "CodeBleu_score": 60.549931063824715}, {"code": "static void _thread_exit(void){\n\tthread_t thread;\n\trt_err_t result;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* close thread */\n\tresult = rt_thread_close(thread);\n\tRT_ASSERT(result == RT_EOK);\n\n\t/* switch to next thread */\n\trt_schedule();\n}", "CodeBleu_score": 26.6039018209296}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\tthread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_CLOSE);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* thread is suspended */\n\tif (thread->stat == RT_THREAD_CLOSE)\n\t{\n\t\t/* set error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert thread to ready list */\n\t\trt_sched_insert_thread(thread);\n\n\t\t/* unlock scheduler */\n\t\trt_exit_critical();\n\n\t\t/* re-schedule */\n\t\trt_schedule();\n\t}\n\telse\n\t{\n\t\t/* unlock scheduler */\n\t\trt_exit_critical();\n\t}\n}", "CodeBleu_score": 55.451148984664954}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\t/* get thread control block from timeout parameter */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* change thread stat */\n\trt_list_remove(&(thread->tlist));\n\trt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]), &(thread->tlist));\n\tthread->stat = RT_THREAD_READY;\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 50.84147912315665}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\t/* get thread object */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* check thread is valid */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_CLOSE);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check thread is suspended */\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert thread to ready list */\n\trt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]), &(thread->tlist));\n\n\t/* change thread stat */\n\tthread->stat = RT_THREAD_READY;\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 55.90530157193376}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_list_t *list;\n\trt_list_t *node;\n\trt_base_t level;\n\trt_uint8_t detach_flag;\n\n\t/* lock the thread's spinlock */\n\tlevel = rt_spin_lock_irqsave(&thread->spinlock);\n\n\t/* check if the thread is waiting on a mutex */\n\tif (thread->pending_object) {\n\t\t/* get the mutex object */\n\t\trt_object_t object = thread->pending_object;\n\n\t\t/* detach the thread from the mutex */\n\t\tdetach_flag = rt_mutex_detach_from_mutex(thread, object);\n\n\t\t/* check if the thread is detached */\n\t\tif (detach_flag == RT_TRUE) {\n\t\t\t/* get the mutex list */\n\t\t\tlist = &((rt_mutex_t)object)->parent.suspend_thread;\n\n\t\t\t/* search the thread in the mutex list */\n\t\t\tfor (node = list->next; node!= list; node = node->next) {\n\t\t\t\tif (rt_list_entry(node, struct rt_thread, tlist) == thread) {\n\t\t\t\t\t/* remove the thread from the mutex list */\n\t\t\t\t\trt_list_remove(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* release all mutexes the thread has taken */\n\t_thread_mutex_release(thread);\n\n\t/* restore the spinlock state */\n\trt_spin_unlock_irqrestore(&thread->spinlock, level);\n}", "CodeBleu_score": 47.88671100092622}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* lock thread spinlock */\n\tlevel = rt_spin_lock_irqsave(&thread->parent.spinlock);\n\n\t/* check if thread is waiting on a mutex */\n\tif (thread->parent.pending_on!= RT_NULL) {\n\t\trt_list_remove(&(thread->parent.pending_on->wait_list), thread);\n\t\tthread->parent.pending_on = RT_NULL;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\twhile (thread->parent.mutex_list!= RT_NULL) {\n\t\trt_mutex_release((rt_mutex_t)thread->parent.mutex_list);\n\t}\n\n\t/* restore thread spinlock */\n\trt_spin_unlock_irqrestore(&thread->parent.spinlock, level);\n}", "CodeBleu_score": 34.57857406614684}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t", "CodeBleu_score": 1.5259533266411016}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t) thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* set the default priority */\n\tif (thread->init_priority!= RT_THREAD_PRIORITY_INIT) {\n\t\tthread->current_priority = thread->init_priority;\n\t} else {\n\t\tthread->current_priority = RT_THREAD_PRIORITY_MAX / 2;\n\t}\n\n\t/* reset thread's state */\n\tthread->stat = RT_THREAD_INIT;\n\n\t/* resume thread */\n\tresult = rt_thread_resume(thread);\n\n\t/* start scheduler */\n\tif (result == RT_EOK) {\n\t\trt_schedule();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 54.04133783143935}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t) thread) == RT_Object_Class_Thread);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\t/* set thread name */\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\t/* set thread priority */\n\trt_thread_priority_set(thread, thread->init_priority);\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\t/* resume thread */\n\tresult = rt_thread_resume(thread);\n\t/* if thread is in static memory, we should trigger scheduler */\n\tif (result == RT_EOK) {\n\t\tif (thread->stat == RT_THREAD_READY) {\n\t\t\t/* trigger scheduler */\n\t\t\trt_schedule();\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 55.45089219267215}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t) thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* check thread is in init state */\n\tif (thread->stat == RT_THREAD_INIT) {\n\t\t/* set priority */\n\t\tthread->current_priority = thread->init_priority;\n\n\t\t/* set thread state */\n\t\tthread->stat = RT_THREAD_SUSPEND;\n\n\t\t/* startup thread */\n\t\tresult = rt_thread_resume(thread);\n\t} else {\n\t\tresult = -RT_EBUSY;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 56.2667806407829}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_tick_t tick;\n\n\tif (!rt_list_isempty(&(timer_list[RT_TIMER_SKIP_LIST_LEVEL]))) {\n\t\trt_timer_t timer;\n\n\t\ttimer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL]);\n\t\ttick = timer->timeout_tick;\n\t\t*timeout_tick = tick;\n\n\t\treturn RT_EOK;\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 53.64889617678581}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_list_t *t;\n\trt_timer_t timer;\n\n\tlist = timer_list;\n\tif (!rt_list_isempty(list)) {\n\t\tt = rt_list_entry(list->next, rt_list_t, list);\n\t\ttimer = rt_list_entry(t, struct rt_timer, row[0]);\n\t\t*timeout_tick = timer->timeout_tick;\n\t\treturn RT_EOK;\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 52.04731502937633}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\tif (rt_list_isempty(&timer_list[TIMER_SKIP_LIST_LEVEL - 1])) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t*timeout_tick = rt_list_entry(timer_list[TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[TIMER_SKIP_LIST_LEVEL - 1])->timeout_tick;\n\treturn RT_EOK;\n}", "CodeBleu_score": 59.392391565740766}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL)\n\t{\n\t\t/* initialize timer */\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 57.054141967770434}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* parameter check */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL)\n\t{\n\t\t/* initialize timer */\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 59.02297560162661}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* check timer name */\n\tRT_ASSERT(name!= RT_NULL);\n\t/* check timeout function */\n\tRT_ASSERT(timeout!= RT_NULL);\n\t/* check time */\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL)\n\t{\n\t\t/* initialize timer */\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 58.19324276066064}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// create a new recorder\n\trec := httptest.NewRecorder()\n\t// create a new request with the same URL\n\tnewReq := httptest.NewRequest(req.Method, req.URL.String(), req.Body)\n\t// copy the headers from the original request to the new request\n\tfor key, values := range req.Header {\n\t\tfor _, value := range values {\n\t\t\tnewReq.Header.Add(key, value)\n\t\t}\n\t}\n\t// create a new response writer with the recorder\n\tnewRes := &responseWriter{\n\t\tResponseWriter: res,\n\t\tRecorder:       rec,\n\t}\n\t// copy the headers from the recorder to the original response\n\tfor key, values := range rec.Header() {\n\t\tfor _, value := range values {\n\t\t\tres.Header().Add(key, value)\n\t\t}\n\t}\n\t// pass the request through the handlers\n\tfor _, handler := range a.handlers {\n\t\t// if the handler returns an unauthorized status, send a \"Not Authorized\" error response and stop further processing\n\t\tif status := handler(newRes, newReq); status == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\t// if all handlers pass without unauthorized status, pass the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 62.00091971141205}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// create a new recorder for capturing the response\n\trec := httptest.NewRecorder()\n\t// create a new context with the request\n\tctx := context.WithValue(context.Background(), \"request\", req)\n\t// create a new response with the recorder\n\tres = &response{rec, res}\n\t// create a new handler with the recorder\n\thandler := http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\t// call the router to handle the request\n\t\ta.router.ServeHTTP(res, req)\n\t})\n\t// process the request through the handler\n\thandler.ServeHTTP(res, req.WithContext(ctx))\n\t// copy the recorder's headers to the original response\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\t// check if the recorder's status code is 401\n\tif rec.Code == http.StatusUnauthorized {\n\t\t// send a \"Not Authorized\" error response\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\t// forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 62.05966864785568}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar rec *httptest.ResponseRecorder\n\tfor _, handler := range a.handlers {\n\t\trec = httptest.NewRecorder()\n\t\thandler(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 72.4460555516963}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif strings.HasPrefix(path, \"/\") {\n\t\tpath = path[1:]\n\t}\n\n\tif strings.HasSuffix(path, \"/\") {\n\t\tpath += \"index.html\"\n\t}\n\n\tasset, err := a.assets.Open(path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdefer asset.Close()\n\n\tcontentType := mime.TypeByExtension(filepath.Ext(path))\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t_, err = io.Copy(res, asset)\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 47.740530394938894}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Parse the URL path to extract the asset path\n\tpath := req.URL.Path\n\n\t// Check if the asset path is empty\n\tif path == \"\" {\n\t\t// Return a 404 error if the asset path is empty\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Check if the asset path starts with a leading slash\n\tif!strings.HasPrefix(path, \"/\") {\n\t\t// Prepend a leading slash to the asset path\n\t\tpath = \"/\" + path\n\t}\n\n\t// Check if the asset path ends with a trailing slash\n\tif strings.HasSuffix(path, \"/\") {\n\t\t// Append an index.html file to the asset path\n\t\tpath += \"index.html\"\n\t}\n\n\t// Retrieve the asset based on the parsed path\n\tasset, err := a.assets.Asset(path)\n\tif err!= nil {\n\t\t// Return a 404 error if the asset is not found\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header based on the file extension\n\text := filepath.Ext(path)\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t}\n\n\t// Write the asset content to the response\n\tres.Write(asset)\n}", "CodeBleu_score": 50.41747079146312}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path[1:]\n\tasset, err := a.Asset(path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\text := filepath.Ext(path)\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 57.57745389739224}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]interface{}{\"error\": fmt.Sprintf(\"No robot found with name: %s\", robotName)})\n\t\treturn\n\t}\n\tconnections := make([]map[string]interface{}, len(robot.Connections()))\n\ti := 0\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections[i] = map[string]interface{}{\n\t\t\t\"name\": c.Name(),\n\t\t\t\"type\": c.ConnectionType(),\n\t\t}\n\t\ti++\n\t})\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 52.55207907374755}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot!= nil {\n\t\tconnections := []string{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, c.Name())\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeError(res, fmt.Errorf(\"No robot found with name %s\", robotName))\n\t}\n}", "CodeBleu_score": 49.50736278993967}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := a.master.NameFromURL(req.URL.Path)\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Robot not found\"})\n\t\treturn\n\t}\n\tconnections := []map[string]interface{}{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\": c.Name(),\n\t\t\t\"type\": c.ConnectionType(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 50.41773296250347}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tauth := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\")!= \"Basic \"+auth {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 65.60614107426957}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 50.284593828356606}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || subtle.ConstantTimeCompare([]byte(user), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.58428361198588}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.423369332856396}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.423369332856396}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// TODO: check if fromMin < fromMax and toMin < toMax\n\tslope := float64(toMax-toMin) / (fromMax-fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.29943694952878}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, errors.New(\"analog sensor: no connection\")\n\t}\n\n\tif!a.Connection().AnalogReadCapable() {\n\t\treturn 0, 0, errors.New(\"analog sensor: connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 53.01732552921683}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, errors.New(\"connection not set\")\n\t}\n\tif!a.Connection().AnalogSensorReadSupported() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 53.40458695609058}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver: Not connected\")\n\t}\n\tif!a.Connection().AnalogReadSupported() {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver: Connection does not support analog read\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = raw\n\ta.lastScaledValue = a.sensorCfg.scale(raw)\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 54.81095841253016}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m * float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 50.78736036823659}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m * float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn m * float64(value) + n\n\t}\n}", "CodeBleu_score": 50.984660179685804}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMax - m * float64(fromMax)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 52.68350144788327}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = \"GrovePiezoVibrationSensorDriver\"\n\td.AddEvent(\"vibration\")\n\td.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(\"vibration\", true)\n\t\t}\n\t})\n\tif err := d.Connect(); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 40.80101601689796}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t", "CodeBleu_score": 4.505648365866602}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(VibrationEvent)\n\td.On(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent, data)\n\t\t}\n\t})\n\tif err := d.Start(); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 55.942706033138734}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz < 0 {\n\t\treturn fmt.Errorf(\"frequency must be a positive number\")\n\t}\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"duration must be a positive number\")\n\t}\n\tif d.bpm < 0 {\n\t\treturn fmt.Errorf(\"beats per minute must be a positive number\")\n\t}\n\tif d.pin == nil {\n\t\treturn fmt.Errorf(\"pin not set\")\n\t}\n\t// calculate the tone period based on the given frequency\n\ttonePeriod := 1 / hz\n\t// calculate the tempo based on the buzzer's beats per minute\n\ttempo := 60 / d.bpm\n\t// calculate the number of times to repeat the tone based on the duration and tempo\n\trepeat := int(duration / tempo)\n\t// loop through the number of times to repeat the tone\n\tfor i := 0; i < repeat; i++ {\n\t\t// turn the buzzer on\n\t\tif err := d.pin.High(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// sleep for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod * float64(time.Second)))\n\t\t// turn the buzzer off\n\t\tif err := d.pin.Low(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// sleep for the tempo\n\t\ttime.Sleep(time.Duration(tempo * float64(time.Second)))\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.772296894539714}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency\n\ttonePeriod := 1 / hz\n\t// Calculate the tempo based on the buzzer's beats per minute (bpm)\n\ttempo := 60 / d.bpm\n\t// Calculate the number of times to toggle the buzzer based on the duration\n\tnumToggles := int(duration / tempo)\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < numToggles; i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Second)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Second)\n\t}\n\treturn nil\n}", "CodeBleu_score": 58.11394617466833}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1.0 / hz\n\ttempo := 60.0 / d.Bpm\n\tonTime := period * tempo\n\toffTime := period - onTime\n\n\tfor i := 0; i < int(duration); i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(onTime) * time.Second)\n\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(offTime) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 53.311299364745004}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"cannot sleep without a sleep pin\")\n\t}\n\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 31.07618335280749}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 32.22721499549442}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.047270859026366}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.Pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not yet initialized\")\n\t}\n\tif pin, ok := a.Pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.sys.NewAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.12525366488823}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params := a.translate(id)\n\tif path == \"\" {\n\t\treturn nil, errors.New(\"Unknown analog pin\")\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 44.82234439459853}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not properly initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params := a.translate(id)\n\tif path == \"\" {\n\t\treturn nil, errors.New(\"Unknown analog pin id: \" + id)\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 44.98652088739563}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.061152485652336}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.Pins() == nil {\n\t\treturn nil, fmt.Errorf(\"Adaptor is not connected to any pins\")\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a)\n\t}\n\n\tif pin, ok := a.Pins()[id]; ok {\n\t\tif err := pin.ApplyOptions(opts); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif err := pin.Initialize(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.Pins()[id] = pin\n\n\tif err := pin.ApplyOptions(opts); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 48.04802204533611}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.DigitalPins()) == 0 {\n\t\treturn nil, fmt.Errorf(\"Adaptor %s not connected to any pins\", a.Name())\n\t}\n\n\topts = append(opts, gobot.WithPinID(id))\n\n\tpin, err := a.DigitalPins()[0].WithOptions(opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif pin == nil {\n\t\tpin, err = a.translate(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = pin.Initialize()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.DigitalPins()[0].Add(pin)\n\t}\n\n\terr = pin.ApplyOptions(opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 49.539312106812176}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"Adaptor not connected to any pins\")\n\t}\n\topts = append(opts, a.translate(id))\n\tpin, err := a.initialize(id, opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 31.829837183867916}]}
