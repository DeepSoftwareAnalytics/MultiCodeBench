{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tauto content = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\tfor (const auto &file : content) {\n\t\tif (download &&!FileTransfer::FileExists(file)) {\n\t\t\tRequestFile(file);\n\t\t\tlog_info << \"Downloaded \" << file << \" from the server\";\n\t\t} else {\n\t\t\tlog_info << \"Found \" << file << \" in the cache\";\n\t\t}\n\t\tfiles.push_back(file);\n\t}\n\treturn files;\n}", "CodeBleu_score": 51.448660165726736}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files = FileTransfer::GetRequiredFiles(folder);\n\tif (download) {\n\t\tfor (const auto &file : required_files) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\tRequestFile(file);\n\t\t\t\tlog_info(\"Downloaded file: {}\", file);\n\t\t\t} else {\n\t\t\t\tlog_info(\"Found file in cache: {}\", file);\n\t\t\t}\n\t\t}\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 56.1025428222115}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t", "CodeBleu_score": 8.781990752468507}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n#ifdef _WIN32\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.Length() < 1e-6) {\n      Log::Get().Warn(\"SpawnActorWithParent: The translation of the transform is too small, \"\n                      \"which may cause the spring arm to be ill-formed. \"\n                      \"Please make sure that the translation is not too small.\");\n    }\n  }\n#endif\n\n  return _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 41.77768677490641}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// The function checks if the ActorId is valid, and if it is not, it throws an exception.\n// It then calls the private function _pimpl->GetGBufferToken to get a token for the G-buffer.\n// The function then copies the token data into a vector of unsigned char.\n// It then calls the streaming client's Subscribe function with the token data and the callback function.\n// The function then returns.\n  if (!IsValidActorId(ActorId)) {\n    throw std::runtime_error(\"Invalid ActorId\");\n  }\n\n  auto token_data = _pimpl->GetGBufferToken(ActorId, GBufferId);\n\n  std::vector<unsigned char> token_data_copy(token_data.size());\n  std::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n\n  _pimpl->streaming_client.Subscribe(\n      std::move(token_data_copy),\n      [callback = std::move(callback)](const Buffer& buffer) {\n        callback(buffer);\n      });\n}", "CodeBleu_score": 54.52120335463071}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\tif (_walker_navigation.compare_exchange(navigation, navigation)) {\n\t\t\t// navigation was successfully set\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 51.289788611887786}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n\twhile (navigation == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n\t\tif (_walker_navigation.compare_exchange(navigation, new_navigation)) {\n\t\t\tnavigation = new_navigation;\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 52.9812767090675}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation;\n\tdo {\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation) {\n\t\t\treturn navigation;\n\t\t}\n\t} while (!_walker_navigation.compare_exchange(navigation, std::make_shared<WalkerNavigation>()));\n\treturn navigation;\n}", "CodeBleu_score": 50.07838916351632}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\t// Get the current frame of the episode state\n\tuint64_t current_frame = episode.GetState()->GetFrame();\n\n\t// Check if the current frame is less than the given frame\n\tif (current_frame < frame) {\n\t\t// Calculate the time point at which the timeout will be exceeded\n\t\tauto timeout_point = std::chrono::system_clock::now() + timeout.to_chrono();\n\n\t\t// Continuously check if the current frame is less than the given frame\n\t\twhile (current_frame < frame) {\n\t\t\t// Yield control to allow other threads to run\n\t\t\tstd::this_thread::yield();\n\n\t\t\t// Check if the timeout has been exceeded\n\t\t\tif (std::chrono::system_clock::now() > timeout_point) {\n\t\t\t\t// Timeout exceeded, return false\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Get the current frame of the episode state\n\t\t\tcurrent_frame = episode.GetState()->GetFrame();\n\t\t}\n\t}\n\n\t// Synchronization successful, trigger a tick in the TrafficManager\n\tcarla::traffic_manager::TrafficManager::Tick();\n\n\t// Return true to indicate synchronization was successful\n\treturn true;\n}", "CodeBleu_score": 47.616950515552794}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tauto now = std::chrono::system_clock::now();\n\t\tif (now - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.GetState()->Tick();\n\treturn true;\n}", "CodeBleu_score": 40.428483976890504}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start_time = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tif (std::chrono::system_clock::now() - start_time > timeout.to_chrono()) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tTrafficManager::Tick();\n\treturn true;\n}", "CodeBleu_score": 38.41684542978303}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// TODO: Add map_layers to the episode settings.\n\tEpisodeSettings settings;\n\tsettings.set_map_name(map_name);\n\tsettings.set_reset_settings(reset_settings);\n\treturn LoadEpisode(settings);\n}", "CodeBleu_score": 14.54952392766404}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t", "CodeBleu_score": 3.4229654508845124}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tepisode.SetId(0);\n\tepisode.SetMapName(map_name);\n\tepisode.SetResetSettings(reset_settings);\n\tepisode.SetMapLayers(map_layers);\n\n\t// Load episode.\n\tclient.LoadEpisode(episode);\n\n\t// Wait for episode to be ready.\n\tclient.GetEpisodeSettings(episode);\n\tclient.GetTimeout().milliseconds = 100;\n\twhile (episode.GetId() == 0) {\n\t\tclient.SendTickCue();\n\t\tclient.GetTimeout().milliseconds = 100;\n\t\tclient.GetEpisodeSettings(episode);\n\t}\n\treturn episode;\n}", "CodeBleu_score": 32.77525742678285}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller and throw an exception if the walker is not found.\n\tconst auto walker = GetWalker(controller.GetWalkerId());\n\t// Assert that the episode is not null, create navigation if it is missing, and register the walker with the controller's ID.\n\tDEBUG_ASSERT(_episode!= nullptr);\n\t_episode->CreateNavigationIfMissing();\n\t_episode->GetNavigation()->RegisterWalker(walker->GetId(), controller.GetId());\n}", "CodeBleu_score": 44.508247870858455}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tconst Walker *walker = GetWalker(controller.GetWalkerId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"AI controller is not associated with a walker\");\n\t}\n\n\t// Assert that the episode is not null\n\tDEBUG_ASSERT(_episode!= nullptr);\n\n\t// Create navigation if it is missing\n\t_episode->CreateNavigationIfMissing();\n\n\t// Register the walker with the controller's ID\n\t_episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 54.01197325428102}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Get the walker associated with the controller\n\tauto walker = _episode->GetWalker(controller.GetId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found for controller \" + controller.GetId());\n\t}\n\n\t// Assert that the episode is not null\n\tDEBUG_ASSERT(_episode!= nullptr);\n\n\t// Create navigation if it is missing\n\t_episode->CreateNavigationIfMissing();\n\n\t// Register the walker with the controller's ID\n\t_episode->GetNavigation()->RegisterWalker(walker, controller.GetId());\n}", "CodeBleu_score": 60.34827172447231}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef DEBUG\n    if (blueprint.GetDescription().empty()) {\n      throw std::runtime_error(\"Cannot spawn an actor with an empty description\");\n    }\n#endif\n    if (parent!= nullptr) {\n      if (parent->GetParent()!= nullptr) {\n        throw std::runtime_error(\"Cannot spawn an actor with a parent that already has a parent\");\n      }\n      if (parent->GetEpisode()!= GetCurrentEpisode()) {\n        throw std::runtime_error(\"Cannot spawn an actor with a parent that is not in the current episode\");\n      }\n    }\n    auto actor = std::make_shared<Actor>(blueprint, transform, parent, attachment_type, socket_name);\n    GetCurrentEpisode()->RegisterActor(actor);\n    actor->SetGarbageCollectionPolicy(gc);\n    log_debug(\"Spawned actor {} of type {}\", actor->GetId(), actor->GetDescription());\n    return actor;\n  }", "CodeBleu_score": 42.91281885329214}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef DEBUG\n    // Ensure that the actor blueprint is valid.\n    if (!blueprint.IsValid()) {\n      log_error(\"Invalid actor blueprint.\");\n      return nullptr;\n    }\n#endif  // DEBUG\n\n    // Get the current episode.\n    auto episode = GetReadyCurrentEpisode();\n\n    // If the actor has a parent, spawn it as a child of the parent.\n    if (parent) {\n      return SpawnActorWithParent(blueprint, transform, parent, attachment_type, gc, socket_name);\n    }\n\n    // Otherwise, spawn the actor independently.\n    return SpawnActorIndependently(blueprint, transform, gc, socket_name);\n  }", "CodeBleu_score": 33.496496542922344}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef LILY_DEBUG\n    // Check if the blueprint is valid\n    if (!blueprint.IsValid()) {\n      log_debug(\"Cannot spawn actor from an invalid blueprint.\");\n      return nullptr;\n    }\n#endif\n    // Get the current episode\n    auto episode = GetCurrentEpisode();\n    // Spawn the actor\n    SharedPtr<Actor> actor = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n    // Register the actor in the current episode\n    episode->RegisterActor(actor, gc);\n    // Log the creation details\n    log_debug(\"Spawned actor with ID {} and name {}.\", actor->GetId(), actor->GetName());\n    // Return the actor\n    return actor;\n  }", "CodeBleu_score": 40.782423869918574}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t//   Debug::Assert(episode_!= nullptr, \"Episode is not valid\");\n//   Debug::Assert(client_!= nullptr, \"Client is not valid\");\n//   Debug::Assert(callback!= nullptr, \"Callback is not valid\");\n//   client_->SubscribeToStream(\n//       sensor.GetActorDescription().GetStreamToken(),\n//       [this, sensor, callback](SharedPtr<sensor::SensorData> data) {\n//         // Deserialize the data\n//         sensor::Deserializer::Deserialize(sensor, data);\n//         // Associate the data with the current episode\n//         data->SetEpisode(episode_);\n//         // Invoke the callback with the deserialized data\n//         callback(data);\n//       },\n//       shared_from_this());\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n// Ensure that the episode is valid.\nif (!episode) {\nLOG_AND_THROW(\"Simulator::SubscribeToSensor: Invalid episode.\");\n}\n\n// Subscribe to the sensor's data stream.\nauto cb = [this, callback](SharedPtr<sensor::SensorData> data) {\n// Deserialize the incoming data.\nauto deserializedData = sensor::Deserializer::Deserialize(*data);\n\n// Associate the deserialized data with the current episode.\ndeserializedData->SetEpisode(episode);\n\n// Invoke the callback with the deserialized sensor data.\ncallback(deserializedData);\n};\n\n// Subscribe to the sensor's data stream.\nclient->SubscribeToStream(sensor.GetActorDescription().GetStreamToken(), cb);\n}", "CodeBleu_score": 44.37351250336745}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// get all walkers from episode\n\tstd::vector<WalkerHandle> walkers = GetWalkers(episode);\n\n\t// check if walkers list is empty\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// get current state\n\tstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n\t// remove walkers that no longer exist\n\tCheckIfWalkerExist(walkers, *state);\n\n\t// update the vehicles found\n\tUpdateVehiclesInCrowd(episode, false);\n\n\t// update the crowd\n\t_nav.UpdateCrowd();\n\n\t// apply the commands to the walkers\n\tstd::vector<carla::rpc::Command> commands;\n\tcommands.reserve(walkers.size());\n\n\tfor (auto &&walker : walkers) {\n\t\t// get the transform\n\t\tcarla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n\t\t// get the speed\n\t\tfloat speed = _nav.GetWalkerSpeed(walker.walker);\n\t\t// apply the transform and speed to the walker\n\t\tcommands.emplace_back(carla::rpc::Command::ApplyTransform(walker.walker, transform));\n\t\tcommands.emplace_back(carla::rpc::Command::ApplySpeed(walker.walker, speed));\n\t}\n\n\t// apply the batch of commands\n\tepisode->ApplyBatchSync(commands);\n\n\t// check if any walker has been killed\n\tfor (auto &&walker : walkers) {\n\t\tif (!_nav.IsWalkerAlive(walker.walker)) {\n\t\t\t// remove from the crowd\n\t\t\t_nav.RemoveAgent(walker.walker);\n\t\t\t// destroy the controller\n\t\t\t_simulator.lock()->DestroyActor(walker.controller);\n\t\t\t// unregister from list\n\t\t\tUnregisterWalker(walker.walker, walker.controller);\n\t\t}\n\t}\n}", "CodeBleu_score": 51.89616601694805}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// load walkers\n\tstd::vector<WalkerHandle> walkers = LoadWalkers(episode);\n\tif (walkers.empty()) return;\n\n\t// check if walkers exist\n\tCheckIfWalkerExist(walkers, *episode->GetState());\n\n\t// update vehicles in crowd\n\tUpdateVehiclesInCrowd(episode, false);\n\n\t// update crowd\n\t_nav.UpdateCrowd();\n\n\t// apply walker states\n\tstd::vector<carla::rpc::Command> commands;\n\tcommands.reserve(walkers.size());\n\tfor (auto &&walker : walkers) {\n\t  // get the transform\n\t  carla::geom::Transform transform = _nav.GetWalkerTransform(walker.walker);\n\t  // get the speed\n\t  float speed = _nav.GetWalkerSpeed(walker.walker);\n\t  // apply the state\n\t  commands.emplace_back(carla::rpc::Command::ApplyWalkerState(walker.controller, transform, speed));\n\t}\n\t// apply the batch\n\t_simulator.lock()->ApplyBatchSync(commands);\n\n\t// check if walker is dead\n\tfor (auto &&walker : walkers) {\n\t  if (!_nav.IsWalkerAlive(walker.walker)) {\n\t    // remove from the crowd\n\t    _nav.RemoveAgent(walker.walker);\n\t    // destroy the controller\n\t    _simulator.lock()->DestroyActor(walker.controller);\n\t    // unregister from list\n\t    UnregisterWalker(walker.walker, walker.controller);\n\t  }\n\t}\n  }", "CodeBleu_score": 43.87215120961645}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load walkers\n    std::vector<WalkerHandle> walkers = Load(episode);\n    if (walkers.empty())\n      return;\n\n    // check if any walker is not in the list\n    CheckIfWalkerExist(walkers, *episode->GetState());\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update crowd\n    _nav.UpdateCrowd();\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // apply walkers states\n    std::vector<carla::rpc::Command> commands;\n    commands.reserve(walkers.size());\n    for (auto &&walker : walkers) {\n      // get the transform\n      carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n      // get the speed\n      float speed = _nav.GetWalkerSpeed(walker.walker);\n      // apply in batch\n      commands.emplace_back(carla::rpc::Command::ApplyWalkerControl(walker.walker, transform, speed));\n    }\n    _simulator.lock()->ApplyBatchSync(commands);\n\n    // check if any walker is dead\n    for (auto &&walker : walkers) {\n      // check if dead\n      if (!_nav.IsWalkerAlive(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 52.51963787445552}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.mutable_attributes()->Reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.mutable_attributes()->AddAllocated(attribute->MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 58.48231647533068}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.9808456489869}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 77.75374432928028}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = std::make_shared<BlueprintLibrary>();\n\nfor (const auto& pair : m_blueprints) {\n  const auto& blueprint = pair.second;\n\n  if (blueprint.ContainsAttribute(name)) {\n    const auto& attribute = blueprint.GetAttribute(name);\n\n    if (attribute.GetValue() == value ||\n        attribute.GetRecommendedValues().contains(value)) {\n      result->emplace(pair.first, blueprint);\n    }\n  }\n}\n\nreturn result;\n}", "CodeBleu_score": 43.753348716731935}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeSharedPtr<BlueprintLibrary>();\nfor (const auto &pair : *this) {\nif (pair.second.ContainsAttribute(name)) {\nconst std::string &attrValue = pair.second.GetAttribute(name);\nif (attrValue == value) {\nresult->emplace(pair.first, pair.second);\n} else {\nconst std::vector<std::string> &recommendedValues =\npair.second.GetRecommendedValues(name);\nif (std::find(recommendedValues.begin(), recommendedValues.end(),\nvalue)!= recommendedValues.end()) {\nresult->emplace(pair.first, pair.second);\n}\n}\n}\n}\nreturn result;\n}", "CodeBleu_score": 52.537948476863036}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t}", "CodeBleu_score": 7.892504696556612}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFullFilePath(path);\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ofstream::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 42.27962013929919}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFilePath(path);\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write((char *)&content[0], content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 46.21987111974547}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFullPath(path);\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ios::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write((char *)content.data(), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 41.96691432752326}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tconst auto location = transform.location;\n\tconst auto yaw = transform.yaw;\n\tconst auto extents = transform.extents;\n\tconst auto corners = geom::Rotate(yaw, {extents.x, extents.y, 0.0f}) + geom::Rotate(yaw, {-extents.x, extents.y, 0.0f}) + geom::Rotate(yaw, {-extents.x, -extents.y, 0.0f}) + geom::Rotate(yaw, {extents.x, -extents.y, 0.0f});\n\tconst auto min = location + corners;\n\tconst auto max = location - corners;\n\treturn std::make_shared<Bounds>(frame, min, max);\n  }", "CodeBleu_score": 48.95613201055925}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Get the location of the bounding box in the world frame\n    const geom::Location location = transform.location + parent_transform_.location;\n\t// Calculate the four corners of the bounding box\n    const geom::Location corners[4] = {\n      geom::Rotate(transform.yaw, {transform.extents.x, -transform.extents.y, 0.0f}) + location,\n      geom::Rotate(transform.yaw, {-transform.extents.x, -transform.extents.y, 0.0f}) + location,\n      geom::Rotate(transform.yaw, {-transform.extents.x, transform.extents.y, 0.0f}) + location,\n      geom::Rotate(transform.yaw, {transform.extents.x, transform.extents.y, 0.0f}) + location,\n    };\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners\n    return std::make_shared<Bounds>(frame, corners);\n  }", "CodeBleu_score": 43.98017611739281}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// Create a bounding box for the given frame and transform.\n    const auto &location = transform.location;\n    const auto &extents = transform.extents;\n    const float yaw = transform.rotation.yaw;\n// Calculate the location by adding the parent's bounding box location to the transform's location.\n    const auto &parent_location = transform.parent->bounds->location;\n    const geom::Location bounds_location = parent_location + location;\n// Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n    const auto &corner_extents = geom::Rotate(yaw, extents);\n    const geom::Location corners[4] = {\n        bounds_location + geom::Location{-corner_extents.x, -corner_extents.y, 0.0f},\n        bounds_location + geom::Location{corner_extents.x, -corner_extents.y, 0.0f},\n        bounds_location + geom::Location{corner_extents.x, corner_extents.y, 0.0f},\n        bounds_location + geom::Location{-corner_extents.x, corner_extents.y, 0.0f},\n    };\n// Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n    return std::make_shared<const Bounds>(frame, corners);\n  }", "CodeBleu_score": 40.84910739400328}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tstd::vector<LightState> lightStates;\n\tif (GetLightStatesFromServer(lightStates)) {\n\t\tfor (auto& lightState : lightStates) {\n\t\t\tauto it = _lights.find(lightState.GetLightId());\n\t\t\tif (it!= _lights.end()) {\n\t\t\t\tit->second->SetState(lightState);\n\t\t\t} else {\n\t\t\t\t_lights[lightState.GetLightId()] = std::make_unique<Light>(lightState);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.21274754601224}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety.\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server.\n\tauto light_states = _episode.Lock()->GetLightManager()->GetLightStates();\n\n\t// Update the local light states.\n\tfor (auto& light_state : light_states) {\n\t\t// Check if the light already exists in the _lights map.\n\t\tauto it = _lights.find(light_state.first);\n\t\tif (it!= _lights.end()) {\n\t\t\t// If the light already exists, update its state.\n\t\t\tit->second->SetState(light_state.second);\n\t\t}\n\t\telse {\n\t\t\t// If the light does not exist, create a new light object.\n\t\t\t_lights[light_state.first] = std::make_unique<Light>(light_state.first, light_state.second);\n\t\t}\n\t}\n\n\t// Remove any lights that are no longer in the server's light states.\n\tfor (auto it = _lights.begin(); it!= _lights.end();) {\n\t\tif (light_states.find(it->first) == light_states.end()) {\n\t\t\tit = _lights.erase(it);\n\t\t}\n\t\telse {\n\t\t\t++it;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.20870541208565}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Get the current light state from the server\n\tstd::vector<LightState> lightStates;\n\tif (!GetLightStates(lightStates)) {\n\t\treturn;\n\t}\n\n\t// Update the local light states\n\tfor (const auto& lightState : lightStates) {\n\t\tauto it = _lights.find(lightState.lightId);\n\t\tif (it!= _lights.end()) {\n\t\t\tit->second->SetState(lightState);\n\t\t} else {\n\t\t\t_lights[lightState.lightId] = std::make_unique<Light>(lightState);\n\t\t}\n\t}\n\n\t// Remove any lights that are no longer in the server's state\n\tfor (auto it = _lights.begin(); it!= _lights.end();) {\n\t\tif (std::find_if(lightStates.begin(), lightStates.end(), [&](const LightState& state) { return state.lightId == it->first; }) == lightStates.end()) {\n\t\t\tit = _lights.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.86568494794764}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t_episode.Lock();\n\tif (_lights_changes.empty()) {\n\t\t_episode.Unlock();\n\t\treturn;\n\t}\n\tstd::vector<uint8_t> message;\n\tmessage.push_back(static_cast<uint8_t>(discard_client? rpc::LightState::DISCARD_CLIENT : rpc::LightState::UPDATE));\n\tmessage.push_back(static_cast<uint8_t>(_lights_changes.size()));\n\tfor (auto it_light = _lights_changes.begin(); it_light!= _lights_changes.end(); ++it_light) {\n\t\tmessage.push_back(static_cast<uint8_t>(it_light->first));\n\t\tmessage.push_back(static_cast<uint8_t>(it_light->second.GetLocation()));\n\t\tmessage.push_back(static_cast<uint8_t>(it_light->second.GetColor()));\n\t}\n\t_episode.Unlock();\n\t_episode.Lock();\n\t_episode.GetServer()->SendMessage(message);\n\t_lights_changes.clear();\n\t_dirty = false;\n\t_episode.Unlock();\n}", "CodeBleu_score": 39.16404905222297}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\tif (_lights_changes.empty())\n\t\treturn;\n\n\tstd::string message = \"lights \";\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); ++it_light) {\n\t\tif (it_light->second.GetLocation()!= rpc::Location::Unknown)\n\t\t\tmessage.push_back(static_cast<char>(it_light->second.GetLocation()));\n\t\tmessage.push_back(static_cast<char>(it_light->second.GetColor()));\n\t}\n\n\t_episode.Lock()->SendMessage(message);\n\t_lights_changes.clear();\n\t_dirty = false;\n}", "CodeBleu_score": 39.538540143949916}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_lights_mutex);\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\n\tstd::vector<uint8_t> message;\n\tmessage.push_back(static_cast<uint8_t>(rpc::Command::LIGHTS));\n\tmessage.push_back(static_cast<uint8_t>(rpc::LightCommand::UPDATE));\n\tmessage.push_back(static_cast<uint8_t>(rpc::LightUpdate::STATE));\n\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); it_light++) {\n\t\tif (_lights_changes.find(it_light->first) == _lights_changes.end()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmessage.push_back(static_cast<uint8_t>(it_light->first));\n\t\tmessage.push_back(it_light->second.GetLocation());\n\t\tmessage.push_back(it_light->second.GetColor());\n\t}\n\n\tmessage.push_back(static_cast<uint8_t>(rpc::LightUpdate::END));\n\n\t_lights_changes.clear();\n\t_dirty = false;\n\n\t_episode.Lock()->UpdateServerLightsState(message, discard_client);\n}", "CodeBleu_score": 46.93916216725636}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tlog_debug(\"ServerSideSensor::Send called\");\n\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send called with wrong sensor ID\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 53.38452323499756}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send called on a sensor with ID %s\", GetDisplayId().c_str());\n\t\treturn;\n\t}\n\tlog_debug(\"ServerSideSensor::Send called\");\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 54.00487119765116}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"Send called on sensor with incorrect display id.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 52.358752556489186}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (!IsAutopilotOn()) {\n\t\t\tif (m_tmPort == 0) {\n\t\t\t\tm_tmPort = tm_port;\n\t\t\t}\n\t\t\tm_trafficManager->RegisterVehicle(shared_from_this());\n\t\t}\n\t} else {\n\t\tif (IsAutopilotOn()) {\n\t\t\tm_trafficManager->UnregisterVehicle(shared_from_this());\n\t\t}\n\t}\n}", "CodeBleu_score": 43.72530141480924}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicle(shared_from_this(), tm_port);\n\t} else {\n\t\ttm.UnregisterVehicle(shared_from_this());\n\t}\n}", "CodeBleu_score": 49.56430745458913}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\t// Register the vehicle with the traffic manager\n\t\ttm.RegisterVehicle(shared_from_this(), tm_port);\n\t} else {\n\t\t// Unregister the vehicle from the traffic manager\n\t\ttm.UnregisterVehicle(shared_from_this());\n\t}\n}", "CodeBleu_score": 49.56430745458913}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor from the episode\n\twalker = GetEpisode().Lock()->GetActorById(walkerId);\n\n\t// Add the walker actor to the navigation system with its current location\n\tGetEpisode().Lock()->GetNavigation()->AddActor(walker, walker->GetLocation());\n\n\t// Disable physics simulation and collisions for the walker actor\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 41.843591745085654}, {"code": "void WalkerAIController::Start(){\n\t\t// Register the AI controller with the episode.\n\tGetEpisode().Lock()->RegisterAIController(this);\n\n\t// Retrieve the walker actor.\n\tauto walker = GetParent();\n\n\t// Add the walker to the navigation system with its current location.\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker->GetId(), walker->GetLocation());\n\n\t// Disable the physics simulation and collisions for the walker actor.\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker->GetId(), false);\n\tGetEpisode().Lock()->SetActorCollisions(walker->GetId(), false);\n}", "CodeBleu_score": 51.42505646190363}, {"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor\n\twalker = GetParent()->GetComponent<Walker>();\n\t// Register the AI controller with the episode\n\tGetEpisode().Lock()->RegisterAIController(this);\n\t// Add the walker to the navigation system with its current location\n\tGetEpisode().Lock()->AddWalker(walker, walker->GetLocation());\n\t// Disable physics simulation and collisions for the walker\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker->GetId(), false);\n\tGetEpisode().Lock()->SetActorCollisions(walker->GetId(), false);\n}", "CodeBleu_score": 44.503314789797244}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tEpisode* episode = GetEpisode();\n\tif (episode!= nullptr) {\n\t\tNavigation* nav = episode->Lock()->GetNavigation();\n\t\tif (nav!= nullptr) {\n\t\t\tWalker* walker = GetParent();\n\t\t\tif (walker!= nullptr) {\n\t\t\t\tnav->SetWalkerMaxSpeed(walker->GetId(), max_speed);\n\t\t\t} else {\n\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker not found\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: navigation not found\");\n\t\t}\n\t\tepisode->Unlock();\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: episode not found\");\n\t}\n}", "CodeBleu_score": 54.96666070232323}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the navigation instance from the current episode.\n\tNavigation* nav = GetEpisode().Lock()->GetNavigation();\n\n\t// Check if the navigation instance is valid.\n\tif (nav) {\n\t\t// Get the parent walker.\n\t\tPtr<Walker> walker = GetParent().Downcast<Walker>();\n\n\t\t// Attempt to set the walker's maximum speed using the navigation instance.\n\t\tif (walker && nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// If setting the speed fails or the walker is not found, log a warning message.\n\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not set walker max speed.\");\n}", "CodeBleu_score": 45.99971056444366}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tEpisode* episode = GetEpisode();\n\tif (!episode) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No episode found.\");\n\t\treturn;\n\t}\n\tNavigation* nav = episode->Lock()->GetNavigation();\n\tif (!nav) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No navigation found.\");\n\t\treturn;\n\t}\n\tWalker* walker = GetParent();\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No walker found.\");\n\t\treturn;\n\t}\n\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker max speed.\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 50.47739499396462}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = _parent->GetMap().GetPrevious(_id, distance);\n\tfor (auto waypoint : waypoints) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint, _parent));\n\t}\n\treturn result;\n}", "CodeBleu_score": 61.15610540102819}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = _parent->GetMap().GetPrevious(_id, distance);\n\tfor (auto waypoint : waypoints) {\n\t\tSharedPtr<Waypoint> waypointPtr = SharedPtr<Waypoint>(new Waypoint(waypoint->GetId(), waypoint->GetLatitude(), waypoint->GetLongitude(), waypoint->GetAltitude(), waypoint->GetSpeed(), waypoint->GetCourse(), waypoint->GetTime(), _parent));\n\t\tresult.emplace_back(waypointPtr);\n\t}\n\treturn result;\n}", "CodeBleu_score": 56.88111642482411}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previous = _parent->GetMap().GetPrevious(_id, distance);\n\tfor (auto waypoint : previous) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint, _parent));\n\t}\n\treturn result;\n}", "CodeBleu_score": 58.76815301595555}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<SharedPtr<Signal>> added_signals;\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\nfor (auto signal : signals) {\nif (added_signals.count(signal) == 0) {\nadded_signals.insert(signal);\nSharedPtr<Waypoint> waypoint = signal->GetWaypoint();\nSharedPtr<Landmark> landmark = MakeShared<Landmark>(waypoint, signal);\nresult.emplace_back(landmark);\n}\n}\nreturn result;\n}", "CodeBleu_score": 46.05715505214132}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<SharedPtr<Signal>> added_signals;\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\nfor (auto& signal : signals) {\nif (added_signals.count(signal) == 0) {\nadded_signals.insert(signal);\nSharedPtr<Waypoint> waypoint = signal->GetWaypoint();\nif (waypoint!= nullptr) {\nresult.emplace_back(std::make_shared<Landmark>(waypoint));\n}\n}\n}\nreturn result;\n}", "CodeBleu_score": 42.08893632519578}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<SharedPtr<Signal>> added_signals;\nfor (const auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\nif (added_signals.count(signal) == 0) {\nadded_signals.insert(signal);\nSharedPtr<Waypoint> wp = signal->GetWaypoint();\nresult.emplace_back(wp, signal->GetDistanceFromWaypoint());\n}\n}\nreturn result;\n}", "CodeBleu_score": 38.60871897345765}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t//    World::ApplySettings\n//    _episode.Lock()->GetNetworkingTimeout\n//    _episode.Lock\n//    timeout.milliseconds\n//    settings.fixed_delta_seconds.get\n//    settings.fixed_delta_seconds.has_value\n//    log_warning\n//    _episode.Lock()->SetEpisodeSettings\n//    abs\n//    new_settings.fixed_delta_seconds.get\n//    settings.fixed_delta_seconds.has_value\n//    log_warning\n\n    time_duration local_timeout = timeout.milliseconds() == 0?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t id = _episode.Lock()->ApplySettings(settings);\n    if (settings.fixed_delta_seconds.has_value()) {\n      // Verify fixed delta time accuracy\n      float delta = settings.fixed_delta_seconds.get();\n      float epsilon = std::numeric_limits<float>::epsilon();\n      float min_delta = delta * (1 - epsilon);\n      float max_delta = delta * (1 + epsilon);\n      uint64_t start_tick = Tick(local_timeout);\n      WorldSnapshot curr_snapshot = GetSnapshot();\n      uint64_t end_tick = Tick(local_timeout);\n      WorldSnapshot new_snapshot = GetSnapshot();\n      float actual_delta = new_snapshot.GetTimestamp() - curr_snapshot.GetTimestamp();\n      if (actual_delta < min_delta || actual_delta > max_delta) {\n        log_warning(\"Fixed delta time setting is not accurate. Expected: %f, Actual: %f\", delta, actual_delta);\n      }\n      if (start_tick!= end_tick) {\n        log_warning(\"Fixed delta time setting is not accurate. Expected: %f, Actual: %f\", delta, actual_delta);\n      }\n    }\n    return id;\n  }", "CodeBleu_score": 55.70477394957454}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// 1. Lock the episode.\n\tEpisode *episode = _episode.Lock();\n\n\t// 2. Set a local timeout based on the provided timeout or the episode's networking timeout.\n\ttime_duration local_timeout = timeout.milliseconds() == 0? episode->GetNetworkingTimeout() : timeout;\n\n\t// 3. If the settings include a fixed delta time, it attempts to verify the accuracy of this setting over a series of ticks.\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\t// 4. Tick the world until the fixed delta time is correct or the timeout is reached.\n\t\tWorldSnapshot curr_snapshot = episode->GetWorldSnapshot();\n\t\tfloat new_delta = settings.fixed_delta_seconds.get();\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tepisode->Tick(local_timeout);\n\t\t\tWorldSnapshot new_snapshot = episode->GetWorldSnapshot();\n\t\t\tif (abs(new_snapshot.GetTimestamp() - curr_snapshot.GetTimestamp() - new_delta) < std::numeric_limits<float>::epsilon()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurr_snapshot = new_snapshot;\n\t\t}\n\n\t\t// 5. If the setting is not correctly applied after a number of attempts, a warning is logged.\n\t\tif (abs(episode->GetWorldSnapshot().GetTimestamp() - curr_snapshot.GetTimestamp() - new_delta) > std::numeric_limits<float>::epsilon()) {\n\t\t\tlog_warning(\"Fixed delta time setting is not being applied correctly.\");\n\t\t}\n\t}\n\n\t// 6. Apply the settings to the episode.\n\tepisode->SetEpisodeSettings(settings);\n\n\t// 7. Return the identifier of the applied settings.\n\treturn episode->GetAppliedSettingsId();\n}", "CodeBleu_score": 52.553994138015426}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t/    std::unique_ptr<Episode> episode = _episode.Lock();\n//    time_duration local_timeout = timeout.milliseconds() == 0?\n//        episode->GetNetworkingTimeout() : timeout;\n//    uint64_t id = episode->ApplySettings(settings, local_timeout);\n//    if (settings.fixed_delta_seconds.has_value()) {\n//      time_duration fixed_delta = settings.fixed_delta_seconds.value();\n//      time_duration epsilon = std::chrono::duration<float>(std::numeric_limits<float>::epsilon());\n//      if (fixed_delta < epsilon) {\n//        log_warning(\"World::ApplySettings: fixed delta time of 0 is not allowed\");\n//        return id;\n//      }\n//      time_duration delta_sum = time_duration::zero();\n//      uint64_t num_ticks = 0;\n//      uint64_t max_ticks = 10;\n//      while (num_ticks < max_ticks) {\n//        time_duration delta = episode->Tick(local_timeout);\n//        delta_sum += delta;\n//        if (std::abs(delta - fixed_delta) > epsilon) {\n//          log_warning(\"World::ApplySettings: fixed delta time of %f was not applied after %d ticks\",\n//                      fixed_delta.count(), num_ticks + 1);\n//          break;\n//        }\n//        num_ticks++;\n//      }\n//      if (num_ticks == max_ticks) {\n//        log_warning(\"World::ApplySettings: fixed delta time of %f was applied after %d ticks\",\n//                    fixed_delta.count(), num_ticks);\n//      }\n//    }\n//    return id;\n    return 0;\n  }", "CodeBleu_score": 7.84375722205366}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat lengthSquared = DistanceSquared2D(segment.start, segment.end);\n\tif (lengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segment.start));\n\t}\n\tfloat length = std::sqrt(lengthSquared);\n\tfloat projection = Dot2D(point - segment.start, segment.end - segment.start) / lengthSquared;\n\tprojection = Clamp(projection, 0.0f, 1.0f);\n\treturn std::make_pair(projection * length, Distance2D(point, segment.start + projection * (segment.end - segment.start)));\n}", "CodeBleu_score": 36.610430906810286}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst float segmentLengthSquared = DistanceSquared2D(segment.start, segment.end);\n\tconst float segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segment.start));\n\t}\n\tconst float projection = Dot2D(point - segment.start, segment.end - segment.start) / segmentLengthSquared;\n\tconst float clampedProjection = Clamp(projection, 0.0f, 1.0f);\n\tconst float distanceAlongSegment = segmentLength * clampedProjection;\n\tconst float distanceFromProjection = Distance2D(point, segment.start + (segment.end - segment.start) * clampedProjection);\n\treturn std::make_pair(distanceAlongSegment, distanceFromProjection);\n}", "CodeBleu_score": 44.62711142752245}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst float segmentLengthSquared = DistanceSquared2D(segment.first, segment.second);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn { 0.0f, Distance2D(point, segment.first) };\n\t}\n\tconst float segmentLength = std::sqrt(segmentLengthSquared);\n\tconst float projection = Dot2D(point - segment.first, segment.second - segment.first) / segmentLengthSquared;\n\tconst float clampedProjection = Clamp(projection, 0.0f, 1.0f);\n\tconst float distanceAlongSegment = clampedProjection * segmentLength;\n\tconst float distanceFromProjectionToPoint = Distance2D(point, segment.first + (segment.second - segment.first) * clampedProjection);\n\treturn { distanceAlongSegment, distanceFromProjectionToPoint };\n}", "CodeBleu_score": 40.9856035650865}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t", "CodeBleu_score": 5.712762733113359}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT\nvertices.size\nAddIndex\nAddVertices\n }", "CodeBleu_score": 9.297801824690463}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT\nvertices.size\nAddVertices\nAddIndex\n}", "CodeBleu_score": 9.268901155571452}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(message!= nullptr);\n#endif\n  boost::asio::post(\n      _strand,\n      [self = shared_from_this(), message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(30));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              [self, message](const boost::system::error_code &ec, std::size_t /*bytes_transferred*/) {\n                if (ec) {\n                  self->log_error(ec.message());\n                  self->CloseNow();\n                }\n              });\n        }\n      });\n}", "CodeBleu_score": 38.818663968094256}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message->IsValid());\n\tboost::asio::post(self->_strand, [self, message]() {\n\t\tif (self->_socket.is_open()) {\n\t\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(10));\n\t\t\tboost::asio::async_write(self->_socket, message->GetBufferSequence(), [self, message](const boost::system::error_code &ec, std::size_t) {\n\t\t\t\tif (ec) {\n\t\t\t\t\tlog_error(ec.message());\n\t\t\t\t\tself->CloseNow();\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_ASSERT(message->empty());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}", "CodeBleu_score": 32.042308631859356}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(message!= nullptr);\n  DEBUG_ASSERT(message->IsValid());\n#endif\n\n  boost::asio::post(\n      _strand,\n      [self = shared_from_this(), message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(3));\n          self->_socket.async_write_some(\n              boost::asio::buffer(message->GetBufferSequence()),\n              [self, message](const boost::system::error_code &ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                  return;\n                }\n\n                if (ec == boost::asio::error::operation_aborted) {\n                  return;\n                }\n\n                LOG_ERROR(\"Error while sending message: \", ec.message());\n                self->CloseNow();\n              });\n        }\n      });\n}", "CodeBleu_score": 42.40063331759332}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\t_on_closed(ec);\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 45.74010471736975}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\tshared_from_this()->_on_closed();\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 48.1055497028298}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\t_deadline.cancel();\n\n\t// If there is no error code, and the socket is open,\n\t// attempt to shut down and close the socket.\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\n\t// If there is an error code, log the error.\n\tif (ec) {\n\t\tlog_debug(\"Error on closing socket: %s\", ec.message().c_str());\n\t}\n\n\t// Trigger the on_closed callback.\n\t_on_closed(shared_from_this());\n\n\t// Log that the session has been closed.\n\tlog_debug(\"Session closed.\");\n}", "CodeBleu_score": 59.38406035010234}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(msg.size());\n\tbuffer->data = msg;\n\tlog_info(\"Sending message: \" + msg);\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\tstd::shared_ptr<Buffer> response = _router->ReadFromNext();\n\tlog_info(\"Response: \" + response->data);\n}", "CodeBleu_score": 48.637295225356766}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tstd::string msg = \"Are you alive?\";\n\tstd::unique_ptr<char[]> buffer(new char[msg.size() + 1]);\n\tstrcpy(buffer.get(), msg.c_str());\n\n\t// Log the sending action\n\tlog_info(\"Sending message: %s\", msg.c_str());\n\n\t// Write the buffer to the next router\n\t_router->WriteToNext(buffer.get(), msg.size(), YOU_ALIVE);\n\n\t// Wait for the response from the system\n\tstd::future<std::unique_ptr<char[]>> fut = _router->ReadFromNext(msg.size());\n\tstd::unique_ptr<char[]> response = std::move(fut.get());\n\n\t// Log the response\n\tlog_info(\"Response: %s\", response.get());\n}", "CodeBleu_score": 47.39085925459483}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tstd::string msg = \"Are you alive?\";\n\tBuffer buffer(msg.size());\n\tbuffer.data = msg.c_str();\n\n\t// Log the sending action\n\tlog_info(\"Sending message to check if system is alive.\");\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tlog_info(\"Waiting for response from system.\");\n}", "CodeBleu_score": 40.160166333337855}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Create a buffer to store the sensor ID.\n\tchar buffer[sizeof(stream_id)];\n\t// Copy the sensor ID to the buffer.\n\tstd::memcpy(buffer, &sensor_id, sizeof(stream_id));\n\t// Send an ENABLE_ROS command to the server using the router.\n\tRouter::Response response = _router->SendCommand(Router::Command::ENABLE_ROS, buffer, sizeof(stream_id));\n\t// If the response is not empty, process it.\n\tif (!response.buffer.empty()) {\n\t\t// Create a stream_id variable to store the sensor ID.\n\t\tstream_id id;\n\t\t// Copy the sensor ID from the response buffer to the stream_id variable.\n\t\tstd::memcpy(&id, response.buffer.data(), sizeof(stream_id));\n\t\t// If the sensor ID is valid, log a message indicating that the sensor was enabled.\n\t\tif (id == sensor_id) {\n\t\t\tlog_info(\"Enabled sensor %u for ROS\", sensor_id);\n\t\t}\n\t\t// If the sensor ID is not valid, log an error message indicating that the sensor was not enabled.\n\t\telse {\n\t\t\tlog_error(\"Could not enable sensor %u for ROS\", sensor_id);\n\t\t}\n\t}\n\t// If the response is empty, log an error message indicating that the sensor was not found on any server.\n\telse {\n\t\tlog_error(\"Could not find sensor %u on any server\", sensor_id);\n\t}\n}", "CodeBleu_score": 45.4089728597358}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor has been activated on any secondary server.\n\tauto it = _servers.find(sensor_id);\n\tif (it == _servers.end()) {\n\t\t// If not, log an error message.\n\t\tlog_error(\"Could not find sensor %d on any secondary server.\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router.\n\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(ENABLE_ROS);\n\tbuffer.push_back(sensor_id);\n\t_router->WriteToOne(it->second, buffer.data(), buffer.size());\n\n\t// Wait for and process the server's response.\n\tauto response = _router->ReadOne();\n\tif (response.buffer.size()!= 1) {\n\t\tlog_error(\"Received an invalid response from the server.\");\n\t\treturn;\n\t}\n\tif (response.buffer.data()[0] == 0) {\n\t\tlog_error(\"Failed to enable sensor %d on the server.\", sensor_id);\n\t\treturn;\n\t}\n}", "CodeBleu_score": 53.27787984517247}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Find the sensor on any secondary server\n\tauto sensor_it = std::find_if(_servers.begin(), _servers.end(), [&sensor_id](const auto& server) {\n\t\treturn server.second.find(sensor_id)!= server.second.end();\n\t});\n\n\tif (sensor_it == _servers.end()) {\n\t\tlog_error(\"Sensor %d not found on any secondary server\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID\n\tstd::vector<uint8_t> buffer(sizeof(stream_id));\n\t*reinterpret_cast<stream_id *>(buffer.data()) = sensor_id;\n\n\t// Send the ENABLE_ROS command to the server\n\tauto fut = _router->WriteToOne(sensor_it->first, Command::ENABLE_ROS, buffer);\n\n\t// Wait for the server's response\n\tauto response = fut.get();\n\n\t// Process the server's response\n\tif (response.status == Status::OK) {\n\t\tlog_info(\"Enabled sensor %d on server %d\", sensor_id, sensor_it->first);\n\t} else {\n\t\tlog_error(\"Failed to enable sensor %d on server %d\", sensor_id, sensor_it->first);\n\t}\n}", "CodeBleu_score": 53.17611995986303}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_debug(\"getting token for sensor \", sensor_id);\n\tauto it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"sensor already activated, returning existing token\");\n\t\treturn it->second;\n\t}\n\tlog_debug(\"sensor not activated, enabling sensor on secondary server\");\n\tauto token = SendGetToken(sensor_id);\n\t_tokens[sensor_id] = token;\n\t_sensor_to_token[token.get_stream_id()] = sensor_id;\n\tlog_debug(\"got token \", token.get_stream_id(), \" for sensor \", sensor_id);\n\treturn token;\n}", "CodeBleu_score": 58.45236770116298}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_debug(\"getting token for sensor \", sensor_id);\n\tif (_tokens.find(sensor_id)!= _tokens.end()) {\n\t\tlog_debug(\"already got token for sensor \", sensor_id);\n\t\treturn _tokens[sensor_id];\n\t} else {\n\t\tlog_debug(\"asking for token for sensor \", sensor_id);\n\t\tauto new_token = SendGetToken(sensor_id);\n\t\t_tokens[sensor_id] = new_token;\n\t\t_token_to_sensor[new_token] = sensor_id;\n\t\treturn new_token;\n\t}\n}", "CodeBleu_score": 44.89377866520222}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t//  log_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it!= _tokens.end()) {\n    log_debug(\"already have a token for sensor \", sensor_id);\n    return it->second;\n  }\n\n  log_debug(\"need to get a token for sensor \", sensor_id);\n  auto new_token = SendGetToken(sensor_id);\n\n  auto server = _router->GetNextServer();\n  log_debug(\"got a token from server \", server.get_id());\n  _tokens.insert(std::make_pair(sensor_id, new_token));\n  _token_to_server.insert(std::make_pair(new_token, server));\n  _server_to_tokens[server].insert(sensor_id);\n  return new_token;\n}", "CodeBleu_score": 60.01395843299034}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(m_crowd);\n\tif (!m_crowd) {\n\t\treturn false;\n\t}\n\n\tauto it = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\tEnterCriticalSection(&_cs);\n\t\tm_crowd->removeAgent(it->second);\n\t\t_mapped_vehicles_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\t\tLeaveCriticalSection(&_cs);\n\t\treturn true;\n\t}\n\n\tit = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\tEnterCriticalSection(&_cs);\n\t\t_walker_manager.RemoveWalker(it->second);\n\t\t_mapped_walkers_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\t\tLeaveCriticalSection(&_cs);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 64.79896900644503}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(m_ready);\n\tDEBUG_ASSERT(m_crowd);\n\n\t// Check if the agent is a walker\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\t// Enter critical section\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\t// Remove the agent from the crowd\n\t\tm_crowd->removeAgent(it->second);\n\n\t\t// Update the walker manager\n\t\t_walker_manager.RemoveWalker(it->second);\n\n\t\t// Remove the agent from the mapping\n\t\t_mapped_walkers_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\n\t\treturn true;\n\t}\n\n\t// Check if the agent is a vehicle\n\tit = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\t// Enter critical section\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\t// Remove the agent from the crowd\n\t\tm_crowd->removeAgent(it->second);\n\n\t\t// Remove the agent from the mapping\n\t\t_mapped_vehicles_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 65.22192264464913}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(m_ready);\n\tDEBUG_ASSERT(m_crowd);\n\n\tauto it = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\tEnterCriticalSection(&_cs);\n\t\tm_crowd->removeAgent(it->second);\n\t\t_mapped_vehicles_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\t\t_mapped_vehicles_id.erase(id);\n\t\tLeaveCriticalSection(&_cs);\n\t\treturn true;\n\t}\n\n\tit = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\tEnterCriticalSection(&_cs);\n\t\t_walker_manager.RemoveWalker(it->second);\n\t\t_mapped_walkers_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\t\t_mapped_walkers_id.erase(id);\n\t\tLeaveCriticalSection(&_cs);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 55.67048422278917}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t  return false;\n\t}\n\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\n\t// get the list of vehicles\n\tstd::set<ActorId> current_vehicles;\n\t{\n\t  // critical section, force single thread running this\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\t  for (auto &it : _mapped_vehicles_id) {\n\t    current_vehicles.insert(it.first);\n\t  }\n\t}\n\n\t// add or update the vehicles\n\tfor (auto &vehicle : vehicles) {\n\t  // add or update the vehicle\n\t  if (!AddOrUpdateVehicle(vehicle)) {\n\t    return false;\n\t  }\n\n\t  // mark as updated\n\t  current_vehicles.erase(vehicle.id);\n\t}\n\n\t// remove the vehicles not updated\n\tfor (auto &id : current_vehicles) {\n\t  if (!RemoveAgent(id)) {\n\t    return false;\n\t  }\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.36246457256124}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\n\t// get the set of currently mapped vehicles\n\tstd::set<ActorId> current_vehicles;\n\tfor (auto &it : _mapped_vehicles_id) {\n\t\tcurrent_vehicles.insert(it.first);\n\t}\n\n\t// add or update vehicles\n\tfor (auto &vehicle : vehicles) {\n\t\t// add or update vehicle\n\t\tif (AddOrUpdateVehicle(vehicle)) {\n\t\t\t// mark as updated\n\t\t\tcurrent_vehicles.erase(vehicle.id);\n\t\t}\n\t}\n\n\t// remove vehicles not updated\n\tfor (auto &id : current_vehicles) {\n\t\t// remove from crowd\n\t\t{\n\t\t\t// critical section, force single thread running this\n\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t_crowd->removeAgent(_mapped_vehicles_id[id]);\n\t\t}\n\t\t// remove from mapping\n\t\t_mapped_vehicles_id.erase(id);\n\t\t_mapped_by_index.erase(_mapped_vehicles_id[id]);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.92412628991441}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tllect all the vehicles that are already mapped\n\tstd::set<ActorId> mapped_vehicles;\n\tfor (auto &vehicle : _mapped_vehicles_id) {\n\t\tmapped_vehicles.insert(vehicle.first);\n\t}\n\n\t// add or update the vehicles\n\tfor (auto &vehicle : vehicles) {\n\t\tif (!AddOrUpdateVehicle(vehicle)) {\n\t\t\treturn false;\n\t\t}\n\t\t// mark as updated\n\t\tmapped_vehicles.erase(vehicle.id);\n\t}\n\n\t// remove the vehicles that are not updated\n\tfor (auto &vehicle_id : mapped_vehicles) {\n\t\tif (!RemoveAgent(vehicle_id)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.04913358232229}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\treturn _crowd->hasVehicleNear(it->second, distance, direction);\n\t}\n\n\tit = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\treturn _crowd->hasVehicleNear(it->second, distance, direction);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 59.9729018179875}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tauto it_walker = _mapped_walkers_id.find(id);\n\tif (it_walker!= _mapped_walkers_id.end()) {\n\t\treturn HasVehicleNear(it_walker->second, distance, direction);\n\t}\n\tauto it_vehicle = _mapped_vehicles_id.find(id);\n\tif (it_vehicle!= _mapped_vehicles_id.end()) {\n\t\treturn HasVehicleNear(it_vehicle->second, distance, direction);\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.48436947013896}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tauto it = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tconst auto &vehicle = _mapped_vehicles_id.at(id);\n\t\tconst auto &location = vehicle->GetLocation();\n\t\tconst auto &speed = vehicle->GetVelocity();\n\t\tconst auto &direction_vector = direction.ToVector3D();\n\t\tconst auto &distance_squared = distance * distance;\n\t\tconst auto &speed_squared = speed.SquaredLength();\n\t\treturn _crowd->hasVehicleNear(location.x, location.y, location.z, speed_squared, direction_vector.x, direction_vector.y, direction_vector.z, distance_squared);\n\t}\n\tit = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tconst auto &walker = _mapped_walkers_id.at(id);\n\t\tconst auto &location = walker->GetLocation();\n\t\tconst auto &speed = walker->GetVelocity();\n\t\tconst auto &direction_vector = direction.ToVector3D();\n\t\tconst auto &distance_squared = distance * distance;\n\t\tconst auto &speed_squared = speed.SquaredLength();\n\t\treturn _crowd->hasVehicleNear(location.x, location.y, location.z, speed_squared, direction_vector.x, direction_vector.y, direction_vector.z, distance_squared);\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.96336651333182}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point\n\tRoutePoint rp = info.route.front();\n\n\t// Create the visitor\n\tWalkerEventVisitor visitor(context, delta, id);\n\n\t// Execute the event\n\tEventResult result = boost::variant2::visit(visitor, rp.event);\n\n\treturn result;\n}", "CodeBleu_score": 50.66580682796391}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point for the walker.\n\tauto point = info.route.GetCurrentPoint();\n\t// Create a WalkerEventVisitor with the current context.\n\tWalkerEventVisitor visitor(info.context, delta);\n\t// Use the visitor to process the event at the current route point.\n\tboost::variant2::visit(visitor, point->event);\n\t// Return the result of the event execution.\n\treturn visitor.result;\n}", "CodeBleu_score": 49.36860478870934}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &route = info.route;\n\tauto &current = info.current;\n\tauto &context = info.context;\n\tauto &current_event = route[current];\n\tWalkerEventVisitor visitor(context, delta);\n\treturn boost::variant2::visit(visitor, current_event);\n}", "CodeBleu_score": 52.29496330550383}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n#ifdef LIBCARLA_INCLUDED_FROM_UE4\n    if (map_builder.GetMap().GetLanes().Num()!= 0) {\n      UE_LOG(LogCarla, Error, TEXT(\"LaneParser::Parse: Map already contains lanes.\"));\n      return;\n    }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n\n    for (pugi::xml_node road_node : xml.children(\"OpenDRIVE\")) {\n      for (pugi::xml_node road_child : road_node.children(\"road\")) {\n\n        const int road_id = road_child.attribute(\"id\").as_int();\n\n        // Get Road Length\n        double road_length = 0.0;\n        for (pugi::xml_node road_length_node : road_child.children(\"length\")) {\n          road_length = road_length_node.attribute(\"s\").as_double();\n        }\n\n        // Create Road\n        map_builder.CreateRoad(road_id, road_length);\n\n        // Get Road Lanes\n        for (pugi::xml_node lanes_node : road_child.children(\"lanes\")) {\n\n          // Get Lane Offset\n          double s = 0.0;\n          for (pugi::xml_node lane_offset_node : lanes_node.children(\"laneOffset\")) {\n            s = lane_offset_node.attribute(\"s\").as_double();\n          }\n\n          // Parse Left Lanes\n          ParseLanes(lanes_node.child(\"laneSection\").child(\"left\"), road_id, s, map_builder);\n\n          // Parse Center Lanes\n          ParseLanes(lanes_node.child(\"laneSection\").child(\"center\"), road_id, s, map_builder);\n\n          // Parse Right Lanes\n          ParseLanes(lanes_node.child(\"laneSection\").child(\"right\"), road_id, s, map_builder);\n        }\n      }\n    }\n  }", "CodeBleu_score": 56.031441395831735}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t#ifdef LIBCARLA_DEBUG\n    std::cout << \"LaneParser::Parse\" << std::endl;\n#endif\n    for (pugi::xml_node road_node : xml.children(\"OpenDRIVE\")) {\n      for (pugi::xml_node road_node_child : road_node.children(\"road\")) {\n        const road::RoadId road_id = road_node_child.attribute(\"id\").as_int();\n\n        for (pugi::xml_node lanes_node : road_node_child.children(\"lanes\")) {\n          for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n            const double s = lane_section_node.attribute(\"s\").as_double();\n\n            ParseLanes(lane_section_node.child(\"left\"), road_id, s, map_builder);\n            ParseLanes(lane_section_node.child(\"center\"), road_id, s, map_builder);\n            ParseLanes(lane_section_node.child(\"right\"), road_id, s, map_builder);\n          }\n        }\n      }\n    }\n  }", "CodeBleu_score": 60.77202336742866}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// New match\n\t\t++m_matchedCount;\n\t\tif (m_matchedCount == 1) {\n\t\t\t// First connection\n\t\t\tm_firstConnection = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// Match lost\n\t\t--m_matchedCount;\n\t} else {\n\t\t// Invalid count change\n\t\tEFD_LOG(efd::ILogger::kError, \"CarlaListenerImpl::on_publication_matched: invalid count change: %d\n\", info.current_count_change);\n\t}\n}", "CodeBleu_score": 54.72579837117488}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::cout << \"Publisher matched\" << std::endl;\n\t\tm_matchedCount++;\n\t\tif (m_matchedCount == 1) {\n\t\t\tm_firstConnection = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tstd::cout << \"Publisher unmatched\" << std::endl;\n\t\tm_matchedCount--;\n\t} else {\n\t\tstd::cout << \"Listener: on_publication_matched: invalid publication matched status\" << std::endl;\n\t}\n}", "CodeBleu_score": 50.95722570164099}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// A new match was detected\n\t\t++m_matchedCount;\n\t\tm_firstConnection = true;\n\t} else if (info.current_count_change == -1) {\n\t\t// A match was lost\n\t\t--m_matchedCount;\n\t} else {\n\t\t// An invalid count change was detected\n\t\tEFD_LOG(efd::efdError, \"CarlaListenerImpl::on_publication_matched: Invalid count change: %d\n\", info.current_count_change);\n\t}\n}", "CodeBleu_score": 54.839304350531236}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change > 0) {\n\t\t// A new subscription has been matched\n\t\tm_matched_count++;\n\t\tif (m_matched_count == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change < 0) {\n\t\t// A subscription has been unmatched\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\t// No more subscriptions, so destroy the subscriber\n\t\t\tm_owner->DestroySubscriber();\n\t\t}\n\t} else {\n\t\t// Something is wrong, so log an error message\n\t\tCarla_Error(\"CarlaSubscriberListenerImpl::on_subscription_matched - Invalid change count\");\n\t}\n}", "CodeBleu_score": 49.81221340952485}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change > 0) {\n\t\t// A new subscription has been discovered.\n\t\tm_matched_count++;\n\t\tm_first_connected = true;\n\t} else if (info.current_count_change < 0) {\n\t\t// A subscription has been removed.\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\t// This was the last subscription, so destroy the subscriber.\n\t\t\tm_owner->DestroySubscriber();\n\t\t}\n\t} else {\n\t\t// The change count is invalid.\n\t\tELOG(\"CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count\");\n\t}\n}", "CodeBleu_score": 49.41728607384225}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// A new subscription has been matched\n\t\tm_matched_count++;\n\t\tif (m_matched_count == 1) {\n\t\t\t// This is the first matched subscription\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// A subscription has been unmatched\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\t// This was the last matched subscription\n\t\t\tm_owner->DestroySubscriber();\n\t\t}\n\t} else {\n\t\t// Something went wrong\n\t\tCARLA_ASSERT(false);\n\t}\n}", "CodeBleu_score": 50.83467651503337}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\n#if defined(_WIN32) &&!defined(__MINGW32__)\n    // avoid compilation on Windows with -ansi -pedantic-errors\n    struct timeval {\n        long tv_sec;\n        long tv_usec;\n    };\n#endif\n\n    // check if key retrieval is defined\n    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    // serialize key\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    Cdr ser(m_keyBuffer, m_keyBufferCapacity);\n    if (!p_type->serializeKey(ser)) {\n        return false;\n    }\n\n    // compute key\n    if (force_md5 || m_isGetKeyDefined) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 72.4507987323678}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t} else {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 92.04901466765068}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\n// Object that manages the raw buffer.\neprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n// Object that serializes the data.\neprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\n// Serialize encapsulation.\npayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\ntry\n{\n// Serialize the object.\np_type->serialize(ser);\n}\ncatch(eprosima::fastcdr::exception::Exception& /*exception*/)\n{\nreturn false;\n}\n\n// Get the serialized data.\npayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\nreturn true;\n}", "CodeBleu_score": 75.84285430698459}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\neprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\neprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\npayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\ntry {\nser.serialize_encapsulation();\npayload->length = static_cast<uint32_t>(payload->max_size) - static_cast<uint32_t>(ser.getSerializedDataLength());\np_type->serialize(ser);\nreturn true;\n} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\nreturn false;\n}\n}", "CodeBleu_score": 85.93210165563812}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\tser.serialize_encapsulation();\n\ttry {\n\t\tp_type->serialize(ser);\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}", "CodeBleu_score": 82.75505607414047}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.g.sysid_target!= 0) {\n\t\t// already have a target\n\t\treturn;\n\t}\n\n\t// decode the message\n\tmavlink_message_t message;\n\tmessage.sysid = msg.sysid;\n\tmessage.compid = msg.compid;\n\tmessage.msgid = msg.msgid;\n\tmavlink_msg_decode(&msg, &message);\n\n\t// check if the message type is one we should track\n\tif (message.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n\t\t// set the target system ID\n\t\ttracker.g.sysid_target = message.sysid;\n\n\t\t// request position and air pressure data streams from the target\n\t\ttracker.gcs().request_datastream_position();\n\t\ttracker.gcs().request_datastream_airpressure();\n\n\t\t// flag that the target has been set\n\t\ttracker.g.target_set = true;\n\t}\n}", "CodeBleu_score": 48.0188177122682}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = _handle_command_preflight_calibration(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 47.09760375867245}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_alt_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.89084913586612}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\tbaro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.59021083549183}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\tif (packet.param1 == 0) {\n\t\tdisarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 54.94231570602929}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0) {\n\t\tdisarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 47.46425555526497}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// Arm servos\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse if (packet.param1 == 0.0) {\n\t\t// Disarm servos\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\telse {\n\t\t// Unsupported parameter\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.31687562023853}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i=0; i<num_gcs; i++) {\n\t\tif (gcs[i].available_payload_space() > MAVLINK_MSG_REQUEST_DATA_STREAM_LEN) {\n\t\t\tgcs[i].send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 0, 0);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.60488476036474}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i=0; i<num_gcs; i++) {\n\t\tif (gcs[i]->available_payload_space() >= MAVLINK_MSG_REQUEST_DATA_STREAM_LEN) {\n\t\t\tgcs[i]->send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.16262309581736}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i=0; i<num_gcs; i++) {\n\t\tif (gcs[i].have_position_payload_space()) {\n\t\t\tmavlink_msg_request_data_stream_send(gcs[i].get_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.948745487648786}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP::ahrs\n\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = asin(ahrs.sin_roll * pitch + ahrs.cos_roll * ahrs.cos_pitch * yaw);\n\tef_yaw = atan2(ahrs.cos_roll * yaw - ahrs.sin_roll * pitch, ahrs.cos_pitch * ahrs.cos_roll);\n\treturn true;\n}", "CodeBleu_score": 53.36181495652308}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP::ahrs\n\tif (ahrs.cos_pitch!= 0.0f) {\n\t\tef_pitch = atan2f(ahrs.sin_roll * sin(pitch) + ahrs.cos_roll * cos(pitch) * sin(yaw), cos(pitch) * cos(yaw));\n\t\tef_yaw = atan2f(-ahrs.cos_roll * sin(pitch) + ahrs.sin_roll * cos(pitch) * sin(yaw), cos(pitch) * cos(yaw));\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.903851804777815}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Get AHRS instance\n\tAP_AHRS_NavEKF &ahrs = AP_AHRS_NavEKF::get_instance();\n\t// Check for zero pitch cosine\n\tif (ahrs.cos_pitch == 0) {\n\t\t// Return false if pitch cosine is zero\n\t\treturn false;\n\t}\n\t// Calculate earth frame pitch and yaw\n\tef_pitch = atan2(ahrs.cos_roll * sin(pitch) + ahrs.sin_roll * ahrs.sin_pitch * cos(pitch), ahrs.cos_pitch * cos(pitch));\n\tef_yaw = yaw + atan2(-ahrs.sin_roll * sin(pitch) + ahrs.cos_roll * ahrs.sin_pitch * cos(pitch), ahrs.cos_pitch * sin(pitch));\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 54.35519114955048}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// if the target is valid or no minimum distance is set, update pitch and yaw servos\n    if (tracker.nav_status.target_valid || tracker.g.min_distance == 0) {\n        // calculate yaw and pitch in centidegrees\n        float pitch = tracker.nav_status.pitch;\n        float yaw = tracker.nav_status.yaw;\n\n        // check if the direction is reversed\n        bool direction_reversed = get_ef_yaw_direction();\n\n        // calculate angle error\n        calc_angle_error(pitch, yaw, direction_reversed);\n\n        // update pitch and yaw servos\n        tracker.update_pitch_servo();\n        tracker.update_yaw_servo();\n    }\n}", "CodeBleu_score": 32.09093051971558}, {"code": "void Mode::update_auto(void){\n\t\tParameters &g = tracker.g;\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\t// if we have a valid target\n\tif (nav_status.target_valid) {\n\t\t// calculate yaw and pitch in centidegrees\n\t\tfloat yaw = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n\t\tfloat pitch = nav_status.elevation*100;\n\n\t\t// if the tracker is trying to move clockwise to reach the vehicle,\n\t\t// but the tracker could get closer to the vehicle by moving counter-clockwise then set direction_reversed to true\n\t\tbool direction_reversed = get_ef_yaw_direction();\n\n\t\t// calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n\t\tcalc_angle_error(pitch, yaw, direction_reversed);\n\n\t\t// if we have a valid target distance or no minimum distance is set\n\t\tif (nav_status.distance_valid || g.min_distance == 0) {\n\t\t\t// update the pitch and yaw servos\n\t\t\ttracker.update_yaw_servo();\n\t\t\ttracker.update_pitch_servo();\n\t\t}\n\t}\n}", "CodeBleu_score": 51.12460736730813}, {"code": "void Mode::update_auto(void){\n\t\t// Get the current navigation status\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\t// Get the current parameters\n\tParameters &g = tracker.g;\n\n\t// If we have a valid target\n\tif (nav_status.status == Tracker::NavStatus::NAV_STATUS_OK) {\n\t\t// Calculate the yaw and pitch in centidegrees\n\t\tfloat yaw = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n\t\tfloat pitch = nav_status.altitude*100;\n\n\t\t// Check if the direction is reversed\n\t\tbool direction_reversed = get_ef_yaw_direction();\n\n\t\t// Calculate the angle error\n\t\tcalc_angle_error(pitch, yaw, direction_reversed);\n\n\t\t// If the target distance is valid or no minimum distance is set\n\t\tif ((nav_status.distance >= g.min_distance) || (g.min_distance == 0)) {\n\t\t\t// Update the pitch servo\n\t\t\ttracker.update_pitch_servo();\n\t\t\t// Update the yaw servo\n\t\t\ttracker.update_yaw_servo();\n\t\t}\n\t}\n}", "CodeBleu_score": 53.78988342901432}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\tset_home();\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN_TIME;\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tground_start_countdown--;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.81118773046109}, {"code": "void Tracker::update_GPS(void){\n\t\tif (gps.update()) {\n\t\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t\t\tif (gps.status >= 3) {\n\t\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\t\tset_home();\n\t\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tground_start_countdown = 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.40898587112381}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\tset_home();\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN_TIME;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.598262177054565}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\t// pitch up\n\t\tif (pitch > 10) {\n\t\t\t// pitch up too much, turn on\n\t\t\t_pitch_onoff_servo.write(180);\n\t\t} else {\n\t\t\t// pitch up not too much, turn off\n\t\t\t_pitch_onoff_servo.write(0);\n\t\t}\n\t} else {\n\t\t// pitch down\n\t\tif (pitch < -10) {\n\t\t\t// pitch down too much, turn on\n\t\t\t_pitch_onoff_servo.write(180);\n\t\t} else {\n\t\t\t// pitch down not too much, turn off\n\t\t\t_pitch_onoff_servo.write(0);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.91416788164038}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class checks\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer reference\n\tif (g.arming_check & ARMING_CHECK_BARO) {\n\t\t// check barometer reference\n\t\tif (!barometer_reference_valid()) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Baro reference not valid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check baro altitude\n\t\tif (fabsf(baro_alt_meter - copter.inertial_nav.get_position(AP_InertialNav::Z)) > g.arming_check_alt_max) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Baro altitude check failed\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 44.10928694818986}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_APM1 || CONFIG_HAL_BOARD == HAL_BOARD_APM2\n    // we don't have barometer checks for APM1 or APM2\n    return AP_Arming::barometer_checks(display_failure);\n#else\n    // check base class checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer reference\n    if (g.arming_check & ARMING_CHECK_BARO) {\n        if (fabsf(barometer.get_base_altitude() - copter.inertial_nav.get_position_z_cm()) > g.arming_check_altitude_cm) {\n            if (display_failure) {\n                gcs_send_text_P(SEVERITY_HIGH,PSTR(\"baro ref failed\"));\n            }\n            return false;\n        }\n    }\n    return true;\n#endif\n}", "CodeBleu_score": 43.623879211174476}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call the base class's barometer check function\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n#if ARMING_CHECK_BARO == ENABLED\n\t// check barometer reference\n\tif (ahrs.barometer_reference_valid() == false) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Barometer reference not valid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tfloat baro_alt = ahrs.get_barometer_alt_cm();\n\tif (baro_alt < -100000 || baro_alt > 100000) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Barometer altitude out of range\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check inertial nav altitude\n\tfloat inertial_alt = copter.inertial_nav.get_position_z_cm();\n\tif (inertial_alt < -100000 || inertial_alt > 100000) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Inertial altitude out of range\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check difference\n\tif (fabsf(inertial_alt - baro_alt) > g.arming_check_alt_max_diff) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Baro altitude too far from inertial altitude\"));\n\t\t}\n\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}", "CodeBleu_score": 48.49712928068234}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TerrainSource_Rangefinder) {\n\t\treturn false;\n\t}\n\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TerrainSource_Database && copter.mode_rtl.get_alt_type() == AP_RTL::AltType_Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.61969799238803}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::Terrain_Source_Rangefinder) {\n\t\treturn false;\n\t}\n\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::Terrain_Source_Database && copter.mode_rtl.get_alt_type() == AP_RTL::Alt_Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.1961342862405}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t#if AP_TERRAIN_AVAILABLE\n    if (copter.mode_rtl.get_alt_type() == AP_RTL::ALT_TYPE_TERRAIN) {\n        return true;\n    }\n#endif\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 35.83250947737368}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the attitude, position, and motor controllers\n\t// using the last loop time from the scheduler\n\tfloat dt = AP::scheduler.get_last_loop_time_s();\n\tpos_control.set_dt(dt);\n\tmotors.set_dt(dt);\n\tattitude_control.set_dt(dt);\n\n\t// run the low-level rate controllers that require only IMU data\n\t// this is done before the controllers that require position and altitude\n\t// information\n\tattitude_control.rate_controller_run();\n}", "CodeBleu_score": 55.02333760213528}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the dt for the rate controllers from the scheduler\n\tfloat dt = AP::scheduler.get_last_loop_time_s();\n\tattitude_control.set_dt(dt);\n\tpos_control.set_dt(dt);\n\tmotors.set_dt(dt);\n\n\t// run the rate controllers\n\tattitude_control.rate_controller_run();\n}", "CodeBleu_score": 55.02333760213528}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the controllers\n\t// TODO: this should be set in the scheduler\n\tfloat dt = AP::scheduler().get_last_loop_time_s();\n\tattitude_control->set_dt(dt);\n\tpos_control->set_dt(dt);\n\tmotors->set_dt(dt);\n\n\t// run the rate controllers\n\t// TODO: this should be in the rate controller\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 60.970192239934626}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old location is not the same as the next waypoint\n\tif (!old_loc.same_loc_as(get_wp_location())) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames do not match\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 56.71694379982516}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old location is not the same as the current waypoint\n\tif (!old_loc.same_loc_as(get_wp())) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames of old and new locations are not the same\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 56.41485667965055}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old location is not the same as the current waypoint\n\tif (!old_loc.same_loc_as(wp_nav->get_wp_loc())) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames are not the same\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 56.28158094376662}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AUX_HIGH) {\n\t\t// Attempt to set the mode\n\t\tif (copter.set_mode(mode) == false) {\n\t\t\t// Failed to set the mode, so reset the mode switch\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t} else if (copter.flightmode->mode_number == mode) {\n\t\t// The mode is the same as the one we are trying to change to, so reset the mode switch\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 57.1839090301083}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AUX_HIGH) {\n\t\t// if the switch is in the HIGH position, try to set the mode\n\t\tcopter.set_mode(mode);\n\t} else {\n\t\t// if the switch is not in the HIGH position and the current flight mode matches the given mode,\n\t\t// reset the mode switch using rc().reset_mode_switch\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 55.97201182970457}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AUX_SWITCH_HIGH) {\n\t\t// set mode\n\t\tcopter.set_mode(mode);\n\n\t} else if (ch_flag == AUX_SWITCH_LOW) {\n\t\t// reset mode switch if in the given mode\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 57.50083572844555}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\tfloat trim_roll, trim_pitch;\n\ttrim_roll = channel_roll->get_control_in() * 0.01f;\n\ttrim_pitch = channel_pitch->get_control_in() * 0.01f;\n\tahrs.add_trim(ToRad(trim_roll), ToRad(trim_pitch));\n\tLOGGER_WRITE_EVENT(LOG_SUBSYSTEM_NAVIGATION, LOG_CATEGORY_CONTROL, LOG_LEVEL_INFO, LOG_EVENT_CONTROL_TRIM_SAVE, trim_roll, trim_pitch);\n\tgcs().send_message(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 50.603892561183294}, {"code": "void Copter::save_trim(){\n\t\t// get the roll and pitch trim from the control inputs\n\tfloat roll_trim = ToRad(channel_roll->get_control_in());\n\tfloat pitch_trim = ToRad(channel_pitch->get_control_in());\n\n\t// add the trim to the AHRS trim\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LOG_LEVEL_INFO, \"TRIM_SAVE\", \"roll_trim:%.4f pitch_trim:%.4f\", (double)roll_trim, (double)pitch_trim);\n\n\t// send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"TRIM SAVED\");\n}", "CodeBleu_score": 61.93623949485904}, {"code": "void Copter::save_trim(){\n\t\t// calculate the trim values from the control inputs\n\tfloat trim_roll = channel_roll->get_control_in() * ToRad;\n\tfloat trim_pitch = channel_pitch->get_control_in() * ToRad;\n\n\t// add the trim values to the AHRS trim\n\tahrs.add_trim(trim_roll, trim_pitch);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LOG_SUBSYSTEM_COPTER, LOG_CATEGORY_CONTROL, LOG_LEVEL_INFO, \"Trim saved\");\n\n\t// send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 58.8466952204469}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tVector3f vel = inertial_nav.get_velocity_ned_cms();\n\tfloat speed_sq = vel.length_squared();\n\tif (position_ok && speed_sq > sq(LOOK_AHEAD_MIN_SPEED_CM_S)) {\n\t\tlook_ahead_yaw = atan2f(vel.y, vel.x);\n\t}\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 39.948431272177466}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat yaw = 0.0f;\n\tVector3f vel = inertial_nav.get_velocity();\n\tfloat speed_sq = vel.length_squared();\n\n\tif (copter.position_ok && speed_sq > 100.0f) {\n\t\tyaw = atan2f(vel.y, vel.x);\n\t}\n\n\treturn yaw;\n}", "CodeBleu_score": 36.46973476393618}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tVector2f vel = copter.inertial_nav.get_velocity_neu_cms();\n\tfloat speed_sq = vel.length_squared();\n\n\tif (copter.position_ok && speed_sq > 0.01f) {\n\t\tlook_ahead_yaw = atan2f(vel.y, vel.x);\n\t}\n\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 45.17220736875247}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (get_rudder_arming_type() == AP_RUDDER_DISABLED) {\n\t\t\tgcs().send_text(MAV_SEVERITY_INFO, \"rudder arming disabled\");\n\t\t\treturn false;\n\t\t}\n\t\tif (plane.get_throttle_input()!= 0) {\n\t\t\tgcs().send_text(MAV_SEVERITY_INFO, \"throttle not zero\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (method == AP_Arming::DISABLED || hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 56.785264741865284}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t#if AP_ARM_CHECK == ENABLED\n    if (method == AP_Arming::RUDDER) {\n        if (!g.rudder_arming ||!plane.get_throttle_input()) {\n            gcs().send_text_P(SEVERITY_LOW,PSTR(\"arming: rudder arming disabled or throttle not zero\"));\n            return false;\n        }\n    }\n#endif\n    if (hal.util->was_watchdog_armed()) {\n        gcs().send_text_P(SEVERITY_LOW,PSTR(\"arming: watchdog armed\"));\n        return false;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 53.88179226294743}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (!g.rudder_arming || plane.get_throttle_input()!= 0) {\n\t\t\tgcs().send_text_P(SEVERITY_LOW,PSTR(\"arming: rudder arming disabled or throttle not zero\"));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (g.arming_check == 0 || hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.93957205576981}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\tif (has_disarm_function()) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\tif (display_failure) {\n\t\tAP_Notify::flags.arming_check_failed = true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 59.80512203993644}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tsub.notify_error(AP_Notify::k_pre_arm_checks, AP_Notify::k_pre_arm_checks_no_disarm);\n\t\t}\n\t\treturn false;\n\t}\n\treturn sub.pre_arm_checks(display_failure);\n}", "CodeBleu_score": 61.73591328479075}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_check_failed = true;\n\t\t\tAP_Notify::flags.arming_check_failed_type = AP_Notify::k_arming_check_failed_disarm;\n\t\t}\n\t\treturn false;\n\t}\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.73299125205297}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat x_temp = x;\n\tfloat y_temp = y;\n\tx = x_temp * ahrs.cos_yaw - y_temp * ahrs.sin_yaw;\n\ty = x_temp * ahrs.sin_yaw + y_temp * ahrs.cos_yaw;\n}", "CodeBleu_score": 41.79856088204119}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat x_temp = x;\n\tfloat y_temp = y;\n\n\tx = x_temp * ahrs.cos_yaw - y_temp * ahrs.sin_yaw;\n\ty = x_temp * ahrs.sin_yaw + y_temp * ahrs.cos_yaw;\n}", "CodeBleu_score": 41.79856088204119}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat x_temp = x;\n\tfloat y_temp = y;\n\tx = x_temp * ahrs.cos_yaw - y_temp * ahrs.sin_yaw;\n\ty = x_temp * ahrs.sin_yaw + y_temp * ahrs.cos_yaw;\n}", "CodeBleu_score": 41.79856088204119}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param1 < -180 || packet.param1 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param2 < -180 || packet.param2 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param3 < -180 || packet.param3 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param5 < -180 || packet.param5 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param6 < -180 || packet.param6 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param7 < -180 || packet.param7 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set yaw heading\n\tg.mode_sub.mode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param2, packet.param3, packet.param4);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 47.02840444619153}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if the yaw angle is within acceptable range\n\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\t// return MAV_RESULT_DENIED if the yaw angle is not within acceptable range\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the param4 value is within acceptable range\n\tif (packet.param4 < 0 || packet.param4 > 1) {\n\t\t// return MAV_RESULT_DENIED if the param4 value is not within acceptable range\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw heading using the provided parameters\n\tg.rc_4.set_angle(packet.param1);\n\n\t// return MAV_RESULT_ACCEPTED if the yaw heading is set successfully\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 39.24169655031828}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// if the yaw angle is within acceptable range\n\tif (is_zero(packet.param1) || is_equal(packet.param1, 360.0f)) {\n\t\t// if the param4 value is within acceptable range\n\t\tif (is_zero(packet.param4) || is_equal(packet.param4, 360.0f)) {\n\t\t\t// set the yaw heading using the provided parameters\n\t\t\tmode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param2, packet.param3, packet.param4);\n\t\t\t// return MAV_RESULT_ACCEPTED\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\t// return MAV_RESULT_DENIED\n\treturn MAV_RESULT_DENIED;\n}", "CodeBleu_score": 58.5325203655914}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _sub.wp_nav.get_wp_bearing_to_destination()/2;\n}", "CodeBleu_score": 13.268691457319942}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _sub.wp_nav.get_wp_bearing_to_destination();\n}", "CodeBleu_score": 13.101801492659407}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _sub.wp_nav.get_wp_bearing_to_destination() / 2;\n}", "CodeBleu_score": 13.558475323744057}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tAP_HAL::micros64_t now = AP_HAL::micros64();\n\t\tlogger.WriteCriticalBlock(LOG_PACKET_HEADER_INIT, now, id, value);\n\t}\n}", "CodeBleu_score": 37.977534681697314}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tAP_HAL::micros64();\n\t\tlogger.WriteCriticalBlock(LOG_PACKET_HEADER_INIT, id, value);\n\t}\n}", "CodeBleu_score": 30.01072542938609}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tlogger.WriteCriticalBlock(AP_HAL::micros64(), id, value);\n\t}\n}", "CodeBleu_score": 28.121026778826852}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 49.32366750873185}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 49.32366750873185}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 49.32366750873185}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\tfloat roll_rate_desired = get_pilot_desired_angle_rates().x;\n\tfloat pitch_rate_desired = get_pilot_desired_angle_rates().y;\n\tfloat yaw_rate_desired = get_pilot_desired_angle_rates().z;\n\tfloat throttle_in = channel_throttle->norm_input();\n\tfloat throttle_out = attitude_control->input_rate_bf_roll_pitch_yaw(roll_rate_desired, pitch_rate_desired, yaw_rate_desired);\n\tmotors.set_throttle_out(throttle_out);\n\tmotors.set_forward(throttle_in);\n\tmotors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 47.61458362485958}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\n\t// convert pilot inputs to desired body frame rates\n\tVector3f pilot_desired_angle_rates = get_pilot_desired_angle_rates();\n\n\t// run the attitude controller\n\tattitude_control->input_rate_bf_roll_pitch_yaw(pilot_desired_angle_rates);\n\tattitude_control->set_throttle_out(channel_throttle->norm_input);\n\n\t// set the forward and lateral motor inputs based on pilot controls\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n}", "CodeBleu_score": 33.727387148308836}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(SPOOL_UNLIMITED_THROTTLE);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(SPOOL_UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to desired body frame rates\n\tfloat desired_angle_rates[3];\n\tget_pilot_desired_angle_rates(desired_angle_rates);\n\n\t// run the attitude controller with these rates\n\tattitude_control->input_rate_bf_roll_pitch_yaw(desired_angle_rates);\n\tattitude_control->run();\n\n\t// output the pilot's throttle input without angle boost\n\tmotors.set_throttle(channel_throttle->norm_input);\n\n\t// set the forward and lateral motor inputs based on pilot controls\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n}", "CodeBleu_score": 39.72630354363018}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set position control mode\n\tsub.pos_control_mode = POSCONTROL_MODE_GUIDED;\n\n\t// get stopping point\n\tsub.wp_nav.get_wp_stopping_point();\n\n\t// set destination to stopping point\n\tsub.wp_nav.set_destination(sub.wp_nav.stopping_point.lat, sub.wp_nav.stopping_point.lng, sub.wp_nav.stopping_point.alt);\n\n\t// initialize yaw\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 48.955928580006166}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// switch to position control mode\n\t// set_mode(POSCTL);\n\tsub.wp_nav.set_mode(WP_NAV_MODE_POSITION_HOLD);\n\t// set_mode(WP_NAV_MODE_POSITION_HOLD);\n\n\t// get the stopping point\n\tVector3f stopping_point = get_stopping_point();\n\n\t// set the stopping point as the waypoint destination\n\tsub.wp_nav.set_destination(stopping_point);\n\n\t// initialize yaw using the default auto yaw mode\n\tsub.wp_nav.set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 47.255584865981234}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tset_mode(GUIDED);\n\n\t// initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// set the stopping point as the waypoint destination\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n\t// initialize the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 40.394136291662235}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical velocity control max speeds and accelerations\n\tset_max_speed_accel_z(g.pilot_velz_max, g.pilot_velz_max, g.pilot_velz_accel);\n\n\t// initialise vertical velocity controller\n\tinit_z_controller();\n\n\t// initialise horizontal velocity controller\n\tposition_control->init_xy_controller();\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 32.0307436143011}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set the vertical speed limits\n\tset_max_speed_accel_z(sub.pilot_vel_z_max, sub.pilot_accel_z_max);\n\t// initialise vertical velocity controller\n\tinit_z_controller();\n\t// initialise horizontal velocity controller\n\tinit_xy_controller();\n\t// set the yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 22.77694013822844}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical maximum speeds and acceleration using pilot-defined parameters\n\tset_max_speed_accel_z(sub.pilot_velocity_z_max, sub.pilot_acceleration_z_max);\n\t// initialize vertical velocity controller\n\tinit_z_controller();\n\t// initialize horizontal velocity controller\n\tposition_control->init_xy_controller();\n\t// set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 29.83324988571533}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\tbool timeout_exceeded = false;\n\tbool altitude_exceeded = false;\n\tbool horizontal_distance_exceeded = false;\n\tbool vertical_distance_exceeded = false;\n\n\tif (_guided_limit.timeout_ms > 0) {\n\t\tif (AP_HAL::millis() - _guided_limit.start_time_ms > _guided_limit.timeout_ms) {\n\t\t\ttimeout_exceeded = true;\n\t\t}\n\t}\n\n\tif (_guided_limit.min_altitude_cm > 0) {\n\t\tif (inertial_nav.get_altitude_cm() < _guided_limit.min_altitude_cm) {\n\t\t\taltitude_exceeded = true;\n\t\t}\n\t}\n\n\tif (_guided_limit.max_altitude_cm > 0) {\n\t\tif (inertial_nav.get_altitude_cm() > _guided_limit.max_altitude_cm) {\n\t\t\taltitude_exceeded = true;\n\t\t}\n\t}\n\n\tif (_guided_limit.max_horizontal_distance_cm > 0) {\n\t\tVector2f curr_pos = inertial_nav.get_position_xy_cm();\n\t\tfloat horizontal_distance = get_horizontal_distance_cm(_guided_limit.start_pos.xy, curr_pos);\n\n\t\tif (horizontal_distance > _guided_limit.max_horizontal_distance_cm) {\n\t\t\thorizontal_distance_exceeded = true;\n\t\t}\n\t}\n\n\tif (_guided_limit.max_vertical_distance_cm > 0) {\n\t\tfloat vertical_distance = abs(inertial_nav.get_altitude_cm() - _guided_limit.start_pos.z);\n\n\t\tif (vertical_distance > _guided_limit.max_vertical_distance_cm) {\n\t\t\tvertical_distance_exceeded = true;\n\t\t}\n\t}\n\n\tif (timeout_exceeded || altitude_exceeded || horizontal_distance_exceeded || vertical_distance_exceeded) {\n\t\tret = true;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 33.499530626888244}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check if we have reached the timeout\n\tif (AP_HAL::millis() > guided_limit.timeout) {\n\t\treturn true;\n\t}\n\n\t// check if we have reached the altitude limit\n\tif (inertial_nav.get_altitude_cm() < guided_limit.altitude_min_cm || inertial_nav.get_altitude_cm() > guided_limit.altitude_max_cm) {\n\t\treturn true;\n\t}\n\n\t// check if we have reached the horizontal distance limit\n\tVector2f curr_pos = inertial_nav.get_position_neu_cm();\n\tfloat horizontal_distance = get_horizontal_distance_cm(guided_limit.start_pos, curr_pos);\n\tif (horizontal_distance > guided_limit.horizontal_distance_max_cm) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 44.824936853840406}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if we have exceeded the timeout\n\tif (guided_limit.timeout_ms!= 0 && (AP_HAL::millis() - guided_limit.start_time) > guided_limit.timeout_ms) {\n\t\t// we have exceeded the timeout\n\t\treturn true;\n\t}\n\n\t// Check if we have exceeded the altitude limits\n\tif (guided_limit.min_altitude_cm!= 0 && (guided_limit.start_pos.z - inertial_nav.get_altitude_cm()) > guided_limit.min_altitude_cm) {\n\t\t// we have exceeded the minimum altitude\n\t\treturn true;\n\t}\n\tif (guided_limit.max_altitude_cm!= 0 && (guided_limit.start_pos.z - inertial_nav.get_altitude_cm()) < guided_limit.max_altitude_cm) {\n\t\t// we have exceeded the maximum altitude\n\t\treturn true;\n\t}\n\n\t// Check if we have exceeded the horizontal distance limit\n\tif (guided_limit.max_distance_cm!= 0 && get_horizontal_distance_cm(guided_limit.start_pos.x, guided_limit.start_pos.y, inertial_nav.get_position_neu_cm().x, inertial_nav.get_position_neu_cm().y) > guided_limit.max_distance_cm) {\n\t\t// we have exceeded the horizontal distance limit\n\t\treturn true;\n\t}\n\n\t// We haven't exceeded any limits\n\treturn false;\n}", "CodeBleu_score": 52.97592813632798}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// Check if the motor test requests have timed out\n\tif (millis() - motor_test_request_timer > MOTOR_TEST_TIMEOUT) {\n\t\t// Send a timeout message\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n\n\t\t// Set the pass flag to false\n\t\tmotor_test_pass = false;\n\n\t\t// Disable the motor test\n\t\tdisable_motor_test();\n\n\t\t// Disarm the system\n\t\tAP::arming().disarm();\n\n\t\t// Record the failure time\n\t\tmotor_test_failure_time = millis();\n\n\t\t// Return false\n\t\treturn false;\n\t}\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 38.15950257994968}, {"code": "bool Sub::verify_motor_test(){\n\t\t// If the motor test has timed out, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false.\n\tif (AP_HAL::millis() - _motor_test_start_time > _motor_test_timeout) {\n\t\tgcs().send_text_P(SEVERITY_LOW, PSTR(\"Motor test timed out\"));\n\t\t_motor_test_pass = false;\n\t\t_motor_test_enabled = false;\n\t\tAP::arming().disarm();\n\t\t_motor_test_failure_time = AP_HAL::millis();\n\t\treturn false;\n\t}\n\n\t// If the motor test has received a request, return true.\n\tif (_motor_test_request_received) {\n\t\treturn true;\n\t}\n\n\t// If the motor test has not received a request, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false.\n\tgcs().send_text_P(SEVERITY_LOW, PSTR(\"Motor test timed out\"));\n\t_motor_test_pass = false;\n\t_motor_test_enabled = false;\n\tAP::arming().disarm();\n\t_motor_test_failure_time = AP_HAL::millis();\n\treturn false;\n}", "CodeBleu_score": 52.74150292254316}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (millis() - motor_test_time > 2000) {\n\t\tgcs().send_text(SEVERITY_LOW, \"Motor test timed out.\");\n\t\tpass = false;\n\t\tmotor_test_enabled = false;\n\t\tAP::arming().disarm();\n\t\tmotor_test_failure_time = millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.40767804811741}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get the current roll and pitch targets from wp_nav\n\tint16_t wp_nav_roll_target = wp_nav.get_roll();\n\tint16_t wp_nav_pitch_target = wp_nav.get_pitch();\n\n\t// Constrain the roll and pitch targets to a maximum angle range\n\tint16_t wp_nav_roll_target_c = constrain_int16(wp_nav_roll_target, -MAX_WPNAV_ANGLE, MAX_WPNAV_ANGLE);\n\tint16_t wp_nav_pitch_target_c = constrain_int16(wp_nav_pitch_target, -MAX_WPNAV_ANGLE, MAX_WPNAV_ANGLE);\n\n\t// Normalize the roll and pitch targets to the range -10000 to 10000\n\tfloat wp_nav_roll_target_n = (float)wp_nav_roll_target_c * 10000.0f / MAX_WPNAV_ANGLE;\n\tfloat wp_nav_pitch_target_n = (float)wp_nav_pitch_target_c * 10000.0f / MAX_WPNAV_ANGLE;\n\n\t// Assign the normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = wp_nav_roll_target_n;\n\tforward_out = wp_nav_pitch_target_n;\n}", "CodeBleu_score": 36.89355634797232}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// get roll and pitch targets from wp_nav\n\tint16_t roll_target_cd = wp_nav.get_roll();\n\tint16_t pitch_target_cd = wp_nav.get_pitch();\n\n\t// constrain roll and pitch targets\n\troll_target_cd = constrain_int16(roll_target_cd, -MAX_ROLL_CD, MAX_ROLL_CD);\n\tpitch_target_cd = constrain_int16(pitch_target_cd, -MAX_PITCH_CD, MAX_PITCH_CD);\n\n\t// normalize roll and pitch targets\n\tfloat roll_target_norm = (float)roll_target_cd / MAX_ROLL_CD;\n\tfloat pitch_target_norm = (float)pitch_target_cd / MAX_PITCH_CD;\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n}", "CodeBleu_score": 44.46645972942295}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tint16_t roll_target_cd = wp_nav.get_roll();\n\tint16_t pitch_target_cd = wp_nav.get_pitch();\n\n\troll_target_cd = constrain_int16(roll_target_cd, -MAX_ANGLE_CD, MAX_ANGLE_CD);\n\tpitch_target_cd = constrain_int16(pitch_target_cd, -MAX_ANGLE_CD, MAX_ANGLE_CD);\n\n\t// normalize targets to -10000 to 10000\n\tlateral_out = (float)roll_target_cd / 100.0f;\n\tforward_out = (float)pitch_target_cd / 100.0f;\n}", "CodeBleu_score": 46.5395201931485}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (depth_sensor_present) {\n\t\tdepth_sensor_healthy = barometer.healthy();\n\t}\n}", "CodeBleu_score": 58.86053760564147}, {"code": "void Sub::read_barometer(){\n\t\tbarometer.update();\n\tif(barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif(depth_sensor.is_present()) {\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 61.08537500696504}, {"code": "void Sub::read_barometer(){\n\t\tbarometer.update();\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor) {\n\t\tdepth_sensor->update_health(barometer.healthy);\n\t}\n}", "CodeBleu_score": 66.41970862416595}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\t// check if inertial navigation is available\n\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\n\t// if the motors are disarmed, we accept a predicted horizontal position\n\tif (!motors.armed()) {\n\t\treturn true;\n\t}\n\n\t// if the motors are armed, we require a good absolute position and ensure the EKF is not in constant position mode\n\tif (ahrs.get_filter_status() == 3 && ahrs.get_filter_status() == 3) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 46.354726182582674}, {"code": "bool Sub::ekf_position_ok(){\n\t\treturn ahrs.have_inertial_nav() &&\n\t       (motors.armed()? (ekf_pos_valid() &&!ekf_const_pos_mode()) : (ekf_pos_valid() || ekf_pos_pred_ok()));\n}", "CodeBleu_score": 24.081868333757477}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// check if inertial navigation is available\n\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\n\t// check if motors are armed\n\tif (motors.armed()) {\n\t\t// require a good absolute position\n\t\tif (!ahrs.have_good_abs_pos()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// require EKF to not be in constant position mode\n\t\tif (inertial_nav.get_filter_status() == INAV_CONSTANT_POS) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// require a predicted horizontal position\n\t\tif (!ahrs.have_good_horz_pos()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 46.87987283099267}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!control_mode->requires_position() &&!control_mode->requires_velocity()) {\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.pre_arm_check(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_ok(display_failure)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.472035393307}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if the current control mode does not require position or velocity, return true\n\tif(!rover.control_mode->requires_position() &&!rover.control_mode->requires_velocity() ) {\n\t\treturn true;\n\t}\n\n\t// call the parent class's GPS checks\n\tif(!AP_Arming::gps_checks(display_failure) ) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready and if the EKF failsafe is active\n\tif(!ahrs.ready_to_arm() ||!ahrs.pre_arm_check(display_failure) ) {\n\t\treturn false;\n\t}\n\n\t// ensure the position estimate is valid\n\tif(!rover.ekf_position_ok() ) {\n\t\tif( display_failure ) {\n\t\t\tAP_Notify::flags.arming_check_failed = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 40.12700938020163}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!requires_position() &&!requires_velocity()) {\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.ready_to_arm() ||!ahrs.pre_arm_check(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_ok()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 32.22479747047891}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (!is_armed()) {\n\t\t// arm the motors\n\t\tif (do_arming_checks &&!arming_checks()) {\n\t\t\t// arming checks failed\n\t\t\treturn false;\n\t\t}\n\t\t// set armed flag\n\t\t_armed = true;\n\t\t// update soft armed status\n\t\tupdate_soft_armed();\n\t\t// set home position for SmartRTL\n\t\tg.smart_rtl.set_home();\n\t\t// initialize simple mode heading\n\t\tg.mode_simple.init_heading();\n\t\t// record home heading for sail vehicles\n\t\tg.windvane.record_home_heading();\n\t\t// send arm/disarm status text\n\t\tsend_arm_disarm_statustext();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 40.677557724035324}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\t// TODO: Add a delay to the charging enable/disable\n\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_disabled_time = 0;\n\t\t} else {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t} else if (millis() - charging_disabled_time > CHARGING_ENABLE_DELAY) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_disabled_time = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 45.828993250023615}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tif (charging_enabled) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (!charging_enabled) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, HIGH);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, LOW);\n\t\t\tcharging_disabled_time = millis();\n\t\t} else if (millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n\t\t\tdigitalWrite(CHARGE_ENABLE_PIN, HIGH);\n\t\t}\n\t}\n}", "CodeBleu_score": 62.094634828579444}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tcharging_enabled = true;\n\t\t\tdigitalWrite(CHARGING_ENABLE_PIN, HIGH);\n\t\t\tcharging_enabled_at = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tif (millis() - charging_enabled_at > CHARGING_ENABLED_DELAY) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tdigitalWrite(CHARGING_ENABLE_PIN, LOW);\n\t\t\t\tcharging_enabled_at = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (millis() - charging_disabled_at > CHARGING_DISABLED_DELAY) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tdigitalWrite(CHARGING_ENABLE_PIN, HIGH);\n\t\t\t\tcharging_enabled_at = millis();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 57.43355520766489}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tmemcpy(message + size, &crc, 2);\n\t\tpacketSerial.send(message, size + 2);\n\t}\n}", "CodeBleu_score": 30.202966365724993}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\t// Calculate CRC\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\n\t\t// Append CRC to message\n\t\tmemcpy((uint8_t *) message + size, &crc, 2);\n\n\t\t// Send message\n\t\tpacketSerial.send(message, size + 2);\n\t}\n}", "CodeBleu_score": 35.26893643205989}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif(ros::isStarted() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tmemcpy(message + size, &crc, 2);\n\t\tpacketSerial.send(message, size + 2);\n\t}\n}", "CodeBleu_score": 29.955988088018557}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tint numFiles = 0;\n\tbool success = false;\n\t// Clear the serial buffer\n\twhile (soundSerial.available()) {\n\t\tsoundSerial.read();\n\t}\n\t// Initialize the sound module\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0xFF);\n\tsoundSerial.write(0x06);\n\tsoundSerial.write(0x09);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0x01);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\t// Wait for the sound module to respond\n\tdelay(100);\n\t// Check if the sound module responded\n\tif (soundSerial.available()) {\n\t\tif (soundSerial.read() == 0x7E) {\n\t\t\tif (soundSerial.read() == 0xFF) {\n\t\t\t\tif (soundSerial.read() == 0x06) {\n\t\t\t\t\tif (soundSerial.read() == 0x09) {\n\t\t\t\t\t\tif (soundSerial.read() == 0x00) {\n\t\t\t\t\t\t\tif (soundSerial.read() == 0x00) {\n\t\t\t\t\t\t\t\tif (soundSerial.read() == 0x01) {\n\t\t\t\t\t\t\t\t\tif (soundSerial.read() == 0x00) {\n\t\t\t\t\t\t\t\t\t\tif (soundSerial.read() == 0xEF) {\n\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// If the sound module responded, get the number of sound files available\n\tif (success) {\n\t\tnumFiles = numSdTracks();\n\t\tif (numFiles > 0) {\n\t\t\tsuccess = true;\n\t\t}\n\t}\n\treturn success;\n}", "CodeBleu_score": 45.56292346294356}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t\t// Initialize serial communication for sound module\n\tsoundSerial.begin(9600);\n\t// Clear any existing data in the buffer\n\tsoundSerial.flush();\n\t// Initialize sound module\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0xFF);\n\tsoundSerial.write(0x06);\n\tsoundSerial.write(0x09);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0x01);\n\tsoundSerial.write(0x01);\n\tsoundSerial.write(0xEF);\n\t// Wait for the sound module to respond\n\tdelay(500);\n\t// Read the response from the sound module\n\twhile (soundSerial.available() > 0) {\n\t\tsoundSerial.read();\n\t}\n\t// Get the number of sound files available on the SD card\n\tnumSdTracks = getNumSdTracks();\n\t// Check if there are one or more sound files available\n\tif (numSdTracks > 0) {\n\t\t// There are one or more sound files available\n\t\treturn true;\n\t} else {\n\t\t// There are no sound files available\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 47.88844789222849}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tplay();\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 38.385249386054845}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.320775072950724}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.320775072950724}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command\n\");\n#endif\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (d->camera->memory_mapped_file!= NULL)\n        wb_camera_memory_mapped_file_cleanup(d);\n      wb_camera_memory_mapped_file_setup(d, r);\n      break;\n    }\n    default:\n      return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 40.93141513625093}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command: command=%d\n\", command);\n#endif\n  bool command_handled = true;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      image_cleanup();\n      image_setup();\n      break;\n    }\n    default:\n      command_handled = false;\n      break;\n  }\n\n  return command_handled;\n}", "CodeBleu_score": 64.2621798619265}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command: command=%d\n\", command);\n#endif\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_camera_memory_mapped_file(d, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 39.706679607465674}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG_FUNCTIONS\n  printf(\"wb_abstract_camera_get_height called\n\");\n#endif\n  robot_mutex_lock();\n  int result = -1;\n  if (d->data!= NULL)\n    result = ((WbAbstractCameraData *)d->data)->height;\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 57.44822154555042}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\n// robot_mutex_lock\n\nint height = -1;\nWbAbstractCamera *ac = (WbAbstractCamera *)d;\n\nif (ac->data) {\n  height = ac->data->height;\n}\n\n// robot_mutex_unlock\n\nreturn height;\n}", "CodeBleu_score": 42.28335454693372}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\n}", "CodeBleu_score": 2.077146505380476}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\n}", "CodeBleu_score": 2.593863874143837}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n  robot_mutex_lock();\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER);\n  int sampling_period = 0;\n  if (d)\n    sampling_period = ((WbAccelerometer *)d)->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag=%d\n\", __FUNCTION__, tag);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 61.73238680510804}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\n\trobot_mutex_lock();\n\tAccelerometer *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n\t}\n\trobot_mutex_unlock();\n\n\treturn sampling_period;\n}", "CodeBleu_score": 53.907190523533224}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *degreesMinutesSeconds = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(degreesMinutesSeconds);\n\tfree(degreesMinutesSeconds);\n\treturn dmsString;\n}", "CodeBleu_score": 42.39168389352911}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *result = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms = result;\n\tfree(result);\n\treturn dms;\n}", "CodeBleu_score": 42.129641847859325}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 38.166184039894674}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdUASSERT (plane, \"plane argument is null\");\n\n\tconst dReal *side = ((dxBox*)g)->side;\n\tconst dReal *pos = g->posr.pos;\n\tconst dReal *R = g->posr.R;\n\tdVector3 p;\n\tp[0] = x - pos[0];\n\tp[1] = y - pos[1];\n\tp[2] = z - pos[2];\n\tdVector3 q;\n\tq[0] = dCalcVectorDot3_41(R+0, p);\n\tq[1] = dCalcVectorDot3_41(R+1, p);\n\tq[2] = dCalcVectorDot3_41(R+2, p);\n\tdReal dist = dInfinity;\n\tint i;\n\tfor (i=0; i<3; i++) {\n\t\tif (q[i] < -side[i]) {\n\t\t\tdReal d = q[i] + side[i];\n\t\t\tif (d < dist) {\n\t\t\t\tdist = d;\n\t\t\t\tplane[0] = R[i*4+0];\n\t\t\t\tplane[1] = R[i*4+1];\n\t\t\t\tplane[2] = R[i*4+2];\n\t\t\t\tplane[3] = dCalcVectorDot3_41(R+i*4, pos) - side[i];\n\t\t\t}\n\t\t} else if (q[i] > side[i]) {\n\t\t\tdReal d = q[i] - side[i];\n\t\t\tif (d < dist) {\n\t\t\t\tdist = d;\n\t\t\t\tplane[0] = -R[i*4+0];\n\t\t\t\tplane[1] = -R[i*4+1];\n\t\t\t\tplane[2] = -R[i*4+2];\n\t\t\t\tplane[3] = -dCalcVectorDot3_41(R+i*4, pos) - side[i];\n\t\t\t}\n\t\t}\n\t}\n\tdUASSERT (dist!= dInfinity, \"point not inside box\");\n}", "CodeBleu_score": 46.53857410007694}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdUASSERT (plane, \"bad argument\");\n\n\tconst dReal* side = dGeomBoxGetLengths (g);\n\tconst dReal* pos = dGeomGetPosition (g);\n\tconst dReal* R = dGeomGetRotation (g);\n\tconst dReal* p = dGeomBoxGetCenterOfGravity (g);\n\n\tdVector3 p_rel;\n\tp_rel[0] = x - pos[0];\n\tp_rel[1] = y - pos[1];\n\tp_rel[2] = z - pos[2];\n\tdMULTIPLY1_331 (p_rel, R, p_rel);\n\tp_rel[0] -= p[0];\n\tp_rel[1] -= p[1];\n\tp_rel[2] -= p[2];\n\n\t// find the axis with the shortest distance to the point\n\tdReal dist = dFabs (p_rel[0]);\n\tint axis = 0;\n\tdReal dist1 = dFabs (p_rel[1]);\n\tif (dist1 < dist) {\n\t\tdist = dist1;\n\t\taxis = 1;\n\t}\n\tdReal dist2 = dFabs (p_rel[2]);\n\tif (dist2 < dist) {\n\t\tdist = dist2;\n\t\taxis = 2;\n\t}\n\n\t// if the point is outside the box, the normal will point inside\n\tif (p_rel[axis] < 0) {\n\t\tp_rel[axis] = -p_rel[axis];\n\t}\n\n\t// set the plane's normal\n\tplane[0] = plane[1] = plane[2] = 0;\n\tplane[axis] = 1;\n\tdMULTIPLY0_331 (plane, R, plane);\n\n\t// set the plane's distance\n\tplane[3] = side[axis] * 0.5 - p_rel[axis];\n}", "CodeBleu_score": 41.717150066162965}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box->body,\"immersion checking requires a body\");\ndUASSERT (flags >= 0 && flags < dImmersionFlagsMax,\"invalid flags\");\nsBoxImmersionData data (box,fluidPlane,flags,immersion);\ndata.performImmersionChecking\nreturn data.result;\n}", "CodeBleu_score": 56.83915849153258}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT(box->body, \"box has no body\");\ndUASSERT(flags & (dIMMERSE_INSIDE|dIMMERSE_OUTSIDE), \"invalid flags\");\nsBoxImmersionData data(box, fluidPlane, immersion, flags);\ndata.performImmersionChecking();\ndIASSERT(data.immersion!= NULL);\nreturn data.immersion->result;\n}", "CodeBleu_score": 63.541886647454234}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box->body, \"dImmerseBox: box has no body\");\n\tdUASSERT (flags & dIMMERSE_VALID_FLAGS, \"dImmerseBox: flags are invalid\");\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.immersion = immersion;\n\tdata.flags = flags;\n\tdata.performImmersionChecking = &performImmersionChecking;\n\tdata.dIASSERT = &dIASSERT;\n\tdata.dUASSERT = &dUASSERT;\n\tdata.performImmersionChecking(&data);\n\treturn data.result;\n}", "CodeBleu_score": 47.627055956837836}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t#if 0\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 28.720204175401726}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\t// The first part of the integration is from zI to zO.\n\tsHemisphereIntegrationData data1(zIOverR, tanTheta0, sinTheta1);\n\tdReal V1 = sHemisphereVolumeIntegrand(0.0, data1);\n\tV1 += 4.0 * sHemisphereVolumeIntegrand(0.5, data1);\n\tV1 += sHemisphereVolumeIntegrand(1.0, data1);\n\tV1 *= 0.5 * data1.dz;\n\n\t// The second part of the integration is from zO to zO + zI.\n\tsHemisphereIntegrationData data2(zIOverR, tanTheta0, sinTheta1);\n\tdReal V2 = sHemisphereVolumeIntegrand(0.0, data2);\n\tV2 += 4.0 * sHemisphereVolumeIntegrand(0.5, data2);\n\tV2 += sHemisphereVolumeIntegrand(1.0, data2);\n\tV2 *= 0.5 * data2.dz;\n\n\treturn V1 + V2;\n}", "CodeBleu_score": 31.999900517759418}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\txBuoyancyCenterData.zIOverR = zIOverR;\n\txBuoyancyCenterData.tanTheta0 = tanTheta0;\n\txBuoyancyCenterData.sinTheta1 = sinTheta1;\n\txBuoyancyCenterData.volume = volume;\n\txBuoyancyCenterData.radius = radius;\n\txBuoyancyCenterData.length = length;\n\txBuoyancyCenterData.density = density;\n\txBuoyancyCenterData.gravity = gravity;\n\txBuoyancyCenterData.gravityDirection = gravityDirection;\n\treturn simpson<xBuoyancyCenterData, &xBuoyancyCenterData::xBuoyancyCenterIntegrand>(xBuoyancyCenterData);\n}", "CodeBleu_score": 35.03085081291991}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData hemisphereData(zIOverR, tanTheta0, sinTheta1);\n\tdReal xCenterOfMass = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(hemisphereData);\n\treturn xCenterOfMass + volume;\n}", "CodeBleu_score": 37.89664990407567}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData hemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1);\n\tdReal xBCOverR = simpson(hemisphereIntegrationData, 0.0, M_PI / 2.0, 1000) / volume;\n\treturn xBCOverR;\n}", "CodeBleu_score": 31.57894872396612}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a trimesh\");\n\n\tsCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 25.100205604635047}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t#ifdef ODE_MT\n  dAASSERT(ode::mt::is_locked());\n#endif\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  const dxCapsule *capsule = (dxCapsule*) o1;\n  const dxTriMesh *trimesh = (dxTriMesh*) o2;\n\n  sCapsuleTrimeshImmersionData data(capsule, trimesh, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 35.56387859679209}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdIASSERT (o1->type == dCapsuleClass);\n\tdIASSERT (o2->type == dTriMeshClass);\n\n\tdxCapsule *capsule = (dxCapsule*) o1;\n\tdxTriMesh *trimesh = (dxTriMesh*) o2;\n\n\tsCapsuleImmersionData data(capsule, trimesh, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 34.11495565790579}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration from the input\n\tconst auto duration_input = input<std::chrono::milliseconds>(0);\n\tif (!duration_input) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tconst auto duration = *duration_input;\n\n\t// If the duration is non-positive, return SUCCESS\n\tif (duration <= std::chrono::milliseconds(0)) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING and start a timer\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_.add(duration, [this]() {\n\t\t// Emit a wake-up signal when the timer expires\n\t\temitWakeUpSignal();\n\t});\n\n\t// Set a callback to reset the timer_waiting_ flag when the timer is aborted\n\ttimer_.setAbortCallback([this]() {\n\t\ttimer_waiting_ = false;\n\t});\n\n\t// Set the timer_waiting_ flag to true to indicate that the node is waiting for the timer to expire\n\ttimer_waiting_ = true;\n\n\t// Return RUNNING to indicate that the node is still running\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 48.31059411657637}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration from the input\n\tauto duration = getInput<std::chrono::milliseconds>(\"duration\");\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (!duration || duration->count() <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// Otherwise, set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\t// Start a timer with the duration and a callback to emit a wake-up signal\n\ttimer_.add(duration->count(), [this]() { emitWakeUpSignal(); });\n\t// Set a callback to reset the timer_waiting_ flag when the timer is aborted\n\ttimer_.setAbortCallback([this]() { timer_waiting_ = false; });\n\t// Return RUNNING to indicate the node is still running\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.25038585643273}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration in milliseconds from the input\n\tauto duration = getInput<std::chrono::milliseconds>(\"duration\");\n\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (!duration.has_value() || duration.value().count() <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer with the sleep duration\n\ttimer_.add(duration.value(), [this]() {\n\t\t// Emit a wake-up signal when the timer expires\n\t\temitWakeUpSignal();\n\n\t\t// Ensure the timer_waiting_ flag is reset\n\t\ttimer_waiting_ = false;\n\t});\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_waiting_ = true;\n\n\t// Return RUNNING\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.05859591643959}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard and lock its mutex.\n\tauto entry = config().blackboard->getEntry(entry_name_);\n\tentry->lock();\n\t// Compare the current sequence ID with the previously stored sequence ID.\n\tif (entry->sequenceID()!= sequence_id_) {\n\t\t// Update the stored sequence ID and return SUCCESS.\n\t\tsequence_id_ = entry->sequenceID();\n\t\tentry->unlock();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// If the IDs are the same or the entry is not found, return FAILURE.\n\tentry->unlock();\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 31.737138949080702}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard->isEntryRegistered(entryName)) {\n\t\t// Retrieve the entry and lock its mutex\n\t\tEntry<T>& entry = blackboard->getEntry<T>(entryName);\n\t\tentry.lock();\n\n\t\t// Compare the sequence ID with the previously stored one\n\t\tif (entry.sequenceID!= sequenceID) {\n\t\t\t// Update the stored sequence ID and return SUCCESS\n\t\t\tsequenceID = entry.sequenceID;\n\t\t\tentry.unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\n\t\t// Unlock the mutex and return FAILURE\n\t\tentry.unlock();\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// If the entry is not found, return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 39.74433386822274}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tstd::unique_lock<std::mutex> lock;\n\tif (!retrieveEntry(lock)) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Check if the sequence ID has changed\n\tif (lock->getSequenceID()!= sequenceID) {\n\t\tsequenceID = lock->getSequenceID();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 33.12378457218546}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size() + success_threshold_;\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.92709212356128}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size() + success_threshold_;\n\t} else {\n\t\treturn success_threshold_;\n\t}\n}", "CodeBleu_score": 54.734165875225614}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size() + success_threshold_;\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.92709212356128}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\tstd::chrono::milliseconds sleep_time(10);\n\twhile(true) {\n\t\tstd::this_thread::sleep_for(sleep_time);\n\t\tbool heartbeat_active = _p->heartbeat_active;\n\t\tbool heartbeat_active_old = _p->heartbeat_active_old;\n\t\tif(heartbeat_active!= heartbeat_active_old) {\n\t\t\t_p->heartbeat_active_old = heartbeat_active;\n\t\t\tenableAllHooks(!heartbeat_active);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.626362471747115}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\t\tfor (auto& [node_uid, hook] : _p->pre_hooks) {\n\t\t\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\t\t\tif (hook->mode == Monitor::Hook::Mode::HEARTBEAT) {\n\t\t\t\tif (hook->enabled && (std::chrono::system_clock::now() - hook->last_heartbeat) > std::chrono::milliseconds(1000)) {\n\t\t\t\t\thook->enabled = false;\n\t\t\t\t\thook->wakeup.notify_all();\n\t\t\t\t} else if (!hook->enabled && (std::chrono::system_clock::now() - hook->last_heartbeat) < std::chrono::milliseconds(1000)) {\n\t\t\t\t\thook->enabled = true;\n\t\t\t\t\thook->wakeup.notify_all();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.220115587961736}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tbool heartbeat_active = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - _p->last_heartbeat).count() < 1000;\n\t\tif (heartbeat_active!= _p->heartbeat_active) {\n\t\t\t_p->heartbeat_active = heartbeat_active;\n\t\t\tenableAllHooks(!heartbeat_active);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.347124333203354}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tnlohmann::json j;\n\tstd::vector<std::string> bb_names;\n\tBT::splitString(bb_list, ',', bb_names);\n\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tauto subtree = it->second.lock();\n\t\t\tif (subtree) {\n\t\t\t\tj[bb_name] = ExportBlackboardToJSON(subtree);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nlohmann::json::to_msgpack(j);\n}", "CodeBleu_score": 58.40856116053015}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tnlohmann::json json;\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\n\tfor (const std::string& bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tstd::shared_ptr<Blackboard> bb = it->second.lock();\n\t\t\tif (bb) {\n\t\t\t\tjson[bb_name] = ExportBlackboardToJSON(*bb);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nlohmann::json::to_msgpack(json);\n}", "CodeBleu_score": 61.89581844865355}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<std::string> bbs = splitString(bb_list, ',');\n\tnlohmann::json j;\n\tfor (auto bb : bbs) {\n\t\tauto _p = blackboards.find(bb);\n\t\tif (_p!= blackboards.end()) {\n\t\t\tauto _it = _p->second.lock();\n\t\t\tif (_it) {\n\t\t\t\tj[bb] = ExportBlackboardToJSON(_it);\n\t\t\t}\n\t\t}\n\t}\n\treturn nlohmann::json::to_msgpack(j);\n}", "CodeBleu_score": 48.83379459615219}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t/  std::cout << \"unlockBreakpoint\" << std::endl;\n  auto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  lk.unlock();\n  std::unique_lock<std::mutex> lk2(hook->mutex);\n  if(hook->status == Hook::BREAKPOINT)\n  {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready.store(true);\n    hook->ready_cond.notify_all();\n  }\n  return true;\n}", "CodeBleu_score": 54.73671937323267}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif(bk_it == hooks->end())\n\t{\n\t\treturn false;\n\t}\n\tauto& hook = bk_it->second;\n\tif(hook->status == Hook::Status::INVALID)\n\t{\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> hook_lk(hook->mutex);\n\tif(hook->status == Hook::Status::BREAKPOINT)\n\t{\n\t\thook->status = result;\n\t\thook->remove = remove;\n\t\thook->ready = true;\n\t\thook->cv.notify_all();\n\t}\n\treturn true;\n}", "CodeBleu_score": 56.24281798156109}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif (bk_it == hooks->end()) {\n\t\treturn false;\n\t}\n\tauto hook = bk_it->second;\n\tlk.unlock();\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\tif (hook->state!= Hook::State::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->state = Hook::State::READY;\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready.notify_all();\n\treturn true;\n}", "CodeBleu_score": 53.556020342792245}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_ = false;\n\t\tasync_result_ = std::async(std::launch::async, &ThreadedAction::tick, this);\n\t}\n\n\ttry {\n\t\tNodeStatus status = async_result_.get();\n\t\tif (status!= prev_status) {\n\t\t\tsetStatus(status);\n\t\t}\n\t} catch (...) {\n\t\tLOG_ERROR(\"Exception caught in ThreadedAction::executeTick()\");\n\t\tsetStatus(NodeStatus::IDLE);\n\t\tthrow;\n\t}\n\n\tif (async_result_.valid()) {\n\t\ttry {\n\t\t\tstd::rethrow_exception(async_result_.get_future().get_exception());\n\t\t} catch (...) {\n\t\t\tLOG_ERROR(\"Exception caught in ThreadedAction::executeTick()\");\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 44.46695945963448}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_.store(false);\n\t\tthread_ = std::async(std::launch::async, [this]() {\n\t\t\ttry {\n\t\t\t\tNodeStatus status = tick_functor_(*this);\n\t\t\t\tif (status!= NodeStatus::IDLE) {\n\t\t\t\t\tsetStatus(status);\n\t\t\t\t}\n\t\t\t} catch (...) {\n\t\t\t\tLOG_ERROR_STREAM(\"Exception in ThreadedAction: \" << name());\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (thread_.valid()) {\n\t\tif (thread_.wait_for(std::chrono::milliseconds(0)) == std::future_status::ready) {\n\t\t\tthread_.get();\n\t\t\tthread_ = std::future<void>();\n\t\t}\n\t}\n\n\tif (halt_requested_.load()) {\n\t\thalt_requested_.store(false);\n\t\tsetStatus(NodeStatus::IDLE);\n\t}\n\n\tif (status()!= prev_status) {\n\t\temitWakeUpSignal();\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 47.93902089760434}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\ttry {\n\t\t\tasync_result_ = std::async(std::launch::async, &BT::ThreadedAction::tick, this);\n\t\t} catch (std::exception& e) {\n\t\t\tLOG_ERROR << \"Exception in async call: \" << e.what();\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\n\tif (async_result_.valid()) {\n\t\ttry {\n\t\t\tNodeStatus status = async_result_.get();\n\t\t\tif (status!= prev_status) {\n\t\t\t\tsetStatus(status);\n\t\t\t}\n\t\t} catch (std::exception& e) {\n\t\t\tLOG_ERROR << \"Exception in async call: \" << e.what();\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\n\tif (stored_exception_) {\n\t\tstd::rethrow_exception(stored_exception_);\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 47.997988507900814}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Define a lambda function to handle the printing recursively\n\tauto print_node = [&](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"  \";\n\t\t}\n\n\t\t// Print the node's name\n\t\tstream << node->name << std::endl;\n\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (const auto control = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto child : control->children) {\n\t\t\t\tprint_node(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (const auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint_node(decorator->child, depth + 1);\n\t\t}\n\t};\n\n\t// Print the root node\n\tstream << \"Root Node:\" << std::endl;\n\tprint_node(root_node, 1);\n\tstream << \"End of Tree\" << std::endl;\n}", "CodeBleu_score": 46.828953430572184}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Lambda function to recursively print the tree structure\n\tauto printNode = [&stream](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\n\t\t// Print the node's name\n\t\tstream << node->name << std::endl;\n\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprintNode(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprintNode(decorator->child, depth + 1);\n\t\t}\n\t};\n\n\t// Begin and end with separator lines\n\tstream << \"---------------------------------------------\" << std::endl;\n\tprintNode(root_node, 0);\n\tstream << \"---------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 53.50720426634936}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Lambda function to recursively print the tree structure\n\tauto printNode = [&](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"    \";\n\t\t}\n\t\t// Print the node's name\n\t\tstream << node->name() << \"\n\";\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (const auto* control = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children()) {\n\t\t\t\tprintNode(child.get(), depth + 1);\n\t\t\t}\n\t\t} else if (const auto* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprintNode(decorator->child().get(), depth + 1);\n\t\t}\n\t};\n\t// Begin and end with separator lines\n\tstream << \"====================\n\";\n\tprintNode(root_node, 0);\n\tstream << \"====================\n\";\n}", "CodeBleu_score": 44.55704438297971}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.54280928346758}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.54280928346758}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\n}", "CodeBleu_score": 7.736551633910178}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tauto it = builders.find(manifest.registration_ID);\n\tif (it!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"ID already registered\");\n\t}\n\n\tbuilders.insert(std::make_pair(manifest.registration_ID, builder));\n\tmanifests.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 54.9304506193975}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"ID already registered\");\n\t}\n\tmanifests.insert(std::make_pair(manifest.registration_ID, manifest));\n\tbuilders.insert(std::make_pair(manifest.registration_ID, builder));\n}", "CodeBleu_score": 48.688601546267705}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder already registered: \" + manifest.registration_ID);\n\t}\n\n\tmanifests.insert(std::make_pair(manifest.registration_ID, manifest));\n\tbuilders.insert(std::make_pair(manifest.registration_ID, builder));\n}", "CodeBleu_score": 50.985000694259696}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t//  registerBuilder(\n//      TreeNodeManifest{\n//          ID, \"SimpleAction\", ports,\n//          {\n//              { \"input_port\", \"input_port\", \"input_port\",\n//                \"input_port\" },\n//              { \"output_port\", \"output_port\", \"output_port\",\n//                \"output_port\" },\n//          }},\n//      [tick_functor](const std::string& name, const NodeConfig& config) {\n//        return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n//      });\n}", "CodeBleu_score": 10.819337351164709}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tregisterBuilder(\n    TreeNodeManifest{TreeNodeType::ACTION, ID, std::move(ports)},\n    [tick_functor](TreeNode* parent, const std::string& id,\n                   const std::string& name, const Blackboard::Ptr& blackboard,\n                   const NodeConfig& config) {\n      return std::make_unique<SimpleActionNode>(parent, id, name, blackboard,\n                                                config, tick_functor);\n    });\n}", "CodeBleu_score": 58.27701855521784}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t/*\n * This lambda function, builder, constructs a SimpleActionNode using the provided tick_functor and configuration. It creates a SimpleActionNode with the provided tick_functor and configuration, and returns it.\n */\n  auto builder = [tick_functor, ports](const std::string& name,\n                                       const NodeConfig& config) -> NodePtr {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n/*\n * This line creates a TreeNodeManifest with the action node type, ID, and ports list.\n */\n  auto manifest = TreeNodeManifest(NodeType::ACTION, ID, ports);\n\n/*\n * This line calls registerBuilder to register the manifest and builder.\n */\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 69.05526643710809}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tBlackboard::Ptr backup = subtree->blackboard->clone();\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 58.319337592682366}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& subtree : tree.subtrees) {\n\t\tBlackboard::Ptr sub = subtree->blackboard;\n\t\tBlackboard::Ptr backup = Blackboard::create();\n\t\tsub->cloneInto(backup);\n\t\tbb.push_back(backup);\n\t}\n\treturn bb;\n}", "CodeBleu_score": 65.38357178153076}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsubtree->blackboard->cloneInto(*bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 74.21495723889093}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\n}", "CodeBleu_score": 8.640850490544928}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (executor.has_value()) {\n\t\treturn executor.value()(env);\n\t} else {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.4374474730744}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value())\n\t{\n\t\treturn executor.value()(env);\n\t}\n\telse\n\t{\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.33243661481168}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 46.61983151096919}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 47.476978355195534}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (handle) {\n\t\tthrow RuntimeError(\"Shared library is already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tthis->path = path;\n}", "CodeBleu_score": 48.84506406433627}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str[0]!= '{' || str[str.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.slice(1, str.size - 1).trim();\n\t}\n\treturn true;\n}", "CodeBleu_score": 20.09968274997399}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim();\n\n\tif (stripped.size < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped[0]!= '{' || stripped[stripped.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.315973441784998}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.strip();\n\tif (stripped[0]!= '{' || stripped[stripped.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.slice(1, stripped.size - 1);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 21.837391626353728}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.num_steps_; i++, line.advance()) {\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\tif (point_cost < 0)\n\t\t\treturn point_cost;\n\t\tif (point_cost > line_cost)\n\t\t\tline_cost = point_cost;\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 65.43468011190797}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (unsigned int i = 0; i < line.count(); ++i, ++line) {\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t} else if (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 61.120194128811}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.num_steps_; ++i, line.advance()) {\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tif (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 61.622924763693476}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\n\t\tif (!path.empty()) {\n\t\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\t}\n\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 79.25448806576337}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\n\t\tif (!path.empty()) {\n\t\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\t}\n\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 79.25448806576337}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 63.0430762213567}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// Get the velocities from the odometry message\n\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\n\t// Check if the velocities are within the thresholds\n\tif (fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 51.70527274292665}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// Check if the robot is stopped based on its odometry data\n\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n\t\t\tfabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 62.88662630082088}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\t//avoid looping\n\t\tsetup_ = false;\n\t}\n\n\tboost::mutex::scoped_lock l(configuration_mutex_);\n\tlimits_ = config;\n}", "CodeBleu_score": 69.95767446975776}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = false;\n\t}\n\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tconfig_mutex_.lock();\n\tlimits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 59.84865254327825}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (check_cell->cost >= costmap.getObstacleCost()) {\n\t\tcheck_cell->target_distance = costmap.getObstacleCost();\n\t\treturn false;\n\t}\n\tdouble new_distance = current_cell->distance + check_cell->distance;\n\tif (new_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_distance;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.973821858407334}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Get the cost of the cell in the costmap.\n\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false.\n\tif (cost >= costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n\t\tcurrent_cell->target_distance = costmap_2d::LETHAL_OBSTACLE;\n\t\treturn false;\n\t}\n\t// If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter.\n\tdouble new_distance = hypot(current_cell->x - check_cell->x, current_cell->y - check_cell->y);\n\tif (new_distance < current_cell->target_distance) {\n\t\tcurrent_cell->target_distance = new_distance;\n\t}\n\t// Return true.\n\treturn true;\n}", "CodeBleu_score": 56.78395119032893}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false.\n\tif (check_cell->cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcheck_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\n\t// If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter.\n\tdouble new_distance = current_cell->distance + hypot(check_cell->x - current_cell->x, check_cell->y - current_cell->y);\n\tif (new_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_distance;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.335016658954366}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/  ROS_DEBUG(\"Scoring Trajectory with costs\");\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"No footprint points provided for costmap obstacle cost function\");\n    return -9;\n  }\n\n  for(unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    geometry_msgs::Point pt = traj.getPoint(i);\n    double footprint_cost = footprintCost(pt.x, pt.y, traj.thetas_[i], scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 63.337109907194936}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/  ROS_ERROR(\"scoreTrajectory\");\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"No footprint points provided for obstacle cost calculation\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double px = traj.getPoint(i).x;\n    double py = traj.getPoint(i).y;\n    double pth = traj.getPoint(i).th;\n    double footprint_cost = footprintCost(px, py, pth, scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 68.0659529633226}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//  ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory\");\n\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"No footprint points provided for costmap_2d::ObstacleCostFunction\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.getX(i), traj.getY(i), traj.getTheta(i), scale, footprint_spec_, costmap_, world_model_);\n\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 63.97714973599447}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//  std::vector<geometry_msgs::Point> scaled_footprint;\n  std::vector<costmap_2d::MapLocation> scaled_footprint;\n  // scale the footprint\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point new_point;\n    new_point.x = footprint_spec[i].x * scale;\n    new_point.y = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(new_point);\n  }\n\n  // check if the footprint is legal\n  if (costmap->footprintCost(x, y, th, scaled_footprint) == -1) {\n    return -6.0;\n  }\n\n  // now check if the center point of the robot is legal\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // check if the robot is in an off-map location...\n  unsigned int cell_x, cell_y;\n  if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n    return -7.0;\n  }\n\n  // we now have a legal footprint... lets get the cost\n  double point_cost = costmap->getCost(cell_x, cell_y);\n  if (point_cost == costmap_2d::LETHAL_OBSTACLE) {\n    return -5.0;\n  }\n\n  return std::max(footprint_cost, point_cost);\n}", "CodeBleu_score": 76.39792230150589}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  std::vector<geometry_msgs::Point> scaled_footprint;\n//  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n//    geometry_msgs::Point new_point;\n//    new_point.x = footprint_spec[i].x * scale;\n//    new_point.y = footprint_spec[i].y * scale;\n//    new_point.z = footprint_spec[i].z * scale;\n//    scaled_footprint.push_back(new_point);\n//  }\n\n//  double cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n//  if (cost < 0) {\n//    return -6.0;\n//  }\n\n//  unsigned int cell_x, cell_y;\n//  if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n//    return -7.0;\n//  }\n\n//  double max_cost = std::max(cost, double(costmap->getCost(cell_x, cell_y)));\n//  return max_cost;\n}", "CodeBleu_score": 8.490178557284024}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Setting the odometry topic to: %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    if (odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic %s\", odom_topic.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    else {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Unsubscribing from odometry topic %s\", odom_topic_.c_str());\n      odom_sub_.shutdown();\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic %s\", odom_topic.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 43.55569028226933}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_INFO_NAMED(\"dwa_local_planner\", \"Setting new odometry topic to %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to new odometry topic %s\", odom_topic.c_str());\n      odom_sub_.subscribe(nh_, odom_topic, 1);\n    } else {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Unsubscribing from odometry topic\");\n      odom_sub_.unsubscribe();\n    }\n  }\n}", "CodeBleu_score": 43.11624977312169}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t", "CodeBleu_score": 3.772375734787445}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//  ROS_DEBUG(\"resetOscillationFlagsIfPossible\");\n  // Check if the robot is oscillating.\n  // If it is, reset oscillation flags.\n  float dx = pos.x() - prev.x();\n  float dy = pos.y() - prev.y();\n  float dt = pos.z() - prev.z();\n\n  float dist_sq = dx * dx + dy * dy + dt * dt;\n  float angle = fabs(angles::shortest_angular_distance(pos.z(), prev.z()));\n\n  if (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_ ||\n      angle > oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 53.54961011967945}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//  ROS_DEBUG(\"resetOscillationFlagsIfPossible\");\n  double sq_dist = (pos - prev).squaredNorm();\n  if (sq_dist > sq_dist_threshold_) {\n    resetOscillationFlags();\n    return;\n  }\n  double yaw = tf2::getYaw(pos.cast<double>() - prev.cast<double>());\n  if (fabs(yaw) > yaw_threshold_) {\n    resetOscillationFlags();\n    return;\n  }\n}", "CodeBleu_score": 38.16930482490639}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// compute squared distance and angular difference\n\tfloat sq_dist = (pos - prev).squaredNorm();\n\tfloat rot_diff = fabs(angles::shortest_angular_distance(tf::getYaw(current_pose_.getRotation()), tf::getYaw(prev_pose_.getRotation())));\n\n\t// if distance or angle is too large, reset oscillation flags\n\tif (sq_dist > sq_dist_threshold_ || rot_diff > rot_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 33.28275211582639}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tunsigned int gx, gy;\n\t//get the grid coordinates of the point\n\tgridCoords(pt, gx, gy);\n\n\t//check if the point is too close to its nearest neighbor\n\tdouble neighbor_sq_dist = nearestNeighborDistance(pt);\n\tif(neighbor_sq_dist < sq_min_separation_)\n\t\treturn;\n\n\t//get the grid index\n\tunsigned int pt_index = gridIndex(gx, gy);\n\n\t//insert the point into the cell\n\tcells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 79.03650923829444}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//if the point is outside the grid, return\n\tif (gx >= width_ || gy >= height_)\n\t\treturn;\n\n\t//if the point is too close to its nearest neighbor, return\n\tdouble neighbor_sq_dist = nearestNeighborDistance(pt);\n\tif (neighbor_sq_dist < sq_min_separation_)\n\t\treturn;\n\n\t//get the grid index of the point\n\tunsigned int pt_index = gridIndex(gx, gy);\n\n\t//insert the point into the cell\n\tcells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 76.69819688798812}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//if the point is out of bounds or too close to its nearest neighbor, return\n\tif (gx >= width_ || gy >= height_ || nearestNeighborDistance(pt) < sq_min_separation_)\n\t\treturn;\n\n\t//get the grid index\n\tunsigned int pt_index = gridIndex(gx, gy);\n\n\t//insert the point into the corresponding cell\n\tcells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 80.73499671206528}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = vel[i];\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 74.59300887147134}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t\telse if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t\telse {\n\t\t\tnew_vel[i] = vel[i];\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 74.27671541159016}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 82.20100398776457}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = DBL_MAX;\n\tdouble world_x, world_y;\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\tif (lineCost(cell_x, global_plan_[i].x, cell_y, global_plan_[i].y) < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcostmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y, world_x, world_y);\n\t\tdiff = fabs(angles::shortest_angular_distance(heading, atan2(world_y - y, world_x - x)));\n\t\tbreak;\n\t}\n\treturn diff;\n}", "CodeBleu_score": 50.43619233354873}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble min_diff = DBL_MAX;\n\tint goal_x = 0;\n\tint goal_y = 0;\n\tdouble world_x = 0.0;\n\tdouble world_y = 0.0;\n\tdouble goal_angle = 0.0;\n\tdouble diff = 0.0;\n\tdouble line_cost = 0.0;\n\tdouble point_cost = 0.0;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\tgoal_x = global_plan_[i].x;\n\t\tgoal_y = global_plan_[i].y;\n\n\t\t// Check if the line of sight is clear\n\t\tline_cost = lineCost(cell_x, goal_x, cell_y, goal_y);\n\t\tif (line_cost < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Convert the goal cell coordinates to world coordinates\n\t\tcostmap_.mapToWorld(goal_x, goal_y, world_x, world_y);\n\n\t\t// Calculate the angle to the goal point\n\t\tgoal_angle = atan2(world_y - y, world_x - x);\n\n\t\t// Calculate the shortest angular distance between the current heading and the goal angle\n\t\tdiff = angles::shortest_angular_distance(heading, goal_angle);\n\n\t\t// Update the minimum difference if a smaller difference is found\n\t\tif (fabs(diff) < fabs(min_diff)) {\n\t\t\tmin_diff = diff;\n\t\t}\n\t}\n\n\treturn fabs(min_diff);\n}", "CodeBleu_score": 55.327215961023335}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t//This function calculates the difference in heading between the robot's current position and a goal point on the path.\n\t//It iterates through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\n\t//If a valid point is found, it converts the goal cell coordinates to world coordinates and returns the absolute value of the shortest angular distance between the current heading and the direction to the goal point.\n\t//If no valid point is found, it returns DBL_MAX.\n\n\tdouble goal_x = 0.0;\n\tdouble goal_y = 0.0;\n\tdouble goal_heading = 0.0;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Check if the current point has a clear line of sight from the robot's current cell\n\t\tif (lineCost(cell_x, global_plan_[i].x, cell_y, global_plan_[i].y) >= 0) {\n\t\t\t// Convert the goal cell coordinates to world coordinates\n\t\t\tgoal_x = global_plan_[i].x * costmap_.getResolution() + costmap_.getOriginX();\n\t\t\tgoal_y = global_plan_[i].y * costmap_.getResolution() + costmap_.getOriginY();\n\n\t\t\t// Calculate the heading to the goal point\n\t\t\tgoal_heading = atan2(goal_y - y, goal_x - x);\n\n\t\t\t// Return the absolute value of the shortest angular distance between the current heading and the goal heading\n\t\t\treturn fabs(angles::shortest_angular_distance(heading, goal_heading));\n\t\t}\n\t}\n\n\t// If no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 53.93881106153526}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//checkTrajectory\nROS_WARN\n\n    // compute the cost of the trajectory\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    // if the cost is negative, the trajectory is invalid\n    if(cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f (cost %f)\", vx_samp, vy_samp, vtheta_samp, cost);\n      return false;\n    }\n\n    // the trajectory is valid\n    return true;\n  }", "CodeBleu_score": 80.89156810438183}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//checkTrajectory\nROS_WARN\n\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    if (cost >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f (cost %f)\", vx_samp, vy_samp, vtheta_samp, cost);\n      return false;\n    }\n  }", "CodeBleu_score": 81.72129017554862}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global costmap passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tros::Time t0 = ros::WallTime::now();\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside of the area to clear\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside of the area to clear\");\n\t}\n\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tclear(global_costmap_);\n\t}\n\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tclear(local_costmap_);\n\t}\n\n\tif (force_updating_) {\n\t\tglobal_costmap_->updateMap();\n\t\tlocal_costmap_->updateMap();\n\t}\n\n\tROS_DEBUG(\"Clear costmap recovery took %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 51.06668545292238}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not clear the costmaps created by the navigation stack.\");\n\t\treturn;\n\t}\n\n\tros::Time t0 = ros::WallTime::now();\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t}\n\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tglobal_costmap_->clear(clear_radius_, x_shift_, y_shift_, invert_area_to_clear_);\n\t\tROS_DEBUG(\"Global costmap cleared\");\n\t}\n\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tlocal_costmap_->clear(clear_radius_, x_shift_, y_shift_, invert_area_to_clear_);\n\t\tROS_DEBUG(\"Local costmap cleared\");\n\t}\n\n\tif (force_updating_) {\n\t\tglobal_costmap_->updateMap();\n\t\tROS_DEBUG(\"Global costmap updated\");\n\t\tlocal_costmap_->updateMap();\n\t\tROS_DEBUG(\"Local costmap updated\");\n\t}\n\n\tROS_DEBUG(\"Clearing took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 55.238910857259484}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global costmap passed to the ClearCostmapRecovery object cannot be NULL. Do not set the global costmap.\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object cannot be NULL. Do not set the local costmap.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t} else {\n\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t}\n\n\tros::Time t0 = ros::WallTime::now();\n\n\tif (affected_maps_ == \"local\") {\n\t\tclear(local_costmap_);\n\t} else if (affected_maps_ == \"global\") {\n\t\tclear(global_costmap_);\n\t} else if (affected_maps_ == \"both\") {\n\t\tclear(local_costmap_);\n\t\tclear(global_costmap_);\n\t} else {\n\t\tROS_ERROR(\"Invalid value for affected_maps: %s. Valid values are 'local', 'global', and 'both'.\", affected_maps_.c_str());\n\t}\n\n\tif (force_updating_) {\n\t\tlocal_costmap_->updateMap();\n\t\tglobal_costmap_->updateMap();\n\t}\n\n\tROS_DEBUG(\"Clear costmap recovery took %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 56.168225413908324}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells poc(polygon_cells);\n\tfor (unsigned int i = 1; i < polygon.size(); ++i) {\n\t\traytraceLine(poc, polygon[i - 1], polygon[i]);\n\t}\n\tif (polygon.size() > 2) {\n\t\traytraceLine(poc, polygon.back(), polygon.front());\n\t}\n}", "CodeBleu_score": 40.44621560643618}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\tif (polygon.empty())\n\t\treturn;\n\n\t// initialize the cells vector\n\tpolygon_cells.reserve(polygon.size() * 8);\n\n\t// iterate through the polygon vertices\n\tfor (size_t i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n\t}\n\n\t// close the polygon\n\tif (polygon.size() > 2) {\n\t\traytraceLine(polygon.back(), polygon.front(), polygon_cells);\n\t}\n}", "CodeBleu_score": 44.774431925859574}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\t// initialize the polygon outline cells object\n\tPolygonOutlineCells poc(polygon_cells);\n\t// iterate through the polygon vertices\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\t// gather cells between consecutive points\n\t\traytraceLine(polygon[i], polygon[i + 1], poc);\n\t}\n\t// close the polygon\n\traytraceLine(polygon.back(), polygon.front(), poc);\n}", "CodeBleu_score": 43.491079664440534}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// TODO:\n\t// 1. Call prepareGrid\n\t// 2. Publish the prepared grid using the provided publisher\n\tprepareGrid\n\tpub.publish\n}", "CodeBleu_score": 48.971438487632284}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tcostmap_->getMutex().lock();\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tcostmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = translation_table_[costmap_->getCharMap()[i]];\n\t}\n\tcostmap_->getMutex().unlock();\n}", "CodeBleu_score": 60.8111344189768}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap and get the resolution.\n\tcostmap_->getMutex().lock();\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header, resolution, width, and height.\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin.\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\tgrid_.info.origin.position.x = wx - resolution / 2;\n\tgrid_.info.origin.position.y = wy - resolution / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates.\n\torigin_x_ = wx;\n\torigin_y_ = wy;\n\n\t// Resize the grid data vector.\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table.\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = costmap_->getCharMap()[i];\n\t}\n\n\t// Unlock the costmap.\n\tcostmap_->getMutex().unlock();\n}", "CodeBleu_score": 77.23730459146991}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = costmap_->getResolution();\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\tgrid_.info.origin.position.x = wx - grid_.info.resolution / 2;\n\tgrid_.info.origin.position.y = wy - grid_.info.resolution / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\tunsigned char* costmap_data = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n\t\tgrid_.data[i] = translation_table_[costmap_data[i]];\n\t}\n}", "CodeBleu_score": 66.89139199954339}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  if (new_config.footprint == old_config.footprint &&\n//      new_config.robot_radius == old_config.robot_radius) {\n//    return;\n//  }\n\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (!makeFootprintFromString(new_config.footprint, new_footprint)) {\n    ROS_ERROR(\"Invalid footprint string provided.  Using default footprint.\");\n    makeFootprintFromRadius(new_config.robot_radius, new_footprint);\n  }\n  setUnpaddedRobotFootprint(new_footprint);\n}", "CodeBleu_score": 36.56077450441527}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  ROS_INFO(\"readFootprintFromConfig\");\n  if (new_config.footprint!= old_config.footprint ||\n      new_config.robot_radius!= old_config.robot_radius) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      ROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n    }\n  }\n}", "CodeBleu_score": 55.547833493643864}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n//  ROS_DEBUG(\"Footprint config changed\");\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n      return;\n    } else {\n      ROS_ERROR(\"Failed to parse footprint string '%s'\", new_config.footprint.c_str());\n    }\n  }\n\n  std::vector<geometry_msgs::Point> new_footprint;\n  makeFootprintFromRadius(new_config.robot_radius, new_footprint);\n  setUnpaddedRobotFootprint(new_footprint);\n}", "CodeBleu_score": 72.7537540333497}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\t// If we fail to get a valid pose, abort reconfiguration\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\t// If the robot's pose has changed, we need to reconfigure the costmap\n\tif (!costmap_->setRobotPose(new_pose)) {\n\t\t// If the pose hasn't changed enough, we won't reconfigure and return\n\t\treturn;\n\t}\n\t// We'll also cancel any active reconfiguration\n\tcancelReconfiguration(new_pose);\n\t// Get the pose of the robot in the global frame\n\tgeometry_msgs::PoseStamped global_pose;\n\tif (!transformPose(global_frame_, new_pose, global_pose)) {\n\t\tROS_WARN(\"Failed to transform robot pose into the %s frame\", global_frame_.c_str());\n\t\treturn;\n\t}\n\t// Get the pose of the robot in the map frame\n\tgeometry_msgs::PoseStamped map_pose;\n\tif (!transformPose(layered_costmap_->getGlobalFrameID(), new_pose, map_pose)) {\n\t\tROS_WARN(\"Failed to transform robot pose into the %s frame\", layered_costmap_->getGlobalFrameID().c_str());\n\t\treturn;\n\t}\n\t// Reconfigure the costmap based on the robot's new pose\n\treconfigureCostmap(global_pose, map_pose);\n}", "CodeBleu_score": 58.61140716633756}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\t// If the costmap is stopped, then we need to re-subscribe to topics and re-advertise services\n\tif (stopped_) {\n\t\tROS_DEBUG(\"Starting costmap...\");\n\t\t// re-subscribe to topics\n\t\tfor (unsigned int i = 0; i < plugins_.size(); i++) {\n\t\t\tif (plugins_[i]!= NULL) {\n\t\t\t\tplugins_[i]->activate();\n\t\t\t}\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\t}\n\n\t// wait for costmap to be ready\n\tros::Rate r(100.0);\n\twhile (ros::ok() &&!layered_costmap_->isSizeLocked() &&!initialized_) {\n\t\tROS_DEBUG(\"Waiting for costmap to be ready...\");\n\t\tr.sleep();\n\t}\n\n\t// wait for map update thread to wake up and start publishing\n\twhile (ros::ok() &&!initialized_) {\n\t\tROS_DEBUG(\"Waiting for map update thread to wake up and start publishing...\");\n\t\tr.sleep();\n\t}\n}", "CodeBleu_score": 50.365152752576236}, {"code": "void Costmap2DROS::start(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(layered_costmap_->getMutex()));\n\tstd::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin) {\n\t\t(*plugin)->activate();\n\t}\n\tstopped_ = false;\n\tstop_updates_ = false;\n\twhile (!ros::ok() ||!layered_costmap_->isInitialized() ||!layered_costmap_->isSizeLocked()) {\n\t\tROS_DEBUG(\"Costmap waiting for ros, layered_costmap, or size lock.\");\n\t\tros::Duration(0.1).sleep();\n\t}\n\tmap_update_thread_ = boost::shared_ptr<boost::thread>(new boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_)));\n}", "CodeBleu_score": 58.11962293765484}, {"code": "void Costmap2DROS::start(){\n\t\t// get the list of plugins\n\tstd::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\t// check if the costmap was stopped\n\tif (stopped_) {\n\t\t// re-subscribe to topics by activating each plugin\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\t// set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!layered_costmap_->isInitialized() ||!ros::ok()) {\n\t\tif (!ros::ok()) {\n\t\t\tROS_ERROR(\"Costmap2DROS transform thread got a cancel request\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(100000);\n\t}\n}", "CodeBleu_score": 67.20597822494932}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0.0)) {\n\t\tobservation_list_.resize(1);\n\t} else {\n\t\t// Find the last valid observation.\n\t\tObservationList::iterator it = observation_list_.end();\n\t\twhile (it!= observation_list_.begin()) {\n\t\t\t--it;\n\t\t\tif (it->stamp_ >= (ros::Time::now() - observation_keep_time_)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Remove all observations prior to it.\n\t\tobservation_list_.erase(observation_list_.begin(), it);\n\t}\n}", "CodeBleu_score": 36.29122229274748}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0)) {\n\t\t// Keep only the most recent observation\n\t\tobservation_list_.clear();\n\t\tobservation_list_.push_back(most_recent_observation_);\n\t} else {\n\t\t// Keep only the most recent observation that is within the specified keep time\n\t\tobservation_list_.erase(\n\t\t\t\tstd::remove_if(observation_list_.begin(), observation_list_.end(),\n\t\t\t\t\t\tboost::bind(&ObservationBuffer::isStale, this, _1)),\n\t\t\t\tobservation_list_.end());\n\t}\n}", "CodeBleu_score": 27.490472941652783}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0.0)) {\n\t\tobservation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n\t} else {\n\t\tros::Time now = ros::Time::now();\n\t\tstd::list<Observation>::iterator it = observation_list_.begin();\n\t\twhile (it!= observation_list_.end()) {\n\t\t\tif (it->stamp_ + observation_keep_time_ < now) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.55990872484221}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//  ROS_INFO(\"interpolate\");\n  // compute the yaw angle at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // compute the shortest angular distance between the start and end yaw angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // compute the incremental change in angle for each pose\n  double increment = angular_distance / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double angle = start_yaw + (i - start_index) * increment;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 74.00062445100633}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// TODO: Implement\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\tdouble angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\tdouble increment = angular_distance / (end_index - start_index);\n\n\tdouble current_yaw = start_yaw;\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tcurrent_yaw += increment;\n\t\tset_angle(&path[i], current_yaw);\n\t}\n}", "CodeBleu_score": 67.6650719194017}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//   ROS_INFO_STREAM(\"OrientationFilter::interpolate\");\n  // get the yaw angle at the start and end of the path\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // get the shortest angular distance between the start and end yaw angles\n  double angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // calculate the incremental change in angle for each pose\n  double increment = angular_distance / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    // get the current yaw angle\n    double current_yaw = tf2::getYaw(path[i].pose.orientation);\n\n    // calculate the new yaw angle by adding the incremental change to the current yaw angle\n    double new_yaw = current_yaw + increment;\n\n    // set the orientation of the pose to the new yaw angle\n    set_angle(&path[i], new_yaw);\n  }\n}", "CodeBleu_score": 67.30830169206628}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tgeometry_msgs::PoseStamped start;\n\tgeometry_msgs::PoseStamped goal;\n\tstart.header.frame_id = goal.header.frame_id = \"map\";\n\tstart.pose = req.start;\n\tgoal.pose = req.goal;\n\tmakePlan(start, goal, resp.plan);\n\tresp.code = resp.plan.size()? navfn::MakeNavPlan::Response::OK : navfn::MakeNavPlan::Response::OUT_OF_REACH;\n\treturn true;\n}", "CodeBleu_score": 44.976362959169656}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\tmakePlan(req.start, req.goal, resp.plan.poses);\n\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\n\treturn true;\n}", "CodeBleu_score": 47.06848047744734}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t//set the frame_id of the start and goal poses to the frame of the costmap\n\treq.start.header.frame_id = costmap_->getGlobalFrameID();\n\treq.goal.header.frame_id = costmap_->getGlobalFrameID();\n\n\t//call the makePlan function\n\tmakePlan(req.start, req.goal, resp.plan);\n\n\t//update the response with the success status and the generated path\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.frame_id = costmap_->getGlobalFrameID();\n\tresp.code = resp.plan.poses.size() > 0? navfn::MakeNavPlan::Response::OK : navfn::MakeNavPlan::Response::OUT_OF_REACH;\n\n\t//return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 40.222510318067215}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tservice = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tplanner_plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"planner_plan\", 1);\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 65.08183745268293}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 66.96111934519689}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_srv_ = private_nh.advertiseService(\"make_plan\",\n\t\t\t&PlannerWithCostmap::makePlanService, this);\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1,\n\t\t\tboost::bind(&PlannerWithCostmap::goalCB, this, _1));\n}", "CodeBleu_score": 64.33347111420312}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "CodeBleu_score": 82.77238242326221}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.47381022559843}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.47381022559843}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 88.60358048543145}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = \"\";\n\n\t//our goal to be sent to the action server\n\tmove_base_msgs::MoveBaseGoal mb_goal;\n\tmb_goal.target_pose = *goal;\n\tmb_goal.goal_id = goal_id;\n\n\t//we could just use the goal here instead of the goal message unless we want to check that the goal is valid\n\ttf::Stamped<tf::Pose> goal_tf;\n\ttf::poseStampedMsgToTF(goal, goal_tf);\n\tmb_goal.target_pose.header.frame_id = global_frame_;\n\tgoal_tf.setData(goal_tf);\n\tgoal_tf.stamp_ = goal->header.stamp;\n\tgoal_tf.frame_id_ = global_frame_;\n\t//we'll just use the most recent transform available for the goal pose instead of transforming into the\n\t//frame id of the goal pose like:\n\t//tf::Stamped<tf::Pose> goal_tf = tf::Stamped<tf::Pose>(goal_tf, goal->header.stamp, global_frame_);\n\ttf::Stamped<tf::Pose> global_goal_tf;\n\tif (!tf::Transformer::getInstance()->transformPose(global_frame_, goal_tf, global_goal_tf)) {\n\t\t//we can't transform the goal to the frame the action server is expecting\n\t\tROS_WARN_NAMED(\"move_base\",\n\t\t\t\t\"Failed to transform the goal pose from %s into the %s frame as specified in the action server, so the goal will be sent in the frame it was received in.\",\n\t\t\t\tgoal->header.frame_id.c_str(), global_frame_.c_str());\n\t\tmb_goal.target_pose.header.frame_id = goal->header.frame_id;\n\t} else {\n\t\ttf::poseStampedTFToMsg(global_goal_tf, mb_goal.target_pose);\n\t}\n\n\t//we have a goal so start moving\n\texecuteCb(mb_goal, false);\n}", "CodeBleu_score": 49.636041265399086}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = \"\";\n\n\t// we have a new goal\n\ttf::Stamped<tf::Pose> goal_tf;\n\tposeStampedMsgToTF(goal, goal_tf);\n\n\t//we'll publish the goal point to the console for monitoring purposes\n\tROS_DEBUG_NAMED(\"goal\", \"Goal pose received for MoveBaseAction server in frame %s\", goal_tf.frame_id_.c_str());\n\n\t//we want to give the robot some time to plan accordingly before executing the goal.\n\t//we wait for one second to allow for this.\n\tros::Duration(1.0).sleep();\n\n\t//wrap the pose in the action message and publish it to the server\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = goal_id.stamp;\n\taction_goal.goal_id = goal_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 61.582596735002014}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID g;\n\t// use the system time for the goal id\n\tg.stamp = ros::Time::now();\n\tg.id = uuid::random_uuid().str();\n\n\t// we have a new goal\n\ttf::Stamped<tf::Pose> goal_tf;\n\ttf::poseStampedMsgToTF(*goal, goal_tf);\n\n\t// we'll publish the goal point to the console for monitoring purposes\n\tROS_DEBUG_NAMED(\"goal\", \"Goal pose received for MoveBaseAction server in frame %s\", goal_tf.frame_id_.c_str());\n\n\t// goal_tf.stamp_ = ros::Time::now();\n\n\t// we want to send a goal to the base\n\ttf::Stamped<tf::Pose> global_pose;\n\tgetRobotPose(global_pose);\n\n\t// set up the goal state\n\tmove_base_msgs::MoveBaseGoal mb_goal;\n\tmb_goal.target_pose.header.frame_id = goal_tf.frame_id_;\n\tmb_goal.target_pose.header.stamp = ros::Time::now();\n\ttf::poseStampedTFToMsg(goal_tf, mb_goal.target_pose);\n\n\t// TODO: the base should be able to handle a PoseWithCovarianceStamped as input\n\tmb_goal.target_pose.pose.covariance[6 * 0 + 0] = 0.5;\n\tmb_goal.target_pose.pose.covariance[6 * 1 + 1] = 0.5;\n\tmb_goal.target_pose.pose.covariance[6 * 5 + 5] = 0.06853891945200942;\n\n\t// start executing the action\n\taction_goal_pub_.publish(mb_goal);\n}", "CodeBleu_score": 46.32444960385518}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > distance_sq_) {\n\t\tROS_INFO(\"MoveSlowAndClear: Robot has moved far enough, removing speed limit.\");\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 61.81813275922604}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble distance = getSqDistance();\n\tif (distance > sq_distance_limit_) {\n\t\tROS_INFO(\"MoveSlowAndClear: Robot moved %f meters, removing speed limit.\", sqrt(distance));\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 73.3897495236447}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t//ROS_INFO(\"distance check\");\n  double sq_dist = getSqDistance();\n  if (sq_dist > sq_limited_distance_) {\n    ROS_INFO(\"Robot has moved far enough, removing speed limit\");\n    if (remove_limit_thread_!= NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 80.60733135988252}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Got new pose\");\n\trm::PoseStamped global_pose;\n\n\t//get the global pose\n\tif (!costmap_ros_->getRobotPose(global_pose)) {\n\t\tROS_WARN(\"Unable to get starting pose of robot, unable to create global plan\");\n\t\treturn;\n\t}\n\n\tstd::vector<rm::PoseStamped> global_plan;\n\n\t//we'll get the plan into global_plan\n\tif (makePlan(global_pose, *goal, global_plan) == true) {\n\t\t//publish the plan\n\t\trm::Path gui_path;\n\t\tgui_path.poses.resize(global_plan.size());\n\n\t\tfor (unsigned int i = 0; i < global_plan.size(); ++i) {\n\t\t\tgui_path.poses[i] = global_plan[i];\n\t\t}\n\n\t\tplan_pub_.publish(gui_path);\n\t}\n\n\treturn;\n}", "CodeBleu_score": 48.48288529663141}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\trm::PoseStamped global_pose;\n\ttf::Stamped<tf::Pose> global_pose_tf;\n\n\t//get the global pose\n\tgetRobotPose(global_pose_tf);\n\n\t//set the global pose\n\tglobal_pose.header.stamp = global_pose_tf.stamp_;\n\tglobal_pose.header.frame_id = global_pose_tf.frame_id_;\n\tglobal_pose.pose.position.x = global_pose_tf.getOrigin().getX();\n\tglobal_pose.pose.position.y = global_pose_tf.getOrigin().getY();\n\tglobal_pose.pose.position.z = global_pose_tf.getOrigin().getZ();\n\tglobal_pose.pose.orientation.x = global_pose_tf.getRotation().getX();\n\tglobal_pose.pose.orientation.y = global_pose_tf.getRotation().getY();\n\tglobal_pose.pose.orientation.z = global_pose_tf.getRotation().getZ();\n\tglobal_pose.pose.orientation.w = global_pose_tf.getRotation().getW();\n\n\t//clear the plan, just in case\n\tplan_.clear();\n\n\t//make the plan\n\tmakePlan(global_pose, goal, plan_);\n}", "CodeBleu_score": 40.99084199324703}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// get the current pose of the robot\n\ttf::Stamped<tf::Pose> global_pose;\n\tcostmap_ros_->getRobotPose(global_pose);\n\n\t// create a vector of waypoints for the planner to follow\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\n\t// generate a plan from the current pose to the goal pose\n\tmakePlan(global_pose, goal, plan);\n}", "CodeBleu_score": 56.420414361241015}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a ParamSet service request\n\tmavros_msgs::ParamSet param_set_srv;\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\t// Call the param_set_client_ to send the request\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 62.91761016539764}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a request object for the service\n\tmavros_msgs::ParamSet srv;\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\t// Call the param_set_client_ to send the request\n\tthis->param_set_client_.call(srv);\n}", "CodeBleu_score": 77.37153616475027}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\tthis->param_set_client_.call(srv);\n}", "CodeBleu_score": 77.38478905492752}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint server_fd, new_socket, valread;\n\tstruct sockaddr_in address;\n\tint opt = 1;\n\tint addrlen = sizeof(address);\n\n\tif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n\t\tperror(\"socket failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt,\n\t\t\tsizeof(opt))) {\n\t\tperror(\"setsockopt\");\n\t\texit(EXIT_FAILURE);\n\t}\n\taddress.sin_family = AF_INET;\n\taddress.sin_addr.s_addr = INADDR_ANY;\n\taddress.sin_port = htons(PORT);\n\n\tif (bind(server_fd, (struct sockaddr *) &address, sizeof(address)) < 0) {\n\t\tperror(\"bind failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (listen(server_fd, 3) < 0) {\n\t\tperror(\"listen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tROS_INFO(\"Waiting for connection from ground station...\");\n\tif ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n\t\t\t(socklen_t*) &addrlen)) < 0) {\n\t\tperror(\"accept\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tROS_INFO(\"Connection established.\");\n\twhile (ros::ok()) {\n\t\tchar buffer[1024] = { 0 };\n\t\tif ((valread = read(new_socket, buffer, 1024)) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (valread <= 0) {\n\t\t\tROS_ERROR(\"Connection closed.\");\n\t\t\tclose(new_socket);\n\t\t\tbreak;\n\t\t}\n\t\t//ROS_INFO(\"Received message: %s\", buffer);\n\t\tpubMsg(buffer);\n\t}\n}", "CodeBleu_score": 49.00473961502242}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint sockfd, newsockfd, portno;\n\tsocklen_t clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tif (ros::param::get(\"~port\", portno)) {\n\t\tROS_INFO(\"port number is %d\", portno);\n\t} else {\n\t\tROS_ERROR(\"port number is not set\");\n\t\texit(1);\n\t}\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\tif (newsockfd < 0) {\n\t\tperror(\"ERROR on accept\");\n\t\texit(1);\n\t}\n\twhile (1) {\n\t\tbzero(buffer, 256);\n\t\tn = read(newsockfd, buffer, 255);\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\tclose(newsockfd);\n\t\t\texit(1);\n\t\t}\n\t\tif (decodeMsg(buffer, n)) {\n\t\t\tpubMsg();\n\t\t}\n\t}\n}", "CodeBleu_score": 44.8349712650577}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_ == false) {\n\t\t// Publish the command to a single UAV\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t} else {\n\t\t// Publish the command to the corresponding UAV in simulation mode\n\t\tstd::map<int, UAVBasic*>::iterator it;\n\t\tit = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub(uav_cmd);\n\t\t} else {\n\t\t\tROS_ERROR(\"CommunicationBridge::recvData: UAV ID %d not found\", uav_cmd.uav_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 55.784415551480826}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t//if not in simulation mode, publish the command to the single UAV\n\tif (!this->simulation_mode_) {\n\t\t//find the UAV by ID\n\t\tstd::map<int, UAVBasic*>::iterator it;\n\t\tit = this->uav_basic_.find(uav_cmd.uav_id);\n\t\tif (it == this->uav_basic_.end()) {\n\t\t\tROS_ERROR(\"UAV ID %d not found\", uav_cmd.uav_id);\n\t\t\treturn;\n\t\t}\n\t\t//publish the command to the UAV\n\t\t(*it).second->uavCmdPub(uav_cmd);\n\t} else {\n\t\t//find the UAV by ID\n\t\tstd::map<int, UAVBasic*>::iterator it;\n\t\tit = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it == this->swarm_control_simulation_.end()) {\n\t\t\tROS_ERROR(\"UAV ID %d not found\", uav_cmd.uav_id);\n\t\t\treturn;\n\t\t}\n\t\t//publish the command to the UAV\n\t\t(*it).second->uavCmdPub(uav_cmd);\n\t}\n}", "CodeBleu_score": 51.45608065354861}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\tstd::map<int, UAVBasic*>::iterator it;\n\t\tit = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\tit->second->uavCmdPub(uav_cmd);\n\t\t} else {\n\t\t\tROS_ERROR(\"UAV ID %d not found in simulation mode\", uav_cmd.uav_id);\n\t\t}\n\t} else {\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t}\n}", "CodeBleu_score": 47.51932230271475}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif(mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"sudo reboot\");\n\t} else if(mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"sudo shutdown -h now\");\n\t} else if(mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if(mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 43.73822114581019}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == USE_MODE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 63.14133173018755}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 60.29918054500549}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count == last_heartbeat_count) {\n\t\tif (heartbeat_count == 0) {\n\t\t\tROS_WARN(\"No heartbeat received\");\n\t\t} else {\n\t\t\tROS_WARN(\"Heartbeat lost\");\n\t\t}\n\t\tdisconnect_flag = true;\n\t} else {\n\t\tlast_heartbeat_count = heartbeat_count;\n\t}\n}", "CodeBleu_score": 26.689280014322748}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count == prev_heartbeat_count) {\n\t\tif (heartbeat_count == 0) {\n\t\t\tROS_ERROR(\"Heartbeat not received from SwarmControl\");\n\t\t\ttriggerSwarmControl = true;\n\t\t} else if (heartbeat_count == 1) {\n\t\t\tROS_ERROR(\"Heartbeat not received from UAV\");\n\t\t\ttriggerUAV = true;\n\t\t} else if (heartbeat_count == 2) {\n\t\t\tROS_ERROR(\"Heartbeat not received from UGV\");\n\t\t\ttriggerUGV = true;\n\t\t}\n\t\tdisconnect_flag = true;\n\t} else {\n\t\tprev_heartbeat_count = heartbeat_count;\n\t\tdisconnect_flag = false;\n\t}\n}", "CodeBleu_score": 35.57249400095241}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// 1. extract data from msg\n\tint traj_num = msg->traj.size();\n\tint drone_id = msg->drone_id;\n\tstd::vector<Bspline> bsplines;\n\tfor (int i = 0; i < traj_num; i++) {\n\t\tBspline bspline;\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.end_time = msg->traj[i].end_time.toSec();\n\t\tbspline.knots.clear();\n\t\tbspline.pos_pts.clear();\n\t\tbspline.yaw_pts.clear();\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots.push_back(msg->traj[i].knots[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n\t\t}\n\t\tbsplines.push_back(bspline);\n\t}\n\n\t// 2. encode msg\n\tstd::vector<uint8_t> msg_encode;\n\tmsg_encode.clear();\n\tthis->communication->encodeMsg(bsplines, msg_encode);\n\n\t// 3. send msg\n\tthis->communication->sendMsgByTcp(msg_encode);\n}", "CodeBleu_score": 58.002401120100075}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tint id = msg->drone_id;\n\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.knots.clear();\n\t\tbspline.pos_pts.clear();\n\t\tbspline.yaw_pts.clear();\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots.push_back(msg->traj[i].knots[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n\t\t}\n\t\tthis->communication->sendMsgByTcp(id, bspline);\n\t}\n}", "CodeBleu_score": 55.68979517160499}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree_compression;\n\toctree_compression.encodePointCloud(cloud, compressed_data.str());\n\n\t// Create a new message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = msg.height;\n\tcompressed_msg.width = msg.width;\n\tcompressed_msg.is_dense = msg.is_dense;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.data.resize(compressed_data.str().size());\n\tstd::memcpy(&compressed_msg.data[0], compressed_data.str().data(), compressed_data.str().size());\n\n\t// Release dynamically allocated memory\n\tcompressed_data.str(\"\");\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 33.996791623731106}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tpcl::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.encodePointCloud(*cloud_ptr, *cloud_out);\n\n\tstd::stringstream compressed_data;\n\tcompressed_data.write((char*)cloud_out->data, cloud_out->data_size);\n\n\tsensor_msgs::PointCloud2 msg_out;\n\tmsg_out.header = msg.header;\n\tmsg_out.height = 1;\n\tmsg_out.width = compressed_data.str().size();\n\tmsg_out.is_bigendian = false;\n\tmsg_out.is_dense = true;\n\tmsg_out.point_step = 1;\n\tmsg_out.row_step = compressed_data.str().size();\n\tmsg_out.data.resize(compressed_data.str().size());\n\tstd::memcpy(&msg_out.data[0], compressed_data.str().c_str(), compressed_data.str().size());\n\n\treturn msg_out;\n}", "CodeBleu_score": 44.306294036941054}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// compress the point cloud\n\tpcl::OctreePointCloudCompression<pcl::PointXYZRGB> octree_compression;\n\toctree_compression.encodePointCloud(cloud, compressed_str);\n\n\t// create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = msg.height;\n\tcompressed_msg.width = msg.width;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.is_dense = msg.is_dense;\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.data.resize(compressed_str.size());\n\tstd::memcpy(&compressed_msg.data[0], compressed_str.data(), compressed_str.size());\n\n\t// release dynamically allocated memory\n\toctree_compression.release();\n\tcompressed_str.clear();\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 34.807498731303475}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t// Iterate through the list of UAV states\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\t// If the UAV ID matches, update the UAV state\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.51828783933385}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize a MultiUGVState message\n\tmavros_msgs::MultiUGVState multi_ugv_state;\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (std::vector<UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); ++it) {\n\t\t// Initialize a UGVState message\n\t\tmavros_msgs::UGVState ugv_state;\n\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state.id = it->id;\n\t\tugv_state.battery = it->battery;\n\t\tugv_state.position.x = it->position.x;\n\t\tugv_state.position.y = it->position.y;\n\t\tugv_state.position.z = it->position.z;\n\t\tugv_state.velocity.x = it->velocity.x;\n\t\tugv_state.velocity.y = it->velocity.y;\n\t\tugv_state.velocity.z = it->velocity.z;\n\t\tugv_state.attitude.x = it->attitude.x;\n\t\tugv_state.attitude.y = it->attitude.y;\n\t\tugv_state.attitude.z = it->attitude.z;\n\n\t\t// Increment the UGV count\n\t\tmulti_ugv_state.ugv_count++;\n\n\t\t// Add each UGVState to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// Publish the assembled MultiUGVState message\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.800806349099105}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.clear();\n\tmulti_ugv_state.ugv_state_all.resize(m_multi_ugv_state.ugv_state_all.size());\n\n\tint count = 0;\n\tfor (auto it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); ++it) {\n\t\tUGVState ugv_state;\n\t\tugv_state.id = it->id;\n\t\tugv_state.battery = it->battery;\n\t\tugv_state.pos.x = it->pos.x;\n\t\tugv_state.pos.y = it->pos.y;\n\t\tugv_state.pos.z = it->pos.z;\n\t\tugv_state.vel.x = it->vel.x;\n\t\tugv_state.vel.y = it->vel.y;\n\t\tugv_state.vel.z = it->vel.z;\n\t\tugv_state.att.x = it->att.x;\n\t\tugv_state.att.y = it->att.y;\n\t\tugv_state.att.z = it->att.z;\n\t\tugv_state.att.w = it->att.w;\n\t\tmulti_ugv_state.ugv_state_all[count] = ugv_state;\n\t\tcount++;\n\t}\n\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 46.06780858898776}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// get predicted positions of moving objects\n\tmoving_objs_->evaluateConstVel(q);\n\n\t// iterate through control points\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\t// iterate through moving objects\n\t\tfor (int j = 0; j < moving_objs_->getObjNums(); j++) {\n\t\t\t// compute distance between control point and object\n\t\t\tdouble dist = (cps_.points.col(i) - moving_objs_->getObjPos(j)).norm();\n\n\t\t\t// if distance is less than clearance, update cost and gradient\n\t\t\tif (dist < clearance_) {\n\t\t\t\tcost += pow(clearance_ - dist, 2);\n\t\t\t\tgradient.col(i) -= (clearance_ - dist) * (cps_.points.col(i) - moving_objs_->getObjPos(j)).normalized();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.74099403686937}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Clear cost and gradient\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// Iterate through control points\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\t// Predict the position of moving objects\n\t\tmoving_objs_->evaluateConstVel(cps_.points.col(i), cps_.times[i]);\n\n\t\t// Iterate through moving objects\n\t\tfor (int j = 0; j < moving_objs_->getObjNums(); j++) {\n\t\t\t// Get the position of the j-th moving object\n\t\t\tEigen::Vector3d obj_prid = moving_objs_->getObjPos(j);\n\n\t\t\t// Compute the distance between the i-th control point and the j-th moving object\n\t\t\tdouble dist = (cps_.points.col(i) - obj_prid).norm();\n\n\t\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\t\tif (dist < clearance_) {\n\t\t\t\tcost += pow(dist - clearance_, 2);\n\t\t\t\tgradient.col(i) += 2 * (dist - clearance_) * (cps_.points.col(i) - obj_prid).normalized();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.24913430497413}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\tEigen::Vector3d x_cross;\n\tEigen::Vector3d x_dot;\n\n\tfor (int i = 1; i < q.cols(); i++) {\n\t\tEigen::Vector3d v = (q.col(i) - q.col(i - 1)).normalized();\n\t\tEigen::Vector3d x_cross = (ref_pts_[i] - ref_pts_[i - 1]).cross(v);\n\t\tdouble x_cross_norm = x_cross.norm();\n\t\tEigen::Vector3d x_dot = (ref_pts_[i] - ref_pts_[i - 1]).dot(v);\n\t\tdouble x_dot_norm = x_dot.norm();\n\n\t\tcost += pow(x_cross_norm, 2) + pow(x_dot_norm, 2);\n\n\t\tEigen::Vector3d x_cross_grad = 2 * x_cross_norm * x_cross;\n\t\tEigen::Vector3d x_dot_grad = 2 * x_dot_norm * x_dot;\n\n\t\tgradient.col(i) = x_cross_grad + x_dot_grad;\n\t}\n}", "CodeBleu_score": 40.07489275706933}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost to zero\n\tcost = 0;\n\n\t// Initialize the gradient to zero\n\tgradient.setZero();\n\n\t// Iterate through the control points of the trajectory\n\tfor (size_t i = 2; i < q.cols(); i++) {\n\t\t// Compute the positional error relative to reference points\n\t\tEigen::Vector3d x = (ref_pts_[i] - ref_pts_[i - 2]).normalized();\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d v = (q.col(i) - q.col(i - 2)).normalized();\n\n\t\t// Compute the squared dot product and cross product of the vectors, normalized by constants a2 and b2\n\t\tdouble dot = x.dot(v);\n\t\tdouble cross = x.cross(v).norm();\n\n\t\t// Update the cost function based on the squared dot product and cross product\n\t\tcost += a2 * dot * dot + b2 * cross * cross;\n\n\t\t// Compute the derivatives for each control point\n\t\tEigen::Matrix3d x_cross = skew(x);\n\t\tEigen::Matrix3d v_cross = skew(v);\n\n\t\t// Update the gradient for each control point using the computed derivatives\n\t\tgradient.col(i) += 2 * a2 * (dot * x_cross + v_cross).transpose() * v;\n\t\tgradient.col(i - 2) += 2 * a2 * (dot * x_cross - v_cross).transpose() * v;\n\t\tgradient.col(i) += 2 * b2 * (cross * x_cross - v_cross).transpose() * x;\n\t\tgradient.col(i - 2) += 2 * b2 * (cross * x_cross + v_cross).transpose() * x;\n\t}\n}", "CodeBleu_score": 43.48901781411191}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd jerk_ctrl_pts = getJerkControlPoints();\n\tEigen::VectorXd knots = getKnot();\n\tdouble jerk = 0;\n\tfor (int i = 0; i < jerk_ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < jerk_ctrl_pts.rows(); j++) {\n\t\t\tjerk += jerk_ctrl_pts(j, i) * jerk_ctrl_pts(j, i) * (knots(i + 1) - knots(i));\n\t\t}\n\t}\n\treturn sqrt(jerk);\n}", "CodeBleu_score": 49.36730426779917}, {"code": "double UniformBspline::getJerk(){\n\t\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\tEigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tEigen::VectorXd u = jerk_traj.getKnot();\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += ctrl_pts(j, i) * (u(i + 1) - u(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 66.1745916406291}, {"code": "double UniformBspline::getJerk(){\n\t\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\tEigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tEigen::VectorXd u = jerk_traj.getKnot();\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += ctrl_pts(j, i) * (u(i + 1) - u(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 66.1745916406291}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos_in_camera;\n\tpos_in_camera << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n\treturn pos_in_camera;\n}", "CodeBleu_score": 52.2596848142844}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.71884142349269}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) / fx_ * depth;\n\tpos[1] = (v - cy_) / fy_ * depth;\n\tpos[2] = depth;\n\tpos[3] = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 53.49004248386151}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(odom.child_frame_id.find(\"_\") + 1));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 47.77507826132403}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string droneID = odom.child_frame_id.substr(1);\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(droneID));\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"Error extracting drone ID from child_frame_id of odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 49.45017145647319}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(odom.child_frame_id.find(\"_\") + 1));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Error in DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}", "CodeBleu_score": 47.39861865368529}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = true_pose_[drone_id];\n\tEigen::Vector3d cam_pose = cam_pose_[drone_id];\n\tEigen::Vector3d drone_pose = cam_pose + true_pose;\n\n\t// Check for the presence of the drone\n\tbool found = false;\n\tint pixel_x = -1;\n\tint pixel_y = -1;\n\tint pixel_z = -1;\n\tfor (int i = 0; i < (int)detected_poses_.size(); i++) {\n\t\tif (detected_poses_[i].drone_id == drone_id) {\n\t\t\tfound = true;\n\t\t\tpixel_x = detected_poses_[i].pixel_x;\n\t\t\tpixel_y = detected_poses_[i].pixel_y;\n\t\t\tpixel_z = detected_poses_[i].pixel_z;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Compute the pose error between the camera and world coordinates\n\tEigen::Vector3d pose_error;\n\tif (found) {\n\t\tpose_error = drone_pose - Eigen::Vector3d(pixel_x, pixel_y, pixel_z);\n\t} else {\n\t\tpose_error = Eigen::Vector3d::Zero();\n\t}\n\n\t// Update the debug result\n\tdebug_result_[drone_id].found = found;\n\tdebug_result_[drone_id].pixel_x = pixel_x;\n\tdebug_result_[drone_id].pixel_y = pixel_y;\n\tdebug_result_[drone_id].pixel_z = pixel_z;\n\tdebug_result_[drone_id].true_pose = true_pose;\n\tdebug_result_[drone_id].cam_pose = cam_pose;\n\tdebug_result_[drone_id].drone_pose = drone_pose;\n\tdebug_result_[drone_id].pose_error = pose_error;\n\n\t// Publish the pose error\n\tdrone_pose_err_pub_[drone_id].publish(pose_error);\n}", "CodeBleu_score": 45.457737702234816}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Compute the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = computeTruePose(drone_id, true_pixel);\n\t// Check for the presence of the drone\n\tbool found = checkForDrone(drone_id, true_pose);\n\t// Compute the pose error between the camera and world coordinates\n\tEigen::Vector3d pose_error = true_pose - pose_estimates_[drone_id];\n\t// Update the debug result\n\tdebug_result_[drone_id].found = found;\n\tdebug_result_[drone_id].true_pose = true_pose;\n\tdebug_result_[drone_id].pose_error = pose_error;\n\t// Publish the pose error\n\tdrone_pose_err_pub_[drone_id].publish(pose_error);\n}", "CodeBleu_score": 33.90160848468005}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Compute the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = computeTruePose(drone_id, true_pixel);\n\t// Check for the presence of the drone\n\tbool found = checkPresence(drone_id, true_pixel);\n\t// If the drone is found, compute the pose error between the camera and world coordinates\n\tif (found) {\n\t\tEigen::Vector3d pose_error = true_pose - drone_poses_[drone_id];\n\t\t// Update the debug result to indicate success\n\t\tdebug_results_[drone_id].success = true;\n\t\tdebug_results_[drone_id].pose_error = pose_error;\n\t\t// Publish the pose error\n\t\tdrone_pose_err_pub_[drone_id].publish(pose_error);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_results_[drone_id].success = false;\n\t\tdebug_results_[drone_id].pose_error = Eigen::Vector3d::Zero();\n\t}\n}", "CodeBleu_score": 35.1351972002804}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to indices\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If start or end point is inside an obstacle, adjust it\n\tif (checkOccupancy(start_idx)) {\n\t\tif (!AdjustPoint(start_pt, end_pt, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (checkOccupancy(end_idx)) {\n\t\tif (!AdjustPoint(end_pt, start_pt, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.48253115259177}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert 3D coordinates to grid indices\n\tif (!Coord2Index(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!Coord2Index(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\t// Check if start or end point is inside an obstacle\n\tif (checkOccupancy(start_idx)) {\n\t\t// Adjust start point by moving it away from the end point\n\t\twhile (checkOccupancy(start_idx)) {\n\t\t\tstart_pt += (start_pt - end_pt).normalized();\n\t\t\tif (!Coord2Index(start_pt, start_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (checkOccupancy(end_idx)) {\n\t\t// Adjust end point by moving it away from the start point\n\t\twhile (checkOccupancy(end_idx)) {\n\t\t\tend_pt += (end_pt - start_pt).normalized();\n\t\t\tif (!Coord2Index(end_pt, end_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 50.49867035413489}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tVector3i start_idx_tmp, end_idx_tmp;\n\tif (!Coord2Index(start_pt, start_idx_tmp) ||!Coord2Index(end_pt, end_idx_tmp)) {\n\t\treturn false;\n\t}\n\tif (checkOccupancy(start_idx_tmp)) {\n\t\tVector3d dir = (end_pt - start_pt).normalized();\n\t\tint steps = 0;\n\t\twhile (checkOccupancy(start_idx_tmp)) {\n\t\t\tstart_pt += dir * 0.01;\n\t\t\tCoord2Index(start_pt, start_idx_tmp);\n\t\t\tif (steps++ > 10000) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (checkOccupancy(end_idx_tmp)) {\n\t\tVector3d dir = (start_pt - end_pt).normalized();\n\t\tint steps = 0;\n\t\twhile (checkOccupancy(end_idx_tmp)) {\n\t\t\tend_pt += dir * 0.01;\n\t\t\tCoord2Index(end_pt, end_idx_tmp);\n\t\t\tif (steps++ > 10000) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tstart_idx = start_idx_tmp;\n\tend_idx = end_idx_tmp;\n\treturn true;\n}", "CodeBleu_score": 49.36671823391555}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = posToId(min_pos);\n\tEigen::Vector3i max_id = posToId(max_pos);\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.7726480457598}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tworldToMap3D(min_pos, min_id);\n\tworldToMap3D(max_pos, max_id);\n\tresetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.02533129138336}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tthis->worldToMap3d(min_pos, min_id);\n\tthis->worldToMap3d(max_pos, max_id);\n\tthis->resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.735603917619}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble min_x_coeff = (0 - camera_pt.x()) / diff.x();\n\tdouble max_x_coeff = (map_width_ - camera_pt.x()) / diff.x();\n\tdouble min_y_coeff = (0 - camera_pt.y()) / diff.y();\n\tdouble max_y_coeff = (map_height_ - camera_pt.y()) / diff.y();\n\tdouble min_z_coeff = (0 - camera_pt.z()) / diff.z();\n\tdouble max_z_coeff = (map_depth_ - camera_pt.z()) / diff.z();\n\n\tdouble min_coeff = fmax(fmax(fmin(min_x_coeff, max_x_coeff), fmin(min_y_coeff, max_y_coeff)), fmin(min_z_coeff, max_z_coeff));\n\tmin_coeff = fmax(fmin(min_coeff, 1.0), 0.0);\n\treturn camera_pt + min_coeff * diff;\n}", "CodeBleu_score": 35.94982221332322}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = pt;\n\tEigen::Vector3d max_pt = pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tdouble min_coeff = 0.0;\n\t\tdouble max_coeff = 0.0;\n\t\tif (diff(i)!= 0.0) {\n\t\t\tmin_coeff = (min_pt(i) - camera_pt(i)) / diff(i);\n\t\t\tmax_coeff = (max_pt(i) - camera_pt(i)) / diff(i);\n\t\t}\n\t\tif (min_coeff < 0.0) {\n\t\t\tmin_coeff = 0.0;\n\t\t}\n\t\tif (max_coeff > 1.0) {\n\t\t\tmax_coeff = 1.0;\n\t\t}\n\t\tif (min_coeff > max_coeff) {\n\t\t\tmin_coeff = max_coeff;\n\t\t}\n\t\tmin_pt(i) = camera_pt(i) + min_coeff * diff(i);\n\t\tmax_pt(i) = camera_pt(i) + max_coeff * diff(i);\n\t}\n\treturn min_pt;\n}", "CodeBleu_score": 45.91243938456328}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_min = 0, x_max = 0, y_min = 0, y_max = 0, z_min = 0, z_max = 0;\n\tif (diff[0] > 0) {\n\t\tx_max = (max_x - camera_pt[0]) / diff[0];\n\t} else if (diff[0] < 0) {\n\t\tx_min = (min_x - camera_pt[0]) / diff[0];\n\t}\n\tif (diff[1] > 0) {\n\t\ty_max = (max_y - camera_pt[1]) / diff[1];\n\t} else if (diff[1] < 0) {\n\t\ty_min = (min_y - camera_pt[1]) / diff[1];\n\t}\n\tif (diff[2] > 0) {\n\t\tz_max = (max_z - camera_pt[2]) / diff[2];\n\t} else if (diff[2] < 0) {\n\t\tz_min = (min_z - camera_pt[2]) / diff[2];\n\t}\n\tdouble x_scale = 1, y_scale = 1, z_scale = 1;\n\tif (x_min > 0) {\n\t\tx_scale = x_min;\n\t} else if (x_max > 0) {\n\t\tx_scale = x_max;\n\t}\n\tif (y_min > 0) {\n\t\ty_scale = y_min;\n\t} else if (y_max > 0) {\n\t\ty_scale = y_max;\n\t}\n\tif (z_min > 0) {\n\t\tz_scale = z_min;\n\t} else if (z_max > 0) {\n\t\tz_scale = z_max;\n\t}\n\tEigen::Vector3d new_pt = camera_pt + diff * min(x_scale, min(y_scale, z_scale));\n\treturn new_pt;\n}", "CodeBleu_score": 40.485077305748504}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// If an update is needed, project the depth image into points and process them with raycasting\n\tif (md_.occ_update_needed_) {\n\t\t// Project the depth image into points\n\t\tstd::vector<cv::Point3f> points;\n\t\tprojectDepthImage(md_.depth_img_, points);\n\n\t\t// Process the points with raycasting\n\t\traycastProcess(points);\n\n\t\t// If the local map has been updated, clear and inflate the local map\n\t\tif (md_.local_map_updated_) {\n\t\t\tclearAndInflateLocalMap();\n\t\t\tmd_.local_map_updated_ = false;\n\t\t}\n\n\t\t// Reset the update flag\n\t\tmd_.occ_update_needed_ = false;\n\t}\n\n\t// Handle timeout errors for odometry or depth data\n\tif ((ros::Time::now() - md_.last_odom_update_time_).toSec() > md_.odom_timeout_) {\n\t\tROS_ERROR(\"Odometry data timeout. Stopping.\");\n\t\tmd_.occ_update_needed_ = false;\n\t\tmd_.odom_timeout_reached_ = true;\n\t}\n\tif ((ros::Time::now() - md_.last_depth_img_update_time_).toSec() > md_.depth_img_timeout_) {\n\t\tROS_ERROR(\"Depth image data timeout. Stopping.\");\n\t\tmd_.occ_update_needed_ = false;\n\t\tmd_.depth_img_timeout_reached_ = true;\n\t}\n}", "CodeBleu_score": 61.23702458290092}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time.\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// If an update is needed, project the depth image into points and process them with raycasting.\n\tif (md_.update_occ_grid_ && md_.new_depth_data_) {\n\t\t// Project the depth image into points.\n\t\tprojectDepthImage();\n\n\t\t// Process the points with raycasting.\n\t\traycastProcess();\n\n\t\t// Clear and inflate the local map if it has been updated.\n\t\tif (md_.local_map_updated_) {\n\t\t\tclearAndInflateLocalMap();\n\t\t}\n\n\t\t// Reset the flags.\n\t\tmd_.update_occ_grid_ = false;\n\t\tmd_.new_depth_data_ = false;\n\t}\n\n\t// Handle timeout errors for odometry or depth data and set relevant flags.\n\tif ((ros::Time::now() - md_.last_odom_update_time_).toSec() > md_.odom_timeout_) {\n\t\tROS_ERROR(\"Odometry timeout.\");\n\t\tmd_.update_occ_grid_ = true;\n\t\tmd_.new_depth_data_ = true;\n\t\tmd_.odom_timeout_occurred_ = true;\n\t}\n\tif ((ros::Time::now() - md_.last_depth_update_time_).toSec() > md_.depth_timeout_) {\n\t\tROS_ERROR(\"Depth image timeout.\");\n\t\tmd_.update_occ_grid_ = true;\n\t\tmd_.new_depth_data_ = true;\n\t\tmd_.depth_timeout_occurred_ = true;\n\t}\n}", "CodeBleu_score": 61.67187708754048}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// if an update is needed, project the depth image into points and process them with raycasting\n\tif (md_.need_update_) {\n\t\t// project depth image into points\n\t\tstd::vector<cv::Point3f> points;\n\t\tprojectDepthImage(md_.depth_image_, points);\n\n\t\t// process the points with raycasting\n\t\traycastProcess(points);\n\n\t\t// if the local map has been updated, clear and inflate the local map\n\t\tif (md_.local_map_updated_) {\n\t\t\tclearAndInflateLocalMap();\n\t\t}\n\t}\n\n\t// handle timeout errors for odometry or depth data\n\tif ((ros::Time::now() - md_.last_occ_update_time_).toSec() > md_.timeout_occ_) {\n\t\tROS_ERROR(\"Occupancy grid update timed out.\");\n\t\tmd_.need_update_ = false;\n\t\tmd_.local_map_updated_ = false;\n\t}\n}", "CodeBleu_score": 49.93698749800771}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure_sum = 0.0f;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure_sum += fmeasure;\n\t}\n\treturn fmeasure_sum / image_fns.size();\n}", "CodeBleu_score": 66.13468594919716}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure_sum = 0.f;\n\tfor (unsigned int i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error opening: \" << image_fns[i] << endl;\n\t\t\treturn 0.f;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure_sum += fmeasure;\n\t}\n\treturn fmeasure_sum / float(image_fns.size());\n}", "CodeBleu_score": 58.94268623345605}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure = 0.0f;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> ell_gt, ell_dt;\n\t\t_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\t\tfmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\t}\n\tfmeasure /= float(image_fns.size());\n\treturn fmeasure;\n}", "CodeBleu_score": 76.04654819161027}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2;\n\tif (foci!= NULL) {\n\t\tangle1 = atan2(y - foci[1], x - foci[0]);\n\t\tangle2 = atan2(y - foci[3], x - foci[2]);\n\t\treturn angle_diff_signed(angle1, angle2);\n\t} else {\n\t\treturn atan2(y, x);\n\t}\n}", "CodeBleu_score": 40.28769263901722}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_a, angle_b, normal_angle;\n\tif (foci!= NULL) {\n\t\tangle_a = atan2(y, x - foci[0]);\n\t\tangle_b = atan2(y, x - foci[1]);\n\t\tnormal_angle = angle_diff_signed(angle_b, angle_a);\n\t} else {\n\t\tnormal_angle = atan2(y, x);\n\t}\n\treturn normal_angle;\n}", "CodeBleu_score": 34.40275112154148}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_a, angle_b;\n\tfloat normal_angle;\n\n\tif (foci) {\n\t\tangle_a = atan2(y, x - foci[0]);\n\t\tangle_b = atan2(y, x - foci[1]);\n\t\tnormal_angle = angle_diff_signed(angle_a, angle_b);\n\t} else {\n\t\tnormal_angle = atan2(y, x);\n\t}\n\n\treturn normal_angle;\n}", "CodeBleu_score": 32.81790799399077}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"ellipse_det_cb\");\n\tint num_lost = 0;\n\tint num_regain = 0;\n\tfor(int i = 0; i < msg->detection_infos.size(); i++)\n\t{\n\t\tif(msg->detection_infos[i].id == \"T\")\n\t\t{\n\t\t\tnum_regain++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum_lost++;\n\t\t}\n\t}\n\tif(num_lost >= VISION_THRES)\n\t{\n\t\tis_detected = false;\n\t}\n\tif(num_regain >= VISION_THRES)\n\t{\n\t\tis_detected = true;\n\t}\n\tif(is_detected)\n\t{\n\t\tellipse_det = msg->detection_infos[0];\n\t\tellipse_det.id = \"T\";\n\t}\n\telse\n\t{\n\t\tellipse_det.id = \"T\";\n\t\tellipse_det.ellipse_center.x = 0;\n\t\tellipse_det.ellipse_center.y = 0;\n\t\tellipse_det.ellipse_center.z = 0;\n\t\tellipse_det.ellipse_size.x = 0;\n\t\tellipse_det.ellipse_size.y = 0;\n\t\tellipse_det.ellipse_size.z = 0;\n\t\tellipse_det.ellipse_angle.x = 0;\n\t\tellipse_det.ellipse_angle.y = 0;\n\t\tellipse_det.ellipse_angle.z = 0;\n\t}\n}", "CodeBleu_score": 53.600614688338744}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"ellipse_det_cb\");\n\tint num_lost = 0;\n\tint num_regain = 0;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].id == 1) {\n\t\t\tnum_regain++;\n\t\t\tellipse_det.is_detected = true;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tellipse_det.is_detected = false;\n\t\t}\n\t}\n\tif (num_lost >= VISION_THRES) {\n\t\tellipse_det.is_detected = false;\n\t}\n\tif (num_regain >= VISION_THRES) {\n\t\tellipse_det.is_detected = true;\n\t}\n\tellipse_det.num_lost = num_lost;\n\tellipse_det.num_regain = num_regain;\n\tellipse_det.ellipse_det_pub.publish(ellipse_det);\n}", "CodeBleu_score": 44.73489356619196}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tellipse_det.ellipse_det_info.clear();\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tellipse_det.ellipse_det_info.push_back(msg->detection_infos[i]);\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (ellipse_det.ellipse_det_info.size() > 0) {\n\t\tstd::swap(ellipse_det.ellipse_det_info[0].sight_angle[0], ellipse_det.ellipse_det_info[0].sight_angle[1]);\n\t}\n}", "CodeBleu_score": 66.05868164989471}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// check the safety of the current position\n\tbool safe = Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n\treturn safe;\n}", "CodeBleu_score": 62.745855781660296}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node->parent_!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.649509291890034}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 52.63619100589134}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.941987291368946}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"Received nei odom\");\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].theta = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].vx = odom->twist.twist.linear.x;\n\tstate_nei[id].vy = odom->twist.twist.linear.y;\n\tstate_nei[id].vz = odom->twist.twist.linear.z;\n\tstate_nei[id].omega = odom->twist.twist.angular.z;\n\tstate_nei[id].t = odom->header.stamp.toSec();\n\t//ROS_INFO(\"Nei %d: %f %f %f %f %f %f %f %f %f\", id, state_nei[id].x, state_nei[id].y, state_nei[id].z, state_nei[id].theta, state_nei[id].vx, state_nei[id].vy, state_nei[id].vz, state_nei[id].omega, state_nei[id].t);\n\tif(simulation_mode) {\n\t\tif((start_pos-state_nei[id]).norm > 5)\n\t\t\tget_nei_state[id] = false;\n\t\telse\n\t\t\tget_nei_state[id] = true;\n\t}\n\telse\n\t\tget_nei_state[id] = true;\n}", "CodeBleu_score": 49.708943979323074}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif(simulation_mode){\n\t\tif((odom->pose.pose.position.x-start_pos.x)*(odom->pose.pose.position.x-start_pos.x)+(odom->pose.pose.position.y-start_pos.y)*(odom->pose.pose.position.y-start_pos.y)>(5*5)){\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse{\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse{\n\t\tget_nei_state[id] = true;\n\t}\n\tif(get_nei_state[id]){\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\t\tstate_nei[id].y = odom->pose.pose.position.y;\n\t\tstate_nei[id].z = odom->pose.pose.position.z;\n\t}\n}", "CodeBleu_score": 48.85361400894327}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"id %d\",id);\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\t//ROS_INFO(\"state_nei[%d] = %f, %f, %f\", id, state_nei[id].x, state_nei[id].y, state_nei[id].z);\n\t//ROS_INFO(\"state_nei[%d] = %f, %f, %f\", id, state_nei[id].x, state_nei[id].y, state_nei[id].z);\n\tif (simulation_mode) {\n\t\tif ((start_pos-state_nei[id]).norm > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 52.226139260293316}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t}\n}", "CodeBleu_score": 57.97973197336893}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count >= 5) {\n\t\tupdate_count = 0;\n\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t}\n}", "CodeBleu_score": 57.15957413509168}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tif (update_counter == 0) {\n\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t\tupdate_counter = 5;\n\t}\n\tupdate_counter--;\n}", "CodeBleu_score": 58.07911403240787}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *global_pcl);\n\t\tinflate_point_cloud(global_pcl, inflated_gpcl);\n\t}\n}", "CodeBleu_score": 48.47684100622459}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl);\n\t}\n}", "CodeBleu_score": 49.078908293643686}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl_inflated);\n\t\tget_gpcl = true;\n\t}\n}", "CodeBleu_score": 46.23006121528474}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert laser scan to point cloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tprojector_.projectLaser(*local_point, cloud);\n\n\t// Convert to ROS data type\n\tsensor_msgs::PointCloud2 cloud_msg;\n\tpcl::toROSMsg(cloud, cloud_msg);\n\tcloud_msg.header.frame_id = \"base_link\";\n\tcloud_msg.header.stamp = ros::Time::now();\n\n\t// Publish the data\n\tcloud_pub_.publish(cloud_msg);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!simulation_mode_) {\n\t\tlocal_map_merge_odom(cloud_msg, odom);\n\t}\n}", "CodeBleu_score": 47.53505873656172}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//Convert laser scan to point cloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tprojector_.projectLaser(*local_point, cloud);\n\t//Convert to ROS message\n\tsensor_msgs::PointCloud2 cloud_msg;\n\tpcl::toROSMsg(cloud, cloud_msg);\n\tcloud_msg.header.frame_id = local_point->header.frame_id;\n\t//Merge point cloud with local map\n\tif (!simulation_mode) {\n\t\tmap_merge_odom(cloud_msg, odom);\n\t} else {\n\t\tmap_merge_laser(cloud_msg);\n\t}\n}", "CodeBleu_score": 50.982973480875884}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg\n\tglobal_pcl_pub.publish\n\tpcl::toROSMsg\n\tinflate_pcl_pub.publish\n}", "CodeBleu_score": 12.060692632569097}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg(global_pcl_map, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\tpcl::toROSMsg(inflated_pcl_map, inflated_pcl_msg);\n\tinflated_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflated_pcl_msg);\n}", "CodeBleu_score": 44.177229174607845}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg\n\tglobal_pcl_pub.publish\n\tpcl::toROSMsg\n\tinflate_pcl_pub.publish\n}", "CodeBleu_score": 12.060692632569097}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  ROS_INFO(\"controlLoop_\");\n  // Calculate target foot positions based on the desired pose using the body controller\n  float target_foot_positions[4][3];\n  body_controller_.control(target_foot_positions);\n\n  // Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions\n  float target_joints[12];\n  for (size_t i = 0; i < 4; i++) {\n    // Compute velocity commands for the legs\n    base_.legs[i]->setVelocityCommand(target_foot_positions[i]);\n\n    // Perform inverse kinematics to determine target joint positions\n    kinematics_.inverse(i, target_foot_positions[i], target_joints + 3 * i);\n  }\n\n  // Publish foot contact information and joint positions\n  publishJoints_(target_joints);\n  publishFootContacts_(base_.legs[0]->foot_contact());\n}", "CodeBleu_score": 53.213328683286555}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    ROS_INFO(\"controlLoop_\");\n    //Update the state of the robot\n    base_.update();\n    //Get the desired pose from the pose controller\n    Eigen::Vector3d desired_position;\n    Eigen::Quaterniond desired_orientation;\n    Eigen::Vector3d desired_velocity;\n    Eigen::Vector3d desired_angular_velocity;\n    body_controller_.getPoseCommand(desired_position, desired_orientation, desired_velocity, desired_angular_velocity);\n    //Calculate the target foot positions based on the desired pose\n    Eigen::Vector3d target_foot_positions[4];\n    kinematics_.forward(desired_position, desired_orientation, target_foot_positions);\n    //Calculate the velocity commands for the legs\n    float target_velocities[12];\n    leg_controller_.calculateVelocityCommands(base_.legs, target_foot_positions, target_velocities);\n    //Perform inverse kinematics to determine target joint positions\n    float target_joints[12];\n    kinematics_.inverse(target_velocities, target_joints);\n    //Publish foot contact information and joint positions\n    publishJoints_(target_joints);\n    bool foot_contacts[4];\n    base_.getFootContacts(foot_contacts);\n    publishFootContacts_(foot_contacts);\n}", "CodeBleu_score": 50.51259382633023}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// Create a ContactsStamped message\n\t\tContactsStamped contacts_msg;\n\t\t// Populate the message with the current gait phase of each leg\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts.resize(4);\n\t\t\tcontacts_msg.contacts[i].name = base_.legs[i]->name;\n\t\t\tcontacts_msg.contacts[i].state = foot_contacts[i];\n\t\t}\n\t\t// Publish the message\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 52.66912025679419}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contact_pub_enabled_ &&!gazebo_sim_) {\n\t\t// Create message\n\t\tbiped_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.contacts.resize(4);\n\t\t// Populate message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].leg = i;\n\t\t\tcontacts_msg.contacts[i].contact = foot_contacts[i];\n\t\t\tcontacts_msg.contacts[i].gait_phase = robot_base_.legs[i]->gait_phase;\n\t\t}\n\t\t// Publish message\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 64.7810440935221}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\t// If foot contact publishing is enabled and the robot is not in Gazebo, create a ContactsStamped message.\n\tif (publish_foot_contacts_ &&!gazebo_simulation_) {\n\t\t// Create a ContactsStamped message.\n\t\tsensor_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"world\";\n\t\t// Populate the message with the current gait phase of each leg.\n\t\tcontacts_msg.contacts.resize(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].name = base_.legs[i]->name;\n\t\t\tcontacts_msg.contacts[i].states.resize(1);\n\t\t\tcontacts_msg.contacts[i].states[0].state = foot_contacts[i];\n\t\t\tcontacts_msg.contacts[i].states[0].name = \"contact\";\n\t\t}\n\t\t// Publish the message.\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 61.23974730606043}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tdef joints_msg = new JointState()\n\tjoints_msg.name = joints.name[0..11]\n\tjoints_msg.position = joints.position[0..11]\n\tjoints_msg.velocity = joints.velocity[0..11]\n\tjoints_msg.effort = joints.effort[0..11]\n\tjoints_msg.header.stamp = self.get_clock().now()\n\tself.joints_publisher.publish(joints_msg)\n\n\tdef joint_trajectory_msg = new JointTrajectory()\n\tjoint_trajectory_msg.joint_names = joints.name[0..11]\n\tjoint_trajectory_msg.header.stamp = self.get_clock().now()\n\tjoint_trajectory_msg.points = [new JointTrajectoryPoint()]\n\tjoint_trajectory_msg.points[0].positions = joints.position[0..11]\n\tjoint_trajectory_msg.points[0].velocities = joints.velocity[0..11]\n\tjoint_trajectory_msg.points[0].accelerations = joints.effort[0..11]\n\tjoint_trajectory_msg.points[0].time_from_start = self.get_clock().now() + self.get_clock().seconds(1)\n\tself.joint_trajectory_publisher.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 35.53413398441657}, {"code": "def joints_cmd_callback(self, joints){\n\t\tdef joints_msg = new JointState()\n\tjoints_msg.name = joints.name[0..11]\n\tjoints_msg.position = joints.position[0..11]\n\tjoints_msg.velocity = joints.velocity[0..11]\n\tjoints_msg.effort = joints.effort[0..11]\n\tjoints_msg.header.stamp = self.get_clock().now()\n\tself.joints_pub.publish(joints_msg)\n\n\tdef joint_trajectory = new JointTrajectory()\n\tjoint_trajectory.joint_names = joints.name[0..11]\n\tdef point = new JointTrajectoryPoint()\n\tpoint.positions = joints.position[0..11]\n\tpoint.velocities = joints.velocity[0..11]\n\tpoint.accelerations = joints.effort[0..11]\n\tpoint.time_from_start = self.get_clock().now() + 1.0\n\tjoint_trajectory.points = [point]\n\tself.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 48.34238923997018}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// create a minimal joints message with the first 12 joint positions\n\tdef minimal_joints = new JointState()\n\tminimal_joints.header.stamp = rospy.Time.now()\n\tminimal_joints.name = joints.name[0..11]\n\tminimal_joints.position = joints.position[0..11]\n\tminimal_joints.velocity = joints.velocity[0..11]\n\tminimal_joints.effort = joints.effort[0..11]\n\t// publish the minimal joints message\n\tjoints_pub.publish(minimal_joints)\n\t// create a joint trajectory message with the same positions and a specified duration\n\tdef joint_trajectory = new JointTrajectory()\n\tjoint_trajectory.header.stamp = rospy.Time.now()\n\tjoint_trajectory.joint_names = joints.name[0..11]\n\tdef trajectory_point = new JointTrajectoryPoint()\n\ttrajectory_point.positions = joints.position[0..11]\n\ttrajectory_point.velocities = joints.velocity[0..11]\n\ttrajectory_point.accelerations = joints.effort[0..11]\n\ttrajectory_point.time_from_start = rospy.Duration.fromSec(0.01)\n\tjoint_trajectory.points = [trajectory_point]\n\t// publish the joint trajectory message\n\tjoint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 46.17019477384315}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contact_state_.left = false;\n\tfoot_contact_state_.right = false;\n\tfor (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n\t\tstd::vector<std::string> collision_vector;\n\t\tboost::split(collision_vector, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\t\tif (collision_vector[0] == \"left_foot\" || collision_vector[0] == \"right_foot\") {\n\t\t\tif (collision_vector[0] == \"left_foot\") {\n\t\t\t\tfoot_contact_state_.left = true;\n\t\t\t} else if (collision_vector[0] == \"right_foot\") {\n\t\t\t\tfoot_contact_state_.right = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.74383309986634}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contact_states_.left = false;\n\tfoot_contact_states_.right = false;\n\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link_name = _msg->contact(i).collision1();\n\t\tboost::split(split_names_, link_name, boost::is_any_of(\"::\"));\n\t\tif (split_names_[1] == \"left_foot_link\")\n\t\t\tfoot_contact_states_.left = true;\n\t\tif (split_names_[1] == \"right_foot_link\")\n\t\t\tfoot_contact_states_.right = true;\n\t}\n}", "CodeBleu_score": 36.621185277588765}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contact_states[i] = false;\n\t}\n\n\t// Iterate through contacts in message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split collision string to identify contact link\n\t\tstd::vector<std::string> collision_vector;\n\t\tboost::split(collision_vector, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n\n\t\t// Check if contact link is a foot link\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (collision_vector[1] == foot_link_names[j]) {\n\t\t\t\tfoot_contact_states[j] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 62.88892808684716}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\t// Project thrust onto body z-axis.\n\tconst double thrust = vehicle_parameters_.mass_ * acceleration.dot(Eigen::Vector3d::UnitZ());\n\n\t// Combine angular acceleration and thrust into a single vector.\n\tEigen::Vector3d angular_acc_thrust;\n\tangular_acc_thrust << angular_acceleration, thrust;\n\n\t// Multiply with a predefined matrix.\n\t*rotor_velocities = rotor_velocity_matrix_ * angular_acc_thrust;\n\n\t// Ensure non-negative values.\n\t*rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n\n\t// Take the square root of each component.\n\t*rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 55.10705014124666}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n// Check if the controller is active.\nif (!controller_active_) {\n  rotor_velocities->setZero();\n  return;\n}\n\n// Compute the desired acceleration.\nEigen::Vector3d acceleration;\nComputeDesiredAcceleration(&acceleration);\n\n// Compute the desired angular acceleration.\nEigen::Vector3d angular_acceleration;\nComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n// Project thrust onto the body z-axis.\nconst Eigen::Vector3d thrust = vehicle_parameters_.mass_ * acceleration;\nconst Eigen::Vector3d thrust_W = odometry_.orientation.toRotationMatrix().transpose() * thrust;\nconst double thrust_z = thrust_W.z();\n\n// Combine thrust and angular acceleration into a single vector.\nEigen::VectorXd angular_acceleration_thrust(3 + vehicle_parameters_.rotor_configuration_.rotors.size);\nangular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\nangular_acceleration_thrust.block<1, 1>(3, 0) = Eigen::VectorXd::Constant(1, thrust_z);\n\n// Compute the rotor velocities.\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size);\n*rotor_velocities = rotor_acceleration_matrix_ * angular_acceleration_thrust;\n\n// Ensure non-negative values.\n*rotor_velocities = rotor_velocities->cwiseSqrt();\n*rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n}", "CodeBleu_score": 71.94715774431172}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n\n  // Check if the controller is active.\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute the desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust = vehicle_parameters_.mass_ * acceleration;\n  thrust[2] = 0;\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector3d thrust_and_angular_acceleration;\n  thrust_and_angular_acceleration << thrust, angular_acceleration;\n\n  // Project thrust and angular acceleration onto the rotors.\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.rotors.transpose() * thrust_and_angular_acceleration;\n\n  // Ensure non-negative values.\n  rotor_velocities->array() = rotor_velocities->array().max(0);\n\n  // Take the square root of each component.\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 49.251472412973726}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// TODO: Implement this function to compute the desired acceleration.\n// Feel free to use the provided functions to compute the position and velocity errors.\n// The desired acceleration should be stored in the acceleration variable passed into this function.\n\n// Transform the vehicle's velocity to the world frame.\nEigen::Vector3d velocity_world =\nodometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n// Compute the position and velocity errors.\nEigen::Vector3d position_error = ComputePositionError();\nEigen::Vector3d velocity_error = ComputeVelocityError(velocity_world);\n\n// Calculate the desired acceleration.\n*acceleration = -position_gain_ * position_error - velocity_gain_ * velocity_error +\ncommand_trajectory_.acceleration + Eigen::Vector3d(0.0, 0.0, gravity_);\n}", "CodeBleu_score": 32.58391033873633}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Transform the velocity to the world frame\n\tEigen::Vector3d velocity_world = vehicle_state_.orientation.toRotationMatrix() * vehicle_state_.velocity;\n\t// Compute the position and velocity errors\n\tEigen::Vector3d position_error = command_trajectory_.position - vehicle_state_.position;\n\tEigen::Vector3d velocity_error = command_trajectory_.velocity - velocity_world;\n\t// Calculate the desired acceleration\n\t*acceleration = -position_gain_ * position_error - velocity_gain_ * velocity_error;\n\t// Adjust for vehicle mass, gravity, and commanded acceleration\n\t*acceleration += vehicle_state_.mass * (vehicle_state_.gravity_vector + command_trajectory_.acceleration);\n}", "CodeBleu_score": 38.429780599412695}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position and velocity errors\n\tEigen::Vector3d position_error = position_error_;\n\tEigen::Vector3d velocity_error = velocity_error_;\n\n\t// Transform the velocity error to the world frame\n\tvelocity_error = odometry_.orientation.toRotationMatrix().transpose() * velocity_error;\n\n\t// Compute the desired acceleration\n\t*acceleration = -position_gain_ * position_error - velocity_gain_ * velocity_error - gravity_ * Eigen::Vector3d::UnitZ() + command_acceleration_;\n\t*acceleration /= mass_;\n}", "CodeBleu_score": 27.858292420756282}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tEigen::Vector3d angular_acceleration_thrust;\n\tComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n\tEigen::Vector4d angular_acceleration_thrust_reference(angular_acceleration_thrust(0), angular_acceleration_thrust(1), angular_acceleration_thrust(2), control_attitude_thrust_reference_(3));\n\n\trotor_velocities->resize(kRotors);\n\n\t// TODO: Calculate the desired rotor velocities here\n\t// rotor_velocities =...\n\t*rotor_velocities = rotor_velocity_matrix_ * angular_acceleration_thrust_reference;\n\n\t// ensure that the rotor velocities are at least one\n\trotor_velocities->array() = rotor_velocities->array().max(1);\n\n\t// take the square root of each rotor velocity\n\trotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 51.77240602310117}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tEigen::VectorXd angular_acceleration_thrust = Eigen::VectorXd(4);\n\tComputeDesiredAngularAcc(&angular_acceleration_thrust.block<3, 1>(0));\n\tangular_acceleration_thrust[3] = control_attitude_thrust_reference_(3);\n\n\tEigen::Matrix<double, 4, 4> rotor_velocities_matrix = Eigen::MatrixXd::Identity(4, 4);\n\trotor_velocities_matrix.block<3, 3>(0, 0) = inertia_.inverse() * attitude_.toRotationMatrix();\n\n\t*rotor_velocities = rotor_velocities_matrix * angular_acceleration_thrust;\n\trotor_velocities->cwiseSqrt();\n\trotor_velocities->cwiseMax(Eigen::VectorXd::Ones(4));\n}", "CodeBleu_score": 50.92763649069097}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// Ensure the input and parameters are valid\n\tassert(rotor_velocities);\n\tassert(gain_attitude_.size() == 3);\n\tassert(gain_angular_rate_.size() == 3);\n\tassert(gain_thrust_.size() == 1);\n\tassert(rotor_velocities->size() == 4);\n\n\t// Resizes the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(4);\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d angular_acceleration_thrust;\n\tComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n\t// Combine the desired angular acceleration and thrust reference into a single vector\n\tEigen::Vector4d angular_acceleration_thrust_reference;\n\tangular_acceleration_thrust_reference << angular_acceleration_thrust, control_attitude_thrust_reference_(3);\n\n\t// Calculate the rotor velocities by multiplying with a predefined matrix\n\t*rotor_velocities = rotor_velocity_gain_ * angular_acceleration_thrust_reference;\n\n\t// Ensure the rotor velocities are at least one\n\trotor_velocities->array() = rotor_velocities->array().max(1.0);\n\n\t// Take the square root of each component\n\trotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 57.29091211166284}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.x = copied_obj.x[start_index:end_index]\n    copied_obj.y = copied_obj.y[start_index:end_index]\n    copied_obj.z = copied_obj.z[start_index:end_index]\n    return copied_obj\n", "CodeBleu_score": 34.32112540570621}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.data = copied_obj.data[start_index:end_index]\n    return copied_obj\n", "CodeBleu_score": 37.94973259415241}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.data = copied_obj.data[start_index:end_index]\n    copied_obj.data_type = copied_obj.data_type[start_index:end_index]\n    copied_obj.data_unit = copied_obj.data_unit[start_index:end_index]\n    return copied_obj", "CodeBleu_score": 33.014720818932375}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    pos = waypoint_msg.pose.position\n    rot = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])\n    # Create a Point object\n    point = Point(pos.x, pos.y, pos.z, yaw)\n    # Check if the current waypoint is different from the last one\n    if point!= self.last_point:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        # Update the last point\n        self.last_point = point\n\n", "CodeBleu_score": 24.655751125823436}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Get the position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    rpy = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z, rpy[2])\n\n    # Check if the current waypoint is different from the last one\n    if len(self.x) > 0 and (point.x!= self.x[-1] or point.y!= self.y[-1] or point.yaw!= self.yaw[-1]):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n        self.yaw = numpy.append(self.yaw, point.yaw)\n", "CodeBleu_score": 23.466790029703553}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Get the position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    euler_angles = euler_from_quaternion(\n        (rotation.x, rotation.y, rotation.z, rotation.w))\n    # Create a Point object\n    point = Point(position.x, position.y, position.z, euler_angles[2])\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or point!= self.last_waypoint:\n        # Append the new point, yaw, and corresponding times\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, euler_angles[2])\n        self.append_times(msg_time, bag_time)\n        # Update the last waypoint\n        self.last_waypoint = point\n", "CodeBleu_score": 23.4243037679432}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 32.64113722173702}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_linear_acceleration_x = numpy.append(self.imu_linear_acceleration_x, msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y = numpy.append(self.imu_linear_acceleration_y, msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z = numpy.append(self.imu_linear_acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 32.260493930132284}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n        self.append_times(self.to_sec(msg.header.stamp), bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n        self.append_times(self.to_sec(msg.header.stamp), bag_time)\n    elif topic == \"/imu/mag\":\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.magnetic_field.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.magnetic_field.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.magnetic_field.z)\n        self.append_times(self.to_sec(msg.header.stamp), bag_time)\n    elif topic == \"/imu/mag_raw\":\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.magnetic_field.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.magnetic_field.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.magnetic_field.z)\n        self.append_times(self.to_sec(msg.header.stamp), bag_time)\n    elif topic == \"/imu/mag_updated\":\n        self.linear_acceleration_x = numpy.append(self.", "CodeBleu_score": 28.454410632937687}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plotting_enabled:\n        fig = pyplot.figure()\n        fig.suptitle(\"Accelerations\")\n        a_x = fig.add_subplot(111)\n        for i, a in enumerate(self.accelerations):\n            a_x.plot(a[:, 0], a[:, 1], label=\"x\")\n            a_x.plot(a[:, 0], a[:, 2], label=\"y\")\n            a_x.plot(a[:, 0], a[:, 3], label=\"z\")\n        pyplot.ylabel(\"Acceleration (m/s^2)\")\n        pyplot.xlabel(\"Time (s)\")\n        pyplot.legend()\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        pyplot.savefig(f\"{self.plot_prefix}_accelerations{plot_suffix}.png\")", "CodeBleu_score": 46.84721451967824}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_enabled:\n        fig = pyplot.figure()\n        fig.suptitle('Accelerations')\n        ax_a_x = fig.add_subplot(311)\n        ax_a_x.plot(self.times, self.a_x, 'r-', label='a_x')\n        ax_a_x.plot(self.times, self.a_y, 'g-', label='a_y')\n        ax_a_x.plot(self.times, self.a_z, 'b-', label='a_z')\n        pyplot.ylabel('Acceleration (m/s^2)')\n        pyplot.legend(loc='upper left')\n        pyplot.xlabel('Time (s)')\n        if plot_suffix is not None:\n            filename = 'accelerations_' + plot_suffix + '.png'\n        else:\n            filename = 'accelerations.png'\n        pyplot.savefig(filename)\n        pyplot.close()\n\n", "CodeBleu_score": 39.10568928403882}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title\n    fig = pyplot.figure()\n    fig.suptitle('Accelerations')\n    # Create a subplot for accelerations\n    a_x = fig.add_subplot(1, 1, 1)\n    # Plot the x, y, and z components of each acceleration dataset\n    for i, a in enumerate(self.accelerations):\n        a_x.plot(a.t, a.x, label='a_x_' + str(i))\n        a_x.plot(a.t, a.y, label='a_y_' + str(i))\n        a_x.plot(a.t, a.z, label='a_z_' + str(i))\n    # Add labels for the x and y axes\n    pyplot.ylabel('Acceleration (m/s^2)')\n    pyplot.xlabel('Time (s)')\n    # Add a legend\n    pyplot.legend()\n    # Save the plot as a PNG file\n    if self.save_plots:\n        filename = self.plot_prefix + '_accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        pyplot.savefig(filename + '.png')", "CodeBleu_score": 43.53470733481306}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for t in self.wrench:\n        if start_time <= t <= end_time:\n            collision_times.append(t)\n    return collision_times\n", "CodeBleu_score": 32.86064105686062}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n//  if (data == nullptr) {\n//    return;\n//  }\n//  const float multiplier =\n//      (this->dist * this->dist) / (this->focal_length * this->focal_length);\n//  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n//  const Eigen::VectorXf rms_noise =\n//      multiplier * this->rms_noise.array().square();\n//  const Eigen::VectorXf noise =\n//      rms_noise.array().square().sqrt() * this->noise_generator.array();\n//  for (uint32_t i = 0; i < width * height; ++i) {\n//    if (InRange(data_vector_map[i])) {\n//      data_vector_map[i] += noise[i];\n//    } else {\n//      data_vector_map[i] = this->bad_point;\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t//  if (data == nullptr) {\n//    return;\n//  }\n//\n//  const float multiplier =\n//      static_cast<float>(width) / static_cast<float>(kDepthWidth);\n//  const Eigen::VectorXf data_vector_map =\n//      Eigen::Map<Eigen::VectorXf>(data, width * height);\n//  const Eigen::VectorXf rms_noise =\n//      Eigen::VectorXf::Ones(width * height).array() * this->rms_noise;\n//  const Eigen::VectorXf noise =\n//      rms_noise.array() *\n//      Eigen::VectorXf::Random(width * height).array().abs();\n//\n//  for (uint32_t i = 0; i < width * height; i++) {\n//    if (InRange(data_vector_map(i) * 1000.0)) {\n//      data[i] = (data_vector_map(i) * 1000.0 + noise(i)) / 1000.0;\n//    } else {\n//      data[i] = kBadPoint;\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n// Check if data pointer is null\n  if (data == nullptr) {\n    return;\n  }\n\n// Calculate multiplier based on camera parameters\n  const float multiplier =\n      this->dist / (this->focal_length * this->focal_length);\n\n// Map data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n// Compute RMS noise\n  const float rms_noise = std::sqrt(this->ComputeRmsNoise(width, height));\n\n// For each pixel, add noise if the pixel value is in range, otherwise set\n// pixel to bad point value\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) +=\n          this->GenerateNoise(rms_noise * multiplier * data_vector_map(i));\n    } else {\n      data_vector_map(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.829254426798485}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time\n\tdouble sim_time = this->world_->SimTime().Double();\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time(sim_time);\n\t// Write the trajectory message to the bag file using the specified namespace and waypoint topic\n\tthis->waypoint_bag_writer_.write(this->waypoint_topic_ns_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 35.857444571262356}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\tif (trajectory_msg->points.empty()) {\n\t\treturn;\n\t}\n\tros::Time t = ros::Time::now();\n\tif (t.is_zero()) {\n\t\tROS_WARN_STREAM(\"Time is zero. Skipping message.\");\n\t\treturn;\n\t}\n\tif (bag_write_) {\n\t\tif (bag_write_->isOpen()) {\n\t\t\tbag_write_->write(waypoint_topic_, t, *trajectory_msg);\n\t\t} else {\n\t\t\tROS_ERROR_STREAM(\"Bag file \" << bag_write_->getFileName()\n\t\t\t\t\t<< \" is not open.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 44.107827903885486}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//    ROS_INFO(\"WaypointCallback\");\n    // Get the current simulation time.\n    common::Time current_time = world_->SimTime();\n    // Convert the simulation time to ROS time.\n    ros::Time ros_time(current_time.sec, current_time.nsec);\n    // Write the trajectory message to the bag file using the specified namespace and waypoint topic.\n    bag_.write(waypoint_namespace_, trajectory_msg, ros_time);\n}", "CodeBleu_score": 57.69228340229857}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\tsensor_msgs::ActuatorVelocities rot_velocities_msg;\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\trot_velocities_msg.header.stamp = ros_time;\n\trot_velocities_msg.header.frame_id = \"base_link\";\n\tint i = 0;\n\tfor (auto m = motor_joints_.begin(); m!= motor_joints_.end(); ++m) {\n\t\trot_velocities_msg.name[i] = m->first;\n\t\trot_velocities_msg.angular_velocities[i] = m->second->GetVelocity(0) / motor_velocity_slowdown_;\n\t\ti++;\n\t}\n\tmotor_velocities_pub_.publish(rot_velocities_msg);\n\tif (bag_ptr_->is_open()) {\n\t\tbag_ptr_->write(motor_topic_, ros_time, rot_velocities_msg);\n\t}\n}", "CodeBleu_score": 55.23452009310611}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_now = ConvertGazeboToRosTime(now);\n\tsensor_msgs::ActuatorVelocities rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_now;\n\trot_velocities_msg.header.frame_id = \"base_link\";\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\tunsigned int i = 0;\n\tfor (auto m = motor_joints_.begin(); m!= motor_joints_.end(); ++m) {\n\t\trot_velocities_msg.name[i] = m->first;\n\t\trot_velocities_msg.angular_velocities[i] = m->second->GetVelocity(0)\n\t\t\t\t* motor_reductions_[m->first];\n\t\ti++;\n\t}\n\tmotor_velocities_pub_.publish(rot_velocities_msg);\n\tbag_.write(motor_topic_ns_, rot_velocities_msg, ros_now);\n}", "CodeBleu_score": 54.18671578280468}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_time = ConvertGazeboTime(now);\n\n\t// Prepare the message\n\tmav_msgs::Actuators rot_velocities_msg;\n\trot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n\t// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n\tint i = 0;\n\tfor (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); ++m) {\n\t\trot_velocities_msg.angular_velocities[i] = m->second->GetVelocity(0) / motor_velocity_slowdown_factor_;\n\t\ti++;\n\t}\n\n\t// Set the message timestamp\n\trot_velocities_msg.header.stamp = ros_time;\n\n\t// Write the data to a bag file using the specified namespace and motor topic\n\tmotor_velocity_bag_.write(motor_velocity_topic_, ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 50.512453611336404}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t}", "CodeBleu_score": 2.749413920229789}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\n#if GAZEBO_MAJOR_VERSION >= 8\n  if (debug_printing_)\n    gzdbg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#else\n  if (debug_printing_)\n    gzdbg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert normalized input values to control surface angles.\n  control_surfaces_.aileron.angle =\n      NormalizedInputToAngle(control_surfaces_.aileron,\n                             roll_pitch_yawrate_thrust_msg->roll());\n  control_surfaces_.elevator.angle =\n      NormalizedInputToAngle(control_surfaces_.elevator,\n                             roll_pitch_yawrate_thrust_msg->pitch());\n  control_surfaces_.rudder.angle =\n      NormalizedInputToAngle(control_surfaces_.rudder,\n                             roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust().x();\n}", "CodeBleu_score": 51.55225235034288}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  if (debug_print_) {\n    gzdbg << \"RollPitchYawrateThrustCallback\" << std::endl;\n  }\n#else\n  if (debug_print_) {\n    gzdbg << \"RollPitchYawrateThrustCallback\" << std::endl;\n  }\n#endif\n\n  // Convert normalized input to control surface angles.\n  control_surfaces_.aileron = NormalizedInputToAngle(\n      control_surfaces_.aileron, roll_pitch_yawrate_thrust_msg->roll());\n  control_surfaces_.elevator = NormalizedInputToAngle(\n      control_surfaces_.elevator, roll_pitch_yawrate_thrust_msg->pitch());\n  control_surfaces_.rudder = NormalizedInputToAngle(\n      control_surfaces_.rudder, roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  control_surfaces_.throttle = roll_pitch_yawrate_thrust_msg->thrust().x;\n}", "CodeBleu_score": 49.22576541858532}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  if (serial_enabled_) {\n//    return;\n//  }\n\n  struct timeval timeout;\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _timeoutMs * 1000;\n\n  // Check if data is available on the file descriptor\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n  int ret = select(_fd + 1, &fds, nullptr, nullptr, &timeout);\n\n  if (ret < 0) {\n    gzerr << \"Error in select: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  if (ret == 0) {\n    return;\n  }\n\n  // Read the data from the file descriptor\n  char buffer[MAVLINK_MAX_PACKET_LEN];\n  int bytes_read = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n  if (bytes_read < 0) {\n    gzerr << \"Error in recv: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  // Parse the MAVLink messages from the buffer\n  mavlink_message_t message;\n  mavlink_status_t status;\n\n  for (int i = 0; i < bytes_read; ++i) {\n    if (mavlink_parse_char(\n            MAVLINK_COMM_0, buffer[i], &message, &status)) {\n      if (serial_enabled_) {\n        // Forward the message to the serial port\n        send_mavlink_message(&message, 0);\n      }\n\n      // Handle the message\n      handle_message(&message);\n    }\n  }\n}", "CodeBleu_score": 48.74827588471667}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tf GAZEBO_MAJOR_VERSION >= 9\n  gazebo::common::Time timeout(_timeoutMs * 1e-3);\n  gazebo::common::Time start = world_->SimTime();\n#else\n  double timeout = _timeoutMs * 1e-3;\n  gazebo::common::Time start = world_->GetSimTime();\n#endif\n\n  while ((world_->SimTime() - start) < timeout) {\n    // Check for new data\n    if (serial_enabled_) {\n      if (is_open()) {\n        io_service_.poll();\n      }\n    } else {\n      if (recvfrom(_fd, _buffer, MAVLINK_MAX_PACKET_LEN, 0, NULL, NULL) > 0) {\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        // Parse received data\n        unsigned nmsg = 0;\n        while (mavlink_parse_char(\n            MAVLINK_COMM_0, _buffer[nmsg], &msg, &status)) {\n          nmsg++;\n\n          // Send data to all connected serial ports\n          if (serial_enabled_) {\n            send_mavlink_message(&msg, 0);\n          }\n\n          // Handle message\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 48.23000070138842}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::unique_lock<boost::mutex> lock(lock_);\n\tif (is_open_)  {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable())  {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 63.2954621921542}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tif (is_open)  {\n\t\tis_open = false;\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable())\n\t\t\tio_thread_.join();\n\t}\n}", "CodeBleu_score": 67.40326664607366}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(this->mutex_);\n\tif (this->is_open)  {\n\t\tthis->io_service_.stop();\n\t\tthis->serial_dev_.close();\n\t\tif (this->io_thread_.joinable())  {\n\t\t\tthis->io_thread_.join();\n\t\t}\n\t\tthis->is_open = false;\n\t}\n}", "CodeBleu_score": 30.890487842215386}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tdouble x, double y, double z,\n\tignition::math::Vector3d p1, ignition::math::Vector3d p2, ignition::math::Vector3d v1, ignition::math::Vector3d v2\n}", "CodeBleu_score": 24.06770279809253}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(ignition::math::Vector3d position, ignition::math::Vector3d position1, ignition::math::Vector3d position2, ignition::math::Vector3d value1, ignition::math::Vector3d value2) {\n\t\tdouble distance1 = (position - position1).Length();\n\t\tdouble distance2 = (position - position2).Length();\n\t\tdouble totalDistance = distance1 + distance2;\n\t\tdouble weight1 = distance2 / totalDistance;\n\t\tdouble weight2 = distance1 / totalDistance;\n\t\treturn (weight1 * value1) + (weight2 * value2);\n\t}\n}", "CodeBleu_score": 30.817271329555453}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d x, ignition::math::Vector3d y, double x_pos, double x_min, double x_max, double y_min, double y_max\n}", "CodeBleu_score": 14.582568579943848}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_pose.pose.position.x, y=self.current_pose.pose.position.y, z=self.current_pose.pose.position.z, yaw=self.current_yaw)\n    self.send_target_pose(target_raw_pose)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + self.vehicle_id)\n    print(\"Flight Mode: \" + self.flight_mode)\n", "CodeBleu_score": 59.08808853380842}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_pose.pose.position.x, y=self.current_pose.pose.position.y, z=self.current_pose.pose.position.z, yaw=self.current_yaw)\n    self.print_vehicle_info()\n\n", "CodeBleu_score": 67.04369044297354}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_position[0], y=self.current_position[1], z=self.current_position[2], yaw=self.current_yaw)\n    self.set_target_pose(target_raw_pose)\n    print(\"Vehicle type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + str(self.flight_mode))\n", "CodeBleu_score": 55.62498096837073}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        self.hover_flag = 0\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode switched to \"+self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode switch failed: %s\"%e)\n            return False\n", "CodeBleu_score": 66.42857965811324}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Successfully switched to \"+self.flight_mode+\" mode\")\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Failed to switch to \"+self.flight_mode+\" mode: %s\"%e)\n            return False\n\n", "CodeBleu_score": 66.49838060008001}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            print \"Service call failed: %s\"%e\n            return False\n", "CodeBleu_score": 66.65485608743941}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= \"HOVER\":\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            self.arm()\n            self.set_target_position(self.current_position.x, self.current_position.y, self.current_position.z,\n                                     self.current_yaw)\n            self.flight_mode = \"HOVER\"\n        else:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n            self.flight_mode = \"OFFBOARD\"\n    else:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n            self.flight_mode = \"OFFBOARD\"\n\n", "CodeBleu_score": 61.963908976089435}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_flight_mode('OFFBOARD')\n        else:\n            self.hover_flag = 1\n            self.set_flight_mode('HOVER')\n            self.hover()\n\n", "CodeBleu_score": 66.51663189780011}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= \"HOVER\":\n        if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.set_mode(self.flight_mode)\n            self.coordinate_frame = 1\n            self.motion_type = 0\n            self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                       z=self.current_position.z, yaw=self.current_yaw)\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.set_mode(self.flight_mode)\n            self.coordinate_frame = 1\n            self.motion_type = 0\n            self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                       z=self.current_position.z, yaw=self.current_yaw)\n\n", "CodeBleu_score": 49.24925358802036}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_angle\n    else:\n        return Quaternion(q).yaw_angle\n\n", "CodeBleu_score": 18.698238975058285}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_local_position.pose.position.x,\n                                            y=self.current_local_position.pose.position.y,\n                                            z=self.current_local_position.pose.position.z,\n                                            yaw=self.current_local_position.pose.orientation.yaw)\n    self.set_target_position(target_raw_pose)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 39.81209679518548}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(z=self.current_altitude, yaw=self.current_yaw)\n    self.set_target_pose(target_raw_pose)\n    print \"Vehicle type: %s\" % self.vehicle_type\n    print \"Vehicle ID: %s\" % self.vehicle_id\n    print \"Current flight mode: %s\" % self.vehicle.mode.name\n\n", "CodeBleu_score": 32.92484898944571}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target(x=self.current_local_position[0], y=self.current_local_position[1], z=self.current_local_position[2], yaw=self.current_yaw)\n\n    self.set_target_raw_pose(target_raw_pose)\n    self.set_mode(\"GUIDED\")\n\n    print \"Vehicle type: %s\" % self.vehicle_type\n    print \"Vehicle ID: %s\" % self.vehicle_id\n    print \"Flight Mode: %s\" % self.flight_mode\n    print \"", "CodeBleu_score": 36.88347636893107}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flightModeService.request.custom_mode = self.flight_mode\n        self.flightModeService.request.vehicle_id = self.vehicle_id\n        self.flightModeService.request.coordinate_frame = self.coordinate_frame\n        self.flightModeService.request.target_motion = self.target_motion\n        self.flightModeService.request.motion_type = self.motion_type\n        self.flightModeService.request.timeout = 5\n        if self.flightModeService.call():\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to switch to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 50.64189941177426}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        self.hover_flag = True\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Flight mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 58.095176057998934}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + \"flight mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 67.28528956368078}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = 0\n    self.end = False\n    self.get_total_reward()\n    if self.visualize_on:\n        self.visualize()\n\n", "CodeBleu_score": 61.68734800883146}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize_on:\n        self.visualize()\n", "CodeBleu_score": 55.923299428706756}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose = msg\n        self.local_pose_updated = True\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z + 1.0\n            self.takeoff_target_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n            self.takeoff_target_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n            self.takeoff_target_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n            self.takeoff_target_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n            self.hover_target_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n            self.hover_target_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n            self.hover_target_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n        self.global_pose.position.x = self.local_pose.pose.position.x + self.global_bias.position.x\n        self.global_pose.position.y = self.local_pose.pose.position.y + self.global_bias.position.y\n        self.global_pose.position.z = self.local_pose.pose.position.", "CodeBleu_score": 19.38271914678416}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        self.local_pose.header.stamp = rospy.Time.now()\n        if self.gcs_command == 0:\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.header.stamp = rospy.Time.now()\n        elif self.gcs_command == 1:\n            self.hover_target_pose = msg\n            self.hover_target_pose.header.stamp = rospy.Time.now()\n        self.global_pose = msg\n        self.global_pose.pose.position.x += self.x_bias\n        self.global_pose.pose.position.y += self.y_bias\n        self.global_pose.pose.position.z += self.z_bias\n        self.global_pose.header.stamp = rospy.Time.now()\n        self.local_pose_callback_flag[i] = True\n        self.local_pose_callback_flag[i] = False\n\n", "CodeBleu_score": 23.435573957714855}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z + self.takeoff_bias\n        elif self.gcs_command == 'hover':\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z + self.hover_bias\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.global_pose_bias.x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.global_pose_bias.y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.global_pose_bias.z\n\n", "CodeBleu_score": 20.739227883335627}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    return self.local_position[2] >= 0.2 and self.arm_state == 1\n\n", "CodeBleu_score": 39.53704682410248}, {"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.location.global_relative_frame.alt > 0.2 and self.vehicle.armed:\n        return True\n    else:\n        return False\n\n\n", "CodeBleu_score": 61.95685276863904}, {"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.armed and self.vehicle.location.global_relative_frame.alt > 0.2:\n        return True\n    else:\n        return False\n\n\n", "CodeBleu_score": 55.337351953608874}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Build graph\n    graph = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            norm = np.linalg.norm(orig_formation[i] - change_formation[j])\n            range = int(50 - norm)\n            graph[i, j] = range\n    return graph\n\n", "CodeBleu_score": 26.007105575836935}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # build distance matrix\n    n = len(orig_formation)\n    m = len(change_formation)\n    distance_matrix = np.zeros((n, m))\n    for i in range(n):\n        for j in range(m):\n            distance_matrix[i, j] = 50 - np.linalg.norm(orig_formation[i] - change_formation[j])\n    return distance_matrix.astype(int)", "CodeBleu_score": 23.60026644041667}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Get the number of UAVs in the original formation\n    num_uavs = len(orig_formation)\n    # Initialize the distance matrix\n    dist_matrix = np.zeros((num_uavs, num_uavs), dtype=int)\n    # Calculate the pairwise distances between UAVs in the original formation\n    for i in range(num_uavs):\n        for j in range(num_uavs):\n            # Calculate the Euclidean distance between UAVs i and j\n            dist = np.linalg.norm(orig_formation[i] - orig_formation[j])\n            # Adjust the distance by subtracting it from 50 and converting it to an integer\n            dist_matrix[i, j] = int(50 - dist)\n    # Calculate the pairwise distances between UAVs in the changed formation\n    for i in range(num_uavs):\n        for j in range(num_uavs):\n            # Calculate the Euclidean distance between UAVs i and j\n            dist = np.linalg.norm(change_formation[i] - change_formation[j])\n            # Adjust the distance by subtracting it from 50 and converting it to an integer\n            dist_matrix[i, j] = int(50 - dist)\n    # Return the distance matrix\n    return dist_matrix", "CodeBleu_score": 27.02983610658929}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.num_uavs):\n        self.visit_left = [False] * self.num_uavs\n        self.visit_right = [False] * self.num_nodes\n        self.slack_right = [float('inf')] * self.num_nodes\n        self.find_path(i)\n        if self.match_right[i] == -1:\n            delta = float('inf')\n            for j in range(self.num_nodes):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(self.num_uavs):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n            for j in range(self.num_nodes):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n    return self.match_right\n\n", "CodeBleu_score": 37.38148650270496}, {"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.num_right\n    for i in range(self.num_left):\n        self.visit_left = [False] * self.num_left\n        self.visit_right = [False] * self.num_right\n        self.slack_right = [sys.maxsize] * self.num_right\n        if self.find_path(i):\n            continue\n        while True:\n            delta = sys.maxsize\n            for j in range(self.num_right):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(self.num_left):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n            for j in range(self.num_right):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n            if self.find_path(i):\n                break\n\n", "CodeBleu_score": 38.46896412199812}, {"code": "def KM(self)\n\t\n    for i, _ in enumerate(self.visit_left, start=0):\n        self.visit_left[i] = False\n        self.label_left[i] = 0\n    for i, _ in enumerate(self.visit_right, start=0):\n        self.visit_right[i] = False\n        self.label_right[i] = 0\n        self.slack_right[i] = sys.maxsize\n    for i, _ in enumerate(self.match_right, start=0):\n        self.match_right[i] = -1\n    for i, _ in enumerate(self.visit_left, start=0):\n        while True:\n            self.find_path(i)\n            if self.match_right[i] == -1:\n                break\n            delta = sys.maxsize\n            for j, _ in enumerate(self.visit_right, start=0):\n                if not self.visit_right[j]:\n                    continue\n                delta = min(delta, self.slack_right[j])\n            for j, _ in enumerate(self.visit_left, start=0):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n            for j, _ in enumerate(self.visit_right, start=0):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n            self.visit_left[i] = False\n            self.visit_right = [False] * len(self.visit_right)\n    return self.match_right\n", "CodeBleu_score": 32.63894714902628}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for the yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for the yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    # convert image to HSV\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # create a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # apply the mask to the image\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t// Check if the standalone tag description exists\n\tif (standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end()) {\n\t\t// If found, set the description container and return true\n\t\tdescriptionContainer = standalone_tag_descriptions_[id];\n\t\treturn true;\n\t} else {\n\t\t// If not found and printWarning is true, log a warning message\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(1.0, \"Standalone tag description not found for ID %d\", id);\n\t\t}\n\t\t// Return false\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 30.146385448625914}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}]}
