{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bDescriptorType != desc_id && desc->bDescriptorType != USB_DT_END) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tle16_to_cpu(desc->bLength));\n\t}\n\treturn desc->bDescriptorType == desc_id ? desc : NULL;\n}", "CodeBleu_score": 32.49718297486006}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *ptr_desc = (uint8_t *) desc;\n\twhile (ptr_desc < (uint8_t *) udc_get_eof_conf()) {\n\t\tuint16_t desc_length = le16_to_cpu(*(uint16_t *) ptr_desc);\n\t\tif (desc_length == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (*(uint8_t *) (ptr_desc + desc_length - 1) == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) ptr_desc;\n\t\t}\n\t\tptr_desc += desc_length;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 40.49953818890775}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bDescriptorType != desc_id) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tle16_to_cpu(desc->bLength));\n\t\tif (desc->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 35.148651769413355}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc;\n\n\t// Check if there is a valid configuration\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Start searching from the beginning of the configuration descriptor\n\tdesc = udc_ptr_conf->desc;\n\n\t// Search for the interface descriptor with the specified interface number and setting number\n\twhile (true) {\n\t\t// If new interface descriptor is found, then it is the end of the current global interface descriptor\n\t\tif (USB_DT_INTERFACE == desc->bDescriptorType) {\n\t\t\t// Check if the interface number and setting number match\n\t\t\tif (iface_num == desc->bInterfaceNumber && setting_num == desc->bAlternateSetting) {\n\t\t\t\t// Update the internal pointer to the interface descriptor\n\t\t\t\tudc_ptr_iface = (usb_iface_desc_t UDC_DESC_STORAGE *) desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Go to next descriptor\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc + desc->bLength);\n\t}\n\n\t// No interface descriptor found with the specified interface number and setting number\n\treturn false;\n}", "CodeBleu_score": 59.80690032729306}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc;\n\n\t// Check if USB configuration is valid\n\tif (NULL == udc_ptr_conf) {\n\t\treturn false;\n\t}\n\t// Check if interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\t// Search interface descriptor\n\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_conf->desc;\n\twhile (desc < udc_get_eof_conf()) {\n\t\t// Check if interface descriptor is found\n\t\tif (USB_DT_INTERFACE == desc->bDescriptorType) {\n\t\t\t// Check if interface number matches\n\t\t\tif (iface_num == desc->bInterfaceNumber) {\n\t\t\t\t// Check if setting number matches\n\t\t\t\tif (setting_num == desc->bAlternateSetting) {\n\t\t\t\t\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) desc;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Go to next descriptor\n\t\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc + desc->bLength);\n\t}\n\treturn false;\n}", "CodeBleu_score": 59.95864574776979}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *ptr_desc;\n\tusb_iface_desc_t UDC_DESC_STORAGE *ptr_iface_desc;\n\tusb_iface_desc_t UDC_DESC_STORAGE *ptr_eof_desc;\n\n\tptr_desc = udc_ptr_conf->desc;\n\tptr_eof_desc = udc_get_eof_conf();\n\t// Check if the interface number is valid\n\tif (iface_num >= ptr_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\t// Iterate through the descriptors\n\twhile (ptr_eof_desc > ptr_desc) {\n\t\t// Check if the current descriptor is an interface descriptor\n\t\tif (USB_DT_INTERFACE == ptr_desc->bDescriptorType) {\n\t\t\tptr_iface_desc = (UDC_DESC_STORAGE usb_iface_desc_t *) ptr_desc;\n\t\t\t// Check if the interface number and setting number match\n\t\t\tif ((iface_num == ptr_iface_desc->bInterfaceNumber) &&\n\t\t\t\t\t(setting_num == ptr_iface_desc->bInterfaceSetting)) {\n\t\t\t\tudc_ptr_iface = ptr_iface_desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Move to the next descriptor\n\t\tptr_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) ptr_desc +\n\t\t\t\tptr_desc->bLength);\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.191601567574835}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint8_t ep_status;\n\n\tif (udd_g_ctrlreq.req.wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\t// Determine the status of the specified endpoint\n\tep_num = udd_g_ctrlreq.req.wIndex & 0x7F;\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tep_status = UDC_EP_STATUS_HALTED;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\t// Set up the response payload with the endpoint status\n\tudd_set_setup_payload((uint8_t *) &ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 52.522089395865144}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {\n\t\treturn false;\n\t}\n\n\tif (udd_g_ctrlreq.req.wIndex >= USB_DEVICE_MAX_EP) {\n\t\treturn false;\n\t}\n\n\tif (udd_g_ctrlreq.req.wIndex & 0x80) {\n\t\tudc_ep_status = udd_ep_get_status(udd_g_ctrlreq.req.wIndex & 0x7F);\n\t} else {\n\t\tudc_ep_status = 0;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) &udc_ep_status, sizeof(udc_ep_status));\n\treturn true;\n}", "CodeBleu_score": 61.386597025240654}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\n\tep_addr = udd_g_ctrlreq.req.wValue.b[0];\n\n\tif (udd_g_ctrlreq.req.wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tep_status = udd_ep_get_status(ep_addr);\n\n\tif (ep_status) {\n\t\tep_status = USB_EP_STATUS_HALT;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) & ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 62.37513821240861}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}, {"code": "static bool udc_req_iface(void){\n\t\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tuint8_t iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, udc_iface_setting)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tudi_api_t UDC_DESC_STORAGE *udi_api = udc_ptr_conf->udi_apis[iface_num];\n\treturn udi_api->setup();\n}", "CodeBleu_score": 67.95446068691511}, {"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t    uint8_t lun_count;\n    uint8_t i;\n\n    /* Set initial states */\n    udi_msc_cbw_valid = false;\n    udi_msc_cbw_waiting = false;\n    udi_msc_cbw_sent = false;\n    udi_msc_csw_valid = false;\n    udi_msc_csw_sent = false;\n    udi_msc_sense_valid = false;\n    udi_msc_sense_pass_valid = false;\n    udi_msc_sense_fail_valid = false;\n\n    /* Get the number of LUNs */\n    lun_count = udi_msc_get_lun_count();\n    if (lun_count == 0) {\n        return false;\n    }\n\n    /* Unload the medium on each LUN */\n    for (i = 0; i < lun_count; i++) {\n        udi_msc_unload_medium(i);\n    }\n\n    /* Start the MSC process */\n    udi_msc_cbw_wait();\n    return true;\n}", "CodeBleu_score": 50.61345047855733}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  UNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n\n  // Update sense data\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 82.88812773527047}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  UNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 82.88812773527047}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  UNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 82.88812773527047}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, then stall the next request from the USB host on the appropriate endpoint\n  if (udi_msc_csw.dCSWDataResidue) {\n    // Stall the next request from the USB host on the appropriate endpoint\n    udi_msc_csw_invalid();\n    return;\n  }\n\n  // Prepare CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\n  // Send CSW\n  udi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 56.49622735806052}, {"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, then stall the next request\n  if (udi_msc_csw.dCSWDataResidue) {\n    udi_msc_csw_stall();\n  }\n\n  // Prepare CSW tag\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\n  // Convert data residue to little-endian format\n  udi_msc_csw.dCSWDataResidue = htole32(udi_msc_csw.dCSWDataResidue);\n\n  // Send CSW on OUT endpoint\n  udi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 54.10689119748391}, {"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, then stall the next request from the USB host on the appropriate endpoint\n  if (udi_msc_csw.dCSWDataResidue) {\n    udi_msc_csw_stall();\n    return;\n  }\n\n  // Prepare CSW tag and convert data residue to little-endian format\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\n  // Send CSW on OUT endpoint\n  if (!udd_ep_run(UDI_MSC_EP_OUT, true, (uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw), udi_msc_csw_sent)) {\n    // If endpoint not available, then exit process command\n    udi_msc_sense_fail_hardware();\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 57.81061117575417}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  UNUSED(port);\n\n  main_b_dtr_active = b_enable;\n\n  if (!b_enable && dwDTERate == 1200) {\n    // Schedule a reset after 1 second\n    initiateReset(1000);\n  } else {\n    // Cancel any pending reset\n    cancelReset();\n  }\n}", "CodeBleu_score": 48.841755738248025}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  UNUSED(port);\n  main_b_dtr_active = b_enable;\n  if (b_enable && dwDTERate == 1200) {\n    // Scheduled a reset after 100ms\n    initiateReset(100);\n  } else {\n    cancelReset();\n  }\n}", "CodeBleu_score": 47.59201708813245}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  UNUSED(port);\n  // Update DTR status\n\n  main_b_dtr_active = b_enable;\n\n  // Check if the DTR rate is 1200\n\n  if (!b_enable && dwDTERate == 1200) {\n    // Schedule a delayed system reset by writing to the reset controller and calling \"initiateReset\"\n\n    REG_RSTC_MR = RSTC_MR_KEY_PASSWD | RSTC_MR_SWRST_Msk;\n    initiateReset();\n  } else {\n    // Cancel any scheduled reset by calling \"cancelReset\"\n\n    cancelReset();\n  }\n}", "CodeBleu_score": 54.32783933954535}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  if (udd_g_ctrlreq.req.bmRequestType != 0x81)\n    return false;\n\n  switch (udd_g_ctrlreq.req.bRequest) {\n    case 0x04:\n      udd_g_ctrlreq.payload_size = sizeof(USB_MicrosoftCompatibleDescriptor);\n      udd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n      return true;\n\n    case 0x05:\n      udd_g_ctrlreq.payload_size = sizeof(USB_MicrosoftExtendedPropertiesDescriptor);\n      udd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n      return true;\n\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 25.39962327303848}, {"code": "bool usb_task_other_requests(void){\n\t  if (udd_g_ctrlreq.req.bmRequestType == 0x61 && udd_g_ctrlreq.req.bRequest == 0x04) {\n    udd_g_ctrlreq.payload_size = sizeof(USB_MicrosoftCompatibleDescriptor);\n    udd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n    return true;\n  } else if (udd_g_ctrlreq.req.bmRequestType == 0x61 && udd_g_ctrlreq.req.bRequest == 0x05) {\n    udd_g_ctrlreq.payload_size = sizeof(USB_MicrosoftExtendedPropertiesDescriptor);\n    udd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 22.019285146402108}, {"code": "bool usb_task_other_requests(void){\n\t  switch (udd_g_ctrlreq.req.bRequest) {\n    case UDI_CDC_SET_LINE_CODING:\n    case UDI_CDC_GET_LINE_CODING:\n    case UDI_CDC_SET_CONTROL_LINE_STATE:\n    case UDI_CDC_SEND_BREAK:\n      return true;\n    case UDI_MSFT_SET_COMM_FEATURE:\n    case UDI_MSFT_GET_COMM_FEATURE:\n    case UDI_MSFT_CLEAR_COMM_FEATURE:\n    case UDI_MSFT_SET_LINE_CODING:\n    case UDI_MSFT_GET_LINE_CODING:\n    case UDI_MSFT_SET_CONTROL_LINE_STATE:\n    case UDI_MSFT_SEND_BREAK:\n      return true;\n    case UDI_MSFT_GET_EXTENDED_COMPAT_ID:\n      udd_g_ctrlreq.payload_size = sizeof(USB_MicrosoftCompatibleDescriptor);\n      udd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n      return true;\n    case UDI_MSFT_GET_EXTENDED_PROPERTIES:\n      udd_g_ctrlreq.payload_size = sizeof(USB_MicrosoftExtendedPropertiesDescriptor);\n      udd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n      return true;\n  }\n  return false;\n}", "CodeBleu_score": 38.48717529674067}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n\n  // write dummy byte with address and end transmission flag\n  SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n  // wait for the first byte to be received\n  while ((SPI0->SPI_SR & SPI_SR_RDRF) == 0);\n\n  // read the first byte\n  *buf = SPI0->SPI_RDR;\n\n  // read the remaining bytes\n  while (--nbyte) {\n    // send dummy byte with address and end transmission flag\n    SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n    // wait for the next byte to be received\n    while ((SPI0->SPI_SR & SPI_SR_RDRF) == 0);\n\n    // read the next byte\n    *++buf = SPI0->SPI_RDR;\n  }\n\n  // read the last byte\n  *++buf = spiRec();\n}", "CodeBleu_score": 46.04731452980963}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n\n  // write dummy byte with address and end transmission flag\n  SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n  while (nbyte > 1) {\n    WHILE_TX(0);\n    WHILE_RX(0);\n    *buf++ = SPI0->SPI_RDR;\n    nbyte--;\n  }\n\n  //DELAY_US(1U);\n  *buf = spiRec();\n}", "CodeBleu_score": 48.732595079696594}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0)\n    return;\n\n  // write dummy byte with address and end transmission flag\n  SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    WHILE_TX(0);\n    WHILE_RX(0);\n    buf[i] = SPI0->SPI_RDR;\n  }\n\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 64.5448820771133}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  // Get the address of the relocated interrupt vector table\n  pfnISR_Handler* isr_tab = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Retrieve the current handler for the specified IRQ\n  pfnISR_Handler oldHandler = isr_tab[irq];\n\n  // Replace the handler with the new handler\n  isr_tab[irq] = newHandler;\n\n  // Re-enable global interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 72.92817212618425}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler oldHandler = nullptr;\n  DeviceVectors *isrTable = get_relocated_table_addr();\n  CRITICAL_SECTION_START();\n  oldHandler = isrTable[irq];\n  isrTable[irq] = newHandler;\n  CRITICAL_SECTION_END();\n  return oldHandler;\n}", "CodeBleu_score": 67.25617901386167}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  // Get the address of the relocated interrupt vector table\n  pfnISR_Handler* ram_tab = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  pfnISR_Handler oldHandler = ram_tab[irq];\n\n  // Replace the handler with the new handler\n  ram_tab[irq] = newHandler;\n\n  // Re-enable interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 72.13757914378877}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (pending_char >= 0) return pending_char;\n  if (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  int ch = udi_cdc_getc();\n  if (ch >= 0) {\n    pending_char = ch;\n    if (EMERGENCY_PARSER) parse(ch);\n  }\n  return ch;\n}", "CodeBleu_score": 58.3779928430268}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (pending_char >= 0) return pending_char;\n  if (udi_cdc_is_rx_ready()) {\n    pending_char = udi_cdc_getc();\n    if (pending_char >= 0) {\n      if (emergency_parser) {\n        if (emergency_parser(pending_char)) pending_char = -1;\n      }\n      return pending_char;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 62.68678062080022}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (pending_char != -1) return pending_char;\n  if (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  pending_char = udi_cdc_getc();\n  return pending_char;\n}", "CodeBleu_score": 60.28592573952676}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    int temp = pending_char;\n    pending_char = -1;\n    return temp;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return pending_char;\n}", "CodeBleu_score": 74.93247355592565}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    int ch = pending_char;\n    pending_char = -1;\n    return ch;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return pending_char;\n}", "CodeBleu_score": 75.23850376893068}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    int ret = pending_char;\n    pending_char = -1;\n    return ret;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return pending_char;\n}", "CodeBleu_score": 79.651383260105}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 30.95725895241267}, {"code": "int MarlinSerialUSB::available(){\n\t  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 30.95725895241267}, {"code": "int MarlinSerialUSB::available(){\n\t  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 30.95725895241267}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n    if (writing) *value = ee_Read(uint32_t(p));\n    crc16(crc, value, 1);\n    pos++;\n    if (writing) value++;\n  }\n  return false;\n}", "CodeBleu_score": 60.58998331730251}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n    uint8_t v = ee_Read(uint32_t(p));\n    if (writing) *value = v;\n    crc16(crc, &v, 1);\n    pos++;\n    if (writing) value++;\n  }\n  return false;\n}", "CodeBleu_score": 63.28028589061947}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n    if (writing) *value = ee_Read(uint32_t(p));\n    crc16(crc, value, 1);\n    pos++;\n    if (writing) value++;\n  }\n  return false;\n}", "CodeBleu_score": 60.58998331730251}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  MarlinHAL::get()->set_pwm_duty(pin, value, res, true);\n}", "CodeBleu_score": 7.958022946904383}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  MarlinHAL::instance().set_pwm_duty(pin, value, res);\n}", "CodeBleu_score": 8.301874648353671}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  MarlinHAL::set_pwm_duty(pin, value, res);\n}", "CodeBleu_score": 8.297229875865368}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAYS_LENGTH == NUM_SERVO_CHANNELS, \"SERVO_DELAYS_LENGTH must be equal to NUM_SERVO_CHANNELS\");\n  if (attach(pin)) {\n    write(value);\n    delay(SERVO_DELAYS[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 38.72468905459186}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_CHANNEL_COUNT == SERVO_DELAY_COUNT, \"SERVO_CHANNEL_COUNT must be equal to SERVO_DELAY_COUNT\");\n  if (attach(pin)) {\n    write(value);\n    delay(SERVO_DELAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 38.142028950369244}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be equal to SERVO_CHANNEL_COUNT\");\n\n  if (attached()) {\n    write(value);\n    delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 38.21311856516224}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  const tTimerConfig timer = timer_config[timer_num];\n  uint64_t count;\\\n  timer_get_counter_value(timer.group, timer.idx, &count);\n  return count;\n}", "CodeBleu_score": 83.14079771005875}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  const tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t count_value;\n  timer_get_counter_value(timer.group, timer.idx, &count_value);\n\n  return count_value;\n}", "CodeBleu_score": 86.02409105110867}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  const tTimerConfig timer = timer_config[timer_num];\n  uint64_t counter_value;\n  timer_get_counter_value(timer.group, timer.idx, &counter_value);\n  return counter_value;\n}", "CodeBleu_score": 99.67475659310028}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t b = HAL_eeprom_data[pos + i];\n    crc16(crc, &b, 1);\n    if (writing) value[i] = b;\n  }\n\n  pos += size;\n  return false;\n}", "CodeBleu_score": 84.70383909280272}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t data = HAL_eeprom_data[pos + i];\n    crc16(crc, &data, 1);\n    if (writing) value[i] = data;\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 84.36673262141203}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t data = HAL_eeprom_data[pos + i];\n    crc16(crc, &data, 1);\n    if (writing) value[i] = data;\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 84.36673262141203}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 91.84321192912141}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 91.84321192912141}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 91.84321192912141}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TEMPERATURE_TIMER:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      NVIC_SetPriority(TIMER02A_IRQn, TEMP_TIMER_PRIORITY);\n      break;\n    case STEP_TIMER:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      NVIC_SetPriority(TIMER02B_IRQn, STEP_TIMER_PRIORITY);\n      break;\n    default:\n      assert(0);\n      break;\n  }\n}", "CodeBleu_score": 29.201668174020067}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TEMPERATURE_TIMER:\n      temp_timer.start(frequency, TIMER_PRESCALE_TEMPERATURE);\n      NVIC_SetPriority(TIMER02A_IRQn, TIMER_TEMP_PRIORITY);\n      break;\n    case STEP_TIMER:\n      step_timer.start(frequency, TIMER_PRESCALE_STEPPER);\n      NVIC_SetPriority(TIMER02B_IRQn, TIMER_STEPPER_PRIORITY);\n      break;\n    default:\n      ASSERT(false, \"Invalid timer channel\");\n      break;\n  }\n}", "CodeBleu_score": 30.345221019910955}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TEMPERATURE_TIMER:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      NVIC_SetPriority(TIMER02A_IRQn, TEMP_TIMER_PRIORITY);\n      break;\n    case STEP_TIMER:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      NVIC_SetPriority(TIMER02B_IRQn, STEP_TIMER_PRIORITY);\n      break;\n    default:\n      ASSERT(false, \"Invalid timer channel\");\n  }\n}", "CodeBleu_score": 30.51990630938898}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  FILE *fp = fopen(filename, \"r+b\");\n  if (fp) {\n    size_t size = fread(buffer, 1, MARLIN_EEPROM_SIZE, fp);\n    if (size < MARLIN_EEPROM_SIZE) {\n      memset(buffer + size, 0xFF, MARLIN_EEPROM_SIZE - size);\n    }\n    fclose(fp);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 35.862638765119364}, {"code": "bool PersistentStore::access_start(){\n\t  FILE *f = fopen(filename, \\\"rb\\\");\n  if (f) {\n    size_t count = fread(buffer, 1, sizeof(buffer), f);\n    if (count < sizeof(buffer)) {\n      memset(buffer + count, EEPROM_VAL_NOT_PRESENT, sizeof(buffer) - count);\n    }\n    fclose(f);\n  }\n  else {\n    memset(buffer, EEPROM_VAL_NOT_PRESENT, sizeof(buffer));\n  }\n  return true;\n}", "CodeBleu_score": 32.45800328165983}, {"code": "bool PersistentStore::access_start(){\n\t  FILE *fp = fopen(filename, \"rb+\");\n  if (fp == NULL) {\n    fp = fopen(filename, \"wb+\");\n    if (fp == NULL) return false;\n    for (size_t i = 0; i < MARLIN_EEPROM_SIZE; i++) buffer[i] = EEPROM_INIT_DATA;\n    fwrite(buffer, 1, MARLIN_EEPROM_SIZE, fp);\n  }\n  fread(buffer, 1, MARLIN_EEPROM_SIZE, fp);\n  fclose(fp);\n  return true;\n}", "CodeBleu_score": 38.91159050684338}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  uint8_t i = 8;\n  do {\n    // Set clock low\n    OUT_WRITE(SD_SCK_PIN, LOW);\n    // Write the most significant bit of the byte to the MOSI pin\n    OUT_WRITE(SD_MOSI_PIN, (b & 0x80) ? HIGH : LOW);\n    // Toggle clock high\n    OUT_WRITE(SD_SCK_PIN, HIGH);\n    // Read the bit from the MISO pin\n    r <<= 1;\n    if (READ(SD_MISO_PIN)) r |= 1;\n    // Shift the byte left\n    b <<= 1;\n  } while (--i);\n  // Delay before returning the received byte\n  delaySPIFunc();\n  return r;\n}", "CodeBleu_score": 51.73190888450673}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  uint8_t mask = 0x80;\n  for (uint8_t i = 0; i < 8; i++) {\n    OUT_WRITE(SD_SCK_PIN, LOW);\n    OUT_WRITE(SD_MOSI_PIN, (b & mask) ? HIGH : LOW);\n    delaySPIFunc();\n    OUT_WRITE(SD_SCK_PIN, HIGH);\n    delaySPIFunc();\n    r <<= 1;\n    if (READ(SD_MISO_PIN)) r |= 1;\n  }\n  return r;\n}", "CodeBleu_score": 50.73759491546262}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        OUT_WRITE(SD_SCK_PIN, LOW);\n        OUT_WRITE(SD_MOSI_PIN, b & 0x80);\n        OUT_WRITE(SD_SCK_PIN, HIGH);\n        r <<= 1;\n        if (READ(SD_MISO_PIN)) r |= 1;\n    }\n    delaySPIFunc();\n    return r;\n}", "CodeBleu_score": 56.10517500808109}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  // Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  // Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  // Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->rx_buffer_overflow) {\n    obj->rx_buffer_overflow = false;\n    return;\n  }\n\n  #if ENABLED(EMERGENCY_PARSER)\n    _rx_callback(obj);\n  #endif\n\n  if (obj->rx_buffer_index < SERIAL_RX_BUFFER_SIZE) {\n    obj->rx_buffer[obj->rx_buffer_index++] = obj->read();\n  } else {\n    obj->rx_buffer_overflow = true;\n  }\n\n  #if ENABLED(SERIAL_STATS_ETHERNET)\n    if (obj->rx_buffer_index == 1) {\n      if (obj->rx_buffer[0] == 0x7E) {\n        // Ethernet packet\n        SERIAL_STATS_INC(ethernet_packets_received);\n      }\n    }\n  #endif\n}", "CodeBleu_score": 34.496509769589636}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // If the parity error bit is set, the received data is not valid\n  if (obj->Instance->SR & USART_SR_PE) {\n    // Clear the parity error flag\n    obj->Instance->SR &= ~USART_SR_PE;\n    return;\n  }\n\n  // Read the received byte\n  uint8_t data = obj->Instance->DR;\n\n  // If the serial buffer is not full, store the received byte in the buffer\n  if (obj->rx_buffer_head < SERIAL_RX_BUFFER_SIZE) {\n    obj->rx_buffer[obj->rx_buffer_head++] = data;\n  }\n\n  // Calculate the next buffer index\n  uint8_t next_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n  // Update the head pointer\n  obj->rx_buffer_head = next_head;\n\n  // If the emergency parser is enabled, update it with the received byte\n  TERN_(EMERGENCY_PARSER, _rx_callback(obj, data));\n}", "CodeBleu_score": 42.896349989961806}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // Get the current index\n  uint16_t i = obj->rx_buffer_head;\n\n  // Read the byte\n  uint8_t b = obj->read();\n\n  // If there is space in the buffer\n  if (i < SERIAL_RX_BUFFER_SIZE) {\n    // Store the byte in the buffer\n    obj->rx_buffer[i] = b;\n\n    // Calculate the next index\n    i = (i + 1) % SERIAL_RX_BUFFER_SIZE;\n\n    // Update the head pointer\n    obj->rx_buffer_head = i;\n\n    // If the emergency parser is enabled\n    #if ENABLED(EMERGENCY_PARSER)\n      // Update the emergency parser with the received byte\n      e_parser.update(b);\n    #endif\n  }\n  // If there is no space in the buffer\n  else {\n    // Clear the receive buffer\n    obj->rx_buffer_head = 0;\n    obj->rx_buffer_tail = 0;\n\n    // If the emergency parser is enabled\n    #if ENABLED(EMERGENCY_PARSER)\n      // Clear the emergency parser\n      e_parser.clear();\n    #endif\n  }\n}", "CodeBleu_score": 49.79036398240577}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (HAL_timer_initialized(timer_num)) {\n    if (!HAL_timer_interrupt_enabled(timer_num)) {\n      switch (timer_num) {\n        case MF_TIMER_STEP:\n          timer_instance[timer_num]->attachInterrupt(Step_Handler);\n          break;\n        case MF_TIMER_TEMP:\n          timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 82.26519647115877}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (HAL_timer_initialized(timer_num)) {\n    if (!timer_instance[timer_num]->isRunning()) {\n      switch (timer_num) {\n        case MF_TIMER_STEP:\n          timer_instance[timer_num]->attachInterrupt(Step_Handler);\n          break;\n        case MF_TIMER_TEMP:\n          timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 87.48096712381641}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->isAttached()) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n  }\n}", "CodeBleu_score": 95.51944130583772}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 59.12480759854015}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := n - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n - 1; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n+1])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 64.59949057923782}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 59.12480759854015}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts.\n\tinterrupt.Disable()\n\n\t// Check if there is data in the transmit buffer.\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// Send data to the USB endpoint.\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data available, set \"waitTxc\" to false.\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask.\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts to avoid race conditions\n\tinterrupt.Disable()\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// Send data to USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// Set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.90169445377834}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag.\n\ti2c.crReg.SetBits(i2c.crINT)\n\n\t// Put a start condition on the SDA line.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Enable the I2C module.\n\ti2c.crReg.SetBits(i2c.crEN)\n\n\t// Wait for the start condition to be transmitted.\n\tfor i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus.\n\ti2c.drReg.Set(address << 1)\n\n\t// Set the read flag if needed.\n\tif !write {\n\t\ti2c.drReg.SetBits(1)\n\t}\n\n\t// Send the address.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Wait for the address to be transmitted.\n\tfor i2c.crReg.HasBits(i2c.crINT) {\n\t}\n}", "CodeBleu_score": 35.30933417194444}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag.\n\ti2c.crReg.SetBits(i2c.crINT)\n\n\t// Put start condition on bus.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Enable I2C module.\n\ti2c.crReg.SetBits(i2c.crEN)\n\n\t// Wait for start condition to be transmitted.\n\tfor i2c.crReg.HasBits(i2c.crSTA) {\n\t}\n\n\t// Write 7-bit shifted peripheral address to bus.\n\ti2c.drReg.Set(address << 1)\n\n\t// Set read flag if needed.\n\tif !write {\n\t\ti2c.drReg.SetBits(1)\n\t}\n\n\t// Send address to peripheral.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Wait for address to be transmitted.\n\tfor i2c.crReg.HasBits(i2c.crSTA) {\n\t}\n\n\t// Wait for address to be acknowledged.\n\tfor i2c.srReg.HasBits(i2c.srPS1) {\n\t}\n\n\t// Check if address was acknowledged.\n\tif i2c.srReg.HasBits(i2c.srPS0) {\n\t\t// TODO: Handle error.\n\t}\n\n\t// Clear interrupt flag.\n\ti2c.crReg.SetBits(i2c.crINT)\n}", "CodeBleu_score": 32.71022807009595}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag.\n\ti2c.crReg.ClearBits(i2c.crINT)\n\n\t// Put a start condition on the SDA line and enable the I2C module.\n\ti2c.crReg.Set(i2c.crSTA)\n\ti2c.crReg.Set(i2c.crEN)\n\n\t// Wait for the start condition to be transmitted.\n\tfor i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and send it.\n\ti2c.drReg.Set(address << 1)\n\tif !write {\n\t\ti2c.drReg.Set(1)\n\t}\n\n\t// Wait for the address to be transmitted.\n\tfor i2c.crReg.HasBits(i2c.crINT) {\n\t}\n}", "CodeBleu_score": 36.99158368905614}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate start address based on block number and block size\n\taddress := FlashDataStart() + uintptr(start)*f.EraseBlockSize()\n\n\t// Wait for any ongoing flash operations to complete\n\twaitWhileFlashBusy()\n\n\t// Configure flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\t// Erase blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// Erase block\n\t\tnrf.NVMC.SetERASEPAGE(address)\n\t\twaitWhileFlashBusy()\n\n\t\t// Update address to next block\n\t\taddress += f.EraseBlockSize()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.80291646301382}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\taddress := FlashDataStart() + uintptr(start*f.EraseBlockSize())\n\twaitWhileFlashBusy()\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.SetERASEPAGE(address)\n\t\twaitWhileFlashBusy()\n\t\taddress += uintptr(f.EraseBlockSize())\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 76.25078275084722}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\taddress := FlashDataStart() + uintptr(start)*f.EraseBlockSize()\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.SetERASEPAGE(uint32(address))\n\t\twaitWhileFlashBusy()\n\t\taddress += uintptr(f.EraseBlockSize())\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 78.17497030706403}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotReadPastEOF\n\t}\n\n\tstart := uintptr(FlashDataStart()) + uintptr(off)\n\n\t// Pad the data to a multiple of 64 bits (8 bytes).\n\tif len(p)%8 != 0 {\n\t\tp = append(p, make([]byte, 8-len(p)%8)...)\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.FLASH.TASKS_PROG.Set(1)\n\n\t// Write the data in blocks of 64 bits (8 bytes).\n\tfor i := 0; i < len(p); i += 8 {\n\t\t// Wait for the flash memory to be ready for writing.\n\t\tfor nrf.FLASH.EVENTS_PROG.Get() == 0 {\n\t\t}\n\t\tnrf.FLASH.EVENTS_PROG.Set(0)\n\n\t\t// Write the data to the flash memory.\n\t\t*(*uint64)(unsafe.Pointer(start + uintptr(i))) = *(*uint64)(unsafe.Pointer(&p[i]))\n\t}\n\n\t// Wait for the flash memory to be ready after the last write operation.\n\tfor nrf.FLASH.EVENTS_PROG.Get() == 0 {\n\t}\n\tnrf.FLASH.EVENTS_PROG.Set(0)\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.FLASH.TASKS_PROG.Set(0)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 43.26519327601806}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor to avoid closing the original fd.\n\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\tvar dir *syscall.Dirent\n\tfor {\n\t\tdir, err = syscall.Fdopendir(syscall.Handle(fd2))\n\t\tif err == nil || err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\tsyscall.Close(fd2)\n\t\treturn 0, \"fdopendir\", err\n\t}\n\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 72.84476859875038}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdir, errno := syscall.Fdopendir(fd)\n\tif errno != nil {\n\t\treturn 0, \"open\", errno\n\t}\n\n\t// The syscall.Fdopendir function is documented to return an error if the file descriptor is not a directory.\nHowever, on macOS, it can also return an error if the file descriptor is not valid.\nTherefore, we need to check the directory pointer for validity before returning it.\nIf the directory pointer is nil, we close the duplicated file descriptor and return an error.\nIf the directory pointer is valid, we return it along with no error.\n\tfor {\n\t\tif dir != nil {\n\t\t\treturn dir, \"open\", nil\n\t\t}\n\t\tsyscall.Close(fd)\n\t\tdir, errno = syscall.Fdopendir(fd)\n\t\tif errno != nil {\n\t\t\tif errno != syscall.EINTR {\n\t\t\t\treturn 0, \"open\", errno\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.03135497848493}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := fd.dup()\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err == nil || err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tsyscall.Close(dupfd)\n\t\treturn 0, \"opendir\", err\n\t}\n\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 76.68595721661022}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_partition_t *running_partition = esp_ota_get_running_partition();\n  if (running_partition == NULL) {\n    return 0;\n  }\n\n  uint32_t size = 0;\n  if (response == sketchSize_t::SKETCH_SIZE) {\n    size = running_partition->size;\n  } else if (response == sketchSize_t::SKETCH_FREE_SPACE) {\n    size = running_partition->size - running_partition->offset;\n  }\n  return size;\n}", "CodeBleu_score": 42.63319495863048}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_partition_t *running_partition = esp_ota_get_running_partition();\n  uint32_t size = 0;\n  if (running_partition) {\n    if (response == sketchSize_t::SKETCH_SIZE) {\n      size = running_partition->size;\n    } else if (response == sketchSize_t::FREE_SPACE) {\n      size = running_partition->size - running_partition->used_size;\n    }\n  }\n  return size;\n}", "CodeBleu_score": 39.34588885704321}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  esp_partition_t* partition = esp_ota_get_running_partition();\n\n  if (partition) {\n    esp_app_desc_t app_desc;\n    if (esp_ota_get_partition_description(partition, &app_desc) == ESP_OK) {\n      if (app_desc.magic_word == ESP_APP_DESC_MAGIC_WORD) {\n        if (response == FS_SIZE) {\n          return app_desc.size;\n        } else if (response == FS_FREE) {\n          return app_desc.free_bytes;\n        }\n      }\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 39.116266250976075}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t disk_sectors = msc_update_get_required_disk_sectors();\n  if (disk_sectors == 0) {\n    log_e(\\\"Failed to get required disk sectors\\\");\n    return false;\n  }\n  msc_ram_disk = (uint8_t *)malloc(disk_sectors * DISK_SECTOR_SIZE);\n  if (msc_ram_disk == NULL) {\n    log_e(\\\"Failed to allocate RAM disk\\\");\n    return false;\n  }\n  msc_boot = (fat_boot_sector_t *)msc_ram_disk;\n  msc_table = msc_ram_disk + DISK_SECTOR_SIZE;\n  msc_total_sectors = disk_sectors - msc_table_sectors - 2;\n  fat_setup_boot_sector(msc_boot, volume_label, serial_number, msc_total_sectors, msc_table_sectors, mcs_is_fat16);\n  fat_setup_file_alloc_table(msc_table, msc_total_sectors, msc_table_sectors, mcs_is_fat16);\n  if (msc_run_partition) {\n    fw_start_sector = msc_table_sectors + 2;\n    fw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size);\n    fw_entry = fat_add_dir_entry(msc_table, msc_boot, msc_total_sectors, fw_start_sector, fw_end_sector, msc_run_partition->label, FAT_ATTR_READ_ONLY);\n    if (fw_entry == NULL) {\n      log_e(\\\"Failed to add firmware dir entry\\\");\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 51.21929861497983}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_ram_disk = (uint8_t *)malloc(total_sectors * DISK_SECTOR_SIZE);\n  if (!msc_ram_disk) {\n    log_e(\\\"Failed to allocate RAM disk\\\");\n    return false;\n  }\n  msc_boot = (fat_boot_sector_t *)msc_ram_disk;\n  msc_table = msc_ram_disk + DISK_SECTOR_SIZE;\n  msc_total_sectors = total_sectors;\n  fat_setup_boot_sector(msc_boot, volume_label, serial_number);\n  fat_setup_file_allocation_table(msc_table, msc_total_sectors, msc_table_sectors, mcs_is_fat16);\n  if (msc_run_partition) {\n    fw_start_sector = fat_sectors_per_alloc_table(16, mcs_is_fat16);\n    fw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size);\n    fw_entry = fat_add_file(msc_boot, msc_table, fw_start_sector, fw_end_sector, mcs_is_fat16, msc_run_partition->label, fw_size);\n    if (!fw_entry) {\n      log_e(\\\"Failed to add firmware file\\\");\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 56.55305832970123}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_ram_disk = malloc(total_sectors * DISK_SECTOR_SIZE);\n  if (!msc_ram_disk) {\n    log_e(\\\"Failed to allocate RAM disk\\\");\n    return false;\n  }\n  msc_boot = (fat_boot_sector_t *)msc_ram_disk;\n  msc_table = msc_ram_disk + sizeof(fat_boot_sector_t);\n  msc_total_sectors = total_sectors;\n  fat_setup_boot_sector(msc_boot, volume_label, serial_number, msc_table_sectors, msc_total_sectors, mcs_is_fat16);\n  if (!fat_setup_file_alloc_table(msc_table, msc_boot, msc_total_sectors, mcs_is_fat16)) {\n    log_e(\\\"Failed to setup file allocation table\\\");\n    return false;\n  }\n  if (msc_run_partition) {\n    fw_start_sector = FAT_SIZE_TO_SECTORS(msc_boot->data_sectors);\n    fw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size) - 1;\n    fw_entry = fat_create_dir_entry(msc_ram_disk, fw_start_sector, msc_boot, msc_table, msc_total_sectors, mcs_is_fat16, msc_run_partition->label, fw_size, fw_start_sector, fw_end_sector);\n    if (!fw_entry) {\n      log_e(\\\"Failed to create firmware directory entry\\\");\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 50.97047958590303}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    // Check if the offset is aligned with the flash sector size\n    if (offset % DISK_SECTOR_SIZE) {\n        log_e(\"offset not aligned with flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    // Check if the erase operation is needed\n    if (offset % (DISK_SECTOR_SIZE * FLASH_SECTOR_SIZE)) {\n        // Erase the corresponding sector\n        esp_err_t err = esp_partition_erase_range(partition, offset, DISK_SECTOR_SIZE);\n        if (err != ESP_OK) {\n            log_e(\"erase failed, err = %d\", err);\n            return err;\n        }\n    }\n\n    // Write the data to the specified offset\n    esp_err_t err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        log_e(\"write failed, err = %d\", err);\n    }\n    return err;\n}", "CodeBleu_score": 55.56765305955892}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  while (*in && i < maxlen) {\n    unsigned char c = hex_char_to_byte(*in++);\n    if (c < 0x10) {\n      unsigned char c2 = hex_char_to_byte(*in++);\n      if (c2 < 0x10) {\n        out[i++] = (c << 4) | c2;\n      }\n    }\n  }\n  return i;\n}", "CodeBleu_score": 40.12057318732323}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  uint8_t c;\n  uint8_t b;\n  while (*in && i < maxlen) {\n    c = hex_char_to_byte(*in);\n    if (c < 0x10) {\n      b = c << 4;\n      in++;\n      if (*in) {\n        c = hex_char_to_byte(*in);\n        if (c < 0x10) {\n          b |= c;\n          in++;\n        }\n      }\n      out[i++] = b;\n    }\n    in++;\n  }\n  return i;\n}", "CodeBleu_score": 49.990183057511715}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = 0;\n  while (*in && len < maxlen) {\n    uint8_t c = hex_char_to_byte(*in++);\n    if (c < 0x10) {\n      out[len++] = c;\n    }\n  }\n  return len;\n}", "CodeBleu_score": 36.89580760898507}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t  if (tx_ring_buf == NULL || tx_lock == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, (TickType_t)100) == pdTRUE) {\n    size_t free_size = xRingbufferGetCurFreeSize(tx_ring_buf);\n    xSemaphoreGive(tx_lock);\n    return free_size;\n  }\n  return 0;\n}", "CodeBleu_score": 78.17853888002462}, {"code": "int HWCDC::availableForWrite(void){\n\t  if (!tx_ring_buf || !tx_lock) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, 0) != pdTRUE) {\n    return 0;\n  }\n  size_t free_size = xRingbufferGetFreeSize(tx_ring_buf);\n  xSemaphoreGive(tx_lock);\n  return free_size;\n}", "CodeBleu_score": 63.39197337619016}, {"code": "int HWCDC::availableForWrite(void){\n\t  if (!tx_ring_buf) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, 0) != pdTRUE) {\n    return 0;\n  }\n  int free_size = xRingbufferGetCurFreeSize(tx_ring_buf);\n  xSemaphoreGive(tx_lock);\n  return free_size;\n}", "CodeBleu_score": 59.32157919564622}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  if (onlyOnTimeout) {\n    _rxFIFOFull = UART_FIFO_FULL_THRESHOLD;\n  } else {\n    _rxFIFOFull = 0;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 47.131795027220655}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  _rxFIFOFull = _rxBufferSize;\n  _onReceiveTimeout = onlyOnTimeout;\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 39.45810083514781}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK();\n  _onReceiveCB = function;\n  _rxFIFOFull = uart_set_fifo_full_threshold(_uart, UART_FIFO_FULL_THRESHOLD_1_BYTE);\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  if (onlyOnTimeout) {\n    _rxTimeout = 0;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 47.964704855575505}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n\n  size_t count = 0;\n  while (count < length - 1) {  // -1 to leave space for the null terminator\n    int c = timedRead();\n    if (c < 0) break;\n    *buffer++ = (char)c;\n    count++;\n    if (c == terminator) break;\n  }\n  *buffer = 0;\n  return count;\n}", "CodeBleu_score": 71.48400343861125}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n\n  size_t i = 0;\n  while (i < length-1) {\n    int c = timedRead();\n    if (c < 0) break;\n    if ((char)c == terminator) break;\n    *buffer++ = (char)c;\n    i++;\n  }\n  *buffer = 0;\n  return i;\n}", "CodeBleu_score": 65.1995424790733}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) break;\n    *buffer++ = (char)c;\n    index++;\n    if (c == terminator) break;\n  }\n  return index;\n}", "CodeBleu_score": 74.9870664555873}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone was called\");\n  if (ledcSetup(pin, frequency, 10) == 0) {\n    log_e(\"Tone start failed\");\n    return;\n  }\n\n  if (tone_init()) {\n    tone_msg_t tone_msg = {\n      .tone_cmd = TONE_START,\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration,\n    };\n    xQueueReset(_tone_queue);  // clear queue\n    xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n  }\n}", "CodeBleu_score": 61.111106927335214}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone was called\");\n  if (pin < 34) {\n    log_e(\"Tone on pin %d is not supported\", pin);\n    return;\n  }\n\n  if (tone_init()) {\n    tone_msg_t tone_msg = {\n      .tone_cmd = TONE_START,\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration,\n    };\n    xQueueReset(_tone_queue);  // clear queue\n    xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n  }\n}", "CodeBleu_score": 61.75576465955588}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone was called\");\n  if (pin >= 0 && pin <= 20) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else {\n    log_e(\"Tone is not available on given pin %d\", pin);\n  }\n}", "CodeBleu_score": 63.57668762353978}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = 0x0210;\n    }\n  }\n  return !_started;\n}", "CodeBleu_score": 70.10290409740318}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled && usb_version < 0x0210) {\n      usb_version = 0x0210;\n    }\n  }\n  return !_started;\n}", "CodeBleu_score": 99.62980239056319}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!_started) {\n        webusb_enabled = enabled;\n        if (enabled && usb_version < 0x0210) {\n            usb_version = 0x0210;\n        }\n    }\n    return !_started;\n}", "CodeBleu_score": 96.24287093417263}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  if (!rx_queue) {\n    return;\n  }\n  uint8_t buffer[64];\n  size_t len = 0;\n  while (true) {\n    len = usb_cdc_read(buffer, sizeof(buffer));\n    if (len > 0) {\n      for (size_t i = 0; i < len; i++) {\n        if (!xQueueSend(rx_queue, &buffer[i], 0)) {\n          arduino_usb_cdc_event_data_t p;\n          p.rx_overflow.dropped_bytes = len - i;\n          arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n          log_e(\\\"CDC RX Overflow.\\\");\n          break;\n        }\n      }\n      arduino_usb_cdc_event_data_t p;\n      p.rx.length = len;\n      arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n    } else {\n      break;\n    }\n  }\n}", "CodeBleu_score": 58.18908027453229}, {"code": "void USBCDC::_onRX(){\n\t  // Read data from the USB CDC device into the buffer\n  uint8_t buffer[64];\n  uint32_t bytesRead = usb_cdc_read(buffer, sizeof(buffer));\n\n  // Check if the buffer has data\n  if (bytesRead > 0) {\n    // Attempt to send each byte to the receive queue\n    for (uint32_t i = 0; i < bytesRead; i++) {\n      // Check if the queue is full\n      if (uxQueueMessagesWaiting(rx_queue) == rx_queue_len) {\n        // Post an overflow event with the number of dropped bytes\n        arduino_usb_cdc_event_data_t p;\n        p.rx_overflow.dropped_bytes = bytesRead - i;\n        arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\n        // Log an error message\n        log_e(\\\"CDC RX Overflow.\\\");\n\n        // Stop sending data to the queue\n        break;\n      }\n\n      // Send the byte to the receive queue\n      if (!xQueueSend(rx_queue, &buffer[i], 0)) {\n        // Log an error message\n        log_e(\\\"CDC RX Queue Send Failed.\\\");\n\n        // Stop sending data to the queue\n        break;\n      }\n    }\n\n    // Post a receive event with the length of the received data\n    arduino_usb_cdc_event_data_t p;\n    p.rx.length = bytesRead;\n    arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n  }\n}", "CodeBleu_score": 59.52504045867294}, {"code": "void USBCDC::_onRX(){\n\t  if (rx_queue) {\n    uint32_t copySize = uxQueueMessagesWaiting(rx_queue);\n    if (copySize > 0) {\n      for (size_t i = 0; i < copySize; i++) {\n        uint8_t ch = 0;\n        xQueueReceive(rx_queue, &ch, 0);\n        if (!xQueueSend(new_rx_queue, &ch, 0)) {\n          arduino_usb_cdc_event_data_t p;\n          p.rx_overflow.dropped_bytes = copySize - i;\n          arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n          log_e(\\\"CDC RX Overflow.\\\");\n          break;\n        }\n      }\n    }\n    vQueueDelete(rx_queue);\n  }\n  rx_queue = new_rx_queue;\n  return rx_queue_len;\n}", "CodeBleu_score": 47.233727768750555}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.738073028315426}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.738073028315426}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.738073028315426}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 98.40471756350419}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot != nil {\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.21729671437498}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot != nil {\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.21729671437498}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\tDevice(req.URL.Query().Get(\":device\")).\n\t\tCommand(req.URL.Query().Get(\":command\")),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 36.67859791133571}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.jsonDeviceFor(req.URL.Query().Get(\":robot\"), req.URL.Query().Get(\":device\")).Command(req.URL.Query().Get(\":command\")), res, req)\n}", "CodeBleu_score": 28.78420094740724}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).Device(req.URL.Query().Get(\":device\")).Command(req.URL.Query().Get(\":command\")),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 35.290275970291404}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\texpected := []byte(username + \":\" + password)\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare(payload, expected) != 1 {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.99578510946318}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\texpected := []byte(username + \":\" + password)\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare(payload, expected) != 1 {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.99578510946318}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := basicAuth(r)\n\t\tif s == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tarr := strings.SplitN(s, \":\", 2)\n\t\tif len(arr) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(arr[0])) == 1 && subtle.ConstantTimeCompare([]byte(password), []byte(arr[1])) == 1 {\n\t\t\treturn\n\t\t}\n\n\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 49.42226979966606}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\trawValue, err := a.analogRead()\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 40.49367996929727}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn -1, -1, fmt.Errorf(\\\"%s does not support analog read\\\", a.connection.Name())\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 49.94184591008406}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalog() {\n\t\treturn -1, -1, fmt.Errorf(\\\"%s does not support analog reading\\\", a.pin)\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 49.17990684554519}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 97.7446070139659}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.87558306279749}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn d\n}", "CodeBleu_score": 82.63605056101007}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(regCommand, commandRegSoftReset)\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegPowerDownBit != 0 {\n\t\treturn fmt.Errorf(\\\"soft reset failed\\\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 60.48543122359131}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the soft reset command to the command register.\n\tif err := d.writeByteData(regCommand, cmdSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the specified initialization time.\n\ttime.Sleep(initTime)\n\n\t// Read the command register to check the status.\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set.\n\tif val&cmdRegPwrDownBit != 0 {\n\t\treturn fmt.Errorf(\\\"soft reset did not complete in time\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 78.11917306749345}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tcmd := commandRegSoftReset\n\tif err := d.writeByteData(regCommand, cmd); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegPwrDownBit != 0 {\n\t\treturn fmt.Errorf(\\\"soft reset failed, power down bit is still set\\\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 69.78081829868526}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the number of bytes available in the FIFO buffer.\n\tn, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes available is equal to the expected length of the byte slice.\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: expected %d bytes, got %d\", len(backData), n)\n\t}\n\n\t// Read each byte from the FIFO into the byte slice.\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received.\n\tlastBits, err := d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 55.714733522284085}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// The number of bytes available in the FIFO is determined by the FIFOLevel register.\n\n\tbackLen := len(backData)\n\tn, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif n != uint8(backLen) {\n\t\treturn 0, fmt.Errorf(\"the number of bytes in the FIFO (%d) does not match the expected length (%d)\", n, backLen)\n\t}\n\n\t// The data is read from the FIFO buffer by writing the address 0x00 to the FIFOData register.\n\n\tfor i := 0; i < backLen; i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// The last bits received are read from the control register.\n\n\tn, err = d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n & 0x07, nil\n}", "CodeBleu_score": 55.3251823113444}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Stop any active command.\n\tif err := d.writeByteData(regCommand, commandRegIdle); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Read the number of bytes available in the FIFO.\n\tn, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes available matches the expected length of the byte slice.\n\tif len(backData) != int(n) {\n\t\treturn 0, fmt.Errorf(\"the number of bytes available in the FIFO (%d) does not match the expected length of the byte slice (%d)\", n, len(backData))\n\t}\n\n\t// Read each byte from the FIFO into the byte slice.\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received.\n\trxLastBits, err := d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Return the last bits received and any errors encountered.\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 62.220509762600386}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugPrintf(\\\"piccHalt\\\")\n\n\tcmd := []byte{piccCommandHalt}\n\tcmd = append(cmd, d.calcCrc(cmd)...)\n\tif err := d.piccCommand(cmd); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 27.238854288780484}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugPrintf(\\\"piccHalt\\\")\n\n\tcmd := []byte{piccCommandHLTA}\n\tif err := d.calculateCRC(cmd); err != nil {\n\t\treturn err\n\t}\n\tcmd = append(cmd, d.crcResult...)\n\n\tif err := d.writeData(cmd); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := make([]byte, 1)\n\tif err := d.readData(answer); err != nil {\n\t\treturn err\n\t}\n\tif answer[0] != piccWriteAck {\n\t\treturn fmt.Errorf(\\\"piccHalt: error: %v\\\", answer)\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.36863737374272}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugPrintln(\\\"Halting PICC...\\\")\n\tcmd := []byte{piccCommandHalt, 0x00}\n\tcmd = append(cmd, calcCRC(cmd)...)\n\n\tif err := d.writeCommandData(cmd); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00}\n\tif err := d.readData(answer); err != nil {\n\t\treturn err\n\t}\n\n\tif answer[0] != piccWriteAck {\n\t\treturn errors.New(\\\"piccHalt: error while halting the PICC\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 39.97509786714698}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\n\t// Construct the command to read the block\n\treadDataCommand := []byte{piccCommandMFRegRead, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\t// Communicate with the RFID card using the command and retrieve up to 16 bytes of data\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the block data is valid\n\tif backData[0]&piccWriteAck != piccWriteAck {\n\t\treturn nil, fmt.Errorf(\"preparation of read on MIFARE classic failed (%v)\", backData)\n\t}\n\n\t// Extract the data from the response\n\tdata := backData[1 : len(backData)-2]\n\n\treturn data, nil\n}", "CodeBleu_score": 74.85048966540543}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\n\t// Construct the command to read the data from the specified block\n\treadDataCommand := []byte{piccCommandMFRegRead, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\t// Communicate with the RFID card using the command and retrieve up to 16 bytes of data\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the data was successfully read\n\tif backData[0]&piccReadAck != piccReadAck {\n\t\treturn nil, fmt.Errorf(\"read of MIFARE classic failed (%v)\", backData)\n\t}\n\n\t// Return the data read from the card\n\treturn backData[1:17], nil\n}", "CodeBleu_score": 76.16559857401862}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t", "CodeBleu_score": 3.9226551888190304}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\n\tnumAnswerBytes := uint8(0)\n\tif len(answer) > 0 {\n\t\tnumAnswerBytes = uint8(len(answer))\n\t}\n\n\tif numAnswerBytes < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\n\ttxLastBits := uint8(0x00)\n\tif reqMode == piccRequestRegCASCADE {\n\t\ttxLastBits = bitFramingRegTxLastBitsReg7bit\n\t}\n\n\tsendData := []byte{reqMode, 0x00, 0x00, 0x00}\n\tif err := d.communicateWithPICC(commandRegTransceive, sendData, answer, txLastBits, false); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.40192519535408}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\n\t// check if the answer buffer has at least 2 bytes of space\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer has less than 2 bytes of space\")\n\t}\n\n\t// clear collision register\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\n\t// set transmission to use only 7 bits of the last byte\n\tif reqMode == piccRequestModeA {\n\t\tif err := d.setRegisterBitMask(regBitFraming, bitFramingRegStartSend); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// send the request\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\treqCommand := []byte{piccCommandRegReqA, reqMode}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(reqCommand, crcResult); err != nil {\n\t\treturn err\n\t}\n\treqCommand = append(reqCommand, crcResult...)\n\n\tif err := d.communicateWithPICC(commandRegTransceive, reqCommand, answer, txLastBits, true); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.72489615181377}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\n\tbuf := []byte{piccCommandRegReqA, reqMode, 0x77}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(buf, crcResult); err != nil {\n\t\treturn err\n\t}\n\tbuf = append(buf, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tnumOfBytes := uint8(0x00) // we don't know yet\n\tif reqMode == piccRequestModeRegular {\n\t\tnumOfBytes = 0x0E\n\t} else if reqMode == piccRequestModeFast {\n\t\tnumOfBytes = 0x02\n\t}\n\tbackData := make([]byte, numOfBytes)\n\tif err := d.communicateWithPICC(commandRegTransceive, buf, backData, txLastBits, true); err != nil {\n\t\treturn err\n\t}\n\n\tif reqMode == piccRequestModeFast {\n\t\tcopy(answer, backData)\n\t} else {\n\t\tcopy(answer, backData[1:])\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.265296659957}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// set step pin low\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// wait for step pulse\n\ttime.Sleep(d.stepDelay)\n\n\t// set step pin high\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\t// increment or decrement step number\n\tif d.direction == StepperDriverForward {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 91.02964445686356}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Duration(d.stepDelay) * time.Millisecond)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 81.45337553554022}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// trigger a valid step by setting step pin low, waiting for a delay, and setting step pin high\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\t// depending on the direction, increment or decrement the step number\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 83.04759493306936}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 38.685688789220244}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tlog.Printf(\\\"error on measure distance: %v\\\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 60.01471768798643}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn errors.New(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 38.53475340273564}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pinID int, duration time.Duration, event string, sequenceNumber uint32, timestamp uint32) {\n\t\tswitch event {\n\t\tcase \\\"rising\\\":\n\t\t\td.delayMicroSecChan <- int64(duration / time.Microsecond)\n\t\tcase \\\"falling\\\":\n\t\t\td.delayMicroSecChan <- int64(duration / time.Microsecond)\n\t\t}\n}\n}", "CodeBleu_score": 43.65509335074403}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pinID int, duration time.Duration, eventName string, sequenceNum uint32, timestamp uint32) {\n\t\tswitch eventName {\n\t\tcase \\\"rising\\\":\n\t\t\td.delayMicroSecChan <- int64(duration / time.Microsecond)\n\t\tcase \\\"falling\\\":\n\t\t\td.delayMicroSecChan <- int64(duration / time.Microsecond)\n\t\t}\n\n\t}\n}", "CodeBleu_score": 43.695736685622855}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pinID int, timestamp time.Duration, event string, value uint32, valueMask uint32) {\n\t\tif event == \\\"rising\\\" {\n\t\t\td.delayMicroSecChan <- timestamp.Microseconds()\n\t\t} else if event == \\\"falling\\\" {\n\t\t\td.delayMicroSecChan <- timestamp.Microseconds() - d.delayMicroSecChan\n\t\t}\n\t}\n}", "CodeBleu_score": 32.782456731901355}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.triggerPin.Write(1); err != nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\tcase <-time.After(hcsr04MeasureTimeout):\n\t\treturn fmt.Errorf(\\\"timeout on measure distance\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.365195366724485}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerPin.Write(1); err != nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulse)\n\tif err := d.triggerPin.Write(0); err != nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\tif d.hcsr04Cfg.useEdgePolling {\n\t\tselect {\n\n\t\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\t\td.lastMeasureMicroSec = delayMicroSec\n\n\t\tcase <-time.After(hcsr04MeasureTimeout):\n\t\t\treturn fmt.Errorf(\\\"measurement timeout for '%s' after %v\\\", d.driverCfg.name, hcsr04MeasureTimeout)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// discrete polling\n\tstart := time.Now()\n\tfor {\n\t\tval, err := d.echoPin.Read()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\\\"error on read echo pin: %v\\\", err)\n\t\t}\n\n\t\tif val == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tif time.Since(start) > hcsr04MeasureTimeout {\n\t\t\treturn fmt.Errorf(\\\"measurement timeout for '%s' after %v\\\", d.driverCfg.name, hcsr04MeasureTimeout)\n\t\t}\n\n\t\ttime.Sleep(hcsr04PollInputIntervall)\n\t}\n\n\td.lastMeasureMicroSec = time.Since(start).Microseconds()\n\n\treturn nil\n}", "CodeBleu_score": 57.97590091395526}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\tif err := d.triggerPin.Write(1); err != nil {\n\t\treturn fmt.Errorf(\\\"error on trigger pin write: %v\\\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerDelay)\n\n\t// wait for the measurement to complete or for a timeout to occur\n\ttimeout := time.NewTimer(hcsr04MeasureTimeout)\n\tselect {\n\tcase d := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = d\n\t\treturn nil\n\tcase <-timeout.C:\n\t\treturn fmt.Errorf(\\\"timeout on measure distance\\\")\n\t}\n}", "CodeBleu_score": 58.26388595423716}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv(\\\"PLATFORMIO_AUTH_TOKEN\\\")\n        if access_token:\n            return access_token\n\n        account = app.get_state_item(\\\"account\\\")\n        if not account:\n            raise AccountNotAuthorized()\n\n        auth = account.get(\\\"auth\\\")\n        if not auth:\n            raise AccountNotAuthorized()\n\n        access_token = auth.get(\\\"access_token\\\")\n        if not access_token:\n            raise AccountNotAuthorized()\n\n        expires_at = auth.get(\\\"expires_at\\\")\n        if expires_at and expires_at < time.time():\n            if not auth.get(\\\"refresh_token\\\"):\n                raise AccountNotAuthorized()\n\n            try:\n                self.fetch_json_data(\\\"refresh\\\", data={\\\"refresh_token\\\": auth.get(\\\"refresh_token\\\")})\n            except AccountError as exc:\n                raise AccountNotAuthorized() from exc\n\n            account = app.get_state_item(\\\"account\\\")\n            auth = account.get(\\\"auth\\\")\n            access_token = auth.get(\\\"access_token\\\")\n            expires_at = auth.get(\\\"expires_at\\\")\n\n        return access_token\n\n", "CodeBleu_score": 34.620678569869646}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\\\"PLATFORMIO_ACCOUNT_AUTH_TOKEN\\\"]\n    except KeyError:\n        pass\n\n    account = app.get_state_item(\\\"account\\\")\n    if not account or \\\"auth\\\" not in account or \\\"access_token\\\" not in account[\\\"auth\\\"]:\n        raise AccountNotAuthorized()\n\n    if account[\\\"auth\\\"][\\\"expires_at\\\"] < time.time():\n        if \\\"refresh_token\\\" not in account[\\\"auth\\\"]:\n            raise AccountNotAuthorized()\n\n        account[\\\"auth\\\"] = self.fetch_authentication_data(account[\\\"auth\\\"][\\\"refresh_token\\\"])\n        app.set_state_item(\\\"account\\\", account)\n\n    return account[\\\"auth\\\"][\\\"access_token\\\"]\n\n", "CodeBleu_score": 27.947360568253565}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\\\"PLATFORMIO_AUTH_TOKEN\\\"]\n    except KeyError:\n        pass\n\n    account = app.get_state_item(\\\"account\\\")\n    if not account or \\\"auth\\\" not in account:\n            raise AccountNotAuthorized()\n        auth = account[\\\"auth\\\"]\n        if \\\"access_token\\\" not in auth or \\\"expire_at\\\" not in auth:\n            raise AccountNotAuthorized()\n        if time.time() < auth[\\\"expire_at\\\"]:\n            return auth[\\\"access_token\\\"]\n        if \\\"refresh_token\\\" not in auth:\n            raise AccountNotAuthorized()\n        try:\n            auth = self.refresh_token(auth[\\\"refresh_token\\\"])\n        except AccountError:\n            raise AccountNotAuthorized()\n        app.set_state_item(\\\"account\\\", {\\\"auth\\\": auth})\n        return auth[\\\"access_token\\\"]\n\n", "CodeBleu_score": 33.14088157609948}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n            refresh_token = self.get_refresh_token()\n        except AccountNotAuthorized:\n            return True\n\n        try:\n            self.fetch_json_data(\n                \\\"post\\\",\n                \\\"/v1/logout\\\",\n                headers={\n                    \\\"Authorization\\\": \\\"Bearer %s\\\" % refresh_token\n                },\n            )\n        except AccountError:\n            pass\n\n        self.delete_local_session()\n        return True\n\n", "CodeBleu_score": 53.4538669291484}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 64.31288061280071}, {"code": "def logout(self)\n\t\n    try:\n            refresh_token = self.get_refresh_token()\n            self.delete_local_session()\n            self.fetch_json_data(\n                \\\"post\\\",\n                \\\"/v1/logout\\\",\n                headers={\n                    \\\"Authorization\\\": \\\"Bearer %s\\\" % refresh_token\n                },\n            )\n            return True\n        except AccountError:\n            return False\n\n", "CodeBleu_score": 48.591392755725465}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())):\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg:\n            continue\n        result.append(dict(name=name, version=str(pkg.metadata.version)))\n        if pkg.metadata.get(\"sources\"):\n            result[-1][\"url\"] = pkg.metadata.get(\"sources\")[0].get(\"url\")\n    return result\n\n", "CodeBleu_score": 51.31475210805976}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        versions = [options.get(\"version\")]\n        if options.get(\"optionalVersions\"):\n            versions.extend(options.get(\"optionalVersions\", []))\n        for version in versions:\n            if not version:\n                continue\n            pkg = self.get_package(name, self.get_package_spec(name, version))\n            if pkg:\n                result.append(pkg)\n    return result\n\n", "CodeBleu_score": 47.057644683277466}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if pkg and pkg.metadata.get(\"external\"):\n            result.append(dict(name=name, version=str(pkg.metadata.version), source=pkg.metadata.get(\"source\")))\n        else:\n            result.append(dict(name=name, version=str(pkg.metadata.version)))\n    return result\n\n", "CodeBleu_score": 50.208761000061045}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    project_config = ProjectConfig()\n    platform_spec = project_config.get_env_platform(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.env = env\n    instance.configure_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 28.67140754450532}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig()\n    config.load_env(env)\n        if not config.has_platform(env):\n            raise UndefinedEnvPlatformError(env)\n\n        platform_spec = config.get_env_platform(env)\n        _instance = cls.new(platform_spec, autoinstall=autoinstall)\n        _instance.env = env\n        _instance.configure_packages(targets=targets)\n        return _instance\n\n", "CodeBleu_score": 40.97837988028843}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig().get_env(env)\n        if not config.get(\\\"platform\\\"):\n            raise UndefinedEnvPlatformError(env)\n        return cls(config.get(\\\"platform\\\", autoinstall=autoinstall), env=env, targets=targets)\n\n    @classmethod\n    def new(cls, platform, env=None, targets=None, autoinstall=False):\n        if isinstance(platform, dict):\n            platform = platform.get(\\\"name\\\")\n\n        if isinstance(platform, base.PlatformBase):\n            _platform = platform\n        else:\n            _platform = PlatformFactory.new(platform, autoinstall=autoinstall)\n\n        if env is not None:\n            _platform.set_env(env)\n\n        if targets is not None:\n            _platform.configure_packages(targets)\n\n        return _platform\n\n    @classmethod\n    def from_string(cls, platform_spec, env=None, targets=None, autoinstall=False):\n        if isinstance(platform_spec, dict):\n            platform_spec = platform_spec.get(\\\"name\\\")\n\n        if isinstance(platform_spec, base.PlatformBase):\n            _platform = platform_spec\n        else:\n            _platform = PlatformFactory.new(platform_spec, autoinstall=autoinstall)\n\n        if env is not None:\n            _platform.set_env(env)\n\n        if targets is not None:\n            _platform.configure_packages(targets)\n\n        return _platform\n\n    @classmethod\n    def from_project_config(cls, env, targets=None, autoinstall=False):\n        return cls.from_env(env, targets=targets, autoinstall=autoinstall)\n\n    @classmethod\n    def from_project_dir(cls, env, targets=None, autoinstall=False):\n        return cls.from_env(env, targets=targets, autoinstall=autoinstall)\n\n    @classmethod\n    def from_project_file(cls, env,", "CodeBleu_score": 32.34078305819931}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.96762498070593}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.96762498070593}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.96762498070593}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x32, 0x01);\n        Write4Byte(0x30, time_in_us);\n    } else {\n        Write1Byte(0x32, 0x00);\n    }\n    Write1Byte(0x31, Read8bit(0x31) & 0x7F);\n    Write1Byte(0x32, Read8bit(0x32) | 0x02);\n}", "CodeBleu_score": 44.89009326367061}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        uint8_t buf[3];\n        buf[0] = time_in_us & 0xff;\n        buf[1] = (time_in_us >> 8) & 0xff;\n        buf[2] = (time_in_us >> 16) & 0xff;\n        WriteBuff(0x32, 3, buf);\n    } else {\n        Write1Byte(0x32, 0x00);\n    }\n    Write1Byte(0x30, 0x02);\n    Write1Byte(0x92, 0x07);\n    Write1Byte(0x90, 0x01);\n    Write1Byte(0x30, 0x00);\n}", "CodeBleu_score": 49.10462286660074}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        Write1Byte(0x32, 0x03);\n        Write32bit(0x30, time_in_us);\n    } else {\n        Write1Byte(0x32, 0x00);\n    }\n    Write1Byte(0x31, Read8bit(0x31) & 0x7F);\n    Write1Byte(0x30, Read8bit(0x30) | 0x01);\n    while (1)\n        ;\n}", "CodeBleu_score": 39.71264699124752}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t", "CodeBleu_score": 1.6688059799790205}, {"code": "int Display::scroll_line(uint32_t color){\n\t  //Serial.println(F(\"scroll_line()\"));\n  int prev_yDraw = yDraw;\n  //Serial.println(yDraw);\n  //Serial.println(yStart);\n  //Serial.println(yArea);\n  //Serial.println(yDraw + TEXT_HEIGHT);\n  //Serial.println(yStart + yArea);\n  //Serial.println(yDraw + TEXT_HEIGHT < yStart + yArea);\n  if (yDraw + TEXT_HEIGHT < yStart + yArea)\n  {\n    yDraw = yDraw + TEXT_HEIGHT;\n  }\n  else\n  {\n    yDraw = yStart;\n  }\n  //Serial.println(yDraw);\n  //Serial.println(prev_yDraw);\n  //Serial.println(color);\n  tft.fillRect(0, prev_yDraw, SCREEN_WIDTH, TEXT_HEIGHT, color);\n  //Serial.println(F(\"scroll_line() end\"));\n  return prev_yDraw;\n}", "CodeBleu_score": 19.938808719101537}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int yPrev = yStart;\n  yStart = (yStart + TEXT_HEIGHT) % yArea;\n\n  if (tteBar)\n    tft.fillRect(0, yPrev, SCREEN_WIDTH, TEXT_HEIGHT, color);\n  else\n    tft.fillRect(0, yPrev, SCREEN_WIDTH, TEXT_HEIGHT, color);\n\n  return yPrev;\n}", "CodeBleu_score": 20.290304420376117}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  this->setup();\n\n  if (!this->setAccessPoints()) {\n    return false;\n  }\n\n  if (!this->setHTMLContent()) {\n    return false;\n  }\n\n  this->start();\n\n  return true;\n}", "CodeBleu_score": 57.857125153153156}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setupAPs()) {\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    return false;\n  }\n\n  this->runServer = true;\n  this->startServer();\n\n  return true;\n}", "CodeBleu_score": 57.53343484704778}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setupAP()) {\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    return false;\n  }\n\n  this->runServer = true;\n  server.begin();\n  return true;\n}", "CodeBleu_score": 57.67464772738481}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif(this->queue_enabled_flag) {\n\t\tif(!this->queue)\n\t\t\tthis->new_queue();\n\t\tif(!this->text)\n\t\t\tthis->text=new LinkedList<String>;\n\t\tif(!this->text_in)\n\t\t\tthis->text_in=new LinkedList<String>;\n\t}\n\telse {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag=true;\n\t}\n}", "CodeBleu_score": 58.26279957843576}, {"code": "void GpsInterface::enable_queue(){\n\t  if(this->queue_enabled_flag){\n    if(!this->queue){\n      this->new_queue();\n    }\n    if(!this->text){\n      this->text=new LinkedList<String>;\n    }\n    if(!this->text_in){\n      this->text_in=new LinkedList<String>;\n    }\n  }\n  else{\n    this->flush_queue();\n    this->queue_enabled_flag=true;\n  }\n}", "CodeBleu_score": 43.47713391614516}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (!this->queue)\n\t\t\tthis->new_queue();\n\t\tif (!this->text)\n\t\t\tthis->text = new LinkedList<String>;\n\t\tif (!this->text_in)\n\t\t\tthis->text_in = new LinkedList<String>;\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 46.16952169934724}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    if (this->queue->size()) {\n      LinkedList<nmea_sentence_t> *delme = this->queue;\n      this->queue = new LinkedList<nmea_sentence_t>;\n      delete delme;\n    }\n    else\n      delete this->queue;\n  }\n  else\n    this->queue = new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 58.63319218343088}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    LinkedList<nmea_sentence_t> *delme = this->queue;\n    this->queue = new LinkedList<nmea_sentence_t>;\n    delete delme;\n  } else\n    this->new_queue();\n}", "CodeBleu_score": 68.38999714170075}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    if (this->queue->size()) {\n      LinkedList<nmea_sentence_t> *delme = this->queue;\n      this->queue = new LinkedList<nmea_sentence_t>;\n      delete delme;\n    }\n  }\n  else\n    this->new_queue();\n}", "CodeBleu_score": 77.18961839395462}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.pushColors(color_p, w * h, true);\n\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 40.746904310097044}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.pushColors((uint16_t *)&color_p->full, w * h, true);\n\n    /* IMPORTANT!!!\n     * Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 41.85720597234801}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.pushColors(color_p, w * h, true);\n\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 40.746904310097044}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tln(\\\"C(Hold) - Exit\\\");\n            pressed = false;\n          }", "CodeBleu_score": 4.254616802858982}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tln(\\\"C(Hold) - Exit\\\");\n            pressed = false;\n          }", "CodeBleu_score": 4.254616802858982}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tln(\\\"C(Hold) - Exit\\\");\n            pressed = false;\n          }", "CodeBleu_score": 4.254616802858982}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int num_generated = 0;\n  for (int i = 0; i < count; i++) {\n    ssid s = {generateRandomString(6), random(1, 12), {random(256), random(256), random(256), random(256), random(256), random(256)}, false};\n    ssids->add(s);\n    Serial.println(ssids->get(ssids->size() - 1).essid);\n    num_generated++;\n  }\n  return num_generated;\n}", "CodeBleu_score": 59.053290027161154}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int num_ssids = 0;\n  for (int i = 0; i < count; i++) {\n    ssid s = {generateRandomSSID(), random(1, 12), {random(256), random(256), random(256), random(256), random(256), random(256)}, false};\n    ssids->add(s);\n    Serial.println(ssids->get(ssids->size() - 1).essid);\n    num_ssids++;\n  }\n  return num_ssids;\n}", "CodeBleu_score": 58.36581712334401}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  for (int i = 0; i < count; i++) {\n    String s = \\\"\\\";\n    for (int j = 0; j < 6; j++) {\n      s += (char)random(65, 91);\n    }\n\n    ssid sid = {s, random(1, 12), {random(256), random(256), random(256), random(256), random(256), random(256)}, false};\n    ssids->add(sid);\n    Serial.println(ssids->get(ssids->size() - 1).essid);\n  }\n\n  return ssids->size();\n}", "CodeBleu_score": 60.97748670197439}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.75438905838018}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.75438905838018}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.75438905838018}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(\\\"Creating JWT using {algorithm}...\\\")\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 62.46708120153812}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(\\\"Creating JWT using {} from private key file {}\\\".format(algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)", "CodeBleu_score": 70.68972901206975}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(\\'Creating JWT using {}\\'.format(algorithm))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 63.111465420234126}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(str(message.payload), message.topic, str(message.qos)))\n    if str(message.payload) == \"on\":\n        print(\"on\")\n        capture_image()\n        upload_image()\n        publish_messages(\"iot-project-349414\", \"iot-topic\", \"gs://iot-project-349414.appspot.com/image.jpg\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 29.058483877806303}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\\\"utf-8\\\"))\n    print(\\\"Received message \\'{}\\' on topic \\'{}\\' with Qos {}\".format(payload, message.topic, str(message.qos)))\n    if payload == \\\"on\\\":\n        # Capture a preview image\n        camera = picamera.PiCamera()\n        camera.resolution = (640, 480)\n        camera.capture(\\\"/home/pi/image.jpg\\\")\n        camera.close()\n        # Upload the image to a specified bucket\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(\\\"<BUCKET_NAME>\\\")\n        blob = bucket.blob(\\\"image.jpg\\\")\n        blob.upload_from_filename(\\\"/home/pi/image.jpg\\\")\n        # Publish the image's URL to an MQTT event topic\n        publish_messages(\\\"<PROJECT_ID>\\\", \\\"<TOPIC_NAME>\\\", blob.public_url)\n    else:\n        print(\\\"off\\\")\n\n", "CodeBleu_score": 32.99119248301528}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\\"#{}\\\" on topic \\\"{}\\\" with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Capturing image')\n        image_capture()\n        print('Image captured')\n        file_name = 'image.jpg'\n        print('Uploading image to bucket')\n        upload_blob(file_name)\n        print('Image uploaded')\n        url = 'gs://' + BUCKET_NAME + '/' + file_name\n        publish_messages(PROJECT_ID, TOPIC_NAME, url)\n        print('Published data')\n    else:\n        print('off')\n\n", "CodeBleu_score": 33.61689874956101}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Subscribe to a Cloud Pub/Sub topic.')\n    parser.add_argument('--project_id',\n                        help='GCP cloud project name.',\n                        required=True)\n    parser.add_argument('--subscription_name',\n                        help='Cloud Pub/Sub subscription name.',\n                        required=True)\n    return parser.parse_args()\n\n", "CodeBleu_score": 30.176930497065268}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Subscribe to a Cloud Pub/Sub topic.')\n    parser.add_argument('--project_id', help='GCP cloud project name', required=True)\n    parser.add_argument('--subscription_name', help='Cloud Pub/Sub subscription name', required=True)\n    parser.add_argument('--timeout', help='Timeout for the subscriber (in seconds)', default=600, type=int)\n    args = parser.parse_args()\n    return args\n\n", "CodeBleu_score": 39.217556468570116}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Subscribe to a Pub/Sub topic.')\n    parser.add_argument('--project-id', required=True, help='GCP cloud project name.')\n    parser.add_argument('--subscription-name', required=True, help='Pub/Sub subscription name.')\n    parser.add_argument('--timeout', default=None, type=float, help='MQTT connection timeout in seconds. Default: 10s')\n    parser.add_argument('--ack-deadline-seconds', default=10, type=int, help='MQTT ack deadline in seconds. Default: 10s')\n    parser.add_argument('--num-messages', default=1, type=int, help='Number of messages to pull. Default: 1')\n    parser.add_argument('--verbosity', choices=['debug', 'info', 'error'], default='info', help='Set the logging level. Default: info')\n    parser.add_argument('--quiet', action='store_true', help='Suppress all but the most important messages.')\n    args = parser.parse_args()\n    return args\n\n", "CodeBleu_score": 41.95694657276541}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = (\n        \"https://cloudiot.googleapis.com/$discovery/rest?version=\"\n        + api_version\n    )\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    client = discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n    return client\n\n", "CodeBleu_score": 27.967205066989724}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    api_discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n    return discovery.build(\"cloudiot\", api_version, credentials=scoped_credentials, discoveryServiceUrl=api_discovery_url)\n\n", "CodeBleu_score": 22.920094948228115}, {"code": "def get_client(service_account_json)\n\t\n    # Define the API scopes to access Cloud IoT Core\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Define the API version and discovery URL for Cloud IoT Core\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials from the JSON file\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n\n    # Build the client for the Cloud IoT Core service\n    client = discovery.build(\n        'cloudiot',\n        api_version,\n        credentials=credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n    return client\n\n", "CodeBleu_score": 26.844188168936768}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = hash_method.asn1_code()\n    if asn1_code is None:\n        raise ValueError('Hash method does not have a DER encoding')\n    if len(asn1_code) != 2:\n        raise ValueError('Hash method DER encoding is not a sequence')\n    if asn1_code[0] != 48:\n        raise ValueError('Hash method DER encoding is not a sequence')\n    if asn1_code[1] != len(hash_value):\n        raise ValueError('Hash method DER encoding is not a sequence')\n    block = b''.join([asn1_code, hash_value])\n    padded = _pad_for_signing(block, common.byte_size(priv_key.n))\n    payload = transform.bytes2int(padded)\n    encrypted = core.encrypt_int(payload, priv_key.d, priv_key.n)\n    return transform.int2bytes(encrypted, common.byte_size(priv_key.n))\n\n", "CodeBleu_score": 41.63569092760676}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = _get_hash_method_asn1(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError('Hash method not supported')\n\n    # Concatenate the ASN1 code with the hash value\n    block = b''.join([hash_method_asn1, hash_value])\n\n    # Pad the block for signing\n    padded_block = _pad_for_signing(block, common.byte_size(priv_key.n))\n\n    # Encrypt the padded block with the private key\n    signature = encrypt(padded_block, priv_key)\n\n    return signature\n\n\n", "CodeBleu_score": 34.87832048632965}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == 'MD5':\n        asn1_code = b'\\\\x30\\\\x20\\\\x30\\\\x0c\\\\x06\\\\x08\\\\x2a\\\\x86\\\\x48\\\\x86\\\\xf7\\\\x0d\\\\x02\\\\x05\\\\x05\\\\x00\\\\x04\\\\x10'\n    elif hash_method == 'SHA-1':\n        asn1_code = b'\\\\x30\\\\x21\\\\x30\\\\x09\\\\x06\\\\x05\\\\x2b\\\\x0e\\\\x03\\\\x02\\\\x1a\\\\x05\\\\x00\\\\x04\\\\x14'\n    elif hash_method == 'SHA-256':\n        asn1_code = b'\\\\x30\\\\x31\\\\x30\\\\x0d\\\\x06\\\\x09\\\\x60\\\\x86\\\\x48\\\\x01\\\\x65\\\\x03\\\\x04\\\\x02\\\\x01\\\\x05\\\\x00\\\\x04\\\\x20'\n    elif hash_method == 'SHA-384':\n        asn1_code = b'\\\\x30\\\\x41\\\\x30\\\\x0d\\\\x06\\\\x09\\\\x60\\\\x86\\\\x48\\\\x01\\\\x65\\\\x03\\\\x04\\\\x02\\\\x02\\\\x05\\\\x00\\\\x04\\\\x30'\n    elif hash_method == 'SHA-512':\n        asn1_code = b'\\\\x30\\\\x51\\\\x30\\\\x0d\\\\x06\\\\x09\\\\x60\\\\x86\\\\x48\\\\x01\\\\x65\\\\x03\\\\x04\\\\x02\\\\x03\\\\x05\\\\x00\\\\x04\\\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n    asn1_code = bytes(asn1_code", "CodeBleu_score": 11.382855317122278}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the signature to obtain the clear signature\n    signature_clear = pub_key.blinded_decrypt(signature_int)\n\n    # Determine the hash method used\n    hash_method = _get_hash_method_from_signature(signature_clear)\n\n    # Compute the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _reconstruct_padded_hash(signature_clear, hash_method)\n\n    # Compare the expected padded hash with the clear signature\n    if expected_padded_hash != msg_hash:\n        raise VerificationError('Signature is invalid')\n\n    # Return the hash method name\n    return hash_method\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 17.21257872531337}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer and decrypt it to obtain the clear signature\n    signature_int = transform.bytes2int(signature)\n    decrypted_signature = core.decrypt_int(signature_int, pub_key.e, pub_key.n)\n    # Convert the clear signature to a byte string\n    clear_signature = transform.int2bytes(decrypted_signature)\n    # Determine the hash method used\n    hash_method = _determine_hash_method(clear_signature)\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _reconstruct_padded_hash(clear_signature, hash_method)\n    # Compare the expected padded hash with the computed hash\n    if message_hash != expected_padded_hash:\n        raise VerificationError('Verification failed')\n    return hash_method\n\n", "CodeBleu_score": 25.646164735184595}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the signature to obtain the clear signature\n    clear_signature = pub_key.blinded_decrypt(signature_int)\n\n    # Determine the hash method used\n    hash_method = _get_hash_method(clear_signature)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_hash = _reconstruct_hash(clear_signature, hash_method)\n\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if expected_hash != message_hash:\n        raise VerificationError('Signature is not valid')\n\n    # Return the hash method name\n    return hash_method\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 18.064262186548092}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t currentTime;\n\tcurrentTime = clock_getTime();\n\tif (currentTime != CLOCK_INVALID_TIME) {\n\t\tupdateJWT(currentTime);\n\t}\n\n\tif (connectMQTTSocket() == 0) {\n\t\twaitingForMQTT = true;\n\t\tsendSubscribe = true;\n\t\tdebug_printError(\\\"CLOUD: MQTT Connection Attempt\\\");\n\t}\n}", "CodeBleu_score": 46.566761875554164}, {"code": "static void connectMQTT(){\n\t   uint32_t currentTime;\n   currentTime = getTime();\n\n   if (currentTime != 0) {\n      updateJWT(currentTime);\n      if (connectMQTTSocket() == 0) {\n         sendSubscribe = true;\n         debug_printError(\\\"CLOUD: MQTT Connection attempt\\\");\n      }\n   }\n}", "CodeBleu_score": 51.762150078430324}, {"code": "static void connectMQTT(){\n\t    uint32_t currentTime = clock_getCurrentTime();\n    if (currentTime != 0) {\n        updateJWT(currentTime);\n        if (connectMQTTSocket() == 0) {\n            waitingForMQTT = true;\n            debug_printInfo(\\\"CLOUD: MQTT connection attempt\\\");\n        }\n    }\n}", "CodeBleu_score": 51.802925434934366}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t  int i;\n  uint32_t n = 0;\n\n  // Convert the string from left to right\n  // Check each character to ensure it is a digit\n  // and calculate the numeric value\n  for (i = 0; i < width; i++)\n  {\n    if (str[i] < '0' || str[i] > '9')\n    {\n      return str;\n    }\n    n = n * 10 + (str[i] - '0');\n  }\n\n  // Check for overflow\n  if (n > UINT32_MAX)\n  {\n    return str;\n  }\n\n  *num = n;\n  return str + width;\n}", "CodeBleu_score": 29.066769578235412}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t ret = 0;\n    int i;\n\n    // Check each character to ensure it is a digit and calculate the numeric value\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        ret = ret * 10 + (str[i] - '0');\n    }\n\n    // Check for overflow\n    if (ret > UINT32_MAX) {\n        return str;\n    }\n\n    // Store the resulting number\n    *num = ret;\n\n    // Return a pointer to the position just past the processed digits\n    return str + width;\n}", "CodeBleu_score": 29.757243782713644}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    int i;\n    uint32_t n = 0;\n    for (i = 0; i < width; i++)\n    {\n        if (str[i] < '0' || str[i] > '9')\n        {\n            return str;\n        }\n        n = n * 10 + (str[i] - '0');\n    }\n    *num = n;\n    return str + width;\n}", "CodeBleu_score": 27.091577915705685}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->is_device_sn) {\n        ret = atcacert_set_device_sn(build_state->cert_def, build_state->cert, *build_state->cert_size, build_state->max_cert_size, build_state->device_sn);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 72.29034156765728}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t  int ret = 0;\n  uint8_t *data = NULL;\n  uint8_t *ca_public_key = NULL;\n\n  if (build_state == NULL) {\n    return ATCACERT_E_BAD_PARAMS;\n  }\n\n  if (build_state->cert_def == NULL) {\n    return ATCACERT_E_BAD_CERT;\n  }\n\n  if (build_state->cert_def->cert_template_size == 0) {\n    return ATCACERT_E_BAD_CERT;\n  }\n\n  if (build_state->cert_def->type == CERTTYPE_X509) {\n    // Set a fake signature that should result in the largest X.509 cert. This will ensure\n    // the cert buffer is large enough early in the cert rebuilding process.\n    uint8_t large_sig[64];\n    memset(large_sig, 0xFF, sizeof(large_sig));\n    ret = atcacert_set_signature(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->max_cert_size, large_sig);\n    if (ret != ATCACERT_E_SUCCESS) {\n      return ret;\n    }\n  }\n\n  if (ca_public_key != NULL) {\n    // Set the authority key ID\n    ret = atcacert_set_auth_key_id(build_state->cert_def, build_state->cert, *build_state->cert_size, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n      return ret;\n    }\n  }\n\n  return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 67.81055404898312}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    atca_status_t status = ATCA_GEN_FAIL;\n    atca_sha2_context_t sha2_ctx;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_BAD_PARAMS;\n    }\n\n    // Retrieve the digest of the certificate's to-be-signed (TBS) portion\n    status = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (status != ATCA_SUCCESS) {\n        return ATCACERT_VERIFY_FAIL;\n    }\n\n    // Retrieve the certificate's signature\n    status = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (status != ATCA_SUCCESS) {\n        return ATCACERT_VERIFY_FAIL;\n    }\n\n    // Verify the TBS digest against the signature using the CA public key\n    status = atca_crypto_verify_sha256(ca_public_key, signature, tbs_digest, &sha2_ctx);\n    if (status != ATCA_SUCCESS) {\n        return ATCACERT_VERIFY_FAIL;\n    }\n\n    return ATCACERT_SUCCESS;\n}", "CodeBleu_score": 73.50510605883822}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *prevPoint = NULL;\n    timerStruct_t *insertPoint = *list;\n    while(insertPoint != NULL)\n    {\n        if(insertPoint == timer)\n        {\n            if(prevPoint == NULL)\n            {\n                *list = timer->next;\n            }\n            else\n            {\n                prevPoint->next = timer->next;\n            }\n            return true;\n        }\n        prevPoint = insertPoint;\n        insertPoint = insertPoint->next;\n    }\n    return false;\n}", "CodeBleu_score": 39.889902601294835}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (timer == NULL)\n        return false;\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    timerStruct_t *curr = prev->next;\n    while (curr != NULL)\n    {\n        if (curr == timer)\n        {\n            prev->next = curr->next;\n            return true;\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 39.07217487461207}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *listHead = list;\n    timerStruct_t * volatile *prevPoint = listHead;\n    timerStruct_t * volatile *insertPoint = listHead;\n\n    while (*insertPoint != NULL)\n    {\n        if (*insertPoint == timer)\n        {\n            if (prevPoint == listHead)\n            {\n                *listHead = timer->next;\n            }\n            else\n            {\n                *prevPoint = timer->next;\n            }\n            return true;\n        }\n        prevPoint = insertPoint;\n        insertPoint = &(*insertPoint)->next;\n    }\n    return false;\n}", "CodeBleu_score": 40.06807308662719}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t    int returnValue = BSD_ERROR;\n    packetReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n    if (!bsdSocket) {\n        debug_printError(\"BSD: close error unknown socket number\");\n    } else {\n        bsdSocket->socketState = NOT_A_SOCKET;\n        if (close(socket) != BSD_SUCCESS) {\n            debug_printError(\"BSD: close error %d\", errno);\n            switch (errno) {\n                case EBADF:\n                    bsd_setErrNo(EBADF);\n                    break;\n                case ENOTSOCK:\n                    bsd_setErrNo(ENOTSOCK);\n                    break;\n                case EIO:\n                    bsd_setErrNo(EIO);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            debug_printGOOD(\"BSD: close success\");\n            returnValue = BSD_SUCCESS;\n        }\n    }\n    return returnValue;\n}", "CodeBleu_score": 56.13626191668934}, {"code": "int BSD_close(int socket){\n\t   int returnValue = BSD_ERROR;\n   packetReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n   if(!bsdSocket)\n   {\n      debug_printError(\"BSD: close error unknown socket number\");\n   }\n   else\n   {\n      bsdSocket->socketState = NOT_A_SOCKET;\n      int wincCloseReturn = close(socket);\n      if(wincCloseReturn != WINC_SOCK_ERR_NO_ERROR)\n      {\n         debug_printError(\"BSD: close error %d\",wincCloseReturn);\n         switch(wincCloseReturn)\n         {\n            case WINC_SOCK_ERR_INVALID_ARG:\n               bsd_setErrNo(EBADF);\n            break;\n            default:\n               bsd_setErrNo(EIO);\n            break;\n         }\n      }\n      else\n      {\n         debug_printGOOD(\"BSD: socket (%d) closed\",*bsdSocket->socket);\n         returnValue = BSD_SUCCESS;\n      }\n   }\n   return returnValue;\n}", "CodeBleu_score": 54.116242013131775}, {"code": "int BSD_close(int socket){\n\t\tint returnValue = BSD_ERROR;\n\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (!bsdSocket) {\n\t\tdebug_printError(\"BSD: close error unknown socket number\");\n\t} else {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t\tif (close(socket) != WINC_SOCK_ERR_NO_ERROR) {\n\t\t\tdebug_printError(\"BSD: close error %d\", close(socket));\n\t\t\tbsd_setErrNo(EBADF);\n\t\t} else {\n\t\t\treturnValue = BSD_SUCCESS;\n\t\t}\n\t}\n\treturn returnValue;\n}", "CodeBleu_score": 39.71807005651608}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d) \", socket);\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t} else if (backlog < 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 75.58035353471367}, {"code": "int BSD_listen(int socket, int backlog){\n\t    wincSocketResponses_t wincListenReturn;\n\n    debug_printGOOD(\"BSD: BSD_listen (%d, %d) \", socket, backlog);\n    packetReceptionHandler_t* sock = getSocketInfo(socket);\n    if (sock != NULL) {\n        sock->socketState = SOCKET_LISTEN;\n    }\n\n    wincListenReturn = listen((SOCKET) socket, (uint16_t) backlog);\n\n    if (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n        switch (wincListenReturn) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if (socket < 0) {\n                    bsd_setErrNo(ENOTSOCK);\n                } else if (backlog < 0) {\n                    bsd_setErrNo(EINVAL);\n                }\n                break;\n            case WINC_SOCK_ERR_INVALID:\n                bsd_setErrNo(EIO);\n                break;\n            default:\n                break;\n        }\n        return BSD_ERROR;\n    } else {\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 70.55158752879962}, {"code": "int BSD_listen(int socket, int backlog){\n\t    wincSocketResponses_t wincListenReturn;\n\n    debug_printGOOD(\"BSD: BSD_listen (%d) \", socket);\n    packetReceptionHandler_t* sock = getSocketInfo(socket);\n    if (sock != NULL) {\n        sock->socketState = LISTENING;\n    }\n\n    wincListenReturn = listen((SOCKET)socket, (uint16_t)backlog);\n\n    if (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n        switch (wincListenReturn) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if (socket < 0) {\n                    bsd_setErrNo(ENOTSOCK);\n                } else if (backlog < 0) {\n                    bsd_setErrNo(EINVAL);\n                }\n                break;\n            case WINC_SOCK_ERR_INVALID:\n                bsd_setErrNo(EIO);\n                break;\n            default:\n                break;\n        }\n        return BSD_ERROR;\n    } else {\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 70.89471960706271}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t   wincSocketResponses_t wincAcceptReturn;\n   static wincSupported_sockaddr winc_sockaddr;\n\n   winc_sockaddr.sa_family = addr->sa_family;\n   memcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n   switch(winc_sockaddr.sa_family)\n   {\n      case PF_INET:\n         winc_sockaddr.sa_family = AF_INET;\n         wincAcceptReturn = accept((int8_t)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n      break;\n      default:\t\t//Address family not supported by WINC\n         bsd_setErrNo(EAFNOSUPPORT);\n         return BSD_ERROR;\n   }\n\n   if (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR)\n   {\n      switch(wincAcceptReturn)\n      {\n         case WINC_SOCK_ERR_INVALID_ARG:\n            if(socket < 0)\n            {\n               bsd_setErrNo(ENOTSOCK);\n            }\n            else if(addr != NULL)\n            {\n               bsd_setErrNo(EFAULT);\n            }\n            else if(addrlen == 0)\n            {\n               bsd_setErrNo(EINVAL);\n            }\n            break;\n         case WINC_SOCK_ERR_INVALID:\n            bsd_setErrNo(EIO);\n            break;\n         default:\n            break;\n      }\n      return BSD_ERROR;\n   }\n   else\n   {\n      return BSD_SUCCESS;\n   }\n}", "CodeBleu_score": 76.52627547285707}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\tstatic wincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family)\n\t{\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif(wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincAcceptReturn)\n\t\t{\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr == NULL)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_BUFFER_FULL:\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n\t\t// The socket.c send() API only returns (0) to indicate No Error\n\t\t// Current WINC implementation doesn't use returned value per BSD.\n\n\t\t// TODO: Number of Bytes received should be returned in correct implementation.\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 80.83939702258051}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t  wincSocketResponses_t wincAcceptReturn;\n  static wincSupported_sockaddr winc_sockaddr;\n\n  winc_sockaddr.sa_family = addr->sa_family;\n  memcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n  switch(winc_sockaddr.sa_family)\n  {\n    case PF_INET:\n      winc_sockaddr.sa_family = AF_INET;\n      wincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n    break;\n    default:    //Address family not supported by WINC\n      bsd_setErrNo(EAFNOSUPPORT);\n      return BSD_ERROR;\n  }\n\n  if (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR)\n  {\n    switch(wincAcceptReturn)\n    {\n      case WINC_SOCK_ERR_INVALID_ARG:\n        if (socket < 0)\n        {\n          bsd_setErrNo(ENOTSOCK);\n        }\n        else if (addr == NULL)\n        {\n          bsd_setErrNo(EFAULT);\n        }\n        else if (addrlen == NULL)\n        {\n          bsd_setErrNo(EINVAL);\n        }\n        break;\n      case WINC_SOCK_ERR_INVALID:\n        bsd_setErrNo(EIO);\n        break;\n      default:\n        break;\n    }\n    return BSD_ERROR;\n  }\n  else\n  {\n    return BSD_SUCCESS;\n  }\n}", "CodeBleu_score": 82.92180296806728}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t   debug_printError(\\\"CLOUD: MQTT Connection attempt\\\");\n   uint32_t currentTime = (uint32_t) time(NULL);\n   if (currentTime != 0) {\n      updateJWT(currentTime);\n   }\n\n   // Initiate MQTT connection\n   if (connectMQTTSocket() == MQTT_SUCCESS) {\n      sendSubscribe = true;\n   }\n}", "CodeBleu_score": 58.95463638944343}, {"code": "static void connectMQTT(){\n\t   debug_printError(\"CLOUD: Connecting to MQTT\");\n   uint32_t currentTime = get_current_time();\n   if (currentTime == 0) {\n      debug_printError(\"CLOUD: Invalid time\");\n      return;\n   }\n   updateJWT(currentTime);\n\n   if (connectMQTTSocket() == 0) {\n      sendSubscribe = true;\n   }\n}", "CodeBleu_score": 56.75384641039807}, {"code": "static void connectMQTT(){\n\t    // Get the current time in UNIX format\n    uint32_t epoch = time(NULL);\n\n    // Check if the time is valid\n    if (epoch != (uint32_t)-1) {\n        // Update the JWT with the current time offset\n        updateJWT(epoch);\n\n        // Initiate the MQTT connection\n        if (connectMQTTSocket() == 0) {\n            // Print a debug message indicating the connection attempt\n            debug_printError(\"CLOUD: MQTT Connection Attempt\");\n\n            // Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n            sendSubscribe = true;\n        }\n    }\n}", "CodeBleu_score": 34.37124379181397}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t    debug_printInfo(\"CLOUD: Disconnect\");\n    if (MQTT_GetClientState() == MQTT_CONNECTED) {\n        MQTT_CLIENT_disconnect();\n    }\n}", "CodeBleu_score": 59.58312097566028}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printInfo(\"CLOUD: Disconnecting\");\n\n\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTT_CLIENT_disconnect();\n\t}\n}", "CodeBleu_score": 58.112463607383816}, {"code": "void CLOUD_disconnect(void){\n\t    debug_printInfo(\"CLOUD: Disconnect\");\n    if (MQTT_GetConnectionState() == CONNECTED) {\n        MQTT_CLIENT_disconnect();\n    }\n}", "CodeBleu_score": 72.12859207477119}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    // Check if the wifi credentials are passed in, if not use the default credentials\n    if(passed_wifi_creds == WIFI_CREDENTIALS_NOT_PASSED_IN)\n    {\n        // If the wifi credentials are not passed in, use the default credentials\n        // Set the SSID, authentication type, and password\n        char *ssid = WIFI_DEFAULT_SSID;\n        uint8_t auth_type = WIFI_AUTH_TYPE;\n        char *password = WIFI_DEFAULT_PASSWORD;\n\n        // Connect to the Wi-Fi access point\n        if (m2m_wifi_connect(ssid, auth_type, password) == NM_SUCCESS)\n        {\n            // If the connection is successful, return true\n            return true;\n        }\n        else\n        {\n            // If the connection fails, log an error message and return false\n            debug_printError(\\\"Failed to connect to Wi-Fi access point\\\");\n            return false;\n        }\n    }\n    else\n    {\n        // If the wifi credentials are passed in, use the passed in credentials\n        // Set the SSID, authentication type, and password\n        char *ssid = wifi_creds.ssid;\n        uint8_t auth_type = wifi_creds.auth_type;\n        char *password = wifi_creds.password;\n\n        // Connect to the Wi-Fi access point\n        if (m2m_wifi_connect(ssid, auth_type, password) == NM_SUCCESS)\n        {\n            // If the connection is successful, return true\n            return true;\n        }\n        else\n        {\n            // If the connection fails, log an error message and return false\n            debug_printError(\\\"Failed to connect to Wi-Fi access point\\\");\n            return false;\n        }\n    }\n}", "CodeBleu_score": 38.44111310663609}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}, {"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}, {"code": "async function DisplaySensors(map){\n\t    const client = generateClient();\n    const response = await client.query({\n        query: listSensors\n    });\n    console.log(response);\n    console.log(\"Retrieval of sensors\");\n    response.data.listSensors.items.forEach(sensor => {\n        const marker = CreateSensorMarker(sensor);\n        map.addLayer({\n            \"id\": \"sensor-marker-\" + sensor.sensorId,\n            \"type\": \"symbol\",\n            \"source\": {\n                \"type\": \"geojson\",\n                \"data\": {\n                    \"type\": \"FeatureCollection\",\n                    \"features\": [{\n                        \"type\": \"Feature\",\n                        \"geometry\": {\n                            \"type\": \"Point\",\n                            \"coordinates\": [sensor.location.lat, sensor.location.lon]\n                        },\n                        \"properties\": {\n                            \"marker-symbol\": marker\n                        }\n                    }]\n                }\n            },\n            \"layout\": {\n                \"icon-image\": \"sensor-image-{sensorId}\",\n                \"icon-size\": 0.4\n            }\n        });\n        map.addSource(\"sensor-marker-\" + sensor.sensorId, {\n            \"type\": \"geojson\",\n            \"data\": {\n                \"type\": \"FeatureCollection\",\n                \"features\": [{\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"Point\",\n                        \"coordinates\": [sensor.location.lat, sensor.location.lon]\n                    },\n                    \"properties\": {\n                        \"marker-symbol\": marker\n                    }\n                }]\n            }\n        });\n    });\n}", "CodeBleu_score": 42.06977210329264}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = 'red';\n  marker.style.border = '2px solid white';\n  return marker;\n}", "CodeBleu_score": 45.44388588345766}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = 'red';\n    marker.style.border = '1px solid black';\n    return marker;\n}", "CodeBleu_score": 44.5373048117686}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = 'red';\n    marker.style.border = '1px solid #fff';\n    return marker;\n}", "CodeBleu_score": 45.08736668871086}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"homeassistant.components.multi_factor.{module_name}\\\"\n    try:\n        module = await hass.async_add_executor_job(async_import_module, module_path)\n    except ImportError:\n        _LOGGER.error(\\\"Failed to import multi-factor module %s\\\", module_name)\n        raise\n\n    if not hasattr(module, \\\"MultiFactorAuthModule\\\"):\n        _LOGGER.error(\\\"Multi-factor module %s does not have a MultiFactorAuthModule class\\\", module_name)\n        raise\n\n    if hasattr(module, \\\"REQUIREMENTS\\\"):\n        if DATA_REQS not in hass.data:\n            hass.data[DATA_REQS] = set()\n\n        if module_name not in hass.data[DATA_REQS]:\n            hass.data[DATA_REQS].add(module_name)\n            await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 42.22617256370525}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"homeassistant.auth.mfa.{module_name}\\\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.exception(\\\"Failed to load mfa module %s: %s\\\", module_name, err)\n        raise\n\n    if not hasattr(module, \\\"CONFIG_SCHEMA\\\"):\n        _LOGGER.error(\\\"Module %s does not have CONFIG_SCHEMA\\\", module_name)\n        raise\n\n    if not hasattr(module, \\\"MultiFactorAuthModule\\\"):\n        _LOGGER.error(\\\"Module %s does not have MultiFactorAuthModule\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"input_schema\\\"):\n        _LOGGER.error(\\\"Module %s does not have input_schema\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_setup_flow\\\"):\n        _LOGGER.error(\\\"Module %s does not have async_setup_flow\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_setup_user\\\"):\n        _LOGGER.error(\\\"Module %s does not have async_setup_user\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_depose_user\\\"):\n        _LOGGER.error(\\\"Module %s does not have async_depose_user\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_is_user_setup\\\"):\n        _LOGGER.error(\\\"Module %s does not have async_is_user_setup\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_validate\\\"):\n        _LOGGER.error(\\\"Module %s does not have async_validate\\\", module_name", "CodeBleu_score": 31.986647703333716}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"homeassistant.components.mfa.auth_modules.{module_name}\\\"\n    try:\n        module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\\\"Failed to load mfa auth module %s: %s\\\", module_name, err)\n        raise\n\n    if not hasattr(module, \\\"CONFIG_SCHEMA\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing CONFIG_SCHEMA\\\", module_name)\n        raise\n\n    if not hasattr(module, \\\"MultiFactorAuthModule\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing MultiFactorAuthModule\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_setup_flow\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing async_setup_flow\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_setup_user\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing async_setup_user\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_depose_user\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing async_depose_user\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_is_user_setup\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing async_is_user_setup\\\", module_name)\n        raise\n\n    if not hasattr(module.MultiFactorAuthModule, \\\"async_validate\\\"):\n        _LOGGER.error(\\\"Invalid mfa auth module %s: missing async_validate\\\", module_name)\n        raise\n\n    if hasattr(module, \\\"REQUIREMENTS\\\"):\n        if", "CodeBleu_score": 32.00355942473214}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\\\"pin\\\"]\n    for entry in self._data:\n            if entry[\\\"user_id\\\"] == user_id:\n                entry[\\\"pin\\\"] = pin\n                return\n        self._data.append({'user_id': user_id, 'pin': pin})\n\n    async def async_validate_login(self, user_id: str, login_data: Any) -> bool:\n        \"\"\"The function \"async_validate_login\" validates the login data by checking if the user ID and PIN match an entry in the internal data list. If a match is found, the function returns True, indicating that the login is valid. Otherwise, it returns False.\"\"\"\n        pin = login_data[\\\"pin\\\"]\n        for entry in self._data:\n            if entry[\\\"user_id\\\"] == user_id and entry[\\\"pin\\\"] == pin:\n                return True\n        return False\n\n    async def async_delete_user(self, user_id: str) -> None:\n        \"\"\"The function \"async_delete_user\" deletes a user from the internal data list by finding and removing the entry with the matching user ID.\"\"\"\n        for entry in self._data:\n            if entry[\\\"user_id\\\"] == user_id:\n                self._data.remove(entry)\n\n    async def async_get_user_data(self, user_id: str) -> dict[str, Any]:\n        \"\"\"The function \"async_get_user_data\" returns the user data for a given user ID by finding the entry with the matching user ID in the internal data list and returning the entire entry as a dictionary.\"\"\"\n        for entry in self._data:\n            if entry[\\\"user_id\\\"] == user_id:\n                return entry\n        return None\n\n    async def async_update_user_data(self, user_id: str, data: Any) -> None:\n        \"\"\"The function \"async_update_user_data\" updates the user data for a given user ID by finding the entry with the matching user ID in the internal data list and updating the entire entry with the provided data.\"\"\"\n        for entry in self._data:\n            if entry", "CodeBleu_score": 41.344661573633154}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\\\"pin\\\"]\n    for user in self._data:\n            if user[\\\"user_id\\\"] == user_id:\n                user[\\\"pin\\\"] = pin\n                return\n\n    self._data.append({'user_id': user_id, 'pin': pin})\n\n    return\n", "CodeBleu_score": 46.394892533013746}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    data = self._data.get(user_id)\n    if data is None:\n        self._data[user_id] = setup_data\n    else:\n        data.update(setup_data)\n    return True\n\n", "CodeBleu_score": 27.05902152225424}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {}\n        self._user_settings = {\n            user_id: NotifySetting(**user_data)\n            for user_id, user_data in data.items()\n        }\n\n", "CodeBleu_score": 49.47636432749507}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {STORAGE_USERS: {}}\n        self._user_settings = {\n            user_id: NotifySetting(**user_data)\n            for user_id, user_data in data[STORAGE_USERS].items()\n        }\n\n", "CodeBleu_score": 53.4321239486103}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = {}\n        data = await self._user_store.async_load()\n        if data is None:\n            return\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = NotifySetting(**user_data)\n\n", "CodeBleu_score": 43.98239369551409}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    async with self._init_lock:\n        otp = user_input.get(INPUT_FIELD_CODE)\n        if otp is None:\n            return False\n\n        async def _verify_otp(secret: str, otp: str, count: int) -> bool:\n            \"\"\"This function is used to verify the OTP (one-time password) for a given secret and count.", "CodeBleu_score": 55.42224664143569}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    async with async_timeout.timeout(10):\n        return await self.hass.async_add_executor_job(\n            _verify_otp, notify_setting.secret, user_input[INPUT_FIELD_CODE], notify_setting.counter\n        )\n\n", "CodeBleu_score": 70.09510770285523}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    if not notify_setting.notify_service or not notify_setting.target:\n        return False\n\n    if not _verify_otp(notify_setting.secret, user_input[INPUT_FIELD_CODE], notify_setting.counter):\n        return False\n\n    async def _async_send_otp(secret: str, count: int, notify_service: str, target: str) -> None:\n        \"\"\"This function sends an OTP to the specified target using the specified notify service.\n\n        It uses the `notify` service to send the OTP.\n\n        Args:\n        - secret (str): The secret used to generate the OTP.\n        - count (int): The count of the OTP.\n        - notify_service (str): The name of the notify service to use.\n        - target (str): The target to send the OTP to.\n\n        Returns:\n        - None: This function does not return anything.\n        \"\"\"\n        await self.hass.services.async_call(\\\"notify\\\", notify_service, {\\\"message\\\": _generate_otp(secret, count)}, target=target)\n\n    await self.hass.async_add_executor_job(_async_send_otp, notify_setting.secret, notify_setting.counter, notify_setting.notify_service, notify_setting.target)\n\n    notify_setting.counter += 1\n    await self._async_save()\n\n    return True\n\n", "CodeBleu_score": 56.501814836658504}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entity_lookup.get(entity_id)\n    if not entity:\n        return None\n\n    device = perm_lookup.device_lookup.get(entity.device_id)\n    if not device:\n        return None\n\n    area_id = device.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.69904699933527}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entity.get(entity_id)\n    if not entity:\n        return None\n\n    device = perm_lookup.device.get(entity.device_id)\n    if not device:\n        return None\n\n    area_id = device.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.36696153370561}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if not entity:\n        return None\n\n    device = perm_lookup.devices.get(entity.device_id)\n    if not device:\n        return None\n\n    area_id = device.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.39876178007634}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category in policy.keys():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {}\n                for policy_ in policies:\n                    if category in policy_.keys():\n                        merged_policy[category] |= policy_[category]\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 50.05892711308791}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {\n        \"categories\": {},\n        \"default\": {},\n        \"default_categories\": {},\n    }\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, category_policy in policy[\"categories\"].items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_category: CategoryType = cast(\n                    CategoryType,\n                    {\n                        \"description\": category_policy.get(\"description\"),\n                        \"enabled\": category_policy.get(\"enabled\"),\n                        \"default_action\": category_policy.get(\"default_action\"),\n                        \"default_justification\": category_policy.get(\n                            \"default_justification\"\n                        ),\n                        \"justifications\": category_policy.get(\"justifications\"),\n                        \"actions\": category_policy.get(\"actions\"),\n                        \"params\": category_policy.get(\"params\"),\n                    },\n                )\n                for other_policy in policies:\n                    if category in other_policy[\"categories\"]:\n                        other_category_policy = other_policy[\"categories\"][category]\n                        merged_category[\"description\"] = (\n                            merged_category[\"description\"]\n                            or other_category_policy.get(\"description\")\n                        )\n                        merged_category[\"enabled\"] = merged_category[\"enabled\"] or other_category_policy.get(\n                            \"enabled\"\n                        )\n                        merged_category[\"default_action\"] = (\n                            merged_category[\"default_action\"]\n                            or other_category_policy.get(\"default_action\")\n                        )\n                        merged_category[\"default_justification\"] = (\n                            merged_category[\"default_justification\"]\n                            or other_category_policy.get(\"default_justification\")\n                        )\n                        merged_category[\"justifications\"] = (\n                            merged_category[\"justifications\"]\n                            or other_category_policy.get(\"justifications\")\n                        )\n                        merged_category[\"actions\"] = (\n                            merged_category[\"actions\"]\n                            or other_category_policy.get(\"actions\")\n                        )\n                        merged_category[\"params\"] = (\n                            merged_category[\"params\"]\n                            or other_category", "CodeBleu_score": 28.238392790231444}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category, categories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = categories\n                for other_policy in policies:\n                    if other_policy is not policy and category in other_policy:\n                        merged_policy[category].extend(other_policy[category])\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 48.47742540488566}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_REQS]:\n        return await async_import_module(provider)\n\n    try:\n        module = await async_import_module(provider)\n    except ImportError as err:\n        _LOGGER.exception(\\\"Failed to import auth provider %s: %s\\\", provider, err)\n        raise HomeAssistantError from err\n\n    if not hasattr(module, \\\"REQUIREMENTS\\\"):\n        hass.data[DATA_REQS].add(provider)\n        return module\n\n    try:\n        reqs = await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    except requirements.RequirementsNotFound as err:\n        _LOGGER.exception(\\\"Failed to import auth provider %s: %s\\\", provider, err)\n        raise HomeAssistantError from err\n\n    hass.data[DATA_REQS].add(provider)\n    return module\n\n", "CodeBleu_score": 44.864355792786064}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in DATA_REQS.get(hass, {}):\n        return await async_import_module(f\\\"homeassistant.auth.providers.{provider}\\\")\n\n    try:\n        module = await async_import_module(f\\\"homeassistant.auth.providers.{provider}\\\")\n    except ImportError as err:\n        _LOGGER.error(\\\"Error loading auth provider %s: %s\\\", provider, err)\n        raise HomeAssistantError(f\\\"Error loading auth provider {provider}\\\") from err\n\n    if not hasattr(module, \\\"REQUIRES\\\"):\n        return module\n\n    if not hass.data.get(DATA_REQS):\n        hass.data[DATA_REQS] = set()\n\n    hass.data[DATA_REQS].add(provider)\n    await requirements.async_process_requirements(hass, module.REQUIRES)\n    return module\n\n", "CodeBleu_score": 46.98787542835926}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_REQS]:\n        return await async_import_module(provider)\n\n    module = await async_import_module(provider)\n    hass.data[DATA_REQS].add(provider)\n\n    if not hasattr(module, \"REQUIRES_IPS\"):\n        return module\n\n    reqs = set(module.REQUIRES_IPS)\n    if reqs:\n        await requirements.async_process_requirements(hass, reqs)\n\n    return module\n\n", "CodeBleu_score": 28.186333905395493}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if self._data is None:\n        try:\n            self._data = await self._store.async_load()\n        except FileNotFoundError:\n            self._data = {}\n\n    if self.is_legacy:\n        for username, users in self._data.items():\n            if not username.strip().casefold() == username:\n                self.is_legacy = False\n                break\n\n        if self.is_legacy:\n            logging.warning(\\\"Legacy mode is deprecated and will be removed in 2026.7\\\")\n\n", "CodeBleu_score": 26.443341738333924}, {"code": "async def async_load(self) -> None\n\t\n    self._data = await self._store.async_load()\n\n    if self._data is None:\n        self._data = {}\n\n    # Legacy mode will allow usernames to start/end with whitespace\n    # and will compare usernames case-insensitive.\n    # Deprecated in June 2019 and will be removed in 2026.7\n    if self._data and not self.is_legacy:\n        self.is_legacy = True\n        for user in self._data.values():\n            for entry in user:\n                entry[\\\"username\\\"] = self.normalize_username(entry[\\\"username\\\"])\n\n\n", "CodeBleu_score": 26.504276067427767}, {"code": "async def async_load(self) -> None\n\t\n    self._data = await self._store.async_load()\n\n    if self._data is None:\n        self._data = {}\n        return\n\n    # Legacy mode will allow usernames to start/end with whitespace\n    # and will compare usernames case-insensitive.\n    # Deprecated in June 2019 and will be removed in 2026.7\n    self.is_legacy = True\n    for username, users in self._data.items():\n        if username != self.normalize_username(username):\n            raise RuntimeError(\\\"Legacy mode detected\\\")\n        for user in users:\n            user[CONF_USERNAME] = username\n\n\n", "CodeBleu_score": 23.50748006702602}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self._data.normalize_username(username)\n    if not any(u[\\\"username\\\"] == username for u in self._data.users):\n        bcrypt.hashpw(b\\\"\\\", bcrypt.gensalt())\n        raise InvalidAuth()\n\n    for user in self._data.users:\n        if user[\\\"username\\\"] == username:\n            if not bcrypt.checkpw(password.encode(\\\"utf-8\\\"), user[CONF_PASSWORD].encode(\\\"utf-8\\\")):\n                raise InvalidAuth()\n\n", "CodeBleu_score": 33.95206368433993}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self._data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\\\"\\\", bcrypt.gensalt()).decode()\n\n    for user in self._data.users:\n        if self._data.normalize_username(user[\\\"username\\\"]) == username:\n            if bcrypt.checkpw(password.encode(), user[\\\"password\\\"].encode()):\n                return\n\n    if bcrypt.checkpw(password.encode(), dummy_hash.encode()):\n        raise InvalidAuth\n\n    raise InvalidUser(\n        \\\"invalid_auth\\\",\n        translation_placeholders={\n            \\\"username\\\": username,\n        },\n    )\n\n", "CodeBleu_score": 34.47154627053468}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    if self.data.is_legacy:\n            username = self.data.normalize_username(username)\n\n        # Dummy hash to prevent timing attacks\n        bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n\n        for user in self.data.users:\n            if self.data.normalize_username(user[\\\"username\\\"]) == username:\n                if bcrypt.checkpw(password.encode(), user[\\\"password\\\"].encode()):\n                    return\n\n        raise InvalidAuth\n\n", "CodeBleu_score": 37.383305950452055}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 38.26156353128374}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    found = None\n\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            found = user\n\n    if found is None:\n        raise InvalidUser(translation_key=\"user_not_found\")\n\n    self.users.remove(found)\n\n", "CodeBleu_score": 53.332811907208225}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    found = None\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            found = user\n    if found is None:\n        raise InvalidUser(translation_key=\"user_not_found\")\n    self.users.remove(found)\n\n", "CodeBleu_score": 53.332811907208225}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n    except InvalidUser:\n        pass\n    await self.data.async_save()\n\n", "CodeBleu_score": 89.78249354043015}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread_timeout = timeout\n            if thread.ident is not None:\n                thread_timeout = min(\n                    thread_timeout,\n                    timeout - (time.monotonic() - thread._start_time),\n                )\n                if thread_timeout > 0:\n                    thread.join(thread_timeout)\n            if not thread.is_alive():\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    if log:\n        for thread in threads - joined:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads - joined:\n        async_raise(thread, SystemExit)\n    return joined\n\n\n", "CodeBleu_score": 47.08913449116382}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread_name = thread.name or \\\"<unnamed>\\\"\n            thread_ident = thread.ident\n            if thread_ident is None:\n                joined_threads.add(thread)\n                continue\n            thread_timeout = timeout / len(threads)\n            thread.join(thread_timeout)\n            if thread.is_alive():\n                if log:\n                    _log_thread_running_at_shutdown(thread_name, thread_ident)\n                async_raise(thread_ident, SystemExit)\n            joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 48.9474049211467}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is not None:\n                _LOGGER.debug(\\\"Joining thread %s\\\", thread.name)\n                thread.join(timeout)\n                if thread.is_alive():\n                    _LOGGER.debug(\\\"Thread %s is still alive\\\", thread.name)\n                    if log:\n                        _log_thread_running_at_shutdown(thread.name, thread.ident)\n                else:\n                    joined.add(thread)\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    for thread in threads - joined:\n        _LOGGER.debug(\\\"Interrupting thread %s\\\", thread.name)\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 48.66322204608808}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    threads = [\n        thread\n        for thread in threads\n        if thread != threading.main_thread() and not thread.daemon\n    ]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        thread.join(timeout)\n    if any(thread.is_alive() for thread in threads):\n        _LOGGER.warning(\\\"%s: Shutdown timeout exceeded\\\", threading.current_thread().name)\n\n\n\n\n", "CodeBleu_score": 34.59085490035952}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    threads = [\n        thread\n        for thread in threads\n        if thread.name != \"MainThread\" and not thread.daemon and thread.is_alive()\n    ]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            _LOGGER.warning(\n                \"Thread %s failed to shutdown in %s seconds, terminating\",\n                thread.name,\n                timeout,\n            )\n            thread.join()\n\n\n\n\n\n", "CodeBleu_score": 39.86187783939103}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = []\n    for thread in threading.enumerate():\n        if thread is not threading.main_thread() and not thread.daemon:\n            threads.append(thread)\n    for thread in threads:\n        thread.join(THREADING_SHUTDOWN_TIMEOUT / len(threads))\n        if thread.is_alive():\n            _LOGGER.warning(f'Thread {thread.name} did not shutdown in time')\n\n", "CodeBleu_score": 30.047548931112217}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(EVENT_HOMEASSISTANT_START, {\\\"remaining_setups\\\": remaining_with_setup_started})\n    self._previous_was_empty = not bool(remaining_with_setup_started)\n\n", "CodeBleu_score": 52.1997154298086}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(EVENT_HOMEASSISTANT_START, {\\\"remaining_setups\\\": remaining_with_setup_started})\n    self._previous_was_empty = not remaining_with_setup_started\n\n", "CodeBleu_score": 57.66098631754437}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(\\\"homeassistant_startup_done\\\", {\\\"remaining\\\": remaining_with_setup_started})\n        self._previous_was_empty = not bool(remaining_with_setup_started)\n\n\n\n", "CodeBleu_score": 51.80527205398284}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.check_bluetooth:\n        return\n\n    content = generate_and_validate(integrations)\n\n    if content == config.bluetooth:\n        return\n\n    config.add_error(\n        \\\"bluetooth.py is not up to date\\\",\n        \\\"Run `python -m homeassistant.scripts.bluetooth_generate_file` to fix\\\",\n        \\\"bluetooth\\\",\n    )\n\n\n\n", "CodeBleu_score": 33.492078625534205}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    from ..model import validate_config\n\n    generated = generate_and_validate(integrations)\n    validate_config(\n        config,\n        \"bluetooth\",\n        generated,\n        lambda: \"\"\"\n            The file `bluetooth.py` is not up to date.\n\n            Run `python -m homeassistant.scripts.generate_bluetooth` to fix this.\n        \"\"\",\n    )\n", "CodeBleu_score": 28.054553626860685}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_file = config.path / \\\"bluetooth.py\\\"\n    generated_content = generate_and_validate(integrations)\n\n    if bluetooth_file.is_file():\n        with bluetooth_file.open() as fp:\n            current_content = fp.read()\n\n        if current_content != generated_content:\n            config.add_error(\n                \\\"bluetooth.py is not up to date\\\",\n                fixable=\\\"Fix by running: python -m script.bluetooth\\\",\n            )\n    else:\n        bluetooth_file.write_text(generated_content)\n\n\n\n\n", "CodeBleu_score": 46.8135796647815}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.7293264155016}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 89.6193055943397}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 89.6193055943397}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\treq.SetQueryParams(map[string]string{\n\t\t\\\"supportsAllDrives\\\": \\\"true\\\",\n\t\t\\\"includeItemsFromAllDrives\\\": \\\"true\\\",\n\t\t\\\"includePermissions\\\": \\\"true\\\",\n\t\t\\\"fields\\\": \\\"*\\\"\n\t})\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres, err = req.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 63.01441438964018}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken).SetQueryParams(map[string]string{\n\t\t\\\"supportsAllDrives\\\": \\\"true\\\",\n\t})\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\terr = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres, err = req.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif res.StatusCode() != 200 {\n\t\treturn nil, fmt.Errorf(res.String())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 62.65795124104472}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken).\n\t\tSetQueryParams(map[string]string{\n\t\t\t\\\"supportsAllDrives\\\": \\\"true\\\",\n\t\t})\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\terr = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres, err = req.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 61.11951733127577}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 10\n\tchunk := make([]byte, chunkSize)\n\toffset := 0\n\tfor {\n\t\tn, err := stream.Read(chunk)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tchunk = chunk[:n]\n\t\t_, err = d.request(url, http.MethodPatch, func(req *resty.Request) {\n\t\t\treq.SetHeader(\\\"Content-Range\\\", fmt.Sprintf(\\\"bytes %d-%d/%d\\\", offset, offset+n-1, stream.Size()))\n\n\\t\\t\\treq.SetHeader(\\\"Content-Length\\\", strconv.Itoa(n))\n\\t\\t\\treq.SetBody(chunk)\n\\t\\t}, nil)\n\\t\\tif err != nil {\n\\t\\t\\treturn err\n\\t\\t}\n\\t\\toffset += n\n\\t\\tselect {\n\\t\\tcase <-ctx.Done():\n\\t\\t\\treturn ctx.Err()\n\\t\\tdefault:\n\\t\\t}\n\\t}\n\\treturn nil\n}", "CodeBleu_score": 41.18576452818837}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 1024 // 1GB\n\tchunk := make([]byte, chunkSize)\n\ttotal := 0\n\tuploaded := 0\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tn, err := stream.Read(chunk)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttotal += n\n\t\t\treq := base.RestyClient.R()\n\t\t\treq.SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\t\t\treq.SetHeader(\\\"Content-Length\\\", strconv.Itoa(n))\n\t\t\treq.SetHeader(\\\"Content-Range\\\", fmt.Sprintf(\\\"bytes %d-%d/%d\\\", uploaded, uploaded+n-1, total))\n\t\t\treq.SetBody(chunk[:n])\n\t\t\tres, err := req.Execute(\\\"PATCH\\\", url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif res.StatusCode() != 200 {\n\t\t\t\treturn fmt.Errorf(\\\"%s\\\", res.String())\n\t\t\t}\n\t\t\tuploaded += n\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.74840465994537}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \\\"mount_point is empty\\\"})\n\t}\n\n\tlogger.Info(\\\"UmountStorage\\\", zap.Any(\\\"req\\\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DeleteConfigByName(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 67.85510769480597}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \\\"mount_point is empty\\\"})\n\t}\n\n\tlogger.Info(\\\"UmountStorage\\\", zap.Any(\\\"req\\\", req))\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 67.24173452287667}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t}\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 72.67542284750427}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.95433320125602}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.33496006639984}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.33496006639984}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn common_err.NewCommonErr(common_err.ErrInvalidParam, \"name is empty\")\n\t}\n\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.NewCommonErr(common_err.ErrInvalidParam, err.Error())\n\t}\n\n\tif err := service.Notify(name, message); err != nil {\n\t\treturn common_err.NewCommonErr(common_err.ErrInternal, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.Success})\n}", "CodeBleu_score": 64.13838661677741}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\n\tmessage := make(map[string]interface{})\n\terr := ctx.Bind(&message)\n\tif err != nil {\n\t\treturn common_err.NewParameterError(err.Error())\n\t}\n\n\tservice.NotifyMessage(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.Success})\n}", "CodeBleu_score": 48.49073238273067}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.New(common_err.BadRequest, err.Error())\n\t}\n\n\tservice.SendNotify(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{\n\t\tSuccess: true,\n\t\tMessage: \"Success\",\n\t})\n}", "CodeBleu_score": 55.90219911224901}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer ws.Close()\n\n\tservice.AddWS(ws)\n\n\tgo service.SendMessage()\n\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"mt:\", mt)\n\t\tfmt.Println(\"message:\", string(message))\n\t\tfmt.Println(\"err:\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.51836252693996}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tservice.AddNotifyConn(conn)\n\tgo service.NotifySendService()\n\tfor {\n\t\tmt, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(mt)\n\t\tfmt.Println(string(message))\n\t\tfmt.Println(err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.521437894556435}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tservice.AddNotifyConn(conn)\n\tservice.StartNotifyService()\n\n\tfor {\n\t\tmt, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(message))\n\t\tif err = conn.WriteMessage(mt, message); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.25682012410371}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tsys := service.MyService.System().GetSysInfo()\n\tdisk := service.MyService.System().GetDiskInfo()\n\n\tdata := make(map[string]interface{}, 2)\n\tdata[\"model\"] = sys.Model\n\tdata[\"architecture\"] = sys.Architecture\n\tif sys.CPU != nil {\n\t\tdata[\"cpu\"] = sys.CPU\n\t} else {\n\t\tdata[\"cpu\"] = nil\n\t}\n\tdata[\"disk\"] = disk\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: data})\n}", "CodeBleu_score": 44.61538837777606}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tmodel, err := service.MyService.System().GetSystemHardwareInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: model})\n}", "CodeBleu_score": 36.89873387252856}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdisk := service.MyService.System().GetDiskInfo()\n\tsys := service.MyService.System().GetSysInfo()\n\n\tcpuInfo := service.MyService.System().GetCpuInfo()\n\tif cpuInfo == nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\n\t\t\t\"disk\": map[string]interface{}{\n\t\t\t\t\"total\": disk.Total >> 20,\n\t\t\t\t\"used\":  disk.Used >> 20,\n\t\t\t},\n\t\t\t\"system\": map[string]interface{}{\n\t\t\t\t\"os\":   sys.OS,\n\t\t\t\t\"arch\": sys.Arch,\n\t\t\t},\n\t\t}})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\n\t\t\"disk\": map[string]interface{}{\n\t\t\t\"total\": disk.Total >> 20,\n\t\t\t\"used\":  disk.Used >> 20,\n\t\t},\n\t\t\"system\": map[string]interface{}{\n\t\t\t\"os\":   sys.OS,\n\t\t\t\"arch\": sys.Arch,\n\t\t},\n\t\t\"cpu\": map[string]interface{}{\n\t\t\t\"model\": cpuInfo.ModelName,\n\t\t},\n\t}})\n}", "CodeBleu_score": 32.88610990716645}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 80.4027818389349}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.94468931855383}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.94468931855383}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings\n\tmessageStrings := make(map[string]string)\n\tfor k, v := range message {\n\t\tjsonData, err := json2.Marshal(v)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to serialize message\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tmessageStrings[k] = string(jsonData)\n\t}\n\n\t// Publish the event to the message bus\n\tresp, err := http.Post(common.GetNotifyServerURL()+\"/notify\", \"application/json\", nil)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response status code\n\tif resp.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to publish event\", zap.Int(\"status\", resp.StatusCode))\n\t\trespData, _ := io.ReadAll(resp.Body)\n\t\tlogger.Error(\"failed to publish event\", zap.String(\"response\", string(respData)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.91651127519248}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageStr, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"SendNotify\", zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := common.GetMessageBus().Publish(name, string(messageStr))\n\tif err != nil {\n\t\tlogger.Error(\"SendNotify\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"SendNotify\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 38.03249701376014}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"SendNotify\", zap.Error(err))\n\t\treturn\n\t}\n\tresp, err := common.MessageBus.Publish(context.Background(), name, string(msg))\n\tif err != nil {\n\t\tlogger.Error(\"SendNotify\", zap.Error(err))\n\t\treturn\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"SendNotify\", zap.Any(\"resp\", resp))\n\t}\n}", "CodeBleu_score": 36.35518961957144}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\\\"\\\")\n\taddress, err := config.GetMessageBusAddress(c.gateway, c.db, c.system.GetRuntimePath())\n\tif err == nil {\n\t\tclient.Server = address\n\t} else {\n\t\tclient.Server = \\\"Error: \\\" + err.Error()\n\t}\n\treturn client\n}", "CodeBleu_score": 33.54602202167196}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tmessageBusAddress, err := config.C.GetMessageBusAddress()\n\tif err != nil && len(RuntimePath) > 0 {\n\t\tpanic(err)\n\t}\n\n\tclient, err := message_bus.NewClientWithResponses(messageBusAddress)\n\tif err != nil {\n\t\tclient.SetServer(message_bus.ServerError{\n\t\t\tMessage: \"message bus is not running\",\n\t\t})\n\t} else {\n\t\tclient.SetServer(messageBusAddress)\n\t}\n\n\treturn client\n}", "CodeBleu_score": 45.27727027831201}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, err := message_bus.NewClientWithResponses(\\\"\\\", func(c *message_bus.Client) error {\n\t\taddress, err := config.C.GetMessageBusAddress(RuntimePath)\n\t\tif err != nil {\n\t\t\tc.Server = \\\"Error: \\\" + err.Error()\n\t\t\treturn err\n\t\t}\n\n\t\tc.Server = address\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn client\n}", "CodeBleu_score": 53.57198615253452}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == `` {\n\t\tip = strings.Split(request.RemoteAddr, `:`)[0]\n\t}\n\tif ip == `::1` {\n\t\tip = `127.0.0.1`\n\t}\n\tif ip == `::ffff:127.0.0.1` {\n\t\tip = `127.0.0.1`\n\t}\n\treturn ip\n}", "CodeBleu_score": 47.60549811019257}, {"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\"x-forwarded-for\")\n\tif xForwardedFor != `` {\n\t\ti := strings.Index(xForwardedFor, `,`)\n\t\tif i == -1 {\n\t\t\ti = len(xForwardedFor)\n\t\t}\n\t\tip := xForwardedFor[:i]\n\t\tip = strings.TrimSpace(ip)\n\t\tif ip != `` {\n\t\t\treturn ip\n\t\t}\n\t}\n\tip := strings.TrimSpace(request.RemoteAddr)\n\tif ip != `` {\n\t\tif ip == `::1` {\n\t\t\treturn `127.0.0.1`\n\t\t}\n\t\tif strings.HasPrefix(ip, `::ffff:`) {\n\t\t\treturn ip[7:]\n\t\t}\n\t\treturn ip\n\t}\n\treturn ``\n}", "CodeBleu_score": 36.92383094315074}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != `` {\n\t\tip = strings.Split(ip, `,`)[0]\n\t}\n\tif ip == `` {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == `::1` || ip == `::ffff:127.0.0.1` {\n\t\tip = `127.0.0.1`\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.774529666767414}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tentryPath := config.AppInfo.ModulePath + \\\"/entry.json\\\"\n\tmodulesPath := config.AppInfo.ModulePath\n\n\tentryFile, err := os.OpenFile(entryPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)\n\tif err != nil {\n\t\tlogger.Error(\\\"failed to open entry file\\\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\tentryJson := \\\"[]\\\"\n\n\tmoduleDirs, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\\\"failed to read module directory\\\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, moduleDir := range moduleDirs {\n\t\tif moduleDir.IsDir() {\n\t\t\tmodulePath := filepath.Join(modulesPath, moduleDir.Name())\n\t\t\tentryFilePath := filepath.Join(modulePath, \\\"entry.json\\\")\n\n\t\t\tentryFile, err := os.Open(entryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\\\"failed to open entry file\\\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer entryFile.Close()\n\n\t\t\tentryJsonBytes, err := io.ReadAll(entryFile)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\\\"failed to read entry file\\\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tentryJson += string(entryJsonBytes)\n\t\t}\n\t}\n\n\t_, err = entryFile.WriteString(entryJson)\n\tif err != nil {\n\t\tlogger.Error(\\\"failed to write entry file\\\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 44.15100070456251}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames := MyService.System().GetNet(true)\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 72.63683056342674}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := MyService.System().GetNet(false)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 67.23756773015243}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := MyService.System().GetNet(false)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, netInterface := range interfaces {\n\t\t\tif netInterface.Name == netName {\n\t\t\t\treturn netInterface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 65.8646245322718}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  int32_t res = TSDB_CODE_SUCCESS;\n  if (pRequest == NULL || pTscObj == NULL) {\n    return TSDB_CODE_INVALID_ARGUMENTS;\n  }\n\n  pRequest->ref++;\n  pTscObj->reqCount++;\n\n  if (pTscObj->appInfo != NULL) {\n    pTscObj->appInfo->reqCount++;\n    pTscObj->appInfo->curReqCount++;\n  }\n\n  if (tscDbg.debugLevel >= TSDB_DEBUG_LEVEL_INFO) {\n    tscDbg.log(tscDbg.logObj, TSDB_LOG_INFO, \"register request %p, tscObj %p\", pRequest, pTscObj);\n  }\n\n  return res;\n}", "CodeBleu_score": 38.8853707101396}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest == NULL || exceptDb == NULL) {\n    return false;\n  }\n\n  char *primaryDb = pRequest->pDb;\n  if (primaryDb == NULL) {\n    return true;\n  }\n\n  if (strcmp(primaryDb, exceptDb) != 0) {\n    if (pRequest->dbList != NULL) {\n      for (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n        char *db = taosArrayGet(pRequest->dbList, i);\n        if (db != NULL) {\n          char *dot = strchr(db, '.');\n          if (dot != NULL) {\n            db = dot + 1;\n          }\n          if (strcmp(db, exceptDb) == 0) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 74.38645377474658}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDb != NULL) {\n    if (strcmp(pRequest->pDb, exceptDb) != 0) {\n      return false;\n    }\n  } else if (pRequest->dbList != NULL) {\n    for (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n      char* db = taosArrayGet(pRequest->dbList, i);\n      char* dot = strchr(db, '.');\n      if (dot != NULL) {\n        db = dot + 1;\n      }\n      if (strcmp(db, exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 81.29496918283301}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDb != NULL) {\n    if (strcmp(pRequest->pDb, exceptDb) == 0) {\n      return false;\n    }\n  }\n\n  if (pRequest->dbList != NULL) {\n    for (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n      char *db = taosArrayGet(pRequest->dbList, i);\n      char *dot = strchr(db, '.');\n      if (dot != NULL) {\n        db = dot + 1;\n      }\n      if (strcmp(db, exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 84.1480392498984}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == TAOS_RC_BAD_SERVER_IP || code == TAOS_RC_BAD_SERVER_PORT || code == TAOS_RC_BAD_SERVER_VERSION) {\n    return true;\n  }\n\n  if (msgType != TMSG_TYPE_RESPONSE && msgType != TMSG_TYPE_RESPONSE_DATA && msgType != TMSG_TYPE_RESPONSE_DATA_LAST && msgType != TMSG_TYPE_RESPONSE_DATA_PARTIAL) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 41.48320981268625}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == TSDB_CODE_REDIRECT) {\n    if (msgType == TMSG_TYPE_RESPONSE_RPC_REQ || msgType == TMSG_TYPE_RESPONSE_RPC_REQ_FAST) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 39.299227997721815}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n\n    SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      stopRequest(pRequest);\n      releaseRequest(*rid);\n    }\n\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 96.48466567333622}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n\n    SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      stopQuery(pRequest);\n      releaseRequest(*rid);\n    }\n\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 96.65412294387427}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n\n    SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      stopQuery(pRequest);\n      releaseRequest(*rid);\n    }\n\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 96.65412294387427}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (1 != atomic_val_compare_exchange_32(&clientStop, 1, 0)) {\n    tscError(\"crashReport thread is already stopped\");\n    return;\n  }\n\n  while (clientStop) {\n    taosMsleep(200);\n  }\n}", "CodeBleu_score": 64.55527340454746}, {"code": "void tscStopCrashReport(){\n\t  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (atomic_val_compare_exchange_32(&clientStop, 0, 1) != 0) {\n    tscError(\"crash report thread is already stopped\");\n    return;\n  }\n\n  while (clientStop) {\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 69.92898761251803}, {"code": "void tscStopCrashReport(){\n\t  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (atomic_val_compare_exchange_32(&clientStop, 0, 1) != 0) {\n    tscError(\"crashReport thread is already stopped\");\n    return;\n  }\n\n  while (atomic_val_compare_exchange_32(&clientStop, 1, 0) != 0) {\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 77.28823701144678}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t code = 0;\n\n  SViewHbRsp hbRsp = {0};\n  if (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\n    terrno = TSDB_CODE_INVALID_MSG;\n    return -1;\n  }\n\n  int32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n  for (int32_t i = 0; i < numOfMeta; ++i) {\n    SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n    if (rsp->numOfColumns < 0) {\n      tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n    } else {\n      tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      catalogUpdateViewMeta(pCatalog, rsp);\n    }\n  }\n\n  taosArrayDestroy(hbRsp.pMetaRsp);\n  hbRsp.pMetaRsp = NULL;\n\n  tFreeSViewHbRsp(&hbRsp);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 80.66739777521386}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t code = 0;\n\n  SViewHbRsp hbRsp = {0};\n  if (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\n    terrno = TSDB_CODE_INVALID_MSG;\n    return -1;\n  }\n\n  int32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n  for (int32_t i = 0; i < numOfMeta; ++i) {\n    SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n    if (rsp->numOfColumns < 0) {\n      tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n    } else {\n      tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      if (rsp->pSchemas[0].colId != PRIMARYKEY_TIMESTAMP_COL_ID) {\n        tscError(\"invalid colId[%d] for the first column in view meta rsp msg\", rsp->pSchemas[0].colId);\n        tFreeSViewHbRsp(&hbRsp);\n        return TSDB_CODE_TSC_INVALID_VALUE;\n      }\n\n      catalogAsyncUpdateViewMeta(pCatalog, rsp);\n    }\n  }\n\n  taosArrayDestroy(hbRsp.pMetaRsp);\n  hbRsp.pMetaRsp = NULL;\n\n  tFreeSViewHbRsp(&hbRsp);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 79.16217120607094}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t code = 0;\n\n  SDynViewHbRsp hbRsp = {0};\n  if (tDeserializeSDynViewHbRsp(value, valueLen, &hbRsp) != 0) {\n    terrno = TSDB_CODE_INVALID_MSG;\n    return -1;\n  }\n\n  int32_t numOfViews = taosArrayGetSize(hbRsp.pViewMetaRsp);\n  for (int32_t i = 0; i < numOfViews; ++i) {\n    SViewMetaRsp *rsp = taosArrayGet(hbRsp.pViewMetaRsp, i);\n\n    if (rsp->numOfColumns < 0) {\n      tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n    } else {\n      tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      if (rsp->pSchemas[0].colId != PRIMARYKEY_TIMESTAMP_COL_ID) {\n        tscError(\"invalid colId[%d] for the first column in view meta rsp msg\", rsp->pSchemas[0].colId);\n        tFreeSDynViewHbRsp(&hbRsp);\n        return TSDB_CODE_TSC_INVALID_VALUE;\n      }\n\n      catalogAsyncUpdateViewMeta(pCatalog, rsp);\n    }\n  }\n\n  taosArrayDestroy(hbRsp.pViewMetaRsp);\n  hbRsp.pViewMetaRsp = NULL;\n\n  tFreeSDynViewHbRsp(&hbRsp);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 75.49089103142283}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t  //  (void)callbackData;\n  return S3StatusOK;\n}", "CodeBleu_score": 34.81881053235444}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t  TS3GetData *data = (TS3GetData *)callbackData;\n\n  if (properties->contentLength > 0) {\n    data->content_length = properties->contentLength;\n  } else {\n    data->content_length = 0;\n  }\n\n  return S3StatusOK;\n}", "CodeBleu_score": 79.26125362221364}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t  TS3SizeCBD *cbd = (TS3SizeCBD *)callbackData;\n\n  if (properties->contentLength > 0) {\n    cbd->content_length = properties->contentLength;\n  } else {\n    cbd->content_length = 0;\n  }\n\n  return S3StatusOK;\n}", "CodeBleu_score": 90.60073958996107}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  int32_t code = taosDirCreate(tsCheckpointBackupDir, 0755);\n  if (code != 0) {\n    uError(\"[rsync] create dir %s error,%s\", tsCheckpointBackupDir, strerror(errno));\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsyncd.conf\", tsCheckpointBackupDir);\n\n  code = generateConfigFile(confDir);\n  if (code != 0) {\n    uError(\"[rsync] generate config file error\");\n    return;\n  }\n\n  char command[PATH_MAX * 3] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 3, \"start \\\"rsync\\\" rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n#else\n  snprintf(command, PATH_MAX * 3, \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n#endif\n\n  code = execCommand(command);\n  if (code != 0) {\n    uError(\"[rsync] start rsync server failed,%s\", strerror(errno));\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 64.49514598894882}, {"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] mkdir %s error, %s\", tsCheckpointBackupDir, taosGetLastError());\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%srsync.conf\", tsCheckpointBackupDir);\n\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate config file error\");\n    return;\n  }\n\n  char command[PATH_MAX * 3] = {0};\n  snprintf(command, sizeof(command), \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n  int32_t code = execCommand(command);\n\n  if (code == 0) {\n    uDebug(\"[rsync] start rsync server successful\");\n  } else {\n    uError(\"[rsync] start rsync server failed, errno:%d, msg:%s\", errno, strerror(errno));\n  }\n}", "CodeBleu_score": 52.68508828311488}, {"code": "void startRsync(){\n\t  // create checkpoint backup dir\n  if (taosCreateDir(tsCheckpointBackupDir, 0755) != 0) {\n    uError(\"[rsync] create checkpoint backup dir failed, dir:%s,errno:%d,msg:%s\", tsCheckpointBackupDir, errno, strerror(errno));\n    return;\n  }\n\n  // delete empty dir\n  removeEmptyDir();\n\n  // generate conf file\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s%s\", tsCheckpointBackupDir, \"rsyncd.conf\");\n  if (generateConfigFile(confDir) != 0) {\n    return;\n  }\n\n  // start rsync\n  char command[PATH_MAX * 3] = {0};\n  snprintf(command, PATH_MAX * 3, \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n  int32_t code = execCommand(command);\n  if (code != 0) {\n    uError(\"[rsync] start rsync server failed, errno:%d,msg:%s\", errno, strerror(errno));\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 64.8052005798116}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n    }\n}", "CodeBleu_score": 70.69613928222115}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n    }\n}", "CodeBleu_score": 70.69613928222115}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n            throw new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n        }\n        dispatcher.getExecutor().shutdownNow();\n    }", "CodeBleu_score": 56.52691362685128}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = parentChildMap.get(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    TbActorMailbox mailbox = actors.get(child);\n                    if (mailbox != null) {\n                        if (highPriority) {\n                            mailbox.tellWithHighPriority(msg);\n                        } else {\n                            mailbox.tell(msg);\n                        }\n                    } else {\n                        log.warn(\\\"Actor with id [{}] is not registered!\\\", child);\n                    }\n                }\n            }\n        }\n    }", "CodeBleu_score": 48.025012026929915}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = parentChildMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                TbActorMailbox childMailbox = actors.get(child);\n                if (childMailbox != null) {\n                    if (highPriority) {\n                        childMailbox.tellWithHighPriority(msg);\n                    } else {\n                        childMailbox.tell(msg);\n                    }\n                } else {\n                    log.warn(\\\"Child actor with id [{}] is not registered!\\\", child);\n                }\n            });\n        } else {\n            log.warn(\\\"Parent actor with id [{}] has no children!\\\", parent);\n        }\n    }", "CodeBleu_score": 50.53094694218295}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t     Set<TbActorId> children = parentChildMap.get(parent);\n     if (children != null) {\n         children.stream().filter(childFilter).forEach(child -> {\n             TbActorMailbox childMailbox = actors.get(child);\n             if (childMailbox != null) {\n                 if (highPriority) {\n                     childMailbox.tellWithHighPriority(msg);\n                 } else {\n                     childMailbox.tell(msg);\n                 }\n             } else {\n                 log.warn(\\\"Child Actor with id [{}] is not registered!\\\", child);\n             }\n         });\n     } else {\n         log.warn(\\\"Parent Actor with id [{}] has no children!\\\", parent);\n     }\n }", "CodeBleu_score": 51.395751809242874}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    } else if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n        if (isReady()) {\n            tryInit(1);\n        }\n    } else {\n        msg.notifyActorStopped(stopReason);\n    }\n}", "CodeBleu_score": 48.18554406896976}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n        log.debug(\\\"[{}] Actor is being destroyed, but message is a high-priority RULE_NODE_UPDATED_MSG, going to retry init\\\", selfId);\n        tryInit(1);\n    } else {\n        log.debug(\\\"[{}] Actor is being destroyed, notifying message that actor has stopped\\\", selfId);\n        msg.actorStopped(this);\n    }\n}", "CodeBleu_score": 55.66117471028197}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n        tryInit(1);\n    } else {\n        msg.setActorStopped();\n    }\n}", "CodeBleu_score": 41.92740252089197}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.UNKNOWN;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            while (!normalPriorityMsgs.isEmpty()) {\n                TbActorMsg msg = normalPriorityMsgs.poll();\n                msg.onTbActorStopped(stopReason);\n            }\n            while (!highPriorityMsgs.isEmpty()) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                msg.onTbActorStopped(stopReason);\n            }\n        } catch (Exception e) {\n            log.warn(\\\"[{}] Failed to destroy actor\\\", selfId, e);\n        }\n    });\n}", "CodeBleu_score": 57.771553108117935}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.UNKNOWN;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            log.debug(\"[{}] Going to destroy actor\", selfId);\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            for (TbActorMsg msg : highPriorityMsgs) {\n                msg.onTbActorStopped(stopReason);\n            }\n            for (TbActorMsg msg : normalPriorityMsgs) {\n                msg.onTbActorStopped(stopReason);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 66.81664537782298}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.UNKNOWN;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        ready.set(NOT_READY);\n        try {\n            actor.destroy(stopReason, cause);\n        } catch (Throwable t) {\n            log.warn(\\\"[{}] Failed to destroy actor, stop reason: {}, cause: {}\\\", selfId, stopReason, cause, t);\n        }\n        notifyQueuedMessages(stopReason);\n    });\n}", "CodeBleu_score": 65.48146117434696}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n            return true;\n        }\n        try {\n            TenantProfile tenantProfile = tenantProfileProvider.findTenantProfileByTenantId(tenantId);\n            if (tenantProfile != null) {\n                TbRateLimits rateLimits = tenantProfile.getRateLimits();\n                if (rateLimits != null) {\n                    RateLimitKey key = new RateLimitKey(api, tenantId, level);\n                    TbRateLimits rateLimitsForKey = rateLimits.get(key);\n                    if (rateLimitsForKey != null) {\n                        long now = System.currentTimeMillis();\n                        long lastRequestTime = rateLimitsForKey.getLastRequestTime();\n                        long timeSinceLastRequest = now - lastRequestTime;\n                        if (timeSinceLastRequest > rateLimitsForKey.getTimePeriod()) {\n                            rateLimitsForKey.setLastRequestTime(now);\n                            rateLimits.put(key, rateLimitsForKey);\n                            return true;\n                        }\n                        return false;\n                    }\n                }\n            }\n        } catch (TenantProfileNotFoundException e) {\n            if (ignoreTenantNotFound) {\n                return true;\n            }\n            throw e;\n        }\n        return true;\n    }", "CodeBleu_score": 44.328140556934265}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isSystemTenant()) {\n            return true;\n        }\n\n        TenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId, ignoreTenantNotFound);\n        if (tenantProfile == null) {\n            if (ignoreTenantNotFound) {\n                return true;\n            } else {\n                throw new TenantProfileNotFoundException(tenantId);\n            }\n        }\n\n        TbRateLimits rateLimits = tenantProfile.getRateLimits();\n        if (rateLimits != null) {\n            RateLimitKey rateLimitKey = new RateLimitKey(api, tenantId, level);\n            TbRateLimits rateLimit = rateLimits.getRateLimit(rateLimitKey);\n            if (rateLimit != null) {\n                long currentTime = System.currentTimeMillis();\n                if (rateLimit.getLimit() > 0) {\n                    long lastTime = rateLimits.getLastTime(rateLimitKey);\n                    if (currentTime - lastTime < rateLimit.getInterval()) {\n                        if (rateLimit.getLimit() <= rateLimits.getCount(rateLimitKey)) {\n                            processRateLimitNotification(tenantId, rateLimitKey, rateLimit);\n                            return false;\n                        }\n                    }\n                }\n                rateLimits.setLastTime(rateLimitKey, currentTime);\n                rateLimits.incrementCount(rateLimitKey);\n            }\n        }\n\n        return true;\n    }", "CodeBleu_score": 52.77988300857002}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n            return true;\n        }\n\n        TenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId, ignoreTenantNotFound);\n        if (tenantProfile == null) {\n            if (ignoreTenantNotFound) {\n                return true;\n            } else {\n                throw new TenantProfileNotFoundException(tenantId);\n            }\n        }\n\n        TbRateLimits rateLimits = tenantProfile.getRateLimits();\n        if (rateLimits == null) {\n            return true;\n        }\n\n        RateLimitKey key = new RateLimitKey(api, tenantId, level);\n        TbRateLimits rateLimitsCached = rateLimits.get(key);\n\n        if (rateLimitsCached == null) {\n            rateLimits.put(key, rateLimitsCached = new TbRateLimits(api, tenantId, level));\n        }\n\n        if (rateLimitsCached.isRateLimitExceeded()) {\n            notificationRuleProcessor.processRateLimitNotification(tenantId, rateLimitsCached);\n            return false;\n        }\n\n        rateLimitsCached.increment();\n        return true;\n    }", "CodeBleu_score": 55.506201249404505}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n        dtlsSessionsMap.entrySet().removeIf(entry -> entry.getValue().getLastActivityTime() < expirationTime);\n        log.trace(\\\"DTLS sessions evicted from in-memory store: [{}]\\\", dtlsSessionsMap.size());\n    }", "CodeBleu_score": 57.91612160107413}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n        dtlsSessionsMap.entrySet().removeIf(entry -> entry.getValue().getLastActivityTime() < expirationTime);\n    }", "CodeBleu_score": 42.49148763801792}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n        for (ConcurrentMap.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\n            if (entry.getValue().getLastActivityTime() < expirationTime) {\n                log.trace(\\\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\\\", entry.getKey(), entry.getValue().getLastActivityTime());\n                dtlsSessionsMap.remove(entry.getKey());\n            }\n        }\n    }", "CodeBleu_score": 55.37379823412998}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().map(entry -> {\n            List<TsKvEntry> tsEntries = new ArrayList<>();\n            entry.getValue().forEach(ts -> {\n                KvEntry entry1 = parseValue(entry.getKey(), ts.get(VALUE));\n                tsEntries.add(new BasicTsKvEntry(entry1, ts.get(TS).asLong()));\n            });\n            return tsEntries;\n        }).flatMap(List::stream).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 59.073790152931096}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().map(entry -> {\n            List<KvEntry> values = entry.getValue().stream().map(value -> parseValue(entry.getKey(), value)).collect(Collectors.toList());\n            return new BasicTsKvEntry(entry.getKey(), values);\n        }).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 53.33297355843314}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().map(entry -> {\n                List<TsKvEntry> result = new ArrayList<>();\n                for (JsonNode value : entry.getValue()) {\n                    KvEntry kvEntry = parseValue(entry.getKey(), value);\n                    result.add(new BasicTsKvEntry(kvEntry, value.get(TS).asLong()));\n                }\n                return result;\n            }).flatMap(List::stream).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 57.10779273109694}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\\\"refreshToken\\\", refreshToken);\n    ResponseEntity<JwtPair> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/token\\\", request, JwtPair.class);\n    if (response.getStatusCode() == HttpStatus.OK) {\n            JwtPair jwtPair = response.getBody();\n            mainToken = jwtPair.getAccessToken();\n            refreshToken = jwtPair.getRefreshToken();\n            mainTokenExpTs = System.currentTimeMillis() + jwtPair.getAccessTokenTtl() * 1000;\n            refreshTokenExpTs = System.currentTimeMillis() + jwtPair.getRefreshTokenTtl() * 1000;\n        }\n    }", "CodeBleu_score": 29.1215311457907}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\\\"refreshToken\\\", refreshToken);\n    ResponseEntity<TokenInfo> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/refresh\\\", request, TokenInfo.class);\n    TokenInfo tokenInfo = response.getBody();\n    mainToken = tokenInfo.getToken();\n    refreshToken = tokenInfo.getRefreshToken();\n    mainTokenExpTs = System.currentTimeMillis() + tokenInfo.getExpiresIn() * 1000;\n    refreshTokenExpTs = mainTokenExpTs + tokenInfo.getRefreshExpiresIn() * 1000;\n    clientServerTimeDiff = tokenInfo.getClientServerTimeDiff();\n}", "CodeBleu_score": 30.713535383366608}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\\\"refreshToken\\\", refreshToken);\n    ResponseEntity<JwtPair> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/refresh\\\", request, JwtPair.class);\n    if (response.getStatusCode() != HttpStatus.OK) {\n            throw new ThingsboardException(\\\"Failed to refresh token\\\", response.getStatusCode());\n        }\n        JwtPair jwtPair = response.getBody();\n        mainToken = jwtPair.getJwtToken();\n        refreshToken = jwtPair.getRefreshToken();\n        mainTokenExpTs = System.currentTimeMillis() + TimeUnit.MILLISECONDS.toMillis(jwtPair.getExpiresIn());\n        refreshTokenExpTs = mainTokenExpTs + TimeUnit.MILLISECONDS.toMillis(jwtPair.getRefreshExpiresIn());\n        clientServerTimeDiff = jwtPair.getClientServerTimeDiff();\n    }", "CodeBleu_score": 26.904063098566734}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        long ts = System.currentTimeMillis();\n        ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo.getBody());\n    }", "CodeBleu_score": 86.223724148766}, {"code": " private void doLogin(){\n\t        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        long ts = System.currentTimeMillis();\n        ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo.getBody());\n    }", "CodeBleu_score": 86.223724148766}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo.getBody());\n    }", "CodeBleu_score": 98.07301814223813}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 94.09553786507534}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 94.09553786507534}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 94.09553786507534}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t", "CodeBleu_score": 6.094910559018862}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t", "CodeBleu_score": 6.094910559018862}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t", "CodeBleu_score": 6.094910559018862}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    this.each(function(device) {\n      this.brightness(device, val);\n    });\n  } else {\n    this.send(addr, this.OP.SET_BRIGHTNESS || LedControl.OP.SET_BRIGHTNESS, Math.round(val / 100 * 15));\n  }\n  return this;\n}", "CodeBleu_score": 68.00737923107636}, {"code": "brightness(addr, val){\n\t    if (typeof addr === \"undefined\") {\n        this.each(function(device) {\n            this.brightness(device, val);\n        });\n    } else {\n        if (typeof val === \"undefined\") {\n            val = 15;\n        } else {\n            val = Math.round(val / 100 * 15);\n        }\n        this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, val);\n    }\n    return this;\n}", "CodeBleu_score": 65.78855909011597}, {"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    this.each(function(device) {\n      this.brightness(device, val);\n    });\n  } else {\n    this.send(addr, this.OP.BRIGHTNESS, Math.round(val / 100 * 15));\n  }\n  return this;\n}", "CodeBleu_score": 63.87580238837936}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t  const obj = Object.create(LedControl.prototype);\n  obj.address = addr;\n  Object.keys(LedControl.prototype).forEach(function (key) {\n    if (key !== \\\"constructor\\\") {\n      obj[key] = obj[key].bind(obj, addr);\n    }\n  });\n  return obj;\n}", "CodeBleu_score": 32.834581281575616}, {"code": "device(addr){\n\t  const obj = Object.create(LedControl.prototype);\n  Object.keys(LedControl.prototype).forEach(function(key) {\n    obj[key] = function() {\n      return LedControl.prototype[key].apply(this, [addr].concat(Array.from(arguments)));\n    };\n  });\n  return obj;\n}", "CodeBleu_score": 29.564804843433095}, {"code": "device(addr){\n\t    let obj = Object.create(LedControl.prototype);\n    let keys = Object.getOwnPropertyNames(LedControl.prototype);\n    keys.forEach(function (key) {\n        if (typeof this[key] === 'function') {\n            obj[key] = this[key].bind(this, addr);\n        }\n    }, this);\n    return obj;\n}", "CodeBleu_score": 44.94645488499642}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = function (duration, callback = noop) {\n            const promises = [];\n            const length = this.length;\n            const { emitter } = this;\n\n            for (let i = 0; i < length; i++) {\n                promises.push(this[i][method]());\n            }\n\n            Promise.all(promises).then(() => {\n                callback.call(this, this);\n            });\n\n            emitter.once(`${method}Complete`, () => {\n                emitter.removeAllListeners(`${method}Complete`);\n                emitter.removeAllListeners(`${method}Error`);\n            });\n\n            emitter.once(`${method}Error`, () => {\n                emitter.removeAllListeners(`${method}Complete`);\n                emitter.removeAllListeners(`${method}Error`);\n            });\n\n            return this;\n        };\n    });\n}", "CodeBleu_score": 43.85333354005495}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  return methods.reduce((accum, method) => {\n    accum[method] = function(duration = 1000, callback = noop) {\n      const promises = [];\n      const length = this.length;\n\n      for (let i = 0; i < length; i++) {\n        promises.push(this[i][method].call(this[i], duration, callback));\n      }\n\n      return Promise.all(promises).then(() => callback.call(this, this));\n    };\n\n    return accum;\n  }, target);\n}", "CodeBleu_score": 37.730089756440975}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  return methods.reduce((accum, method) => {\n    accum[method] = function(duration = 1000, callback = noop) {\n      const length = this.length;\n      const promises = [];\n\n      for (let i = 0; i < length; i++) {\n        const promise = this[i][method]();\n        promises.push(promise);\n      }\n\n      Promise.all(promises).then(() => {\n        callback.call(this);\n      }).catch(err => {\n        throw err;\n      });\n\n      return this;\n    };\n\n    return accum;\n  }, target);\n}", "CodeBleu_score": 42.98519443299661}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = state.input;\n\n    this.io.serialRead(state.portId, (err, data) => {\n      if (err) {\n        return;\n      }\n\n      // Append the data to the input string\n      input += String.fromCharCode.apply(null, data);\n      // Split the input string into sentences based on the \\\"\\\\r\\\n\\\" delimiter\n      const sentences = input.split(\\\"\\\\r\\\n\\\");\n      // Remove the incomplete sentence from the end of the array\n      input = sentences.pop();\n      // Process all complete sentences\n      sentences.forEach(sentence => {\n        parseNmeaSentence(sentence);\n      });\n    });\n  }", "CodeBleu_score": 47.49148827064945}, {"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \\\"\\\";\n\n    // Start reading data from the serial port\n    this.io.serialRead(state.portId, (data) => {\n\n      // Append the received data to the input string\n      input += String.fromCharCode.apply(null, data);\n\n      // Split the input string into sentences based on the \"\\r\n\" delimiter\n      const sentences = input.split(/\\r\n/);\n\n      // Process all complete sentences\n      for (let i = 0; i < sentences.length - 1; i++) {\n        this.parseNmeaSentence(sentences[i]);\n      }\n\n      // If there is an incomplete sentence at the end of the input string,\n      // retain it for the next read\n      if (sentences.length > 0) {\n        input = sentences[sentences.length - 1];\n      } else {\n        input = \\\"\\\";\n      }\n    });\n  }", "CodeBleu_score": 66.57383866649928}, {"code": "listen(){\n\t\n    const state = priv.get(this);\n\n    let input = '';\n\n    // Read loop on the specified serial port\n    this.io.serialRead(state.portId, (data) => {\n\n      // Append the received data to the input string\n      input += String.fromCharCode.apply(null, data);\n\n      // Split the input string into sentences based on the \"\\r\n\" delimiter\n      const sentences = input.split('\\r\n');\n\n      // Process all complete sentences\n      for (let i = 0; i < sentences.length - 1; ++i) {\n        this.parseNmeaSentence(sentences[i]);\n      }\n\n      // Retain any incomplete sentence for the next read\n      input = sentences[sentences.length - 1];\n    });\n\n  }", "CodeBleu_score": 69.07102293487229}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0;\n\tuint16_t buffer_size = 0;\n\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_mask & (1 << i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tbuffer_size = channels * sequence->buffer_length;\n\n\tif (buffer_size > data->ctx.buffer_size) {\n\t\tLOG_ERR(\"insufficient buffer size: %d < %d\", data->ctx.buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.879177461945325}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint channels = 0;\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_mask & (1 << i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < channels * sizeof(uint16_t)) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.30932151804891}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint channels = adc_ad559x_get_channels(dev);\n\tsize_t buffer_size = channels * sizeof(uint16_t);\n\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size for %d channels\", channels);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = (uint16_t *)sequence->buffer;\n\tdata->repeat_buffer = (uint16_t *)sequence->buffer + buffer_size;\n\n\treturn 0;\n}", "CodeBleu_score": 53.82412257199549}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct adc_ad559x_config *config = dev->config;\n    struct adc_ad559x_data *data = dev->data;\n    uint8_t adc_conf;\n    uint8_t res_ind;\n    uint8_t res_chan;\n    uint16_t res_val;\n    int ret;\n\n    /* Check if the resolution of the ADC sequence matches the expected resolution */\n    if (sequence->resolution != AD559X_ADC_RESOLUTION) {\n        LOG_ERR(\"invalid resolution %d\", sequence->resolution);\n        return -EINVAL;\n    }\n\n    /* Check if the specified channels are valid */\n    if (sequence->channels & ~data->channels) {\n        LOG_ERR(\"invalid channel(s) 0x%08x\", sequence->channels);\n        return -EINVAL;\n    }\n\n    /* Validate the buffer size for the ADC read */\n    ret = adc_ad559x_validate_buffer_size(dev, sequence);\n    if (ret < 0) {\n        LOG_ERR(\"insufficient buffer size\");\n        return ret;\n    }\n\n    /* Set the buffer and start the ADC read context */\n    data->buffer = (uint16_t *)sequence->buffer;\n    adc_context_start(&data->ctx, sequence);\n\n    /* Wait for the read operation to complete */\n    while (!adc_context_is_complete(&data->ctx)) {\n        k_sleep(K_MSEC(10));\n    }\n\n    return adc_context_get_result(&data->ctx);\n}", "CodeBleu_score": 77.40304522287104}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret = 0;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~data->channels) {\n\t\tLOG_ERR(\"invalid channel(s) 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start(&data->ctx);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\treturn adc_context_wait(&data->ctx);\n}", "CodeBleu_score": 75.71824251436206}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t resolution, channels;\n\tint ret;\n\n\tresolution = POPCOUNT(sequence->resolution);\n\tif (resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > AD559X_PIN_MAX) {\n\t\tLOG_ERR(\"invalid channels %d\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"buffer size is too small\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->buffer + sequence->buffer_offset;\n\n\tret = adc_context_start(&data->ctx);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"failed to start context\");\n\t\treturn ret;\n\t}\n\n\tret = k_sem_take(&data->sem, K_FOREVER);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"failed to wait for completion\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.06983324910605}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tdata->channels = ctx->sequence->channels;\n\tdata->repeat_buffer = data->buffer;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 93.77191536220195}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_ad559x_data *data = container_of(ctx, struct adc_ad559x_data, ctx);\n\n\tdata->channels = ctx->sequence->channels;\n\tdata->repeat_buffer = data->buffer;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 87.4211538785467}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tdata->channels = ctx->seq.channels;\n\tdata->repeat_buffer = ctx->seq.buffer;\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 76.55045662998204}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 78.04269422509998}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 78.04269422509998}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t  struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n  if (repeat_sampling) {\n    ctx->buffer = data->repeat_buffer;\n  }\n}", "CodeBleu_score": 78.97289669116304}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t", "CodeBleu_score": 2.300914627583181}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint16_t *buffer = data->buffer;\n\tuint8_t channels = data->channels;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint16_t val;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\twhile (channels) {\n\t\t\tuint8_t channel = find_lsb_set(channels);\n\t\t\tuint8_t channel_index = channel - 1;\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tadc_context_complete(ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbuffer[channel_index] = val;\n\t\t\tchannels &= ~BIT(channel);\n\t\t}\n\n\t\tadc_context_update_buffer_pointer(ctx, true);\n\t\tadc_context_complete(ctx);\n\t}\n}", "CodeBleu_score": 52.749153883428676}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\tuint16_t *buffer = data->buffer;\n\tuint16_t *repeat_buffer = data->repeat_buffer;\n\tuint8_t channels = data->channels;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, buffer);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tadc_context_complete(&data->ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbuffer++;\n\t\t\t}\n\t\t}\n\n\t\tif (data->ctx.sequence.options & ADC_OPTION_CONTINUOUS) {\n\t\t\tadc_context_update_buffer_pointer(&data->ctx, true);\n\t\t\tdata->buffer = repeat_buffer;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.27502438990038}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\tk_sleep(data->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &data->ctx.reg_val);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\tif ((data->ctx.reg_val & ADS1112_CONFIG_MASK_READY) == 0) {\n\t\twhile ((data->ctx.reg_val & ADS1112_CONFIG_MASK_READY) == 0) {\n\t\t\tk_sleep(K_USEC(100));\n\t\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &data->ctx.reg_val);\n\t\t\tif (rc < 0) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.83106254631062}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    int rc = 0;\n\n    k_sleep(data->ready_time);\n\n    uint8_t reg = 0;\n    rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n    if (rc < 0) {\n        return rc;\n    }\n\n    if (reg & ADS1112_CONFIG_MASK_READY) {\n        return 0;\n    }\n\n    while (!(reg & ADS1112_CONFIG_MASK_READY)) {\n        k_sleep(K_USEC(100));\n        rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n        if (rc < 0) {\n            return rc;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 76.62482244117153}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc = 0;\n\tuint8_t reg;\n\n\tk_sleep(data->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\tif ((reg & ADS1112_CONFIG_MASK_READY) == 0) {\n\t\twhile ((reg & ADS1112_CONFIG_MASK_READY) == 0) {\n\t\t\tk_sleep(K_USEC(100));\n\t\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\t\t\tif (rc < 0) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.95360129005837}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.778215576071295}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t required_buffer_size = sequence->options & ADC_OPT_EXT_SAMPLING_MASK;\n\n\tif (required_buffer_size < sequence->length) {\n\t\tLOG_ERR(\"Buffer size is too small (%d) for %d samplings\",\n\t\t\trequired_buffer_size, sequence->length);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.85427340884186}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int buffer_size = sequence->buffer_length;\n  int required_size = sequence->options.extra_samplings + 1;\n\n  if (buffer_size < required_size) {\n    LOG_ERR(\"Buffer size is too small. Required size: %d, buffer size: %d\", required_size, buffer_size);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 41.10498472689838}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_sampling(&data->ctx);\n\n\tif (wait) {\n\t\treturn ads1112_adc_read(dev);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.97207189715603}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tadc_context_start_sampling(&data->ctx);\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.016291284926865}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_sampling(&data->ctx);\n\n\tif (wait) {\n\t\trc = adc_context_wait_done(&data->ctx);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 71.85553647551865}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36641186127734}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36641186127734}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36641186127734}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_config *config = dev->config;\n    struct mpxxdtyy_data *const data = dev->data;\n    int ret;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state == DMIC_STATE_CONFIGURED) {\n                ret = i2s_cmd(config->comm_master, I2S_CMD_START);\n                if (ret == 0) {\n                    data->state = DMIC_STATE_ACTIVE;\n                } else {\n                    LOG_ERR(\"I2S_CMD_START failed (%d)\", ret);\n                }\n            } else {\n                LOG_ERR(\"Unexpected state %d\", data->state);\n                ret = -EINVAL;\n            }\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state == DMIC_STATE_ACTIVE) {\n                ret = i2s_cmd(config->comm_master, I2S_CMD_STOP);\n                if (ret == 0) {\n                    data->state = DMIC_STATE_CONFIGURED;\n                } else {\n                    LOG_ERR(\"I2S_CMD_STOP failed (%d)\", ret);\n                }\n            } else {\n                LOG_ERR(\"Unexpected state %d\", data->state);\n                ret = -EINVAL;\n            }\n            break;\n\n        default:\n            LOG_ERR(\"Unexpected command %d\", cmd);\n            ret = -EINVAL;\n            break;\n    }\n\n    return ret;\n}", "CodeBleu_score": 60.52527145587307}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tLOG_DBG(\\\"starting\\\");\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tret = i2s_start(config->comm_master);\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\\\"start failed (%d)\\\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tLOG_DBG(\\\"stopping\\\");\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tret = i2s_stop(config->comm_master);\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\\\"stop failed (%d)\\\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\\\"unknown trigger command (%d)\\\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 59.323503874716444}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_config *config = dev->config;\n    struct mpxxdtyy_data *const data = dev->data;\n    int ret = 0;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state == DMIC_STATE_CONFIGURED) {\n                ret = i2s_write(config->comm_master, config->i2s_start_cmd,\n                                sizeof(config->i2s_start_cmd));\n                if (ret != 0) {\n                    LOG_ERR(\"i2s write failed (%d)\", ret);\n                    return ret;\n                }\n\n                data->state = DMIC_STATE_ACTIVE;\n            }\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state == DMIC_STATE_ACTIVE) {\n                ret = i2s_write(config->comm_master, config->i2s_stop_cmd,\n                                sizeof(config->i2s_stop_cmd));\n                if (ret != 0) {\n                    LOG_ERR(\"i2s write failed (%d)\", ret);\n                    return ret;\n                }\n\n                data->state = DMIC_STATE_CONFIGURED;\n            }\n            break;\n\n        default:\n            LOG_ERR(\"invalid trigger command\");\n            ret = -EINVAL;\n            break;\n    }\n\n    return ret;\n}", "CodeBleu_score": 61.386375972050836}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ENABLE;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_BLINK_ENABLE;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ENABLE;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 86.90703586513527}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 89.91130507985382}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    const struct auxdisplay_hd44780_config *config = dev->config;\n    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n    if (data->cursor_enabled) {\n        cmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n    }\n\n    if (data->position_blink_enabled) {\n        cmd |= AUXDISPLAY_HD44780_BLINK_ON;\n    }\n\n    if (enabled) {\n        cmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n    }\n\n    auxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 90.66407804644324}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tint rc = 0;\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = gpio_pin_get_dt(&config->busy_gpio);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO: %d\", rc);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 73.28307688184188}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tstruct auxdisplay_itron_data *data = dev->data;\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint rc;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_take(&data->lock_sem, K_FOREVER);\n#endif\n\n\trc = gpio_pin_get_dt(&config->busy_gpio);\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_give(&data->lock_sem);\n#endif\n\n\treturn rc;\n}", "CodeBleu_score": 70.16380101369599}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    struct auxdisplay_itron_data *data = dev->data;\n    int rc;\n\n    if (!data->busy_gpio.port) {\n        return -ENOTSUP;\n    }\n\n    rc = gpio_pin_get_dt(&data->busy_gpio);\n\n    if (rc < 0) {\n        LOG_ERR(\"Failed to read busy GPIO pin: %d\", rc);\n        return rc;\n    }\n\n    return rc;\n}", "CodeBleu_score": 64.28221216496898}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 63.4588289828467}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\tsize_t dev_size;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_get_size(dev, &dev_size)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > dev_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 64.9161572323498}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\tsize_t dev_size;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_get_size(dev, &dev_size) != 0) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > dev_size) {\n\t\tLOG_ERR(\"Read size exceeds BBRAM size\");\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size < offset || offset + size < size) {\n\t\tLOG_ERR(\"Read size exceeds BBRAM size\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, dev_data->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 61.858885945685984}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size ||\n\t    bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 97.77377392351411}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 3) {\n\t\tshell_error(sh, \"Missing device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[2]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 77.43659965284829}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 3) {\n\t\tshell_error(sh, \"missing device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = DEVICE_DT_GET(DT_INST(0, zephyr_bbram));\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.94958431747853}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 3) {\n\t\tshell_error(sh, \"Missing device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[2]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 77.43659965284829}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\tuint8_t *hdr = h4->rx.hdr_len > 0 ? h4->rx.hdr : NULL;\n\tuint16_t bytes_read = h4->rx.hdr_len - h4->rx.remaining;\n\n\tif (hdr != NULL) {\n\t\tuint16_t bytes_to_read = h4->rx.remaining;\n\n\t\tif (uart_fifo_read(cfg->uart, hdr + bytes_read, bytes_to_read) !=\n\t\t    bytes_to_read) {\n\t\t\tLOG_ERR(\"Unable to read H:4 header\");\n\t\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\t\treturn;\n\t\t}\n\n\t\th4->rx.remaining -= bytes_to_read;\n\t}\n}", "CodeBleu_score": 60.83004724148592}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\tuint16_t already_read = h4->rx.hdr_len - h4->rx.remaining;\n\n\tif (uart_fifo_read(cfg->uart, h4->rx.hdr + already_read, h4->rx.remaining) != h4->rx.remaining) {\n\t\tLOG_ERR(\"Unable to read H:4 packet header\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining -= already_read;\n}", "CodeBleu_score": 67.8939880538758}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tuint8_t *hdr = h4->rx.hdr;\\\n\tuint16_t read;\n\tuint16_t remaining = h4->rx.remaining;\n\n\t/* Calculate number of bytes already read */\n\thdr += h4->rx.hdr_len - remaining;\\\n\tread = remaining;\\\n\n\t/* Read the remaining bytes from the UART FIFO */\n\tif (uart_fifo_read(cfg->uart, hdr, read) != read) {\\\n\t\tLOG_ERR(\\\"Unable to read H:4 header\\\");\\\n\t\treturn;\\\n\t}\\\n\n\t/* Update remaining byte count */\n\th4->rx.remaining -= read;\\\n}", "CodeBleu_score": 61.94791611033874}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t tmp[33];\n    int ret;\n\n    ret = uart_fifo_read(uart, tmp, len);\n    if (ret < 0) {\n        LOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n        return 0U;\n    }\n\n    return (size_t) ret;\n}", "CodeBleu_score": 59.47997422378412}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t tmp[33];\n    size_t ret;\n\n    ret = uart_fifo_read(uart, tmp, MIN(len, sizeof(tmp)));\n    if (ret) {\n        LOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n    } else {\n        len -= ret;\n    }\n\n    return len;\n}", "CodeBleu_score": 62.57011222514293}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret;\n\n\tret = uart_fifo_read(uart, buf, len);\n\tif (ret != len) {\n\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t} else {\n\t\tLOG_DBG(\"Discarded %zu bytes\", len);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 56.700825268650355}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t highest_hop = 0;\n\n\t/* Lock the channel data */\n\tk_mutex_lock(&chan->data->mutex, K_FOREVER);\n\n\t/* Iterate through the observers */\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t_ZBUS_ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->data->hop > highest_hop) {\n\t\t\thighest_hop = obs->data->hop;\n\t\t}\n\t}\n\n\t/* Set the channel's highest observer priority to the determined value */\n\tchan->data->highest_hop = highest_hop;\n\n\t/* Unlock the channel data */\n\tk_mutex_unlock(&chan->data->mutex);\n}", "CodeBleu_score": 69.2560257525611}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t  uint8_t highest_hop = 0;\n  struct zbus_channel_observation *observation;\n  struct zbus_channel_observation_mask *observation_mask;\n\n  for (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n    STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n    STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n    const struct zbus_observer *obs = observation->obs;\n\n    if (!obs->data->enabled || observation_mask->enabled) {\n      continue;\n    }\n\n    if (obs->data->hop > highest_hop) {\n      highest_hop = obs->data->hop;\n    }\n  }\n\n  chan->data->highest_hop = highest_hop;\n}", "CodeBleu_score": 66.95020440297125}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t  struct zbus_channel_data *data = chan->data;\n\n  k_spinlock_key_t key = k_spin_lock(&data->lock);\n\n  uint8_t highest_priority = 0;\n\n  struct zbus_channel_observation *observation;\n  struct zbus_channel_observation_mask *observation_mask;\n\n  for (int16_t i = data->observers_start_idx, limit = data->observers_end_idx; i < limit; ++i) {\n    STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n    STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n    _ZBUS_ASSERT(observation != NULL, \"observation must be not NULL\");\n\n    const struct zbus_observer *obs = observation->obs;\n\n    if (!obs->data->enabled || observation_mask->enabled) {\n      continue;\n    }\n\n    if (obs->priority > highest_priority) {\n      highest_priority = obs->priority;\n    }\n  }\n\n  data->highest_priority = highest_priority;\n\n  k_spin_unlock(&data->lock, key);\n}", "CodeBleu_score": 75.50821698462876}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tstruct zbus_channel_observation *observation;\n\t\tstruct zbus_channel_observation_mask *observation_mask;\n\n\t\tconst int limit = _zbus_channel_observation_count;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 19.63735366361297}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *observation;\n    struct zbus_channel_observation_mask *observation_mask;\n\n    K_SPINLOCK(&_zbus_chan_slock) {\n        for (int16_t i = 0; i < _zbus_channels_count; ++i) {\n            struct zbus_channel *chan = _zbus_channels[i];\n            STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n            STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n            if (!observation->obs->data->enabled || observation_mask->enabled) {\n                continue;\n            }\n\n            if (observation->obs != obs) {\n                continue;\n            }\n\n            chan_update_hop(chan);\n        }\n    }\n}", "CodeBleu_score": 19.93192163452251}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *observation;\n    struct zbus_channel_observation_mask *observation_mask;\n\n    for (int16_t i = 0; i < _zbus_channel_observations_count; ++i) {\n        STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n        STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n        __ASSERT(observation != NULL, \"observation must be not NULL\");\n\n        const struct zbus_channel *chan = observation->chan;\n\n        if (!chan->data->enabled || observation_mask->enabled) {\n            continue;\n        }\n\n        if (obs != observation->obs) {\n            continue;\n        }\n\n        chan_update_hop(chan);\n    }\n}", "CodeBleu_score": 33.246144973763734}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 88.77374490325414}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int err;\n\n    _ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    k_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n    int context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n    err = chan_lock(chan, timeout, &context_priority);\n    if (err) {\n        return err;\n    }\n\n    err = _zbus_vded_exec(chan, end_time);\n\n    chan_unlock(chan, context_priority);\n\n    return err;\n}", "CodeBleu_score": 88.95742836882025}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int err;\n\n    _ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    k_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n    int context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n    err = chan_lock(chan, timeout, &context_priority);\n    if (err) {\n        return err;\n    }\n\n    err = _zbus_vded_exec(chan, end_time);\n\n    chan_unlock(chan, context_priority);\n\n    return err;\n}", "CodeBleu_score": 88.95742836882025}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESLA;\n    ETH_TX_DESC *start = desc;\n\n    do {\n        if (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n            return desc;\n        }\n\n        desc = (ETH_TX_DESC *)desc->nextDescAddr;\n    } while (desc != start);\n\n    return 0;\n}", "CodeBleu_score": 67.09846747877246}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *currDesc = (ETH_TX_DESC *)ETH->TDESLA;\n    uint32_t currAddr = (uint32_t)currDesc;\n    uint32_t startAddr = currAddr;\n    uint32_t endAddr = currAddr + ETH_TX_DESC_SIZE * ETH_TX_DESC_NUM;\n    if (currDesc->TX_0.TX0_b.OWN != ETH_DESC_OWN_BY_SELF) {\n        return 0;\n    }\n\n    do {\n        if (currDesc->TX_0.TX0_b.OWN != ETH_DESC_OWN_BY_SELF) {\n            return currDesc;\n        }\n\n        currAddr += ETH_TX_DESC_SIZE;\n        currDesc = (ETH_TX_DESC *)currAddr;\n    } while (currAddr != startAddr);\n\n    return 0;\n}", "CodeBleu_score": 54.22553303066262}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc = (ETH_TX_DESC *)ETH->TDESLA;\n\n    /* Check if the descriptor is owned by the device */\n    if (txDesc->TX_0.TX0_b.OWN != ETH_DESC_OWN_BY_SELF) {\n        return 0;\n    }\n\n    /* Check if the descriptor is free */\n    if (txDesc->TX_0.TX0_b.FS && txDesc->TX_0.TX0_b.LS) {\n        return txDesc;\n    }\n\n    /* Search for a free descriptor */\n    while (1) {\n        txDesc = (ETH_TX_DESC *)txDesc->nextDescAddr;\n\n        /* Check if the descriptor is owned by the device */\n        if (txDesc->TX_0.TX0_b.OWN != ETH_DESC_OWN_BY_SELF) {\n            return 0;\n        }\n\n        /* Check if the descriptor is free */\n        if (txDesc->TX_0.TX0_b.FS && txDesc->TX_0.TX0_b.LS) {\n            return txDesc;\n        }\n\n        /* Check if we have looped back to the starting address */\n        if (txDesc == (ETH_TX_DESC *)ETH->TDESLA) {\n            return 0;\n        }\n    }\n}", "CodeBleu_score": 50.74973592447508}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    cy_rslt_t result;\n\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel*/\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC device init*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"DAC OutputEnable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n    return RT_EOK;\n}", "CodeBleu_score": 81.85289537828342}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    cy_rslt_t result;\n\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel*/\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC device init*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n    if (result != RT_EOK) {\n        LOG_E(\"DAC OutputEnable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 81.85289537828342}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_uint32_t cyp_channel;\n    cy_rslt_t result;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel*/\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC device init*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\n    if (result != RT_EOK)\n    {\n        LOG_E(\"DAC OutputEnable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 80.99958868297897}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > block_info.size) {\n        LOG_E(\"flash read overflow\");\n        return -EINVAL;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = cyhal_flash_read_byte(&flash_obj, addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 41.80434880870896}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > block_info.size) {\n        LOG_E(\"Read operation exceeds flash memory end address.\");\n        return -RT_EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = cyhal_flash_read_byte(&flash_obj, addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 44.14490410497444}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 45.02898307996257}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 45.02898307996257}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 45.02898307996257}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    result = rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n    if (result != RT_EOK)\n        RT_ASSERT(0);\n}", "CodeBleu_score": 34.561940030591195}, {"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    do {\n        result = rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n    } while (result != RT_EOK);\n}", "CodeBleu_score": 29.87044935376669}, {"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    result = rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 22.61756305901013}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd = startfd;\n\n    if (startfd < 0) {\n        fd = fdt->maxfd;\n    }\n\n    while (fd < fdt->maxfd) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n        fd++;\n    }\n\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 33.80236539985175}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd = -1;\n\n    if (startfd < 0) {\n        startfd = 0;\n    }\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 33.59916709339668}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    /* search for an empty slot */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* expand the fd table */\n    return fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 33.664274934899474}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_size_t i;\\\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n        if (rt_errno_strs[i].error == error) {\n            return rt_errno_strs[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 71.97041406143903}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_uint32_t i;\n    rt_err_t errno_code;\n\n    errno_code = error;\n\n    if (error < 0) {\n        errno_code = -error;\n    }\n\n    for (i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n        if (rt_errno_strs[i].error == errno_code) {\n            return rt_errno_strs[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 63.129627303701064}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_size_t i;\n    rt_err_t err;\n\n    if (error < 0) {\n        err = -error;\n    } else {\n        err = error;\n    }\n\n    for (i = 0; i < RT_ARRAY_SIZE(rt_errno_strs); i++) {\n        if (rt_errno_strs[i].error == err) {\n            return rt_errno_strs[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 60.53860386372509}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_uint32_t i = 0;\n    rt_base_t level;\n\n    rt_spinlock_take(&_hook_spinlock, level);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == NULL) {\n            idle_hook_list[i] = hook;\n            break;\n        }\n    }\n\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n\n    rt_spinlock_release(&_hook_spinlock, level);\n\n    return result;\n}", "CodeBleu_score": 65.42149876439574}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_uint32_t i;\n    rt_base_t level;\n    rt_base_t *p_level;\n\n    if (hook == RT_NULL)\n        return -RT_EINVAL;\n\n    p_level = (rt_base_t *)&level;\n    rt_hw_interrupt_disable(p_level);\n\n    rt_spin_lock(&_hook_spinlock);\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            break;\n        }\n    }\n    rt_spin_unlock(&_hook_spinlock);\n\n    if (i == RT_IDLE_HOOK_LIST_SIZE)\n        result = -RT_EFULL;\n\n    rt_hw_interrupt_enable(p_level);\n\n    return result;\n}", "CodeBleu_score": 66.34141894830104}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_uint32_t i;\n    struct rt_spinlock *lock = &_hook_spinlock;\n    rt_base_t level;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    rt_spinlock_take(lock, level);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n    rt_spinlock_release(lock, level);\n\n    return result;\n}", "CodeBleu_score": 70.37619427468952}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.66622949429424}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.66622949429424}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.66622949429424}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_sched_lock_level_t slvl;\n    rt_thread_t thread;\n    rt_err_t error;\n\n    RT_SCHED_DEBUG_IS_UNLOCKED;\n    RT_ASSERT(susp_list != RT_NULL);\n\n    rt_sched_lock(&slvl);\n    while (!rt_list_isempty(susp_list)) {\n        thread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n        error = rt_sched_thread_ready(thread);\n\n        if (error) {\n            LOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\",\n                  __func__, error, thread);\n\n            thread = RT_NULL;\n            break;\n        } else {\n            /* thread error should not be a negative value */\n            if (thread_error >= 0) {\n                /* set thread error code to notified resuming thread */\n                thread->error = thread_error;\n            }\n        }\n    }\n    rt_sched_unlock(slvl);\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.567644752746695}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n\n    RT_SCHED_DEBUG_IS_UNLOCKED;\n    RT_ASSERT(susp_list != RT_NULL);\n\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_susp_list_dequeue(susp_list, thread_error);\n        if (thread == RT_NULL) {\n            return RT_ERROR;\n        }\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 57.99432047584312}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_sched_lock_level_t slvl;\n    rt_thread_t thread;\n    rt_err_t error;\n\n    RT_SCHED_DEBUG_IS_UNLOCKED;\n    RT_ASSERT(susp_list != RT_NULL);\n\n    rt_sched_lock(&slvl);\n    while (!rt_list_isempty(susp_list)) {\n        thread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n        error = rt_sched_thread_ready(thread);\n\n        if (error) {\n            LOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\",\n                  __func__, error, thread);\n\n            thread = RT_NULL;\n        } else {\n            /* thread error should not be a negative value */\n            if (thread_error >= 0) {\n                /* set thread error code to notified resuming thread */\n                thread->error = thread_error;\n            }\n        }\n    }\n    rt_sched_unlock(slvl);\n\n    LOG_D(\"resume all thread\n\");\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.430879568458145}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device = _console_device;\n    rt_device_t new_device;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (new_device == old_device) {\n        return old_device;\n    }\n\n    if (old_device != RT_NULL) {\n        rt_device_close(old_device);\n    }\n\n    if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    _console_device = new_device;\n\n    return old_device;\n}", "CodeBleu_score": 72.12800134200161}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = _console_device;\n    rt_device_t new_console = RT_NULL;\n    rt_err_t result;\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        LOG_E(\"Can't find console device: %s\", name);\n        return RT_NULL;\n    }\n\n    if (new_console == old_console) {\n        return old_console;\n    }\n\n    result = rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        LOG_E(\"Can't open console device: %s\", name);\n        return RT_NULL;\n    }\n\n    _console_device = new_console;\n    return old_console;\n}", "CodeBleu_score": 60.9994591420222}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device = RT_NULL;\n    rt_device_t device = RT_NULL;\n    rt_err_t result = RT_EOK;\n\n    RT_ASSERT(name != RT_NULL);\n\n    /* save old console device */\n    old_device = _console_device;\n\n    /* find the new device */\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        LOG_E(\"Can't find device: %s\", name);\n        goto __exit;\n    }\n\n    /* check if the new device is the same as the current device */\n    if (device == old_device) {\n        goto __exit;\n    }\n\n    /* close the current console device if it exists */\n    if (old_device != RT_NULL) {\n        result = rt_device_close(old_device);\n        if (result != RT_EOK) {\n            LOG_E(\"Close old device failed: %s\", name);\n            goto __exit;\n        }\n    }\n\n    /* open the new console device with read/write and stream flags */\n    result = rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        LOG_E(\"Open device failed: %s\", name);\n        goto __exit;\n    }\n\n    /* set the new device as the console device */\n    _console_device = device;\n\n__exit:\n    return old_device;\n}", "CodeBleu_score": 54.43744287992378}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_information *info;\n    int count;\n\n    type = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n    info = rt_object_get_information(type);\n    if (info == RT_NULL) return 0;\n\n    rt_base_ticketlock_lock(&info->lock);\n    count = 0;\n    for (struct rt_object_list *p = info->list.next; p != &info->list; p = p->next) {\n        count++;\n    }\n    rt_base_ticketlock_unlock(&info->lock);\n\n    return count;\n}", "CodeBleu_score": 48.45913081886037}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count;\n    struct rt_object_information *info;\n\n    info = rt_object_get_information(type);\n    if (info == RT_NULL) return 0;\n\n    rt_base_ticketlock_take(&info->lock);\n    count = 0;\n    for (struct rt_object *object = info->list.next; object != &info->list; object = object->next)\n        count++;\n    rt_base_ticketlock_release(&info->lock);\n\n    return count;\n}", "CodeBleu_score": 44.953937283098625}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\tstruct rt_object_information *info;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\tinfo = rt_object_get_information(type);\n\tif (info == RT_NULL)\n\t\treturn 0;\n\n\trt_base_ticketlock_lock(&info->lock);\n\n\tindex = 0;\n\twhile (info->list[index].object != RT_NULL)\n\t\tindex++;\n\n\trt_base_ticketlock_unlock(&info->lock);\n\n\treturn index;\n}", "CodeBleu_score": 41.890097462111285}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    struct rt_object_information *information;\n\n    RT_ASSERT(object != RT_NULL);\n\n    information = rt_object_get_information(object->type);\n    RT_ASSERT(information != RT_NULL);\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    rt_list_remove(&(object->list));\n\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    object->type = 0;\n}", "CodeBleu_score": 86.75485570843581}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    struct rt_object_information *information;\n\n    RT_ASSERT(object != RT_NULL);\n\n    information = rt_object_get_information(object->type);\n    RT_ASSERT(information != RT_NULL);\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n    rt_list_remove(&(object->list));\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    object->type = 0;\n}", "CodeBleu_score": 86.75485570843581}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    struct rt_object_information *information;\n\n    if (object == RT_NULL)\n        return;\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    /* get object information */\n    information = rt_object_get_information(object->type);\n    if (information == RT_NULL)\n        return;\n\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove object from information object list */\n    rt_list_remove(&(object->list));\n\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    /* set object type to zero */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 76.04346050740405}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = -RT_EINVAL;\n    if (obj != RT_NULL) {\n        struct rt_custom_object *cobj = (struct rt_custom_object *)obj;\n        if (cobj->type == RT_Object_Class_Custom) {\n            if (cobj->destroy != RT_NULL) {\n                result = cobj->destroy(cobj->data);\n            }\n            rt_object_delete(obj);\n        }\n    }\n    return result;\n}", "CodeBleu_score": 73.41517683081686}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = -RT_EINVAL;\n\tstruct rt_custom_object *cobj = RT_NULL;\n\n\tif (obj != RT_NULL)\n\t{\n\t\tcobj = (struct rt_custom_object *)obj;\n\t\tif (cobj->type == RT_Object_Class_Custom)\n\t\t{\n\t\t\tif (cobj->destroy)\n\t\t\t{\n\t\t\t\tresult = cobj->destroy(cobj->data);\n\t\t\t}\n\t\t\trt_object_delete(obj);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 71.98364687371912}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    struct rt_custom_object *cobj = (struct rt_custom_object *)obj;\n    rt_err_t result = -RT_EINVAL;\n    if ((obj != RT_NULL) && (cobj->type == RT_Object_Class_Custom)) {\n        if (cobj->destroy != RT_NULL) {\n            result = cobj->destroy(cobj->data);\n        }\n        rt_object_destroy(obj);\n    }\n    return result;\n}", "CodeBleu_score": 63.61685710161685}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread = parameter;\n    rt_base_t level;\n\n    /* check parameter */\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    /* lock scheduler */\n    level = rt_hw_interrupt_disable();\n\n    /* verify the thread is suspended */\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_hw_interrupt_enable(level);\n        return;\n    }\n\n    /* set thread error */\n    thread->error = RT_ERROR_TIMEOUT;\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert thread to ready list */\n    rt_list_insert_after(&(rt_list_tick_object.list), &(thread->tlist));\n\n    /* unlock scheduler */\n    rt_hw_interrupt_enable(level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 41.28085437741781}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread = (struct rt_thread *) parameter;\n    rt_base_t critical_level;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n\n    critical_level = rt_enter_critical();\n\n    /* check thread status */\n    if (thread->status != RT_THREAD_STATUS_SUSPEND) {\n        rt_exit_critical_safe(critical_level);\n        return;\n    }\n\n    /* set thread error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_list_insert_after(&(rt_thread_ready_list), &(thread->tlist));\n\n    rt_exit_critical_safe(critical_level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 51.7746922276273}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread = (struct rt_thread *) parameter;\n    rt_base_t critical_level;\n\n    /* check parameter */\n    RT_ASSERT(thread != RT_NULL);\n\n    /* lock the scheduler */\n    critical_level = rt_enter_critical();\n\n    /* check thread state */\n    if (thread->state != RT_THREAD_SUSPEND) {\n        rt_exit_critical_safe(critical_level);\n        return;\n    }\n\n    /* set thread error */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove thread from suspend list */\n    rt_thread_suspend_list_remove(thread);\n\n    /* insert thread into ready list */\n    rt_thread_ready_enqueue(thread);\n\n    /* unlock the scheduler */\n    rt_exit_critical_safe(critical_level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 48.70350898727265}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t", "CodeBleu_score": 1.5259533266411016}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    struct rt_mutex *mutex;\n    struct rt_thread *thread_node;\n\n    level = rt_hw_interrupt_disable();\n    thread_node = (struct rt_thread *)thread;\n\n    if (thread_node->object.wait_object != RT_NULL) {\n        mutex = (struct rt_mutex *)thread_node->object.wait_object;\n        rt_list_remove(&mutex->wait_list);\n        mutex->pending_object = RT_NULL;\n    }\n\n    while (thread_node->taken_mutex != RT_NULL) {\n        mutex = (struct rt_mutex *)thread_node->taken_mutex;\n        rt_mutex_release(mutex);\n    }\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 47.46759453243801}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_mutex_t mutex;\n\n    /* lock thread's spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* check if thread is waiting on a mutex */\n    if (thread->wait.wait_type == RT_Wait_Mutex) {\n        /* remove thread from mutex's waiting list */\n        mutex = (rt_mutex_t)thread->wait.wait_obj;\n        rt_mutex_remove_waiting_thread(mutex, thread);\n\n        /* clear pending object */\n        thread->wait.wait_obj = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (!rt_list_isempty(&thread->mutex_list)) {\n        rt_mutex_t mutex = RT_LIST_ENTRY(thread->mutex_list.next, struct rt_mutex, thread_list);\n        rt_mutex_remove_owner(mutex, thread);\n    }\n\n    /* restore spinlock state */\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 41.654141511493734}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n    RT_ASSERT(thread->parent.flag & RT_OBJECT_FLAG_INIT);\n    RT_ASSERT(thread->parent.flag & RT_OBJECT_FLAG_ACTIVE);\n\n    rt_kprintf(\"thread [%s] startup, prio = %d\n\", thread->parent.name, thread->parent.current_priority);\n\n    /* calculate thread priority attributes */\n    rt_thread_priority_calc(thread);\n\n    /* reset thread state to suspended */\n    thread->parent.flag &= ~RT_OBJECT_FLAG_ACTIVE;\n\n    /* resume the thread */\n    rt_thread_resume(thread);\n\n    /* trigger a scheduler */\n    if (rt_thread_count() > 1)\n    {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 52.513234414022456}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_class((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->init_flag == RT_THREAD_INIT);\n\n    rt_kprintf(\"[%s] start, prio:%d, tick:%d\n\", thread->name, thread->init_prio, thread->init_tick);\n\n    /* calculate priority attributes */\n    thread->prio_attribute = rt_thread_prio_attr_get(thread->init_prio);\n\n    /* reset state to suspended */\n    thread->state = RT_THREAD_SUSPEND;\n\n    /* resume the thread */\n    result = rt_thread_resume(thread);\n    if (result != RT_EOK) {\n        return result;\n    }\n\n    /* trigger a scheduler if available */\n    if (rt_system_scheduler_lock() == RT_EOK) {\n        rt_system_scheduler_unlock();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 52.027628524113666}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t  rt_err_t result;\n\n  /* parameter check */\n  RT_ASSERT(thread != RT_NULL);\n  RT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n  RT_ASSERT(thread->parent.state == RT_Object_Inited);\n\n  /* log thread name and priority */\n  rt_kprintf(\"thread:%s(%d)\n\", thread->parent.name, thread->priority);\n\n  /* calculate thread priority attributes */\n  thread->init_tick = rt_tick_get();\n  thread->init_priority = thread->priority;\n  thread->priority_attr = rt_thread_priority_attr_get(thread->priority);\n\n  /* reset thread state to suspended */\n  thread->parent.state = RT_Object_Suspended;\n\n  /* resume the thread */\n  result = rt_thread_resume(thread);\n  if (result != RT_EOK) {\n    return result;\n  }\n\n  /* trigger scheduler if available */\n  rt_schedule();\n\n  return RT_EOK;\n}", "CodeBleu_score": 52.44351699581533}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    int i;\n    struct rt_timer *timer;\n\n    /* check if the highest level of the timer skip list is not empty */\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ENOENT;\n    }\n\n    /* get the first timer entry */\n    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    /* set the provided timeout tick to the timer's timeout value */\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 84.65012925221279}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    int i;\n    rt_list_t *node;\n\n    /* find the first non-empty list */\n    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++) {\n        if (!rt_list_isempty(&timer_list[i])) {\n            /* get the first node */\n            node = rt_list_first(&timer_list[i]);\n\n            /* get the timeout tick */\n            *timeout_tick = ((rt_timer_t)node)->timeout_tick;\n\n            /* return ok */\n            return RT_EOK;\n        }\n    }\n\n    /* no node in the list */\n    return -RT_ERROR;\n}", "CodeBleu_score": 38.192870566241375}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list_head = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    rt_list_t *list_node = NULL;\n\n    if (rt_list_isempty(list_head)) {\n        return RT_ERROR;\n    }\n\n    list_node = list_head->next;\n    *timeout_tick = list_node->entry->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 39.794605333923194}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer = NULL;\n    rt_err_t result;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for timer object */\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    result = rt_timer_init(timer, name, timeout, parameter, time, flag);\n    if (result != RT_EOK) {\n        rt_free(timer);\n        return RT_NULL;\n    }\n\n    return timer;\n}", "CodeBleu_score": 72.68704744292596}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for the timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize the timer object */\n    rt_timer_init(timer, name, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 77.67233735173416}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    rt_timer_init(timer, name, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 78.12261916940398}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler(recorder, req)\n\t\tres.Header().Set(recorder.HeaderMap.Get(robeaux.ContentType), recorder.HeaderMap.Get(robeaux.ContentType))\n\t\tres.Header().Set(recorder.HeaderMap.Get(robeaux.ContentLength), recorder.HeaderMap.Get(robeaux.ContentLength))\n\t\tres.Header().Set(recorder.HeaderMap.Get(robeaux.Connection), recorder.HeaderMap.Get(robeaux.Connection))\n\t\tres.Header().Set(recorder.HeaderMap.Get(robeaux.AccessControlAllowOrigin), recorder.HeaderMap.Get(robeaux.AccessControlAllowOrigin))\n\t\tres.Header().Set(recorder.HeaderMap.Get(robeaux.AccessControlAllowMethods), recorder.HeaderMap.Get(robeaux.AccessControlAllowMethods))\n\t\tres.Header().Set(recorder.HeaderMap.Get(robeaux.AccessControlAllowHeaders), recorder.HeaderMap.Get(robeaux.AccessControlAllowHeaders))\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(`{\"error\":\"Not Authorized\"}`))\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 43.14531631324086}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == 401 {\n\t\t\thttp.Error(res, \\\"Not Authorized\\\", 401)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 77.24776939622788}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler(recorder, req)\n\t\tres.Header().Set(robeaux.Header, recorder.Header().Get(robeaux.Header))\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\\\"Not Authorized\\\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 52.87346795046233}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tasset := path[1:]\n\tassetPath := filepath.Join(\\\"robeaux\\\", asset)\n\n\tdata, err := ioutil.ReadFile(assetPath)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch filepath.Ext(asset) {\n\tcase \\\".js\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/javascript\\\")\n\tcase \\\".css\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/css\\\")\n\tcase \\\".html\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/html\\\")\n\t}\n\n\tres.Write(data)\n}", "CodeBleu_score": 50.536333905428485}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \\\"/\\\" {\n\t\tpath = \\\"/index.html\\\"\n\t}\n\tasset, err := Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tcontentType := \\\"\\\"\n\tif strings.HasSuffix(path, \\\".js\\\") {\n\t\tcontentType = \\\"application/javascript\\\"\n\t} else if strings.HasSuffix(path, \\\".css\\\") {\n\t\tcontentType = \\\"text/css\\\"\n\t} else if strings.HasSuffix(path, \\\".html\\\") {\n\t\tcontentType = \\\"text/html\\\"\n\t}\n\n\tres.Header().Set(\\\"Content-Type\\\", contentType)\n\tres.Write(asset)\n}", "CodeBleu_score": 40.74234850512487}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \\\"/\\\" {\n\t\tpath = \\\"/index.html\\\"\n\t}\n\tasset, err := Asset(path[1:])\n\tif err != nil {\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch filepath.Ext(path) {\n\tcase \\\".js\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"application/javascript\\\")\n\tcase \\\".css\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/css\\\")\n\tcase \\\".html\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/html\\\")\n\tdefault:\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/plain\\\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 41.53847041857184}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t} else {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c *gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t}\n}", "CodeBleu_score": 87.93523838342097}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot != nil {\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.21729671437498}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\trobot.Connections().Each(func(c *gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 93.90494664112671}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tu := []byte(username)\n\tp := []byte(password)\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\\\"WWW-Authenticate\\\", \\\"Basic realm=Restricted\\\")\n\n\t\ts := strings.SplitN(r.Header.Get(\\\"Authorization\\\"), \\\" \\\", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \\\"Not authorized\\\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \\\"Not authorized\\\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \\\":\\\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \\\"Not authorized\\\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare(u, []byte(pair[0])) != 1 || subtle.ConstantTimeCompare(p, []byte(pair[1])) != 1 {\n\t\t\thttp.Error(w, \\\"Not authorized\\\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 43.8605453088445}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tencoded := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 || !subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) || !subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.115968600908666}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tb64 := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) != 1 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Authorization\", \"Basic \"+b64)\n\t\tw.WriteHeader(http.StatusOK)\n\t}\n}", "CodeBleu_score": 50.15423086596892}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept of the linear scaling function\n\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Return the linear scaling function\n\treturn func(input float64) (value int) {\n\t\t// Clamp the input value to the source range\n\t\tif input < fromMin {\n\t\t\tinput = fromMin\n\t\t} else if input > fromMax {\n\t\t\tinput = fromMax\n\t\t}\n\n\t\t// Apply the linear scaling function\n\t\tvalue = int(slope*input + intercept)\n\n\t\t// Clamp the output value to the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 62.37220933010173}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tscale := float64(toMax-toMin) / (fromMax - fromMin)\n\toffset := toMin - fromMin*scale\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input*scale + offset)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 56.51996848976177}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept of the linear scaling function\n\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Create the linear scaling function\n\treturn func(input float64) (value int) {\n\t\t// Apply the linear scaling function\n\t\toutput := slope*input + intercept\n\n\t\t// Clamp the output to the target range\n\t\tif output < float64(toMin) {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > float64(toMax) {\n\t\t\treturn toMax\n\t\t}\n\t\treturn int(output)\n\t}\n}", "CodeBleu_score": 66.48519218090352}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\\\"%s does not support analog reading\\\", a.Name())\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 54.58941295790486}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.HasAnalogRead() {\n\t\treturn -1, -1, ErrNotSupported\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 47.40008474664318}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.(*AnalogReader).SupportsAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\\\"%s does not support analog reading\\\", a.Name())\n\t}\n\n\trawValue, err := a.connection.(*AnalogReader).Read(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\n\treturn rawValue, a.lastValue, nil\n}", "CodeBleu_score": 59.3588060875791}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\tif fromMin == fromMax {\n\t\t\t// Avoid division by zero\n\t\t\treturn 0\n\t\t}\n\n\t\t// Calculate the slope and intercept of the linear transformation\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\t\tn := toMin - m*float64(fromMin)\n\n\t\t// Scale the input value using the linear transformation\n\t\toutput := m*float64(input) + n\n\n\t\t// Ensure the output value stays within the specified output range\n\t\tif output < toMin {\n\t\t\toutput = toMin\n\t\t} else if output > toMax {\n\t\t\toutput = toMax\n\t\t}\n\n\t\treturn output\n\t}\n}", "CodeBleu_score": 67.67702847752867}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\t// Calculate the slope (m) and intercept (n) for the linear transformation\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\t\tn := toMin - m*float64(fromMin)\n\n\t\t// Scale the input value using the linear transformation\n\t\toutput := m*float64(input) + n\n\n\t\t// Ensure the output value stays within the specified output range\n\t\tif output < toMin {\n\t\t\toutput = toMin\n\t\t} else if output > toMax {\n\t\t\toutput = toMax\n\t\t}\n\n\t\treturn output\n\t}\n}", "CodeBleu_score": 69.962328126973}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\t// Calculate the slope and intercept for the linear transformation\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\t\tn := toMin - m*float64(fromMin)\n\n\t\t// Scale the input value using the linear transformation\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 53.82796602429596}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\tif err := d.SetDataHandler(func(data interface{}) {\n\t\tif f, ok := data.(float64); ok && f > 1000 {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 74.57937479544181}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(VibrationEvent)\n\n\td.AddEvent(DataEvent)\n\td.On(DataEvent, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent, true)\n\t\t}\n\t})\n\n\treturn &d\n}", "CodeBleu_score": 60.73579798780284}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(\"vibration\")\n\n\td.AddEvent(\"data\")\n\n\td.On(d.Event(\"data\"), func(data interface{}) {\n\t\tif d.driverCfg.data >= float64(1000) {\n\t\t\td.Publish(d.Event(\"vibration\"), true)\n\t\t}\n\t})\n\n\treturn &d\n}", "CodeBleu_score": 56.03545851100864}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (60.0 / d.bpm) / (1.0 / hz)\n\treturn d.tone(period, duration)\n}", "CodeBleu_score": 10.089221671984184}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (60.0 / d.bpm) / (hz / 1000.0) * 1000.0\n\tfor i := 0; i < int(duration/period); i++ {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.832139508771476}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (60 / d.bpm) * 1000\n\tt := time.Duration(period) * time.Millisecond\n\tend := time.Now().Add(time.Duration(duration) * time.Millisecond)\n\n\tfor time.Now().Before(end) {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(t)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(t)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.80807608313674}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\t// ensure that read and write of variables (direction, stepNum) can not interfere\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// stop any ongoing operation\n\t_ = d.stopIfRunning()\n\n\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 88.19232491382927}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\t// ensure that read and write of variables (direction, stepNum) can not interfere\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 91.88110695303826}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\t// ensure that read and write of variables (direction, stepNum) can not interfere\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 91.88110695303826}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not connected\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 60.39016483331103}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor is not connected\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 61.26319351868299}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 63.461459132201604}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, ErrNotConnected\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = system.NewDigitalPin(chip, line)\n\t\tif err := pin.Export(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin.ApplyOptions(opts...)\n\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 56.49803201922886}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, ErrNotConnected\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := translateDigitalPinID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = system.NewDigitalPin(chip, line)\n\t\ta.pins[id] = pin\n\n\t\topts = append(opts, system.WithPinActiveLow(a.pinOptions[id].activeLow))\n\t\topts = append(opts, system.WithPinPullUpDown(a.pinOptions[id].pullUpDown))\n\t\topts = append(opts, system.WithPinOpenDrain(a.pinOptions[id].openDrain))\n\t\topts = append(opts, system.WithPinDebounce(a.pinOptions[id].debounce))\n\t\topts = append(opts, system.WithPinEventOnFallingEdge(a.pinOptions[id].eventOnFallingEdge))\n\t\topts = append(opts, system.WithPinEventOnRisingEdge(a.pinOptions[id].eventOnRisingEdge))\n\t\topts = append(opts, system.WithPinEventOnBothEdges(a.pinOptions[id].eventOnBothEdges))\n\t\topts = append(opts, system.WithPinPollForEdgeDetection(a.pinOptions[id].pollInterval, a.pinOptions[id].pollQuitChan))\n\t\topts = append(opts, system.WithPinDirectionInput())\n\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 52.313603802371404}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"adaptor is not connected to any pins\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tchip, line, err := a.translateID(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewDigitalPin(chip, line)\n\tif err := pin.Initialize(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range a.pinOptions {\n\t\tif err := pin.ApplyOptions(opt); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := pin.ApplyOptions(opt); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 56.77997960491098}]}
