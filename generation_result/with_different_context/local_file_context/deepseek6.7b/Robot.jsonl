{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n  for (const auto &file : FileTransfer::GetRequiredFiles(folder)) {\n    if (download) {\n      if (!FileTransfer::FileExists(file)) {\n        LOG_INFO(\"Downloading file: \", file);\n        FileTransfer::GetFile(file);\n      } else {\n        LOG_INFO(\"Found file in cache: \", file);\n      }\n    }\n    required_files.emplace_back(file);\n  }\n  return required_files;\n}", "CodeBleu_score": 53.93181012472119}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n    for (auto &file : FileTransfer::GetFilesInFolder(folder)) {\n      if (download && !FileTransfer::FileExists(file)) {\n        LOG_INFO(\\\"Requesting file: \\\", file);\n        FileTransfer::RequestFile(file);\n      } else {\n        LOG_INFO(\\\"Found file in cache: \\\", file);\n      }\n      required_files.push_back(file);\n    }\n    return required_files;\n  }", "CodeBleu_score": 50.04324059966873}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> required_files;\n\n    for (auto &file : FileTransfer::GetRequiredFiles(folder)) {\n      if (download) {\n        if (FileTransfer::FileExists(file)) {\n          LOG_INFO(\\\"Found \\\" << file << \\\" in cache.\\\");\n        } else {\n          LOG_INFO(\\\"Downloading \\\" << file << \\\"...\\\");\n          FileTransfer::RequestFile(file);\n        }\n      }\n      required_files.emplace_back(file);\n    }\n\n    return required_files;\n  }", "CodeBleu_score": 47.94447396147476}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // If the attachment type is SpringArm or SpringArmGhost, check the validity of the transformation\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.z != 0.0f) {\n      log_warning(\"SpringArm and SpringArmGhost attachments only support 2D attachments, ignoring z-axis translation\");\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 44.531150817139284}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transformation is ill-formed.\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f &&\n        transform.location.z != 0.0f) {\n      log_warning(\"SpringArm and SpringArmGhost attachments can only be used \"\n                  \"when the translation is only in the 'z' axis. The \"\n                  \"transformation will be adjusted to avoid this issue.\");\n      geom::Transform adjusted_transform = transform;\n      adjusted_transform.location.x = 0.0f;\n      adjusted_transform.location.y = 0.0f;\n      return SpawnActorWithParentInternal(\n          description, adjusted_transform, parent, attachment_type, socket_name);\n    }\n  }\n  return SpawnActorWithParentInternal(\n      description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 49.50561313933435}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.z != 0.0) {\n      log_warning(\n          \"SpringArm or SpringArmGhost attachment type requires a translation \"\n          \"only in the 'z' axis, but the provided transform has a translation \"\n          \"in the 'x' and 'y' axis as well. This might lead to ill-formed \"\n          \"transformations.\");\n    }\n  }\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 48.768854566620675}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _pimpl->CallAndWait<streaming::Token>(\"get_gbuffer_token\", ActorId, GBufferId);\n  auto token_data = token.get_token();\n  streaming::Token receivedToken(token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 57.33646653291129}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  auto token = _pimpl->CallAndWait<streaming::Token>(\"get_gbuffer_token\", ActorId, GBufferId);\n  carla::streaming::detail::token_type thisToken(token);\n  _pimpl->streaming_client.Subscribe(thisToken, std::move(callback));\n}", "CodeBleu_score": 45.59460510767569}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  carla::streaming::detail::token_type thisToken = _pimpl->CallAndWait<carla::streaming::detail::token_type>(\"get_gbuffer_token\", ActorId, GBufferId);\n  streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\"get_gbuffer_token\", thisToken.get_stream_id());\n  _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 51.0375902779712}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (_walker_navigation == nullptr) {\n    _walker_navigation = std::make_shared<WalkerNavigation>(_client);\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 29.50523593267736}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (_walker_navigation == nullptr) {\n    _walker_navigation = std::make_shared<WalkerNavigation>(_client);\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 29.50523593267736}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (!_walker_navigation) {\n    _walker_navigation = std::make_shared<WalkerNavigation>(_client);\n    if (!_walker_navigation->Set(_actors.GetActorsById(_state->GetActorIds()))) {\n      _walker_navigation.reset();\n    }\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 38.17806805478738}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::steady_clock::now();\n  while (episode.GetState().frame < frame) {\n    std::this_thread::yield();\n    if (std::chrono::steady_clock::now() - start > timeout) {\n      return false;\n    }\n  }\n  TrafficManager::GetInstance().Tick(episode.GetState().frame);\n  return true;\n}", "CodeBleu_score": 40.59225003554433}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  using namespace std::chrono;\n\n    auto start = steady_clock::now();\n    auto end = start + timeout;\n    auto frame_state = episode.GetState().frame;\n\n    while (frame_state < frame) {\n      if (steady_clock::now() > end) {\n        return false;\n      }\n      std::this_thread::yield();\n      frame_state = episode.GetState().frame;\n    }\n\n    if (frame_state == frame) {\n      auto traffic_manager = episode.GetTrafficManager();\n      traffic_manager->Tick(frame);\n    }\n\n    return true;\n  }", "CodeBleu_score": 49.92197190990735}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  using namespace std::chrono;\n\n    const auto start = steady_clock::now();\n    const auto end = start + timeout;\n    while (episode.GetFrame() < frame) {\n      if (steady_clock::now() > end) {\n        return false;\n      }\n      std::this_thread::yield();\n    }\n    traffic_manager::TrafficManager::GetInstance().Tick(frame);\n    return true;\n  }", "CodeBleu_score": 43.293299170329014}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  const auto start = std::chrono::system_clock::now();\n  const auto timeout = std::chrono::seconds(10);\n  const auto &client = _client.GetClient();\n  auto episode = client.LoadEpisode(map_name, reset_settings, map_layers);\n  auto episode_id = episode.GetId();\n  auto end = std::chrono::system_clock::now();\n  auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n  while (diff < timeout) {\n    if (episode_id != episode.GetId()) {\n      break;\n    }\n    std::this_thread::yield();\n    end = std::chrono::system_clock::now();\n    diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n  }\n  if (diff >= timeout) {\n    throw_exception(std::runtime_error(\\\"Failed to load episode \\\"s + map_name));\n  }\n  return EpisodeProxy(std::move(episode));\n}", "CodeBleu_score": 47.63109506641846}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  const auto map = GetWorld().GetMap();\n  if (map_name.empty()) {\n    map_name = map.GetName();\n  }\n  const auto map_index = map.GetIndex();\n  const auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  auto episode = GetEpisode(episode_id);\n  if (!episode.IsValid()) {\n    throw_exception(std::runtime_error(\"Couldn't load episode \" + map_name));\n  }\n  while (episode.GetId() != episode_id) {\n    std::this_thread::yield();\n    episode = GetEpisode(episode_id);\n  }\n  return episode;\n}", "CodeBleu_score": 47.457179739556764}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  auto start = std::chrono::system_clock::now();\n  auto end = std::chrono::system_clock::now();\n  auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n  while (diff < _client.GetTimeout()) {\n    try {\n      auto episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n      if (episode.IsValid()) {\n        return EpisodeProxy(episode, _client);\n      }\n    } catch (const std::exception &e) {\n      log_error(e.what());\n    }\n    end = std::chrono::system_clock::now();\n    diff = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n  }\n  throw std::runtime_error(\\\"Failed to load episode: \\\"s + map_name);\n}", "CodeBleu_score": 48.539878630844036}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterAIController(controller);\n}", "CodeBleu_score": 46.13302003447187}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterAIController(controller);\n}", "CodeBleu_score": 45.59118077901177}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterAIController(controller);\n}", "CodeBleu_score": 45.59118077901177}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  DEBUG_ASSERT(_episode != nullptr);\n\n  // spawn actor\n  auto actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  // register actor\n  _episode->RegisterActor(actor, gc);\n\n  // log\n  log_info(\\\"spawned actor \\\" + actor->GetDisplayId());\n\n  // return actor\n  return actor;\n  }", "CodeBleu_score": 30.66216395630027}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  DEBUG_ASSERT(_episode != nullptr);\n\n  // create the actor\n  auto actor = _episode->CreateActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  // register the actor\n  _episode->RegisterActor(actor);\n\n  // apply the garbage collection policy\n  if (gc == GarbageCollectionPolicy::ALWAYS) {\n    _episode->RegisterGarbage(actor);\n  }\n\n  // log the creation details\n  const auto &display_id = actor->GetDisplayId();\n  const auto &blueprint_name = blueprint.GetName();\n  const auto &parent_display_id = parent ? parent->GetDisplayId() : \\\"\\\";\n  log_info(\\\"actor created: {}\\\", display_id);\n  log_info(\\\"  blueprint: {}\\\", blueprint_name);\n  log_info(\\\"  parent: {}\\\", parent_display_id);\n\n  return actor;\n  }", "CodeBleu_score": 45.72891310834417}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  // spawn actor\n  auto actor = MakeActor(_client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name));\n\n  // register actor\n  _episode->RegisterActor(actor);\n\n  // apply garbage collection policy\n  switch (gc) {\n    case GarbageCollectionPolicy::NEVER:\n      break;\n    case GarbageCollectionPolicy::ALWAYS:\n      _episode->RegisterActorForDeletion(actor);\n      break;\n    case GarbageCollectionPolicy::DESTRUCTION:\n      _episode->RegisterActorForDeletionOnDestruction(actor);\n      break;\n  }\n\n  // log\n  std::string parent_name = parent ? parent->GetDisplayId() : \\\"none\\\";\n  log_info(\\\"spawned actor \\\", actor->GetDisplayId(), \\\" (parent: \\\", parent_name, \\\")\\\");\n\n  return actor;\n}", "CodeBleu_score": 44.47641978939687}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  _client.SubscribeToStream(sensor.GetId(), [this, callback](const rpc::SensorData &data) {\n    auto result = sensor::SensorData::Deserialize(data);\n    result->AssociateWithEpisode(_episode);\n    callback(result);\n  });\n}", "CodeBleu_score": 44.50819699124108}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  _client.SubscribeToStream(sensor.GetId(), [this, callback](const rpc::SensorData &data) {\n    auto sensor_data = sensor::SensorDataFactory::MakeSensorData(GetCurrentEpisode(), data);\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 39.95973826745135}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  _client.SubscribeToStream(sensor.GetId(), [this, callback](const std::string &data) {\n    auto episode = GetCurrentEpisode();\n    auto sensor_data = sensor::SensorData::Deserialize(data);\n    sensor_data->SetEpisode(episode);\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 46.76179720435788}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto simulator = _simulator.lock();\n  if (simulator == nullptr) {\n    return;\n  }\n\n  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->GetState();\n  if (state == EpisodeState::Running) {\n    // Remove walkers that no longer exist.\n    auto it = walkers.begin();\n    while (it != walkers.end()) {\n      if (!(*it)->IsAlive()) {\n        it = walkers.erase(it);\n      } else {\n        ++it;\n      }\n    }\n  }\n\n  // Update the crowd.\n  _nav.UpdateVehiclesInCrowd(episode);\n  _nav.UpdateCrowd(episode);\n\n  // Apply the states of the walkers to the simulator.\n  std::vector<rpc::WalkerControl> controls;\n  for (auto walker : walkers) {\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetSpeed();\n    controls.emplace_back(transform, speed);\n  }\n  simulator->ApplyWalkerStates(controls);\n\n  // Check if any walker has been killed.\n  for (auto walker : walkers) {\n    if (!walker->IsAlive()) {\n      _nav.RemoveVehicleFromCrowd(walker);\n      walker->Destroy();\n    }\n  }\n}", "CodeBleu_score": 42.01634943002385}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto simulator = _simulator.lock();\n  if (!simulator) {\n    return;\n  }\n  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n  auto state = episode->GetState();\n  auto it = walkers.begin();\n  while (it != walkers.end()) {\n      auto walker = *it;\n      if (!walker->IsAlive()) {\n        walker->Destroy();\n        it = walkers.erase(it);\n      } else {\n        auto transform = walker->GetTransform();\n        auto velocity = walker->GetVelocity();\n        auto speed = velocity.length();\n        _nav.UpdateVehicle(walker->GetId(), transform, speed);\n        ++it;\n      }\n    }\n    _nav.UpdateCrowd();\n    // Check if any walker has been killed.\n    for (auto walker : walkers) {\n      if (walker->IsDead()) {\n        _nav.RemoveVehicle(walker->GetId());\n        walker->Destroy();\n      }\n    }\n  }", "CodeBleu_score": 38.86275271929996}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 79.48629673680531}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 84.23778532147426}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = _id;\n  description.uid = _uid;\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.ToActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 76.95453105876618}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  map_type result;\n  for (auto &pair : _blueprints) {\n    if (pair.second.HasAttribute(name)) {\n      auto &attribute = pair.second.GetAttribute(name);\n      if (attribute.MatchValue(value)) {\n        result.emplace(pair);\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 42.22822296844186}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  map_type result;\n  for (auto &pair : _blueprints) {\n    if (pair.second.HasAttribute(name)) {\n      if (pair.second.GetAttribute(name) == value) {\n        result.emplace(pair);\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 38.63384687517319}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  map_type result;\n  for (auto &pair : _blueprints) {\n    auto &blueprint = pair.second;\n    auto attribute = blueprint.GetAttribute(name);\n    if (attribute != nullptr) {\n      if (attribute->HasRecommendedValues()) {\n        for (auto &recommended_value : attribute->GetRecommendedValues()) {\n          if (recommended_value == value) {\n            result.emplace(pair);\n            break;\n          }\n        }\n      } else {\n        if (attribute->GetValue() == value) {\n          result.emplace(pair);\n          break;\n        }\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 64.92644185981649}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path using the base folder and version information\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Validate the file path\n  if (!ValidateFilePath(fullpath)) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\n  // Check if the file is open\n  if (file.is_open()) {\n    // Write the content to the file\n    file.write(reinterpret_cast<char*>(content.data()), content.size());\n\n    // Close the file\n    file.close();\n\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 57.964513773977245}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path using a base folder and version information\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Validate the file path\n  if (fullpath.empty()) return false;\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\n  // Check if the file is successfully opened\n  if (!file.is_open()) return false;\n\n  // Write the content and close the file\n  file.write(reinterpret_cast<const char *>(content.data()), content.size());\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 58.31094849424322}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path using a base folder and version information\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Validate the file path\n  if (fullpath.empty()) return false;\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\n  // If the file is successfully opened, write the content and close the file\n  if (file.is_open()) {\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    file.close();\n    return true;\n  }\n\n  // If the file cannot be opened, return false\n  return false;\n}", "CodeBleu_score": 57.40773188551762}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  auto corners = _parent_bounding_box.GetCorners();\n  for (auto &corner : corners) {\n    corner += transform.location;\n  }\n  auto yaw = transform.rotation.yaw;\n  for (auto &corner : corners) {\n    corner = Rotate(yaw, corner);\n  }\n  return std::make_shared<Bounds>(frame, corners);\n}", "CodeBleu_score": 34.46141561618191}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto parent_location = _parent_bounding_box.location + transform.location;\n  const auto parent_rotation = transform.rotation;\n  const auto parent_yaw = parent_rotation.yaw;\n  const auto parent_extent = _parent_bounding_box.extent;\n  const auto parent_corners = std::array<geom::Location, 4u>{\n      Rotate(parent_yaw, {parent_location.x - parent_extent.x, parent_location.y + parent_extent.y, parent_location.z}),\n      Rotate(parent_yaw, {parent_location.x + parent_extent.x, parent_location.y + parent_extent.y, parent_location.z}),\n      Rotate(parent_yaw, {parent_location.x + parent_extent.x, parent_location.y - parent_extent.y, parent_location.z}),\n      Rotate(parent_yaw, {parent_location.x - parent_extent.x, parent_location.y - parent_extent.y, parent_location.z})};\n  return std::make_shared<Bounds>(frame, parent_corners);\n}", "CodeBleu_score": 42.985941402617925}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &location = transform.location + _parent_bounding_box.location;\n  const auto &rotation = transform.rotation;\n  const auto &extents = _parent_bounding_box.extent;\n  const auto &yaw = rotation.yaw;\n  const auto &corners = std::array<geom::Location, 4u>{\n      Rotate(yaw, {location.x - extents.x, location.y - extents.y, location.z}),\n      Rotate(yaw, {location.x + extents.x, location.y - extents.y, location.z}),\n      Rotate(yaw, {location.x + extents.x, location.y + extents.y, location.z}),\n      Rotate(yaw, {location.x - extents.x, location.y + extents.y, location.z})};\n  return std::make_shared<Bounds>(frame, std::move(corners));\n}", "CodeBleu_score": 47.049949851874885}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  std::vector<LightState> states = _server->QueryLightsState();\n  for (auto state : states) {\n    auto it = _lights_state.find(state._id);\n    if (it == _lights_state.end()) {\n      Light light = Light(state._id, _server);\n      _lights.insert(std::make_pair(state._id, light));\n    }\n    _lights_state[state._id] = state;\n  }\n}", "CodeBleu_score": 39.9515040314386}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  std::map<LightId, LightState> lights_state = _server->QueryLightsState();\n  _lights_state.insert(lights_state.begin(), lights_state.end());\n  for (auto& light_state : lights_state) {\n    auto it_light = _lights.find(light_state.first);\n    if (it_light == _lights.end()) {\n      _lights.emplace(light_state.first, Light(light_state.first));\n    }\n  }\n}", "CodeBleu_score": 34.029992345597734}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  carla::client::LightStateMap lights_state = _client.QueryLightsState();\n\n  for (auto light_state : lights_state) {\n    LightId id = light_state.first;\n    auto it = _lights_state.find(id);\n    if (it == _lights_state.end()) {\n      _lights_state[id] = light_state.second;\n      _lights[id] = Light(id, light_state.second);\n    } else {\n      it->second = light_state.second;\n    }\n  }\n}", "CodeBleu_score": 36.53755740191531}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_dirty) {\n    // Send blocking query\n    std::vector<rpc::LightState> lights_snapshot = _episode.Lock()->QueryLightsStateToServer();\n\n    // Update lights\n    SharedPtr<LightManager> lm = _episode.Lock()->GetLightManager();\n\n    for (const auto & it : lights_snapshot) {\n      _lights_state[it._id] = LightState(\n          it._intensity,\n          Color(it._color.r, it._color.g, it._color.b),\n          static_cast<LightState::LightGroup>(it._group),\n          it._active\n      );\n\n      if (_lights.find(it._id) == _lights.end())\n      {\n        _lights[it._id] = Light(lm, it._location, it._id);\n      }\n    }\n\n    if (!discard_client) {\n      // Create message\n      rpc::LightStateList message;\n      for (const auto & it : _lights_changes) {\n        const LightState & state = it.second;\n        rpc::LightState & light_state = *message.add_lights();\n        light_state._id = it.first;\n        light_state._intensity = state._intensity;\n        light_state._color = rpc::Color(state._color.r, state._color.g, state._color.b);\n        light_state._group = static_cast<uint8_t>(state._group);\n        light_state._active = state._active;\n      }\n\n      // Send message\n      _episode.Lock()->Send(message);\n    }\n\n    // Clear changes\n    _lights_changes.clear();\n    _dirty = false;\n  }\n}", "CodeBleu_score": 53.107503014427756}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_dirty) {\n    // Create message\n    std::vector<rpc::LightState> lights_changes;\n    for (auto it : _lights_changes) {\n      lights_changes.push_back(rpc::LightState(\n          it.first,\n          it.second._intensity,\n          rpc::Color(it.second._color.r, it.second._color.g, it.second._color.b),\n          static_cast<uint8_t>(it.second._group),\n          it.second._active\n      ));\n    }\n    // Send message\n    _episode.Lock()->SendLightsStateToServer(lights_changes);\n    // Clear changes\n    _lights_changes.clear();\n    // Reset dirty flag\n    _dirty = false;\n  }\n}", "CodeBleu_score": 47.48797890723054}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_dirty) {\n    // Send blocking query\n    std::vector<rpc::LightState> lights_snapshot = _episode.Lock()->QueryLightsStateToServer();\n    // Update lights\n    SharedPtr<LightManager> lm = _episode.Lock()->GetLightManager();\n    for (const auto& it : lights_snapshot) {\n      _lights_state[it._id] = LightState(\n          it._intensity,\n          Color(it._color.r, it._color.g, it._color.b),\n          static_cast<LightState::LightGroup>(it._group),\n          it._active\n      );\n      if (_lights.find(it._id) == _lights.end()) {\n        _lights[it._id] = Light(lm, it._location, it._id);\n      }\n    }\n    if (!discard_client) {\n      std::vector<rpc::LightState> lights_changes;\n      for (const auto& it : _lights_changes) {\n        lights_changes.push_back(rpc::LightState(\n            it.first,\n            it.second._intensity,\n            rpc::Color(it.second._color.r, it.second._color.g, it.second._color.b),\n            static_cast<uint8_t>(it.second._group),\n            it.second._active\n        ));\n      }\n      _episode.Lock()->Send(new rpc::SetLightsState(lights_changes));\n    }\n    _lights_changes.clear();\n    _dirty = false;\n  }\n}", "CodeBleu_score": 55.476422314659224}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \\\"sensor.other.v2x_custom\\\") {\n    log_warning(\\\"sensor with id \\\", GetId(), \\\" is not a V2X sensor\\\");\n    return;\n  }\n  GetEpisode().Lock()->Send(GetContext(), std::move(message));\n}", "CodeBleu_score": 47.45785413435985}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \\\"sensor.other.v2x_custom\\\") {\n    log_warning(\\\"sensor.other.v2x_custom is not the sensor ID\\\");\n    return;\n  }\n  GetEpisode().Lock()->SendMessage(GetContext(), message);\n}", "CodeBleu_score": 35.386815104470784}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetDisplayId() != \\\"sensor.other.v2x_custom\\\") {\n    log_warning(\\\"sensor id is not sensor.other.v2x_custom\\\");\n    return;\n  }\n  GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 48.38680346690352}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  auto traffic_manager = GetWorld()->GetTrafficManager();\n  if (traffic_manager != nullptr) {\n    if (enabled) {\n      traffic_manager->RegisterVehicle(this, tm_port);\n    } else {\n      traffic_manager->UnregisterVehicle(this);\n    }\n  }\n}", "CodeBleu_score": 44.594021031013064}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    auto tm = TM::Get(tm_port);\n    if (tm != nullptr) {\n      tm->RegisterVehicle(GetActorId());\n    }\n  } else {\n    auto tm = TM::Get(tm_port);\n    if (tm != nullptr) {\n      tm->UnregisterVehicle(GetActorId());\n    }\n  }\n}", "CodeBleu_score": 47.91368372612999}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    auto tm = std::make_shared<TM>(tm_port);\n    tm->RegisterVehicle(GetId());\n    _traffic_manager = tm;\n  } else {\n    _traffic_manager->UnregisterVehicle(GetId());\n    _traffic_manager.reset();\n  }\n}", "CodeBleu_score": 45.63428375079106}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  auto walker = boost::static_pointer_cast<Walker>(GetParent());\n  auto &simulator = GetEpisode().Lock()->GetSimulator();\n  auto &navigation = simulator.GetNavigation();\n  navigation.Add(walker, walker->GetTransform().location);\n  walker->DisablePhysics();\n  walker->DisableCollision();\n}", "CodeBleu_score": 41.209742244926225}, {"code": "void WalkerAIController::Start(){\n\t  auto walker = GetParent();\n  auto simulator = GetEpisode().Lock()->GetSimulator();\n  auto navigation = simulator->GetNavigation();\n  auto transform = walker->GetTransform();\n  auto walker_id = navigation->Add(walker, transform.location);\n  walker->DisablePhysics();\n  walker->DisableCollision();\n  _walker_id = walker_id;\n}", "CodeBleu_score": 45.34012987405179}, {"code": "void WalkerAIController::Start(){\n\t  auto walker = GetActor()->GetParent();\n  auto navigation = GetEpisode()->GetWorld()->GetNavigation();\n  navigation->Add(walker);\n  walker->DisablePhysics();\n  walker->DisableCollision();\n}", "CodeBleu_score": 34.14898409327895}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set request to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \" (parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 82.60602021468998}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set max speed to \", max_speed, \"(parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 83.65246887613512}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set max speed to \", max_speed, \" (parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 84.17228800022963}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.8124700189432}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.8124700189432}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.8124700189432}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n    for (auto &signal : signals) {\n      if (stop_at_junction && signal->GetType() == SignalType::Junction) {\n        break;\n      }\n      unique_signals.insert(signal);\n    }\n\n    for (auto &signal : unique_signals) {\n      result.emplace_back(SharedPtr<Landmark>(new Landmark(signal)));\n    }\n\n    return result;\n  }", "CodeBleu_score": 44.31585338151432}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n\n    for (auto &signal : signals) {\n      if (unique_signals.find(signal) == unique_signals.end()) {\n        unique_signals.insert(signal);\n        SharedPtr<Waypoint> waypoint(new Waypoint(_parent, signal->GetWaypoint()));\n        SharedPtr<Landmark> landmark(new Landmark(waypoint, signal));\n        result.emplace_back(landmark);\n      }\n    }\n\n    if (stop_at_junction) {\n      for (auto &signal : signals) {\n        if (signal->GetType() == road::element::Signal::Type::Junction) {\n          return result;\n        }\n      }\n    }\n\n    return result;\n  }", "CodeBleu_score": 50.37914398390113}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::set<SharedPtr<Signal>> unique_signals(signals.begin(), signals.end());\n  for (auto signal : unique_signals) {\n    if (signal->GetType() == road::element::Signal::Type::TrafficLight) {\n      if (stop_at_junction) {\n        if (signal->GetJunction() != nullptr) {\n          continue;\n        }\n      }\n    }\n    result.emplace_back(SharedPtr<Landmark>(new Landmark(_parent, signal)));\n  }\n  return result;\n}", "CodeBleu_score": 44.649833722027374}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  auto episode = _episode.Lock();\n  auto identifier = episode->ApplySettings(settings, timeout);\n  if (settings.fixed_delta_seconds) {\n    auto delta_seconds = *settings.fixed_delta_seconds;\n    auto verification_attempts = 10;\n    auto verification_timeout = std::chrono::seconds(static_cast<int>(delta_seconds * verification_attempts));\n    auto verification_start = std::chrono::steady_clock::now();\n    for (auto i = 0u; i < verification_attempts; ++i) {\n      if (episode->GetSimulator()->Tick(verification_timeout)) {\n        auto verification_end = std::chrono::steady_clock::now();\n        auto verification_duration = std::chrono::duration_cast<std::chrono::milliseconds>(verification_end - verification_start);\n        auto expected_duration = std::chrono::milliseconds(static_cast<int>(delta_seconds * 1000));\n        auto delta = std::abs(verification_duration.count() - expected_duration.count());\n        auto tolerance = std::chrono::milliseconds(100);\n        if (delta > tolerance.count()) {\n          log_warning(\"fixed delta seconds is not correctly applied, expected:\", expected_duration.count(), \"ms, got:\", verification_duration.count(), \"ms\");\n        }\n        return identifier;\n      }\n    }\n  }\n  return identifier;\n}", "CodeBleu_score": 47.80990027024391}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  auto episode = _episode.Lock();\n  auto settings_id = episode->ApplySettings(settings, timeout);\n  if (settings.fixed_delta_seconds) {\n    auto fixed_delta = *settings.fixed_delta_seconds;\n    auto timeout_ms = std::chrono::milliseconds(static_cast<int64_t>(timeout.count() * 1000.0));\n    auto start = std::chrono::high_resolution_clock::now();\n    auto end = start + timeout_ms;\n    auto total_ticks = 0u;\n    auto ticks_with_bad_delta = 0u;\n    while (std::chrono::high_resolution_clock::now() < end) {\n      auto delta = episode->Tick(0.0f);\n      if (delta != fixed_delta) {\n        ++ticks_with_bad_delta;\n      }\n      ++total_ticks;\n    }\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() - start);\n    auto average_delta = duration.count() / static_cast<double>(total_ticks);\n    if (ticks_with_bad_delta > 0u) {\n      log_warning(\"Fixed delta time setting was not applied correctly.\",\n        \"The setting was applied for\", total_ticks, \"ticks, but\", ticks_with_bad_delta, \"ticks had a delta time of\", average_delta, \"s\");\n    }\n  }\n  return settings_id;\n}", "CodeBleu_score": 46.16469125230635}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  auto episode = _episode.Lock();\n  auto identifier = episode->ApplySettings(settings, timeout);\n  if (settings.fixed_delta_seconds) {\n    auto delta = *settings.fixed_delta_seconds;\n    auto max_attempts = 10u;\n    auto attempts = 0u;\n    auto success = false;\n    while (attempts < max_attempts) {\n      auto start = std::chrono::steady_clock::now();\n      episode->Tick(delta);\n      auto end = std::chrono::steady_clock::now();\n      auto elapsed = std::chrono::duration_cast<time_duration>(end - start);\n      if (elapsed < delta) {\n        std::this_thread::sleep_for(delta - elapsed);\n      }\n      auto ticks = episode->Tick(time_duration::zero());\n      auto expected_ticks = static_cast<uint32_t>(std::ceil(delta.count() / ticks.fixed_delta_seconds));\n      success = ticks.number_of_frames == expected_ticks;\n      if (success) {\n        break;\n      }\n      ++attempts;\n    }\n    if (!success) {\n      log_warning(\"fixed delta seconds setting is not correctly applied\");\n    }\n  }\n  return identifier;\n}", "CodeBleu_score": 48.074133318196786}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  auto const &a = segment.GetA();\n  auto const &b = segment.GetB();\n  auto const &p = point;\n  auto const &ab = b - a;\n  auto const &ap = p - a;\n  auto const &ab_length = ab.Length();\n  auto const &ab_squared_length = ab_length * ab_length;\n  auto const &ap_ab = Dot(ap, ab) / ab_squared_length;\n  auto const &projection = a + ab * ap_ab;\n  auto const &distance_to_projection = (projection - p).Length();\n  auto const &distance_to_a = (a - p).Length();\n  auto const &distance_to_b = (b - p).Length();\n  auto const &distance_to_projection_or_a = std::min(distance_to_projection, distance_to_a);\n  auto const &distance_to_projection_or_b = std::min(distance_to_projection, distance_to_b);\n  auto const &distance = std::min(distance_to_projection_or_a, distance_to_projection_or_b);\n  return std::make_pair(distance, distance_to_projection);\n}", "CodeBleu_score": 37.4386777835228}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  float squared_length = (end - start).SquaredLength();\n  if (squared_length == 0.0f) {\n    return {0.0f, (point - start).Length()};\n  }\n  float t = Dot(point - start, end - start) / squared_length;\n  t = std::min(1.0f, std::max(0.0f, t));\n  Vector2D projection = start + t * (end - start);\n  return {t * std::sqrt(squared_length), (point - projection).Length()};\n}", "CodeBleu_score": 35.30783897413869}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  if (vertices.size() == 0) {\n    return;\n  }\n  DEBUG_ASSERT(vertices.size() >= 3);\n  size_t i = GetVerticesNum() + 1;\n  AddVertices(vertices);\n  while (i < GetVerticesNum()) {\n    AddIndex(i - 1);\n    AddIndex(i);\n    AddIndex(i + 1);\n    ++i;\n  }\n}", "CodeBleu_score": 70.89951823151083}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t   DEBUG_ASSERT(vertices.size() >= 3);\n   size_t i = GetVerticesNum() + 2;\n   AddVertices(vertices);\n   while (i < GetVerticesNum()) {\n     AddIndex(i + 1);\n     AddIndex(i);\n     AddIndex(i - 1);\n     ++i;\n   }\n }", "CodeBleu_score": 69.94960296698956}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  if (vertices.size() == 0) {\n    return;\n  }\n  DEBUG_ASSERT(vertices.size() >= 3);\n  size_t i = GetVerticesNum() + 2;\n  AddVertices(vertices);\n  while (i < GetVerticesNum()) {\n    AddIndex(i - 1);\n    AddIndex(i);\n    AddIndex(i + 1);\n    ++i;\n  }\n}", "CodeBleu_score": 72.48424612105256}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    return;\n  }\n  if (!message->IsValid()) {\n    return;\n  }\n  auto buffer = _buffer_pool->GetBuffer(message->GetSize());\n  message->Serialize(buffer.get());\n  boost::asio::post(\n      _strand,\n      [this, buffer, message]() {\n        if (_socket.is_open()) {\n          _deadline.expires_after(_timeout);\n          boost::asio::async_write(\n              _socket,\n              boost::asio::buffer(buffer.get(), message->GetSize()),\n              boost::asio::bind_executor(\n                  _strand,\n                  [this, buffer = std::move(buffer), message](\n                      const boost::system::error_code &error,\n                      std::size_t bytes_transferred) {\n                    if (error) {\n                      LOG_ERROR(\"tcp multigpu server: error sending message:\", error.message());\n                      Close();\n                    } else if (bytes_transferred != message->GetSize()) {\n                      LOG_ERROR(\"tcp multigpu server: incomplete message sent\");\n                      Close();\n                    } else {\n                      DEBUG_ASSERT(bytes_transferred == message->GetSize());\n                    }\n                  }));\n        }\n      });\n}", "CodeBleu_score": 41.31411595426013}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    return;\n  }\n\n  boost::asio::post(_strand, [this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n\n    _deadline.expires_from_now(_timeout);\n\n    boost::asio::async_write(\n        _socket,\n        boost::asio::buffer(message->data(), message->size()),\n        boost::asio::bind_executor(_strand, [this, message](boost::system::error_code ec, std::size_t) {\n          HandleSent(ec, message);\n        }));\n  });\n}", "CodeBleu_score": 31.093858973438355}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message->IsValid()) {\n    boost::asio::post(\n        _strand,\n        [this, message]() {\n          if (_socket.is_open()) {\n            _deadline.expires_from_now(_timeout);\n            boost::asio::async_write(\n                _socket,\n                boost::asio::buffer(message->GetBuffer()),\n                boost::asio::bind_executor(\n                    _strand,\n                    [this, message](boost::system::error_code ec, std::size_t) {\n                      HandleSent(ec, message);\n                    }));\n          } else {\n            LOG_DEBUG(\"Primary::Write: socket closed\");\n          }\n        });\n  } else {\n    LOG_ERROR(\"Primary::Write: invalid message\");\n  }\n}", "CodeBleu_score": 33.777521806930345}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }", "CodeBleu_score": 50.60518374159282}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }", "CodeBleu_score": 50.60518374159282}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }", "CodeBleu_score": 50.60518374159282}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 15);\n  log_info(\"sending alive message\");\n  _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = _router->Read().get();\n  log_info(\"got response: \", response.buffer.data());\n}", "CodeBleu_score": 57.08294943155365}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 15);\n  log_info(\"sending alive message\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\"got a response: \", response.buffer.data());\n}", "CodeBleu_score": 63.790253255907345}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 14);\n  log_info(\"sending alive message\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\"got a response: \", response.buffer.data());\n}", "CodeBleu_score": 63.790253255907345}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  log_info(\"asking if a sensor is enabled on any secondary server\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_info(\"sensor not found on any secondary server\");\n  } else {\n    log_info(\"sensor found on secondary server\");\n    _router->Write(MultiGPUCommand::ENABLE_ROS, std::move(response.buffer));\n  }\n}", "CodeBleu_score": 62.685080612030355}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  log_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_error(\"sensor not found\");\n    return;\n  }\n\n  // log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  // return new_token;\n}", "CodeBleu_score": 48.97548790804937}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  log_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_error(\"sensor not found on any server\");\n    return;\n  }\n  log_info(\"sending enable ros command\");\n  auto port = *reinterpret_cast<uint16_t *>(response.buffer.data());\n  log_info(\"got a port: \", port);\n\n  // TODO: create a new secondary server to enable the sensor\n  // TODO: send a command to the secondary server to enable the sensor\n  // TODO: wait for the response\n  // TODO: process the response\n}", "CodeBleu_score": 65.94518865955268}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"GetToken: sensor already activated\");\n    return it->second.get_token();\n  } else {\n    log_info(\"GetToken: sensor not activated\");\n    // enable the sensor on a secondary server\n    auto new_token = SendGetToken(sensor_id);\n    // update the maps\n    _servers[sensor_id] = new_token;\n    return new_token;\n  }\n}", "CodeBleu_score": 49.8680442520942}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"GetToken: sensor already activated on server \", it->second);\n    return _tokens[it->second];\n  } else {\n    // if the sensor is not activated, enable it on a secondary server\n    SendEnableForROS(sensor_id);\n    // retrieve a new token\n    token_type new_token = SendGetToken(sensor_id);\n    // update the maps\n    _tokens[new_token.get_stream_id()] = new_token;\n    _servers[sensor_id] = new_token.get_stream_id();\n    log_info(\"GetToken: sensor \", sensor_id, \" enabled on server \", new_token.get_stream_id());\n    return new_token;\n  }\n}", "CodeBleu_score": 60.50655568809429}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"getting token for sensor\", sensor_id, \"from server\", it->second);\n    return it->second.get_token();\n  } else {\n    log_info(\"activating sensor\", sensor_id);\n    // enable the sensor on a secondary server\n    token_type new_token = SendGetToken(sensor_id);\n    // update the maps\n    _servers[sensor_id] = new_token;\n    log_info(\"activated sensor\", sensor_id, \"on server\", new_token.get_stream_id());\n    return new_token;\n  }\n}", "CodeBleu_score": 56.14665243036154}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file) {\n    return false;\n  }\n  file.seekg(0, std::ios::end);\n  std::vector<uint8_t> data(file.tellg());\n  file.seekg(0, std::ios::beg);\n  file.read(reinterpret_cast<char *>(data.data()), data.size());\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 54.03026378011574}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::in | std::ios::binary);\n  if (file.is_open()) {\n    std::vector<uint8_t> data{std::istreambuf_iterator<char>(file),\n                              std::istreambuf_iterator<char>()};\n    file.close();\n    return Load(data);\n  }\n  return false;\n}", "CodeBleu_score": 55.86505078247998}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::in | std::ios::binary | std::ios::ate);\n  if (!file.is_open()) {\n    LOG_ERROR(\"failed to open file:\", filename);\n    return false;\n  }\n  auto size = file.tellg();\n  std::vector<char> buffer(size);\n  file.seekg(0, std::ios::beg);\n  file.read(buffer.data(), size);\n  file.close();\n  return Load(buffer);\n}", "CodeBleu_score": 55.570716217566144}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  namespace cg = carla::geom;\n  dtCrowdAgentParams params;\n\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the index found\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    int index = it->second;\n    if (index != -1) {\n      // remove from the crowd\n      {\n        // critical section, force single thread running this\n        std::lock_guard<std::mutex> lock(_mutex);\n        _crowd->removeAgent(index);\n      }\n      // remove from the walker manager\n      _walker_manager.RemoveWalker(id);\n      // remove from the mappings\n      _mapped_walkers_id.erase(id);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  // get the index found\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    int index = it->second;\n    if (index != -1) {\n      // remove from the crowd\n      {\n        // critical section, force single thread running this\n        std::lock_guard<std::mutex> lock(_mutex);\n        _crowd->removeAgent(index);\n      }\n      // remove from the mappings\n      _mapped_vehicles_id.erase(id);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 76.23811411153811}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  namespace cg = carla::geom;\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  // search for the id in the walkers\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    // get the index found\n    int index = it->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent\n      _crowd->removeAgent(index);\n      // update the walker manager\n      _walker_manager.RemoveWalker(id);\n      // remove the id from the mappings\n      _mapped_walkers_id.erase(it);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  // search for the id in the vehicles\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    // get the index found\n    int index = it->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent\n      _crowd->removeAgent(index);\n      // remove the id from the mappings\n      _mapped_vehicles_id.erase(it);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 76.9482163788161}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t", "CodeBleu_score": 1.060187825043224}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the internal index\n  auto it = _mapped_walkers_id.find(id);\n  if (it == _mapped_walkers_id.end()) {\n    return false;\n  }\n\n  // get the index found\n  int index = it->second;\n  if (index == -1) {\n    return false;\n  }\n\n  // get the walker\n  const dtCrowdAgent *agent;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    agent = _crowd->getAgent(index);\n  }\n\n  // compute the squared distance\n  float sq_distance = distance * distance;\\\n\n  // use the crowd system to determine if a vehicle is nearby\n  int nb_vehicles = _crowd->getNbVehicles();\n  for (int i = 0; i < nb_vehicles; ++i) {\n    const dtCrowdVehicle *vehicle = _crowd->getVehicle(i);\n    if (vehicle->active) {\n      float dx = agent->npos[0] - vehicle->npos[0];\n      float dy = agent->npos[1] - vehicle->npos[1];\n      float dz = agent->npos[2] - vehicle->npos[2];\n      float sq_dist = dx * dx + dy * dy + dz * dz;\\\n      if (sq_dist < sq_distance) {\n        return true;\n      }\n    }\n  }\n\n  // return the result\n  return false;\n}", "CodeBleu_score": 56.21551956638255}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the internal index\n  auto it = _mapped_walkers_id.find(id);\n  if (it == _mapped_walkers_id.end()) {\n    return false;\n  }\n\n  // get the index found\n  int index = it->second;\n  if (index == -1) {\n    return false;\n  }\n\n  // get the walker\n  const dtCrowdAgent *agent;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    agent = _crowd->getAgent(index);\n  }\n\n  // compute the squared distance\n  float sq_distance = (agent->npos[0] - direction.x) * (agent->npos[0] - direction.x) + (agent->npos[1] - direction.y) * (agent->npos[1] - direction.y) + (agent->npos[2] - direction.z) * (agent->npos[2] - direction.z);\n\n  // use the crowd system to determine if a vehicle is nearby\n  return _crowd->hasVehicleNear(agent, sq_distance, distance * distance);\n}", "CodeBleu_score": 60.65524830797449}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // get the current route point\n  WalkerRoutePoint &point = info.route[info.currentIndex];\n\n  // create a visitor with the current context\n  WalkerEventVisitor visitor(info, delta);\n\n  // process the event at the current route point\n  return boost::apply_visitor(visitor, point.event);\n}", "CodeBleu_score": 52.645471418318394}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // get the current route point\n    WalkerRoutePoint &current = info.route[info.currentIndex];\n\n    // create a visitor with the current context\n    WalkerEventVisitor visitor(id, info, delta);\n\n    // process the event at the current route point\n    return boost::apply_visitor(visitor, current.event);\n}", "CodeBleu_score": 53.28279857632122}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // get the elements\n  WalkerEvent &event = info.route[info.currentIndex].event;\n  carla::geom::Location &target = info.route[info.currentIndex].location;\n  // get current position\n  carla::geom::Location current;\n  _nav->GetWalkerPosition(id, current);\n  // check distance to the target point\n  carla::geom::Vector3D dist(target.x - current.x, target.z - current.z, target.y - current.y);\n  if (dist.SquaredLength() <= 1) {\n    // if we are in the same point, we have to check the event\n    WalkerEventVisitor visitor(info, delta);\n    return boost::apply_visitor(visitor, event);\n  }\n  return EventResult::Continue;\n}", "CodeBleu_score": 46.684100252154195}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\\\"OpenDRIVE\\\").children(\\\"road\\\")) {\n    const int road_id = road_node.attribute(\\\"id\\\").as_int();\n    for (pugi::xml_node lane_section_node :\n         road_node.child(\\\"lanes\\\").children(\\\"laneSection\\\")) {\n      const double s = lane_section_node.attribute(\\\"s\\\").as_double();\n\n      // Lane Left\n      pugi::xml_node lane_left_node = lane_section_node.child(\\\"left\\\");\n      if (lane_left_node) {\n        ParseLanes(road_id, s, lane_left_node, map_builder);\n      }\n\n      // Lane Center\n      pugi::xml_node lane_center_node = lane_section_node.child(\\\"center\\\");\n      if (lane_center_node) {\n        ParseLanes(road_id, s, lane_center_node, map_builder);\n      }\n\n      // Lane Right\n      pugi::xml_node lane_right_node = lane_section_node.child(\\\"right\\\");\n      if (lane_right_node) {\n        ParseLanes(road_id, s, lane_right_node, map_builder);\n      }\n    }\n  }\n}", "CodeBleu_score": 58.84001766190916}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.children(\\\"road\\\")) {\n    const std::string id = road_node.attribute(\\\"id\\\").value();\n    for (pugi::xml_node lane_section_node : road_node.children(\\\"laneSection\\\")) {\n      const double s = lane_section_node.attribute(\\\"s\\\").as_double();\n      const pugi::xml_node left_lane_node = lane_section_node.child(\\\"left\\\");\n      const pugi::xml_node center_lane_node = lane_section_node.child(\\\"center\\\");\n      const pugi::xml_node right_lane_node = lane_section_node.child(\\\"right\\\");\n      ParseLanes(id, s, left_lane_node, map_builder);\n      ParseLanes(id, s, center_lane_node, map_builder);\n      ParseLanes(id, s, right_lane_node, map_builder);\n    }\n  }\n}", "CodeBleu_score": 50.47886308932992}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\\\"OpenDRIVE\\\").children(\\\"road\\\")) {\n    const int road_id = road_node.attribute(\\\"id\\\").as_int();\n    for (pugi::xml_node lane_section_node : road_node.children(\\\"lanes\\\")) {\n      const double s = lane_section_node.attribute(\\\"s\\\").as_double();\n      const pugi::xml_node left_lane_node = lane_section_node.child(\\\"left\\\");\n      const pugi::xml_node center_lane_node = lane_section_node.child(\\\"center\\\");\n      const pugi::xml_node right_lane_node = lane_section_node.child(\\\"right\\\");\n      ParseLanes(road_id, s, left_lane_node, center_lane_node, right_lane_node, map_builder);\n    }\n  }\n}", "CodeBleu_score": 41.61164140338154}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    if (_first_connected) {\n      _matched++;\n    } else {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    if (_matched > 0) {\n      _matched--;\n    } else {\n      std::cerr << \"Received publication disconnection notification for an unmatched publisher!\" << std::endl;\n    }\n  } else if (info.current_count_change != 0) {\n    std::cerr << \"Received publication matched notification with invalid count change \" << info.current_count_change << \"!\" << std::endl;\n  }\n}", "CodeBleu_score": 61.301674255514705}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change > 0) {\n    _matched = info.current_count;\n    if (!_first_connected) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change < 0) {\n    _matched = info.current_count;\n  } else {\n    std::cerr << \"Invalid count change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 69.39578186502334}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    _matched++;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched--;\n  } else {\n    std::cerr << \"Publisher matched with invalid count change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 61.37864713754322}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched = info.total_count;\n        _first_connected = true;\n    } else if (info.current_count_change == -1) {\n        _matched = info.total_count;\n        if (_matched == 0) {\n            _owner->destroy();\n        }\n    } else {\n        std::cout << \"Invalid change in subscription count: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 80.79348298877346}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched++;\n        if (!_first_connected) {\n            _first_connected = true;\n            RCLCPP_INFO(rclcpp::get_logger(\"CarlaSubscriberListenerImpl\"), \"Subscriber matched\");\n        }\n    } else if (info.current_count_change == -1) {\n        _matched--;\n        if (_matched == 0) {\n            RCLCPP_INFO(rclcpp::get_logger(\"CarlaSubscriberListenerImpl\"), \"Subscriber unmatched\");\n            _owner->destroy();\n        }\n    } else {\n        RCLCPP_ERROR(rclcpp::get_logger(\"CarlaSubscriberListenerImpl\"), \"Invalid change in subscription count\");\n    }\n}", "CodeBleu_score": 52.79940871346821}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched++;\n        if (!_first_connected) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched--;\n        if (_matched == 0) {\n            if (_owner) {\n                _owner->_destroy();\n            }\n        }\n    } else {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid current_count_change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 62.819089498434124}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!m_isGetKeyDefined)\n        return false;\n    carla_msgs::msg::dds_::CarlaCollisionEvent_ *p_type = static_cast<carla_msgs::msg::dds_::CarlaCollisionEvent_*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize()); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16)\t{\n        m_md5.init();\n        m_md5.update(m_keyBuffer,static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i<16;++i)    \t{\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else    \t{\n        memcpy(handle->value,m_keyBuffer,16);\n    }\n    return true;\n}", "CodeBleu_score": 68.31555684983105}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.getState()[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 93.55941007172139}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.output[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 97.34548868439035}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    // Serialize object\n    p_type->serialize(ser);\n    // Get serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Provides the actual length of the serialized message\n    return true;\n}", "CodeBleu_score": 82.70427594319152}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    try {\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 95.57679849269995}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? eprosima::fastrtps::rtps::CDR_BE : eprosima::fastrtps::rtps::CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    try {\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 89.60759407594568}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_set) {\n        return;\n    }\n\n    // decode\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // if the target has not been set yet, set it to this sysid\n    if (tracker.g.sysid_target == 0) {\n        tracker.g.sysid_target = packet.target_system;\n        tracker.request_stream_from_target(GCS_MAVLINK::STREAM_POSITION, 1);\n        tracker.request_stream_from_target(GCS_MAVLINK::STREAM_RAW_SENSORS, 1);\n    }\n\n    // if the target has been set, check if it is still this sysid\n    if (tracker.g.sysid_target != packet.target_system) {\n        // if it is not, set it to this sysid\n        tracker.g.sysid_target = packet.target_system;\n        tracker.request_stream_from_target(GCS_MAVLINK::STREAM_POSITION, 1);\n        tracker.request_stream_from_target(GCS_MAVLINK::STREAM_RAW_SENSORS, 1);\n    }\n\n    // flag that the target has been set\n    target_set = true;\n}", "CodeBleu_score": 46.67248135725568}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // return immediately if target has already been set\n\n    if (tracker.g.sysid_target != 0) {\n        return;\n    }\n\n    // decode\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // return immediately if heartbeat type is not a target\n    if (packet.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    // set target sysid\n    tracker.g.sysid_target = msg.sysid;\n\n    // request position and air pressure data streams\n    tracker.set_stream_rate(0, 10);\n    tracker.set_stream_rate(1, 10);\n    tracker.set_stream_rate(2, 10);\n    tracker.set_stream_rate(3, 10);\n    tracker.set_stream_rate(4, 10);\n    tracker.set_stream_rate(5, 10);\n    tracker.set_stream_rate(6, 10);\n    tracker.set_stream_rate(7, 10);\n    tracker.set_stream_rate(8, 10);\n\n    // flag that target has been set\n    tracker.g.sysid_target_set = true;\n}", "CodeBleu_score": 50.573325208263185}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // if the target has already been set, exit immediately\n\n    if (tracker.g.sysid_target != 0) {\n        return;\n    }\n\n    // decode\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // exit if not a heartbeat message\n    if (packet.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    // if the target sysid is not set, set it to the current sysid\n    if (tracker.g.sysid_target == 0) {\n        tracker.g.sysid_target = msg.sysid;\n        tracker.set_stream_rate(0, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1000);\n        tracker.set_stream_rate(0, MAVLINK_MSG_ID_SCALED_PRESSURE, 1000);\n    }\n\n    // flag that the target has been set\n    tracker.g.sysid_target_set = true;\n}", "CodeBleu_score": 53.5369525255186}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.flags.baro_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 78.85559328436062}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT ret = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (ret == MAV_RESULT_ACCEPTED) {\n        tracker.calibrate_altitude_needed = true;\n    }\n    return ret;\n}", "CodeBleu_score": 84.38216291780282}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.alt_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 70.36858486465054}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 4.769920375128312}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.target_component != 0) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    if (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n        if (packet.param1 == 1.0) {\n            // arm\n            tracker.arming.set_enabled(true);\n            return MAV_RESULT_ACCEPTED;\n        }\n        if (packet.param1 == 0.0) {\n            // disarm\n            tracker.arming.set_enabled(false);\n            return MAV_RESULT_ACCEPTED;\n        }\n    }\n\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 56.42472887904335}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT ret = MAV_RESULT_UNSUPPORTED;\n\n    if (packet.param1 > 1.0f) {\n        // if param1 is > 1.0f, disarm the servos\n        tracker.arming.disarm(AP_Arming::Method::GCS_COMMAND);\n        ret = MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 < 0.0f) {\n        // if param1 is < 0.0f, arm the servos\n        tracker.arming.arm(AP_Arming::Method::GCS_COMMAND);\n        ret = MAV_RESULT_ACCEPTED;\n    }\n\n    return ret;\n}", "CodeBleu_score": 52.48357757074793}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t  for (uint8_t i = 0; i < GCS_MAVLINK::num_channels; i++) {\n    if (GCS_MAVLINK::available_channel_instance(i) == MAV_COMP_ID_ALL) {\n      if (GCS_MAVLINK::get_channel_force_telemetry(i)) {\n        continue;\n      }\n      if (GCS_MAVLINK::get_channel_tx_buffer(i) >= MAVLINK_MSG_ID_HEARTBEAT_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n        GCS_MAVLINK::send_message_position(i, sysid, compid);\n        return;\n      }\n    }\n  }\n}", "CodeBleu_score": 45.14616684783995}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t", "CodeBleu_score": 5.5394447414533605}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t", "CodeBleu_score": 5.5394447414533605}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch != 0.0f) {\n        ef_pitch = ahrs.cos_roll() * pitch + ahrs.sin_roll() * ahrs.sin_pitch() * yaw;\n        ef_yaw = -ahrs.sin_roll() * pitch + ahrs.cos_roll() * ahrs.sin_pitch() * yaw;\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 74.03323025465617}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  const AP_AHRS &ahrs = AP::ahrs();\n  if (fabsf(ahrs.cos_pitch()) < 0.001f) {\n    return false;\n  }\n  ef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * ahrs.sin_pitch() * yaw;\n  ef_yaw = ahrs.sin_roll() * pitch + ahrs.cos_roll() * ahrs.sin_pitch() * yaw;\n  return true;\n}", "CodeBleu_score": 80.70410114719029}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    // body frame to earth frame pitch and yaw conversion\n    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch != 0.0f) {\n        ef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * ahrs.sin_pitch() * yaw;\n        ef_yaw = ahrs.sin_roll() * pitch + ahrs.cos_roll() * ahrs.sin_pitch() * yaw;\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 76.32205934482747}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    float yaw_cd, pitch_cd;\n    if (g.failsafe_throttle == FAILSAFE_THROTTLE_AUTO) {\n        yaw_cd = (g.failsafe_pitch_cd + g.failsafe_yaw_cd) / 2;\n        pitch_cd = (g.failsafe_pitch_cd - g.failsafe_yaw_cd) / 2;\n    } else {\n        yaw_cd = (int16_t)ahrs.yaw_sensor;\n        pitch_cd = (int16_t)ahrs.pitch_sensor;\n    }\n\n    // check if direction reversed\n    if (g.reverse_direction) {\n        yaw_cd = -yaw_cd;\n        pitch_cd = -pitch_cd;\n    }\n\n    // compute angle error\n    float yaw_error_cd = wrap_180_cd(ahrs.yaw_sensor - yaw_cd);\n    float pitch_error_cd = wrap_180_cd(ahrs.pitch_sensor - pitch_cd);\n\n    // convert errors to body frame\n    yaw_error_cd = -ahrs.cos_roll * ahrs.cos_pitch * yaw_error_cd + ahrs.sin_roll * pitch_error_cd;\n    pitch_error_cd = ahrs.sin_roll * ahrs.cos_pitch * yaw_error_cd + ahrs.cos_roll * pitch_error_cd;\n\n    // check if target distance is valid or no minimum distance is set\n    if (!fabsf(ahrs.groundspeed) < MIN(g.wp_navalt_min, g.wp_nav_alt_min) || g.wp_navalt_min == 0) {\n        // update pitch and yaw servos\n        tracker.set_pitch(pitch_error_cd);\n        tracker.set_yaw(yaw_error_cd);\n    }\n}", "CodeBleu_score": 45.390928248000236}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    if (GPS::has_new_data(chan)) {\n        if (gps.update(chan)) {\n            gps_last_update_ms = millis();\n            if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n                // check if we have a valid location\n                if (gps.location_valid()) {\n                    // if we don't have a home location yet, set it to the current location\n                    if (!AP::ahrs().home_is_set()) {\n                        AP::ahrs().set_home(gps.location());\n                    }\n                    // if we have a home location, set it to the current location\n                    else {\n                        AP::ahrs().set_home(gps.location());\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 33.449419039584555}, {"code": "void Tracker::update_GPS(void){\n\t    // update the GPS\n    gps.update();\n\n    // check if the last message time has changed and if the GPS status is at least 3D fix\n    if (gps.time_of_last_fix_changed() && gps.status_3D()) {\n        // if we are not in a ground start countdown\n        if (ground_start_countdown == 0) {\n            // check if the current location is valid\n            if (gps.location_valid()) {\n                // if the home location is not set, set it to the current location\n                if (!AP::ahrs().home_is_set()) {\n                    AP::ahrs().set_home(gps.location());\n                }\n            }\n        }\n    }\n\n    // if the ground start countdown is not zero, decrement it\n    if (ground_start_countdown > 0) {\n        --ground_start_countdown;\n    }\n\n    // if the ground start countdown reaches one, check if the current location is valid\n    if (ground_start_countdown == 1 && gps.location_valid()) {\n        // if the home location is not set, set it to the current location\n        if (!AP::ahrs().home_is_set()) {\n            AP::ahrs().set_home(gps.location());\n        }\n    }\n}", "CodeBleu_score": 42.76504700334135}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n\n    if (gps.last_message_time_ms() != last_gps_time_ms) {\n        last_gps_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            if (!have_gps_home &&\n                (gps.fix_type() == AP_GPS::GPS_FIX_3D ||\n                 gps.fix_type() == AP_GPS::GPS_FIX_3D_DGPS ||\n                 gps.fix_type() == AP_GPS::GPS_FIX_3D_RTK)) {\n                // we have a 3D fix, so record this as the home\n                // location\n                if (!gps.set_home(gps.location())) {\n                    gps.set_home_to_current_location();\n                }\n                have_gps_home = true;\n            }\n            if (gps.ground_speed() > GROUND_START_SPEED) {\n                // we're moving fast enough to consider ourselves\n                // on the ground\n                if (ground_start_countdown == 0) {\n                    // we've just started moving, so start the\n                    // countdown\n                    ground_start_countdown = GROUND_START_DELAY;\n                } else {\n                    // we're moving, so reduce the countdown\n                    if (--ground_start_countdown == 0) {\n                        // we've reached the end of the countdown\n                        // so set the home location\n                        if (!gps.set_home(gps.location())) {\n                            gps.set_home_to_current_location();\n                        }\n                        have_gps_home = true;\n                    }\n                }\n            } else {\n                // we're not moving fast enough, so reset the\n                // countdown\n                ground_start_countdown = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 50.034823598724124}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // update the servo\n\n    // calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= pitch_min_cd) {\n        new_servo_out = pitch_min_cd;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= pitch_max_cd) {\n        new_servo_out = pitch_max_cd;\n        g.pidPitch2Srv.reset_I();\n    }\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 42.653568313835635}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch < 0) {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.pitch_min);\n    } else {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.pitch_max);\n    }\n}", "CodeBleu_score": 21.996056886454767}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call the base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if the ARMING_CHECK_BARO is enabled, check the barometer reference\n    if (check_enabled(ARMING_CHECK_BARO)) {\n        // check the barometer reference\n        if (!copter.barometer.check_reference()) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Barometer reference\");\n            return false;\n        }\n\n        // check the barometer altitude against the inertial navigation altitude\n        if (fabsf(copter.inertial_nav.get_altitude() - copter.barometer.get_altitude()) > copter.g.baro_max_delta_alt) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Baro altitude delta\");\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 52.490846310466345}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer reference is consistent with inertial nav\n    if (copter.inertial_nav.get_filter_status() < AP_InertialNav::GPS_OK_FIX_3D &&\n        copter.inertial_nav.get_filter_status() < AP_InertialNav::INS_OK_FIX_3D) {\n        // we don't have a 3D fix, so we don't know if we're upright\n        // assume we are, and don't check the baro\n        return true;\n    }\n\n    // check barometer reference is consistent with inertial nav\n    float alt_diff = fabsf(copter.inertial_nav.get_altitude() - copter.barometer.get_altitude());\n    if (alt_diff > copter.g.fs_baro_max_diff) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Baro/Inertial Nav Alt Diff\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 49.83715596465766}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if barometer checks are disabled, return true\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    // check barometer reference\n    if (!check_barometer_reference(display_failure)) {\n        return false;\n    }\n\n    // check barometer altitude\n    if (!check_barometer_altitude(display_failure)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 25.492665361534684}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain.source() == AP_TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.terrain.source() == AP_TERRAIN_SOURCE_TERRAIN && copter.g.terrain_source_type == AP_TERRAIN_SOURCE_TYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 67.81152341311105}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if we are using a rangefinder, then we do not need a terrain database\n    if (copter.rangefinder_state.enabled && copter.rangefinder_state.has_data) {\n        return false;\n    }\n    // if we are using terrain database and RTL altitude is set to terrain, then we need a terrain database\n    if (copter.g.terrain_source == AP_TERRAIN_SOURCE_TERRAIN && copter.g.rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    // otherwise defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 64.05261688084455}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if the terrain source is from a rangefinder, then we don't need a terrain database\n    if (copter.rangefinder_state.source == RangeFinder::SOURCE_RANGEFINDER) {\n        return false;\n    }\n    // if the terrain source is from the terrain database and the RTL altitude type is terrain, then we need a terrain database\n    if (copter.rangefinder_state.source == RangeFinder::SOURCE_TERRAIN && copter.g.rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    // otherwise defer to the base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 64.58522329984808}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // call attitude controller\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 11.259248511475347}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for rate and position controllers\n    attitude_control.set_loop_time_from_scheduler(scheduler.get_last_loop_time());\n\n    // run low level rate controllers\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 27.233042978212275}, {"code": "void Copter::run_rate_controller(){\n\t    // call attitude controller\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 11.259248511475347}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // exit immediately if no change in location\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // exit immediately if not in guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // check if the old and new locations are the same\n    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.alt == new_loc.alt && old_loc.terrain_alt == new_loc.terrain_alt && old_loc.relative_alt == new_loc.relative_alt) {\n        return false;\n    }\n\n    // check if the altitude frames are the same\n    if (old_loc.relative_alt && new_loc.relative_alt) {\n        return false;\n    }\n\n    if (!old_loc.relative_alt && !new_loc.relative_alt) {\n        return false;\n    }\n\n    // set the new target\n    return flightmode->set_wp(new_loc);\n}", "CodeBleu_score": 52.70192677156484}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.same_latlon(new_loc) && old_loc.relative_alt && new_loc.relative_alt && old_loc.relative_alt == new_loc.relative_alt) {\n        return false;\n    }\n    if (!set_target_location(new_loc)) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 52.644616789654265}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.same_latlon(new_loc) && old_loc.relative_alt && new_loc.relative_alt && old_loc.relative_alt == new_loc.relative_alt) {\n        // we're already at the correct location\n        return false;\n    }\n\n    // set the target location\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 55.479964754173935}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AUX_SWITCH_HIGH) {\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            // if set_mode fails, reload the switch's parameter\n            rc().reset_mode_switch(get_aux_function());\n        }\n    } else if (copter.mode() == mode) {\n        // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the switch\n        rc().reset_mode_switch(get_aux_function());\n    }\n}", "CodeBleu_score": 55.53829161895612}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (copter.failsafe.radio) {\n        return;\n    }\n\n    if (copter.failsafe.radio_counter != 0) {\n        return;\n    }\n\n    if (copter.control_mode == mode) {\n        // if the switch is in the high position, set the mode\n        if (ch_flag == AUXSWITCH_HIGH) {\n            if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n                return;\n            }\n        }\n        // if the switch is in the low position, reset the mode switch\n        if (ch_flag == AUXSWITCH_LOW) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 57.67327141569343}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (copter.control_mode == mode) {\n        // if the switch is in the HIGH position, reset it\n        if (ch_flag == AUX_SWITCH_HIGH) {\n            rc().reset_mode_switch();\n        }\n    } else {\n        // if the switch is in the HIGH position, attempt to change modes\n        if (ch_flag == AUX_SWITCH_HIGH) {\n            if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n                rc().reset_mode_switch();\n            }\n        }\n    }\n}", "CodeBleu_score": 60.48531640227732}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    float roll_trim = channel_roll->get_control_in() / 4500.0f;\n    float pitch_trim = channel_pitch->get_control_in() / 4500.0f;\n    ahrs.add_trim(Vector3f(roll_trim, pitch_trim, 0));\n    gcs().send_text(MAV_SEVERITY_INFO, PSTR(\"Trim Saved\"));\n    LOG_INFO(LogEvent::SAVE_TRIM);\n}", "CodeBleu_score": 53.469897260915424}, {"code": "void Copter::save_trim(){\n\t    // calculate roll trim\n    float roll_trim = channel_roll->get_control_in() / 4500.0f;\n    // calculate pitch trim\n    float pitch_trim = channel_pitch->get_control_in() / 4500.0f;\n    // add roll trim to ahrs\n    ahrs.add_roll_trim(roll_trim);\n    // add pitch trim to ahrs\n    ahrs.add_pitch_trim(pitch_trim);\n    // log event\n    AP_Notify::flags.save_trim = true;\n    // send confirmation message\n    gcs().send_text(MAV_SEVERITY_INFO, \\\"Saved roll and pitch trim\\\");\n}", "CodeBleu_score": 56.678805622119356}, {"code": "void Copter::save_trim(){\n\t    // exit immediately if not armed\n    if (!motors.armed()) {\n        return;\n    }\n\n    // calculate the trim values\n    const float roll_trim = channel_roll->get_control_in() / 4500.0f;\n    const float pitch_trim = channel_pitch->get_control_in() / 4500.0f;\n\n    // add to ahrs\n    ahrs.add_trim(Vector3f(roll_trim, pitch_trim, 0));\n\n    // log and send message\n    AP_Notify::flags.save_trim = true;\n    gcs().send_text(MAV_SEVERITY_INFO, \\\"Saved roll and pitch trims to EEPROM\\\");\n}", "CodeBleu_score": 50.96286581497693}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  // get velocity\n  Vector3f velocity = copter.inertial_nav.get_velocity();\n  // get speed squared\n  float speed_sq = velocity.length_squared();\n  // if position is valid and speed is above minimum threshold, update look-ahead yaw angle\n  if (copter.inertial_nav.get_position_ok() && speed_sq > MIN_LOOK_AHEAD_SPEED * MIN_LOOK_AHEAD_SPEED) {\n    // update look-ahead yaw angle\n    look_ahead_yaw_cd = degrees(atan2f(velocity.y, velocity.x)) * 100.0f;\n  }\n  // return look-ahead yaw angle\n  return look_ahead_yaw_cd;\n}", "CodeBleu_score": 58.145184297692566}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float look_ahead_yaw = 0.0f;\n    float speed_xy = copter.inertial_nav.get_velocity_xy();\n    float speed_z = fabsf(copter.inertial_nav.get_velocity_z());\n    if (copter.inertial_nav.get_position_ok() && speed_xy > 0.1f && speed_z < 100.0f) {\n        // calculate the yaw angle to look ahead based on the velocity\n        look_ahead_yaw = atan2f(copter.inertial_nav.get_velocity_y(), copter.inertial_nav.get_velocity_x()) * 180.0f / M_PI_F;\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 41.87053576046323}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // get velocity\n    Vector3f vel = copter.inertial_nav.get_velocity_neu();\n    float speed_sq = vel.length_squared();\n\n    // if we have a valid position and the speed is above a threshold, calculate a yaw based on velocity\n    if (copter.inertial_nav.get_position_xy_valid() && speed_sq > 0.1f) {\n        float yaw_cd = atan2f(vel.y, vel.x);\n        return yaw_cd * 180.0f / M_PI;\n    }\n\n    return 0.0f;\n}", "CodeBleu_score": 48.292267703533135}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t", "CodeBleu_score": 3.490344250163065}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t", "CodeBleu_score": 3.490344250163065}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (check_enabled(ARMING_CHECK_DISABLED)) {\n        return true;\n    }\n\n    if (check_enabled(ARMING_CHECK_WATCHDOG)) {\n        return true;\n    }\n\n    if (method == AP_Arming::Method::RUDDER) {\n        if (plane.g.rudder_enabled && plane.channel_throttle->get_control_in() != 0) {\n            check_failed(ARMING_CHECK_RUDDER, true, \"Rudder arming disabled\");\n            return false;\n        }\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 57.22821691182441}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (is_armed()) {\n        return true;\n    }\n\n    // if we are using a gps, then we should have a location\n    if (plane.gps.enabled() && plane.gps.status() < AP_GPS::GPS_OK_FIX_2D) {\n        return false;\n    }\n\n    // check if the plane should be armed\n    if (!should_arm()) {\n        return false;\n    }\n\n    // call pre-arm checks\n    if (!pre_arm_checks(true)) {\n        return false;\n    }\n\n    // arm the motors\n    if (!motors->arm()) {\n        return false;\n    }\n\n    // set the home location if necessary\n    if (plane.home_is_set == false) {\n        plane.set_home_to_current_location();\n    }\n\n    // set the current location to home\n    plane.set_current_loc_from_home_for_pid();\n\n    // update the soft armed state\n    change_arm_state();\n\n    // set the delay arming flag\n    plane.delay_arming = true;\n\n    // send a status text\n    plane.gcs_send_text_P(MAV_SEVERITY_INFO, PSTR(\"Throttle armed\"));\n\n    // log event\n    AP::logger().Write_Event(LogEvent::ARMING_ARM);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 42.498439367650775}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (plane.g.disarm_on_lockdown) {\n        // if lockdown is enabled, disarm immediately\n        disarm(AP_Arming::Method::DISARM_LOCKDOWN);\n        return false;\n    }\n\n    // check if arming checks are disabled\n    if (!check_enabled(ARMING_CHECK_ALL)) {\n        return AP_Arming::arm(method, false);\n    }\n\n    // check if arming checks are enabled\n    if (do_arming_checks) {\n        if (!pre_arm_checks(false)) {\n            return false;\n        }\n    }\n\n    // if arming checks are disabled, we need to perform them here\n    if (!check_enabled(ARMING_CHECK_ALL)) {\n        if (!pre_arm_checks(true)) {\n            return false;\n        }\n    }\n\n    // if arming checks are enabled, we need to perform them here\n    if (check_enabled(ARMING_CHECK_ALL)) {\n        if (!pre_arm_checks(true)) {\n            return false;\n        }\n    }\n\n    // call parent class arm\n    return AP_Arming::arm(method, true);\n}", "CodeBleu_score": 45.7024078429095}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // check if the vehicle is already armed\n    if (pre_armed) {\n        return true;\n    }\n\n    // check if the vehicle has a disarm button configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_disarm_button = true;\n        }\n        return false;\n    }\n\n    // call the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 72.25251863394885}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed) {\n        // already armed\n        return true;\n    }\n\n    // check if the vehicle has a disarm button configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Disarm button not configured\");\n        }\n        return false;\n    }\n\n    // run the checks from AP_Arming\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 75.96365349491938}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (is_armed()) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_shift :\n                has_shift_function = true;\n                break;\n            case JSButton::k_arm_toggle :\n                return true;\n            case JSButton::k_disarm :\n                return true;\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    if (has_shift_function) {\n        for (uint8_t i = 0; i < 16; i++) {\n            switch (sub.get_button(i)->function(true)) {\n                case JSButton::k_arm_toggle :\n                case JSButton::k_disarm :\n                    return true;\n            }\n        }\n    }\n\n    if (display_failure) {\n        AP_Notify::flags.pre_arm_disarm_failure = true;\n    }\n    return false;\n}", "CodeBleu_score": 47.42761087411216}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float yaw_rad = ToRad(ahrs.yaw);\n    float ne_x = x * cosf(yaw_rad) + y * sinf(yaw_rad);\n    float ne_y = -x * sinf(yaw_rad) + y * cosf(yaw_rad);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 56.173737674063354}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float yaw = ahrs.yaw;\n    float ne_x = x * cosf(yaw) - y * sinf(yaw);\n    float ne_y = x * sinf(yaw) + y * cosf(yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.80568054717521}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float yaw = ahrs.yaw;\n    float ne_x = x * cos(yaw) + y * sin(yaw);\n    float ne_y = -x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.55314467142887}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Check if the yaw angle is within the acceptable range\n    if (packet.param4 > 360 || packet.param4 < 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if the param4 value is within the acceptable range\n    if (packet.param4 > 360 || packet.param4 < 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set the yaw heading using the provided parameters\n    sub.mode_auto.set_auto_yaw_heading(packet.param4, packet.param5);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 47.6229317100978}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Check if the yaw angle is within acceptable range\n    if (packet.param4 < 0.0f || packet.param4 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if param4 is within acceptable range\n    if (packet.param4 < 0.0f || packet.param4 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set the yaw heading using the provided parameters\n    sub.set_yaw_heading(packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 43.41382160663998}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Check if the yaw angle is within the acceptable range\n    if (packet.param4 < 0 || packet.param4 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if the param4 value is within the acceptable range\n    if (packet.param4 < 0 || packet.param4 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set the yaw heading using the provided parameters\n    sub.set_yaw_heading(packet.param4, 0);\n\n    // Return MAV_RESULT_ACCEPTED to indicate success\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 42.628877189472426}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        return (uint8_t)(sub.pos_control.get_yaw_error_cd() / 200);\n    }\n    return 0;\n}", "CodeBleu_score": 78.87096964470777}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    AP_AHRS &ahrs = AP::ahrs();\n    Location global_position_current;\n    UNUSED_RESULT(ahrs.get_location(global_position_current));\n\n    //return units are degrees divided by 2\n    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        return (global_position_current.bearing_cd / 200);\n    }\n    return 0;\n}", "CodeBleu_score": 70.30460136012772}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        return (sub.mission.get_current_nav_bearing() * 2) / 100;\n    }\n    return 0;\n}", "CodeBleu_score": 79.45085907473694}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.57185063097107}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.57185063097107}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.57185063097107}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    if (!AP::ahrs().home_is_set()) {\n        if (motors->armed()) {\n            if (set_home_to_current_location()) {\n                AP::logger().Write_Event(LogEvent::SET_HOME);\n            }\n        } else {\n            set_home_to_EKF_origin();\n        }\n    }\n}", "CodeBleu_score": 31.12233859612782}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ap.home_is_set == true) {\n        return;\n    }\n    if (motors.armed()) {\n        // if motors are armed, home is set to current location\n        set_home_to_current_location(false);\n    } else {\n        // if motors are not armed, home is set to EKF location\n        set_home_to_current_location(true);\n    }\n}", "CodeBleu_score": 42.672524307897895}, {"code": "void Sub::update_home_from_EKF(){\n\t\n    // exit immediately if home is already set\n    if (set_home_to_current_location()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors->armed()) {\n        set_home_to_current_location(true);\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to current EKF location\n    set_home_to_current_location(false);\n}", "CodeBleu_score": 36.74095038849011}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t    // if not armed or throttle at zero, set throttle to zero and exit immediately\n    if (!motors->armed() || sub.mode_acro.get_pilot_desired_throttle_rate() == 0) {\n        // set motors to zero throttle\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        // set attitude controller to relax\n        attitude_control->relax_attitude_controllers();\n        // exit immediately\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(target_roll, target_pitch,\n                                  sub.mode_acro.get_pilot_desired_throttle(),\n                                  sub.mode_acro.get_pilot_desired_lateral(),\n                                  sub.mode_acro.get_pilot_desired_forward(),\n                                  sub.mode_acro.get_pilot_desired_yaw_rate());\n\n    // run attitude controller\n    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, sub.mode_acro.get_pilot_desired_yaw_rate());\n}", "CodeBleu_score": 51.29075576583213}, {"code": "void ModeAcro::run(){\n\t    // if not armed set throttle to zero and exit immediately\n    if (!motors->armed()) {\n        // set throttle to zero if not in a failsafe or autopilot controlled mode\n        if (!(failsafe.radio || autopilot)) {\n            motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n            attitude_control->set_throttle_out(0, true, 0);\n        }\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set spool state to unlimited\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert the input to the desired body frame rate\n    float rate_roll, rate_pitch, rate_yaw;\n    get_pilot_desired_angle_rates(rate_roll, rate_pitch, rate_yaw);\n\n    // run attitude controller\n    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, rate_yaw);\n\n    // process pilot's roll and pitch input\n    if (g.acro_lock_roll) {\n        rate_roll = 0;\n    }\n    if (g.acro_lock_pitch) {\n        rate_pitch = 0;\n    }\n\n    // set motors to desired values\n    motors->set_forward(channel_roll->norm_input() * g.acro_deadzone + g.acro_pitch_scale * rate_pitch);\n    motors->set_lateral(channel_pitch->norm_input() * g.acro_deadzone + g.acro_roll_scale * rate_roll);\n}", "CodeBleu_score": 57.30674470912616}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set position controller to position control mode\n    set_mode(POSITION_CONTROL, MODE_REASON_GUIDED_ENABLED);\n\n    // set waypoint destination to stopping point\n    Vector3f stopping_point = guided_limit.start_pos;\n    wp_nav.set_wp_destination(stopping_point);\n\n    // set yaw state\n    auto_yaw.set_mode_to_default(true);\n}", "CodeBleu_score": 25.762319267375876}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set mode to position control\n\",\n    set_mode(Mode::Number::POSITION_CONTROL);\n\n    // initialize waypoint controller\n\",\n    pos_control->init_z_controller();\n    pos_control->init_vel_controller_xy();\n    pos_control->init_accel_controller_xy();\n\n    // get stopping point\n\",\n    Vector3f stopping_point = sub.guided_pos_target_cm;\n\n    // set destination\n\",\n    pos_control->set_pos_target_z_from_climb_rate_cm(stopping_point.z, G_Dt);\n    pos_control->set_pos_target_xy(stopping_point.xy());\n\n    // initialise yaw\n\",\n    auto_yaw.set_mode(get_default_auto_yaw_mode(false), sub.guided_angle_yaw_cd);\n\n    // start yaw controller\n\",\n    auto_yaw.start_yaw();\n\n    // start time\n\",\n    guided_limit.start_time = AP_HAL::millis();\n\n    // record start position\n\",\n    guided_limit.start_pos = sub.current_loc.alt;\n}", "CodeBleu_score": 37.102312866421684}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set mode to position control\n    set_mode(Mode::Number::POSITION_CONTROL);\n\n    // initialise waypoint controller\n    wp_nav.wp_and_spline_init();\n\n    // set stopping point\n    Vector3f stopping_point = sub.pos_ned;\n\n    // set waypoint destination\n    wp_nav.set_wp_destination(stopping_point);\n\n    // initialise yaw\n    if (g.wp_nav_yaw) {\n        // initialise yaw to waypoint destination\n        guided_angle_state.yaw_cd = wp_nav.get_yaw();\n\n    } else {\n        // initialise yaw to current heading\n        guided_angle_state.yaw_cd = ahrs.yaw_sensor;\n    }\n\n    // initialise yaw speed\n    guided_angle_state.yaw_rate_cds = 0;\n\n    // initialise pitch and roll to zero\n    guided_angle_state.roll_cd = 0;\n    guided_angle_state.pitch_cd = 0;\n\n    // initialise climb rate to zero\n    guided_angle_state.climb_rate_cms = 0;\n\n    // initialise timeout\n    update_time_ms = AP_HAL::millis();\n\n    // initialise timeout\n    guided_limit.timeout_ms = 0;\n\n    // initialise start time\n    guided_limit.start_time = AP_HAL::millis();\n\n    // initialise start position\n    guided_limit.start_pos = sub.pos_ned;\n\n    // initialise altitude limits\n    guided_limit.alt_min_cm = 0;\n    guided_limit.alt_max_cm = 0;\n\n    // initialise horizontal position limit\n    guided_limit.horiz_max_cm = 0;\n\n    // set guided_pos_control_start to true\n    guided_pos_control_start = true;\n}", "CodeBleu_score": 32.068208450111804}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical maximum speed and acceleration\n    sub.pos_control.set_max_speed_accel_z(-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up(), sub.wp_nav.get_accel_z());\n\n    // initialise horizontal speed and acceleration\n    sub.pos_control.set_max_speed_accel_xy(sub.wp_nav.get_default_speed_xy(), sub.wp_nav.get_accel_xy());\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 36.19683069118106}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set to velocity control mode\n\"\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical speed and acceleration\n\"\n    pos_control.set_max_speed_accel_z(-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up(), sub.wp_nav.get_accel_z());\n\n    // initialise horizontal speed and acceleration\n\"\n    pos_control.set_max_speed_accel_xy(sub.wp_nav.get_default_speed_xy(), sub.wp_nav.get_accel_xy());\n\n    // initialise velocity controller\n\"\n    pos_control.init_z_controller();\n    pos_control.init_xy_controller();\n\n    // initialise yaw\n\"\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 51.737878040898536}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical speed and acceleration\n    sub.pos_control.set_max_speed_accel_z(-g.pilot_vel_max_down, g.pilot_vel_max_up, g.pilot_vel_z_max_up, g.pilot_vel_z_max_down);\n    sub.pos_control.set_max_speed_accel_xy(g.pilot_vel_max_xy, g.pilot_vel_max_back_xy);\n\n    // initialise horizontal velocity controller\n    sub.pos_control.set_max_speed_accel_xy(g.pilot_vel_max_xy, g.pilot_vel_max_back_xy);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 41.30367602909105}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    if (guided_limit.timeout_ms > 0) {\n        uint32_t tnow = AP_HAL::millis();\n        if (tnow - guided_limit.start_time > guided_limit.timeout_ms) {\n            return true;\n        }\n    }\n\n    // check if we have gone below the minimum altitude\n    if (!is_zero(guided_limit.alt_min_cm)) {\n        float alt = inertial_nav.get_altitude();\n        if (alt < guided_limit.alt_min_cm) {\n            return true;\n        }\n    }\n\n    // check if we have gone above the maximum altitude\n    if (!is_zero(guided_limit.alt_max_cm)) {\n        float alt = inertial_nav.get_altitude();\n        if (alt > guided_limit.alt_max_cm) {\n            return true;\n        }\n    }\n\n    // check if we have gone beyond the horizontal distance limit\n    if (!is_zero(guided_limit.horiz_max_cm)) {\n        float horiz_move = (guided_limit.start_pos - inertial_nav.get_position_neu_cm()).toproperties();\n        if (horiz_move > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be within limits\n    return false;\n}", "CodeBleu_score": 63.956786164328875}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    uint32_t now = AP_HAL::millis();\n    if (guided_limit.timeout_ms > 0 && (now - guided_limit.start_time) > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check if we have gone below the minimum altitude\n    float altitude = inertial_nav.get_altitude();\n    if (guided_limit.alt_min_cm > 0.0f && altitude < guided_limit.alt_min_cm) {\n        return true;\n    }\n\n    // check if we have gone above the maximum altitude\n    if (guided_limit.alt_max_cm > 0.0f && altitude > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // check if we have gone beyond the horizontal distance limit\n    if (guided_limit.horiz_max_cm > 0.0f && (guided_limit.start_pos - inertial_nav.get_position_neu_cm()).topostype() > guided_limit.horiz_max_cm) {\n        return true;\n    }\n\n    // if we got this far we must be within limits\n    return false;\n}", "CodeBleu_score": 52.19627725140681}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    uint32_t now = AP_HAL::millis();\n    if (guided_limit.timeout_ms > 0 && (now - guided_limit.start_time) > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check if we have gone below the minimum altitude\n    if (guided_limit.alt_min_cm > 0 && inertial_nav.get_altitude() < guided_limit.alt_min_cm) {\n        return true;\n    }\n\n    // check if we have gone above the maximum altitude\n    if (guided_limit.alt_max_cm > 0 && inertial_nav.get_altitude() > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // check if we have gone beyond the horizontal distance limit\n    if (guided_limit.horiz_max_cm > 0) {\n        const Vector3f &curr_pos = inertial_nav.get_position_neu_cm();\n        float horiz_move_cm = get_horizontal_distance_cm(guided_limit.start_pos, curr_pos);\n        if (horiz_move_cm > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be within limits\n    return false;\n}", "CodeBleu_score": 58.85485934650232}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    static uint32_t last_motor_test_request_ms = 0;\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - last_motor_test_request_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 55.84206098366826}, {"code": "bool Sub::verify_motor_test(){\n\t    uint32_t tnow = AP_HAL::millis();\n\n    // if the last motor test command was more than 2 seconds ago, we assume the motors are not moving\n    if (tnow > last_do_motor_test_ms + 2000) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test timed out\\\");\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n\n    // if we get a motor test command, update the time\n    if (motor_test_request) {\n        last_do_motor_test_ms = tnow;\n        motor_test_request = false;\n    }\n\n    // if the test has been running for more than 10 seconds, we assume the motors are moving\n    if (tnow > last_do_motor_test_ms + 10000) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test passed\\\");\n        ap.motor_test = false;\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 54.6315023372846}, {"code": "bool Sub::verify_motor_test(){\n\t    uint32_t tnow = AP_HAL::millis();\n    if (tnow - last_do_motor_test_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        pass = false;\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 53.02824778969426}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t", "CodeBleu_score": 3.4981965412920477}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // retrieve roll and pitch targets from wp_nav\n\n    float roll_cd, pitch_cd;\n    wp_nav.get_roll_pitch(roll_cd, pitch_cd);\n\n    // constrain roll and pitch to the limits\n\n    roll_cd = constrain_float(roll_cd, -roll_limit_cd, roll_limit_cd);\n    pitch_cd = constrain_float(pitch_cd, -pitch_limit_cd, pitch_limit_cd);\n\n    // convert roll and pitch from centidegrees to degrees\n\n    float roll_deg = roll_cd * 0.01f;\n    float pitch_deg = pitch_cd * 0.01f;\n\n    // rotate roll and pitch to match the front of the vehicle\n\n    float cos_yaw = cos(ahrs.yaw * 0.0174532925f);\n    float sin_yaw = sin(ahrs.yaw * 0.0174532925f);\n    lateral_out = roll_deg * cos_yaw - pitch_deg * sin_yaw;\n    forward_out = roll_deg * sin_yaw + pitch_deg * cos_yaw;\n}", "CodeBleu_score": 33.7875199138537}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // retrieve roll and pitch targets from wp_nav\n    float roll_cd, pitch_cd;\n    wp_nav.get_roll_pitch(roll_cd, pitch_cd);\n\n    // constrain roll and pitch to the limits\n    roll_cd = constrain_float(roll_cd, ahrs.roll_in_deg_range(roll_cd - ahrs.roll_trim_cd), ahrs.roll_in_deg_range(roll_cd - ahrs.roll_trim_cd));\n    pitch_cd = constrain_float(pitch_cd, ahrs.pitch_in_deg_range(pitch_cd - ahrs.pitch_trim_cd), ahrs.pitch_in_deg_range(pitch_cd - ahrs.pitch_trim_cd));\n\n    // normalize roll and pitch\n    float roll_out, pitch_out;\n    wp_nav.get_roll_pitch_from_heading(roll_out, pitch_out, ahrs.yaw_sensor);\n\n    // apply to lateral and forward controller\n    lateral_out = roll_out * ahrs.cos_roll_offset() + pitch_out * ahrs.sin_roll_offset();\n    forward_out = pitch_out * ahrs.cos_roll_offset() - roll_out * ahrs.sin_roll_offset();\n}", "CodeBleu_score": 39.111530272371006}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\n    // read barometer\n    barometer.read();\n\n    // update calibration if necessary\n    if (barometer.healthy() && barometer.get_altitude() > 0) {\n        barometer.calibrate();\n    }\n\n    // update sensor health\n    if (depth_sensor.present()) {\n        depth_sensor.update_health(barometer.healthy());\n    }\n}", "CodeBleu_score": 62.79473505626183}, {"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    if (barometer.healthy() && barometer.get_altitude() > 0) {\n        barometer_calibration.update_calibration(barometer.get_altitude());\n    }\n    if (depth_sensor.healthy()) {\n        depth_sensor.update();\n    }\n}", "CodeBleu_score": 61.67965936165758}, {"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    if (depth_sensor.present()) {\n        depth_sensor.update();\n        if (depth_sensor.healthy() && barometer.healthy()) {\n            // if the depth sensor is healthy and the barometer is healthy, update the depth sensor health\n            depth_sensor.set_healthy(true);\n        } else {\n            // if the depth sensor is not healthy or the barometer is not healthy, update the depth sensor health\n            depth_sensor.set_healthy(false);\n        }\n    }\n\n    if (barometer.healthy() && barometer.altitude() > 0) {\n        // if the barometer is healthy and the altitude is above zero, update the barometer calibration\n        barometer.calibrate(barometer.altitude());\n    }\n}", "CodeBleu_score": 54.05220662046517}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf failsafe has triggered\n    if (failsafe.ekf) {\n        return false;\n    }\n\n    // return true if EKF is inertial only\n    if (ahrs.inertial_nav_ok()) {\n        return true;\n    }\n\n    // return true if motors are disarmed\n    if (motors.armed()) {\n        return false;\n    }\n\n    // return true if EKF is in a constant position mode\n    if (ins.get_hgt_ctrl_mode() == const_hgt_ctrl_mode) {\n        return false;\n    }\n\n    // return true if EKF has a good horizontal position\n    if (ekf_ok_horiz()) {\n        return true;\n    }\n\n    // return true if EKF has a good vertical position\n    if (ekf_ok_vert()) {\n        return true;\n    }\n\n    // return true if we have a good absolute position\n    if (position_ok_xy()) {\n        return true;\n    }\n\n    // we don't have a good position estimate\n    return false;\n}", "CodeBleu_score": 24.386001322264466}, {"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf failsafe has triggered\n    if (failsafe.ekf) {\n        return false;\n    }\n\n    // return false if motors are not armed\n    if (!motors.armed()) {\n        return false;\n    }\n\n    // return false if inertial navigation is not available\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // return true if ekf is inertial navigation only mode\n    if (ahrs.inertial_nav_ok()) {\n        return true;\n    }\n\n    // return false if we are in constant position mode\n    if (ahrs.fly_forward()) {\n        return false;\n    }\n\n    // return false if we do not have a valid position\n    if (!ahrs.home_is_set() || !ahrs.home_is_valid()) {\n        return false;\n    }\n\n    // return true if we have a good absolute position estimate\n    return ahrs.have_absolute_position();\n}", "CodeBleu_score": 55.8387413854734}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // set gps-checks to success if GPS checks are disabled\n    if (!check_enabled(ARMING_CHECK_GPS)) {\n        return true;\n    }\n\n    // check if GPS is connected and has a good position\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!AP::ahrs().prearm_check(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (AP::ahrs().in_failure_mode(AP_AHRS::FAILURE_EKF_GPS)) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if the position estimate is valid\n    if (!AP::ahrs().prearm_checks(display_failure)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 45.37940832558493}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t", "CodeBleu_score": 1.9477481621875286}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't require a position control mode, we're done\n    if (!rover.control_mode->requires_position_control()) {\n        return true;\n    }\n\n    // check parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (rover.failsafe.gps) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"GPS failsafe active\");\n        return false;\n    }\n\n    // ensure position estimate is valid\n    if (!AP::ahrs().prearm_healthy()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"Position estimate not valid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 48.58392754119827}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // set the home location\n    if (rover.mode_rover.is_set(Mode::Number::Rover_SteerLock)) {\n        rover.mode_rover.set_steer_lock_heading();\n    } else {\n        rover.mode_rover.set_home_to_current_location();\n    }\n\n    // initialise the simple mode heading\n    rover.mode_rover.set_simple_mode_heading();\n\n    // record the home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.windvane.set_home_heading(rover.ahrs.yaw);\n    }\n\n    update_soft_armed();\n\n    // send an event to the GCS and log the arming\n    AP_Notify::events.arm_complete = true;\n    AP::logger().Write_Event(LogEvent::ARM_COMPLETE);\n\n    return true;\n}", "CodeBleu_score": 63.933767360741214}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t    if (charging_allowed && !charging_enabled) {\n        // Charging is allowed but not enabled, so enable it\n        charging_enabled = true;\n        charging_enabled_time = millis();\n    } else if (!charging_allowed && charging_enabled) {\n        // Charging is not allowed but is enabled, so disable it\n        charging_enabled = false;\n        charging_enabled_time = millis();\n    } else if (!charging_allowed && !charging_enabled && millis() - charging_enabled_time > 10000) {\n        // Charging is not allowed and not enabled, so try enabling it again\n        charging_enabled_time = millis();\n    }\n}", "CodeBleu_score": 38.2890055780682}, {"code": "void updateChargingEnabled(){\n\t    // if charging is allowed and not enabled, enable charging\n    if (charging_allowed && !charging_enabled) {\n        charging_enabled = true;\n        charging_enabled_millis = millis();\n        p.neoPixelSetValue(0, 0, 255, 0, true);\n    }\n    // if charging is not allowed and enabled, disable charging and record the time\n    else if (!charging_allowed && charging_enabled) {\n        charging_enabled = false;\n        charging_disabled_millis = millis();\n        p.neoPixelSetValue(0, 255, 0, 0, true);\n    }\n    // if charging is allowed and enabled, check if it should be disabled\n    else if (charging_allowed && charging_enabled) {\n        // check if it should be disabled\n        if (checkShouldCharge()) {\n            // if it should be disabled, disable it\n            charging_enabled = false;\n            charging_disabled_millis = millis();\n            p.neoPixelSetValue(0, 255, 0, 0, true);\n        }\n    }\n    // if charging is not allowed and not enabled, check if it should be enabled\n    else if (!charging_allowed && !charging_enabled) {\n        // check if it should be enabled\n        if (checkShouldCharge()) {\n            // if it should be enabled, enable it\n            charging_enabled = true;\n            charging_enabled_millis = millis();\n            p.neoPixelSetValue(0, 0, 255, 0, true);\n        }\n    }\n}", "CodeBleu_score": 46.67364537083339}, {"code": "void updateChargingEnabled(){\n\t    // Check if charging is allowed\n    if (charging_allowed) {\n        // If charging is enabled, check if it should be stopped\n        if (charging_enabled) {\n            // Check if it should be stopped\n            if (!checkShouldCharge()) {\n                // Stop charging and record the time\n                charging_enabled = false;\n                last_charging_disabled_millis = millis();\n            }\n        } else {\n            // Check if it should be started\n            if (checkShouldCharge()) {\n                // Start charging\n                charging_enabled = true;\n                last_charging_enabled_millis = millis();\n            }\n        }\n    } else {\n        // If charging is not allowed, check if it should be enabled\n        if (charging_enabled) {\n            // Check if it should be enabled\n            if (millis() - last_charging_disabled_millis > CHARGING_DISABLE_DELAY) {\n                // Enable charging\n                charging_enabled = true;\n                last_charging_enabled_millis = millis();\n            }\n        } else {\n            // Check if it should be disabled\n            if (millis() - last_charging_enabled_millis > CHARGING_ENABLE_DELAY) {\n                // Disable charging\n                charging_enabled = false;\n                last_charging_disabled_millis = millis();\n            }\n        }\n    }\n}", "CodeBleu_score": 56.25545085745438}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (ROS_running && size >= 4) {\n    uint16_t crc = crc16(message, size - 2);\n    memcpy((char *)message + size - 2, &crc, 2);\n    packetSerial.sendMessage(message, size);\n  }\n}", "CodeBleu_score": 36.938252003602365}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ROS_running && size >= 4) {\n        uint16_t crc = crc16(message, size - 2);\n        memcpy(message + size - 2, &crc, 2);\n        packetSerial.sendMessage(message, size);\n    }\n}", "CodeBleu_score": 33.80881790364002}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ROS_running && size >= 4) {\n        uint32_t crc = crc32(message, size - 4);\n        memcpy(message + size - 4, &crc, 4);\n        packetSerial.sendMessage(message, size);\n    }\n}", "CodeBleu_score": 32.65217810979982}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t    soundSerial.begin();\n    soundSerial.clear();\n    myMP3.begin(soundSerial);\n\n    // wait for the sound module to initialize\n    while (!myMP3.available()) {\n        delay(100);\n    }\n\n    // retrieve the number of sound files available on the SD card\n    this->anzSoundfiles = myMP3.getTotalNum();\n\n    // return true if there are one or more sound files available\n    return (this->anzSoundfiles > 0);\n}", "CodeBleu_score": 53.83944592447576}, {"code": "bool MP3Sound::begin(){\n\t    soundSerial.begin(9600);\n    soundSerial.clear();\n\n    if (myMP3.begin(soundSerial)) {\n        myMP3.volume(10);\n        this->anzSoundfiles = myMP3.totalTrack();\n        this->sound_available = true;\n        return true;\n    }\n    this->sound_available = false;\n    return false;\n}", "CodeBleu_score": 56.219216697306386}, {"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.clear();\n  myMP3.begin(soundSerial);\n  this->anzSoundfiles = myMP3.getTotalNum();\n  if (this->anzSoundfiles > 0) {\n    this->sound_available = true;\n    return true;\n  } else {\n    this->sound_available = false;\n    return false;\n  }\n}", "CodeBleu_score": 56.45281398051767}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t    // check number of active sounds\n    if ((active_sounds.size() == 0) || (playing)) {\n        return active_sounds.size();\n    }\n\n    // retrieve and play last sound from active sounds list\n    int sound = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(sound);\n    playing = true;\n    return active_sounds.size();\n}", "CodeBleu_score": 55.45728998936743}, {"code": "int MP3Sound::processSounds(){\n\t  if (active_sounds.size() == 0) {\n    return 0;\n  }\n  if (playing) {\n    return active_sounds.size();\n  }\n  int sound = active_sounds.back();\n  active_sounds.pop_back();\n  myMP3.play(sound);\n  playing = true;\n  return active_sounds.size();\n}", "CodeBleu_score": 54.10912730235747}, {"code": "int MP3Sound::processSounds(){\n\t\n    if(active_sounds.size() == 0) return 0;\n    if(playing) return active_sounds.size();\n\n    playing = true;\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    return active_sounds.size();\n\n}", "CodeBleu_score": 54.765464472139044}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (c->memory_mapped_file != NULL) {\n      munmap(c->memory_mapped_file, c->memory_mapped_file_size);\n      close(c->memory_mapped_file_fd);\n    }\n    c->memory_mapped_file_fd = request_read_int(r);\n    c->memory_mapped_file_size = request_read_int(r);\n    c->memory_mapped_file = mmap(NULL, c->memory_mapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, c->memory_mapped_file_fd, 0);\n    if (c->memory_mapped_file == MAP_FAILED)\n      c->memory_mapped_file = NULL;\n    return true;\n  }\n  c->command_handled = false;\n  return false;\n}", "CodeBleu_score": 45.39681468520691}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t", "CodeBleu_score": 6.48713104527464}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (c->memory_mapped_file != NULL) {\n      munmap(c->memory_mapped_file, c->memory_mapped_file_size);\n      close(c->memory_mapped_file_fd);\n      free(c->memory_mapped_file_name);\n    }\n    c->memory_mapped_file_name = request_read_string(r);\n    c->memory_mapped_file_size = request_read_uint32(r);\n    c->memory_mapped_file_fd = open(c->memory_mapped_file_name, O_RDWR);\n    if (c->memory_mapped_file_fd < 0) {\n      fprintf(stderr, \"Cannot open memory-mapped file %s\n\", c->memory_mapped_file_name);\n      return false;\n    }\n    c->memory_mapped_file = mmap(NULL, c->memory_mapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, c->memory_mapped_file_fd, 0);\n    if (c->memory_mapped_file == MAP_FAILED) {\n      fprintf(stderr, \"Cannot mmap memory-mapped file %s\n\", c->memory_mapped_file_name);\n      return false;\n    }\n    return true;\n  }\n  c->command_handled = false;\n  return false;\n}", "CodeBleu_score": 44.15231903499998}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.7323980855264}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.7323980855264}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.7323980855264}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 60.093445795918356}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 60.093445795918356}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 60.093445795918356}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  free(dms);\n  return result;\n}", "CodeBleu_score": 43.090065346945124}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  free(dms);\n  return result;\n}", "CodeBleu_score": 43.090065346945124}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dIASSERT(box->body);\n  dIASSERT(immersion);\n  dIASSERT(immersion->g1);\n  dIASSERT(immersion->g2);\n  dIASSERT(immersion->immersion);\n  dIASSERT(flags & (dxImmersionOutline | dxImmersionOutlineDisabled));\n  sBoxImmersionData data(box, fluidPlane, immersion, flags);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 61.01725244194657}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dIASSERT(box->body);\n  dIASSERT(dAreValidImmersionFlags(flags));\n\n  sBoxImmersionData data;\n  data.init(box, fluidPlane, immersion, flags);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 54.197377822931855}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dIASSERT(box != NULL);\n  dIASSERT(immersion != NULL);\n  dIASSERT(dBodyGetBody(box) != NULL);\n  dIASSERT(flags == DX_IMMERSE_NORMAL || flags == DX_IMMERSE_COMPLEMENT);\n\n  sBoxImmersionData data(box, fluidPlane, immersion, flags);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 61.45738533182823}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  dxBox *const box = (dxBox *) o1;\n  dxCapsule *const capsule = (dxCapsule *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 98.18997189821218}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  dxBox *const box = (dxBox *) o1;\n  dxCapsule *const capsule = (dxCapsule *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 98.18997189821218}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  dxBox *const box = (dxBox *) o1;\n  dxCapsule *const capsule = (dxCapsule *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.87456364832381}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n  return 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.71008041165729}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n  return volume;\n}", "CodeBleu_score": 91.14807874876388}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n  return volume;\n}", "CodeBleu_score": 91.14807874876388}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n  x += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n  return m_fRadius * x / volume;\n}", "CodeBleu_score": 66.41286629332043}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n  xBuoyancyCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n  return xBuoyancyCenter / (m_fRadius * volume);\n}", "CodeBleu_score": 64.50847848121315}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const dReal singularityStart = singularityFactor * sinTheta1;\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  dReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n  xBuoyancyCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\n  return xBuoyancyCenter * m_fRadius * volume;\n}", "CodeBleu_score": 65.42688398688551}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  const dxCapsule *const capsule = (dxCapsule *) o1;\n  dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\n  return dImmerseCapsule(capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 83.14296670324211}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  const dxCapsule *const capsule = (dxCapsule *) o1;\n  dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\n  return dImmerseCapsule(capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 78.45295818729619}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  const dxCapsule *const capsule = (dxCapsule *) o1;\n  dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\n\n  return dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 86.18598494498107}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t    double duration_ms = 0.0;\n    if ( !getInput(\"duration_ms\", duration_ms) ) {\n        return NodeStatus::SUCCESS;\n    }\n\n    if (duration_ms <= 0.0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n\n    timer_waiting_ = true;\n    timer_ = std::make_unique<ros::Timer>(\n        nh_.createTimer(ros::Duration(duration_ms / 1000.0),\n                        &SleepNode::timerCallback, this, true, false));\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 49.76431790117151}, {"code": "NodeStatus SleepNode::onStart(){\n\t    if (getInput<int>(\"milliseconds\").value() <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    status_ = NodeStatus::RUNNING;\n    timer_waiting_ = true;\n\n    int milliseconds = getInput<int>(\"milliseconds\").value();\n    timer_ = std::make_unique<ros::Timer>(\n        nh_.createTimer(ros::Duration(milliseconds / 1000.0), &SleepNode::timerCallback, this));\n    timer_->start();\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.09485784711126}, {"code": "NodeStatus SleepNode::onStart(){\n\t\n    /* Get the sleep duration in milliseconds from the input port. */\n    int duration_ms = getInput<int>(\"duration_ms\").value();\n\n    /* If the duration is missing or non-positive, return SUCCESS. */\n    if (duration_ms <= 0)\n    {\n        return NodeStatus::SUCCESS;\n    }\n\n    /* Set the node status to RUNNING. */\n    setStatus(NodeStatus::RUNNING);\n\n    /* Start a timer. */\n    timer_waiting_ = true;\n    timer_.expires_from_now(boost::posix_time::milliseconds(duration_ms));\n    timer_.async_wait(boost::bind(&SleepNode::onTimer, this, boost::asio::placeholders::error));\n\n    /* Set a callback to emit a wake-up signal when the timer expires. */\n    timer_.async_wait(boost::bind(&SleepNode::onTimer, this, boost::asio::placeholders::error));\n\n    /* Return SUCCESS. */\n    return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 51.54315187233861}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  NodeStatus status = NodeStatus::FAILURE;\n  auto entry = getInput<Blackboard::Entry>(\\\"entry\\\");\n  if(entry) {\n    if(entry->sequence_id != last_sequence_id_) {\n      last_sequence_id_ = entry->sequence_id;\n      status = NodeStatus::SUCCESS;\n    }\n  }\n  return status;\n}", "CodeBleu_score": 36.46296116291699}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  NodeStatus status = NodeStatus::FAILURE;\n  std::string entry_value;\n  if( !getInput(entry_key_, entry_value)) {\n    return status;\n  }\n\n  if(entry_value.empty()) {\n    return status;\n  }\n\n  auto& blackboard = this->blackboard();\n  auto& entry = blackboard.get<std::string>(entry_key_);\n  auto& mutex = entry.mutex;\n\n  std::lock_guard<std::mutex> lock(mutex);\n\n  if(entry.sequence_id != sequence_id_) {\n    sequence_id_ = entry.sequence_id;\n    status = NodeStatus::SUCCESS;\n  }\n\n  return status;\n}", "CodeBleu_score": 45.03848717004242}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  NodeStatus status = NodeStatus::FAILURE;\n  auto blackboard = getBlackboard();\n  if (!blackboard)\n  {\n    throw LogicError(\\\"Missing blackboard in \\\", name());\n  }\n  const auto& entry = blackboard->get<Entry>(entry_key_);\n  if (entry.lock_guard)\n  {\n    auto lock = entry.lock_guard();\n    if (entry.sequence_id != prev_sequence_id_)\n    {\n      prev_sequence_id_ = entry.sequence_id;\n      status = NodeStatus::SUCCESS;\n    }\n  }\n  return status;\n}", "CodeBleu_score": 41.94533962132431}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return static_cast<size_t>(std::max(0, static_cast<int>(children_nodes_.size()) + success_threshold_));\n  } else {\n    return static_cast<size_t>(success_threshold_);\n  }\n}", "CodeBleu_score": 60.88438396290006}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return std::max(size_t(-success_threshold_), size_t(1));\n  } else {\n    return static_cast<size_t>(success_threshold_);\n  }\n}", "CodeBleu_score": 57.147518729429144}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return static_cast<size_t>(std::max(0, static_cast<int>(children_nodes_.size()) + success_threshold_));\n  } else {\n    return static_cast<size_t>(success_threshold_);\n  }\n}", "CodeBleu_score": 60.88438396290006}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  std::unique_lock<std::mutex> lk(_p->status_mutex);\n  bool was_active = _p->active;\n  while(true)\n  {\n    auto now = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch());\n    if(now - _p->last_heartbeat > _p->heartbeat_timeout)\n    {\n      _p->active = false;\n    }\n    else\n    {\n      _p->active = true;\n    }\n\n    if(was_active != _p->active)\n    {\n      enableAllHooks(_p->active);\n      was_active = _p->active;\n    }\n\n    _p->status_cond.wait_for(lk, std::chrono::milliseconds(10));\n  }\n}", "CodeBleu_score": 43.5448075687667}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while(!_p->stop_threads)\n  {\n    auto now = std::chrono::high_resolution_clock::now();\n    std::unique_lock<std::mutex> lk(_p->status_mutex);\n    if(_p->last_heartbeat_time.time_since_epoch().count() != 0 &&\n        (now - _p->last_heartbeat_time) > std::chrono::milliseconds(100))\n    {\n      enableAllHooks(false);\n    }\n    lk.unlock();\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n}", "CodeBleu_score": 50.329700671404076}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while(_p->running)\n  {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    auto now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch());\n    if(_p->last_heartbeat_time != now)\n    {\n      _p->last_heartbeat_time = now;\n      if(_p->heartbeat_active)\n      {\n        enableAllHooks(true);\n      }\n      else\n      {\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 50.16545012443818}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  // Split the input string into a vector of blackboard names\n  std::vector<std::string> bb_names = split(bb_list, ',');\n\n  // Create a JSON object to store the blackboards\n  nlohmann::json bb_json;\n\n  // Iterate through the blackboard names\n  for (const auto& bb_name : bb_names) {\n    // Find the subtree corresponding to the blackboard name\n    auto subtree = _p->tree.getSubtree(bb_name);\n\n    // Lock the subtree\n    std::unique_lock<std::mutex> lock(subtree->mutex);\n\n    // Check if the subtree is valid\n    if (subtree->blackboard) {\n      // Export the blackboard to JSON and add it to the JSON object\n      bb_json[bb_name] = subtree->blackboard->toJson();\n    }\n  }\n\n  // Convert the JSON object to MessagePack format\n  return nlohmann::json::to_msgpack(bb_json);\n}", "CodeBleu_score": 48.42162556100018}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    // Create a JSON object to store the blackboards\n    nlohmann::json json_out;\n\n    // Split the input string into a vector of blackboard names\n    std::vector<std::string> blackboards;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        blackboards.push_back(bb_name);\n    }\n\n    // Iterate through the blackboards\n    for (const auto& bb_name : blackboards) {\n        // Find the corresponding subtree\n        auto subtree = _p->blackboard_manager->getSubtree(bb_name);\n        if (!subtree) {\n            continue;\n        }\n\n        // Lock the subtree\n        std::unique_lock<std::mutex> lock(*subtree->mutex);\n\n        // Export the blackboard to JSON\n        auto json_bb = subtree->blackboard->toJson();\n        json_out[bb_name] = json_bb;\n    }\n\n    // Convert the JSON object to MessagePack format\n    return nlohmann::json::to_msgpack(json_out);\n}", "CodeBleu_score": 50.08287467371424}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t", "CodeBleu_score": 5.780157160879095}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  TreeNode::Ptr node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  if (node->position() != pos) {\n    return false;\n  }\n\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto hook_it = _p->pre_hooks.find(node_uid);\n  if (hook_it == _p->pre_hooks.end()) {\n    return false;\n  }\n  auto hook = hook_it->second;\n\n  std::unique_lock<std::mutex> lk2(hook->mutex);\n  if (hook->mode != Monitor::Hook::Mode::BREAKPOINT) {\n    return false;\n  }\n\n  hook->desired_status = result;\n  hook->remove_when_done = remove;\n  hook->ready = true;\n  lk2.unlock();\n  hook->wakeup.notify_all();\n\n  return true;\n}", "CodeBleu_score": 72.26470971877615}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  TreeNode::Ptr node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto hook_it = _p->pre_hooks.find(node_uid);\n  if (hook_it == _p->pre_hooks.end()) {\n    return false;\n  }\n  auto hook = hook_it->second;\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk2(hook->mutex);\n  if (hook->mode != Monitor::Hook::Mode::BREAKPOINT) {\n    return false;\n  }\n  hook->desired_status = result;\n  hook->remove_when_done = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 74.29154966563269}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  TreeNode::Ptr node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto hook_it = _p->pre_hooks.find(node_uid);\n  if (hook_it == _p->pre_hooks.end()) {\n    return false;\n  }\n  auto hook = hook_it->second;\n  lk.unlock();\n\n  std::unique_lock<std::mutex> lk_hook(hook->mutex);\n  if (hook->mode != Monitor::Hook::Mode::BREAKPOINT) {\n    return false;\n  }\n  hook->desired_status = result;\n  hook->remove_when_done = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 72.27980802623762}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    const NodeStatus prev_status = status();\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        std::thread th([this] {\n            try {\n                tick_functor_(*this);\n            } catch (...) {\n                exception_ = std::current_exception();\n            }\n        });\n        th.detach();\n        return NodeStatus::RUNNING;\n    }\n\n    if (prev_status == NodeStatus::RUNNING) {\n        if (halt_requested_.load()) {\n            setStatus(NodeStatus::IDLE);\n        } else {\n            setStatus(NodeStatus::RUNNING);\n        }\n    }\n\n    if (exception_) {\n        std::rethrow_exception(exception_);\n    }\n\n    return status();\n}", "CodeBleu_score": 47.49956726119255}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    const NodeStatus prev_status = status();\n\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        thread_ = std::thread([this]() {\n            try {\n                tick();\n            } catch (...) {\n                exception_ = std::current_exception();\n            }\n        });\n    }\n\n    if (thread_.joinable()) {\n        thread_.join();\n    }\n\n    if (exception_) {\n        exception_ = nullptr;\n        setStatus(NodeStatus::IDLE);\n        throw_exception_if_any();\n    }\n\n    return status();\n}", "CodeBleu_score": 42.39453059480272}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    const NodeStatus prev_status = status();\n\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n\n        // start a new asynchronous thread to run the tick function\n        thread_ = std::thread([this]() {\n            try {\n                tick_functor_(*this);\n            } catch (...) {\n                exception_ = std::current_exception();\n            }\n        });\n    }\n\n    // wait for the thread to complete\n    thread_.join();\n\n    // check if the tick function completed without a halt request\n    if (!halt_requested_.load()) {\n        // update the node status\n        setStatus(NodeStatus::SUCCESS);\n    }\n\n    // check for any stored exceptions and rethrow them\n    if (exception_) {\n        std::exception_ptr eptr = std::move(exception_);\n        exception_ = nullptr;\n        std::rethrow_exception(eptr);\n    }\n\n    return status();\n}", "CodeBleu_score": 49.33176164516475}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << std::string(40, '-') << std::endl;\n  if (!root_node) {\n    stream << \\\"Empty tree\\\" << std::endl;\n    stream << std::string(40, '-') << std::endl;\n    return;\n  }\n\n  auto print_node = [&stream](const TreeNode* node, unsigned depth) {\n    if (!node) {\n      return;\n    }\n\n    stream << std::string(depth, '.') << node->name() << std::endl;\n  };\n\n  auto print_children = [&stream, &print_node](const TreeNode* node, unsigned depth) {\n    if (!node) {\n      return;\n    }\n\n    if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n      for (const auto& child : control->children()) {\n        print_node(child, depth + 1);\n        print_children(child, depth + 1);\n      }\n    } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      print_node(decorator->child(), depth + 1);\n      print_children(decorator->child(), depth + 1);\n    }\n  };\n\n  print_node(root_node, 0);\n  print_children(root_node, 0);\n  stream << std::string(40, '-') << std::endl;\n}", "CodeBleu_score": 56.910511243584935}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  if(!root_node) {\n    throw LogicError(\"The root_node is null\");\n  }\n\n  stream << \"------------------\n\";\n  const auto print_node = [&stream](const TreeNode* node, int depth) {\n    for(int i = 0; i < depth; i++) {\n      stream << \"--\";\n    }\n    stream << node->name() << \"\n\";\n  };\n\n  const auto print_tree = [&print_node](const TreeNode* node, int depth) {\n    print_node(node, depth);\n    if(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n      for(const auto& child : control->children()) {\n        print_tree(static_cast<const TreeNode*>(child), depth + 1);\n      }\n    }\n    else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      if(decorator->child()) {\n        print_tree(decorator->child(), depth + 1);\n      }\n    }\n  };\n\n  print_tree(root_node, 0);\n  stream << \"------------------\n\";\n}", "CodeBleu_score": 63.18743297084977}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  const auto print_node = [&stream](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; i++) {\n      stream << \"| \";\n    }\n    stream << node->name() << std::endl;\n  };\n\n  stream << \"------------------------------\" << std::endl;\n  std::function<void(const TreeNode*, int)> print_tree =\n      [&print_node, &print_tree](const TreeNode* node, int depth) {\n        print_node(node, depth);\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n          for (const auto& child : control->children()) {\n            print_tree(static_cast<const TreeNode*>(child), depth + 1);\n          }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n          if (decorator->child()) {\n            print_tree(decorator->child(), depth + 1);\n          }\n        }\n      };\n\n  print_tree(root_node, 0);\n  stream << \"------------------------------\" << std::endl;\n}", "CodeBleu_score": 62.180077911856394}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"applyRecursiveVisitor(): node is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto cnode = dynamic_cast<const ControlNode*>(node)) {\n    for (auto child : cnode->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto dnode = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(dnode->child(), visitor);\n  }\n}", "CodeBleu_score": 62.87937360285974}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"applyRecursiveVisitor on a nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control_node->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator_node->child(), visitor);\n  }\n}", "CodeBleu_score": 64.4138388087801}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"Trying to apply visitor to a null node\");\n  }\n  visitor(node);\n  if (auto ctrl = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : ctrl->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (auto deco = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(deco->child(), visitor);\n  }\n}", "CodeBleu_score": 62.442399002233884}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builtinNodes().count(manifest.ID)) {\n    throw BehaviorTreeException(\n        \"You can not override the builtin registration ID [\" + manifest.ID +\n        \"]\");\n  }\n  _p->builders[manifest.ID] = builder;\n  _p->manifests[manifest.ID] = manifest;\n}", "CodeBleu_score": 41.6041973728278}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (_p->builders.count(manifest.ID)) {\n    throw BehaviorTreeException(\"Node with ID [\" + manifest.ID +\n                               \"] already registered\");\n  }\n\n  _p->builders[manifest.ID] = builder;\n  _p->manifests[manifest.ID] = manifest;\n}", "CodeBleu_score": 46.94721792258677}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builtinNodes().count(manifest.ID)) {\n    throw BehaviorTreeException(\"You can not register the builtin registration ID [\",\n                               manifest.ID, \"]\");\n  }\n  _p->builders.insert({manifest.ID, builder});\n  _p->manifests.insert({manifest.ID, manifest});\n}", "CodeBleu_score": 52.86719314549473}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports), {}};\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 93.20881361046894}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports), {}};\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 93.20881361046894}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports), {}};\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 93.20881361046894}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for(const auto& subtree : tree.subtrees) {\n    auto bb = std::make_shared<Blackboard>();\n    subtree->blackboard->cloneInto(*bb);\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 60.11351043513255}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (const auto& subtree : tree.subtrees) {\n    auto bb = std::make_shared<Blackboard>();\n    subtree->blackboard->cloneInto(*bb);\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 59.698819132465076}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (const auto& subtree : tree.subtrees) {\n    auto bb = std::make_shared<Blackboard>();\n    subtree->blackboard->cloneInto(*bb);\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 59.698819132465076}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto result = ParseScript(script);\n  if (result) {\n    return result.value()(env);\n  } else {\n    return nonstd::make_unexpected(result.error());\n  }\n}", "CodeBleu_score": 72.09135974366426}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto func = ParseScript(script);\n  if (func) {\n    return func.value()(env);\n  } else {\n    return nonstd::make_unexpected(func.error());\n  }\n}", "CodeBleu_score": 71.67524337925579}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto script_function = ParseScript(script);\n  if (!script_function) {\n    return nonstd::make_unexpected(script_function.error());\n  }\n  return script_function.value()(env);\n}", "CodeBleu_score": 61.34948267599214}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::unique_lock<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\"Library already loaded: \", _path);\n  }\n\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    throw RuntimeError(dlerror());\n  }\n\n  _path = path;\n}", "CodeBleu_score": 59.58925017220258}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\"Library \" + _path + \" is already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    throw RuntimeError(\"Failed to load library: \" + std::string(dlerror()));\n  }\n  _path = path;\n}", "CodeBleu_score": 62.038768653496334}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    throw RuntimeError(dlerror());\n  }\n  _path = path;\n}", "CodeBleu_score": 53.331236559575956}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n    auto trimmed = str.trim();\n    if (trimmed.starts_with('{') && trimmed.ends_with('}')) {\n        if (stripped_pointer) {\n            *stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 25.578697497261714}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if(str.size() < 3)\n  {\n    return false;\n  }\n  auto begin = str.begin() + 1;\n  auto end = str.end() - 1;\n  if(*begin == ' ' || *end == ' ')\n  {\n    return false;\n  }\n  if(*begin != '{' || *end != '}')\n  {\n    return false;\n  }\n  if(stripped_pointer)\n  {\n    *stripped_pointer = StringView(begin, end);\n  }\n  return true;\n}", "CodeBleu_score": 34.15053516887705}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n  str = str.trim();\n  if (str.front() != '{' || str.back() != '}') {\n    return false;\n  }\n  if (stripped_pointer) {\n    *stripped_pointer = str.substr(1, str.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 23.392253459974892}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = 0.0;\n\n  //get the line iterator\n  LineIterator line(costmap_, x0, y0, x1, y1);\n\n  //used to determine the direction of the line\n  double delta_x = x1 - x0;\n  double delta_y = y1 - y0;\n  double delta_abs_x = fabs(delta_x);\n  double delta_abs_y = fabs(delta_y);\n\n  //used to keep track of the current position of the line iterator\n  int x = line.x();\n  int y = line.y();\n\n  //we need to iterate over the cells in this line\n  unsigned int point_count = 0;\n  while(!line.isEnd()) {\n    point_count++;\n\n    //get the cell cost\n    unsigned char cost = costmap_.getCost(x, y);\n\n    //if the cell is in an obstacle that isn't free, we know that we can return false right away\n    if(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n      return -1.0;\n\n    //if the cell is not legal or unknown, we also return false\n    if(cost == NO_INFORMATION)\n      return -2.0;\n\n    //we use max because assuring that the footprint is convex is more important than minimizing the number of points\n    //on the line\n    line_cost = std::max(line_cost, pointCost(x, y, delta_abs_x, delta_abs_y));\n\n    //move to the next cell\n    line.advance();\n\n    //make sure that we don't go off the end of the map\n    x = line.x();\n    y = line.y();\n  }\n\n  //if all points on the line are legal... then we can return that the footprint is legal\n  return line_cost;\n}", "CodeBleu_score": 43.141853706717406}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = 0.0;\n\n  //get the cell coord of the first point\n  unsigned int cell_x = x0;\n  unsigned int cell_y = y0;\n\n  //get the cell coord of the last point\n  unsigned int cell_x2 = x1;\n  unsigned int cell_y2 = y1;\n\n  //get the minimum and maximum x and y values\n  int min_x = min(cell_x, cell_x2);\n  int max_x = max(cell_x, cell_x2);\n  int min_y = min(cell_y, cell_y2);\n  int max_y = max(cell_y, cell_y2);\n\n  //iterate over the line\n  LineIterator line(costmap_, cell_x, cell_y, cell_x2, cell_y2);\n  for(unsigned int x = min_x; x <= max_x; ++x) {\n    for(unsigned int y = min_y; y <= max_y; ++y) {\n      //get the cost of the cell\n      point_cost = costmap_.getCost(x, y);\n\n      //if the point is an obstacle, we know that the path cannot be expanded to this point\n      if(point_cost == LETHAL_OBSTACLE)\n        return point_cost;\n\n      //if the point is not an obstacle, we need to check if it is free\n      if(point_cost != NO_INFORMATION) {\n        //if the point is not an obstacle, we need to check if it is free\n        if(point_cost > line_cost)\n          line_cost = point_cost;\n      }\n    }\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 41.33772585221691}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = 0.0;\n  LineIterator line(x0, y0, x1, y1);\n\n  for (unsigned int x = line.x0; line.isValid(); line.advance()) {\n    point_cost = pointCost(line.x, line.y);\n    if (point_cost < 0)\n      return point_cost;\n    line_cost = std::max(line_cost, point_cost);\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 63.93728587580838}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //create a message for the plan\n  nav_msgs::Path gui_path;\n\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n\n    gui_path.header.frame_id = path[0].header.frame_id;\n\n    gui_path.header.stamp = path[0].header.stamp;\n\n  }\n\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n\n    gui_path.poses[i] = path[i];\n\n  }\n\n\n  pub.publish(gui_path);\n\n}", "CodeBleu_score": 83.31417000485905}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //given a vector of geometry_msgs::PoseStamped, publish it as a nav_msgs::Path\n  //first, make sure the vector is not empty\n  if (path.empty()) {\n    ROS_WARN(\"Received an empty plan\");\n    return;\n  }\n\n  //create a nav_msgs::Path message\n  nav_msgs::Path gui_path;\\\n  gui_path.poses.resize(path.size());\n\n  //copy the path into the message\n  gui_path.header.frame_id = path[0].header.frame_id;\\\n  gui_path.header.stamp = path[0].header.stamp;\\\n  for (unsigned int i = 0; i < path.size(); i++) {\\\n    gui_path.poses[i] = path[i];\\\n  }\n\n  //publish the message\n  pub.publish(gui_path);\n}", "CodeBleu_score": 71.52454942613087}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //create a message for the plan\n  nav_msgs::Path gui_path;\n\n  gui_path.poses.resize(path.size());\n\n\n  if (!path.empty()) {\n\n    gui_path.header.frame_id = path[0].header.frame_id;\n\n    gui_path.header.stamp = path[0].header.stamp;\n\n  }\n\n\n  //extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n\n    gui_path.poses[i] = path[i];\n\n  }\n\n\n  pub.publish(gui_path);\n\n}", "CodeBleu_score": 83.31417000485905}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity)\n    return true;\n\n  return false;\n}", "CodeBleu_score": 77.1120903762109}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity;\n}", "CodeBleu_score": 69.66277136806724}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  if(fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n     fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n     fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity)\n    return true;\n  return false;\n}", "CodeBleu_score": 85.32526905673826}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (restore_defaults) {\n    config = default_limits_;\n  }\n  if (!initialized_) {\n    default_limits_ = config;\n    initialized_ = true;\n  }\n  limits_mutex_.lock();\n  limits_ = config;\n  limits_mutex_.unlock();\n}", "CodeBleu_score": 60.33282480431983}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if(initialized_) {\n    if(restore_defaults) {\n      config = limits_default;\n    }\n    if(!setup_) {\n      limits_default = config;\n      setup_ = true;\n    }\n  }\n  else {\n    ROS_ERROR(\\\"Local planner utils have not been initialized, cannot reconfigure.\\\");\n    return;\n  }\n  limits_mutex_.lock();\n  limits_ = config;\n  limits_mutex_.unlock();\n}", "CodeBleu_score": 56.75801262632342}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if(restore_defaults) {\n    config = default_limits_;\n  }\n  if(!initialized_) {\n    default_limits_ = config;\n    initialized_ = true;\n  }\n  limits_mutex_.lock();\n  limits_ = config;\n  limits_mutex_.unlock();\n}", "CodeBleu_score": 60.496483548113}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t    unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n    if (cost == costmap_2d::NO_INFORMATION) {\n      return false;\n    }\n    if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n      check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n      return false;\n    }\n    // calculate new target distance\n    double new_target_dist = current_cell->target_dist + costmap_2d::costToProb(cost);\n    // if the new target distance is shorter, update the cell\n    if (new_target_dist < check_cell->target_dist) {\n      check_cell->target_dist = new_target_dist;\n      return true;\n    }\n    return false;\n  }", "CodeBleu_score": 68.92047056388675}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int check_x = check_cell->cx;\n  unsigned int check_y = check_cell->cy;\n  unsigned int index = getIndex(check_x, check_y);\n\n  //check if the cell is an obstacle\n  unsigned char cost = costmap.getCost(check_x, check_y);\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    //if the cell is an obstacle, set the target distance to the maximum obstacle cost and return false\n    check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  //if the cell is not an obstacle, calculate a new target distance\n  double new_target = current_cell->target_dist + distance(current_cell->cx, current_cell->cy, check_x, check_y);\n\n  //update the cell's target distance if the new distance is shorter\n  if (new_target < check_cell->target_dist) {\n    check_cell->target_dist = new_target;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 60.495210354940944}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int check_index = getIndex(check_cell->cx, check_cell->cy);\n  unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cost == costmap_2d::NO_INFORMATION) {\n    return false;\n  }\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n  double new_dist = current_cell->target_dist + cost;\n  if (new_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_dist;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 68.49842226118916}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scale = 1.0;\n  double traj_cost = 0.0;\n  double traj_cost_sum = 0.0;\n  double traj_cost_max = -9.0;\n\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, can't score trajectory\");\n    return -9.0;\n  }\n\n  // calculate the scaling factor\n  if (fabs(traj.xv_) > 0.001) {\n    scale = max_trans_vel_ / traj.xv_;\n  }\n  if (scale > max_scaling_factor_) {\n    scale = max_scaling_factor_;\n  }\n\n  // calculate the trajectory cost\n  for (unsigned int i = 0; i < footprint_spec_.size(); ++i) {\n    traj_cost = footprintCost(traj.x0_ + footprint_spec_[i].x * scale, traj.y0_ + footprint_spec_[i].y * scale, traj.th0_);\n    if (traj_cost < 0.0) {\n      return traj_cost;\n    }\n    if (sum_scores_) {\n      traj_cost_sum += traj_cost;\n    } else {\n      if (traj_cost > traj_cost_max) {\n        traj_cost_max = traj_cost;\n      }\n    }\n  }\n\n  if (sum_scores_) {\n    cost = traj_cost_sum;\n  } else {\n    cost = traj_cost_max;\n  }\n\n  return cost;\n}", "CodeBleu_score": 59.66070521694174}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scale = 1.0;\n  double traj_cost = 0.0;\n\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (traj.xv_ > 0) {\n    // we're going forward\n    cost = scale * max_trans_vel_ - traj.xv_;\n    if (cost < 0) {\n      cost = 0;\n    }\n    scale = std::max(scale, cost / max_trans_vel_);\n  } else {\n    // we're going backwards\n    cost = scale * max_trans_vel_ + traj.xv_;\n    if (cost < 0) {\n      cost = 0;\n    }\n    scale = std::max(scale, cost / max_trans_vel_);\n  }\n\n  // if the footprint specification is empty, we'll just return a constant score\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty\");\n    return -9;\n  }\n\n  // check the footprints for collisions\n  for (unsigned int i = 0; i < traj.xv_.size(); ++i) {\n    // calculate the footprint cost\n    traj_cost = footprintCost(traj.xv_[i], traj.yv_[i], traj.th_[i], scale);\n    // if the footprint cost is negative, then we have a collision\n    if (traj_cost < 0) {\n      return traj_cost;\n    }\n    // either sum the scores or take the maximum\n    if (sum_scores_) {\n      cost += traj_cost;\n    } else {\n      cost = std::max(cost, traj_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 57.891490362043065}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  //check to make sure the footprint is not empty\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint?\");\n    return -9;\n  }\n\n  //now we need to transform all of the points in the footprint\n  std::vector<geometry_msgs::Point> footprint;\n  geometry_msgs::Point pt;\n\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    pt.x = x + (footprint_spec[i].x * scale);\n    pt.y = y + (footprint_spec[i].y * scale);\n    footprint.push_back(pt);\n  }\n\n  //check if the footprint is off the map\n  if (!world_model->worldModel_->isPolygonInside(footprint)) {\n    return -7.0;\n  }\n\n  //now we need to check for an inflated footprint\n  std::vector<geometry_msgs::Point> inflated_footprint;\n  world_model->getInflatedFootprint(footprint, inflated_footprint);\n\n  //now we need to check if the footprint is too close to an obstacle\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint);\n  double inflated_cost = world_model->footprintCost(x, y, th, inflated_footprint);\n  double cost = std::max(footprint_cost, inflated_cost);\n\n  //if the footprint is too close to an obstacle, we'll return a negative value\n  if (cost < 0) {\n    return -6.0;\n  }\n\n  //otherwise we'll return the cost\n  return cost;\n}", "CodeBleu_score": 63.5984538637829}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    if (odom_topic.empty()) {\n      // Shut down the existing subscription\n\";\n      odom_sub_.shutdown();\n    } else {\n      // Setup a new subscription\n      odom_topic_ = odom_topic;\n\";\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 44.48648762962559}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 46.62720528332076}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      if (!odom_sub_) {\n        odom_sub_.subscribe(nh_, odom_topic_, 5);\n        odom_notifier_ = new message_filters::Subscriber<nav_msgs::Odometry>(odom_sub_);\n      } else {\n        odom_sub_.unsubscribe();\n        odom_sub_.subscribe(nh_, odom_topic_, 5);\n      }\n      odom_notifier_->registerCallback(boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    } else {\n      odom_sub_.unsubscribe();\n    }\n  }\n}", "CodeBleu_score": 52.14583754396818}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  //calculate the squared distance\n  double sq_dist = (pos.head(2) - prev.head(2)).squaredNorm();\n  //calculate the angular difference\n  double delta_yaw = pos[2] - prev[2];\n  //normalize the angle\n  while (delta_yaw > M_PI) delta_yaw -= 2.0 * M_PI;\\\n  while (delta_yaw < -M_PI) delta_yaw += 2.0 * M_PI;\\\n  //if the squared distance is greater than the threshold or the angular difference is greater than the set angle, reset the oscillation flags\n  if (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ || fabs(delta_yaw) > oscillation_reset_angle_) {\\\n    forward_pos_only_ = false;\\\n    forward_neg_only_ = false;\\\n    strafe_pos_only_ = false;\\\n    strafe_neg_only_ = false;\\\n    rot_pos_only_ = false;\\\n    rot_neg_only_ = false;\\\n  }\\\n}", "CodeBleu_score": 55.21129349986236}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n  double angle = atan2(pos.y() - prev.y(), pos.x() - prev.x());\n  if (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ || fabs(angle) > oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 45.398860810618324}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n  double angle = atan2(pos.y() - prev.y(), pos.x() - prev.x());\n  if (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ || fabs(angle) > oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 45.398860810618324}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n  if(!gridCoords(pt, gx, gy))\n    return;\n\n  //get the index of the cell\n  unsigned int index = gridIndex(gx, gy);\n\n  //if the cell is empty, we can just insert\n  if(cells_[index].empty()) {\n    cells_[index].push_back(pt);\n    return;\n  }\n\n  //otherwise, we need to find the nearest neighbor and make sure they're far enough apart\n  double min_dist = DBL_MAX;\n  list<geometry_msgs::Point32>::iterator min_it = cells_[index].begin();\n  for(list<geometry_msgs::Point32>::iterator it = cells_[index].begin(); it != cells_[index].end(); ++it) {\n    double dist = sqrt(pow(it->x - pt.x, 2) + pow(it->y - pt.y, 2));\n    if(dist < min_dist) {\n      min_dist = dist;\n      min_it = it;\n    }\n  }\n\n  //if the minimum distance is less than the threshold, don't insert\n  if(min_dist < min_dist_)\n    return;\n\n  //otherwise, insert\n  cells_[index].insert(min_it, pt);\n}", "CodeBleu_score": 61.38576062947507}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  unsigned int gx, gy;\n  if (!gridCoords(pt, gx, gy))\n    return;\n  unsigned int index = gridIndex(gx, gy);\n  if (index >= cells_.size())\n    return;\n  list<geometry_msgs::Point32>& cell = cells_[index];\n  if (cell.empty()) {\n    cell.push_back(pt);\n    return;\n  }\n  double min_dist = DBL_MAX;\n  list<geometry_msgs::Point32>::iterator it = cell.begin();\n  for (; it != cell.end(); ++it) {\n    const geometry_msgs::Point32& p = *it;\n    double dist = sqrt((pt.x - p.x) * (pt.x - p.x) + (pt.y - p.y) * (pt.y - p.y));\n    if (dist < min_dist)\n      min_dist = dist;\n  }\n  if (min_dist < min_dist_)\n    cell.push_back(pt);\n}", "CodeBleu_score": 58.491588554896865}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //compute the grid coordinates of the point\n\n    unsigned int gx, gy;\n    if(!gridCoords(pt, gx, gy))\n      return;\n\n    //compute the index of the cell\n    unsigned int index = gridIndex(gx, gy);\n\n    //insert the point into the cell\n    cells_[index].push_back(pt);\n  }", "CodeBleu_score": 71.67360996027013}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (unsigned int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 81.03900381786056}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 81.44807041434383}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 83.60671184924328}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  //find the goal point on the path\n\";\n  int goal_x, goal_y;\n  double goal_x, goal_y;\n  double goal_theta;\n  double goal_dist = DBL_MAX;\n  int goal_idx = -1;\n  for(unsigned int i = global_plan_.size() - 1; i > 0; --i){\n    //if we have a clear line of sight to the point on the global plan\n    if(lineOfSight(cell_x, cell_y, global_plan_[i].pose.position.x, global_plan_[i].pose.position.y)){\n      //we've found a goal point\n      goal_idx = i;\n      break;\n    }\n  }\n\n  //if we didn't find a valid goal point, return max\n  if(goal_idx == -1){\n    return DBL_MAX;\n  }\n\n  //convert the goal point to world coordinates\n  costmap_.mapToWorld(global_plan_[goal_idx].pose.position.x, global_plan_[goal_idx].pose.position.y, goal_x, goal_y);\n  goal_theta = tf::getYaw(global_plan_[goal_idx].pose.orientation);\n\n  //calculate the angle to the goal\n  double angle = angles::normalize_angle(atan2(goal_y - y, goal_x - x) - heading);\n  return fabs(angle);\n}", "CodeBleu_score": 54.93260583518165}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  //ROS_INFO(\\\"headingDiff\\\");\n\n    //we'll look at the global plan in reverse and find the first point with a clear line of sight\n    int i = global_plan_.size() - 1;\n    while(i >= 0) {\n      unsigned int gx, gy;\n      if(!costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, gx, gy)){\n        ROS_ERROR(\\\"Unable to convert global plan point to map coordinates!\\\");\n        return DBL_MAX;\n      }\n\n      //if there is a clear line of sight, we'll calculate the heading difference\n      if(clearLineOfSight(cell_x, cell_y, gx, gy)){\n        //convert the goal point to world coordinates\n        double wx, wy;\n        costmap_.mapToWorld(gx, gy, wx, wy);\n\n        //calculate the angle to the goal point\n        double angle = atan2(wy - y, wx - x);\n\n        //return the absolute value of the shortest angular distance\n        return fabs(normalizeAngle(angle - heading));\n      }\n\n      //we'll step backwards through the plan\n      --i;\n    }\n\n    //if we get to the end of the plan without finding a valid goal point, we'll return max value\n    return DBL_MAX;\n  }", "CodeBleu_score": 61.29960933633324}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double dx = x - costmap_.getOriginX();\n  double dy = y - costmap_.getOriginY();\n  double yaw = atan2(dy, dx);\n  double diff = angles::shortest_angular_distance(yaw, heading);\n  if (diff > M_PI) {\n    diff = 2 * M_PI - diff;\n  }\n  return fabs(diff);\n}", "CodeBleu_score": 26.537738282516045}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN(\\\"Trajectory (%.2f, %.2f, %.2f, %.2f, %.2f, %.2f) is not valid.  Cost: %.2f\\\", x, y, theta, vx, vy, vtheta, cost);\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 66.07840852135533}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  //ROS_DEBUG(\\\"Checking trajectory\\\");\n  //ROS_DEBUG(\\\"x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f\\\", x, y, theta, vx, vy, vtheta);\n  //ROS_DEBUG(\\\"vx_samp: %.2f, vy_samp: %.2f, vtheta_samp: %.2f\\\", vx_samp, vy_samp, vtheta_samp);\n\n  //calculate the trajectory costs\n  double cost = scoreTrajectory(x, y, theta, vx_samp, vy_samp, vtheta_samp);\n\n  //ROS_DEBUG(\\\"Trajectory cost: %.2f\\\", cost);\n\n  //if the trajectory is valid, return true\n  if (cost >= 0) {\n    return true;\n  }\n\n  //otherwise, log a warning and return false\n  ROS_WARN(\\\"Trajectory (%.2f, %.2f, %.2f, %.2f, %.2f, %.2f) is invalid with cost %.2f\\\", x, y, theta, vx_samp, vy_samp, vtheta_samp, cost);\n  return false;\n}", "CodeBleu_score": 60.32064841518253}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  //calculate positions\n  x_ = computeNewXPosition(x, vx, vy, theta, dt_);\n  y_ = computeNewYPosition(y, vx, vy, theta, dt_);\n  theta_ = computeNewThetaPosition(theta, vtheta, dt_);\n\n  //increment time\n  time_ += dt_;\n\n  //ROS_INFO(\\\"OccCost: %f, vx: %.2f, vy: %.2f, vtheta: %.2f\\\", occ_cost, vx_samp, vy_samp, vtheta_samp);\n  double cost = -1.0;\n  if (!heading_scoring_) {\n    cost = path_distance_bias_ * path_dist + goal_dist * goal_distance_bias_ + occdist_scale_ * occ_cost;\n  } else {\n    cost = occdist_scale_ * occ_cost + path_distance_bias_ * path_dist + 0.3 * heading_diff + goal_dist * goal_distance_bias_;\n  }\n  traj.cost_ = cost;\n\n  if (cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN(\\\"Trajectory score of %.2f for (%.2f, %.2f, %.2f, %.2f, %.2f, %.2f) is below zero.\\\", cost, x, y, theta, vx, vy, vtheta);\n    return false;\n  }\n}", "CodeBleu_score": 49.751753061765456}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_)\n  {\n    ROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\\\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Not clearing costmaps.\\\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\\\"Recovery behavior will clear inside the specified area\\\");\n  } else {\n    ROS_WARN(\\\"Recovery behavior will clear outside the specified area\\\");\n  }\n\n  ros::Time start = ros::Time::now();\n  if (affected_maps_ == \\\"both\\\" || affected_maps_ == \\\"global\\\") {\n    ROS_INFO(\\\"Clearing the global costmap\\\");\n    global_costmap_->resetWorld();\n    if (force_updating_) {\n      global_costmap_->updateMap();\n    }\n    ROS_INFO(\\\"Done clearing the global costmap, took %.3f seconds\\\", (ros::Time::now() - start).toSec());\n  }\n\n  start = ros::Time::now();\n  if (affected_maps_ == \\\"both\\\" || affected_maps_ == \\\"local\\\") {\n    ROS_INFO(\\\"Clearing the local costmap\\\");\n    local_costmap_->resetWorld();\n    if (force_updating_) {\n      local_costmap_->updateMap();\n    }\n    ROS_INFO(\\\"Done clearing the local costmap, took %.3f seconds\\\", (ros::Time::now() - start).toSec());\n  }\n}", "CodeBleu_score": 48.84210245945522}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if(!initialized_) {\n    ROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\n    return;\n  }\n  if(global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\\\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL.\\\");\n    return;\n  }\n\n  ros::Time start = ros::Time::now();\n  if(invert_area_to_clear_) {\n    ROS_WARN(\\\"Clearing costmap outside of specified area.\\\");\n  } else {\n    ROS_WARN(\\\"Clearing costmap inside of specified area.\\\");\n  }\n\n  if(affected_maps_ == \\\"local\\\") {\n    clearLocalCostmap();\n  } else if(affected_maps_ == \\\"global\\\") {\n    clearGlobalCostmap();\n  } else {\n    clearGlobalCostmap();\n    clearLocalCostmap();\n  }\n\n  if(force_updating_) {\n    global_costmap_->updateMap();\n    local_costmap_->updateMap();\n  }\n\n  ROS_INFO(\\\"Done clearing costmap (%f seconds).\\\", (ros::Time::now() - start).toSec());\n}", "CodeBleu_score": 39.304252245144355}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if(!initialized_) {\n    ROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\n    return;\n  }\n  if(global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\\\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL.\\\");\n    return;\n  }\n\n  ros::Time start = ros::Time::now();\n  if(invert_area_to_clear_) {\n    ROS_WARN(\\\"This recovery behavior will clear everything inside the specified area.\\\");\n  } else {\n    ROS_WARN(\\\"This recovery behavior will clear everything outside the specified area.\\\");\n  }\n\n  if(affected_maps_ == \\\"global\\\") {\n    clear_costmap(global_costmap_);\n  } else if(affected_maps_ == \\\"local\\\") {\n    clear_costmap(local_costmap_);\n  } else {\n    clear_costmap(global_costmap_);\n    clear_costmap(local_costmap_);\n  }\n\n  ros::Time end = ros::Time::now();\n  ROS_INFO(\\\"Clearing costmap took %.3f seconds\\\", (end - start).toSec());\n}", "CodeBleu_score": 41.062275114868676}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  // we need a place to store the line segments we create\n  std::vector<MapLocation> line_cells;\n\n  // we'll use the polygon's first point as our \"previous\" point, and then iterate through the polygon's points\n\n  // to create lines between each point and its previous one\n  MapLocation previous = polygon.front();\n  for (unsigned int i = 1; i < polygon.size(); ++i)\n  {\n    // we want to add all the cells in the line segment to our list\n    traceLine(previous, polygon[i], line_cells);\n\n    // use the current point as the previous point for the next iteration\n    previous = polygon[i];\n  }\n\n  // if we closed the polygon, we'll want to connect the last point back to the first\n  if (polygon.front() != polygon.back())\n  {\n    traceLine(previous, polygon.front(), line_cells);\n  }\n\n  // now we have all the cells in the polygon's outline, so we'll add them to our list\n  polygon_cells.insert(polygon_cells.end(), line_cells.begin(), line_cells.end());\n}", "CodeBleu_score": 46.19817602344497}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  if (polygon.empty())\n    return;\n\n  // initialize the cell vector\n  polygon_cells.clear();\n\n  // we need a local copy of the polygon, since we'll be modifying it\n  std::vector<MapLocation> local_polygon = polygon;\n\n  // if the polygon is not closed, close it\n  if (local_polygon.front().x != local_polygon.back().x || local_polygon.front().y != local_polygon.back().y)\n  {\n    local_polygon.push_back(local_polygon.front());\n  }\n\n  // iterate over the polygon's vertices\n  for (unsigned int i = 0; i < local_polygon.size() - 1; ++i)\n  {\n    // get the cells between the points\n    raytraceLine(local_polygon[i], local_polygon[i+1], polygon_cells);\n  }\n}", "CodeBleu_score": 45.50584412098395}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cells(polygon_cells);\n  if (polygon.empty())\n    return;\n\n  // iterate over the polygon\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i)\n  {\n    // use raytraceLine to get the cells between each pair of points\n    raytraceLine(polygon[i], polygon[i + 1], cells);\n  }\n\n  // connect the first and last points\n  raytraceLine(polygon.front(), polygon.back(), cells);\n}", "CodeBleu_score": 45.50606182909313}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // prepare the grid data\n  prepareGrid();\n\n  // publish the prepared grid\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  //ROS_INFO(\"Costmap2DPublisher::onNewSubscription\");\n  if (always_send_full_costmap_ || !initial_publish_)\n  {\n    nav_msgs::OccupancyGridPtr grid(new nav_msgs::OccupancyGrid);\n    prepareGrid(*grid);\n    pub.publish(grid);\n  }\n  initial_publish_ = true;\n}", "CodeBleu_score": 47.90108539494318}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  if (active_)\n    return;\n\n  active_ = true;\n\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.311593696568}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t", "CodeBleu_score": 0.7655082089124154}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // resize the vector, if necessary\n  if (grid_.info.width != x0_ || grid_.info.height != y0_)\n  {\n    grid_.info.width = x0_;\n    grid_.info.height = y0_;\n    grid_.data.resize(x0_ * y0_);\n  }\n\n  // get the resolution of the map\n  double resolution = costmap_->getResolution();\n\n  // set the grid's header\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n\n  // set the grid's resolution\n  grid_.info.resolution = resolution;\n\n  // set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin coordinates\n  ox_ = costmap_->getOriginX();\n  oy_ = costmap_->getOriginY();\n\n  // resize the grid data vector\n  grid_.data.resize(x0_ * y0_);\n\n  // populate the grid data\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < x0_ * y0_; i++)\n  {\n    grid_.data[i] = cost_translation_table_[data[i]];\n  }\n}", "CodeBleu_score": 69.49595222913769}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t", "CodeBleu_score": 0.7655082089124154}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  std::vector<geometry_msgs::Point> new_footprint, old_footprint;\n  if (!getRobotFootprint(new_config.robot_base_frame, new_footprint)) {\n    ROS_ERROR(\"Could not parse footprint string\");\n    return;\n  }\n  if (!getRobotFootprint(old_config.robot_base_frame, old_footprint)) {\n    ROS_ERROR(\"Could not parse footprint string\");\n    return;\n  }\n\n  if (new_footprint.size() != old_footprint.size()) {\n    setRobotFootprint(new_footprint);\n  } else if (new_footprint != old_footprint) {\n    setRobotFootprint(new_footprint);\n  }\n}", "CodeBleu_score": 45.475968462528016}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t", "CodeBleu_score": 4.722552995136935}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // check if the footprint has changed\n  if (new_config.footprint_string == old_config.footprint_string &&\n      new_config.footprint_radius == old_config.footprint_radius &&\n      new_config.footprint_padding == old_config.footprint_padding) {\n    return;\n  }\n\n  // check if the footprint string is valid\n  std::vector<geometry_msgs::Point> footprint;\n  if (!costmap_2d::makeFootprintFromString(new_config.footprint_string, footprint)) {\n    ROS_ERROR(\"Footprint string is not valid: %s\", new_config.footprint_string.c_str());\n    return;\n  }\n\n  // check if the footprint is valid\n  if (!layered_costmap_->isValidFootprint(footprint)) {\n    ROS_ERROR(\"Footprint is not valid: %s\", new_config.footprint_string.c_str());\n    return;\n  }\n\n  // set the footprint\n  layered_costmap_->setRobotFootprint(footprint);\n\n  // set the footprint radius\n  layered_costmap_->setFootprintRadius(new_config.footprint_radius);\n\n  // set the footprint padding\n  layered_costmap_->setFootprintPadding(new_config.footprint_padding);\n\n  // set the footprint padding\n  layered_costmap_->setFootprintPadding(new_config.footprint_padding);\n\n  // update the costmap\n  layered_costmap_->updateMap(0, 0, 0, 0);\n}", "CodeBleu_score": 51.95859195217404}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  // check if the costmap needs to be updated\n  if (publish_cycle.isZero() || event.current_real - last_publish_ > publish_cycle) {\n    last_publish_ = event.current_real;\n    publishCostmap();\n  }\n\n  if (map_update_thread_shutdown_) {\n    return;\n  }\n\n  // check if the costmap needs to be updated\n  if (update_cycle.isZero() || event.current_real - last_updated_ > update_cycle) {\n    last_updated_ = event.current_real;\n    updateMap();\n  }\n}", "CodeBleu_score": 37.56655741036556}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  // get the list of plugins\n  std::vector<boost::shared_ptr<layer::Layer> >* plugins = layered_costmap_->getPlugins();\n  // check if the costmap was stopped\n  if (stopped_) {\n    // re-subscribe to topics by activating each plugin\n    for (unsigned int i = 0; i < plugins->size(); i++) {\n      (*plugins)[i]->activate();\n    }\n    // set the stopped flag to false\n    stopped_ = false;\n  }\n  // set stop_updates_ to false\n  stop_updates_ = false;\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::isInitialized() && !layered_costmap_->isInitialized() && map_update_thread_ == NULL) {\n    usleep(100000);\n  }\n}", "CodeBleu_score": 57.11984529493328}, {"code": "void Costmap2DROS::start(){\n\t  // reactivate plugins if they were stopped\n  std::vector<std::string> plugins = layered_costmap_->getPlugins();\n  for (unsigned int i = 0; i < plugins.size(); ++i) {\n    layered_costmap_->activatePlugin(plugins[i]);\n  }\n\n  // check if costmap was stopped\n  if (stopped_) {\n    // re-subscribe to topics\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      layered_costmap_->activatePlugin(plugins[i]);\n    }\n    stopped_ = false;\n  }\n\n  // set stop_updates_ to false\n  stop_updates_ = false;\n\n  // wait until ROS is running, costmap is initialized, and map update thread is active\n  while (!ros::isInitialized() || !layered_costmap_->isInitialized() || map_update_thread_ == NULL) {\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 57.074897914527035}, {"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    std::vector<std::string> plugin_names = layered_costmap_->getPlugins();\n    for (std::vector<std::string>::iterator it = plugin_names.begin(); it != plugin_names.end(); ++it) {\n      layered_costmap_->activatePlugin(*it);\n    }\n    stopped_ = false;\n  }\n\n  // wait for ROS to come up\n  while (!ros::isInitialized() && ros::ok()) {\n    ros::spinOnce();\n    ros::WallDuration(0.1).sleep();\n  }\n\n  // wait for costmap to become initialized\n  while (!initialized_ && ros::ok()) {\n    ros::spinOnce();\n    ros::WallDuration(0.1).sleep();\n  }\n\n  // wait for map update thread to become active\n  while (map_update_thread_ == NULL && ros::ok()) {\n    ros::spinOnce();\n    ros::WallDuration(0.1).sleep();\n  }\n}", "CodeBleu_score": 45.70000989536008}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  ros::Time now = ros::Time::now();\n  ros::Duration keep_time = observation_keep_time_ > ros::Duration(0) ? observation_keep_time_ : ros::Duration(0, 1);\n  ros::Duration max_age = now - last_updated_ - keep_time;\n  // if we have a keep time, we only want to keep observations that are less than the keep time old\n  if (max_age > ros::Duration(0))\n  {\n    list<Observation>::iterator obs_it = observation_list_.begin();\n    while (obs_it != observation_list_.end() && (now - obs_it->cloud_->header.stamp) < max_age)\n    {\n      // we found a valid observation, so we'll stop removing\n      ++obs_it;\n    }\n\n    // remove all the stale observations from the list\n    observation_list_.erase(observation_list_.begin(), obs_it);\n  }\n}", "CodeBleu_score": 46.94611656745982}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  // if we've been asked to keep only the most recent observation, we'll just clear the list and return\n  if (observation_keep_time_ == 0.0)\n  {\n    observation_list_.clear();\n    return;\n  }\n\n  // otherwise, we'll iterate through the list and remove observations that are older than the specified keep time\n  ros::Time now = ros::Time::now();\n  ros::Duration keep_time(observation_keep_time_);\n  list<Observation>::iterator obs_it = observation_list_.begin();\n  while (obs_it != observation_list_.end())\n  {\n    if (now - obs_it->origin_time_ > keep_time)\n    {\n      obs_it = observation_list_.erase(obs_it);\n    }\n    else\n    {\n      break;\n    }\n  }\n}", "CodeBleu_score": 44.541353268912914}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t", "CodeBleu_score": 1.4641945780713905}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double diff = angles::shortest_angular_distance(end_yaw, start_yaw);\n  double increment = diff / (end_index - start_index);\n  for (int i = start_index; i < end_index; ++i) {\n    double yaw = start_yaw + (i - start_index) * increment;\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 68.25499114129848}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n  double inc = diff / (end_index - start_index);\n  for (int i = start_index; i < end_index; ++i) {\n    double yaw = start_yaw + inc * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 71.46634373389851}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n  double diff = angles::shortest_angular_distance(end_angle, start_angle);\n  double increment = diff / (end_index - start_index);\n  for (int i = start_index; i < end_index; i++) {\n    double angle = start_angle + increment * (i - start_index);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 70.3337988271779}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    resp.plan.poses.clear();\n    if (makePlan(req.start, req.goal, resp.plan.poses)) {\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        resp.success = true;\n    } else {\n        resp.success = false;\n    }\n    return true;\n}", "CodeBleu_score": 50.491913824696475}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    vector<geometry_msgs::PoseStamped> plan;\n    bool success = makePlan(req.start, req.goal, plan);\n\n    // Update the response with the success status and the generated path\n    resp.plan.poses = plan;\n    resp.plan.header.frame_id = \"map\";\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 65.36786403823321}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    vector<geometry_msgs::PoseStamped> plan;\n    bool found_plan = makePlan(req.start, req.goal, plan);\n\n    // Update the response with the success status and the generated path if a plan is found\n    if (found_plan) {\n        resp.plan = plan;\n        resp.plan.header.frame_id = \"map\";\n    }\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 70.33744852948819}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle nh;\n    make_plan_service_ = nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n    cmap_ = cmap;\n}", "CodeBleu_score": 52.751980300342595}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    cmap_ = cmap;\n    ros::NodeHandle private_nh(\\\"~\\\");\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 58.37495492802901}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    cmap_ = cmap;\n    ros::NodeHandle n;\n    make_plan_service_ = n.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = n.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 71.20249144431206}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n        wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n        wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n        return false;\n    }\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n    return true;\n}", "CodeBleu_score": 48.89002012090248}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n        wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n        wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n        return false;\n    }\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n    if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 50.90782823469993}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n    return false;\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n    return true;\n\n  return false;\n}", "CodeBleu_score": 53.10293656183514}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  //create a message for the plan\n  nav_msgs::Path gui_path;\\\n  gui_path.poses.resize(path.size());\n\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.60333931056728}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  //create a message for the plan\n  nav_msgs::Path gui_path;\\\n  gui_path.poses.resize(path.size());\n\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) gui_path.poses[i] = path[i];\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 87.66668734287623}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  //create a message for the plan\n  nav_msgs::Path gui_path;\\\n  gui_path.poses.resize(path.size());\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) gui_path.poses[i] = path[i];\n  //send the path to the visualization markers\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 87.66668734287623}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  boost::unique_lock<boost::recursive_mutex> lock(configuration_mutex_);\n  ROS_DEBUG_NAMED(ROS_NAME, \"Got a goal\");\n\n  //check to see if we've been asked to prempt all goal subscriptions\n  if(preempt_all_subscriptions_)\n  {\n    ROS_INFO_NAMED(ROS_NAME, \"Preempting all goal subscriptions\");\n    as_->setPreemptAll();\n  }\n\n  //create an action goal and populate it with our goal\n\n    move_base_msgs::MoveBaseGoal action_goal;\n    action_goal.target_pose = *goal;\n\n    //publish the action goal\n    action_goal_pub_.publish(action_goal);\n\n    //set the action state to PENDING\n    as_->acceptNewGoal(action_goal);\n  }", "CodeBleu_score": 42.02996640481115}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 7.204876027809698}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 7.204876027809698}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_distance = getSqDistance();\n  if(sq_distance > limited_distance_ * limited_distance_)\n  {\n    ROS_INFO(\\\"Move slow and clear recovery behavior succeeded.\\\");\n    distance_check_timer_.stop();\n    if(remove_limit_thread_)\n    {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 66.69438903761262}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > limited_distance_ * limited_distance_) {\n    ROS_WARN(\\\"Move slow and clear recovery behavior complete.\\\");\n    distance_check_timer_.stop();\n    delete remove_limit_thread_;\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n  }\n}", "CodeBleu_score": 50.20055074913273}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    double sq_distance = getSqDistance();\n    if(sq_distance > limited_distance_ * limited_distance_)\n    {\n        ROS_INFO(\\\"Move slow and clear recovery behavior succeeded.\\\");\n        distance_check_timer_.stop();\n        if(remove_limit_thread_ != NULL)\n        {\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n        }\n        remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    }\n}", "CodeBleu_score": 62.26321200604459}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  vector<PoseStamped> path;\n  bool success = false;\n  try {\n    tf2_ros::Buffer tf_buffer;\n    tf2_ros::TransformListener tf_listener(tf_buffer);\n\n    rm::PoseStamped global_pose;\n    tf_buffer.transform(goal, global_pose, \\\"map\\\");\n\n    success = makePlan(global_pose, path);\n  }\n  catch (tf2::TransformException& ex) {\n    ROS_WARN(\\\"%s\\\", ex.what());\n    return;\n  }\n\n  if (success) {\n    publishPlan(path);\n  }\n}", "CodeBleu_score": 49.732348191862705}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  vector<PoseStamped> path;\n\n  if (!makePlan(goal->pose, path)) {\n    ROS_ERROR(\\\"Failed to generate a plan\\\");\n  }\n}", "CodeBleu_score": 40.01282002466574}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  vector<PoseStamped> path;\n  PoseStamped global_pose;\n  cmap_->getRobotPose(global_pose);\n  global_pose.header.frame_id = \\\"map\\\";\n  bool success = makePlan(global_pose, *goal, path);\n  if (success) {\n    publishPlan(path);\n  }\n}", "CodeBleu_score": 63.34657194757237}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 70.01936124391204}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_msg;\n    param_set_msg.request.param_id = param_set.param_id;\n    param_set_msg.request.value.integer = param_set.value.integer;\n    param_set_msg.request.value.real = param_set.value.real;\n    param_set_msg.request.value.str = param_set.value.str;\n    param_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 53.50278620210042}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.integer = param_set.value.integer;\n    param_set_srv.request.value.real = param_set.value.real;\n    param_set_srv.request.value.type = param_set.value.type;\n    param_set_srv.request.value.str_value = param_set.value.str_value;\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 56.296416811466024}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t    ros::Rate loop_rate(100);\n    while (ros::ok()) {\n        // \u5982\u679c\u6709\u8fde\u63a5\u8bf7\u6c42\uff0c\u5c31\u63a5\u53d7\u8fde\u63a5\n        if (this->acceptTcpConnection()) {\n            // \u63a5\u53d7\u8fde\u63a5\u6210\u529f\uff0c\u5f00\u59cb\u5904\u7406\u6570\u636e\n            this->processTcpData();\n        }\n        loop_rate.sleep();\n    }\n}", "CodeBleu_score": 6.674754880866429}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->swarm_control_ != NULL && this->swarm_num_ != 0) {\n        // \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->updateAllUAVCommand(uav_cmd);\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n    }\n}", "CodeBleu_score": 30.153400575210636}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (!this->is_simulation_) {\n    if (this->uav_basic_ != NULL) {\n      // \u53d1\u5e03\u8bdd\u9898\n      this->uav_basic_->publishUAVCommand(uav_cmd);\n    }\n  } else {\n    if (this->swarm_control_ != NULL && this->swarm_num_ != 0) {\n      // \u627e\u5230\u5bf9\u5e94\u7684UAV\n      int uav_id = uav_cmd.uav_id;\n      int ugv_id = uav_cmd.ugv_id;\n      int swarm_id = uav_cmd.swarm_id;\n      int uav_index = this->swarm_control_->findUAVIndexByID(uav_id);\n      int ugv_index = this->swarm_control_->findUGVIndexByID(ugv_id);\n      int swarm_index = this->swarm_control_->findSwarmIndexByID(swarm_id);\n      if (uav_index >= 0) {\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->updateUAVCommand(uav_index, uav_cmd);\n        this->swarm_control_->publishUAVCommand(uav_index);\n      } else if (ugv_index >= 0) {\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->updateUGVCommand(ugv_index, uav_cmd);\n        this->swarm_control_->publishUGVCommand(ugv_index);\n      } else if (swarm_index >= 0) {\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->updateSwarmCommand(swarm_index, uav_cmd);\n        this->swarm_control_->publishSwarmCommand(swarm_index);\n      }\n    }\n  }\n}", "CodeBleu_score": 48.89023622333761}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->swarm_control_ != NULL && this->swarm_num_ != 0) {\n        // \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->updateAllUAVCommand(uav_cmd);\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n    } else {\n        if (this->is_simulation_ == 1) {\n            // \u4eff\u771f\u6a21\u5f0f\u4e0b\uff0c\u6839\u636eID\u67e5\u627e\u5bf9\u5e94\u7684UAV\n            for (int i = 0; i < this->swarm_num_; i++) {\n                if (this->swarm_control_simulation_[i]->getUAVID() == uav_cmd.uav_id) {\n                    // \u53d1\u5e03\u8bdd\u9898\n                    this->swarm_control_simulation_[i]->uavCommandPub(uav_cmd);\n                }\n            }\n        } else {\n            // \u53d1\u5e03\u8bdd\u9898\n            this->uav_basic_->uavCommandPub(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 56.071606585391805}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    // \u91cd\u542fNX\n    if (mode_selection.use_mode == ModeSelection::Mode::REBOOTNX) {\n        system(\"reboot\");\n        return;\n    }\n    // \u9000\u51faNX\n    if (mode_selection.use_mode == ModeSelection::Mode::EXITNX) {\n        system(\"exit\");\n        return;\n    }\n    // \u521b\u5efa\u6a21\u5f0f\n    if (mode_selection.use_mode == ModeSelection::Mode::CREATENX) {\n        createMode(mode_selection);\n        return;\n    }\n    // \u5220\u9664\u6a21\u5f0f\n    if (mode_selection.use_mode == ModeSelection::Mode::DELETENX) {\n        deleteMode(mode_selection);\n        return;\n    }\n}", "CodeBleu_score": 66.18296879994048}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  // \u5224\u65ad\u662f\u5426\u9700\u8981\u91cd\u542fNX\u7cfb\u7edf\n  if (mode_selection.use_mode == ModeSelection::Mode::REBOOTNX) {\n    // \u6267\u884c\u91cd\u542fNX\u7cfb\u7edf\u7684\u7cfb\u7edf\u547d\u4ee4\n    system(\"reboot\");\n  } else if (mode_selection.use_mode == ModeSelection::Mode::EXITNX) {\n    // \u6267\u884c\u9000\u51faNX\u7cfb\u7edf\u7684\u7cfb\u7edf\u547d\u4ee4\n    system(\"reboot -p\");\n  } else {\n    // \u6839\u636euse_mode\u5b57\u6bb5\u7684\u503c\uff0c\u8c03\u7528createMode\u6216deleteMode\u51fd\u6570\n    if (mode_selection.use_mode == ModeSelection::Mode::CREATEMODE) {\n      createMode(mode_selection);\n    } else if (mode_selection.use_mode == ModeSelection::Mode::DELETEMODE) {\n      deleteMode(mode_selection);\n    }\n  }\n}", "CodeBleu_score": 74.9180732439205}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t", "CodeBleu_score": 4.546652861136631}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // \u521b\u5efa\u6ee4\u6ce2\u5668\u5bf9\u8c61\n  pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n  octree.setInputCloud(cloud);\n  octree.defineCompressionOctree(cloud);\n\n  // \u538b\u7f29\u70b9\u4e91\n  std::vector<int> pointIdxVector;\n  octree.getOccupiedVoxelCenters(pointIdxVector);\n\n  // \u8f6c\u6362\u56de ROS \u70b9\u4e91\u6d88\u606f\n  sensor_msgs::PointCloud2 compressed_msg;\n  pcl::toROSMsg(*cloud, compressed_msg);\n  compressed_msg.header = msg.header;\n\n  return compressed_msg;\n}", "CodeBleu_score": 35.60742702691975}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // \u521b\u5efa\u6ee4\u6ce2\u5668\u5bf9\u8c61\n    pcl::octree::OctreePointCloudChangeDetector<pcl::PointXYZ> octree(0.1);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    // \u538b\u7f29\u70b9\u4e91\n    std::vector<int> newPointIdxVector;\n    octree.getPointIndicesFromNewVoxels(newPointIdxVector);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*cloud, newPointIdxVector, *compressed_cloud);\n\n    // \u8f6c\u6362\u56de ROS \u70b9\u4e91\u6d88\u606f\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::toROSMsg(*compressed_cloud, compressed_msg);\n    compressed_msg.header = msg.header;\n\n    return compressed_msg;\n}", "CodeBleu_score": 44.777823265830065}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // \u521b\u5efa\u6ee4\u6ce2\u5668\u5bf9\u8c61\n    pcl::octree::OctreePointCloud<pcl::PointXYZ> octree(0.1);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    // \u538b\u7f29\u70b9\u4e91\n    std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> compressed_clouds;\n    octree.getOccupiedVoxelCenters(compressed_clouds);\n\n    // \u8f6c\u6362\u56de ROS \u70b9\u4e91\u6d88\u606f\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::toROSMsg(*compressed_clouds[0], compressed_msg);\n    compressed_msg.header = msg.header;\n\n    return compressed_msg;\n}", "CodeBleu_score": 38.23576246893584}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 86.38256457558022}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); ++i) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 93.55567312906258}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (auto &uav_state_ : this->multi_uav_state_.uav_state_all) {\n    if (uav_state_.uav_id == uav_state.uav_id) {\n      uav_state_ = uav_state;\n    }\n  }\n}", "CodeBleu_score": 38.89491476603559}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  prometheus_msgs::MultiUGVState multi_ugv_state;\n  multi_ugv_state.ugv_num = 0;\n\n  for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n    prometheus_msgs::UGVState ugv_state;\n    ugv_state.ugv_id = (*it).ugv_id;\n    ugv_state.battery = (*it).battery;\n    for (int i = 0; i < 3; i++) {\n      ugv_state.position[i] = (*it).position[i];\n      ugv_state.velocity[i] = (*it).velocity[i];\n      ugv_state.attitude[i] = (*it).attitude[i];\n    };\n    ugv_state.attitude_q.x = (*it).attitude_q.x;\n    ugv_state.attitude_q.y = (*it).attitude_q.y;\n    ugv_state.attitude_q.z = (*it).attitude_q.z;\n    ugv_state.attitude_q.w = (*it).attitude_q.w;\n    multi_ugv_state.ugv_num++;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // \u53d1\u5e03\u8bdd\u9898\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 94.71452390987551}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  prometheus_msgs::MultiUGVState multi_ugv_state;\n  multi_ugv_state.ugv_num = 0;\n\n  for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n    prometheus_msgs::UGVState ugv_state;\n    ugv_state.ugv_id = (*it).ugv_id;\n    ugv_state.battery_state = (*it).battery_state;\n    ugv_state.battery_percetage = (*it).battery_percetage;\n    for (int i = 0; i < 3; i++) {\n      ugv_state.position[i] = (*it).position[i];\n      ugv_state.velocity[i] = (*it).velocity[i];\n      ugv_state.attitude[i] = (*it).attitude[i];\n      ugv_state.attitude_rate[i] = (*it).attitude_rate[i];\n    };\n    ugv_state.attitude_q.x = (*it).attitude_q.x;\n    ugv_state.attitude_q.y = (*it).attitude_q.y;\n    ugv_state.attitude_q.z = (*it).attitude_q.z;\n    ugv_state.attitude_q.w = (*it).attitude_q.w;\n    multi_ugv_state.ugv_num++;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // \u53d1\u5e03\u8bdd\u9898\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 90.5122691837546}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    prometheus_msgs::MultiUGVState multi_ugv_state;\n    multi_ugv_state.ugv_num = 0;\n\n    for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n        prometheus_msgs::UGVState ugv_state;\n        ugv_state.ugv_id = (*it).ugv_id;\n        ugv_state.battery_state = (*it).battery_state;\n        ugv_state.battery_percetage = (*it).battery_percetage;\n        for (int i = 0; i < 3; i++) {\n            ugv_state.position[i] = (*it).position[i];\n            ugv_state.velocity[i] = (*it).velocity[i];\n            ugv_state.attitude[i] = (*it).attitude[i];\n            ugv_state.attitude_rate[i] = (*it).attitude_rate[i];\n        };\n        ugv_state.attitude_q.x = (*it).attitude_q.x;\n        ugv_state.attitude_q.y = (*it).attitude_q.y;\n        ugv_state.attitude_q.z = (*it).attitude_q.z;\n        ugv_state.attitude_q.w = (*it).attitude_q.w;\n        multi_ugv_state.ugv_num++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n\n    // \u53d1\u5e03\u8bdd\u9898\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 90.65088777104262}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n  const double CLEARANCE = moving_obj_clearance_;\n  double t_now = ros::Time::now().toSec();\n  for (int i = order_; i < end_idx; i++) {\n    double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n    for (size_t id = 0; id < moving_objs_->size(); id++) {\n      double traj_i_satrt_time = moving_objs_->at(id).start_time_.toSec();\n      if (glb_time < traj_i_satrt_time + moving_objs_->at(id).duration_ - 0.1) {\n        Eigen::Vector3d moving_obj_prid = moving_objs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n        double dist_err = (cps_.points.col(i) - moving_obj_prid).norm() - CLEARANCE;\n        if (dist_err < 0) {\n          /* do nothing */\n        } else {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += 2 * dist_err * (cps_.points.col(i) - moving_obj_prid).normalized();\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 72.91140147266127}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double a2 = 1.0, b2 = 1.0;\n\n    for (auto i = order_; i < end_idx; ++i) {\n        for (size_t j = 0; j < cps_.direction[i].size(); ++j) {\n            double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n            double dist_err = cps_.clearance - dist;\n            Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n            if (dist_err < 0) {\n                /* do nothing */\n            } else {\n                cost += dist_err * dist_err / a2;\n                gradient.col(i) += -2.0 * dist_err / a2 * dist_grad;\n            }\n\n            Eigen::Vector3d vel_vec = cps_.velocity[i][j];\n            double vel_err = vel_vec.dot(cps_.direction[i][j]);\n            Eigen::Vector3d vel_grad = cps_.direction[i][j];\n\n            if (vel_err < 0) {\n                /* do nothing */\n            } else {\n                cost += vel_err * vel_err / b2;\n                gradient.col(i) += -2.0 * vel_err / b2 * vel_grad;\n            }\n\n            Eigen::Vector3d cross_vec = vel_vec.cross(cps_.direction[i][j]);\n            double cross_err = cross_vec.norm();\n            Eigen::Vector3d cross_grad = cross_vec.normalized();\n\n            if (cross_err < 0) {\n                /* do nothing */\n            } else {\n                cost += cross_err * cross_err;\n                gradient.col(i) += -2.0 * cross_err * cross_grad;\n            }\n        }\n    }\n}", "CodeBleu_score": 43.67912717504863}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    const double a2 = 0.0001, b2 = 0.0001;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++) {\n        double time = ((double) (order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n        Eigen::Vector3d pos_err = cps_.points.col(i) - cps_.base_point[i][0];\n        Eigen::Vector3d vel_vec = (cps_.points.col(i + 1) - cps_.points.col(i - 1)) / (2 * bspline_interval_);\n        double vel_err = (cps_.points.col(i) - cps_.base_point[i][0]).dot(vel_vec);\n        double pos_err_norm = pos_err.norm();\n        double vel_err_norm = vel_vec.norm();\n        Eigen::Vector3d pos_err_norm_grad = pos_err / pos_err_norm;\n        Eigen::Vector3d vel_err_norm_grad = vel_vec / vel_err_norm;\n        Eigen::Vector3d pos_err_grad = -pos_err_norm_grad;\n        Eigen::Vector3d vel_err_grad = -vel_err_norm_grad;\n\n        cost += pos_err_norm * pos_err_norm * a2 + vel_err_norm * vel_err_norm * b2;\n        gradient.col(i) += pos_err_grad * 2 * a2 + vel_err_grad * 2 * b2;\n    }\n}", "CodeBleu_score": 45.28192940338578}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  int end_idx = q.cols() - order_;\n  constexpr double a2 = 1.0, b2 = 1.0;\n  double t_now = ros::Time::now().toSec();\n\n  /*** calculate fitness cost and gradient ***/\n  for (int i = order_; i < end_idx; ++i) {\n    double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n    Eigen::Vector3d pos_err = cps_.points.col(i) - cps_.ref_points.col(i);\n    Eigen::Vector3d vel_vec = cps_.direction[i][0];\n    double dot_prod = pos_err.dot(vel_vec);\n    Eigen::Vector3d cross_prod = pos_err.cross(vel_vec);\n    cost += a2 * dot_prod * dot_prod + b2 * cross_prod.squaredNorm();\n    gradient.col(i) += -2.0 * a2 * dot_prod * vel_vec + 4.0 * b2 * cross_prod;\n  }\n}", "CodeBleu_score": 42.153870941146245}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t", "CodeBleu_score": 1.1628100042452454}, {"code": "double UniformBspline::getJerk(){\n\t  // get third derivative\n  Eigen::MatrixXd jerk_pts = evaluateDeBoorT(3);\n\n  // get knot times\n  Eigen::VectorXd knot_times = getKnot();\n\n  // get control points\n  Eigen::MatrixXd ctrl_pts = getCtrlPts();\n\n  // initialize jerk\n  double jerk = 0.0;\n\n  // iterate through control points and dimensions\n  for (int i = 0; i < ctrl_pts.cols(); ++i) {\n    for (int j = 0; j < ctrl_pts.rows(); ++j) {\n      // sum squared control point values multiplied by differences in knot times\n      jerk += jerk_pts(j, i) * jerk_pts(j, i) * (knot_times(i + 3) - knot_times(i));\n    }\n  }\n\n  // return total jerk\n  return jerk;\n}", "CodeBleu_score": 58.72062874810824}, {"code": "double UniformBspline::getJerk(){\n\t  double jerk = 0.0;\n  double dur = getTimeSum();\n  Eigen::VectorXd p_l = evaluateDeBoorT(0.0), p_n;\n  for (double t = 0.0; t <= dur + 1e-4; t += 0.01) {\n    p_n = evaluateDeBoorT(t);\n    jerk += (p_n - p_l).squaredNorm();\n    p_l = p_n;\n  }\n  return jerk;\n}", "CodeBleu_score": 30.64048590757406}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    // 3D position in camera frame\n    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.43444769802734}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.35005343899863}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    double x = (u - cx_) / fx_;\n    double y = (v - cy_) / fy_;\n    double z = depth;\n    Eigen::Vector4d pos(x, y, z, 1.0);\n    return pos;\n}", "CodeBleu_score": 39.870673272719635}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    int drone_id = std::stoi(odom.child_frame_id.substr(5));\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (const std::exception& e) {\n    ROS_ERROR(\"Exception caught: %s\", e.what());\n  }\n}", "CodeBleu_score": 58.33929837861318}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    int drone_id = std::stoi(odom.child_frame_id.substr(odom.child_frame_id.find(\"drone\") + 5));\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (std::exception& e) {\n    ROS_ERROR(\"Exception caught: %s\", e.what());\n  }\n}", "CodeBleu_score": 55.62890606187253}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    int drone_id = std::stoi(odom.child_frame_id.substr(5));\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (std::exception& e) {\n    ROS_ERROR(\"Error: %s\", e.what());\n  }\n}", "CodeBleu_score": 56.6729406500073}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // ROS_WARN(\"DroneDetector::detect\");\n  Eigen::Vector3d true_pose_cam;\n  bool found = false;\n  found = search(drone_id, true_pixel, true_pose_cam);\n  if (found) {\n    Eigen::Vector3d true_pose_world = cam2World(true_pose_cam);\n    double pose_error = getPoseError(true_pose_world, drone_pose_world_[drone_id]);\n    result_.pose_error = pose_error;\n    result_.detected = true;\n    result_.true_pose_world = true_pose_world;\n    result_.true_pixel = true_pixel;\n    result_.true_pose_cam = true_pose_cam;\n    result_.drone_id = drone_id;\n  } else {\n    result_.detected = false;\n    result_.true_pixel = true_pixel;\n    result_.true_pose_cam = true_pose_cam;\n    result_.drone_id = drone_id;\n  }\n  result_pub_.publish(result_);\n}", "CodeBleu_score": 49.93197317690217}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        path.push_back(current->cameFrom);\n        current = current->cameFrom;\n    }\n    return path;\n}", "CodeBleu_score": 87.07610576529899}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> Path;\n\n    while (!(current->index == start_node_->index)) {\n        Path.push_back(current);\n        current = current->cameFrom;\n    }\n    Path.push_back(start_node_);\n    reverse(Path.begin(), Path.end());\n\n    return Path;\n}", "CodeBleu_score": 59.563790147835405}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        path.push_back(current->cameFrom);\n        current = current->cameFrom;\n    }\n    return path;\n}", "CodeBleu_score": 83.04513295405867}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    // Convert start and end points to indices\n    start_idx = grid_map_->getIndex(start_pt);\n    end_idx = grid_map_->getIndex(end_pt);\n\n    // Check if start or end point is inside an obstacle\n    if (grid_map_->isOccupied(start_idx) || grid_map_->isOccupied(end_idx)) {\n        // Adjust start point if it is inside an obstacle\n        if (grid_map_->isOccupied(start_idx)) {\n            Vector3d adjusted_start_pt = start_pt;\n            while (grid_map_->isOccupied(grid_map_->getIndex(adjusted_start_pt))) {\n                adjusted_start_pt += (start_pt - adjusted_start_pt).normalized() * 0.01;\n            }\n            start_idx = grid_map_->getIndex(adjusted_start_pt);\n        }\n\n        // Adjust end point if it is inside an obstacle\n        if (grid_map_->isOccupied(end_idx)) {\n            Vector3d adjusted_end_pt = end_pt;\n            while (grid_map_->isOccupied(grid_map_->getIndex(adjusted_end_pt))) {\n                adjusted_end_pt -= (adjusted_end_pt - end_pt).normalized() * 0.01;\n            }\n            end_idx = grid_map_->getIndex(adjusted_end_pt);\n        }\n    }\n\n    // Check if start and end points are still inside an obstacle\n    if (grid_map_->isOccupied(start_idx) || grid_map_->isOccupied(end_idx)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 43.47697875589901}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start point to index\n  start_idx = grid_map_->getGridIndex(start_pt);\n\n  // Convert end point to index\n  end_idx = grid_map_->getGridIndex(end_pt);\n\n  // Check if start or end point is inside an obstacle\n  if (grid_map_->isOccupied(start_idx) || grid_map_->isOccupied(end_idx)) {\n    // If start point is inside an obstacle, adjust it by moving it away from end point\n    if (grid_map_->isOccupied(start_idx)) {\n      Vector3i dir = end_idx - start_idx;\n      Vector3i step(dir.cwiseSign());\n      Vector3i new_start_idx = start_idx;\n      while (grid_map_->isOccupied(new_start_idx)) {\n        new_start_idx += step;\n      }\n      start_idx = new_start_idx;\n    }\n\n    // If end point is inside an obstacle, adjust it by moving it away from start point\n    if (grid_map_->isOccupied(end_idx)) {\n      Vector3i dir = start_idx - end_idx;\n      Vector3i step(dir.cwiseSign());\n      Vector3i new_end_idx = end_idx;\n      while (grid_map_->isOccupied(new_end_idx)) {\n        new_end_idx += step;\n      }\n      end_idx = new_end_idx;\n    }\n  }\n\n  // Check if start or end point is still inside an obstacle after adjustment\n  if (grid_map_->isOccupied(start_idx) || grid_map_->isOccupied(end_idx)) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 38.641627676447584}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start point to grid index\n  start_idx = grid_map_->getGridIndex(start_pt);\n\n  // Convert end point to grid index\n  end_idx = grid_map_->getGridIndex(end_pt);\n\n  // Check if start point is inside an obstacle\n  if (grid_map_->isObs(start_idx)) {\n    // Adjust start point until it is no longer inside an obstacle\n    while (grid_map_->isObs(start_idx)) {\n      // Move start point away from end point\n      start_idx = start_idx + (end_idx - start_idx).normalized();\n\n      // Check if start point is still inside an obstacle\n      if (grid_map_->isObs(start_idx)) {\n        // If start point is still inside an obstacle, adjust it further\n        start_idx = start_idx + (end_idx - start_idx).normalized();\n      }\n    }\n  }\n\n  // Check if end point is inside an obstacle\n  if (grid_map_->isObs(end_idx)) {\n    // Adjust end point until it is no longer inside an obstacle\n    while (grid_map_->isObs(end_idx)) {\n      // Move end point away from start point\n      end_idx = end_idx + (start_idx - end_idx).normalized();\n\n      // Check if end point is still inside an obstacle\n      if (grid_map_->isObs(end_idx)) {\n        // If end point is still inside an obstacle, adjust it further\n        end_idx = end_idx + (start_idx - end_idx).normalized();\n      }\n    }\n  }\n\n  // Check if start and end points are now inside an obstacle\n  if (grid_map_->isObs(start_idx) || grid_map_->isObs(end_idx)) {\n    // If start or end point is still inside an obstacle, return false\n    return false;\n  }\n\n  // If start and end points are not inside an obstacle, return true\n  return true;\n}", "CodeBleu_score": 35.194099044132}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  // \u5c06\u4e16\u754c\u5750\u6807\u7cfb\u4e0b\u7684\u70b9\u8f6c\u6362\u5230\u6805\u683c\u5730\u56fe\u5750\u6807\u7cfb\u4e0b\n  min_id = coordWorld2Grid(min_pos);\n  max_id = coordWorld2Grid(max_pos);\n\n  // \u5224\u65ad\u662f\u5426\u8d8a\u754c\n  min_id = min_id.cwiseMax(Eigen::Vector3i::Zero());\n  min_id = min_id.cwiseMin(mp_.map_voxel_num_ - Eigen::Vector3i::Ones());\n  max_id = max_id.cwiseMax(Eigen::Vector3i::Zero());\n  max_id = max_id.cwiseMin(mp_.map_voxel_num_ - Eigen::Vector3i::Ones());\n\n  // \u904d\u5386\u91cd\u7f6e\n  for (int k = min_id(2); k <= max_id(2); ++k)\n  {\n    for (int j = min_id(1); j <= max_id(1); ++j)\n    {\n      for (int i = min_id(0); i <= max_id(0); ++i)\n      {\n        int index = getIndex(i, j, k);\n        md_.occupancy_buffer_inflate_[index] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 49.423980090880846}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t", "CodeBleu_score": 4.296121109088976}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  // \u8ba1\u7b97\u9700\u8981\u91cd\u7f6e\u7684\u8303\u56f4\n  min_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n  max_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\n  // \u91cd\u7f6e\u5bf9\u5e94\u7684buffer\n  for (int i = min_id(0); i <= max_id(0); ++i)\n  {\n    for (int j = min_id(1); j <= max_id(1); ++j)\n    {\n      for (int k = min_id(2); k <= max_id(2); ++k)\n      {\n        int index = getIndex(i, j, k);\n        md_.occupancy_buffer_inflate_[index] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 56.01325375402114}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  double max_x = diff(0) > 0 ? mp_.map_size_(0) - camera_pt(0) : -camera_pt(0);\n  double max_y = diff(1) > 0 ? mp_.map_size_(1) - camera_pt(1) : -camera_pt(1);\n  double max_z = diff(2) > 0 ? mp_.map_size_(2) - camera_pt(2) : -camera_pt(2);\n  double min_x = diff(0) > 0 ? camera_pt(0) : -camera_pt(0);\n  double min_y = diff(1) > 0 ? camera_pt(1) : -camera_pt(1);\n  double min_z = diff(2) > 0 ? camera_pt(2) : -camera_pt(2);\n  double max_coeff = std::max(std::max(max_x, max_y), max_z);\n  double min_coeff = std::min(std::min(min_x, min_y), min_z);\n  double coeff = min_coeff > 0 ? min_coeff : max_coeff;\n  return pt + diff / diff.norm() * coeff;\n}", "CodeBleu_score": 36.2001350436776}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n  // calculate the difference vector between the point and the camera position\n  Eigen::Vector3d diff = pt - camera_pt;\n\n  // determine the maximum and minimum translation coefficients along each axis\n  double max_tx = (mp_.map_size_x_ - camera_pt(0)) / diff(0);\n  double min_tx = -camera_pt(0) / diff(0);\n  double max_ty = (mp_.map_size_y_ - camera_pt(1)) / diff(1);\n  double min_ty = -camera_pt(1) / diff(1);\n  double max_tz = (mp_.map_size_z_ - camera_pt(2)) / diff(2);\n  double min_tz = -camera_pt(2) / diff(2);\n\n  // find the minimum positive scaling factor that keeps the point within map boundaries\n  double tx = std::max(std::min(max_tx, min_tx), 0.0);\n  double ty = std::max(std::min(max_ty, min_ty), 0.0);\n  double tz = std::max(std::min(max_tz, min_tz), 0.0);\n\n  // return the adjusted point near the boundary\n  return camera_pt + diff * std::min(std::min(tx, ty), tz);\n}", "CodeBleu_score": 36.47873404433546}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  double max_x = std::numeric_limits<double>::max();\n  double max_y = std::numeric_limits<double>::max();\n  double max_z = std::numeric_limits<double>::max();\n  double min_x = std::numeric_limits<double>::min();\n  double min_y = std::numeric_limits<double>::min();\n  double min_z = std::numeric_limits<double>::min();\n\n  if (diff(0) > 0) {\n    max_x = (md_.map_bound_max_(0) - camera_pt(0)) / diff(0);\n  } else if (diff(0) < 0) {\n    min_x = (md_.map_bound_min_(0) - camera_pt(0)) / diff(0);\n  }\n\n  if (diff(1) > 0) {\n    max_y = (md_.map_bound_max_(1) - camera_pt(1)) / diff(1);\n  } else if (diff(1) < 0) {\n    min_y = (md_.map_bound_min_(1) - camera_pt(1)) / diff(1);\n  }\n\n  if (diff(2) > 0) {\n    max_z = (md_.map_bound_max_(2) - camera_pt(2)) / diff(2);\n  } else if (diff(2) < 0) {\n    min_z = (md_.map_bound_min_(2) - camera_pt(2)) / diff(2);\n  }\n\n  double max_scale = std::min(std::min(max_x, max_y), max_z);\n  double min_scale = std::max(std::max(min_x, min_y), min_z);\n  double scale = std::max(min_scale, max_scale);\n  return scale * diff + camera_pt;\n}", "CodeBleu_score": 36.371819834799666}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // \u66f4\u65b0\u6700\u540e\u4e00\u6b21\u66f4\u65b0\u5730\u56fe\u7684\u65f6\u95f4\n  md_.last_occupancy_update_time_ = ros::Time::now();\n\n  // \u5982\u679c\u9700\u8981\u66f4\u65b0\u5730\u56fe\uff0c\u5219\u66f4\u65b0\u5730\u56fe\n  if (md_.update_occupancy_) {\n    // \u66f4\u65b0\u5730\u56fe\n    updateMap();\n    // \u6e05\u9664\u5e76\u81a8\u80c0\u5c40\u90e8\u5730\u56fe\n    clearAndInflateLocalMap();\n    // \u91cd\u7f6e\u66f4\u65b0\u6807\u5fd7\n    md_.update_occupancy_ = false;\n  }\n\n  // \u5982\u679c\u8d85\u65f6\uff0c\u5219\u8bbe\u7f6e\u76f8\u5e94\u7684\u6807\u5fd7\n  if (ros::Time::now() - md_.last_odom_update_time_ > ros::Duration(mp_.odom_timeout_)) {\n    md_.odom_timeout_ = true;\n  }\n  if (ros::Time::now() - md_.last_depth_update_time_ > ros::Duration(mp_.depth_timeout_)) {\n    md_.depth_timeout_ = true;\n  }\n}", "CodeBleu_score": 51.31034245593167}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // \u66f4\u65b0\u6700\u540e\u4e00\u6b21\u66f4\u65b0\u65f6\u95f4\n  md_.last_occupancy_update_time_ = ros::Time::now();\n\n  // \u5982\u679c\u9700\u8981\u66f4\u65b0\n  if (md_.need_update_) {\n    // \u66f4\u65b0odometry\n    updateOdometry();\n    // \u66f4\u65b0\u6df1\u5ea6\u56fe\u50cf\n    updateDepth();\n    // \u66f4\u65b0\u5730\u56fe\n    updateMap();\n    // \u66f4\u65b0\u5730\u56fe\u81a8\u80c0\n    updateMapInflate();\n    // \u66f4\u65b0\u6807\u5fd7\u4f4d\n    updateFlags();\n    // \u66f4\u65b0\u53d1\u5e03\n    publishMapInflate(false);\n    publishMap();\n  }\n}", "CodeBleu_score": 25.535004373495664}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // \u66f4\u65b0\u6700\u540e\u4e00\u6b21\u5360\u7528\u66f4\u65b0\u65f6\u95f4\n  last_occupancy_update_time_ = ros::Time::now();\n  // \u5982\u679c\u9700\u8981\u66f4\u65b0\uff0c\u5219\u4f7f\u7528\u6df1\u5ea6\u56fe\u50cf\u8fdb\u884c\u6295\u5f71\uff0c\u5e76\u4f7f\u7528\u5c04\u7ebf\u6cd5\u8fdb\u884c\u5904\u7406\n  if (need_update_) {\n    need_update_ = false;\n    if (md_.last_odom_time_ == ros::Time(0)) {\n      ROS_WARN(\"No odometry data received, occupancy map will not be updated\");\n      return;\n    }\n    if (md_.last_depth_time_ == ros::Time(0)) {\n      ROS_WARN(\"No depth data received, occupancy map will not be updated\");\n      return;\n    }\n    if ((md_.last_odom_time_ - md_.last_depth_time_).toSec() > mp_.max_odom_depth_time_diff_) {\n      ROS_WARN(\"Odometry and depth data are too old, occupancy map will not be updated\");\n      return;\n    }\n    // \u66f4\u65b0\u5730\u56fe\n    updateMap();\n    // \u5982\u679c\u5730\u56fe\u5df2\u7ecf\u66f4\u65b0\uff0c\u5219\u6e05\u9664\u548c\u81a8\u80c0\u5c40\u90e8\u5730\u56fe\n    if (md_.map_updated_) {\n      clearLocalMap();\n      inflateLocalMap();\n    }\n  }\n  // \u5904\u7406\u8d85\u65f6\u9519\u8bef\n  if ((ros::Time::now() - md_.last_odom_time_).toSec() > mp_.max_odom_time_diff_) {\n    ROS_WARN(\"Odometry data is too old, occupancy map will not be updated\");\n    md_.odom_timeout_ = true;\n  }\n  if ((ros::Time::now() - md_.last_depth_time_).toSec() > mp_.max_depth_time_diff_) {\n    ROS_WARN(\"Depth data is too old, occupancy map will not be updated\");\n    md_.depth_timeout_ = true;\n  }\n}", "CodeBleu_score": 39.55797835612928}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure_accum = 0.f;\n    for (unsigned i = 0; i<image_fns.size(); ++i) {\n        string img_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n\n        vector<Ellipse> ell_gt;\n        vector<Ellipse> ell_dt;\n        Mat3b img;\n        img = imread(img_fn);\n\n        _load_ellipse_GT(gt_fn, ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fn, ell_dt, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\n        fmeasure_accum += fmeasure;\n    }\n\n    return fmeasure_accum / float(image_fns.size());\n}", "CodeBleu_score": 54.82842866832605}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure_accum = 0.f;\n    for (unsigned i = 0; i < image_fns.size(); ++i) {\n        Mat3b img = imread(image_fns[i]);\n        vector<Ellipse> ell_gt;\n        vector<Ellipse> ell_dt;\n\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n        fmeasure_accum += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n    }\n\n    return fmeasure_accum / float(image_fns.size());\n}", "CodeBleu_score": 70.35603011798409}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure = 0.f;\n    unsigned n = image_fns.size();\n\n    for (unsigned i = 0; i < n; ++i) {\n        vector<Ellipse> ell_gt;\n        vector<Ellipse> ell_dt;\n        Mat3b img;\n        img = imread(image_fns[i]);\n\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n    }\n\n    fmeasure /= n;\n    return fmeasure;\n}", "CodeBleu_score": 67.02050671862357}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float f1, f2, f3, f4, a1, a2, a3, a4, d, n;\n    f1 = foci[0];\n    f2 = foci[1];\n    f3 = foci[2];\n    f4 = foci[3];\n    a1 = atan2(y - f1, x - f1);\n    a2 = atan2(y - f2, x - f2);\n    a3 = atan2(y - f3, x - f3);\n    a4 = atan2(y - f4, x - f4);\n    d = angle_diff_signed(a1, a3);\n    n = angle_diff_signed(a2, a4);\n    return angle_diff_signed(d, n);\n}", "CodeBleu_score": 42.12624537846691}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t  float a, b, c, d, e, f;\n  float angle;\n  if (foci == NULL) {\n    fprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null.\n\");\n    return 0.0;\n  }\n  a = foci[0];\n  b = foci[1];\n  c = foci[2];\n  d = foci[3];\n  e = x - a;\n  f = y - b;\n  angle = atan2(f, e);\n  e = x - c;\n  f = y - d;\n  angle -= atan2(f, e);\n  angle = angle_diff_signed(angle, 0.0);\n  return angle;\n}", "CodeBleu_score": 50.849586750895924}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t  float a, b, c, d, e, f;\n  float angle1, angle2;\n  float normal_angle;\n\n  /* check parameters */\n  if (foci == NULL) {\n    fprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null.\n\");\n    return 0;\n  }\n\n  /* compute angles from point to foci */\n  a = sqrt((x - foci[0]) * (x - foci[0]) + (y - foci[1]) * (y - foci[1]));\n  b = sqrt((x - foci[2]) * (x - foci[2]) + (y - foci[3]) * (y - foci[3]));\n  c = sqrt((x - foci[0]) * (x - foci[0]) + (y - foci[3]) * (y - foci[3]));\n  d = sqrt((x - foci[2]) * (x - foci[2]) + (y - foci[1]) * (y - foci[1]));\n  e = sqrt((x - foci[0]) * (x - foci[0]) + (y - foci[1]) * (y - foci[1]));\n  f = sqrt((x - foci[2]) * (x - foci[2]) + (y - foci[3]) * (y - foci[3]));\n\n  angle1 = atan2(y - foci[1], x - foci[0]);\n  angle2 = atan2(y - foci[3], x - foci[2]);\n\n  /* compute normal angle */\n  normal_angle = angle_diff_signed(angle1, angle2);\n\n  return normal_angle;\n}", "CodeBleu_score": 50.60820884948072}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\te\n        return true;\n}", "CodeBleu_score": 3.0939704032948514}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\te\n        return true;\n}", "CodeBleu_score": 3.0939704032948514}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\te\n        return true;\n}", "CodeBleu_score": 3.0939704032948514}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->detection_info.size(); i++) {\n        if (msg->detection_info[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n            ellipse_det = msg->detection_info[i];\n            ellipse_det.sight_angle = -ellipse_det.sight_angle;\n            break;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n        num_lost = 0;\n        num_regain = 0;\n    } else if (num_regain > VISION_THRES) {\n        is_detected = true;\n        num_regain = 0;\n        num_lost = 0;\n    }\n}", "CodeBleu_score": 61.97778101940412}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->detection_infos.size(); i++) {\n        if (msg->detection_infos[i].name == \"T\") {\n            ellipse_det = msg->detection_infos[i];\n            num_regain = 0;\n            num_lost = 0;\n            is_detected = true;\n            hold_lost = 0;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    if (is_detected) {\n        ellipse_det.sight_angle = -ellipse_det.sight_angle;\n    }\n    num_lost++;\n    num_regain++;\n}", "CodeBleu_score": 62.09851989773285}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (auto detection_info : msg->detection_info) {\n        if (detection_info.name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n            ellipse_det = detection_info;\n            ellipse_det.sight_angle = -ellipse_det.sight_angle;\n            break;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n}", "CodeBleu_score": 66.52858958456025}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3i cur_idx = posToIndex(cur_pos);\n    int x = cur_idx(0);\n    int y = cur_idx(1);\n    int z = cur_idx(2);\n    int safe_idx = floor(safe_distance / resolution_);\n    for (int i = -safe_idx; i <= safe_idx; i++) {\n        for (int j = -safe_idx; j <= safe_idx; j++) {\n            for (int k = -safe_idx; k <= safe_idx; k++) {\n                if (Occupy_map_ptr->getOccupancy(x + i, y + j, z + k) == 1) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 38.03268677453314}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3i idx = posToIndex(cur_pos);\n    int x = idx(0), y = idx(1), z = idx(2);\n    // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u5728\u5730\u56fe\u5916\uff0c\u5219\u4e0d\u5b89\u5168\n    if (x < 0 || x >= Occupy_map_ptr->getSizeX() || y < 0 || y >= Occupy_map_ptr->getSizeY() || z < 0 || z >= Occupy_map_ptr->getSizeZ()) {\n        return false;\n    }\n    // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u7684cost\u4e3a-1\uff0c\u5219\u4e0d\u5b89\u5168\n    if (Occupy_map_ptr->getCost(idx) == -1) {\n        return false;\n    }\n    // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u7684cost\u5927\u4e8e\u5b89\u5168\u8ddd\u79bb\uff0c\u5219\u4e0d\u5b89\u5168\n    if (Occupy_map_ptr->getCost(idx) > safe_distance) {\n        return false;\n    }\n    // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u7684cost\u5c0f\u4e8e\u5b89\u5168\u8ddd\u79bb\uff0c\u5219\u5b89\u5168\n    return true;\n}", "CodeBleu_score": 39.91520820252303}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3i cur_idx = posToIndex(cur_pos);\n    for (int i = cur_idx(0) - safe_distance * inv_resolution_; i <= cur_idx(0) + safe_distance * inv_resolution_; i++) {\n        for (int j = cur_idx(1) - safe_distance * inv_resolution_; j <= cur_idx(1) + safe_distance * inv_resolution_; j++) {\n            for (int k = cur_idx(2) - safe_distance * inv_resolution_; k <= cur_idx(2) + safe_distance * inv_resolution_; k++) {\n                if (Occupy_map_ptr->isOccupied(Eigen::Vector3i(i, j, k))) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 40.2969935962472}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr cur_node = end_node;\n    while (cur_node != NULL) {\n        path_nodes_.push_back(cur_node);\n        cur_node = cur_node->parent;\n    }\n    // \u53cd\u8f6c\u8def\u5f84\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 66.42816851854472}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  path_nodes_.clear();\n\n  // \u4ece\u7ec8\u6b62\u70b9\u5f00\u59cb\u5f80\u56de\u627e\u8def\u5f84\n  NodePtr cur_node = end_node;\n  while (cur_node != NULL) {\n    path_nodes_.push_back(cur_node);\n    cur_node = cur_node->parent;\n  }\n\n  // \u5c06\u8def\u5f84\u53cd\u8f6c\uff0c\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.65905761046841}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  path_nodes_.clear();\n\n  // \u4ece\u7ec8\u70b9\u5f80\u56de\u63a8\n  NodePtr cur_node = end_node;\n  while (cur_node != NULL) {\n    path_nodes_.push_back(cur_node);\n    cur_node = cur_node->parent;\n  }\n\n  // \u53cd\u8f6c\u8def\u5f84\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 70.91881716049214}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    if (in_return_mode) {\n        return;\n    }\n    if (id == 1) {\n        if (odom->pose.pose.position.x > 50 || odom->pose.pose.position.y > 50 || odom->pose.pose.position.z > 50) {\n            return;\n        }\n    }\n    if (id == 2) {\n        if (odom->pose.pose.position.x < -50 || odom->pose.pose.position.y > 50 || odom->pose.pose.position.z > 50) {\n            return;\n        }\n    }\n    if (id == 3) {\n        if (odom->pose.pose.position.x > 50 || odom->pose.pose.position.y < -50 || odom->pose.pose.position.z > 50) {\n            return;\n        }\n    }\n    if (id == 4) {\n        if (odom->pose.pose.position.x < -50 || odom->pose.pose.position.y < -50 || odom->pose.pose.position.z > 50) {\n            return;\n        }\n    }\n    state_nei[id](0) = odom->pose.pose.position.x;\n    state_nei[id](1) = odom->pose.pose.position.y;\n    state_nei[id](2) = odom->pose.pose.position.z;\n    get_nei_state[id] = true;\n}", "CodeBleu_score": 41.863296332074306}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  // \u66f4\u65b0\u90bb\u5c45\u72b6\u6001\n  state_nei[id](0) = odom->pose.pose.position.x;\n  state_nei[id](1) = odom->pose.pose.position.y;\n  state_nei[id](2) = odom->pose.pose.position.z;\n  get_nei_state[id] = true;\n\n  // \u5728\u4eff\u771f\u6a21\u5f0f\u4e0b\uff0c\u68c0\u67e5\u90bb\u5c45\u4e0e\u8d77\u59cb\u4f4d\u7f6e\u7684\u8ddd\u79bb\uff0c\u5982\u679c\u8ddd\u79bb\u8d85\u8fc75\u7c73\uff0c\u5219\u5c06get_nei_state\u6807\u5fd7\u8bbe\u7f6e\u4e3afalse\n  if (simulation_mode) {\n    double dist = sqrt(pow(state_nei[id](0) - start_pos(0), 2) + pow(state_nei[id](1) - start_pos(1), 2));\n    if (dist > 5.0) {\n      get_nei_state[id] = false;\n    }\n  }\n}", "CodeBleu_score": 46.50483322854404}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id] << odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z;\n    get_nei_state[id] = true;\n    if(simulation_mode)\n    {\n        double dis = sqrt(pow(state_nei[id](0) - start_pos(0),2) + pow(state_nei[id](1) - start_pos(1),2));\n        if(dis > 5)\n        {\n            get_nei_state[id] = false;\n        }\n    }\n}", "CodeBleu_score": 41.277013927239516}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  // \u5982\u679c\u91cc\u7a0b\u8ba1\u4e0d\u5c31\u7eea\uff0c\u5219\u8fd4\u56de\n  if (!odom_ready)\n    return;\n\n  // \u66f4\u65b0\u8ba1\u6570\u5668\n  sensor_update_counter++;\n\n  // \u6bcf\u96945\u6b21\u66f4\u65b0\uff0c\u66f4\u65b0Astar\u5730\u56fe\n  if (sensor_update_counter % 5 == 0) {\n    // \u66f4\u65b0\u5730\u56fe\n    Astar_ptr->Occupy_map_ptr->update_map_from_pointcloud(msg);\n    // \u91cd\u7f6e\u8ba1\u6570\u5668\n    sensor_update_counter = 0;\n  }\n}", "CodeBleu_score": 59.75237916514977}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n\n    sensor_ready = true;\n    update_count++;\n\n    // \u6bcf5\u6b21\u66f4\u65b0\u4e00\u6b21\u5730\u56fe\n    if (update_count % 5 == 0) {\n        Astar_ptr->Occupy_map_ptr->update_map(msg);\n        update_count = 0;\n    }\n}", "CodeBleu_score": 65.6377776524823}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n\n    if (sensor_ready) {\n        update_counter++;\n        if (update_counter % 5 == 0) {\n            Astar_ptr->Occupy_map_ptr->update_map_from_cloud(msg);\n            update_counter = 0;\n        }\n    } else {\n        sensor_ready = true;\n    }\n}", "CodeBleu_score": 60.46001108683179}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  // \u5982\u679c\u5168\u5c40\u70b9\u4e91\u6ca1\u6709\u88ab\u66f4\u65b0\u8fc7\uff0c\u5219\u66f4\u65b0\u5168\u5c40\u70b9\u4e91\n  if (!get_gpcl) {\n    // \u8bbe\u7f6e\u5168\u5c40\u70b9\u4e91\u88ab\u66f4\u65b0\u8fc7\n    get_gpcl = true;\n    // \u8f6c\u6362\u70b9\u4e91\n    pcl::fromROSMsg(*global_point, *global_point_cloud);\n    // \u5b58\u50a8\u70b9\u4e91\n    global_point_cloud->header.frame_id = global_frame_id;\n    // \u81a8\u80c0\u70b9\u4e91\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflate(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*global_point_cloud, *cloud_inflate);\n    // \u81a8\u80c0\u70b9\u4e91\n    for (int i = 0; i < inflate_index_ugv; i++) {\n      pcl::PointXYZ p;\n      p.x = enum_p_ugv[i](0);\n      p.y = enum_p_ugv[i](1);\n      p.z = enum_p_ugv[i](2);\n      cloud_inflate->push_back(p);\n    }\n    // \u81a8\u80c0\u70b9\u4e91\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_inflate_vis(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*cloud_inflate, *cloud_inflate_vis);\n    // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\n    cloud_inflate_vis_->header.frame_id = global_frame_id;\n    cloud_inflate_vis_->header.stamp = ros::Time::now().toNSec() / 1000;\n    cloud_inflate_pub.publish(cloud_inflate_vis);\n  }\n}", "CodeBleu_score": 47.46327653746237}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  // \u8f6c\u6362\u4e3aPointCloud2\n  sensor_msgs::PointCloud2 laser_point;\n  projector.transformLaserScanToPointCloud(\"base_link\", *local_point, laser_point);\n\n  // \u8f6c\u6362\u4e3apcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(laser_point, *laser_cloud);\n\n  if (!sim_mode) {\n    local_map_merge_odom(odom);\n  }\n\n  // \u66f4\u65b0\u5730\u56fe\n  *global_point_cloud_map += *laser_cloud;\n  inflate_point_cloud();\n}", "CodeBleu_score": 56.24553426113237}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\tprojectLaser(*local_point, laser_cloud);\n\n\thas_global_point = true;\n\n\tif (sim_mode) {\n\t\tif (queue_size <= 0) // without slide windows\n\t\t{\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += laser_cloud;\n\t\t} else // with slide windows\n\t\t{\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = laser_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor (iter = point_cloud_pair.begin(); iter != point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 55.884891901607205}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // Publish global point cloud map\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_point_cloud_map, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Publish inflated point cloud\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*cloud_inflate_vis_, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 66.45934716379126}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_point_cloud_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the global point cloud map message\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert the inflated point cloud to a ROS message\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*cloud_inflate_vis_, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the inflated point cloud message\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 67.53257996469189}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    // \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u66f4\u65b0\u5730\u56fe\n    Astar_ptr->Occupy_map_ptr->map_update_lcl(msg, uav_odom);\n}", "CodeBleu_score": 92.24722638503793}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  // \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5927\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n  if (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n    // \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n  }\n}", "CodeBleu_score": 79.33715582512552}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n\n    // \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5927\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n    if (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n        // \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n    }\n}", "CodeBleu_score": 77.94513769081995}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (publish_foot_contacts_ && !in_gazebo_) {\n    champ_msgs::ContactsStamped foot_contacts_msg;\n    foot_contacts_msg.header.stamp = ros::Time::now();\n    foot_contacts_msg.contacts.resize(4);\n\n    for (size_t i = 0; i < 4; i++) {\n      foot_contacts_msg.contacts[i].name = foot_names_[i];\n      foot_contacts_msg.contacts[i].state = foot_contacts[i];\n    }\n\n    foot_contacts_publisher_.publish(foot_contacts_msg);\n  }\n}", "CodeBleu_score": 65.62346427014553}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (publish_foot_contacts_ && !in_gazebo_) {\n    champ_msgs::ContactsStamped foot_contacts_msg;\n    foot_contacts_msg.header.stamp = ros::Time::now();\n    foot_contacts_msg.contacts.resize(4);\n    for (size_t i = 0; i < 4; i++) {\n      foot_contacts_msg.contacts[i].phase = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(foot_contacts_msg);\n  }\n}", "CodeBleu_score": 66.83448232424574}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (publish_foot_contacts_ && !in_gazebo_) {\n        champ_msgs::ContactsStamped foot_contacts_msg;\n        foot_contacts_msg.header.stamp = ros::Time::now();\n        foot_contacts_msg.contacts.resize(4);\n\n        for (size_t i = 0; i < 4; i++) {\n            foot_contacts_msg.contacts[i].state = foot_contacts[i];\n        }\n\n        foot_contacts_publisher_.publish(foot_contacts_msg);\n    }\n}", "CodeBleu_score": 68.47101391563541}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    Joints minimal_joints = Joints()\n    minimal_joints.joints.resize(12)\n    minimal_joints.joints[0] = joints.position[3]\n    minimal_joints.joints[1] = joints.position[2]\n    minimal_joints.joints[2] = joints.position[1]\n    minimal_joints.joints[3] = joints.position[0]\n    minimal_joints.joints[4] = joints.position[7]\n    minimal_joints.joints[5] = joints.position[6]\n    minimal_joints.joints[6] = joints.position[5]\n    minimal_joints.joints[7] = joints.position[4]\n    minimal_joints.joints[8] = joints.position[11]\n    minimal_joints.joints[9] = joints.position[10]\n    minimal_joints.joints[10] = joints.position[9]\n    minimal_joints.joints[11] = joints.position[8]\n\n    self.joint_minimal_pub.publish(minimal_joints)\n\n    JointTrajectory trajectory = JointTrajectory()\n    trajectory.joint_names = self.joint_names\n    JointTrajectoryPoint point = JointTrajectoryPoint()\n    point.positions = joints.position\n    point.time_from_start = rospy.Duration(1)\n    trajectory.points.append(point)\n    self.joint_trajectory_pub.publish(trajectory)\n}", "CodeBleu_score": 43.03278913281515}, {"code": "def joints_cmd_callback(self, joints){\n\t    Joints minimal_joints = Joints()\n    minimal_joints.header = joints.header\n    minimal_joints.position = joints.position[0:12]\n    self.joint_minimal_pub.publish(minimal_joints)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header = joints.header\n    joint_trajectory.joint_names = self.joint_names\n    joint_trajectory.points.append(JointTrajectoryPoint())\n    joint_trajectory.points[0].positions = joints.position[0:12]\n    joint_trajectory.points[0].velocities = [0.0] * 12\n    joint_trajectory.points[0].accelerations = [0.0] * 12\n    joint_trajectory.points[0].effort = [0.0] * 12\n    joint_trajectory.points[0].time_from_start = rospy.Duration(0.005)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 41.51607929573747}, {"code": "def joints_cmd_callback(self, joints){\n\t    Joints minimal_joints_msg = Joints();\n    minimal_joints_msg.header.stamp = rospy.Time.now();\n    minimal_joints_msg.header.frame_id = \"base_link\";\n\n    minimal_joints_msg.joints.resize(12);\n\n    for i in range(0, 12):\n        minimal_joints_msg.joints[i] = joints.position[i];\n\n    self.joint_minimal_pub.publish(minimal_joints_msg);\n\n    JointTrajectory joint_trajectory_msg = JointTrajectory();\n    joint_trajectory_msg.joint_names = self.joint_names;\n    joint_trajectory_msg.points.resize(1);\n    joint_trajectory_msg.points[0].positions = joints.position;\n    joint_trajectory_msg.points[0].time_from_start = rospy.Duration(1);\n\n    self.joint_trajectory_pub.publish(joint_trajectory_msg);\n}", "CodeBleu_score": 53.1735819692118}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\tcontacts_msg.header.stamp = ros::Time::now();\n\tcontacts_msg.header.frame_id = \"base_link\";\n\n\tfor (int i = 0; i < 4; i++)\n\t\tfoot_contacts_[i] = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (collision1 == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t\tcontacts_msg.contacts.push_back(foot_links_[j]);\n\t\t\t}\n\n\t\t\tif (collision2 == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t\tcontacts_msg.contacts.push_back(foot_links_[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcontacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 57.20814918520829}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tchamp_msgs::ContactsStamped contacts_msg;\\\n\tcontacts_msg.header.stamp = ros::Time::now();\n\tcontacts_msg.contacts.clear();\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\n\tfor(int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision_names;\n\t\tboost::split(collision_names, _msg->contact(i).collision1(), boost::is_any_of(\"_\"));\n\t\tboost::split(collision_names, _msg->contact(i).collision2(), boost::is_any_of(\"_\"));\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(foot_links_[j] == collision_names[0]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tcontacts_msg.contacts.push_back(foot_contacts_[i]);\n\t}\n\n\tcontacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 57.642673415094215}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tchamp_msgs::ContactsStamped contacts_msg;\\\n\tcontacts_msg.header.stamp = ros::Time::now();\n\n\tfor(int i=0;i<4;i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\n\tfor(int i=0;i<_msg->contact_size();i++) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\n\t\tstd::vector<std::string> collision1_split;\\\n\t\tboost::split(collision1_split, collision1, boost::is_any_of(\"::\"));\n\n\t\tstd::vector<std::string> collision2_split;\\\n\t\tboost::split(collision2_split, collision2, boost::is_any_of(\"::\"));\n\n\t\tfor(int j=0;j<foot_links_.size();j++) {\n\t\t\tif(collision1_split[collision1_split.size()-1] == foot_links_[j] || collision2_split[collision2_split.size()-1] == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<4;i++) {\n\t\tcontacts_msg.contacts.push_back(foot_contacts_[i]);\n\t}\n\n\tcontacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 46.66625208078977}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  if (!initialized_params_) {\n    ROS_ERROR(\"The controller parameters are not initialized!\");\n    return;\n  }\n\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration = angular_acceleration_command_;\n  // Project thrust onto the body z-axis.\n  const double thrust = thrust_command_ / vehicle_parameters_.rotor_configuration_.rotors.size();\n  angular_acceleration.z() += thrust;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust << angular_acceleration, thrust;\n\n  // Calculate rotor velocities from the pseudo-inverse A^{ \\dagger} and the angular acceleration.\n  Eigen::VectorXd rotor_velocities_unbounded = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n\n  // Make sure, rotor_velocities are non-negative.\n  for (int i = 0; i < rotor_velocities_unbounded.size(); ++i) {\n    if (rotor_velocities_unbounded(i) < 0.0) {\n      rotor_velocities_unbounded(i) = 0.0;\n    }\n  }\n\n  // Take the square root of each rotor velocity to get the final rotor velocities.\n  *rotor_velocities = rotor_velocities_unbounded.cwiseSqrt();\n}", "CodeBleu_score": 45.351180092883716}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  if (!initialized_params_) {\n    ROS_ERROR(\\\"The LeePositionController is not properly initialized.\\\");\n    return;\n  }\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  Eigen::Vector3d thrust;\n  CalculateDesiredAcceleration(&thrust, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  thrust(2) = 0;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust << angular_acceleration, thrust;\n\n  // Calculate rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  rotor_velocities->cwiseMax(0);\n  rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 36.86081183596344}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!initialized_params_) {\n    ROS_ERROR(\\\"Parameters not set yet.\\\");\n    return;\n  }\n\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  Eigen::Vector3d desired_acceleration;\n\n  desired_acceleration = controller_parameters_.position_gain_ * (desired_position_ - current_position_) +\n      controller_parameters_.velocity_gain_ * (desired_velocity_ - current_velocity_);\n\n  // Project thrust onto body z-axis.\n  double thrust_z = desired_acceleration.dot(rotor_velocities->head(3));\n  desired_acceleration.z() = thrust_z;\n\n  angular_acceleration = normalized_attitude_gain_ * (desired_attitude_.conjugate() * desired_acceleration - current_attitude_.conjugate() * current_acceleration_) -\n      normalized_angular_rate_gain_ * (desired_angular_rate_ - current_angular_rate_);\n\n  // Combine angular acceleration and thrust into one vector.\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust << angular_acceleration, thrust_z;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n\n  // Ensure non-negative values.\n  rotor_velocities->cwiseMax(0.0);\n\n  // Take the square root to get rotor velocities.\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 49.594556042185104}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n  assert(initialized_params_);\n\n  // Calculate velocity error in world frame.\n\n  Eigen::Vector3d velocity_error = command_trajectory_.position_W - odometry_.position;\n  Eigen::Vector3d velocity_error_W = odometry_.orientation.toRotationMatrix().transpose() * velocity_error;\n\n  // Calculate position error in world frame.\n\n  Eigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position;\n  Eigen::Vector3d position_error_W = odometry_.orientation.toRotationMatrix().transpose() * position_error;\n\n  // Calculate desired acceleration in world frame.\n\n  Eigen::Vector3d acceleration_desired = controller_parameters_.position_gain_.cwiseProduct(position_error_W)\n      + controller_parameters_.velocity_gain_.cwiseProduct(velocity_error_W)\n      + command_trajectory_.acceleration_W;\n\n  // Transform desired acceleration to body frame.\n\n  *acceleration = odometry_.orientation.toRotationMatrix() * acceleration_desired;\n\n  // Add gravity term.\n\n  acceleration->z() += vehicle_parameters_.mass_ * vehicle_parameters_.g;\n}", "CodeBleu_score": 51.59964589831628}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n  assert(initialized_params_);\n\n  Eigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position;\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity_W - odometry_.velocity;\n\n  // Transform velocity to world frame.\n\n  Eigen::Vector3d velocity_W = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n  velocity_error -= velocity_W;\n\n  // Compute desired acceleration.\n\n  Eigen::Vector3d desired_acceleration = controller_parameters_.position_gain_.cwiseProduct(position_error)\n      + controller_parameters_.velocity_gain_.cwiseProduct(velocity_error)\n      + command_trajectory_.acceleration_W;\n  desired_acceleration -= odometry_.orientation.toRotationMatrix().col(2) * vehicle_parameters_.mass_ * 9.81;\n\n  *acceleration = desired_acceleration;\n}", "CodeBleu_score": 53.378541936185606}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n  assert(initialized_params_);\n\n  // Transform current velocity to world frame.\n\n  Eigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix().transpose() * odometry_.velocity;\n\n  // Calculate position error.\n\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Calculate velocity error.\n\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - velocity_world;\n\n  // Calculate desired acceleration.\n\n  *acceleration = controller_parameters_.position_gain_.cwiseProduct(position_error) +\n                  controller_parameters_.velocity_gain_.cwiseProduct(velocity_error) +\n                  Eigen::Vector3d(0, 0, vehicle_parameters_.mass_ * GRAVITY_CONSTANT);\n}", "CodeBleu_score": 49.15035884670015}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  if (rotor_velocities == nullptr) {\n    std::cerr << \"Input to CalculateRotorVelocities is null\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->size() != amount_rotors_) {\n    rotor_velocities->resize(amount_rotors_);\n  }\n\n  Eigen::Vector4d angular_acceleration_desired;\n  angular_acceleration_desired.setZero();\n\n  // Calculate the desired angular acceleration\n  angular_acceleration_desired =\n      gain_attitude_.asDiagonal() * attitude_error_ +\n      gain_angular_rate_.asDiagonal() * angular_rate_error_;\n\n  // Calculate the rotor velocities\n  *rotor_velocities =\n      angular_acc_to_rotor_velocities_ * angular_acceleration_desired;\n\n  // Ensure the rotor velocities are at least one\n  for (int i = 0; i < amount_rotors_; i++) {\n    if ((*rotor_velocities)(i) < 1.0) {\n      (*rotor_velocities)(i) = 1.0;\n    }\n  }\n\n  // Take the square root of each component\n  for (int i = 0; i < amount_rotors_; i++) {\n    (*rotor_velocities)(i) = sqrt((*rotor_velocities)(i));\n  }\n}", "CodeBleu_score": 53.31940630198668}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 3.965771277166072}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  if (!initialized_params_) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: \"\n              << \"Parameters not initialized.\" << std::endl;\n    return;\n  }\n  if (rotor_velocities == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: \"\n              << \"rotor_velocities is a nullptr.\" << std::endl;\n    return;\n  }\n\n  rotor_velocities->resize(amount_rotors_);\n  rotor_velocities->setZero();\n\n  Eigen::Vector3d desired_angular_acceleration =\n      -gain_attitude_.asDiagonal() * quaternion_rotor_attitude_\n      - gain_angular_rate_.asDiagonal() * angular_velocity_body_\n      + gain_thrust_reference_ * thrust_reference_;\n\n  Eigen::Vector4d angular_acceleration_vector;\n  angular_acceleration_vector << desired_angular_acceleration,\n                                0;\n\n  Eigen::Vector4d rotor_velocities_vector =\n      angular_acc_to_rotor_velocities_ * angular_acceleration_vector;\n\n  for (int i = 0; i < amount_rotors_; ++i) {\n    if (rotor_velocities_vector(i) < 1) {\n      rotor_velocities_vector(i) = 1;\n    }\n    (*rotor_velocities)(i) = std::sqrt(rotor_velocities_vector(i));\n  }\n}", "CodeBleu_score": 39.72832021822625}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.where(self.time >= start_time)[0][0]\n        end_idx = numpy.where(self.time <= end_time)[0][-1]\n        sliced_object = copy.deepcopy(self)\n        sliced_object.time = sliced_object.time[start_idx:end_idx + 1]\n        sliced_object.bag_time = sliced_object.bag_time[start_idx:end_idx + 1]\n        for key, value in self.__dict__.items():\n            if isinstance(value, BaseWithTime):\n                sliced_object.__dict__[key] = value.slice(start_time, end_time)\n            else:\n                sliced_object.__dict__[key] = value[start_idx:end_idx + 1]\n        return sliced_object\n\n", "CodeBleu_score": 26.753712207310652}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.where(self.time >= start_time)[0][0]\n        end_idx = numpy.where(self.time <= end_time)[0][-1]\n        new_object = copy.deepcopy(self)\n        new_object.time = new_object.time[start_idx:end_idx+1]\n        new_object.bag_time = new_object.bag_time[start_idx:end_idx+1]\n        return new_object\n\n", "CodeBleu_score": 21.457524554248835}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = numpy.where(self.time >= start_time)[0][0]\n        end_index = numpy.where(self.time <= end_time)[0][-1]\n        obj = copy.deepcopy(self)\n        obj.time = obj.time[start_index:end_index + 1]\n        obj.bag_time = obj.bag_time[start_index:end_index + 1]\n        return obj\n\n", "CodeBleu_score": 24.43188620562889}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if waypoint_msg.pose.pose.orientation_covariance != [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]:\n        orientation = Quaternion(waypoint_msg.pose.pose.orientation.x, waypoint_msg.pose.pose.orientation.y, waypoint_msg.pose.pose.orientation.z, waypoint_msg.pose.pose.orientation.w)\n        euler = tf.transformations.euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n        yaw = euler[2]\n    else:\n        yaw = 0.0\n    if self.empty or self.x[-1] != waypoint_msg.pose.pose.position.x or self.y[-1] != waypoint_msg.pose.pose.position.y or self.z[-1] != waypoint_msg.pose.pose.position.z or self.yaw[-1] != yaw:\n        self.empty = False\n        self.append_point(Point(waypoint_msg.pose.pose.position.x, waypoint_msg.pose.pose.position.y, waypoint_msg.pose.pose.position.z))\n        self.append_times(msg_time, bag_time)\n        self.yaw = numpy.append(self.yaw, yaw)\n\n", "CodeBleu_score": 34.629077135475825}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if not self.empty:\n        # Check if the current waypoint is different from the last one.\n        if (waypoint_msg.pose.position.x != self.x[-1] or\n                waypoint_msg.pose.position.y != self.y[-1] or\n                waypoint_msg.pose.position.z != self.z[-1] or\n                self.get_yaw_from_quaternion(waypoint_msg.pose.orientation) != self.yaw[-1]):\n            self.append_point(waypoint_msg.pose.position)\n            self.append_yaw(self.get_yaw_from_quaternion(waypoint_msg.pose.orientation))\n            self.append_times(msg_time, bag_time)\n            self.empty = False\n    else:\n        self.append_point(waypoint_msg.pose.position)\n        self.append_yaw(self.get_yaw_from_quaternion(waypoint_msg.pose.orientation))\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 29.3053338558755}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    quaternion_list = [quaternion.x, quaternion.y, quaternion.z, quaternion.w]\n    (roll, pitch, yaw) = tf.transformations.euler_from_quaternion(quaternion_list)\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    if self.empty or (not numpy.array_equal(point.x, self.x[-1]) or not numpy.array_equal(point.y, self.y[-1]) or not numpy.array_equal(point.z, self.z[-1]) or not numpy.array_equal(yaw, self.yaw[-1])):\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 35.89133705103646}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    if topic in self.imu_topics:\n        index = self.imu_topics.index(topic)\n        self.acc[index].append_point(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n        self.ang_vel[index].append_point(msg.angular_velocity)\n        self.ang_vel[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 41.19174692307377}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    if topic != self.imu_topics[0]:\n        return\n    elif \"Imu\" in str(type(msg)):\n        self.acc[0].append_point(msg.linear_acceleration)\n        self.acc[0].append_times(msg_time, bag_time)\n        self.ang_vel[0].append_point(msg.angular_velocity)\n        self.ang_vel[0].append_times(msg_time, bag_time)\n    else:\n        print(\"Got unknown type: %s\" % type(msg))\n\n", "CodeBleu_score": 29.680663290384214}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    if topic in self.imu_topics:\n        index = self.imu_topics.index(topic)\n        self.acc[index].append_point(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n        self.ang_vel[index].append_point(msg.angular_velocity)\n        self.ang_vel[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 41.19174692307377}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x')\n        a_x.plot(acc.time, acc.y, 'r', label='y')\n        a_x.plot(acc.time, acc.z, 'g', label='z')\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                     box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n    pyplot.grid(b=True, which='both')\n\n    if self.save_plots:\n        file_name = self.prefix + '_acc' if self.prefix else 'acc'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 65.59270602746845}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x')\n        a_x.plot(acc.time, acc.y, 'r', label='y')\n        a_x.plot(acc.time, acc.z, 'g', label='z')\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                      box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n    pyplot.grid(b=True, which='both')\n\n    if self.save_plots:\n        file_name = self.prefix + '_acc' if self.prefix else 'acc'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 65.57345761290429}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x')\n        a_x.plot(acc.time, acc.y, 'r', label='y')\n        a_x.plot(acc.time, acc.z, 'g', label='z')\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                     box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n    pyplot.grid(b=True, which='both')\n\n    if self.save_plots:\n        file_name = self.prefix + '_accelerations' if self.prefix else 'accelerations'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 63.980066078694676}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print('Error: compare_positions requires at least two pose indices to compare.')\n        return\n    for index1 in range(len(pose_indeces)):\n        for index2 in range(index1 + 1, len(pose_indeces)):\n            print('Comparing poses ' + str(pose_indeces[index1]) + ' and ' + str(pose_indeces[index2]))\n            self.compare_two_xyz(self.pos[pose_indeces[index1]], self.pos[pose_indeces[index2]])\n\n", "CodeBleu_score": 43.1178006753067}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError('At least two pose indices are required to compare.')\n    for index, pose_index in enumerate(pose_indeces):\n        for pose_index2 in pose_indeces[index + 1:]:\n            self.compare_two_xyz(pose_index, pose_index2)\n\n", "CodeBleu_score": 52.129268464418544}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError(\"compare_positions requires at least two pose indices\")\n    for index, pose_index in enumerate(pose_indeces):\n        for next_index in range(index + 1, len(pose_indeces)):\n            compare_two_xyz(self.pos[pose_index], self.pos[pose_indeces[next_index]])\n\n", "CodeBleu_score": 49.205712959563954}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time and end_time:\n            if collision.time >= start_time and collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time:\n            if collision.time >= start_time:\n                collision_times.append(collision.time)\n        elif end_time:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.26095308604406}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.time:\n        if start_time and end_time:\n            if start_time <= time <= end_time:\n                collision_times.append(time)\n        elif start_time:\n            if start_time <= time:\n                collision_times.append(time)\n        elif end_time:\n            if time <= end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 39.88517953681986}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time and end_time:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 45.64520329806013}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(start_time=start_time, end_time=end_time,\n                                       settling_time=absolute_settling_time,\n                                       x_range=x_range, plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(start_time=start_time,\n                                            end_time=end_time,\n                                            settling_time=absolute_settling_time,\n                                            x_range=x_range, y_range=[-1.5, 1.5],\n                                            plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 58.41291790174953}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 71.55115547094847}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 71.55115547094847}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier based on camera parameters\n  const float multiplier =\n      (this->max_depth - this->min_depth) /\n      (this->max_depth_pixel - this->min_depth_pixel);\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> depth_vec(data, width * height);\n\n  // Compute RMS noise\n  const float rms_noise = this->rms_noise_;\n\n  // Compute noise values\n  std::vector<float> noise_values(depth_vec.size());\n  std::generate(noise_values.begin(), noise_values.end(),\n                [&]() { return rms_noise * this->random_generator_->Gaussian(0, 1); });\n\n  // Add noise to depth data\n  for (uint32_t i = 0; i < depth_vec.size(); ++i) {\n    if (this->InRange(depth_vec[i])) {\n      depth_vec[i] += noise_values[i];\n    } else {\n      depth_vec[i] = this->bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 46.62984493781606}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t", "CodeBleu_score": 2.6906647105137806}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Compute the multiplier\n  const float fov_x = this->fov_horizontal * M_PI / 180.0;\n  const float fov_y = this->fov_vertical * M_PI / 180.0;\n  const float fov_x_half = fov_x / 2.0;\n  const float fov_y_half = fov_y / 2.0;\n  const float fov_x_multiplier = width / (2.0 * tan(fov_x_half));\n  const float fov_y_multiplier = height / (2.0 * tan(fov_y_half));\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>>\n      depth_map(data, height, width);\n\n  // Compute the RMS noise\n  const float rms_noise = this->rms_noise;\n\n  // Compute the noise values\n  const float noise_x = rms_noise * fov_x_multiplier;\n  const float noise_y = rms_noise * fov_y_multiplier;\n\n  // Add noise to the data\n  for (uint32_t row = 0; row < height; row++) {\n    for (uint32_t col = 0; col < width; col++) {\n      float depth = depth_map(row, col);\n      if (this->InRange(depth)) {\n        depth += static_cast<float>(this->distribution(this->generator)) * noise_x *\n                 static_cast<float>(this->distribution(this->generator)) * noise_y;\n      } else {\n        depth = this->bad_point;\n      }\n      depth_map(row, col) = depth;\n    }\n  }\n}", "CodeBleu_score": 40.06054282725877}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 99.66306672220828}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 99.66306672220828}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 99.66306672220828}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert the simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for actuator velocities.\n  mav_msgs::Actuators actuators_msg;\n\n  // Iterate through the motor joints.\n  for (unsigned int i = 0; i < motor_joints_.size(); ++i) {\n    // Get the joint name.\n    std::string joint_name = motor_joints_[i]->GetName();\n\n    // Get the joint velocity.\n    double joint_velocity = motor_joints_[i]->GetVelocity(0);\n\n    // Calculate the slowed-down rotational velocity.\n    double slowed_down_velocity = joint_velocity * motor_velocity_factor_;\n\n    // Assign the slowed-down rotational velocity to the message.\n    actuators_msg.angular_velocities[i] = slowed_down_velocity;\n\n    // Set the message timestamp.\n    actuators_msg.header.stamp = ros_now;\n  }\n\n  // Write the data to a bag file using the specified namespace and motor topic.\n  writeBag(namespace_ + \"/\" + motor_topic_, ros_now, &actuators_msg);\n}", "CodeBleu_score": 55.76983541476721}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare message for actuator velocities.\n  mav_msgs::Actuators actuator_msg;\n  actuator_msg.header.stamp = ros_now;\n  actuator_msg.angular_velocities.resize(rotors_ptr_->GetNumberOfRotors());\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\n  for (int i = 0; i < rotors_ptr_->GetNumberOfRotors(); i++) {\n    double motor_velocity = rotors_ptr_->GetMotorSpeed(i);\n    double slowed_down_velocity = motor_velocity * rotors_ptr_->GetMotorSpeedSlowdown();\n    actuator_msg.angular_velocities[i] = slowed_down_velocity;\n  }\n\n  // Set the message timestamp and write the data to a bag file using the specified namespace and motor topic.\n  actuator_msg.header.stamp = ros_now;\n  writeBag(namespace_ + \"/\" + motor_topic_, ros_now, &actuator_msg);\n}", "CodeBleu_score": 61.44545815045277}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert the simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare the message for the motor velocities.\n  mav_msgs::Actuators actuator_msg;\n  actuator_msg.header.stamp = ros_now;\n  actuator_msg.angular_velocities.resize(num_motors_);\n\n  // Iterate through the motor joints and calculate the slowed-down rotational velocities.\n  for (unsigned int i = 0; i < num_motors_; i++) {\n    // Get the motor joint.\n    physics::JointPtr motor_joint = motor_joints_[i];\n\n    // Get the motor joint velocity.\n    double motor_velocity = motor_joint->GetVelocity(0);\n\n    // Calculate the slowed-down rotational velocity.\n    double slowed_down_velocity = motor_velocity * slow_down_factor_;\n\n    // Assign the slowed-down rotational velocity to the message.\n    actuator_msg.angular_velocities[i] = slowed_down_velocity;\n  }\n\n  // Set the message timestamp.\n  actuator_msg.header.stamp = ros_now;\n\n  // Write the data to a bag file using the specified namespace and motor topic.\n  writeBag(namespace_ + \"/\" + motor_topic_, ros_now, actuator_msg);\n}", "CodeBleu_score": 58.9636269746647}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\n  delta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\n  delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\n  delta_flap_ = NormalizedInputToAngle(vehicle_params_.flap,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.flap.channel));\n  delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 65.4696136608528}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\n  delta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\n  delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\n  delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 67.85516265255413}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\n  delta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\n  delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\n  delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 67.85516265255413}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serialPort_->getHandle(), &readfds);\n\n  if (select(serialPort_->getHandle() + 1, &readfds, NULL, NULL, &tv) <= 0) {\n    return;\n  }\n\n  if (FD_ISSET(serialPort_->getHandle(), &readfds)) {\n    char buffer[1024];\n    int nbytes = serialPort_->read(buffer, 1024);\n\n    if (nbytes <= 0) {\n      return;\n    }\n\n    mavlink_message_t msg;\n    mavlink_status_t status;\n\n    for (int i = 0; i < nbytes; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        handleMAVLinkMessage(msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 59.26022578670671}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // convert timeout to timeval\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // poll for data\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(fd_, &readfds);\n  int retval = select(fd_ + 1, &readfds, NULL, NULL, &timeout);\n\n  if (retval > 0) {\n    // data available, read it\n    uint8_t buffer[256];\n    int nbytes = read(fd_, buffer, sizeof(buffer));\n    if (nbytes <= 0) {\n      return;\n    }\n\n    // parse messages\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < nbytes; ++i) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        handleMAVLinkMessage(msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 58.7961699337096}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // perform poll operation on file descriptors\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serial_->handle(), &readfds);\n\n  int retval = select(serial_->handle() + 1, &readfds, NULL, NULL, &timeout);\n\n  if (retval > 0) {\n    // data available, receive data and parse MAVLink messages\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    int bytes_received = serial_->read(buffer, MAVLINK_MAX_PACKET_LEN);\n\n    if (bytes_received > 0) {\n      // parse MAVLink messages from buffer\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      for (int i = 0; i < bytes_received; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n          // message parsed, handle message\n          handleMAVLinkMessage(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 57.49688411652365}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex_);\n  if (serial_enabled_) {\n    if (serial_dev_.is_open()) {\n      serial_dev_.cancel();\n      serial_dev_.close();\n    }\n  }\n  if (io_thread_.joinable()) {\n    io_thread_.join();\n  }\n}", "CodeBleu_score": 57.916169859545306}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex_);\n  if (serial_dev_.is_open()) {\n    serial_dev_.cancel();\n    serial_dev_.close();\n  }\n  if (io_thread_.joinable()) {\n    io_thread_.join();\n  }\n}", "CodeBleu_score": 60.43905368185926}, {"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (serial_dev_.is_open()) {\n    // Stop the I/O service.\n\n    io_service_.stop();\n    // Close the serial device.\n\n    serial_dev_.close();\n    // Join the I/O thread if it is joinable.\n\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 68.14886270982356}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  // Check if the position is within the bounds of the wind field.\n  if (position.X() < min_x_ || position.X() > min_x_ + n_x_ * res_x_ ||\n    position.Y() < min_y_ || position.Y() > min_y_ + n_y_ * res_y_) {\n    gzerr << \\\"[gazebo_wind_plugin] Position out of bounds. Returning default wind speed.\n\\\";\n    return ignition::math::Vector3d(0, 0, 0);\n  }\n\n  // Calculate the indices of the surrounding points.\n  int idx_x = static_cast<int>(floor((position.X() - min_x_) / res_x_));\n  int idx_y = static_cast<int>(floor((position.Y() - min_y_) / res_y_));\n\n  // Calculate the interpolation weights.\n  double weight_x = (position.X() - (idx_x * res_x_ + min_x_)) / res_x_;\n  double weight_y = (position.Y() - (idx_y * res_y_ + min_y_)) / res_y_;\n\n  // Calculate the interpolated value.\n  ignition::math::Vector3d interpolated_value =\n      (1 - weight_x) * (1 - weight_y) * wind_at_vertices[idx_x + idx_y * n_x_] +\n      weight_x * (1 - weight_y) * wind_at_vertices[idx_x + 1 + idx_y * n_x_] +\n      (1 - weight_x) * weight_y * wind_at_vertices[idx_x + (idx_y + 1) * n_x_] +\n      weight_x * weight_y * wind_at_vertices[idx_x + 1 + (idx_y + 1) * n_x_];\n\n  return interpolated_value;\n}", "CodeBleu_score": 34.325857400145416}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  // Calculate the interpolation weight between the two points.\n\n  double weight = (position - points[0].X()) / (points[1].X() - points[0].X());\n\n  // Interpolate the value between the two points using the weight.\n\n  return points[0] + (points[1] - points[0]) * weight;\n}", "CodeBleu_score": 37.14414000981483}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  double newTime = _time;\n  if (this->loop)\n  {\n    if (newTime < 0)\n      newTime = fmod(newTime, this->length);\n    else if (newTime > this->length)\n      newTime = fmod(newTime, this->length);\n  }\n  else\n  {\n    if (newTime < 0)\n      newTime = 0;\n    else if (newTime > this->length)\n      newTime = this->length;\n  }\n\n  this->timePos = newTime;\n}", "CodeBleu_score": 48.48270493073158}, {"code": "void Animation::SetTime(double _time){\n\t  if (this->timePos == _time)\n    return;\n\n  if (this->loop)\n  {\n    this->timePos = fmod(_time, this->length);\n  }\n  else\n  {\n    this->timePos = ignition::math::clamp(_time, 0.0, this->length);\n  }\n\n  this->Update();\n}", "CodeBleu_score": 47.95946145130061}, {"code": "void Animation::SetTime(double _time){\n\t  // If the time position is different than the new time, update it\n  if (this->timePos != _time)\n  {\n    this->timePos = _time;\n    this->UpdateTime();\n  }\n}", "CodeBleu_score": 37.402746177921784}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.vehicle.attitude)\n    self.target_motion = self.construct_target(yaw=yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n\n", "CodeBleu_score": 57.126056730495975}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.vehicle.attitude)\n    self.target_motion = self.construct_target(\n        x=self.vehicle.location.global_relative_frame.lat,\n        y=self.vehicle.location.global_relative_frame.lon,\n        z=self.vehicle.location.global_relative_frame.alt,\n        yaw=yaw,\n    )\n    print(\n        self.vehicle_type + \"_\" + self.vehicle_id + \": \" + self.flight_mode\n    )  # Print the vehicle type, vehicle ID, and flight mode\n\n", "CodeBleu_score": 58.14097378217063}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.vehicle.attitude)\n    self.target_motion = self.construct_target(x=self.vehicle.location.global_relative_frame.lat, y=self.vehicle.location.global_relative_frame.lon, z=self.vehicle.location.global_relative_frame.alt, yaw=yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n", "CodeBleu_score": 61.31914263158386}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode + \" failed\")\n            return False\n\n", "CodeBleu_score": 57.23031197667828}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    elif self.flight_mode == 'OFFBOARD':\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        if self.flightModeService('OFFBOARD'):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode changed to \" + self.flight_mode)\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode change failed\")\n    elif self.flight_mode == 'LAND':\n        self.hover_flag = 0\n        self.flight_mode = 'LAND'\n        if self.flightModeService('LAND'):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode changed to \" + self.flight_mode)\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode change failed\")\n    elif self.flight_mode == 'TAKEOFF':\n        self.hover_flag = 0\n        self.flight_mode = 'TAKEOFF'\n        if self.flightModeService('TAKEOFF'):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode changed to \" + self.flight_mode)\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode change failed\")\n    elif self.flight_mode == 'STOP':\n        self.hover_flag = 0\n        self.flight_mode = 'STOP'\n        if self.flightModeService('STOP'):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode changed to \" + self.flight_mode)\n        else:\n            print(self.vehicle_type + '_' + self.veh", "CodeBleu_score": 38.23513972769935}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + ': mode switch failed')\n            return False\n\n", "CodeBleu_score": 69.3114659347853}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, 'OFFBOARD')\n    if self.hover_flag == 0 and self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, 'HOVER'):\n        self.hover_flag = 1\n        self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, 'HOVER')\n\n", "CodeBleu_score": 36.10244921931884}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        if self.flight_mode != 'HOVER':\n            self.flight_mode = 'OFFBOARD'\n            self.flightModeService(self.flight_mode, 1)\n    else:\n        if self.hover_flag == 0:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.flightModeService(self.flight_mode, 1)\n            self.target_motion = self.construct_target(z=1.0)\n\n", "CodeBleu_score": 57.4250593148218}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, \"OFFBOARD\")\n    if (self.hover_flag == 0 and self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, \"HOVER\")):\n        self.hover_flag = 1\n        self.flightModeService(self.vehicle_type + '_' + self.vehicle_id, \"HOVER\")\n        self.hover_action()\n\n", "CodeBleu_score": 47.698729602924026}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        return q.yaw\n\n", "CodeBleu_score": 41.855859011870166}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        return q.yaw\n\n", "CodeBleu_score": 41.855859011870166}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        return q.yaw\n\n", "CodeBleu_score": 41.855859011870166}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 0\n    self.motion_type = 0\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw=self.current_yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": Hovering", "CodeBleu_score": 48.133208174060606}, {"code": "def hover(self)\n\t\n    # Set the coordinate frame and motion type\n    self.coordinate_frame = 1\n    self.motion_type = 1\n\n    # Construct the target motion\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n\n    # Print the vehicle type and ID\n    print(self.vehicle_type + '_' + self.vehicle_id + ': Hovering')\n\n", "CodeBleu_score": 44.319192047761426}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": \" + self.flight_mode)\n\n", "CodeBleu_score": 43.77990133503626}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode + ' failed')\n            return False\n\n", "CodeBleu_score": 59.382663015096725}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Flight mode switch failed!\\\")\n            return False\n\n", "CodeBleu_score": 68.00726400482782}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return\n    if self.flight_modeService(self.flight_mode):\n        print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode + ' failed')\n        return False\n\n", "CodeBleu_score": 62.4167352455702}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n    return self.total_reward\n\n", "CodeBleu_score": 55.929247471399535}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n    return self.total_reward\n\n", "CodeBleu_score": 55.929247471399535}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n    return self.total_reward\n\n", "CodeBleu_score": 55.929247471399535}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[self.uav_id] = msg\n        if self.gcs_cmd == \"TAKEOFF\":\n            self.takeoff_target_pose = self.construct_target(self.takeoff_target_pose.pose.position.x,\n                                                             self.takeoff_target_pose.pose.position.y,\n                                                             self.takeoff_target_pose.pose.position.z + self.takeoff_height,\n                                                             self.current_heading)\n        elif self.gcs_cmd == \"HOVER\":\n            self.hover_target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                           self.hover_target_pose.pose.position.y,\n                                                           self.hover_target_pose.pose.position.z,\n                                                           self.current_heading)\n\n        # Applying a bias to the position coordinates\n        self.global_pose[self.uav_id].pose.position.x += self.uav_bias[0]\n\n        self.global_pose[self.uav_id].pose.position.y += self.uav_bias[1]\n\n        self.global_pose[self.uav_id].pose.position.z += self.uav_bias[2]\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget", "CodeBleu_score": 20.700072159396505}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[i] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x + self.takeoff_bias[0]\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y + self.takeoff_bias[1]\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z + self.takeoff_bias[2]\n            self.takeoff_target_pose.pose.orientation = self.local_pose.pose.orientation\n\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x + self.hover_bias[0]\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y + self.hover_bias[1]\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z + self.hover_bias[2]\n            self.hover_target_pose.pose.orientation = self.local_pose.pose.orientation\n\n    elif i in self.neighbor_id:\n        self.global_pose[i] = msg\n\n", "CodeBleu_score": 25.216780485045163}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[i] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose = self.local_pose\n            self.hover_target_pose = self.local_pose\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = self.local_pose\n    else:\n        self.global_pose[i] = msg\n        self.global_pose[i].pose.position.x += self.uav_id_bias[i][0]\n        self.global_pose[i].pose.position.y += self.uav_id_bias[i][1]\n        self.global_pose[i].pose.position.z += self.uav_id_bias[i][2]\n\n    '''\n    Callback Function\n    '''\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n\n    def local_pose_callback(self, msg, i):\n        if i == self.uav_id:\n            self.local_pose = msg\n            self.global_pose[i] = msg\n            if self.gcs_cmd == 'TAKEOFF':\n                self.takeoff_target_pose = self.local_pose\n                self.hover_target_pose = self.local_pose\n            elif self.gcs_cmd == 'HOVER':\n                self.hover_target_pose = self.local_pose\n        else:\n            self.global_pose[i] = msg\n            self.global_pose[i].pose.position.x += self.uav_id_bias[i][0]\n            self.global_pose[i].pose.position.y += self.uav_id_bias[i][1]\n            self.global_pose[i].pose.position.z += self.uav_id_bias[i][2]\n\n    def mavros_state_callback", "CodeBleu_score": 27.76669654907218}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.global_pose[self.uav_id].pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 72.40427091732786}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    graph = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            graph[i, j] = int(numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])) - 50)\n    return graph\n\n", "CodeBleu_score": 39.59613606193424}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            dist_matrix[i][j] = int(numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])))\n    return dist_matrix\n\n", "CodeBleu_score": 41.989196657939964}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\n    dist_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            dist_matrix[i, j] = numpy.linalg.norm(orig_formation[i] - change_formation[j])\n\n    # Adjust the distances by subtracting them from 50 and convert to integers\n    dist_matrix = (50 - dist_matrix).astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 40.82826362365643}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n", "CodeBleu_score": 54.516172958351916}, {"code": "def find_path(self, i)\n\t\n\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 54.516172958351916}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n", "CodeBleu_score": 54.516172958351916}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    changed_id = []\n    for i in range(self.uav_num - 1):\n        while True:\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            if self.find_path(i):\n                break\n            slack_min = numpy.min(self.slack_right)\n            self.label_left += slack_min\n            self.label_right -= slack_min\n        for j in range(self.uav_num - 1):\n            if self.visit_right[j]:\n                self.visit_right[j] = False\n                if self.match_right[j] != -1:\n                    self.visit_left[self.match_right[j]] = True\n        changed_id.append(i)\n    return changed_id\n\n", "CodeBleu_score": 50.831239079806856}, {"code": "def KM(self)\n\t\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    changed_id = []\n    while len(changed_id) != self.uav_num - 1:\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        for i in range(self.uav_num - 1):\n            if self.visit_left[i] == 0 and self.match_right[i] == -1:\n                self.find_path(i)\n        if len(changed_id) != self.uav_num - 1:\n            slack_min = numpy.min(self.slack_right)\n            self.label_left += slack_min\n            self.label_right -= slack_min\n            changed_id = []\n            for i in range(self.uav_num - 1):\n                if self.visit_left[i] == 0 and self.match_right[i] == -1:\n                    self.find_path(i)\n    return changed_id\n\n", "CodeBleu_score": 49.23236097063459}, {"code": "def KM(self)\n\t\n    while True:\n            self.slack_right = numpy.array([100] * (self.uav_num - 1))\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            for i in range(self.uav_num - 1):\n                while not self.find_path(i):\n                    gap = numpy.min(self.slack_right)\n                    self.label_left += gap\n                    self.label_right -= gap\n                    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n                    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n                    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            return self.match_right\n\n    def timer_callback(self):\n        self.pose_pub.publish(self.pose)\n        self.formation_pattern_pub.publish(Float32MultiArray(data=self.new_formation.flatten().tolist()))\n        self.communication_topology_pub.publish(Int32MultiArray(data=self.communication_topology.flatten().tolist()))\n        self.vel_enu_pub.publish(self.cmd_vel_enu)\n        self.cmd_pub.publish(self.cmd)\n\n    def get_new_formation(self, changed_id, change_formation):\n        # Get a new formation pattern of UAVs based on KM.\n        new_formation = numpy.zeros((3, self.uav_num - 1))\n        for i in range(self.uav_num - 1):\n            if i in changed_id:\n                new_formation[:, i] = change_formation[:, changed_id[i]]\n            else:\n                new_formation", "CodeBleu_score": 44.58690243810677}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    yellow = cv2.bitwise_and(image, image, mask=yellow_mask)\n    return yellow\n\n", "CodeBleu_score": 28.668945243058065}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=yellow_mask)\n\n", "CodeBleu_score": 28.24710080405423}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // Check if the standalone_tag_descriptions_ map contains a description for the given ID\n  std::map<int, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n  if (it != standalone_tag_descriptions_.end()) {\n    // If the description is found, set the descriptionContainer to the tag's description and return true\n    descriptionContainer = &(it->second);\n    return true;\n  } else {\n    // If the description is not found and printWarning is true, log a warning message\n    if (printWarning) {\n      ROS_WARN_STREAM(\"Could not find standalone tag description for id: \" << id);\n    }\n    // Return false\n    return false;\n  }\n}", "CodeBleu_score": 47.33320706113201}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  std::map<int, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end())\n  {\n    if (printWarning)\n    {\n      ROS_WARN_STREAM(\\\"Could not find standalone tag description for id \\\" << id);\n    }\n    return false;\n  }\n  else\n  {\n    descriptionContainer = &(it->second);\n    return true;\n  }\n}", "CodeBleu_score": 43.68570350898256}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // Search for the tag's description in the map of standalone tag descriptions\n  StandaloneTagDescriptionMap::iterator it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end())\n  {\n    // If the tag is not found, print a warning\n    if (printWarning)\n    {\n      ROS_WARN(\\\"Could not find standalone tag description for tag %d\\\", id);\n    }\n    return false;\n  }\n  else\n  {\n    // If the tag was found, set the description container and return true\n    descriptionContainer = &(it->second);\n    return true;\n  }\n}", "CodeBleu_score": 38.2814088515681}]}
