{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_next;\n\tuint16_t wTotalLength;\n\n\tif (desc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tdesc_next = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\tle16_to_cpu(desc->bLength));\n\twTotalLength = le16_to_cpu(desc->wTotalLength);\n\n\twhile ((uint8_t *) desc_next < (uint8_t *) desc + wTotalLength) {\n\t\tif (desc_next->bDescriptorType == desc_id) {\n\t\t\treturn desc_next;\n\t\t}\n\t\tdesc_next = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc_next +\n\t\t\t\tle16_to_cpu(desc_next->bLength));\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 52.99003549793893}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_tmp;\n\tuint16_t desc_len;\n\n\twhile (desc) {\n\t\tdesc_tmp = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tle16_to_cpu(desc->bLength));\n\t\tdesc_len = le16_to_cpu(desc->bLength);\n\t\tif (desc_tmp->bDescriptorType == desc_id) {\n\t\t\treturn desc_tmp;\n\t\t}\n\t\tdesc = desc_tmp;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 43.342311056372246}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t", "CodeBleu_score": 8.384775463940153}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\n\tif (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {\n\t\treturn false;\n\t}\n\n\tep_num = udd_g_ctrlreq.req.wIndex & USB_EP_ADDR_MASK;\n\tif (ep_num == 0) {\n\t\tudd_set_setup_payload( (uint8_t *) & udc_ep_status[0],\n\t\t\t\tsizeof(udc_ep_status[0]));\n\t} else {\n\t\tif (udd_is_ep_halted(ep_num)) {\n\t\t\tudc_ep_status[ep_num].ep_status =\n\t\t\t\t\tCPU_TO_LE16(USB_EP_HALT);\n\t\t} else {\n\t\t\tudc_ep_status[ep_num].ep_status = 0;\n\t\t}\n\t\tudd_set_setup_payload( (uint8_t *) & udc_ep_status[ep_num],\n\t\t\t\tsizeof(udc_ep_status[ep_num]));\n\t}\n\treturn true;\n}", "CodeBleu_score": 60.95530054167424}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint16_t ep_status;\n\n\tep_num = udc_get_ep_num(udd_g_ctrlreq.req.wIndex);\n\n\tif (udd_g_ctrlreq.req.wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tep_status = 0;\n\n\tif (udd_is_ep_halted(ep_num)) {\n\t\tep_status = UDD_EP_HALT;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) & ep_status, sizeof(ep_status));\n\n\treturn true;\n}", "CodeBleu_score": 64.08875278189274}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tusb_ep_status_t ep_status;\n\n\tep_num = udd_g_ctrlreq.req.wIndex & 0x7F;\n\tif (udd_g_ctrlreq.req.wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tif (udd_is_ep_halted(ep_num)) {\n\t\tep_status = USB_EP_STATUS_HALT;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) & ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 58.619242264746205}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\tuint8_t iface_altset;\n\tuint8_t iface_setting;\n\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Select first alternate setting of the interface to update udc_ptr_iface\n\t// before call iface->setup()\n\tiface_altset = udd_g_ctrlreq.req.wValue & 0xFF;\n\tif (!udc_update_iface_desc(iface_num, iface_altset)) {\n\t\treturn false;\n\t}\n\n\t// Get alternate setting from UDI\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\tiface_setting = udi_api->getsetting();\n\n\t// Link value to payload pointer of request\n\tudd_set_setup_payload(&iface_setting, 1);\n\treturn udi_api->setup();\n}", "CodeBleu_score": 64.93891886973587}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num, setting_num;\n\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tsetting_num = udd_g_ctrlreq.req.wValue & 0xFF;\n\n\t// Disable current setting\n\tif (!udc_iface_disable(iface_num)) {\n\t\treturn false;\n\t}\n\n\t// Enable new setting\n\treturn udc_iface_enable(iface_num, setting_num);\n}", "CodeBleu_score": 33.544627857998115}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\tbool (*setup)(void);\n\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Select first alternate setting of the interface to update udc_ptr_iface\n\t// before call iface->setup()\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Call UDI setup function\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\tsetup = udi_api->setup;\n\treturn setup();\n}", "CodeBleu_score": 59.244453490303606}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Decrease data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 82.55771435159151}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n// Check status of transfer\nif (UDD_EP_TRANSFER_OK != status) {\n// Transfer aborted\n// Now wait MSC setup reset to relaunch CBW reception\nreturn;\n}\nudi_msc_csw.dCSWDataResidue -= nb_sent;\nudi_msc_csw_process();\n}", "CodeBleu_score": 79.19285916238562}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\t// Check status of transfer\n\tif (UDD_EP_TRANSFER_OK != status) {\n\t\t// Transfer aborted\n\t\t// Now wait MSC setup reset to relaunch CBW reception\n\t\treturn;\n\t}\n\t// Update CSW residue field\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\t// Process CSW\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 79.43271917726864}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// If data to send\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\t// Case 1: data to send\n\t\t// Stall the next request from the host on the appropriate endpoint\n\t\t// based on the direction of the CBW\n\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n\t\t} else {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n\t\t}\n\t} else {\n\t\t// Case 14: no data to send\n\t\t// Send CSW\n\t\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\t\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t\tudi_msc_csw.bCSWStatus = 0;\n\t\tudi_msc_csw.dCSWSignature = USB_CSW_SIGNATURE;\n\t\tudi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n\t}\n}", "CodeBleu_score": 59.80171064453654}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If data to send, then stall the endpoint\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n\t\t} else {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n\t\t}\n\t}\n\t// Prepare CSW\n\tudi_msc_csw.bCSWTag = udi_msc_cbw.bCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t// Send CSW\n\tudi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 57.52849764848889}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check if there is a data to send\n\tif (0 != udi_msc_csw.dCSWDataResidue) {\n\t\t// Check direction of the data\n\t\tif (0 != (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)) {\n\t\t\t// IN data\n\t\t\t// Stall next request on IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t\t// Wait for clear of halt\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n\t\t} else {\n\t\t\t// OUT data\n\t\t\t// Stall next request on OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t\t// Wait for clear of halt\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n\t\t}\n\t} else {\n\t\t// Send CSW\n\t\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\t\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASSED;\n\t\tudi_msc_csw_send();\n\t}\n}", "CodeBleu_score": 72.89825644097363}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\tmain_b_dtr_active = true;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Cancel any scheduled reset\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tmain_b_dtr_active = false;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Schedule a delayed reset\n\t\t\tinitiateReset(1000);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.363740894805645}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\t// Enable DTR\n\t\tmain_b_dtr_active = true;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Cancel any scheduled reset\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\t// Disable DTR\n\t\tmain_b_dtr_active = false;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Schedule a delayed reset\n\t\t\tinitiateReset(1000);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.363740894805645}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\t// Enable DTR\n\t\tmain_b_dtr_active = true;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Cancel any pending reset\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\t// Disable DTR\n\t\tmain_b_dtr_active = false;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Schedule a delayed system reset\n\t\t\tinitiateReset(1000);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.363740894805645}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t\tswitch (udd_g_ctrlreq.req.bmRequestType.Type) {\n\t\tcase USB_REQ_TYPE_STANDARD:\n\t\t\tswitch (udd_g_ctrlreq.req.bRequest) {\n\t\t\t\tcase USB_REQ_GET_DESCRIPTOR:\n\t\t\t\t\tswitch (udd_g_ctrlreq.req.wValue >> 8) {\n\t\t\t\t\t\tcase USB_DT_STRING:\n\t\t\t\t\t\t\tif (udd_g_ctrlreq.req.wValue == 0xEE04) {\n\t\t\t\t\t\t\t\t// Microsoft-compatible ID descriptor\n\t\t\t\t\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\t\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (udd_g_ctrlreq.req.wValue == 0xEE05) {\n\t\t\t\t\t\t\t\t// Microsoft extended properties descriptor\n\t\t\t\t\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_extended_properties_descriptor);\n\t\t\t\t\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t// if the string is larger than request length, then cut it\n\tif (udd_g_ctrlreq.payload_size > udd_g_ctrlreq.req.wLength) {\n\t\tudd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 32.91728982574592}, {"code": "bool usb_task_other_requests(void){\n\t\tswitch (udd_g_ctrlreq.req.bmRequestType.Type) {\n\tcase USB_REQ_TYPE_STANDARD:\n\t\tswitch (udd_g_ctrlreq.req.bRequest) {\n\t\tcase USB_REQ_GET_DESCRIPTOR:\n\t\t\tswitch (udd_g_ctrlreq.req.wValue >> 8) {\n\t\t\tcase USB_DT_STRING:\n\t\t\t\tif (udd_g_ctrlreq.req.wValue & 0xFF == UDI_MS_EXTENDED_PROPERTIES_STRING_ID) {\n\t\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_extended_properties_descriptor);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (udd_g_ctrlreq.req.wValue & 0xFF == UDI_MS_COMPATIBLE_ID_STRING_ID) {\n\t\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\tdefault:\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 38.59687903471938}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\tuint8_t *p = buf;\n\tuint8_t *end = p + nbyte;\n\n\twhile (p < end) {\n\t\t// write dummy byte with address and end transmission flag\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n\t\tWHILE_TX(0);\n\t\tWHILE_RX(0);\n\n\t\t*p++ = SPI0->SPI_RDR;\n\t}\n\n\t// read last byte\n\t*p = spiRec();\n}", "CodeBleu_score": 50.42586072145563}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint8_t *p = buf;\n\twhile (nbyte--) {\n\t\t// write dummy byte with address and end transmission flag\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n\t\tWHILE_TX(0);\n\t\tWHILE_RX(0);\n\n\t\t//DELAY_US(1U);\n\t\t*p++ = SPI0->SPI_RDR;\n\t}\n\t*p = spiRec();\n}", "CodeBleu_score": 48.99005173813303}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\tuint8_t *p = buf;\n\twhile (nbyte--) {\n\t\t// write dummy byte with address and end transmission flag\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n\t\t// wait until byte is received\n\t\tWHILE_TX(0);\n\t\tWHILE_RX(0);\n\n\t\t*p++ = SPI0->SPI_RDR;\n\t}\n\n\t// read last byte\n\t*p = spiRec();\n}", "CodeBleu_score": 48.99005173813303}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* isr_table = get_relocated_table_addr();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = isr_table[irq];\n\n\t// Disable global interrupts\n\tCRITICAL_SECTION_START();\n\n\t// Replace the current handler with the new handler\n\tisr_table[irq] = newHandler;\n\n\t// Reenable interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 66.5481920441454}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* relocated_table_addr = get_relocated_table_addr();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = relocated_table_addr[irq];\n\n\t// Disable global interrupts\n\tCRITICAL_SECTION_START();\n\n\t// Replace the current handler with the new handler\n\trelocated_table_addr[irq] = newHandler;\n\n\t// Reenable interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 63.96827334516517}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* isr_tab = get_relocated_table_addr();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = isr_tab[irq];\n\n\t// Disable global interrupts\n\tCRITICAL_SECTION_START();\n\n\t// Replace the current handler with the new handler\n\tisr_tab[irq] = newHandler;\n\n\t// Reenable interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 67.08756012153272}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\n#if ENABLED(EMERGENCY_PARSER)\n  // If the emergency parser is enabled, check if there is a character pending\n  if (pending_char >= 0) return pending_char;\n#endif\n\n  // If the USB CDC is not enabled, return -1\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If there are no bytes available, return -1\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  // Read the next character\n  int c = udi_cdc_getc();\n\n  // If the emergency parser is enabled, process the character\n  if (ENABLED(EMERGENCY_PARSER)) {\n    // If the character is a carriage return, process the line\n    if (c == '\\r') {\n      emergency_parser.process_now();\n      pending_char = -1;\n    }\n    // If the character is a line feed, process the line\n    else if (c == '\n') {\n      emergency_parser.process_now();\n      pending_char = -1;\n    }\n    // Otherwise, store the character in the pending character\n    else\n      pending_char = c;\n  }\n\n  // Return the character\n  return c;\n}", "CodeBleu_score": 51.89538835804516}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (pending_char >= 0) return pending_char;\n#endif\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  return udi_cdc_getc();\n}", "CodeBleu_score": 49.79338249386225}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  // If there is a pending character, return it\n  if (pending_char >= 0) {\n    return pending_char;\n  }\n#endif\n  // If the USB CDC is not enabled or configured on the PC side, or if no bytes are sent from the PC, return -1\n  if (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active() || !udi_cdc_is_rx_ready()) {\n    return -1;\n  }\n  // Read the next character and return it\n  return udi_cdc_getc();\n}", "CodeBleu_score": 37.1593172235235}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    emergency_parser.update(emergency_state, (char)c);\n    return c;\n  }\n#endif\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  int c = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(emergency_state, (char)c));\n\n  return c;\n}", "CodeBleu_score": 74.27621914722738}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n    return c;\n  }\n#endif\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  int c = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n  return c;\n}", "CodeBleu_score": 83.80081486475018}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n    return c;\n  }\n#endif\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  int c = udi_cdc_getc();\n\n#if ENABLED(EMERGENCY_PARSER)\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n#endif\n\n  return c;\n}", "CodeBleu_score": 78.0594653517553}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  // If the emergency parser is enabled, check if there are any characters pending in the buffer\n  if (emergency_parser.available())\n    return emergency_parser.available();\n#endif\n\n  // If there is a pending character, return 1\n  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 48.49948908560533}, {"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(MARLIN_SERIAL_STATS_DROPPED_RX)\n  static uint32_t last_rx_time = 0;\n  static uint32_t last_rx_count = 0;\n  uint32_t now = millis();\n  if (now - last_rx_time > 1000) {\n    SERIAL_ECHO_MSG(\"RX: \");\n    SERIAL_ECHOLNPAIR(\"dropped \", last_rx_count);\n    last_rx_count = 0;\n    last_rx_time = now;\n  }\n#endif\n\n  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n#if ENABLED(MARLIN_SERIAL_STATS_DROPPED_RX)\n  last_rx_count++;\n#endif\n\n  return 1;\n}", "CodeBleu_score": 35.26097530943565}, {"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (pending_char >= 0)\n    return 1;\n#endif\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 26.95628428740853}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint16_t read = 0;\n\twhile (size--) {\n\t\tuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n\n\t\tuint8_t v = ee_Read(uint32_t(p));\n\t\tif (writing && value) *value++ = v;\n\t\tcrc16(crc, &v, 1);\n\t\tpos++;\n\t\tread++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.493616300136495}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint16_t read = 0;\n\twhile (size--) {\n\t\tuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n\n\t\tuint8_t v = ee_Read(uint32_t(p));\n\t\tif (writing) *value = v;\n\t\tcrc16(crc, &v, 1);\n\t\tpos++;\n\t\tvalue++;\n\t\tread++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 60.010860065073814}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint16_t read = 0;\nwhile (size--) {\nuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\nuint8_t v = ee_Read(uint32_t(p));\nif (writing) *value = v;\nif (value) crc16(crc, &v, 1);\npos++;\nvalue++;\nif (++read & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM reads\n}\nreturn false;\n}", "CodeBleu_score": 57.38881279354724}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    pwm_pin_t &pindata = pwm_pin_data[pin & 0x7F];\n    const uint32_t duty = map(value, 0, 255, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty ? SBI32(i2s_port_data, pin & 0x7F) : CBI32(i2s_port_data, pin & 0x7F); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(value, 0, 255, 0, _BV(PWM_RESOLUTION)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 46.0434212715817}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(value, 0, 255, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty ? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(value, 0, 255, 0, _BV(PWM_RESOLUTION)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 46.462156040774005}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(value, 0, 255, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty ? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(value, 0, 255, 0, _BV(PWM_RESOLUTION)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 46.462156040774005}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n  if (value != degrees) {\n    write(value);\n    delay(servo_delay[channel]);\n    detach();\n  }\n#else\n  write(value);\n  delay(servo_delay[channel]);\n#endif\n}", "CodeBleu_score": 43.28031305927047}, {"code": "void Servo::move(const int value){\n\t#if NUM_SERVOS > 0\n  static_assert(SERVO_DELAY_LENGTH >= NUM_SERVOS, \"SERVO_DELAY_LENGTH is too short for NUM_SERVOS\");\n#endif\n  if (channel >= 0) {\n    write(value);\n    delay(SERVO_DELAY[channel]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n#endif\n  }\n}", "CodeBleu_score": 50.54505032932657}, {"code": "void Servo::move(const int value){\n\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n#if NUM_SERVOS > 0\n  static_assert(SERVO_DELAY_LENGTH >= NUM_SERVOS, \"SERVO_DELAY_LENGTH is too short for the number of servos. See Configuration.h.\");\n  if (channel >= 0) {\n    write(value);\n    delay(SERVO_DELAY_ARRAY[channel]);\n  }\n#endif\n}", "CodeBleu_score": 50.8067478095648}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n  if (i2s_port_data != i2s_port_data_last) {\n    i2s_port_data_last = i2s_port_data;\n    i2s_port_data_pos = i2s_port_data_pos_last = (i2s_port_data_pos + 1) % DMA_BUF_COUNT;\n    i2s_port_data_buf[i2s_port_data_pos] = i2s_port_data;\n  }\n#else\n  if (i2s_port_data != i2s_port_data_last) {\n    i2s_port_data_last = i2s_port_data;\n    i2s_port_data_pos = i2s_port_data_pos_last = (i2s_port_data_pos + 1) % DMA_BUF_COUNT;\n    i2s_port_data_buf[i2s_port_data_pos] = i2s_port_data;\n  }\n#endif\n}", "CodeBleu_score": 24.941570785674887}, {"code": "void i2s_push_sample(){\n\t\n#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n  if (i2s_port_data != i2s_port_data_last) {\n    i2s_port_data_last = i2s_port_data;\n    i2s_port_data_dma[i2s_port_data_pos] = i2s_port_data;\n    i2s_port_data_pos = (i2s_port_data_pos + 1) & (DMA_BUF_COUNT - 1);\n  }\n#else\n  i2s_port_data_dma[i2s_port_data_pos] = i2s_port_data;\n  i2s_port_data_pos = (i2s_port_data_pos + 1) & (DMA_BUF_COUNT - 1);\n#endif\n}", "CodeBleu_score": 17.776152859928196}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n\treturn counter_value;\n}", "CodeBleu_score": 97.86105963185919}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n\treturn counter_value;\n}", "CodeBleu_score": 97.86105963185919}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t#if TIMER_MAX <= 2\n  return TG[timer_config[timer_num].group]->hw_timer[timer_config[timer_num].idx].cnt_high;\n#else\n  return TG[timer_config[timer_num].group]->hw_timer[timer_config[timer_num].idx].cnt_low;\n#endif\n}", "CodeBleu_score": 39.74344687666781}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n#if ENABLED(EEPROM_CHITCHAT)\n  if (pos + size > MARLIN_EEPROM_SIZE) {\n    SERIAL_ERROR_MSG(\"EEPROM read out of bounds\");\n    return false;\n  }\n#endif\n\n  for (size_t i = 0; i < size; i++) {\n    value[i] = HAL_eeprom_data[pos + i];\n    if (writing) HAL_eeprom_data[pos + i] = 0xFF;\n    crc16(crc, &value[i], 1);\n  }\n\n  pos += size;\n  return false;\n}", "CodeBleu_score": 67.54457024586206}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t data = HAL_eeprom_data[pos + i];\n\t\tif (writing) value[i] = data;\n\t\tcrc16(crc, &data, 1);\n\t}\n\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 82.83128569321696}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\nif (writing) value[i] = HAL_eeprom_data[pos + i];\ncrc16(crc, &HAL_eeprom_data[pos + i], 1);\n}\npos += size;\nreturn false;\n}", "CodeBleu_score": 74.05619735832707}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 83.20810264275119}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 83.20810264275119}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\nCORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\nWITH_RETRY(SDIO_WRITE_RETRIES, {\nen_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\nif (rc == Ok) return true;\nprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n})\n\nreturn false;\n}", "CodeBleu_score": 83.16309928024805}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t#if defined(TEMP_TIMER_PRESCALE) && defined(STEP_TIMER_PRESCALE)\n  if (timer_num == TIMER_CHANNEL_TEMP) {\n    temp_timer.start(frequency, TEMP_TIMER_PRESCALE, 1);\n  } else if (timer_num == TIMER_CHANNEL_STEP) {\n    step_timer.start(frequency, STEP_TIMER_PRESCALE, 1);\n  } else {\n    ASSERT(0);\n  }\n#elif defined(TEMP_TIMER_PRESCALE)\n  if (timer_num == TIMER_CHANNEL_TEMP) {\n    temp_timer.start(frequency, TEMP_TIMER_PRESCALE, 1);\n  } else {\n    ASSERT(0);\n  }\n#elif defined(STEP_TIMER_PRESCALE)\n  if (timer_num == TIMER_CHANNEL_STEP) {\n    step_timer.start(frequency, STEP_TIMER_PRESCALE, 1);\n  } else {\n    ASSERT(0);\n  }\n#else\n  if (timer_num == TIMER_CHANNEL_TEMP) {\n    temp_timer.start(frequency, 1);\n  } else if (timer_num == TIMER_CHANNEL_STEP) {\n    step_timer.start(frequency, 1);\n  } else {\n    ASSERT(0);\n  }\n#endif\n}", "CodeBleu_score": 46.662049400171576}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\n#ifdef TEMP_TIMER_CHANNEL\n\n  if (timer_num == TEMP_TIMER_CHANNEL) {\n\n    temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n\n  }\n\n#endif\n\n#ifdef STEP_TIMER_CHANNEL\n\n  if (timer_num == STEP_TIMER_CHANNEL) {\n\n    step_timer.start(frequency, STEP_TIMER_PRESCALE);\n\n  }\n\n#endif\n\n}", "CodeBleu_score": 33.079717259680265}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t#ifdef DEBUG_TIMER\n  DEBUG_TIMER_MSG(\"HAL_timer_start(%d, %d)\n\", timer_num, frequency);\n#endif\n  if (timer_num == TIMER_CHANNEL_TEMP) {\n    temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n  }\n  else if (timer_num == TIMER_CHANNEL_STEP) {\n    step_timer.start(frequency, STEP_TIMER_PRESCALE);\n  }\n  else {\n    ASSERT(0);\n  }\n}", "CodeBleu_score": 37.5179455996139}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t#ifdef DEBUG_EEPROM\n  DEBUG_ECHOLNPGM(\\\"PersistentStore::access_start\\\");\n#endif\n\n  FILE *fp = fopen(filename, \\\"rb\\\");\n  if (fp) {\n    fseek(fp, 0, SEEK_END);\n    size_t size = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    if (size < MARLIN_EEPROM_SIZE) {\n      memset(buffer + size, EEPROM_ERASE_VALUE, MARLIN_EEPROM_SIZE - size);\n    }\n    fread(buffer, 1, MARLIN_EEPROM_SIZE, fp);\n    fclose(fp);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 39.05024594361393}, {"code": "bool PersistentStore::access_start(){\n\t\tFILE *f = fopen(filename, \\\"rb\\\");\n\tif (!f) return false;\n\tfread(buffer, 1, capacity(), f);\n\tfclose(f);\n\treturn true;\n}", "CodeBleu_score": 8.960796488082378}, {"code": "bool PersistentStore::access_start(){\n\t#if ENABLED(DEBUG_EEPROM_EMULATION)\n  debugEeprom(\"access_start()\n\");\n#endif\n  FILE *f = fopen(filename, \"rb\");\n  if (!f) {\n    // File does not exist or cannot be opened\n    return false;\n  }\n\n  // Get file size\n  fseek(f, 0, SEEK_END);\n  size_t size = ftell(f);\n  fseek(f, 0, SEEK_SET);\n\n  // Fill buffer with default value\n  memset(buffer, EEPROM_ERASE_VALUE, sizeof(buffer));\n\n  if (size < sizeof(buffer)) {\n    // File is smaller than EEPROM size, fill buffer with default erase value\n    fread(buffer, 1, size, f);\n    fread(buffer + size, 1, sizeof(buffer) - size, f);\n  }\n  else {\n    // File is larger than EEPROM size, read file contents into buffer\n    fread(buffer, 1, sizeof(buffer), f);\n  }\n\n  fclose(f);\n\n  return true;\n}", "CodeBleu_score": 46.980367757690445}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tuint8_t i = 0x80;\n\twhile (i) {\n\t\tHAL_GPIO_WritePin(SPIx_MISO_GPIO_Port, SPIx_MISO_Pin, GPIO_PIN_SET);\n\t\tif (b & i) {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_RESET);\n\t\tr = r << 1;\n\t\tif (HAL_GPIO_ReadPin(SPIx_MISO_GPIO_Port, SPIx_MISO_Pin)) {\n\t\t\tr |= 1;\n\t\t}\n\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_SET);\n\t\ti >>= 1;\n\t}\n\t(*delaySPIFunc)();\n\treturn r;\n}", "CodeBleu_score": 33.56401976246662}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t c = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\t// Set the clock pin low\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_RESET);\n\t\t// Write the most significant bit of the byte to the MOSI pin\n\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\t// Toggle the clock pin high\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_SET);\n\t\t// Read the bit from the MISO pin\n\t\tc <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin)) c |= 0x01;\n\t\t// Shift the byte left\n\t\tb <<= 1;\n\t\t// Delay a bit\n\t\t(*delaySPIFunc)();\n\t}\n\treturn c;\n}", "CodeBleu_score": 39.03436351818075}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t", "CodeBleu_score": 1.975462297699716}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\n}", "CodeBleu_score": 3.9245730253189546}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\n}", "CodeBleu_score": 3.9245730253189546}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\nassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\nassert_param(IS_FUNCTIONAL_STATE(NewState));\nif (NewState != DISABLE)\nRCC->AHBENR |= RCC_AHBPeriph;\nelse\nRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 93.47929745602885}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// If there is a byte available, read it\n\tif (obj->uart->SR & USART_SR_RXNE) {\n\t\t// Read the byte\n\t\tuint8_t c = obj->uart->DR;\n\n\t\t// If there is a byte available, store it in the buffer\n\t\tif (obj->rx_head != obj->rx_tail) {\n\t\t\tobj->rx_buffer[obj->rx_head] = c;\n\t\t\tobj->rx_head = (obj->rx_head + 1) & SERIAL_BUFFER_MASK;\n\t\t}\n\n\t\t// Update the emergency parser\n\t\t#if ENABLED(EMERGENCY_PARSER)\n\t\t\tif (obj->emergency_parser)\n\t\t\t\temergency_parser_rx_byte(c);\n\t\t#endif\n\t}\n}", "CodeBleu_score": 43.302276785062475}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Read status register\n\tuint32_t sr = obj->s->SR;\n\t// If no error occurs\n\tif (!(sr & USART_SR_PE)) {\n\t\t// Read data from data register\n\t\tuint8_t data = obj->s->DR;\n\t\t// If there is space available in the receive buffer\n\t\tif (obj->rx_buffer.head != (obj->rx_buffer.tail + 1) % SERIAL_RX_BUFFER_SIZE) {\n\t\t\t// Store data in receive buffer\n\t\t\tobj->rx_buffer.buffer[obj->rx_buffer.head] = data;\n\t\t\t// Increment head index\n\t\t\tobj->rx_buffer.head = (obj->rx_buffer.head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t}\n\t\t// If emergency parser is enabled\n\t\tif (ENABLED(EMERGENCY_PARSER)) {\n\t\t\t// Update emergency parser\n\t\t\temergency_parser.update(data);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.966961568348374}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (obj == &MSerial0._serial) {\n    MSerial0.emergency_parser.receive_byte(MSerial0._serial.getc());\n  }\n  else\n#endif\n  {\n    uint8_t c;\n    if (obj->sercom->USART.INTFLAG.bit.RXC) {\n      c = obj->sercom->USART.DATA.bit.DATA;\n      if (obj->rx_buffer.availableForStore()) {\n        obj->rx_buffer.store_char(c);\n      }\n      obj->rx_buffer.set_head(obj->rx_buffer.get_head() + 1);\n    }\n  }\n}", "CodeBleu_score": 42.5027040065557}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t#if ENABLED(SPEAKER) && defined(USE_MCP4922)\n  if (timer_num == MF_TIMER_STEP) {\n    // If we're using the step timer for speaker output, we need to disable the\n    // MCP4922 interrupt output because it uses the same timer.\n    MCP4922_disable_interrupt();\n  }\n#endif\n\n  if (timer_num < NUM_HARDWARE_TIMERS && timer_instance[timer_num] && !timer_instance[timer_num]->hasInterrupt()) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n  }\n}", "CodeBleu_score": 81.47404103571874}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num] != nullptr && !timer_instance[timer_num]->hasInterrupt()) {\n\t\tswitch (timer_num) {\n\t\tcase MF_TIMER_STEP:\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\tbreak;\n\t\tcase MF_TIMER_TEMP:\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 85.72111833019778}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t#if ENABLED(SPEAKER) && defined(HAL_TIMER_SPEAKER_INTERRUPT)\n  if (timer_num == MF_TIMER_SPEAKER) {\n    if (timer_instance[timer_num] && !timer_instance[timer_num]->hasInterrupt())\n      timer_instance[timer_num]->attachInterrupt(HAL_timer_speaker_interrupt);\n  }\n  else\n#endif\n  if (timer_num == MF_TIMER_STEP) {\n    if (timer_instance[timer_num] && !timer_instance[timer_num]->hasInterrupt())\n      timer_instance[timer_num]->attachInterrupt(Step_Handler);\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (timer_instance[timer_num] && !timer_instance[timer_num]->hasInterrupt())\n      timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n  }\n}", "CodeBleu_score": 52.532485444580956}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 58.137965493277}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 58.137965493277}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 58.137965493277}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// disable interrupts\n\tinterrupt.Disable(usb.IRQ_OTG_HS)\n\n\t// check if data available\n\tsize := usbcdc.txBuffer.Used()\n\tif size > 0 {\n\t\t// send data\n\t\tusbcdc.SendUSBInPacket(size)\n\t} else {\n\t\t// no data available\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// restore interrupts\n\tinterrupt.Enable(usb.IRQ_OTG_HS)\n}", "CodeBleu_score": 54.711030069630255}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// disable interrupts\n\tinterrupt.Disable()\n\n\t// check if there is data in the transmit buffer\n\tsize := usbcdc.txBuffer.Used()\n\tif size > 0 {\n\t\t// send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket(size)\n\t}\n\n\t// if no data is available, set \"waitTxc\" to false\n\tif size == 0 {\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// restore interrupts\n\tinterrupt.Enable()\n}", "CodeBleu_score": 57.57777730831059}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// disable interrupts\n\tinterrupt.Disable()\n\n\t// check if there is data in the transmit buffer\n\tsize := usbcdc.txBuffer.Used()\n\tif size > 0 {\n\t\t// send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket(size)\n\t} else {\n\t\t// no data, so disable waiting for data\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// restore interrupts\n\tinterrupt.Enable()\n}", "CodeBleu_score": 61.039834037790285}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag.\n\ti2c.crReg.SetBits(i2c.crINT)\n\n\t// Generate start condition.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Wait for start condition to be transmitted.\n\tfor !i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Set peripheral address and transfer direction.\n\tif write {\n\t\ti2c.drReg.Set(address << 1) // write\n\t} else {\n\t\ti2c.drReg.Set((address << 1) | 0x01) // read\n\t}\n}", "CodeBleu_score": 44.89539679579515}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Set the I2C control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crINT | i2c.crSTO | i2c.crEN | i2c.crSTA)\n\t// Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor !i2c.srReg.HasBits(i2c.srPS1) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and send it.\n\tif write {\n\t\ti2c.drReg.Set(address<<1) // Set the read flag.\n\t}\n\ti2c.drReg.Set(address<<1 | 1) // Send the address.\n}", "CodeBleu_score": 40.34540557325694}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag.\n\ti2c.crReg.SetBits(i2c.crINT)\n\n\t// Send start condition.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Wait for start condition to be transmitted.\n\tfor !i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Send address.\n\ti2c.drReg.Set(address << 1)\n\tif !write {\n\t\ti2c.drReg.SetBits(1)\n\t}\n\ti2c.crReg.SetBits(i2c.crEA)\n}", "CodeBleu_score": 42.48109653627901}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 1 {\n\t\treturn errEraseInvalidParameters\n\t}\n\n\tif start+len > int64(FlashEraseEnd()-FlashEraseStart())/int64(eraseBlockSize()) {\n\t\treturn errEraseInvalidParameters\n\t}\n\n\twaitWhileFlashBusy()\n\n\taddress := FlashEraseStart() + uintptr(start*eraseBlockSize())\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := 0; i < int(len); i++ {\n\t\tnrf.NVMC.SetERASEPAGE(uint32(address))\n\t\twaitWhileFlashBusy()\n\t\taddress += eraseBlockSize()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.55236345343785}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 || start+len > int64(FlashDataEnd()-FlashDataStart())/eraseBlockSize() {\n\t\treturn errFlashEraseOutOfBounds\n\t}\n\n\taddress := FlashDataStart() + uintptr(start*eraseBlockSize())\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := 0; i < int(len); i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(address))\n\t\twaitWhileFlashBusy()\n\t\taddress += eraseBlockSize()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.95280650830212}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 || start+len > f.Size()/f.EraseBlockSize() {\n\t\treturn errEraseOutOfBounds\n\t}\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\taddress := FlashDataStart() + uintptr(start*f.EraseBlockSize())\n\tfor i := int64(0); i < len; i++ {\n\t\twaitWhileFlashBusy()\n\t\t// Erase word\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0xFFFFFFFF\n\t\taddress += uintptr(f.EraseBlockSize())\n\t}\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 60.02785549103669}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\t// Calculate start address for writing.\n\tstart := FlashDataStart() + uintptr(off)\n\n\t// Pad the slice to a multiple of the write block size.\n\tpadLen := len(p) % flashWriteBlockSize\n\tif padLen > 0 {\n\t\tp = append(p, make([]byte, flashWriteBlockSize-padLen)...)\n\t}\n\n\t// Enable write mode.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// Write data in blocks.\n\tfor len(p) > 0 {\n\t\t// Calculate length of block to write.\n\t\tblockLen := min(len(p), flashWriteBlockSize)\n\n\t\t// Write block.\n\t\tblock := (*[flashWriteBlockSize]byte)(unsafe.Pointer(start))\n\t\tcopy(block[:], p[:blockLen])\n\n\t\t// Wait for flash ready.\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\n\t\t// Advance.\n\t\tp = p[blockLen:]\n\t\tstart += flashWriteBlockSize\n\t}\n\n\t// Disable write mode.\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 48.18228563999318}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\t// Calculate the start address for writing.\n\taddr := FlashDataStart() + uintptr(off)\n\t// Pad the byte slice to fit the write block size.\n\tp = append(p, make([]byte, flashWriteBlockSize-len(p)%flashWriteBlockSize)...)\n\n\t// Enable write mode.\n\tFlash.Bus.TASKS_ERASESTART.Set(1)\n\tfor Flash.Bus.EVENTS_ERASESTARTED.Get() == 0 {\n\t}\n\tFlash.Bus.EVENTS_ERASESTARTED.Set(0)\n\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Wait for the flash memory to be ready.\n\t\tfor Flash.Bus.EVENTS_READY.Get() == 0 {\n\t\t}\n\t\tFlash.Bus.EVENTS_READY.Set(0)\n\n\t\t// Write a block.\n\t\tFlash.Bus.TASKS_ERASEPAGE.Set(1)\n\t\tFlash.Bus.TASKS_WRITESTART.Set(1)\n\t\tFlash.Bus.TASKS_ERASEPAGE.Set(0)\n\t\tFlash.Bus.TASKS_WRITESTART.Set(0)\n\t\tFlash.Bus.TXD.Set(uint32(addr))\n\t\tfor i := 0; i < len(p); i += 4 {\n\t\t\tFlash.Bus.TXD.Set(uint32(p[i]) | uint32(p[i+1])<<8 | uint32(p[i+2])<<16 | uint32(p[i+3])<<24)\n\t\t}\n\n\t\t// Remove the written data from the slice.\n\t\tp = p[flashWriteBlockSize:]\n\t\taddr += flashWriteBlockSize\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 42.40160762739039}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tfdDup, err := dup(fd)\n\tif err != nil {\n\t\treturn 0, \\\"\\\", err\n\t}\n\n\t// Attempt to open the directory.\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tclose(fdDup)\n\t\t\treturn 0, \\\"\\\", err\n\t\t}\n\t}\n\n\t// Return the directory pointer and no error.\n\treturn dir, \\\"\\\", nil\n}", "CodeBleu_score": 62.65610292535831}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor so that we can close it without affecting the original.\n\tfdDup, err := dup(fd)\n\tif err != nil {\n\t\treturn 0, \\\"\\\", err\n\t}\n\n\t// Attempt to open the directory using syscall.Fdopendir.\n\tdir, err := syscall.Fdopendir(fdDup)\n\tif err == nil {\n\t\treturn dir, \\\"\\\", nil\n\t}\n\n\t// If the error is anything other than EINTR, return the error.\n\tif err != syscall.EINTR {\n\t\treturn 0, \\\"\\\", err\n\t}\n\n\t// If the error is EINTR, close the duplicated file descriptor and try again.\n\tdefer close(fdDup)\n\tfor {\n\t\t// Attempt to open the directory using syscall.Fdopendir.\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\treturn dir, \\\"\\\", nil\n\t\t}\n\n\t\t// If the error is anything other than EINTR, return the error.\n\t\tif err != syscall.EINTR {\n\t\t\treturn 0, \\\"\\\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 54.277539942865815}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor so that we can close it later without\n\t// affecting the original.\n\tdupFd, _, errno := syscall.Syscall(syscall.SYS_FCNTL, uintptr(fd), syscall.F_DUPFD_CLOEXEC, 0)\n\tif errno != 0 {\n\t\treturn 0, \\\"syscall.F_DUPFD_CLOEXEC\\\", errno\n\t}\n\n\t// Repeatedly attempt to open the directory using syscall.Fdopendir until\n\t// either it succeeds or we encounter an error other than EINTR.\n\tfor {\n\t\tdir, _, errno := syscall.Syscall(syscall.SYS_OPENDIR, dupFd, 0, 0)\n\t\tif errno == 0 {\n\t\t\treturn dir, \\\"syscall.SYS_OPENDIR\\\", nil\n\t\t}\n\t\tif errno != syscall.EINTR {\n\t\t\tsyscall.Close(int(dupFd))\n\t\t\treturn 0, \\\"syscall.SYS_OPENDIR\\\", errno\n\t\t}\n\t}\n}", "CodeBleu_score": 34.78866847895201}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, \"sketch\");\n\tif (partition == NULL) {\n\t\tif (response) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (response) {\n\t\treturn partition->size - partition->label_len;\n\t} else {\n\t\treturn partition->label_len;\n\t}\n}", "CodeBleu_score": 34.57891041043638}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t desc;\n\tesp_err_t err = esp_app_desc_get_by_offs(&desc, 0);\n\tif (err != ESP_OK) {\n\t\treturn 0;\n\t}\n\n\tif (response == sketchSize_t::free) {\n\t\treturn desc.free_space;\n\t} else {\n\t\treturn desc.sketch_size;\n\t}\n}", "CodeBleu_score": 30.280060989926973}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t", "CodeBleu_score": 2.073033576343574}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % DISK_SECTOR_SIZE) {\n\t\tlog_e(\\\"Offset not aligned with sector size\\\");\n\t\treturn ESP_FAIL;\n  }\n  if (size % DISK_SECTOR_SIZE) {\n    log_e(\\\"Size not aligned with sector size\\\");\n    return ESP_FAIL;\n  }\n  if (partition->type == ESP_PARTITION_TYPE_DATA) {\n    if (partition->subtype == ESP_PARTITION_SUBTYPE_DATA_OTA) {\n      return esp_ota_write(partition, offset, data, size);\n    }\n    if (partition->subtype == ESP_PARTITION_SUBTYPE_DATA_NVS) {\n      return esp_partition_write(partition, offset, data, size);\n    }\n    if (partition->subtype == ESP_PARTITION_SUBTYPE_DATA_FAT) {\n      return ESP_FAIL;\n    }\n  }\n  if (partition->type == ESP_PARTITION_TYPE_APP) {\n    return esp_partition_write(partition, offset, data, size);\n  }\n  return ESP_FAIL;\n}", "CodeBleu_score": 42.16617852757957}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\twhile (i < maxlen && *in) {\n\t\tuint8_t a = hex_char_to_byte(*in++);\n\t\tif (a >= 0x10) continue;\n\t\tuint8_t b = hex_char_to_byte(*in++);\n\t\tif (b >= 0x10) continue;\n\t\tout[i++] = (a << 4) | b;\n\t}\n\treturn i;\n}", "CodeBleu_score": 35.552651719472465}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i, j;\n\n\tfor (i = j = 0; i < maxlen && in[i] != 0; i++) {\n\t\tuint8_t c = hex_char_to_byte(in[i]);\n\t\tif (c < 0x10) {\n\t\t\tif (j & 1) {\n\t\t\t\tout[j >> 1] |= c;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tout[j >> 1] = c << 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn j >> 1;\n}", "CodeBleu_score": 46.49136656213464}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\twhile (i < maxlen) {\n\t\tuint8_t c = hex_char_to_byte(in[i]);\n\t\tif (c > 0x0F) {\n\t\t\t// skip non-hexadecimal characters\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tuint8_t c2 = hex_char_to_byte(in[i + 1]);\n\t\tif (c2 > 0x0F) {\n\t\t\t// skip non-hexadecimal characters\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tout[i / 2] = (c << 4) + c2;\n\t\ti += 2;\n\t}\n\treturn i / 2;\n}", "CodeBleu_score": 44.21212437626967}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (!tx_ring_buf || !tx_lock) {\nreturn 0;\n}\nif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) == pdTRUE) {\nreturn uxRingbufferGetFreeSize(tx_ring_buf);\n}\nreturn 0;\n}", "CodeBleu_score": 50.29430088131522}, {"code": "int HWCDC::availableForWrite(void){\n\tif (!tx_ring_buf || !tx_lock) {\nreturn 0;\n}\nif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) != pdTRUE) {\nreturn 0;\n}\nint free_size = tx_ring_buf->free_size;\nxSemaphoreGive(tx_lock);\nreturn free_size;\n}", "CodeBleu_score": 66.87314567095275}, {"code": "int HWCDC::availableForWrite(void){\n\t//  if (!tx_ring_buf || !tx_lock) {\n//    return 0;\n//  }\n//  if (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) != pdTRUE) {\n//    return 0;\n//  }\n//  int free_size = xRingbufferGetCurFreeSize(tx_ring_buf);\n  xSemaphoreGive(tx_lock);\n  return free_size;\n}", "CodeBleu_score": 8.533515676131753}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n// function may be NULL to cancel onReceive() from its respective task\n_onReceiveCB = function;\n// this can be called after Serial.begin(), therefore it shall create the event task\nif (function != NULL && _uart != NULL && _eventTask == NULL) {\n_createEventTask(this);\n}\n// configure receive timeout behavior\nif (onlyOnTimeout) {\n_rxTimeout = 0;\n} else {\n_rxTimeout = 2;\n}\n// set FIFO full threshold to 1/4 of the RX buffer size\nif (_rxBufferSize > 0) {\n_uart->set_rx_full_threshold(_rxBufferSize / 4);\n}\nHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 57.455331406116095}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if !CONFIG_DISABLE_HAL_LOCKS\n  HSERIAL_MUTEX_LOCK();\n#endif\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  // configure the receive timeout behavior\n  _onReceiveTimeout = onlyOnTimeout;\n  _rxTimeout = onlyOnTimeout ? 2 : 0;\n  // set FIFO full threshold\n  if (_uart != NULL) {\n    uart_set_rx_full_threshold(_uart, _rxBufferSize / 2);\n  }\n#if !CONFIG_DISABLE_HAL_LOCKS\n  HSERIAL_MUTEX_UNLOCK();\n#endif\n}", "CodeBleu_score": 56.168324038420735}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if !CONFIG_DISABLE_HAL_LOCKS\n  HSERIAL_MUTEX_LOCK();\n#endif\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  // configure the receive timeout behavior\n  _onReceiveTimeout = onlyOnTimeout;\n  if (_onReceiveTimeout) {\n    _rxTimeout = 0;\n  } else {\n    _rxTimeout = 2;\n  }\n  // set the FIFO full threshold\n  _uart->set_rx_full_threshold(_rxBufferSize / 2);\n#if !CONFIG_DISABLE_HAL_LOCKS\n  HSERIAL_MUTEX_UNLOCK();\n#endif\n}", "CodeBleu_score": 61.375993590052246}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\tint c;\n\tdo {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tcount++;\n\t} while (c != terminator && count < length);\n\treturn count;\n}", "CodeBleu_score": 54.41313931129797}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\tint c;\n\tdo {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tcount++;\n\t} while (c != terminator && count < length);\n\treturn count;\n}", "CodeBleu_score": 54.41313931129797}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\tchar c;\n\twhile (count < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tcount++;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}", "CodeBleu_score": 61.98027935626518}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone was called: pin=%d, frequency=%u Hz, duration=%lu ms\", pin, frequency, duration);\n\tif (tone_init()) {\n\t\ttone_msg_t tone_msg = {\n\t\t\t.tone_cmd = TONE_START,\n\t\t\t.pin = pin,\n\t\t\t.frequency = frequency,\n\t\t\t.duration = duration,\n\t\t};\n\t\txQueueReset(_tone_queue);  // clear queue\n\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 61.15322625420859}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone was called: pin=%d, frequency=%u Hz, duration=%lu ms\", pin, frequency, duration);\n\tif (_pin == -1) {\n\t\tif (ledcAttach(pin, frequency, 10) == 0) {\n\t\t\tlog_e(\"Tone start failed\");\n\t\t\treturn;\n\t\t}\n\t\t_pin = pin;\n\t} else {\n\t\tlog_e(\"Tone is already running on pin %d\", _pin);\n\t\treturn;\n\t}\n\n\ttone_msg_t tone_msg = {\n\t\t.tone_cmd = TONE_START,\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration,\n\t};\n\txQueueReset(_tone_queue);  // clear queue\n\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n}", "CodeBleu_score": 70.49855320082082}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone was called with pin=%d, frequency=%u Hz, duration=%lu ms\", pin, frequency, duration);\n\tif (_pin == -1) {\n\t\tif (ledcAttach(pin, frequency, 10) == 0) {\n\t\t\tlog_e(\"Tone start failed\");\n\t\t\treturn;\n\t\t}\n\t\t_pin = pin;\n\t} else {\n\t\tlog_e(\"Tone is already running on pin %d\", _pin);\n\t\treturn;\n\t}\n\ttone_msg_t tone_msg = {\n\t\t.tone_cmd = TONE_START,\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration,\n\t};\n\txQueueReset(_tone_queue);  // clear queue\n\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n}", "CodeBleu_score": 70.3981138275737}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_started) {\nif (enabled) {\nif (usb_version < 0x0210) {\nusb_version = 0x0210;\n}\nwebusb_enabled = enabled;\n}\n}\nreturn !_started;\n}", "CodeBleu_score": 74.35034768292542}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_started) {\nwebusb_enabled = enabled;\nif (enabled && usb_version < 0x0210) {\nusb_version = 0x0210;\n}\n}\nreturn !_started;\n}", "CodeBleu_score": 94.00400768860221}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_started) {\nif (enabled) {\nusb_version = 0x0210;\nwebusb_enabled = true;\n} else {\nwebusb_enabled = false;\n}\n} else {\nif (enabled) {\nif (usb_version < 0x0210) {\nreturn false;\n}\nwebusb_enabled = true;\ntinyusb_enable_interface(USB_INTERFACE_VENDOR, TUD_VENDOR_DESC_LEN, load_vendor_descriptor);\n} else {\nwebusb_enabled = false;\ntinyusb_disable_interface(USB_INTERFACE_VENDOR);\n}\n}\nreturn _started;\n}", "CodeBleu_score": 52.47403922619327}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tif (connected) {\n\t\tuint8_t ch = 0;\n\t\tif (xQueueReceive(rx_queue, &ch, 0)) {\n\t\t\tif (xQueueSend(rx_queue, &ch, 0)) {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx.data_length = 1;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t} else {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = 1;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.8404081186782}, {"code": "void USBCDC::_onRX(){\n\t\tBaseType_t woken = 0;\n\tuint8_t ch;\n\tsize_t rx_queue_len = 0;\n\n\tif (connected) {\n\t\twhile (cdc_rx_available()) {\n\t\t\tif (xQueueReceiveFromISR(rx_queue, &ch, &woken) == pdTRUE) {\n\t\t\t\trx_queue_len++;\n\t\t\t} else {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = rx_queue_len;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (woken) {\n\t\t\tportYIELD_FROM_ISR();\n\t\t}\n\t}\n\tif (rx_queue_len) {\n\t\tarduino_usb_cdc_event_data_t p;\n\t\tp.rx.size = rx_queue_len;\n\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 51.24586153656868}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t ch;\n\tsize_t queue_size = 0;\n\tif (rx_queue) {\n\t\tqueue_size = uxQueueSpacesAvailable(rx_queue);\n\t}\n\tif (queue_size) {\n\t\twhile (cdc_rx.available()) {\n\t\t\tch = cdc_rx.read();\n\t\t\tif (!xQueueSend(rx_queue, &ch, 0)) {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = queue_size;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tarduino_usb_cdc_event_data_t p;\n\t\tp.rx.bytes = queue_size;\n\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 53.60249605213038}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\\\":robot\\\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\\\"devices\\\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 29.32593801262563}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t", "CodeBleu_score": 3.5362673365206354}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t", "CodeBleu_score": 3.5362673365206354}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\\\":robot\\\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\\\"connections\\\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": \\\"No Robot found with the name \\\" + req.URL.Query().Get(\\\":robot\\\")}, res)\n\t}\n}", "CodeBleu_score": 76.14216265518337}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\\\":robot\\\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\\\"connections\\\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": \\\"No Robot found with the name \\\" + req.URL.Query().Get(\\\":robot\\\")}, res)\n\t}\n}", "CodeBleu_score": 76.14216265518337}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\\\":robot\\\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\\\"connections\\\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": \\\"No Robot found with the name \\\" + req.URL.Query().Get(\\\":robot\\\")}, res)\n\t}\n}", "CodeBleu_score": 76.14216265518337}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif device, err := a.jsonDeviceFor(req.URL.Query().Get(\\\":robot\\\"), req.URL.Query().Get(\\\":device\\\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": err.Error()}, res)\n\t} else {\n\t\ta.executeCommand(device.Command(req.URL.Query().Get(\\\":command\\\")),\n\t\t\tres,\n\t\t\treq,\n\t\t)\n\t}\n}", "CodeBleu_score": 54.14267442094314}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif device, err := a.jsonDeviceFor(req.URL.Query().Get(\\\":robot\\\"), req.URL.Query().Get(\\\":device\\\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": err.Error()}, res)\n\t} else {\n\t\ta.executeCommand(device.Command(req.URL.Query().Get(\\\":command\\\")), res, req)\n\t}\n}", "CodeBleu_score": 47.60678253530446}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif device, err := a.jsonDeviceFor(req.URL.Query().Get(\\\":robot\\\"), req.URL.Query().Get(\\\":device\\\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": err.Error()}, res)\n\t} else {\n\t\ta.executeCommand(device.Command(req.URL.Query().Get(\\\":command\\\")), res, req)\n\t}\n}", "CodeBleu_score": 47.60678253530446}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.analogRead == nil {\n\t\treturn 0, 0, ErrUnsupported\n\t}\n\n\trawValue, err := a.analogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaledValue := a.sensorCfg.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 51.46126013406365}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.analogRead == nil {\n\t\treturn 0, 0.0, errors.New(\\\"analogRead function not initialized\\\")\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tif rawValue != a.lastRawValue {\n\t\ta.lastRawValue = rawValue\n\t\ta.Publish(a.Event(Data), rawValue)\n\t}\n\n\tif value != a.lastValue {\n\t\ta.lastValue = value\n\t\ta.Publish(a.Event(Value), value)\n\t}\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 47.38967699670752}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// check if the sensor supports analog reading\n\tif a.AnalogReader == nil || !a.AnalogReader.Analog() {\n\t\treturn -1, -1, ErrAnalogReadingNotSupported\n\t}\n\n\t// read the raw value from the sensor\n\trawValue, err := a.AnalogReader.Read()\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\t// scale the raw value according to the sensor's configuration\n\tscaledValue := a.sensorCfg.scale(rawValue)\n\n\t// update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 47.69207551229531}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.87558306279749}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.87558306279749}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.87558306279749}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, commandRegSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegSoftResetBit == 0 {\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"soft reset failed\")\n}", "CodeBleu_score": 79.61972773299371}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, commandRegSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegSoftReset == 0 {\n\t\treturn nil\n\t}\n\treturn errors.New(\"soft reset failed\")\n}", "CodeBleu_score": 79.44650356479256}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, commandRegPCDReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegPCDReset == 0 {\n\t\treturn nil\n\t}\n\treturn ErrTimeout\n}", "CodeBleu_score": 76.32601797903317}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// The last bits received must be cleared before reading the FIFO.\n\tif err := d.clearRegisterBitMask(regBitFraming, bitFramingRegRxLastBits); err != nil {\n\t\treturn 0, err\n\t}\n\t// The FIFO buffer may contain data from the previous transceive operation.\n\t// Clear the FIFO buffer before reading.\n\tif err := d.writeByteData(regFIFOLevel, fifoLevelRegFlushBufferBit); err != nil {\n\t\treturn 0, err\n\t}\n\t// The FIFO buffer may contain data from the previous transceive operation.\n\t// Wait until the FIFO buffer is empty.\n\tconst maxTries = 3\n\tfor i := 0; i < maxTries; i++ {\n\t\tfifoLevel, err := d.readByteData(regFIFOLevel)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif fifoLevel&fifoLevelRegRxLevelBits == 0 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tif i >= maxTries {\n\t\treturn 0, fmt.Errorf(\"no data available after %d tries\", maxTries)\n\t}\n\t// Read the data from FIFO.\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the last bits received.\n\trxLastBits, err := d.readByteData(regBitFraming)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 51.52595946658265}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// the register command is always the same, the pointer in FIFO is incremented automatically after each write\n\t// read the number of bytes available in the FIFO\n\tfifoLevel, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// check the number of bytes available in the FIFO\n\tif int(fifoLevel) != len(backData) {\n\t\treturn 0, fmt.Errorf(\\\"length of backData does not match the number of bytes available in the FIFO\\\")\n\t}\n\t// read each byte from the FIFO into the byte slice\n\tfor i := 0; i < int(fifoLevel); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// read the control register to get the last bits received\n\trxLastBits, err := d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 55.68747078474785}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t", "CodeBleu_score": 2.4614450729887336}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\tcmd := []byte{piccCommandHALT}\n\tcmd = append(cmd, crc24q(cmd))\n\tif err := d.piccTransceive(cmd); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.84696683810551}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\tcommand := []byte{piccCommandHALT}\n\tcrc := crc24(command)\n\tcommand = append(command, crc[0], crc[1], crc[2])\n\terr := d.piccTransceive(command, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.91690004910077}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"halt\\\")\n\t}\n\n\t// Build command\n\tcommand := []byte{piccCommandHALT}\n\tcrc := crc24(command)\n\tcommand = append(command, crc[0])\n\tcommand = append(command, crc[1])\n\tcommand = append(command, crc[2])\n\n\t// Send the command\n\tif err := d.piccTransceive(command); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 33.457255544052046}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"-read-\\\")\n\t}\n\t// The read command consists of a command header of 7 bits followed by the block number.\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn []byte{}, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 17)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err != nil {\n\t\treturn []byte{}, err\n\t}\n\tif backData[0]&piccReadAck != piccReadAck {\n\t\treturn []byte{}, fmt.Errorf(\\\"preparation of read on MIFARE classic failed (%v)\\\", backData)\n\t}\n\tif piccDebug {\n\t\tfmt.Println(\\\"backData\\\", backData)\n\t}\n\n\treturn backData[1:], nil\n}", "CodeBleu_score": 67.30460768846885}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t", "CodeBleu_score": 3.9226551888190304}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\t// The block address must be between 0 and 63.\n\tif block < 0 || block > 63 {\n\t\treturn nil, fmt.Errorf(\"block address needs to be between 0 and 63, but is %d\", block)\n\t}\n\n\t// Build the command for block address block.\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\n\t// Calculate CRC for the command.\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Append CRC to the command.\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\t// Transceive the command.\n\ttxLastBits := uint8(0x00) // We want to send 16 bits.\n\tbackData := make([]byte, 17)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The first byte is the error code (0x00 = success).\n\tif backData[0] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"read failed: %v\", backData)\n\t}\n\n\t// The next 16 bytes are the data.\n\treturn backData[1:], nil\n}", "CodeBleu_score": 76.2137942611796}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\\\"answer buffer too small\\\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\n\ttxLastBits := uint8(0x00)\n\tif reqMode == piccReqIDL {\n\t\t// no bit adjustments\n\t} else if reqMode == piccReqALL {\n\t\t// no bit adjustments\n\t} else if reqMode == piccReqSEL {\n\t\t// no bit adjustments\n\t} else if reqMode == piccReqCL1 {\n\t\t// set bit 8, bit adjustments for cascade level 1\n\t\ttxLastBits = uint8(0x08)\n\t} else if reqMode == piccReqCL2 {\n\t\t// set bit 8, bit adjustments for cascade level 2\n\t\ttxLastBits = uint8(0x08)\n\t} else if reqMode == piccReqCL3 {\n\t\t// set bit 8, bit adjustments for cascade level 3\n\t\ttxLastBits = uint8(0x08)\n\t} else {\n\t\treturn fmt.Errorf(\\\"unknown request mode %d\\\", reqMode)\n\t}\n\n\tif err := d.communicateWithPICC(commandRegTransceive, []byte{piccCommandMFRegReqIDL}, answer, txLastBits, false); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.99069465546064}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\ttxLastBits := uint8(0x00)\n\tif reqMode == piccReqIDL {\n\t\ttxLastBits = uint8(0x07)\n\t}\n\tif err := d.communicateWithPICC(commandRegTransceive, []byte{piccCommandMFRegREQA, reqMode}, answer, txLastBits, false); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.92118626352162}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.disabled {\n\t\treturn fmt.Errorf(\\\"'%s' is disabled, can not move\\\", d.driverCfg.name)\n\t}\n\n\tif d.sleeping {\n\t\treturn fmt.Errorf(\\\"'%s' is sleeping, can not move\\\", d.driverCfg.name)\n\t}\n\n\tif d.stepperDebug {\n\t\tfmt.Printf(\\\"%s: step %d\\\n\\\", d.driverCfg.name, d.stepNum)\n\t}\n\n\t// stepPin is active low\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// wait for stepper motor to move\n\ttime.Sleep(d.stepDelay)\n\n\t// stepPin is active low\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\t// increment/decrement step number depending on direction\n\tif d.direction == StepperDriverForward {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 71.12350420508191}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.disabled {\n\t\treturn ErrDeviceDisabled\n\t}\n\n\tif d.sleeping {\n\t\treturn ErrDeviceSleeping\n\t}\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// delay is the time between steps.\n\tdelay := time.Duration(d.stepsPerRev/d.speedRpm) * time.Second / 4\n\n\t// we need to wait 1ms after sleeping before doing a step to charge the step pump (according to data sheet)\n\ttime.Sleep(1 * time.Millisecond)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\ttime.Sleep(delay)\n\n\treturn nil\n}", "CodeBleu_score": 74.35934754754156}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// ensure that write of variable can not interfere with read in step()\n\tif d.direction == StepperDriverForward {\n\t\td.stepCount++\n\t} else {\n\t\td.stepCount--\n\t}\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.01044069175771}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitoring is already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = new(sync.WaitGroup)\n\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\\tcase <-d.distanceMonitorStopChan:\n\\t\\treturn\n\\tdefault:\n\\t}\n\n\\t\\t// measure distance\n\\t\\terr := d.measureDistance()\n\\t\\tif err != nil {\n\\t\\t\\tfmt.Printf(\\\"error on distance measurement: %v\\\n\\\", err)\n\\t\\t}\n\\t\\tselect {\n\\t\\tcase <-d.distanceMonitorStopChan:\n\\t\\t\\treturn\n\\t\\tcase d.delayMicroSecChan <- d.lastMeasureMicroSec:\n\\t\\t\\t// do nothing\n\\t\\t}\n\\t}\n}()\n\nreturn nil\n}", "CodeBleu_score": 52.45680039583051}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn errors.New(\\\"distance monitor is already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\n\tgo d.measureDistanceContinuously()\n\n\treturn nil\n}", "CodeBleu_score": 35.02133293856446}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitoring already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitorWorker()\n\n\treturn nil\n}", "CodeBleu_score": 38.821872935195685}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(fd int, level gpiod.LineLevel, ts time.Duration, eventID uint32, eventVal uint32) {\n\t\td.measureMutex.Lock()\n\t\tdefer d.measureMutex.Unlock()\n\n\t\tif level == gpiod.LineLevelLow {\n\t\t\td.lastMeasureMicroSec = int64(ts)\n\t\t} else if level == gpiod.LineLevelHigh {\n\t\t\td.delayMicroSecChan <- int64(ts) - d.lastMeasureMicroSec\n\t\t\td.lastMeasureMicroSec = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 38.507593699741626}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(fd int, ts time.Duration, edge string, val uint32, eventID uint32) {\n\t\t// note: the event handler is called from a different goroutine\n\t\t// and must not access any variables from the driver struct\n\t\t// (like d.lastMeasureMicroSec)\n\t\t//\n\t\t// instead, use a channel to return the result\n\t\t//\n\t\t// see https://github.com/hybridgroup/gobot/issues/731\n\t\tselect {\n\t\tcase d.delayMicroSecChan <- int64(ts.Microseconds()):\n\t\tdefault:\n\t\t\tfmt.Printf(\\\"hcsr04: channel for event handler return value is full, drop event: %s %d %d\n\\\", edge, val, eventID)\n\t\t}\n\t}\n}", "CodeBleu_score": 41.15173634610173}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, level time.Duration, name string, eventID uint32, eventFlags uint32) {\n\t\tif level == time.Duration(0) {\n\t\t\t// rising edge\n\t\t\td.measureMutex.Lock()\n\t\t\td.lastMeasureMicroSec = time.Now().UnixNano() / 1000\n\t\t\td.measureMutex.Unlock()\n\t\t} else {\n\t\t\t// falling edge\n\t\t\td.measureMutex.Lock()\n\t\t\td.lastMeasureMicroSec = time.Now().UnixNano() / 1000\n\t\t\td.measureMutex.Unlock()\n\t\t\tduration := d.lastMeasureMicroSec - d.lastMeasureMicroSec\n\t\t\td.delayMicroSecChan <- duration\n\t\t\td.measureMutex.Lock()\n\t\t\td.lastMeasureMicroSec = 0\n\t\t\td.measureMutex.Unlock()\n\t\t}\n\t}\n}", "CodeBleu_score": 37.00205469654921}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t", "CodeBleu_score": 1.8836688096722443}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\td.triggerPin.Write(1)\n\ttime.Sleep(hcsr04TriggerPulseDuration)\n\td.triggerPin.Write(0)\n\n\t// wait for the measurement to complete\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\\\"timeout reached while waiting for the measurement to complete\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.61820064936799}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\tif err := d.triggerPin.Write(1); err != nil {\n\t\treturn fmt.Errorf(\\\"error on trigger: %v\\\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerHoldDuration)\n\tif err := d.triggerPin.Write(0); err != nil {\n\t\treturn fmt.Errorf(\\\"error on trigger: %v\\\", err)\n\t}\n\n\t// wait for echo pin to go high\n\tvar timeout time.Duration\n\tif d.hcsr04Cfg.timeoutDuration > 0 {\n\t\ttimeout = d.hcsr04Cfg.timeoutDuration\n\t}\n\tif d.hcsr04Cfg.useEdgePolling {\n\t\ttimeout = hcsr04PollInputIntervall\n\t}\n\tif err := d.echoPin.WaitForEdge(timeout, d.createEventHandler()); err != nil {\n\t\treturn fmt.Errorf(\\\"error on echo pin wait for edge: %v\\\", err)\n\t}\n\n\t// wait for echo pin to go low again\n\tif err := d.echoPin.WaitForEdge(timeout, d.createEventHandler()); err != nil {\n\t\treturn fmt.Errorf(\\\"error on echo pin wait for edge: %v\\\", err)\n\t}\n\n\t// calculate the time difference between trigger and echo pin\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\tdefault:\n\t\treturn fmt.Errorf(\\\"no echo pin event received\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.56506242311631}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token:\n        return self.auth_token\n    if self.auth_token_expire:\n        if time.time() < self.auth_token_expire:\n            return self.auth_token\n    if self.refresh_token:\n        try:\n            data = self.fetch_json_data(\n                \\\"/v3/oauth/token\\\",\n                method=\\\"POST\\\",\n                data={\n                    \\\"grant_type\\\": \\\"refresh_token\\\",\n                    \\\"refresh_token\\\": self.refresh_token,\n                },\n            )\n            self.auth_token = data.get(\\\"access_token\\\")\n            self.auth_token_expire = time.time() + data.get(\\\"expires_in\\\")\n            self.save_authentication_data()\n            return self.auth_token\n        except AccountError:\n            pass\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 38.973505099266134}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\\\"PLATFORMIO_AUTH_TOKEN\\\"]\n    except KeyError as exc:\n        pass\n    try:\n        auth = app.get_state_item(\\\"account\\\").get(\\\"auth\\\")\n        if auth.get(\\\"access_token\\\") and auth.get(\\\"expires_at\\\") > int(time.time()):\n            return auth.get(\\\"access_token\\\")\n    except Exception as exc:  # pylint:disable=broad-except\n        raise AccountNotAuthorized() from exc\n    try:\n        refresh_token = self.get_refresh_token()\n        if not refresh_token:\n            raise AccountNotAuthorized()\n        data = self.fetch_json_data(\\\"/v3/auth/token\\\", method=\\\"POST\\\", data={\\\"grant_type\\\": \\\"refresh_token\\\", \\\"refresh_token\\\": refresh_token})\n        app.set_state_item(\\\"account\\\", {\\\"auth\\\": data})\n        return data.get(\\\"access_token\\\")\n    except AccountNotAuthorized:\n        raise\n    except Exception as exc:  # pylint:disable=broad-except\n        raise AccountError(exc) from exc\n\n", "CodeBleu_score": 38.087321678025596}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\"PLATFORMIO_AUTH_TOKEN\"]\n    except KeyError:\n        pass\n    try:\n        account = app.get_state_item(\"account\")\n        if not account:\n            raise AccountNotAuthorized()\n        if not account.get(\"auth\"):\n            raise AccountNotAuthorized()\n        if not account.get(\"auth\").get(\"access_token\"):\n            raise AccountNotAuthorized()\n        if not account.get(\"auth\").get(\"expires_in\"):\n            raise AccountNotAuthorized()\n        if account.get(\"auth\").get(\"expires_in\") > time.time():\n            return account.get(\"auth\").get(\"access_token\")\n        if not account.get(\"auth\").get(\"refresh_token\"):\n            raise AccountNotAuthorized()\n        data = {\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": account.get(\"auth\").get(\"refresh_token\"),\n        }\n        try:\n            result = self.fetch_json_data(\"/v1/oauth/token\", data=data)\n        except HTTPClientError as exc:\n            raise AccountNotAuthorized() from exc\n        if not result.get(\"access_token\"):\n            raise AccountNotAuthorized()\n        if not result.get(\"expires_in\"):\n            raise AccountNotAuthorized()\n        account[\"auth\"][\"access_token\"] = result.get(\"access_token\")\n        account[\"auth\"][\"expires_in\"] = time.time() + result.get(\"expires_in\")\n        app.set_state_item(\"account\", account)\n        return result.get(\"access_token\")\n    except AccountNotAuthorized:\n        raise\n    except Exception as exc:\n        raise AccountError(exc) from exc\n\n", "CodeBleu_score": 41.016824394300535}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n    except AccountError:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 67.91479516642136}, {"code": "def logout(self)\n\t\n    # pylint:disable=too-many-branches\n    try:\n        refresh_token = self.get_refresh_token()\n    except:  # pylint:disable=bare-except\n        pass\n    else:\n        try:\n            self.fetch_json_data(\n                \"post\",\n                \"/v1/logout\",\n                headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n            )\n        except AccountError:\n            pass\n    self.delete_local_session()\n    return True\n", "CodeBleu_score": 55.942416700638944}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n    except AccountNotAuthorized:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\"post\", \"/v1/logout\", headers={\"Authorization\": \"Bearer %s\" % refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 59.84329292479016}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        version = options.get(\"version\")\n        if not version:\n            continue\n        pkg = self.get_package(name, self.get_package_spec(name, version))\n        if not pkg:\n            continue\n        result.append(\n            {\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"external\": pkg.metadata.spec.external,\n            }\n        )\n        if pkg.metadata.spec.external:\n            result[-1][\"url\"] = pkg.metadata.spec.url\n    return result\n\n", "CodeBleu_score": 49.61282382796909}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for name, options in sorted(self.packages.items()):\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg:\n            continue\n        packages.append(\n            {\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"external\": pkg.metadata.spec.external,\n            }\n        )\n        if pkg.metadata.spec.external:\n            packages[-1][\"url\"] = pkg.metadata.spec.url\n    return packages\n\n", "CodeBleu_score": 48.55386826511715}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg:\n            continue\n        result.append(\n            {\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"external\": pkg.metadata.spec.external,\n            }\n        )\n        if pkg.metadata.spec.external:\n            result[-1][\"url\"] = pkg.metadata.spec.url\n    return result\n\n", "CodeBleu_score": 55.31941790302265}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    # pylint: disable=import-outside-toplevel\n    from platformio.package.manager.platform import PlatformPackageManager\n\n    project_config = ProjectConfig.get_instance()\n    platform_name = project_config.get(\n        [\"env:\" + env, \"platform\"], os.environ.get(\"PLATFORMIO_DEFAULT_PLATFORM\", None)\n    )\n    if not platform_name:\n        raise UndefinedEnvPlatformError(env)\n    platform_dir = PlatformPackageManager().get_package(platform_name).path\n    platform_cls = None\n    if os.path.isfile(os.path.join(platform_dir, \"platform.py\")):\n        platform_cls = getattr(\n            load_python_module(\"platformio.platform.%s\" % platform_name, os.path.join(platform_dir, \"platform.py\")),\n            cls.get_clsname(platform_name),\n        )\n    else:\n        platform_cls = type(str(cls.get_clsname(platform_name)), (base.PlatformBase,), {})\n    _instance = platform_cls(os.path.join(platform_dir, \"platform.json\"))\n    assert isinstance(_instance, base.PlatformBase)\n    _instance.configure_project_packages(project_config, env, targets)\n    return _instance\n\n", "CodeBleu_score": 36.73511806057776}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    # pylint: disable=import-outside-toplevel\n    from platformio.package.manager.platform import PlatformPackageManager\n\n    if not env:\n        raise UndefinedEnvPlatformError(env)\n    config = ProjectConfig.get_instance()\n    if not config.has_section(env):\n        raise UndefinedEnvPlatformError(env)\n    if not config.has_option(env, \"platform\"):\n        raise UndefinedEnvPlatformError(env)\n    spec = config.get(env, \"platform\")\n    platform = PlatformFactory.new(spec, autoinstall=autoinstall)\n    platform.configure_project_packages(env, targets)\n    platform.set_project_config(config)\n    return platform\n", "CodeBleu_score": 47.63882967259108}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env or not env.name:\n        raise UndefinedEnvPlatformError()\n    if not env.project_config.has_section(env.name):\n        raise UndefinedEnvPlatformError(env.name)\n    if not targets:\n        targets = env.get_targets()\n    platform_spec = env.project_config.get(env.name, \"platform\")\n    platform = PlatformFactory.new(platform_spec, autoinstall)\n    platform.configure_project_packages(env, targets)\n    return platform\n\n", "CodeBleu_score": 41.74967205902092}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\t// enable timer\n\t\tuint8_t buf = Read8bit(0x31);\n\t\tbuf         = (1 << 7) | buf;\n\t\tWrite1Byte(0x31, buf);\n\t\t// set timer\n\t\tuint32_t timer = time_in_us / 1000000;\n\t\tWrite32bit(0x32, timer);\n\t} else {\n\t\t// disable timer\n\t\tuint8_t buf = Read8bit(0x31);\n\t\tbuf         = (~(1 << 7)) & buf;\n\t\tWrite1Byte(0x31, buf);\n\t}\n\t// enter sleep\n\tWrite1Byte(0x12, Read8bit(0x12) | 0x80);\n\t// delay for at least 100us\n\tdelayMicroseconds(100);\n\t// enter sleep\n\tWrite1Byte(0x12, Read8bit(0x12) | 0x80);\n\t// deep sleep\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 40.75598887670967}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tWrite1Byte(0x96, 0x01);  // Enable timer wakeup source\n\t\tWrite4Byte(0x94, time_in_us);\n\t} else {\n\t\tWrite1Byte(0x96, 0x00);  // Disable timer wakeup source\n\t}\n\tWrite1Byte(0x12, Read8bit(0x12) | 0x20);  // Enable poweroff bit\n\tWrite1Byte(0x12, Read8bit(0x12) & 0xDF);  // Disable all outputs but DCDC1\n\tdelay(10);\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 41.66538291330245}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t//  Serial.println(F(\\\"scroll_line()\\\"));\n  int yReturn = yDraw;\n  tft.fillRect(0, yDraw, TFT_WIDTH, TEXT_HEIGHT, color);\n  yDraw += TEXT_HEIGHT;\n  if (yDraw > yArea) {\n    yDraw = TOP_FIXED_AREA;\n  }\n  return yReturn;\n}", "CodeBleu_score": 16.379472391592127}, {"code": "int Display::scroll_line(uint32_t color){\n\t\n#ifdef SCREEN_BUFFER\n  if (this->screen_buffer->size() >= MAX_SCREEN_BUFFER)\n    this->scrollScreenBuffer();\n\n  this->screen_buffer->add(display_buffer->shift());\n#endif\n\n  if (!printing) {\n    tft.fillRect(0, yStart, TFT_WIDTH, TEXT_HEIGHT, color);\n  }\n\n  yStart += TEXT_HEIGHT;\n  if (yStart > (yArea + yStart - yArea)) {\n    yStart = TOP_FIXED_AREA;\n  }\n\n  return yStart;\n}", "CodeBleu_score": 22.784142483742247}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef DEBUG_SCROLL\n  Serial.println(F(\\\"scroll_line()\\\"));\n#endif\n\n  // Store the current starting y-coordinate\n  int y = yStart;\n\n  // Fill a rectangle at the current starting y-coordinate with the specified color\n  tft.fillRect(0, y, TFT_WIDTH, TEXT_HEIGHT, color);\n\n  // Increment the y-coordinate by the height of a text line\n  y += TEXT_HEIGHT;\n\n  // Wrap around if it exceeds the display boundaries minus the bottom fixed area\n  if (y > yArea + BOT_FIXED_AREA) {\n    y = TOP_FIXED_AREA;\n  }\n\n  // Update the scroll address\n  yStart = y;\n\n  // Return the previous y-coordinate\n  return y;\n}", "CodeBleu_score": 16.65502001301411}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->ssids = ssids;\n\tthis->access_points = access_points;\n\n\tif (this->setupAccessPoints()) {\n\t\tif (this->setupHtmlContent()) {\n\t\t\tthis->runServer = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 52.675594127660176}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t#ifdef DEBUG\n  Serial.println(\\\"Starting Evil Portal\\\");\n#endif\n  this->runServer = true;\n  this->access_points = access_points;\n  this->ssids = ssids;\n\n  if (!this->setupAccessPoints()) {\n    this->runServer = false;\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    this->runServer = false;\n    return false;\n  }\n\n  this->portal_thread.onRun(std::bind(&EvilPortal::portalThread, this));\n  this->portal_thread.start(THREAD_PRIORITY_NORMAL);\n\n  return true;\n}", "CodeBleu_score": 51.490190151686335}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t#ifdef HAS_AP\n  if (!this->setupAccessPoints(ssids, access_points)) {\n    return false;\n  }\n#endif\n\n  #ifdef HAS_SD\n    if (sd_obj.supported) {\n      this->setupSD();\n    }\n  #endif\n\n  this->setupServer();\n\n  return true;\n}", "CodeBleu_score": 58.11363927627079}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif(this->queue_enabled_flag){\n\t\tif(!this->queue) this->new_queue();\n\t\tif(!this->text) this->new_text();\n\t\tif(!this->text_in) this->new_text_in();\n\t}\n\telse\n\t\tthis->flush_queue();\n\n\tthis->queue_enabled_flag=true;\n}", "CodeBleu_score": 34.129399909120885}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (!this->queue)\n\t\t\tthis->new_queue();\n\t\tif (!this->text)\n\t\t\tthis->text = new LinkedList<String>();\n\t\tif (!this->text_in)\n\t\t\tthis->text_in = new LinkedList<String>();\n\t}\n\telse\n\t\tthis->flush_queue();\n\tthis->queue_enabled_flag = true;\n}", "CodeBleu_score": 34.93696464365369}, {"code": "void GpsInterface::enable_queue(){\n\t\tif(this->queue_enabled_flag) {\n\t\tif(!this->queue)\n\t\t\tthis->new_queue();\n\n\t\tif(!this->text)\n\t\t\tthis->text=new LinkedList<String>;\n\n\t\tif(!this->text_in)\n\t\t\tthis->text_in=new LinkedList<String>;\n\t}\n\telse {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag=true;\n\t}\n}", "CodeBleu_score": 58.26279957843576}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue) {\n\t\t\t#ifdef GPS_NMEA_MAXQUEUE\n\t\t\tif (this->queue->size() >= GPS_NMEA_MAXQUEUE)\n\t\t\t#else\n\t\t\tif (this->queue->size() >= 30)\n\t\t\t#endif\n\t\t\t\tthis->flush_queue();\n\t\t} else\n\t\t\tthis->new_queue();\n\t}\n}", "CodeBleu_score": 53.3368736112357}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif(this->queue){\n\t\tif(this->queue->size()){\n\t\t\tLinkedList<nmea_sentence_t> *delme=this->queue;\n\t\t\tthis->queue=new LinkedList<nmea_sentence_t>;\n\t\t\tdelete delme;\n\t\t}\n\t\telse{\n\t\t\tdelete this->queue;\n\t\t\tthis->queue=0;\n\t\t}\n\t}\n\telse\n\t\tthis->queue=new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 64.96806808759695}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif(this->queue_enabled_flag){\n\t\tif(this->queue){\n\t\t\t#ifdef GPS_NMEA_MAXQUEUE\n\t\t\t\tif(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n\t\t\t#else\n\t\t\t\tif(this->queue->size()>=30)\n\t\t\t#endif\n\t\t\t\t{\n\t\t\t\t\tLinkedList<nmea_sentence_t> *delme=this->queue;\n\t\t\t\t\tthis->queue=new LinkedList<nmea_sentence_t>;\n\t\t\t\t\tdelete delme;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tthis->new_queue();\n\t}\n\telse\n\t\tthis->flush_queue();\n}", "CodeBleu_score": 67.19319911673225}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t#ifdef HAS_ILI9341\n    uint16_t x = area->x1;\n    uint16_t y = area->y1;\n    uint16_t w = lv_area_get_width(area);\n    uint16_t h = lv_area_get_height(area);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(x, y, w, h);\n    for (uint16_t j = 0; j < h; j++) {\n      for (uint16_t i = 0; i < w; i++) {\n        uint16_t color = color_p->full;\n        display_obj.tft.writePixel(color);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n#endif\n  }", "CodeBleu_score": 47.91757419342916}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t#ifdef HAS_ILI9341\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n    for (int32_t y = area->y1; y <= area->y2; y++) {\n      for (int32_t x = area->x1; x <= area->x2; x++) {\n        lv_color_t color = color_p[x - area->x1 + (y - area->y1) * area->x2];\n        display_obj.tft.writePixel(x, y, color.full);\n      }\n    }\n    display_obj.tft.endWrite();\n#endif\n  }", "CodeBleu_score": 58.212006672808926}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t", "CodeBleu_score": 3.1791339452368352}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tMenuNode * node = menu->list;\n\tint indent = layer * 2;\n\tint i = 0;\n\n\twhile (node != NULL) {\n\t\tif (node->isMenu()) {\n\t\t\tSerial.print(F(\"  \"));\n\t\t\tSerial.print(node->getName());\n\t\t\tSerial.println(F(\" (Menu)\"));\n\t\t} else {\n\t\t\tSerial.print(F(\"  \"));\n\t\t\tSerial.print(node->getName());\n\t\t\tSerial.println(F(\"\"));\n\t\t}\n\t\tnode = node->next;\n\t}\n\tSerial.println(F(\"\"));\n}", "CodeBleu_score": 44.66277221449935}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tint i = 0;\n\tfor (MenuNode * node = menu->list; node; node = node->next, i++) {\n\t\tif (node->is_submenu) {\n\t\t\tSerial.print(F(\"    \"));\n\t\t\tSerial.print(node->name);\n\t\t\tSerial.println(F(\" ->\"));\n\t\t\tshowMenuList(node->submenu, layer + 1);\n\t\t} else {\n\t\t\tSerial.print(F(\"    \"));\n\t\t\tSerial.print(node->name);\n\t\t\tSerial.println(\"\");\n\t\t}\n\t}\n}", "CodeBleu_score": 40.82793503029397}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num_generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tint channel = random(1, 12);\n\t\tbyte mac[6];\n\t\tmac[0] = random(256);\n\t\tmac[1] = random(256);\n\t\tmac[2] = random(256);\n\t\tmac[3] = random(256);\n\t\tmac[4] = random(256);\n\t\tmac[5] = random(256);\n\t\tString essid = \\\"\\\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tessid += (char)('A' + random(26));\n\t\t}\n\t\tssid s = {essid, channel, mac, false};\n\t\tssids->add(s);\n\t\tSerial.println(ssids->get(ssids->size() - 1).essid);\n\t\tnum_generated++;\n\t}\n\treturn num_generated;\n}", "CodeBleu_score": 59.0639635955329}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint num_generated = 0;\n\nSerial.println(\\\"Generating SSIDs...\\\");\n\nfor (int i = 0; i < count; i++) {\nchar essid[7]; // 6 characters + null terminator\n\nfor (int j = 0; j < 6; j++) {\nessid[j] = (char)(random(97, 123)); // 97 is the ASCII value of \\\"a\\\" and 123 is the ASCII value of \\\"z\\\"\n}\nessid[6] = 0; // null terminator\n\nif (addSSID(String(essid)))\nnum_generated++;\n}\n\nSerial.println(\\\"Generated SSIDs: \\\" + (String)num_generated);\n\nreturn num_generated;\n}", "CodeBleu_score": 33.872977394331976}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tString essid = \\\"\\\";\n\t\tfor (int j = 0; j < 6; j++)\n\t\t\tessid.concat(random(97, 123));\n\t\taddSSID(essid);\n\n\t}\n\treturn i;\n\n}", "CodeBleu_score": 24.508731219024593}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(\"Created topic: {}\".format(topic))\n\n", "CodeBleu_score": 52.382854777896114}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Created topic: {topic}\")\n\n", "CodeBleu_score": 47.30410687693764}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(\"Created topic: {}\".format(topic))\n\n", "CodeBleu_score": 52.382854777896114}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 75.24423914554694}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        \"iat\": datetime.datetime.utcnow(),\n        # The time the token expires.\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)", "CodeBleu_score": 70.8670332375393}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        \"iat\": datetime.datetime.utcnow(),\n        # The time the token expires.\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 70.8670332375393}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, message.topic, str(message.qos)))\n    # If the message is \"on\", capture a preview image and publish the URL to an event topic.\n    if payload == 'on':\n        # Capture a preview image.\n        camera.start_preview()\n        time.sleep(5)\n        camera.capture('/home/pi/Desktop/image.jpg')\n        camera.stop_preview()\n        # Upload the image to a specified bucket.\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket('your-bucket-name')\n        blob = bucket.blob('image.jpg')\n        blob.upload_from_filename('/home/pi/Desktop/image.jpg')\n        # Publish the image's URL to an MQTT event topic.\n        url = 'https://storage.googleapis.com/your-bucket-name/image.jpg'\n        publish_messages(project_id, topic_name, url)\n    # If the message is not \"on\", print \"off\".\n    else:\n        print('off')\n\n", "CodeBleu_score": 50.654130213192595}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload\n    qos = message.qos\n    topic = message.topic\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, topic, qos))\n    if str(payload) == \"on\":\n        print(\"on\")\n        # Capture a preview image from the camera and upload it to a specified bucket.\n        camera = picamera.PiCamera()\n        camera.resolution = (640, 480)\n        camera.start_preview()\n        time.sleep(5)\n        camera.capture('/home/pi/Desktop/image.jpg')\n        camera.stop_preview()\n        camera.close()\n        # Upload the image to the bucket.\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket('bucket-name')\n        blob = bucket.blob('image.jpg')\n        blob.upload_from_filename('/home/pi/Desktop/image.jpg')\n        # Publish the image's URL to an MQTT event topic.\n        url = \"https://storage.googleapis.com/bucket-name/image.jpg\"\n        publish_messages(project_id, topic_name, url)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 48.967903262477016}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, message.topic, str(message.qos)))\n    if str(payload) == 'on':\n        print('on')\n        # Capture a preview image\n        camera.start_preview()\n        time.sleep(5)\n        camera.capture('/home/pi/Desktop/image.jpg')\n        camera.stop_preview()\n        # Upload the image to a bucket\n        bucket = storage_client.get_bucket(BUCKET_NAME)\n        blob = bucket.blob('image.jpg')\n        blob.upload_from_filename('/home/pi/Desktop/image.jpg')\n        # Publish the image URL to an MQTT topic\n        url = 'https://storage.googleapis.com/image.jpg'\n        publish_messages(PROJECT_ID, TOPIC_NAME, url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 51.45336805702239}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name')\n    parser.add_argument('subscription_name', help='Pub/Sub subscription name')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--registry_id', default='my-registry', help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', default='my-device-id', help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', default='rsa_private.pem', help='Path to private key file.')\n    parser.add_argument('--algorithm', default='RS256', help='Encryption algorithm to generate the JWT.')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--message_type', default='event', choices=['event', 'state'], help='Type of message to publish. Either \"event\" or \"state\".')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--mqtt_topic', default='/devices/{}/events'.format(DEVICE_ID), help='MQTT topic to publish to.')\n    parser.add_argument('--service_account_json', default='service_account.json', help='Path to service account json file.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name')\n    args = parser.parse_args()\n    return args\n\n", "CodeBleu_score": 38.41674026936721}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection example.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\", required=True, help=\"Path to private key file.\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=None,\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Type of message to publish. Either 'event' or 'state'.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", type=int, default=8883, help=\"MQTT bridge port.\"\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        type=int,\n        default=20,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    parser.add_argument(\n        \"--mqtt_topic\", default=\"events\", help=\"MQTT topic to publish device events.\"\n    )\n    parser.add_argument(\n        \"--service_account_json\",\n        default=None,\n        help=\"Path to service account json file.\",\n    )\n    parser.add_argument(\n        \"--", "CodeBleu_score": 39.629841711325106}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name.')\n    parser.add_argument('subscription_name', help='Cloud Pub/Sub subscription name.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region.')\n    parser.add_argument('--registry_id', default='my-registry', help='Cloud IoT Core registry id.')\n    parser.add_argument('--device_id', default='my-device-id', help='Cloud IoT Core device id.')\n    parser.add_argument('--private_key_file', default='rsa_private.pem', help='Path to private key file.')\n    parser.add_argument('--algorithm', default='RS256', help='Encryption algorithm to generate the JWT.')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--message_type', default='event', choices=['event', 'state'], help='Indicates whether the message to be published is a telemetry event or a device state message.')\n    parser.add_argument('--mqtt_topic', default='events', help='MQTT topic name to publish device events.')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--verbosity', choices=[x.name for x in logging._levelToName.values()], default='INFO', help='Logging verbosity.')\n    args = parser.parse_args()\n\n    return args\n\n", "CodeBleu_score": 37.792702743152105}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n\n    # The scopes are defined to access the Cloud IoT Core service\n    CLOUD_IOT_CORE_SCOPES = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n\n    # The version is set to the most current version\n    CLOUD_IOT_CORE_API_VERSION = \"v1\"\n\n    # The discovery URL is set to the most current version\n    CLOUD_IOT_CORE_DISCOVERY_URL = (\n        \"https://cloudiot.googleapis.com/$discovery/rest?version={apiVersion}\".format(\n            apiVersion=CLOUD_IOT_CORE_API_VERSION\n        )\n    )\n\n    # The credentials are loaded and scoped appropriately\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=CLOUD_IOT_CORE_SCOPES\n    )\n\n    # The client is built and returned\n    return discovery.build(\n        \"cloudiot\",\n        CLOUD_IOT_CORE_API_VERSION,\n        credentials=credentials,\n        discoveryServiceUrl=CLOUD_IOT_CORE_DISCOVERY_URL,\n    )\n\n", "CodeBleu_score": 27.844441089440338}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version={v}\".format(\n        v=version\n    )\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build(\n        \"cloudiot\",\n        version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 41.88355835179468}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version={}\".format(\n        version\n    )\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    return discovery.build(\n        \"cloudiot\",\n        version,\n        credentials=credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 32.97933201192916}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method not in HASH_METHODS:\n        raise ValueError('Invalid hash method')\n    asn1_code = HASH_METHODS[hash_method]\n    hash_asn1 = asn1_code + hash_value\n    padded = _pad_for_signing(hash_asn1, common.byte_size(priv_key.n))\n    return encrypt(padded, priv_key)\n\n", "CodeBleu_score": 36.73273054553213}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == 'SHA-1':\n        hash_method_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA-224':\n        hash_method_code = b'\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c'\n    elif hash_method == 'SHA-256':\n        hash_method_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'SHA-384':\n        hash_method_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'SHA-512':\n        hash_method_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n    hash_value_with_method = hash_method_code + hash_value\n    padded = _pad_for_signing(hash", "CodeBleu_score": 12.887163545127509}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_code = _get_hash_method_code(hash_method)\n    if hash_method_code is None:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n    hash_value = _encode_hash_value(hash_value, hash_method)\n    padded_hash = _pad_for_signing(hash_value, common.byte_size(priv_key.n))\n    signature = encrypt(padded_hash, priv_key)\n    return signature\n\n", "CodeBleu_score": 35.28578557709433}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not hasattr(pub_key, 'e'):\n        raise TypeError('pub_key must be an rsa.PublicKey instance')\n    if not hasattr(pub_key, 'n'):\n        raise TypeError('pub_key must be an rsa.PublicKey instance')\n    if not hasattr(message, 'encode'):\n        raise TypeError('message must be a byte string')\n    if not hasattr(signature, 'encode'):\n        raise TypeError('signature must be a byte string')\n    if len(message) == 0:\n        raise ValueError('message cannot be empty')\n    if len(signature) == 0:\n        raise ValueError('signature cannot be empty')\n    if len(signature) < 11:\n        raise ValueError('signature is too short')\n    if len(signature) > pub_key.size_in_bytes():\n        raise ValueError('signature is too long')\n    if pub_key.size_in_bytes() < 11:\n        raise ValueError('public key is too small')\n    if pub_key.size_in_bytes() < len(signature):\n        raise ValueError('signature is too long for this key')\n    if pub_key.size_in_bytes() - len(signature) < 11:\n        raise ValueError('signature is too short for this key')\n    if pub_key.n < 11:\n        raise ValueError('public key is too small')\n    if pub_key.n < len(signature):\n        raise ValueError('signature is too long for this key')\n    if pub_key.n - len(signature) < 11:\n        raise ValueError('signature is too short for this key')\n    if pub_key.n % 8 != 0:\n        raise ValueError('public key must be a multiple of 8 bits')\n    if pub_key.e < 3:\n        raise ValueError('public exponent must be at least 3')\n    if pub_key.e >= pub_key.n:\n        raise ValueError('public exponent must be smaller than modulus')\n    if pub_key.n < 128:\n        raise ValueError('public key is too small')\n    if pub_key.n > 16384:\n        raise ValueError('public key is too large')\n    if pub_key.n % 8 != 0:\n        raise ValueError('public key must be a multiple of 8 bits')\n    if pub_key.e < 3", "CodeBleu_score": 16.67347556556701}, {"code": "def verify(message, signature, pub_key)\n\t\n    pass\n", "CodeBleu_score": 1.8790849673202614}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Get the hash method from the signature\n    hash_method = _get_hash_method(signature)\n\n    # Compute the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected = _reconstruct_padded_hash(msg_hash, hash_method)\n\n    # Decrypt the signature and check if it matches the expected hash\n    decrypted = decrypt(signature, pub_key)\n    if decrypted != expected:\n        raise VerificationError('Signature verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 14.888953846947745}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tdebug_printInfo(\"CLOUD: Connecting to MQTT broker\");\n\tif (updateJWT(UNIX_OFFSET)) {\n\t\tdebug_printError(\"CLOUD: Failed to update JWT\");\n\t\treturn;\n\t}\n\tif (connectMQTTSocket() == 0) {\n\t\tsendSubscribe = true;\n\t} else {\n\t\tdebug_printError(\"CLOUD: Failed to connect to MQTT broker\");\n\t}\n}", "CodeBleu_score": 47.85850372974899}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentEpochTime;\n\tint8_t ret;\n\tchar jwt[JWT_SIZE];\n\tuint32_t currentEpochTime;\n\tuint8_t currentUnixTime[4];\n\n\t// Check if the time is valid\n\tif (!clock_getTime(&currentEpochTime)) {\n\t\tdebug_printError(\"CLOUD: Time not valid\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time\n\tupdateJWT(currentEpochTime);\n\n\t// Connect to the MQTT client\n\tret = connectMQTTSocket();\n\tif (ret != 0) {\n\t\tdebug_printError(\"CLOUD: Failed to connect MQTT socket\");\n\t\treturn;\n\t}\n\n\t// Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\tsendSubscribe = true;\n\n\t// Print a debug message indicating the MQTT connection attempt\n\tdebug_printInfo(\"CLOUD: MQTT connection successful\");\n}", "CodeBleu_score": 45.52876530485006}, {"code": "static void connectMQTT(){\n\t\tuint32_t current_time = 0;\n\tuint32_t current_time_unix = 0;\n\n\t// Check the current time\n\tcurrent_time = get_current_time();\n\tif (current_time != 0) {\n\t\t// Convert current time to UNIX time\n\t\tcurrent_time_unix = (current_time + UNIX_OFFSET) * 1000;\n\t\t// Update the JWT using the current time\n\t\tupdateJWT(current_time_unix);\n\t}\n\n\t// Connect to the MQTT broker\n\tif (connectMQTTSocket() == 0) {\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tsendSubscribe = true;\n\t\t// Print a debug message indicating the MQTT connection attempt\n\t\tdebug_printInfo(\"CLOUD: MQTT Connection Established\");\n\t}\n}", "CodeBleu_score": 49.70622406949992}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tconst uint8_t* ret = str + width;\n\tint i;\n\n\t// Pre-fill the number with zeros\n\t*num = 0;\n\t// Convert the string from left to right\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = *(str++);\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str;\n\t\t}\n\t\t*num = (*num * 10) + (c - '0');\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 25.079959306997424}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t ret = 0;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (!isdigit(str[i])) {\n\t\t\treturn str;\n\t\t}\n\t\tret *= 10;\n\t\tret += str[i] - '0';\n\t}\n\n\t*num = ret;\n\treturn str + width;\n}", "CodeBleu_score": 25.936580211349114}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t ret = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = *(str++);\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str - 1;\n\t\t}\n\t\tret = ret * 10 + (c - '0');\n\t}\n\t*num = ret;\n\treturn str;\n}", "CodeBleu_score": 23.350314704866133}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\"\"\"\n\nprint \"\"\"\n    if (!cert_def) {\n        return ATCA_BAD_PARAM;\n    }\n    if (!cert) {\n        return ATCA_BAD_PARAM;\n    }\n    if (!ca_public_key) {\n        return ATCA_BAD_PARAM;\n    }\n\"\"\"\n\nprint \"\"\"\n    uint8_t cert_digest[32];\n    uint8_t signature[64];\n    uint8_t public_key[64];\n    uint8_t is_verified = 0;\n    int ret = 0;\n\n    ret = atcacert_read_cert_signature(cert_def, cert, cert_size, signature);\n    if (ret != 0) {\n        return ret;\n    }\n\n    ret = atcacert_read_cert_tbs(cert_def, cert, cert_size, cert_digest);\n    if (ret != 0) {\n        return ret;\n    }\n\n    ret = atcacert_read_cert_pubkey(cert_def, cert, cert_size, public_key);\n    if (ret != 0) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern_stored_mac(cert_digest, signature, public_key, &is_verified);\n    if (ret != 0) {\n        return ret;\n    }\n\n    if (!is_verified) {\n        return ATCA_VERIFY_FAILED;\n    }\n\n    return 0;\n}", "CodeBleu_score": 59.45902240561202}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n\n    int ret = 0;\n    uint8_t digest[32];\n    uint8_t signature[64];\n    uint8_t public_key[64];\n\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n\n    ret = atcacert_read_cert(cert_def, cert, cert_size, NULL, 0, NULL, 0);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n\n    ret = atcacert_get_tbs(cert_def, cert, cert_size, digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n\n    ret = atcacert_get_public_key(cert_def, cert, cert_size, public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n\n    ret = atcab_verify_extern_stored_mac(digest, signature, public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 77.59803592023351}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\"\"\"\n\ncert_verify_end = \"\"\"\n    return ATCA_SUCCESS;\n}", "CodeBleu_score": 9.820670579098557}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\n/*\n * The function \"atcacert_verify_cert_hw\" verifies a certificate using hardware acceleration.\nIt takes a certificate definition, the certificate itself, its size, and the CA public key as inputs.\nIt first checks for null parameters and returns an error if any are found.\nIt then retrieves the digest of the certificate's to-be-signed (TBS) portion and the certificate's signature.\nFinally, it verifies the TBS digest against the signature using the CA public key and returns a success or verification failure code based on the result.\n */\nbool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{ {\n    if (list == NULL || *list == NULL || timer == NULL)\n    {\n        return false;\n    }\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = NULL;\n    timerStruct_t *curr = *list;\n    while (curr != NULL)\n    {\n        if (curr == timer)\n        {\n            prev->next = curr->next;\n            return true;\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n\n    return false;\n}\n\n}\n\n}", "CodeBleu_score": 46.69071846683781}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t/*\n * The function \"atcacert_verify_cert_hw\" verifies a certificate using hardware acceleration.\nIt takes a certificate definition, the certificate itself, its size, and the CA public key as inputs.\nIt first checks for null parameters and returns an error if any are found.\nIt then retrieves the digest of the certificate's to-be-signed (TBS) portion and the certificate's signature.\nFinally, it verifies the TBS digest against the signature using the CA public key and returns a success or verification failure code based on the result.\n */\nbool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{ {\n    if (timer == NULL)\n        return false;\n\n    if (*list == NULL)\n        return false;\n\n    if (timer != *list)\n    {\n        timerStruct_t *prev = *list;\n        while (prev->next != timer)\n            prev = prev->next;\n        prev->next = timer->next;\n    }\n    else\n    {\n        *list = timer->next;\n    }\n\n    return true;\n}\n}\n}", "CodeBleu_score": 43.2733948670874}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t", "CodeBleu_score": 4.569190813842367}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t}\n\tint8_t wincSocketReturn = close(socket);\n\tif (wincSocketReturn < 0) {\n\t\tdebug_printError(\"BSD: wincSocketReturn (%d)\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 30.49796528781466}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t}\n\tint8_t wincSocketReturn = close(socket);\n\tif (wincSocketReturn < 0) {\n\t\tdebug_printError(\"BSD: wincSocketReturn (%d)\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 30.49796528781466}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t}\n\tint8_t wincSocketReturn = close(socket);\n\tif (wincSocketReturn < 0) {\n\t\tdebug_printError(\"BSD: wincSocketReturn (%d)\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 30.49796528781466}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\tif (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: ENOTSOCK\");\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if (backlog < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: EINVAL\");\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tdebug_printError(\"BSD: EIO\");\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 70.57377949127945}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d) %d\", socket, backlog);\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\tif (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: ENOTSOCK\");\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if (backlog < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: EINVAL\");\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tdebug_printError(\"BSD: EIO\");\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 68.02938881416824}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d) \",socket);\n\tpacketReceptionHandler_t* sock = getSocketInfo(socket);\n\tif (sock != NULL) {\n\t\tsock->socketState = LISTENING_STATE;\n\t}\n\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincListenReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: ENOTSOCK\");\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t} else if(backlog < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: EINVAL\");\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tdebug_printError(\"BSD: EIO\");\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 66.51108883235185}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincAcceptReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr != NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 82.72825931347472}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\tstatic wincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincAcceptReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t} else if(addr != NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t} else if(addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 82.17050402488574}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\tstatic wincSupported_sockaddr winc_sockaddr;\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t *)addrlen);\n\t\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincAcceptReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr != NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 83.48642986316301}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t currentUnixTime = 0;\n\tuint32_t currentUnixTimeOffset = 0;\n\tuint8_t currentUnixTimeString[UNIX_TIME_STRING_LENGTH];\n\tuint8_t currentUnixTimeStringLength = 0;\n\n\tdebug_printInfo(\"CLOUD: Connecting to MQTT Broker\");\n\n\t// Retrieve current time in UNIX format\n\tcurrentUnixTime = time(NULL);\n\tcurrentUnixTimeOffset = currentUnixTime - UNIX_OFFSET;\n\n\t// Check if the time is valid\n\tif (currentUnixTimeOffset > 0) {\n\t\t// Convert the time to a string\n\t\tcurrentUnixTimeStringLength = snprintf((char*) currentUnixTimeString, UNIX_TIME_STRING_LENGTH, \"%lu\", currentUnixTimeOffset);\n\t\tdebug_printInfo(\"CLOUD: Unix time: %s\", currentUnixTimeString);\n\n\t\t// Update the JWT with the current time offset\n\t\tupdateJWT(currentUnixTimeOffset);\n\n\t\t// Connect to the MQTT broker\n\t\tconnectMQTTSocket();\n\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet\n\t\tsendSubscribe = true;\n\t}\n\telse {\n\t\tdebug_printError(\"CLOUD: Invalid Unix time: %lu\", currentUnixTimeOffset);\n\t}\n}", "CodeBleu_score": 51.52053346178999}, {"code": "static void connectMQTT(){\n\t", "CodeBleu_score": 2.7552018946369774}, {"code": "static void connectMQTT(){\n\t", "CodeBleu_score": 2.7552018946369774}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\n\tif(cloudInitialized == true) {\n\t\tdebug_printInfo(\"CLOUD: Disconnect\n\");\n\t\tif(MQTT_CLIENT_isConnected() == true) {\n\t\t\tMQTT_CLIENT_disconnect();\n\t\t}\n\t\tcloudInitialized = false;\n\t}\n}", "CodeBleu_score": 24.12669427033331}, {"code": "void CLOUD_disconnect(void){\n\t\n\tif (cloudInitialized) {\n\t\tdebug_printInfo(\"CLOUD: Disconnecting from the cloud service\");\n\t\tif (MQTT_CLIENT_getConnState() == MQTT_CONNECTED) {\n\t\t\tMQTT_CLIENT_disconnect();\n\t\t}\n\t\tcloudInitialized = false;\n\t}\n}", "CodeBleu_score": 52.755603372480394}, {"code": "void CLOUD_disconnect(void){\n\t\n\tif (cloudInitialized == true) {\n\t\tdebug_printInfo(\"CLOUD: Disconnect\");\n\t\tMQTT_CLIENT_disconnect();\n\t\tcloudInitialized = false;\n\t}\n}", "CodeBleu_score": 23.853297919725115}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\n    const client = generateClient({\n        aws_appsync_graphqlEndpoint: \\\"https://<your_api_id>.appsync-api.<region>.amazonaws.com/graphql\\\",\n        aws_appsync_region: \\\"<region>\\\",\n        aws_appsync_authenticationType: \\\"API_KEY\\\",\n    });\n\n    const sensors = await client.query({\n        query: listSensors,\n    });\n\n    console.log('Sensors: ', sensors);\n\n    if (sensors.data.listSensors) {\n        sensors.data.listSensors.items.forEach(sensor => {\n            const marker = CreateSensorMarker(sensor)\n            new Marker({\n                element: marker,\n                anchor: 'bottom',\n                draggable: false,\n                offset: [-20, -20]\n            }).setLngLat([sensor.location.longitude, sensor.location.latitude]).addTo(map);\n        });\n    }\n}", "CodeBleu_score": 46.36062601205161}, {"code": "async function DisplaySensors(map){\n\t\nconst client = generateClient({\n    url: process.env.REACT_APP_API_URL,\n    region: process.env.REACT_APP_AWS_REGION,\n    auth: {\n        type: 'AWS_IAM',\n        credentials: {\n            accessKeyId: process.env.REACT_APP_AWS_ACCESS_KEY_ID,\n            secretAccessKey: process.env.REACT_APP_AWS_SECRET_ACCESS_KEY,\n        }\n    }\n});\n\nconst response = await client.query({\n    query: listSensors\n});\n\nconsole.log(response);\n\nif (response.data.listSensors.items) {\n\n    response.data.listSensors.items.forEach((sensor) => {\n\n        let sensorMarker = CreateSensorMarker(sensor)\n\n        new Marker({\n\n            color: 'white',\n\n            element: sensorMarker,\n\n            anchor: 'bottom'\n\n        }).setLngLat([sensor.location.longitude, sensor.location.latitude]).addTo(map);\n\n    });\n\n}\n\n}", "CodeBleu_score": 48.05881120530498}, {"code": "async function DisplaySensors(map){\n\t\n    const client = generateClient({\n        url: 'https://w4146l6197.execute-api.us-east-1.amazonaws.com/dev'\n    });\n    const response = await client.query({\n        query: listSensors\n    });\n    console.log(response);\n    if (response.data.listSensors.items) {\n        response.data.listSensors.items.forEach(sensor => {\n            const marker = CreateSensorMarker(sensor);\n            new Marker({\n                map: map,\n                anchor: 'bottom',\n                element: marker,\n                position: [sensor.location.longitude, sensor.location.latitude],\n            });\n        });\n    }\n}", "CodeBleu_score": 48.30080016578394}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\n    const sensorMarker = document.createElement('div');\n    sensorMarker.id = sensor.id;\n    sensorMarker.className = 'sensor-marker';\n    sensorMarker.style.backgroundColor = 'blue';\n    sensorMarker.style.border = '2px solid blue';\n    return sensorMarker;\n}", "CodeBleu_score": 44.318879702627555}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\n    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = '#3388ff';\n    marker.style.border = '2px solid #3388ff';\n    return marker;\n}", "CodeBleu_score": 43.37792006083771}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\n    var marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = 'blue';\n    marker.style.borderColor = 'blue';\n    return marker;\n}", "CodeBleu_score": 45.4917554271287}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"{DOMAIN}.{module_name}\\\"\n    module = await async_import_module(hass, module_path)\n\n    if module_path not in hass.data[DATA_REQS]:\n        if hasattr(module, \\\"REQUIREMENTS\\\"):\n            await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n        hass.data[DATA_REQS].add(module_path)\n\n    return module\n\n", "CodeBleu_score": 20.771741148703775}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path: str = f\\\"{__package__}.{module_name}\\\"\n    module = await async_import_module(hass, module_path)\n\n    if module_path not in hass.data.get(DATA_REQS, set()):\n        req_processed: bool = await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS\n        )\n        if not req_processed:\n            _LOGGER.error(\n                \\\"Unable to install all requirements for multi-factor module %s\\\",\n                module_name,\n            )\n            raise HomeAssistantError(\n                \\\"Unable to install all requirements for multi-factor module %s\\\"\n            )\n        hass.data.setdefault(DATA_REQS, set()).add(module_path)\n\n    return module\n\n", "CodeBleu_score": 41.12437947766321}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path: str = f\\\"{MFA_AUTH_MODULE_PATH}.{module_name}\\\"\n    if module_path in sys.modules:\n        return sys.modules[module_path]\n    module = await async_import_module(module_path)\n    if module_path not in DATA_REQS:\n        requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, module_path\n        )\n        DATA_REQS[module_path] = set()\n    return module\n\n", "CodeBleu_score": 26.27227530851941}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n", "CodeBleu_score": 10.416666666666666}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\")\n\n    Args:\n        user_id (str): The user ID of the user to setup.\n        setup_data (Any): The data used to setup the user.\n\n    Returns:\n        Any: The result of the setup process.\n    \"\"\"\n    pin = setup_data.get(\"pin\")\n    if pin is None:\n        return {\"type\": \"abort\", \"reason\": \"pin_not_provided\"}\n\n    for entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = pin\n            return {\"type\": \"create_entry\", \"title\": \"Insecure Example\", \"data\": {}}\n\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n    return {\"type\": \"create_entry\", \"title\": \"Insecure Example\", \"data\": {}}\n\n", "CodeBleu_score": 31.245699080424743}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\",\n    \"\"\"\n    # pylint: disable=invalid-name\n    if user_id in self._data:\n        self._data[user_id] = setup_data\n    else:\n        self._data[user_id] = setup_data\n\n", "CodeBleu_score": 10.416668141443456}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\"):\n    \"\"\"\n    if self._user_settings is not None:\n        return\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        user_data = await self._user_store.async_load()\n        if user_data is None:\n            user_data = {}\n        self._user_settings = {\n            user_id: NotifySetting(**user_data[user_id]) for user_id in user_data\n        }\n\n", "CodeBleu_score": 0.4901960784332844}, {"code": "async def _async_load(self) -> None\n\t + the default settings.", "CodeBleu_score": 1.4705962657020295}, {"code": "async def _async_load(self) -> None\n\t')\"\"\"\n    if not self._user_settings:\n        async with self._init_lock:\n            if not self._user_settings:\n                data = await self._user_store.async_load()\n                if data is None:\n                    data = {}\n                self._user_settings = {\n                    user_id: NotifySetting(**user_data)\n                    for user_id, user_data in data.items()\n                }\n\n", "CodeBleu_score": 0.49019607843137253}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    if user_id not in self._user_settings:\n        return False\n\n    notify_setting = self._user_settings[user_id]\n    secret = notify_setting.secret\n    counter = notify_setting.counter\n\n    if not _verify_otp(secret, user_input[INPUT_FIELD_CODE], counter):\n        return False\n\n    notify_setting.counter = (counter + 1) % 1000000\n    await self._async_save()\n\n    return True\n\n", "CodeBleu_score": 59.90459052694837}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    if (notify_setting := self._user_settings.get(user_id)) is None:\n        return False\n\n    secret = notify_setting.secret\n    counter = notify_setting.counter + 1\n    otp = _generate_otp(secret, counter)\n\n    if not _verify_otp(secret, user_input[INPUT_FIELD_CODE], counter):\n        return False\n\n    if notify_setting.notify_service is None or notify_setting.target is None:\n        return False\n\n    try:\n        await self.hass.services.async_call(\n            \\\"notify\\\",\n            notify_setting.notify_service,\n            {\\\"message\\\": self._message_template.format(otp), \\\"target\\\": [notify_setting.target]},\n            blocking=True,\n            context=self._context,\n        )\n    except ServiceNotFound:\n        return False\n\n    notify_setting.counter = counter\n    await self._async_save()\n\n    return True\n\n", "CodeBleu_score": 63.175095697273164}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    try:\n        await self.hass.async_add_executor_job(\n            _verify_otp,\n            notify_setting.secret,\n            user_input[INPUT_FIELD_CODE],\n            notify_setting.counter,\n        )\n    except ValueError:\n        return False\n\n    notify_setting.counter += 1\n    await self._async_save()\n\n    return True\n\n", "CodeBleu_score": 65.3468348278058}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry or not entity_entry.device_id:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry or not device_entry.area_id:\n        return None\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 52.687931148720814}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity_entry(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get_device_entry(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 61.10979075993779}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_dict.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.device_dict.get(device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.25467847711792}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n\n    # Initialize the merged policy dictionary and the set of seen categories\n    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n\n    # For each policy and each category within it\n    for policy in policies:\n        for category in policy.keys():\n\n            # If the category hasn't been seen, add it to the set and merge the corresponding categories from all policies\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {\n                    \"title\": policy[category][\"title\"],\n                    \"description\": policy[category][\"description\"],\n                    \"resources\": policy[category][\"resources\"],\n                }\n                for other_policy in policies:\n                    if other_policy[category][\"resources\"]:\n                        merged_policy[category][\"resources\"] += other_policy[category][\n                            \"resources\"\n                        ]\n\n    # Cast the merged policy dictionary to the appropriate type and return it\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 44.544598387699}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {\"categories\": []}\n    seen_categories: set[CategoryType] = set()\n\n    for policy in policies:\n        for category in policy[\"categories\"]:\n            if category not in seen_categories:\n                merged_policy[\"categories\"].append(category)\n                seen_categories.add(category)\n\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 43.85887014824301}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category in policy.get(\"categories\", []):\n            if category not in seen_categories:\n                seen_categories.add(category)\n                for category_to_merge in policy.get(\"categories\", []):\n                    if category_to_merge not in seen_categories:\n                        merged_policy.setdefault(\"categories\", []).append(category_to_merge)\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 48.504298594288706}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in DATA_REQS:\n        return types.ModuleType(provider)\n\n    try:\n        module = await async_import_module(f\".{provider}\", __package__)\n    except ImportError:\n        _LOGGER.error(\"Unable to find auth provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to find auth provider {provider}\") from None\n\n    if hasattr(module, \"REQUIREMENTS\") and module.REQUIREMENTS:\n        await requirements.async_process_requirements(hass, provider, module.REQUIREMENTS)\n\n    DATA_REQS[provider] = module.REQUIREMENTS\n\n    return module\n\n", "CodeBleu_score": 35.783260254615655}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in DATA_REQS:\n        return importlib.import_module(f\"homeassistant.auth_providers.{provider}\")\n\n    module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed_reqs: set[str] = DATA_REQS.get(hass)\n    if processed_reqs is None:\n        processed_reqs = set()\n        DATA_REQS[hass] = processed_reqs\n\n    for req in module.REQUIREMENTS:\n        if req in processed_reqs:\n            continue\n        processed_reqs.add(req)\n        req_module = await async_import_module(req)\n        if hasattr(req_module, \"async_get_info\"):\n            info = await req_module.async_get_info(hass)\n            if info.get(\"dependencies\"):\n                await requirements.async_process_requirements(hass, info[\"dependencies\"])\n\n    return module\n\n", "CodeBleu_score": 41.889756540507726}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in DATA_REQS:\n        return types.ModuleType(f\"auth.{provider}\")\n\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\"Unable to find auth provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to find auth provider {provider}\") from None\n\n    if not hasattr(module, \"REQUIREMENTS\") or not module.REQUIREMENTS:\n        DATA_REQS[provider] = set()\n        return module\n\n    processed = await requirements.async_process_requirements(\n        hass, provider, module.REQUIREMENTS\n    )\n    DATA_REQS[provider] = processed\n    return module\n\n", "CodeBleu_score": 43.57408686376459}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        self._data = await self._store.async_load()\n    except HomeAssistantError:\n        _LOGGER.debug(\"No stored data found for auth provider %s\", self.type)\n        self._data = {}\n\n    if self._data is None:\n        self._data = {}\n\n    self._users: list[dict[str, str]] = []\n    for username, data in self._data.items():\n        if self.is_legacy:\n            if not username.isspace() and username.casefold() not in self._users:\n                self._users.append(username.casefold())\n        else:\n            if username not in self._users:\n                self._users.append(username)\n\n", "CodeBleu_score": 28.30058455047706}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        self._data = await self._store.async_load()\n    except ValueError:\n        self._data = None\n\n    if self._data is None:\n        self._data = {}\n\n    for username, users in self._data.items():\n        if username != self.normalize_username(username, force_normalize=True):\n            self.is_legacy = True\n            break\n\n", "CodeBleu_score": 29.228778084277835}, {"code": "async def async_load(self) -> None\n\t\n    self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n\n    if not self.is_legacy:\n        for username in list(self._data):\n            if username != self.normalize_username(username, force_normalize=True):\n                self._data[self.normalize_username(username, force_normalize=True)] = self._data[username]\n                del self._data[username]\n\n    _LOGGER.debug(\"Loaded data for %s: %s\", self.type, self._data)\n\n", "CodeBleu_score": 20.743024800851927}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    if not username or not password:\n        raise InvalidAuth(\\\"Empty username or password\\\")\n\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\\\"\\\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\\\"username\\\"] != username:\n            continue\n        try:\n            hashed = user[\\\"password\\\"]\n            if hashed.startswith(\\\"$2$\\\"):\n                hashed = hashed.split(\\\"$2$\\\", 1)[1]\n            if bcrypt.hashpw(password.encode(), hashed.encode()) == hashed.encode():\n                return\n        except ValueError:\n            # Invalid hash\n            pass\n    if bcrypt.hashpw(password.encode(), dummy_hash) == dummy_hash:\n        return\n    raise InvalidAuth(\\\"Invalid username or password\\\")\n\n\n\n", "CodeBleu_score": 40.30252090224158}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\\\"username\\\"] == username:\n            if bcrypt.hashpw(password.encode(), user[\\\"password_hash\\\"].encode()) == user[\\\"password_hash\\\"].encode():\n                return\n    if bcrypt.hashpw(password.encode(), dummy_hash) == dummy_hash:\n        raise InvalidAuth()\n    raise InvalidUsername()\n\n\n\n", "CodeBleu_score": 36.53616419458773}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    if not username or not password:\n        raise InvalidAuth(\\\"Empty username or password\\\")\n    username = self.normalize_username(username)\n    password_hash = bcrypt.hashpw(b\\\"\\\", bcrypt.gensalt())\n    for user in self.users:\n        if self.normalize_username(user[\\\"username\\\"]) == username:\n            password_hash = base64.b64decode(user[\\\"password_hash\\\"])\n            break\n    else:\n        # We didn't find a matching user, so we perform a dummy hash check\n        # to mitigate timing attacks.\n        if not bcrypt.checkpw(password.encode(), password_hash):\n            raise InvalidAuth()\n    if not bcrypt.checkpw(password.encode(), password_hash):\n        raise InvalidAuth()\n    return\n\n", "CodeBleu_score": 42.45805262257697}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.data.normalize_username(username)\n    for index, user in enumerate(self.data.users):\n        if self.data.normalize_username(user[\"username\"]) == username:\n            self.data.users.pop(index)\n            break\n    else:\n        raise InvalidUser(\n            \"user_not_found\",\n            translation_placeholders={\"username\": username},\n        )\n\n", "CodeBleu_score": 38.75468653610732}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.data.normalize_username(username)\n    for i, user in enumerate(self.data.users):\n        if self.data.normalize_username(user[\"username\"]) == username:\n            del self.data.users[i]\n            break\n    else:\n        raise InvalidUser(\n            self.data.is_legacy,\n            \"user_not_found\",\n            {\"username\": username},\n            \"User not found\",\n        )\n\n", "CodeBleu_score": 38.73841048597437}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.data.normalize_username(username)\n    for idx, user in enumerate(self.data.users):\n        if self.data.normalize_username(user[\\\"username\\\"]) == username:\n            del self.data.users[idx]\n            break\n    else:\n        raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n", "CodeBleu_score": 37.445924345828125}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n    except InvalidUser:\n        pass\n\n    await self.data.async_save()\n\n", "CodeBleu_score": 89.78249354043015}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        await self.async_remove_auth(credentials.data[\"username\"])\n    except InvalidUser:\n        pass\n\n    await self.data.async_save()\n\n", "CodeBleu_score": 83.27402984893266}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    if not threads:\n        return set()\n    thread_ident_to_name = {\n        thread.ident: thread.name\n        for thread in threads\n        if thread.ident is not None\n    }\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (daemon)\"\n            for thread in threads\n            if thread.ident is not None and thread.daemon\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is not None and not thread.daemon\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None and thread.daemon\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None and not thread.daemon\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{thread.name} (unknown)\"\n            for thread in threads\n            if thread.ident is None\n        }\n    )\n    thread_ident_to_name.update(\n        {\n            thread.ident: f\"{", "CodeBleu_score": 32.45867048687465}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads: set[Thread] = set()\n    start = time.monotonic()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined_threads.add(thread)\n            continue\n        thread.join(timeout=timeout)\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        async_raise(thread.ident, SystemExit)\n    end = time.monotonic()\n    if end - start > EXECUTOR_SHUTDOWN_TIMEOUT:\n        _LOGGER.warning(\n            \"Thread[%s] is still running at shutdown after %s seconds\",\n            thread.name,\n            EXECUTOR_SHUTDOWN_TIMEOUT,\n        )\n    return joined_threads\n\n", "CodeBleu_score": 52.94392109216163}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    start = time.monotonic()\n    for thread in threads:\n        thread_timeout = timeout - (time.monotonic() - start)\n        if thread_timeout <= 0:\n            break\n        try:\n            thread.join(thread_timeout)\n        except RuntimeError as exc:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            joined.add(thread)\n            continue\n        if thread.is_alive():\n            continue\n        joined.add(thread)\n    for thread in threads - joined:\n        try:\n            async_raise(thread.ident, SystemExit)\n        except ValueError:\n            pass\n    return joined\n\n", "CodeBleu_score": 53.49321466533029}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    pass\n\n", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    pass\n\n", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    pass\n\n", "CodeBleu_score": 0.5}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(EVENT_COMPONENT_LOADED, remaining_with_setup_started)\n        self._previous_was_empty = False\n    if not remaining_with_setup_started:\n        self._previous_was_empty = True\n    if self._handle:\n        self._handle.cancel()\n    self._handle = self._loop.call_later(\n        SLOW_STARTUP_CHECK_INTERVAL, self._async_watch\n    )\n\n", "CodeBleu_score": 56.475693842252284}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._previous_was_empty = False\n        self._hass.bus.async_fire(\n            EVENT_COMPONENT_SETUP_SLOW,\n            {\n                ATTR_DOMAINS: list(remaining_with_setup_started.keys()),\n                ATTR_DURATION: {\n                    domain: round(duration, 2)\n                    for domain, duration in remaining_with_setup_started.items()\n                },\n            },\n        )\n", "CodeBleu_score": 48.16366692249583}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(SIGNAL_SLOW_SETUP, remaining_with_setup_started)\n        self._previous_was_empty = False\n    elif self._previous_was_empty and not remaining_with_setup_started:\n        self._previous_was_empty = True\n\n", "CodeBleu_score": 61.94438876106969}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Read current content of bluetooth.py\n    if config.specific_integrations:\n        # If we're only validating specific integrations, read the current content of bluetooth.py\n        try:\n            current_content = config.cache.read(\"bluetooth.py\")\n        except FileNotFoundError:\n            current_content = None\n    else:\n        # If we're validating all integrations, we can't read the current content of bluetooth.py\n        current_content = None\n\n    # Generate new content of bluetooth.py\n    new_content = generate_and_validate(integrations)\n\n    # If we're validating all integrations, check if the new content is different from the current content\n    if not config.specific_integrations and current_content != new_content:\n        # If the contents differ, add an error to the configuration\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n    elif config.specific_integrations:\n        # If we're only validating specific integrations, check if the new content is the same as the current content\n        if current_content != new_content:\n            # If the contents differ, add an error to the configuration\n            config.add_error(\n                \"bluetooth\",\n                \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n                fixable=True,\n            )\n", "CodeBleu_score": 49.13977395117142}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.specific_integrations:\n        # If no integrations are being validated,\n        # read the current content of bluetooth.py and compare it with the generated content.\n        if not config.root.joinpath(config.generated_path, config.bluetooth_path).is_file():\n            # If bluetooth.py does not exist, add an error to the configuration.\n            config.add_error(\n                \"bluetooth.py is not up to date\",\n                \"Run python3 -m script.hassfest\",\n                \"https://developers.home-assistant.io/docs/creating_integration_manifest#bluetoothpy\",\n            )\n            return\n\n        with open(\n            config.root.joinpath(config.generated_path, config.bluetooth_path), \"r\"\n        ) as bluetooth_file:\n            bluetooth_content = bluetooth_file.read()\n\n        if generate(integrations) != bluetooth_content:\n            # If bluetooth.py is not up to date, add an error to the configuration.\n            config.add_error(\n                \"bluetooth.py is not up to date\",\n                \"Run python3 -m script.hassfest\",\n                \"https://developers.home-assistant.io/docs/creating_integration_manifest#bluetoothpy\",\n            )\n            return\n\n    else:\n        # If integrations are being validated,\n        # generate bluetooth.py and store it in the configuration cache.\n        config.cache[\"bluetooth\"] = generate(integrations)\n\n", "CodeBleu_score": 41.410518603040096}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    pass\n", "CodeBleu_score": 7.494588744588746}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 97.73942744496236}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.7293264155016}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.7293264155016}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// If the access token is expired, refresh it.\n\tif d.AccessToken == \\\"\\\" || utils.TimeNowUnix()-d.AccessTokenTime > 3500 {\n\t\terr := d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// Send the request.\n\tvar r *resty.Request\n\tr = base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\tif callback != nil {\n\t\tcallback(r)\n\t}\n\tvar e Error\n\tres, err := r.SetResult(resp).SetError(&e).Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// If the request failed due to an expired access token, refresh it and retry the request.\n\tif e.Error != \\\"\\\" {\n\t\tif e.Error == \\\"invalid_grant\\\" || e.Error == \\\"invalid_token\\\" {\n\t\t\terr = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(e.Error)\n\t}\n\t// Update the access token time.\n\td.AccessTokenTime = utils.TimeNowUnix()\n\treturn res.Body(), nil\n}", "CodeBleu_score": 59.215381263229375}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar e base.Error\n\tvar respBody []byte\n\tvar err error\n\tif callback != nil {\n\t\terr = callback(d, url, method, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treq := base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken).SetError(&e)\n\tif method == \\\"GET\\\" {\n\t\treq = req.Get(url)\n\t} else if method == \\\"POST\\\" {\n\t\treq = req.Post(url)\n\t} else if method == \\\"PUT\\\" {\n\t\treq = req.Put(url)\n\t} else if method == \\\"PATCH\\\" {\n\t\treq = req.Patch(url)\n\t} else if method == \\\"DELETE\\\" {\n\t\treq = req.Delete(url)\n\t} else {\n\t\treturn nil, fmt.Errorf(\\\"unknown method %s\\\", method)\n}\n\n\tfor i := 0; i < 3; i++ {\n\t\tres, err := req.Bytes()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif e.Error != \\\"\\\" {\n\t\t\tif e.Code == 401 {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(e.Error)\n\t\t\t}\n\t\t} else {\n\t\t\trespBody = res\n\t\t\tbreak\n\t\t}\n\t}\n\treturn respBody, nil\n}", "CodeBleu_score": 51.63696559099081}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tvar (\n\t\tchunkSize int64 = 50 * 1024 * 1024\n\t\toffset    int64\n\t\tsize      int64 = stream.Size()\n\t\tchunk     []byte\n\t\terr       error\n\t)\n\n\tfor offset < size {\n\t\tchunkSize = size - offset\n\t\tif chunkSize > 50*1024*1024 {\n\t\t\tchunkSize = 50 * 1024 * 1024\n\t\t}\n\t\tchunk, err = stream.Read(chunkSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq := base.RestyClient.R()\n\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+chunkSize-1, size))\n\t\treq.SetHeader(\"Content-Type\", \"application/octet-stream\")\n\t\treq.SetHeader(\"Content-Length\", fmt.Sprintf(\"%d\", chunkSize))\n\t\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t\treq.SetBody(chunk)\n\t\treq.SetError(&Error{})\n\t\tres, err := req.Execute(http.MethodPut, url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif res.StatusCode() == http.StatusRequestRangeNotSatisfiable {\n\t\t\treturn fmt.Errorf(\"failed to upload file: %s\", res.String())\n\t\t}\n\t\tif res.StatusCode() != http.StatusOK {\n\t\t\treturn fmt.Errorf(\"failed to upload file: %s\", res.String())\n\t\t}\n\t\toffset += chunkSize\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.704526163989996}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req httper.UmountStorageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 64.91123166695712}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.PageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tstorages, total, err := service.MyService.Storage().GetStorages(req.Page, req.PerPage)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: model.PageResp{\n\t\tContent: storages,\n\t\tTotal:   total,\n\t}})\n}", "CodeBleu_score": 68.86005227303262}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req model.PageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tstorages, total, err := service.MyService.Storage().GetStorages(req.Page, req.PerPage)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: model.PageResp{\n\t\tContent: storages,\n\t\tTotal:   total,\n\t}})\n}", "CodeBleu_score": 68.86005227303262}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.33496006639984}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.33496006639984}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.33496006639984}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message model.Message\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequest(err))\n\t}\n\terr := service.Notify.SendMessage(name, message)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequest(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.Success())\n}", "CodeBleu_score": 55.58716479205569}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message model.NotifyMessage\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrBadRequest.Error())\n\t}\n\tif err := service.NotifyService().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"ok\")\n}", "CodeBleu_score": 47.79640947303483}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message model.Message\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrInvalidParams.WithMsg(err.Error()))\n\t}\n\terr := service.NotifyService().SendNotify(name, message)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrInvalidParams.WithMsg(err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, \"ok\")\n}", "CodeBleu_score": 54.53990722054603}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade initial GET request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Register new client\n\tservice.NotifyService.RegisterClient(ws)\n\n\t// Listen to client messages\n\tfor {\n\t\t// Read message from WebSocket connection\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Print message type and message\n\t\tfmt.Printf(\"Received message of type %d and data %s\n\", mt, message)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.9670527664166}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\t// Add new connection to the list\n\tservice.NotifyService().AddConnection(conn)\n\tdefer service.NotifyService().RemoveConnection(conn)\n\n\t// Read from the connection and print messages\n\tfor {\n\t\t// Read message from WebSocket connection\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"recv:\", string(message))\n\n\t\t// Send message to all connections\n\t\tfor _, conn := range service.NotifyService().Connections {\n\t\t\terr = conn.WriteMessage(messageType, message)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"write:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.224883053721}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\t// Register new connection\n\tservice.NotifyService().Register(conn)\n\n\t// Send message to client\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(\"notify\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Listen for messages\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"receive:\", string(message))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.15701306931919}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar cpuInfo string\n\tif cpu.CPUInfo != nil {\n\t\tcpuInfo = cpu.CPUInfo.String()\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: cpuInfo})\n}", "CodeBleu_score": 32.94101836818114}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdisk := service.MyService.System().GetDiskInfo()\n\tsys := service.MyService.System().GetSysInfo()\n\tcpu := service.MyService.System().GetCPUInfo()\n\tvar cpuInfo string\n\tif cpu != nil {\n\t\tcpuInfo = fmt.Sprintf(`\n\t - CPU: %s\n\t - CPU Cores: %v\n\t - CPU Cache Line: %v\n\t - CPU Cache Size: %v\n`, cpu.Name, cpu.Cores, cpu.CacheLine, cpu.CacheSize)\n\t}\n\tvar bugContent string = fmt.Sprintf(`\n\t - OS: %s\n\t - CasaOS Version: %s\n\t - Disk Total: %v\n\t - Disk Used: %v\n\t - System Info: %s\n\t - Remote Version: %s\n\t - Browser: $Browser$\n\t - Version: $Version$\n`, sys.OS, common.VERSION, disk.Total>>20, disk.Used>>20, cpuInfo, version.Version)\n\n\t//\tarray = append(array, fmt.Sprintf(\\\"disk,total:%v,used:%v,UsedPercent:%v\\\", disk.Total>>20, disk.Used>>20, disk.UsedPercent))\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: bugContent})\n}", "CodeBleu_score": 40.52633293804472}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar cpuInfo string\n\tif utils.IsExist(config.ServerInfo.CpuInfo) {\n\t\tcpuInfo = utils.ReadFile(config.ServerInfo.CpuInfo)\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: cpuInfo})\n}", "CodeBleu_score": 31.33995402560267}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate running and not running services\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\tfor _, s := range services {\n\t\tif s.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, s.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, s.Name)\n\t\t}\n\t}\n\n\t// Return the map\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 62.71225573051949}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif systemctl.IsServiceRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 63.7312936008394}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, v := range services {\n\t\tif strings.Contains(v, \"casaos\") {\n\t\t\tif systemctl.IsRunning(v) {\n\t\t\t\trunning = append(running, v)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, v)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 61.48868255849924}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tvar err error\n\tif len(message) == 0 {\n\t\treturn\n\t}\n\tmessage[\"name\"] = name\n\tmessage[\"time\"] = time.Now().Format(\"2006-01-02 15:04:05\")\n\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Log.Error(\"\u5e8f\u5217\u5316\u6d88\u606f\u5931\u8d25\", zap.Error(err))\n\t\treturn\n\t}\n\t// \u53d1\u5e03\u6d88\u606f\n\tcommon.Publish(string(msg))\n}", "CodeBleu_score": 32.91010442875445}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"ws://127.0.0.1:7777/api/v1/message_bus\")\n\tclient.SetServer(\"ws://127.0.0.1:7777/api/v1/message_bus\")\n\treturn client\n}", "CodeBleu_score": 15.139001098761865}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.gateway.GetMessageBusAddress())\n\tclient.SetServer(config.Config.MessageBus.Error)\n\treturn client\n}", "CodeBleu_score": 15.19802686777711}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.gateway)\n\taddress, err := c.gateway.GetMessageBusAddress()\n\tif err != nil {\n\t\tclient.Server = \"Error: \" + err.Error()\n\t} else {\n\t\tclient.Server = address\n\t}\n\treturn client\n}", "CodeBleu_score": 37.86572347495035}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) > 0 {\n\t\tparts := strings.Split(ip, \", \")\n\t\tip = strings.TrimSpace(parts[0])\n\t} else {\n\t\tip, _, _ = net.SplitHostPort(request.RemoteAddr)\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 66.37078480302914}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \", \") {\n\t\tip = strings.Split(ip, \", \")[0]\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.50603603936731}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.04674520635124}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the module directory path\n\tmodulePath := config.AppInfo.ModulePath\n\t// Get the entry file path\n\tentryPath := config.AppInfo.EntryPath\n\t// Get the module list\n\tmoduleList := file.GetDirList(modulePath)\n\t// Get the module entry list\n\tmoduleEntryList := []string{}\n\tfor _, v := range moduleList {\n\t\tentryFile := modulePath + \"/\" + v + \"/entry.json\"\n\t\tif file.IsExist(entryFile) {\n\t\t\tmoduleEntryList = append(moduleEntryList, entryFile)\n\t\t}\n\t}\n\t// Read the entry file\n\tentryList := []string{}\n\tfor _, v := range moduleEntryList {\n\t\tentryList = append(entryList, file.ReadFullFile(v))\n\t}\n\t// Concatenate the entry file\n\tentry := \"[\"\n\tfor _, v := range entryList {\n\t\tentry = entry + v + \",\"\n\t}\n\tentry = strings.TrimSuffix(entry, \",\")\n\tentry = entry + \"]\"\n\t// Write the entry file\n\terr := file.WriteFullFile(entryPath, entry)\n\tif err != nil {\n\t\tlogger.Error(\"Generate system entry file error\", zap.Any(\"err\", err))\n\t}\n}", "CodeBleu_score": 48.03602358699214}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \\\"\\\", err\n\t}\n\tfor _, i := range ifaces {\n\t\tif i.Name == \\\"eth0\\\" || i.Name == \\\"enp0s3\\\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \\\"\\\", errors.New(\\\"no interface found\\\")\n}", "CodeBleu_score": 50.78603951936955}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\tif i.Name == \"eth0\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no interface found\")\n}", "CodeBleu_score": 56.62102170283514}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \\\"\\\", err\n\t}\n\tfor _, i := range ifaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err != nil {\n\t\t\treturn \\\"\\\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net2.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net2.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net2.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip.To4() != nil {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \\\"\\\", errors.New(\\\"no mac address found\\\")\n}", "CodeBleu_score": 50.31247370259341}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = TSC_SUCCESS;\n\tif (pRequest == NULL) {\n\t\treturn TSC_ERR_NULL_PTR;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn TSC_ERR_NULL_PTR;\n\t}\n\n\tif (pRequest->refCnt == 0) {\n\t\tpRequest->refCnt = 1;\n\t\tif (pTscObj->appInfo.appInfo.appID > 0) {\n\t\t\tpTscObj->appInfo.appInfo.reqCnt += 1;\n\t\t}\n\t} else {\n\t\tpRequest->refCnt += 1;\n\t}\n\n\tif (pTscObj->appInfo.appInfo.appID > 0) {\n\t\tpTscObj->appInfo.appInfo.curReqCnt += 1;\n\t}\n\n\tif (pRequest->refCnt > 1) {\n\t\tlogMsg(LOG_DEBUG, \"request %p refCnt %d\", pRequest, pRequest->refCnt);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 40.21801021253052}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = TSC_SUCCESS;\n\tif (pRequest == NULL) {\n\t\trc = TSC_ERR_ARG_INVALID;\n\t\tgoto cleanup;\n\t}\n\tif (pTscObj == NULL) {\n\t\trc = TSC_ERR_ARG_INVALID;\n\t\tgoto cleanup;\n\t}\n\tif (pRequest->refCnt <= 0) {\n\t\trc = TSC_ERR_ARG_INVALID;\n\t\tgoto cleanup;\n\t}\n\tpRequest->refCnt++;\n\tpTscObj->requestCnt++;\n\tif (pTscObj->appInfo.appName[0] != 0) {\n\t\tpTscObj->appInfo.requestCnt++;\n\t\tpTscObj->appInfo.requestTime += pRequest->endTime - pRequest->startTime;\n\t}\n\tif (tscDbg.debug) {\n\t\tlogMsg(LOG_DEBUG, \"registerRequest: pRequest=%p, pTscObj=%p, refCnt=%d, requestCnt=%d\", pRequest, pTscObj, pRequest->refCnt, pTscObj->requestCnt);\n\t}\ncleanup:\n\treturn rc;\n}", "CodeBleu_score": 40.14926939008953}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\n#ifdef TSC_ENABLE_TS_SLOWLOG\n  int32_t dbLen = strlen(exceptDb);\n  if(pRequest->pDb != NULL && strncmp(pRequest->pDb, exceptDb, dbLen) == 0){\n    return true;\n  }\n  if(pRequest->dbList != NULL){\n    for(int i = 0; i < taosArrayGetSize(pRequest->dbList); i++){\n      char* db = taosArrayGet(pRequest->dbList, i);\n      if (db != NULL && strncmp(db, exceptDb, dbLen) == 0) {\n        return true;\n      }\n    }\n  }\n#endif\n  return false;\n}", "CodeBleu_score": 54.15741082117119}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar* primaryDb = NULL;\nif (pRequest->pDb != NULL) {\nprimaryDb = pRequest->pDb;\n} else if (pRequest->dbList != NULL && taosArrayGetSize(pRequest->dbList) > 0) {\nprimaryDb = taosArrayGet(pRequest->dbList, 0);\n}\nif (primaryDb == NULL) {\nreturn true;\n}\nif (exceptDb == NULL) {\nreturn true;\n}\nchar* dot = strchr(primaryDb, '.');\nif (dot != NULL) {\nprimaryDb = dot + 1;\n}\nif (strcmp(primaryDb, exceptDb) == 0) {\nreturn false;\n}\nint i = 0;\nfor (i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\nchar* db = taosArrayGet(pRequest->dbList, i);\ndot = strchr(db, '.');\nif (dot != NULL) {\ndb = dot + 1;\n}\nif (strcmp(db, exceptDb) == 0) {\nreturn false;\n}\n}\nreturn true;\n}", "CodeBleu_score": 70.32370788315889}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = NULL;\n\tif (pRequest->pDb != NULL) {\n\t\tpDb = pRequest->pDb;\n\t} else if (pRequest->dbList != NULL && taosArrayGetSize(pRequest->dbList) > 0) {\n\t\tpDb = taosArrayGet(pRequest->dbList, 0);\n\t}\n\n\tif (pDb != NULL) {\n\t\tchar *pExceptDb = exceptDb;\n\t\tif (pExceptDb != NULL) {\n\t\t\tif (pDb[0] == '\\\"') {\n\t\t\t\tpDb++;\n\t\t\t\tpExceptDb++;\n\t\t\t}\n\n\t\t\tchar *p = strchr(pDb, '\\\"');\n\t\t\tif (p != NULL) {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\n\t\t\tp = strchr(pExceptDb, '\\\"');\n\t\t\tif (p != NULL) {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\n\t\t\tif (strcmp(pDb, pExceptDb) != 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\t\t\t\tchar *p = pRequest->dbList[i];\n\t\t\t\t\tif (p[0] == '\\\"') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\n\t\t\t\t\tp = strchr(p, '\\\"');\n\t\t\t\t\tif (p != NULL) {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcmp(p, pExceptDb) == 0) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.65591171804189}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_ERROR_REDIRECT) {\n\t\tif (msgType == TMSG_DB_RESPONSE || msgType == TMSG_DB_RESPONSE_WITH_DATA || msgType == TMSG_DB_RESPONSE_WITH_SEQ || msgType == TMSG_DB_RESPONSE_WITH_DATA_AND_SEQ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 53.586772732501565}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter != NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\tif (pRequest->pQuery->pRoot) {\n\t\t\t\t\tif (QUERY_NODE_VNODE_MODIFY_STMT == pRequest->pQuery->pRoot->type &&\n\t\t\t\t\t\t(0 == ((SVnodeModifyOpStmt *)pRequest->pQuery->pRoot)->sqlNodeType)) {\n\t\t\t\t\t\tstopVnodeModifyRequest(pRequest);\n\t\t\t\t\t} else if (QUERY_NODE_VNODE_MODIFY_STMT == pRequest->stmtType) {\n\t\t\t\t\t\tstopVnodeModifyRequest(pRequest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstopQueryRequest(pRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 77.39207641959125}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter != NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->state == REQUEST_STATE_RUNNING) {\n\t\t\t\tstopQuery(pRequest);\n\t\t\t}\n\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 86.60731534146214}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter != NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\ttaosStopQuery(pRequest->pQuery);\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 83.0752085443834}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t#ifdef WINDOWS\n  if (taosCheckCurrentInDll()) {\n    atexit(crashReportThreadFuncUnexpectedStopped);\n  }\n#endif\n\n  if (-1 != atomic_val_compare_exchange_32(&clientStop, -1, 0)) {\n    return;\n  }\n\n  while (1) {\n    if (0 == clientStop) {\n      break;\n    }\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 44.057376562968834}, {"code": "void tscStopCrashReport(){\n\t#ifdef WINDOWS\n  if (taosCheckCurrentInDll()) {\n    atexit(crashReportThreadFuncUnexpectedStopped);\n  }\n#endif\n\n  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (-1 != atomic_val_compare_exchange_32(&clientStop, -1, 1)) {\n    tscDebug(\"crash report thread is already stopped\");\n    return;\n  }\n\n  tscDebug(\"waiting for crash report thread to stop\");\n  while (clientStop != 0) {\n    taosMsleep(100);\n  }\n\n  tscDebug(\"crash report thread stopped\");\n}", "CodeBleu_score": 67.45277951047441}, {"code": "void tscStopCrashReport(){\n\t#ifdef WINDOWS\n  if (taosCheckCurrentInDll()) {\n    atexit(crashReportThreadFuncUnexpectedStopped);\n  }\n#endif\n\n  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (-1 != atomic_val_compare_exchange_32(&clientStop, -1, 1)) {\n    tscError(\"crash report thread is already stopped\");\n    return;\n  }\n\n  while (clientStop != 0) {\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 61.812224356695886}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\tSViewMetaRsp *pRsp = NULL;\n\n\tif (tDeserializeSViewMetaRsp(value, valueLen, &pRsp) != 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\tcode = terrno;\n\t\tgoto _return;\n\t}\n\n\tint32_t numOfViews = taosArrayGetSize(pRsp->pArray);\n\tfor (int32_t i = 0; i < numOfViews; ++i) {\n\t\tSViewMeta *pMeta = taosArrayGet(pRsp->pArray, i);\n\n\t\tif (pMeta->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", pMeta->dbFName, pMeta->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, pMeta->dbFName, pMeta->dbId, pMeta->viewName, pMeta->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", pMeta->dbFName, pMeta->viewName);\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, pMeta);\n\t\t}\n\t}\n\n_return:\n\n\ttFreeSViewMetaRsp(pRsp);\n\treturn code;\n}", "CodeBleu_score": 66.24716934082923}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t code = 0;\n\nSViewHbRsp hbRsp = {0};\nif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\nterrno = TSDB_CODE_INVALID_MSG;\nreturn -1;\n}\n\nint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\nfor (int32_t i = 0; i < numOfMeta; ++i) {\nSViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\nif (rsp->numOfColumns < 0) {\ntscDebug(\\\"hb to remove view, db:%s, view:%s\\\", rsp->dbFName, rsp->viewName);\ncatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n} else {\ntscDebug(\\\"hb to update view, db:%s, view:%s\\\", rsp->dbFName, rsp->viewName);\ncatalogAsyncUpdateViewMeta(pCatalog, rsp);\n}\n}\n\ntaosArrayDestroy(hbRsp.pMetaRsp);\nhbRsp.pMetaRsp = NULL;\n\ntFreeSViewHbRsp(&hbRsp);\nreturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 63.15276746561595}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\treturn -1;\n\t}\n\n\tint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n\tfor (int32_t i = 0; i < numOfMeta; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tif (rsp->pSchemas[0].colId != PRIMARYKEY_TIMESTAMP_COL_ID) {\n\t\t\t\ttscError(\"invalid colId[%\\\" PRIi16 \\\"] for the first column in view meta rsp msg\", rsp->pSchemas[0].colId);\n\t\t\t\ttFreeSViewHbRsp(&hbRsp);\n\t\t\t\treturn TSDB_CODE_TSC_INVALID_VALUE;\n\t\t\t}\n\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pMetaRsp);\n\thbRsp.pMetaRsp = NULL;\n\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 77.17266536641971}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3SizeCBD *cbd = (TS3SizeCBD *)callbackData;\n\tif (properties->contentLength > 0) {\n\t\tcbd->content_length = properties->contentLength;\n\t} else {\n\t\tcbd->content_length = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 88.26755050874573}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3SizeCBD *cbdata = (TS3SizeCBD *)callbackData;\n\tcbdata->content_length = 0;\n\n\tif (properties) {\n\t\tconst S3HeaderList *headers = properties->headers;\n\t\twhile (headers) {\n\t\t\tif (headers->name && headers->value) {\n\t\t\t\tif (strcasecmp(headers->name, \\\"Content-Length\\\") == 0) {\n\t\t\t\t\tcbdata->content_length = strtoul(headers->value, NULL, 10);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\theaders = headers->next;\n\t\t}\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 50.39037479758427}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3SizeCBD *cbd = (TS3SizeCBD *)callbackData;\n\tif (properties->contentLength > 0) {\n\t\tcbd->content_length = properties->contentLength;\n\t} else {\n\t\tcbd->content_length = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 88.26755050874573}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \\\"%s\\\\rsyncd.conf\\\", tsCheckpointBackupDir);\n#else\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \\\"%srsyncd.conf\\\", tsCheckpointBackupDir);\n#endif\n\n  if (taosMakeDir(tsCheckpointBackupDir) != 0) {\n    uError(\\\"[rsync] create checkpoint backup dir error, dir:%s,\\\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(confDir) != 0) {\n    uError(\\\"[rsync] generate rsync conf file error, dir:%s,\\\" ERRNO_ERR_FORMAT, confDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, sizeof(command), \\\"rsync --daemon --config=%s\\\", confDir);\n  uDebug(\\\"[rsync] command:%s\\\", command);\n  int32_t code = execCommand(command);\n  if (code != 0) {\n    uError(\\\"[rsync] start rsync server failed, command:%s,\\\" ERRNO_ERR_FORMAT, command, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\\\"[rsync] start rsync server successful, command:%s\\\", command);\n  }\n}", "CodeBleu_score": 41.316541089320566}, {"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \\\"net start rsync\\\");\n  uDebug(\\\"[rsync] start rsync server: %s\\\", command);\n  if (system(command) != 0) {\n    uError(\\\"[rsync] start rsync server failed,\\\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n#else\n  if (taosMkdir(tsCheckpointBackupDir, 0755) != 0) {\n    uError(\\\"[rsync] create backup dir error, dir:%s,\\\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsRsyncConfFile) != 0) {\n    uError(\\\"[rsync] generate conf file error, file:%s,\\\" ERRNO_ERR_FORMAT, tsRsyncConfFile, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \\\"rsync --daemon --config=%s\\\", tsRsyncConfFile);\n  uDebug(\\\"[rsync] start rsync server: %s\\\", command);\n  if (execCommand(command) != 0) {\n    uError(\\\"[rsync] start rsync server failed,\\\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n#endif\n}", "CodeBleu_score": 36.792431397167114}, {"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  if (taosMakeDir(path) != 0) {\n    uError(\\\"[rsync] make checkpoint backup dir error, dir:%s,\\\" ERRNO_ERR_FORMAT, path, ERRNO_ERR_DATA);\n\n    return;\n\n  }\n#else\n  if (taosMakeDir(tsCheckpointBackupDir) != 0) {\n    uError(\\\"[rsync] make checkpoint backup dir error, dir:%s,\\\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n\n    return;\n\n  }\n#endif\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsRsyncConfFile) != 0) {\n    uError(\\\"[rsync] generate rsync config file error, file:%s\\\", tsRsyncConfFile);\n\n    return;\n\n  }\n\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \\\"rsync --daemon --config=%s\\\", tsRsyncConfFile);\n\n  uDebug(\\\"[rsync] exec command:%s\\\", command);\n\n  int32_t code = execCommand(command);\n\n  if (code != 0) {\n\n    uError(\\\"[rsync] start rsync server failed, command:%s,\\\" ERRNO_ERR_FORMAT, command, ERRNO_ERR_DATA);\n\n  } else {\n\n    uDebug(\\\"[rsync] start rsync server successful\\\");\n\n  }\n\n}", "CodeBleu_score": 36.23920471594053}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.get(dispatcherId);\nif (current != null) {\ncurrent.getExecutor().shutdownNow();\nif (!current.getExecutor().isTerminated()) {\ntry {\ncurrent.getExecutor().awaitTermination(settings.getDispatcherTerminationTimeoutInSeconds(), TimeUnit.SECONDS);\n} catch (InterruptedException e) {\nlog.warn(\\\"Failed to terminate executor for dispatcher [{}]\\\", dispatcherId, e);\n}\n}\ndispatchers.remove(dispatcherId);\n} else {\nthrow new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n}\n}", "CodeBleu_score": 46.31115439818843}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\nif (dispatcher == null) {\nthrow new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n}\ndispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 74.70925412940166}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.remove(dispatcherId);\nif (current == null) {\nthrow new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n}\ncurrent.getExecutor().shutdown();\n}", "CodeBleu_score": 43.2973480424224}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t Set<TbActorId> children = parentChildMap.get(parent);\n if (children != null) {\n children.stream()\n .filter(childFilter)\n .map(actors::get)\n .filter(child -> child != null)\n .forEach(child -> {\n try {\n if (highPriority) {\n child.tellWithHighPriority(msg);\n } else {\n child.tell(msg);\n }\n } catch (TbActorNotRegisteredException e) {\n log.warn(\\\"Failed to send message [{}] to child actor [{}]\\\", msg, child.getActorId(), e);\n }\n });\n }\n }", "CodeBleu_score": 63.23563897560971}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t Set<TbActorId> children = parentChildMap.get(parent);\n if (children != null) {\n List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n TbActorMailbox childMailbox = actors.get(child);\n if (childMailbox != null) {\n if (highPriority) {\n childMailbox.tellWithHighPriority(msg);\n } else {\n childMailbox.tell(msg);\n }\n } else {\n log.warn(\\\"Actor with id [{}] is not registered!\\\", child);\n}\n }\n } else {\nlog.warn(\\\"Parent actor with id [{}] has no children!\\\", parent);\n}\n }", "CodeBleu_score": 48.93858509711984}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t Set<TbActorId> children = parentChildMap.get(parent);\n if (children != null) {\n List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox == null) {\n log.warn(\\\"Child actor with id [{}] is not registered!\\\", child);\n } else {\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n }\n }\n } else {\n log.warn(\\\"Parent actor with id [{}] is not registered!\\\", parent);\n }\n }", "CodeBleu_score": 49.08317072191175}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyInProgress.get()) {\nif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\ntryInit(1);\n} else {\nmsg.onActorStopped(selfId, stopReason, null);\n}\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(highPriority);\n}\n}", "CodeBleu_score": 47.64940688835298}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyInProgress.get()) {\n\t\tif (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tlog.info(\\\"[{}] Actor is going to be reinitialized due to high priority message: {}\\\", selfId, msg);\n            initActor();\n        } else {\n            msg.onTbActorStopped(stopReason, null);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(highPriority);\n    }\n}", "CodeBleu_score": 55.22381109825404}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroyInProgress.get()) {\n\t\tif (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n\t\t\tif (ready.get()) {\n\t\t\t\tlog.debug(\\\"[{}] Actor is destroyed, reinitializing actor.\\\", selfId);\n                destroyInProgress.set(false);\n                initActor();\n                return;\n            }\n        } else {\n            log.debug(\\\"[{}] Actor is destroyed, notifying message.\\\", selfId);\n            msg.onTbActorStopped(stopReason);\n            return;\n        }\n    }\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue(highPriority);\n}", "CodeBleu_score": 58.21726889549379}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t\tlog.trace(\\\"[{}] Processing mailbox\\\", selfId);\n\n\ttry {\n\n\t\tboolean newMsg = true;\n\n\t\twhile (ready.get() == READY && !highPriorityMsgs.isEmpty() && !normalPriorityMsgs.isEmpty()) {\n\n\t\t\tnewMsg = false;\n\n\t\t\tif (actor.process(this, highPriorityMsgs.poll(), NORMAL_PRIORITY)) {\n\n\t\t\t\tlog.trace(\\\"[{}] Processed high priority message\\\", selfId);\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile (ready.get() == READY && !normalPriorityMsgs.isEmpty()) {\n\n\t\t\tnewMsg = false;\n\n\t\t\tif (actor.process(this, normalPriorityMsgs.poll(), NORMAL_PRIORITY)) {\n\n\t\t\t\tlog.trace(\\\"[{}] Processed normal priority message\\\", selfId);\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (newMsg) {\n\n\t\t\tready.set(NOT_READY);\n\n\t\t}\n\n\t\tif (stopReason == null) {\n\n\t\t\tif (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n\n\t\t\t\ttryProcessQueue(newMsg);\n\n\t\t\t} else {\n\n\t\t\t\tbusy.set(FREE);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdestroy(null);\n\n\t\t}\n\n\t} catch (Throwable t) {\n\n\t\tif (stopReason == null) {\n\n\t\t\tif (isUnrecoverable(t)) {\n\n\t\t\t\tstopReason = TbActorStopReason.UNRECOVERABLE_FAILURE;\n\n\t\t\t} else {\n\n\t\t\t\tlog.debug(\\\"[{}] Failed to process mailbox\\\", selfId, t);\n\n\t\t\t\tProcessFailureStrategy strategy = actor.onProcessFailure(t);\n\n\t\t\t\tif (strategy.isStop()) {\n\n\t\t\t\t\tstopReason = TbActorStopReason.PROCESS_FAILURE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdestroy(t.getCause());\n\n\t}\n\n}", "CodeBleu_score": 36.130409037679016}, {"code": "private void processMailbox(){\n\t\tlog.trace(\\\"[{}] Processing mailbox\\\", selfId);\n        try {\n            if (destroyInProgress.get()) {\n                return;\n            }\n            if (actor.getActorType().isIsolated()) {\n                processQueue(highPriorityMsgs, true);\n                processQueue(normalPriorityMsgs, false);\n            } else {\n                processQueue(highPriorityMsgs, false);\n                processQueue(normalPriorityMsgs, true);\n            }\n            if (stopReason != null) {\n                destroy();\n            } else {\n                ready.set(NOT_READY);\n                busy.set(FREE);\n                tryProcessQueue(false);\n            }\n        } catch (Throwable t) {\n            log.error(\\\"[{}] Failed to process mailbox\\\", selfId, t);\n            if (isUnrecoverable(t)) {\n                stopReason = TbActorStopReason.FAILURE;\n                destroy();\n            } else {\n                try {\n                    actor.onProcessFailure(t);\n                } catch (Throwable t2) {\n                    log.error(\\\"[{}] Failed to process failure\\\", selfId, t2);\n                    stopReason = TbActorStopReason.FAILURE;\n                    destroy();\n                }\n            }\n        }\n    }", "CodeBleu_score": 33.57060888248748}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (!destroyInProgress.get()) {\n\t\tif (stopReason == null) {\n\t\t\tstopReason = TbActorStopReason.KILLED;\n\t\t}\n\t\tdestroyInProgress.set(true);\n\t\tdispatcher.getExecutor().execute(() -> {\n\t\t\ttry {\n\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\\\"[{}] Failed to destroy actor\\\", selfId, t);\n\t\t\t}\n\t\t\tfor (TbActorMsg msg : highPriorityMsgs) {\n\t\t\t\ttry {\n\t\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warn(\\\"[{}] Failed to notify msg: {}\\\", selfId, msg, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (TbActorMsg msg : normalPriorityMsgs) {\n\t\t\t\ttry {\n\t\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warn(\\\"[{}] Failed to notify msg: {}\\\", selfId, msg, t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 56.95261879295401}, {"code": "public void destroy(Throwable cause){\n\t\tif (destroyInProgress.compareAndSet(false, true)) {\n\t\tif (stopReason == null) {\n\t\t\tstopReason = TbActorStopReason.KILLED;\n\t\t}\n\t\tready.set(NOT_READY);\n\t\ttry {\n\t\t\tactor.destroy(stopReason, cause);\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor, cause: {}\", selfId, cause, t);\n\t\t}\n\t\tfor (TbActorMsg msg : highPriorityMsgs) {\n\t\t\ttry {\n\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\"[{}] Failed to notify message: {}\", selfId, msg, t);\n\t\t\t}\n\t\t}\n\t\tfor (TbActorMsg msg : normalPriorityMsgs) {\n\t\t\ttry {\n\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\"[{}] Failed to notify message: {}\", selfId, msg, t);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 53.4179472332186}, {"code": "public void destroy(Throwable cause){\n\t\tif (destroyInProgress.compareAndSet(false, true)) {\n\t\tif (stopReason == null) {\n\t\t\tstopReason = TbActorStopReason.DESTROY_REQUESTED;\n\t\t}\n\t\ttry {\n\t\t\tdispatcher.getExecutor().execute(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tready.set(NOT_READY);\n\t\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t\t\tfor (TbActorMsg msg : highPriorityMsgs) {\n\t\t\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t\t\t}\n\t\t\t\t\tfor (TbActorMsg msg : normalPriorityMsgs) {\n\t\t\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warn(\"[{}] Failed to destroy actor\", selfId, t);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (RejectedExecutionException e) {\n\t\t\tlog.warn(\"[{}] Failed to schedule destroy actor task\", selfId, e);\n\t\t}\n\t}\n}", "CodeBleu_score": 60.67070885436635}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = tenantProfileProvider.findTenantProfileById(tenantId);\n\t\tRateLimits rateLimits = tenantProfile.getRateLimit(api);\n\t\tif (rateLimits == null) {\n\t\t\treturn true;\n\t\t}\n\t\tRateLimitKey key = new RateLimitKey(api, level);\n\t\tTbRateLimits tbRateLimits = rateLimits.get(key);\n\t\tif (tbRateLimits == null) {\n\t\t\treturn true;\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tif (tbRateLimits.getResetTime() < now) {\n\t\t\ttbRateLimits.reset(rateLimits.getPeriodInSeconds(), rateLimits.getMaxPermits());\n\t\t}\n\t\tif (tbRateLimits.getPermits() > 0) {\n\t\t\ttbRateLimits.setPermits(tbRateLimits.getPermits() - 1);\n\t\t\trateLimits.put(key, tbRateLimits);\n\t\t\treturn true;\n\t\t}\n\t\tif (rateLimits.isNotifyWhenExceeded()) {\n\t\t\tRateLimitsTrigger trigger = new RateLimitsTrigger(api, tenantId, level, rateLimits.getPeriodInSeconds(), rateLimits.getMaxPermits());\n\t\t\tnotificationRuleProcessor.process(trigger);\n\t\t}\n\t\treturn false;\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 42.95446404906554}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tTenantProfile tenantProfile = tenantProfileProvider.findTenantProfileById(tenantId, ignoreTenantNotFound);\nif (tenantProfile == null) {\nif (ignoreTenantNotFound) {\nreturn true;\n}\nthrow new TenantProfileNotFoundException(tenantId);\n}\nRateLimitsTrigger rateLimits = tenantProfile.getRateLimit();\nif (rateLimits == null) {\nreturn true;\n}\nString rateLimitKey = getRateLimitKey(api, level);\nTbRateLimits rateLimitsConfig = rateLimits.getLimits().get(rateLimitKey);\nif (rateLimitsConfig == null) {\nrateLimitsConfig = new TbRateLimits();\nrateLimitsConfig.setLimit(rateLimits.getDefaultLimit());\nrateLimitsConfig.setIntervalMs(rateLimits.getDefaultIntervalMs());\nrateLimitsConfig.setLimitPerInterval(rateLimits.getDefaultLimitPerInterval());\nrateLimits.getLimits().put(rateLimitKey, rateLimitsConfig);\n}\nTbRateLimits.Result result = rateLimitsConfig.check(rateLimitsConfig.getLimit(), rateLimitsConfig.getIntervalMs(), rateLimitsConfig.getLimitPerInterval());\nif (!result.isAllowed()) {\nprocessRateLimitNotification(api, tenantId, rateLimitsConfig, result, level);\n}\nreturn result.isAllowed();\n}", "CodeBleu_score": 45.41451246339756}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isNullUid()) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = tenantProfileProvider.findTenantProfileById(tenantId);\n\t\tif (tenantProfile.isRateLimitingEnabled()) {\n\t\t\tRateLimitsTrigger rateLimits = tenantProfile.getRateLimiting();\n\t\t\tif (rateLimits.isEnabled()) {\n\t\t\t\tRateLimitKey key = new RateLimitKey(api, level);\n\t\t\t\tTbRateLimits tbRateLimits = rateLimits.getRateLimit(key);\n\t\t\t\tif (tbRateLimits.checkAndIncrement(api.getRateLimit())) {\n\t\t\t\t\tnotificationRuleProcessor.processRateLimitNotification(tenantId, api, level, tbRateLimits.getRemainingTime());\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (!ignoreTenantNotFound) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.26884803077209}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nlog.trace(\\\"DTLS sessions in-memory store cleanup started. Expiration time: [{}]. Current time: [{}].\\\", expirationTime, currentTime);\n\ndtlsSessionsMap.entrySet().removeIf(entry -> entry.getValue().getLastActivityTime() < expirationTime);\n\nlog.trace(\\\"DTLS sessions in-memory store cleanup finished. Expiration time: [{}]. Current time: [{}].\\\", expirationTime, currentTime);\n\n}", "CodeBleu_score": 36.8612306402623}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nlog.trace(\\\"DTLS session inactivity timeout: [{}], expiration time: [{}]\\\", dtlsSessionInactivityTimeout, expirationTime);\n\nfor (InetSocketAddress remotePeer : dtlsSessionsMap.keySet()) {\n\nTbCoapDtlsSessionInfo sessionInfo = dtlsSessionsMap.get(remotePeer);\n\nlong lastActivityTime = sessionInfo.getLastActivityTime();\n\nif (lastActivityTime < expirationTime) {\n\nlog.trace(\\\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\\\", remotePeer, lastActivityTime);\n\ndtlsSessionsMap.remove(remotePeer);\n\n}\n\n}\n\n}", "CodeBleu_score": 34.81842080487188}, {"code": "public void evictTimeoutSessions(){\n\t\nlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\n\nfor (InetSocketAddress remotePeer : dtlsSessionsMap.keySet()) {\n\nTbCoapDtlsSessionInfo dtlsSessionInfo = dtlsSessionsMap.get(remotePeer);\nlong lastActivityTime = dtlsSessionInfo.getLastActivityTime();\n\nif (lastActivityTime < expirationTime) {\n\nlog.trace(\\\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\\\", remotePeer, lastActivityTime);\n\ndtlsSessionsMap.remove(remotePeer);\n\n}\n}\n}", "CodeBleu_score": 34.53993430675733}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream().flatMap(entry -> {\nList<TsKvEntry> ts = new ArrayList<>();\nentry.getValue().forEach(tsKv -> {\nKvEntry kvEntry = parseValue(tsKv.get(KEY).asText(), tsKv.get(VALUE));\nts.add(new BasicTsKvEntry(tsKv.get(TS).asLong(), kvEntry));\n});\nreturn ts.stream();\n}).collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 56.574256469504}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (!CollectionUtils.isEmpty(timeseries)) {\n\t\treturn timeseries.entrySet().stream().flatMap(entry -> {\n\t\t\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\t\t\tentry.getValue().forEach(ts -> {\n\t\t\t\tKvEntry kvEntry = parseValue(ts.get(KEY).asText(), ts.get(VALUE));\n\t\t\t\ttsKvEntries.add(new BasicTsKvEntry(ts.get(TS).asLong(), kvEntry));\n\t\t\t});\n\t\t\treturn tsKvEntries.stream();\n\t\t}).collect(Collectors.toList());\n\t} else {\n\t\treturn Collections.emptyList();\n\t}\n}", "CodeBleu_score": 57.135136160273056}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream().flatMap(entry -> {\nList<TsKvEntry> result = new ArrayList<>();\nfor (JsonNode jsonNode : entry.getValue()) {\nTsKvEntry tsKvEntry = parseTsValue(entry.getKey(), jsonNode);\nif (tsKvEntry != null) {\nresult.add(tsKvEntry);\n}\n}\nreturn result.stream();\n}).collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 52.273472252254635}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<>();\n\trequest.put(\\\"refreshToken\\\", refreshToken);\n\n\tMap<String, String> response = loginRestTemplate.postForObject(baseURL + \\\"/api/auth/token\\\", request, Map.class);\n\n\tmainToken = response.get(\\\"token\\\");\n\tmainTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(Long.parseLong(response.get(\\\"expiresIn\\\")));\n\trefreshToken = response.get(\\\"refreshToken\\\");\n\trefreshTokenExpTs = mainTokenExpTs + TimeUnit.SECONDS.toMillis(Long.parseLong(response.get(\\\"refreshTokenExpiresIn\\\")));\n\tclientServerTimeDiff = TimeUnit.SECONDS.toMillis(Long.parseLong(response.get(\\\"clientServerTimeDiff\\\")));\n}", "CodeBleu_score": 26.62958302865145}, {"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<>();\n\trequest.put(\\\"refreshToken\\\", refreshToken);\n    try {\n        String refreshTokenUrl = baseURL + \\\"/api/auth/token\\\";\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n        HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(request, headers);\n        ResponseEntity<JwtPair> response = loginRestTemplate.postForEntity(refreshTokenUrl, requestEntity, JwtPair.class);\n        if (response.getStatusCode().is2xxSuccessful()) {\n            JwtPair jwtPair = response.getBody();\n            mainToken = jwtPair.getToken();\n            mainTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(jwtPair.getExpireInSeconds()) - clientServerTimeDiff;\n            refreshToken = jwtPair.getRefreshToken();\n            refreshTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(jwtPair.getRefreshExpireInSeconds()) - clientServerTimeDiff;\n        }\n    } catch (Exception e) {\n        throw handleException(e);\n    }\n}", "CodeBleu_score": 22.30531002570514}, {"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<>();\n\trequest.put(\\\"refreshToken\\\", refreshToken);\n    request.put(\\\"tenantId\\\", \\\"\\\");\n    request.put(\\\"client_secret\\\", \\\"\\\");\n    request.put(\\\"client_id\\\", \\\"\\\");\n    request.put(\\\"grant_type\\\", \\\"refresh_token\\\");\n    try {\n        String refreshTokenResponse = loginRestTemplate.postForObject(\n                baseURL + \\\"/api/auth/token\\\", request,\n                String.class);\n        JSONObject response = new JSONObject(refreshTokenResponse);\n        mainToken = response.getString(\\\"token\\\");\n        mainTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(response.getInt(\\\"expires_in\\\"));\n        refreshToken = response.getString(\\\"refreshToken\\\");\n        refreshTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(response.getInt(\\\"refreshExpiresIn\\\"));\n        clientServerTimeDiff = TimeUnit.SECONDS.toMillis(response.getInt(\\\"clientServerTimeDiff\\\"));\n    } catch (Exception e) {\n        throw handleException(e);\n    }\n}", "CodeBleu_score": 25.673996450066728}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", password);\n\n long ts = System.currentTimeMillis();\n\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n\n setTokenInfo(ts, tokenInfo.getBody());\n\n }", "CodeBleu_score": 56.24268296677626}, {"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", password);\n loginRequest.put(\\\"rememberMe\\\", \\\"false\\\");\n long ts = System.currentTimeMillis();\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 48.185626096456666}, {"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", password);\n loginRequest.put(\\\"rememberMe\\\", \\\"false\\\");\n loginRequest.put(\\\"captchaResponse\\\", \\\"\\\");\n loginRequest.put(\\\"activateToken\\\", \\\"\\\");\n loginRequest.put(\\\"resetPasswordToken\\\", \\\"\\\");\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n setTokenInfo(System.currentTimeMillis(), tokenInfo.getBody());\n }", "CodeBleu_score": 37.79436837307506}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 88.32580704150976}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 88.32580704150976}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n    ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n    return Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\n    if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n        return Optional.empty();\n    } else {\n        throw exception;\n    }\n}\n}", "CodeBleu_score": 91.42067755948297}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials();\ndeviceWithCredentials.setDevice(device);\ndeviceWithCredentials.setCredentials(credentials);\nResponseEntity<Device> deviceResponse = restTemplate.postForEntity(baseURL + \\\"/api/device-with-credentials\\\", deviceWithCredentials, Device.class);\nreturn Optional.ofNullable(deviceResponse.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 44.09713854621188}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nResponseEntity<Device> deviceResponse = restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class);\nreturn Optional.ofNullable(deviceResponse.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 69.43272881465026}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nResponseEntity<Device> response = restTemplate.postForEntity(baseURL + \\\"/api/device-with-credentials\\\", new DeviceWithCredentials(device, credentials), Device.class);\nreturn Optional.ofNullable(response.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 36.61576353081792}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (typeof val === \"undefined\") {\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, addr);\n\t\t});\n\t} else {\n\t\tlet brightness = Math.floor(val / 100 * 15);\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, brightness);\n\t}\n\treturn this;\n}", "CodeBleu_score": 51.46390337454453}, {"code": "brightness(addr, val){\n\t\tif (typeof addr === \"undefined\") {\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tif (typeof val === \"undefined\") {\n\t\t\tval = addr;\n\t\t\taddr = 0;\n\t\t}\n\t\tval = Math.max(0, Math.min(100, val));\n\t\tval = Math.round(val / 100 * 15);\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, val);\n\t}\n\treturn this;\n}", "CodeBleu_score": 66.972381489293}, {"code": "brightness(addr, val){\n\t\tlet state = priv.get(this);\n\tlet brightness = 0;\n\n\tif (typeof addr === \\\"undefined\\\") {\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t\treturn this;\n\t}\n\n\tif (typeof val === \\\"undefined\\\") {\n\t\tbrightness = addr;\n\t} else {\n\t\tbrightness = Math.round(val / 100 * 15);\n\t}\n\n\tif (brightness < 0) {\n\t\tbrightness = 0;\n\t} else if (brightness > 15) {\n\t\tbrightness = 15;\n\t}\n\n\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, brightness);\n\treturn this;\n}", "CodeBleu_score": 52.79316959764079}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tconst self = this;\n\tconst device = {};\n\n\tfor (const key in LedControl.prototype) {\n\t\tif (self[key]) {\n\t\t\tdevice[key] = self[key].bind(self, addr);\n\t\t}\n\t}\n\n\tfor (const key in self) {\n\t\tif (self[key] instanceof Function) {\n\t\t\tdevice[key] = self[key].bind(self, addr);\n\t\t}\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 30.24029081816152}, {"code": "device(addr){\n\t\tconst device = Object.create(LedControl.prototype, {\n\t\taddress: {\n\t\t\tvalue: addr\n\t\t}\n\t});\n\n\tfor (const key in LedControl.prototype) {\n\t\tif (LedControl.prototype.hasOwnProperty(key)) {\n\t\t\tdevice[key] = device[key].bind(device);\n\t\t}\n\t}\n\n\tfor (const key in this) {\n\t\tif (this.hasOwnProperty(key)) {\n\t\t\tdevice[key] = this[key];\n\t\t}\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 27.269367934866327}, {"code": "device(addr){\n\t\tlet self = this;\n\tlet methods = Object.keys(LedControl.prototype).concat(Object.keys(this));\n\tlet device = {};\n\n\tfor (let i = 0; i < methods.length; i++) {\n\t\tif (typeof self[methods[i]] === \"function\") {\n\t\t\tdevice[methods[i]] = self[methods[i]].bind(self, addr);\n\t\t}\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 29.825583801425665}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tconst {\n\t\tgetDuration = noop,\n\t\tgetCallback = noop\n\t} = methods;\n\n\t/**\n\t * The function \"schedule\" schedules a method to be called on each element in the collection, with a specified duration and callback.\nIf the duration is not provided, it defaults to 1000 milliseconds.\nIt ensures the callback is a function, collects promises for each method call, and invokes the callback once all promises are resolved.\n\t */\n\tconst schedule = (method, duration, callback) => {\n\t\tconst promises = [];\n\t\tconst durationMs = getDuration(duration);\n\t\tconst callbackFn = getCallback(callback);\n\n\t\t// Ensure the callback is a function\n\t\tif (typeof callbackFn !== \\\"function\\\") {\n\t\t\tcallbackFn = noop;\n\t\t}\n\n\t\t// Schedule the method to be called on each element\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tconst element = this[i];\n\t\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst result = element[method]();\n\t\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\t\tresult.then(resolve).catch(reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}, durationMs);\n\t\t\t});\n\t\t\tpromises.push(promise);\n\t\t}\n\n\t\t// Invoke the callback once all promises are resolved\n\t\tPromise.all(promises).then(() => {\n\t\t\tcallbackFn();\n\t\t});\n\t};\n\n\t// Add the callback reconciliation methods to the target object\n\tmethods.forEach(method => {\n\t\ttarget[method] = schedule.bind(target, method);\n\t});\n}", "CodeBleu_score": 37.15080343765981}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method + \\\"WithDelay\\\"] = function(duration, callback = noop) {\n\t\t\tconst promises = [];\n\t\t\tconst length = this.length;\n\n\t\t\tcallback = typeof callback === \\\"function\\\" ? callback : noop;\n\t\t\tduration = typeof duration === \\\"number\\\" ? duration : 1000;\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst instance = this[i];\n\t\t\t\tpromises.push(instance[method]());\n\t\t\t}\n\n\t\t\treturn Promise.all(promises).then(() => {\n\t\t\t\tsetTimeout(callback, duration);\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 34.21727659441567}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tconst noop = () => {};\n\nmethods.forEach(method => {\n  target[`_${method}`] = function(duration, callback) {\n    const promises = [];\n    const length = this.length;\n    let i = 0;\n\n    if (typeof duration === \\\"function\\\") {\n      callback = duration;\n      duration = 1000;\n    } else if (typeof callback !== \\\"function\\\") {\n      callback = noop;\n    }\n\n    for (i = 0; i < length; i++) {\n      const element = this[i];\n      const result = element[method]();\n      if (result && typeof result.then === \\\"function\\\") {\n        promises.push(result);\n      }\n    }\n\n    if (promises.length) {\n      Promise.all(promises).then(() => {\n        callback(this);\n      });\n    } else {\n      callback(this);\n    }\n\n    return this;\n  };\n});\n}", "CodeBleu_score": 49.28277338090487}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\n}", "CodeBleu_score": 1.3739519390252413}, {"code": "listen(){\n\t\tconst state = priv.get(this);\n\tlet input = \\\"\\\";\n\n\t// Start the read loop\n\tthis.io.serialRead(state.portId, (data) => {\n\t\t// Convert the data to a string\n\t\tinput += data.toString();\n\n\t\t// Split the string into sentences\n\t\tconst sentences = input.split(\\\"\\\\r\\\n\\\");\n\n\t\t// Process each sentence\n\t\tfor (let i = 0; i < sentences.length - 1; i++) {\n\t\t\t// If the sentence is valid, process it\n\t\t\tif (this.parseNmeaSentence(sentences[i])) {\n\t\t\t\t// If a callback was specified, call it\n\t\t\t\tif (typeof this.sentenceCallback === \\\"function\\\") {\n\t\t\t\t\tthis.sentenceCallback(this);\n            }\n        }\n\n        // Remove the processed sentence from the input string\n        input = sentences.slice(i + 1).join(\\\"\\\\r\\\n\\\");\n      }\n    });\n  }", "CodeBleu_score": 57.61813980397993}, {"code": "listen(){\n\t\tconst state = priv.get(this);\n\tconst io = this.io;\n\n\t// If we are already listening, return\n\tif (state.listening) {\n\t\treturn;\n\t}\n\n\tstate.listening = true;\n\n\t// Read data from the serial port\n\tlet input = \\\"\\\";\n\n\tconst read = () => {\n\t\tio.serialRead(state.portId, (data) => {\n\t\t\tinput += data.toString();\n\n\t\t\t// Split the input into sentences\n\t\t\tconst sentences = input.split(\\\"\\\\r\\\n\\\");\n\n\t\t\t// The first sentence is incomplete, so append it to the\n\t\t\t// last sentence of the array\n\t\t\tsentences[0] = sentences[sentences.length - 1] + sentences[0];\n\n\t\t\t// Remove the last element of the array, which is an empty string\n\t\t\tsentences.pop();\n\n\t\t\t// Process each sentence\n\t\t\tsentences.forEach(sentence => {\n\t\t\t\t// If the sentence is not empty, process it\n\t\t\t\tif (sentence) {\n\t\t\t\t\tthis.parseNmeaSentence(sentence);\n\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Set the input string to the last sentence\n\t\t\tinput = sentences[sentences.length - 1];\n\t\t});\n\t};\n\n\t// Start the read loop\n\tread();\n}", "CodeBleu_score": 42.56617920795107}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint16_t buffer_size;\n\tuint8_t channels;\n\n\tchannels = 0U;\n\n\tfor (uint8_t i = 0U; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].channel_id < AD559X_PIN_MAX) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tif (channels == 0U) {\n\t\tLOG_ERR(\"No channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size = (channels * sequence->resolution + 7U) / 8U;\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size too small (%d < %d)\",\n\t\t\tsequence->buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\n\treturn 0;\n}", "CodeBleu_score": 33.641311710561844}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint16_t buffer_size = 0;\n\tuint8_t channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].channel_id >= AD559X_PIN_MAX) {\n\t\t\tLOG_ERR(\"invalid channel id %d\", sequence->channels[i].channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].channel_id != i) {\n\t\t\tLOG_ERR(\"invalid channel id order\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuffer_size += sizeof(uint16_t);\n\t\tchannels++;\n\t}\n\n\tif (buffer_size > data->buffer_size) {\n\t\tLOG_ERR(\"buffer size too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\n\treturn 0;\n}", "CodeBleu_score": 34.8485003228548}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0U;\n\tuint32_t buffer_size = 0U;\n\n\t/* Count the number of channels */\n\tfor (uint8_t i = 0U; i < sequence->channels; i++) {\n\t\tif (sequence->channels == 0U) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sequence->channels & BIT(sequence->channels)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tif (channels == 0U) {\n\t\tLOG_ERR(\"No channels selected\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Calculate the size of the buffer */\n\tbuffer_size = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tbuffer_size *= 2U;\n\t}\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size is too small (required: %d, available: %d)\",\n\t\t\tbuffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\n\treturn 0;\n}", "CodeBleu_score": 44.05050781426911}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.478133658581989}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.478133658581989}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.478133658581989}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct device *dev = ctx->dev;\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\n\tdata->channels = POPCOUNT(sequence->channels);\n\tdata->repeat_buffer = data->buffer + data->channels;\n\n\tadc_context_update_buffer_pointer(ctx, data->buffer, data->repeat_buffer,\n\t\t\t\t\t 0);\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 55.81568805532022}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct device *dev = ctx->dev;\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tuint8_t channels;\n\tsize_t needed;\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"insufficient buffer size\");\n\t\tadc_context_abort_sampling(ctx);\n\t\treturn;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = data->buffer + needed;\n\n\tdata->channels = channels;\n\tdata->adc_conf = sequence->channels;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 45.20439675191826}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct device *dev = ctx->dev;\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tstruct adc_ad559x_data *data = dev->data;\n\n\tdata->repeat_buffer = data->buffer + sequence->channels * sequence->buffer_size;\n\n\tdata->channels = sequence->channels;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 59.35074018249532}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 78.04269422509998}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 78.04269422509998}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 92.83809398184619}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\tLOG_DBG(\\\"adc_ad559x_acquisition_thread: started\\\");\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (data->channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\\\"adc_ad559x_read_channel failed: %d\\\", ret);\n\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\n\t\t\t\t*data->buffer++ = result;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->buffer - data->repeat_buffer);\n\n\t}\n\n}", "CodeBleu_score": 53.323772325960384}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (data->channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = result;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->buffer, sizeof(uint16_t) * AD559X_PIN_MAX);\n\t}\n}", "CodeBleu_score": 58.19504509666643}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tconst struct device *mfd_dev = data->dev->config->mfd_dev;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (data->channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = result;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->buffer,\n\t\t\t\t\t  data->buffer, data->channels);\n\t}\n}", "CodeBleu_score": 53.666229154840785}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tuint8_t config;\n\tint rc = 0;\n\n\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\twhile (!(config & ADS1112_CONFIG_MASK_READY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 63.39791274240405}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tuint8_t config_reg;\n\tint rc = 0;\n\n\tif (k_sem_take(&data->acq_sem, data->ready_time) != 0) {\n\t\trc = -EBUSY;\n\t} else if (ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg) != 0) {\n\t\trc = -EIO;\n\t} else if (!(config_reg & ADS1112_CONFIG_MASK_READY)) {\n\t\trc = -EBUSY;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 33.493032785396856}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t", "CodeBleu_score": 4.195926656658344}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t buffer_size = 0;\n\tuint16_t num_samplings = 0;\n\tuint16_t num_extra_samplings = 0;\n\tuint16_t num_channels = 0;\n\n\tif (sequence->options) {\n\t\tnum_extra_samplings = sequence->options->extra_samplings;\n\t}\n\n\tnum_channels = sequence->channels;\n\n\tif (sequence->options && sequence->options->extra_samplings) {\n\t\tnum_samplings = sequence->options->extra_samplings + 1;\n\t} else {\n\t\tnum_samplings = 1;\n\t}\n\n\tbuffer_size = num_samplings * num_channels;\n\n\tif (buffer_size < num_samplings * num_channels) {\n\t\tLOG_ERR(\"Buffer size too small. Required: %d, Available: %d\", buffer_size, num_samplings * num_channels);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.37079319726698}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t buffer_size = 0;\n\tuint16_t options = sequence->options;\n\tuint16_t channels = sequence->channels;\n\tuint16_t channel_id = sequence->channels->channel_id;\n\tuint16_t acq_time = sequence->channels->acquisition_time;\n\n\tif (options & ADC_SEQ_OPTION_EXTRA_SAMPLING) {\n\t\tif (options & ADC_SEQ_OPTION_OVERWRITE) {\n\t\t\tbuffer_size = (options & ADC_SEQ_OPTION_SAMPLING_MASK) + 1;\n\t\t} else {\n\t\t\tbuffer_size = (options & ADC_SEQ_OPTION_SAMPLING_MASK) * channels + 1;\n\t\t}\n\t} else {\n\t\tif (options & ADC_SEQ_OPTION_OVERWRITE) {\n\t\t\tbuffer_size = (options & ADC_SEQ_OPTION_SAMPLING_MASK) + 1;\n\t\t} else {\n\t\t\tbuffer_size = (options & ADC_SEQ_OPTION_SAMPLING_MASK) * channels + 1;\n\t\t}\n\t}\n\n\tif (buffer_size < ADC_BUFFER_SIZE_MIN) {\n\t\tLOG_ERR(\"ADC buffer size (%d) is too small. Minimum size is %d\", buffer_size, ADC_BUFFER_SIZE_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.32378008709289}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size = 0;\n\tsize_t buffer_size = 0;\n\tsize_t i;\n\n\tif (sequence->options) {\n\t\trequired_buffer_size = sequence->options->extra_samplings + 1;\n\t} else {\n\t\trequired_buffer_size = 1;\n\t}\n\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tbuffer_size = sequence->channels[i].buffer_cb->buffer_size;\n\t\tif (buffer_size < required_buffer_size) {\n\t\t\tLOG_ERR(\"Buffer size %d is too small for the sequence\", buffer_size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.58340960232531}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\t/* Check if the sequence is valid */\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Assign the buffer to the device data */\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/* Start the ADC conversion */\n\trc = ads1112_channel_setup(dev, &sequence->channels[0]);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\tif (wait) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 69.40220032318857}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tint rc;\n\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *config = dev->config;\n\n\t/* Check if the ADC is ready to take a new sample */\n\trc = ads1112_wait_data_ready(dev);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Check the ADC sequence parameters */\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Assign the sequence buffer to the device data */\n\tdata->buffer = sequence->buffer;\n\n\t/* Update the ADC context */\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/* Start the ADC read */\n\trc = ads1112_read_sample(dev, data->buffer);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Wait for the ADC read to complete */\n\tif (wait) {\n\t\trc = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 79.50317002501137}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tif (wait) {\n\t\tadc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.613110333651}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 83.93704911631743}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 83.49981133117666}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Applying properties failed\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 83.91809545300927}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret = 0;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t} else {\n\t\t\tLOG_ERR(\\\"DMIC device is not configured\\\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t} else {\n\t\t\tLOG_ERR(\\\"DMIC device is not active\\\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\\\"Unsupported DMIC trigger command (%d)\\\", cmd);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret == 0) {\n\t\tdata->state = cmd;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 59.237269279022684}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t", "CodeBleu_score": 4.702895929663203}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"DMIC not in configured state\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\\\"start failed (%d)\\\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC not in active state\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\\\"stop failed (%d)\\\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.91193163247723}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 89.91130507985382}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 85.80212760663085}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t} else {\n\t\tdata->display_enabled = false;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\\\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ON;\\\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 78.82638913239029}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 52.41497436017841}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint rc;\n\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\n\t}\n\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_take(&data->lock_sem, K_FOREVER);\n\n#endif\n\n\n\trc = gpio_pin_get_dt(&config->busy_gpio);\n\n\tif (rc < 0) {\n\n\t\tLOG_ERR(\\\"Could not get busy GPIO status: %d\\\", rc);\n\n\t}\n\n#ifdef CONFIG_MULTITHREADING\n\n\tk_sem_give(&data->lock_sem);\n\n#endif\n\n\n\treturn rc;\n\n}", "CodeBleu_score": 66.99542510458718}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 54.19481735706211}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *drv_data = dev->data;\n\tbool is_invalid;\n\tint err;\n\n\tif (offset > config->size || offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tis_invalid = bbram_emul_check_invalid(dev);\n\tif (is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\terr = bbram_emul_check_standby_power(dev);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = bbram_emul_check_power(dev);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmemcpy(data, drv_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 70.36981402644584}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\t/* Check if the requested size is valid */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read size does not exceed the memory bounds */\n\tif (offset + size > config->size) {\n\t\treturn -EFBIG;\n\t}\n\n\t/* Check if the requested memory region is invalid */\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Check if the BBRAM incurred a standby power failure */\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Check if the BBRAM incurred a power failure */\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data from the BBRAM to the provided buffer */\n\tmemcpy(data, bbram_data->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 71.28485623263035}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *drv_data = dev->data;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, drv_data->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 71.45349358918621}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size ||\n\t    bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 97.77377392351411}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing required device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = device_get_binding(argv[1], bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Could not get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.7091495325309}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\tuint32_t dev_num;\n\n\tif (argc < 4) {\n\t\tshell_error(sh, \"Missing required argument: <device>\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = parse_u32(argv[3], &dev_num);\n\tif (err) {\n\t\tshell_error(sh, \"Invalid device number: %s\", argv[3]);\n\t\treturn err;\n\t}\n\n\t*bbram_dev = device_get_binding(DT_LABEL(DT_NODELABEL(bbram_0)));\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Could not find BBRAM device: %s\", argv[3]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.68103128344637}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Missing required arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[2]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Cannot find BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 64.81623212584195}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\t/* Calculate already read bytes */\n\tuint16_t read_bytes = h4->rx.remaining - h4->rx.hdr_len;\n\n\t/* Read remaining bytes from UART FIFO */\n\tif (uart_fifo_read(cfg->uart, &h4->rx.hdr[h4->rx.hdr_len], h4->rx.remaining - h4->rx.hdr_len) != h4->rx.remaining - h4->rx.hdr_len) {\n\t\tLOG_WRN(\\\"Unable to read H:4 header\\\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\t/* Update remaining bytes */\n\th4->rx.remaining -= h4->rx.hdr_len;\n}", "CodeBleu_score": 60.73866687859017}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tsize_t read;\n\n\t/* Calculate number of bytes already read */\n\tread = h4->rx.remaining - h4->rx.hdr_len;\n\n\t/* Attempt to read remaining bytes from the UART FIFO */\n\tif (uart_fifo_read(cfg->uart, &h4->rx.hdr[h4->rx.hdr_len], h4->rx.remaining - h4->rx.hdr_len) != h4->rx.remaining - h4->rx.hdr_len) {\n\t\tLOG_WRN(\\\"Unable to read H:4 header (type 0x%02x)\\\", h4->rx.type);\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\t/* Update remaining byte count */\n\th4->rx.remaining = read + h4->rx.hdr_len;\n}", "CodeBleu_score": 55.80803163795965}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\t/* Calculate already read bytes */\n\tsize_t read = h4->rx.remaining - h4->rx.hdr_len;\n\n\t/* Read remaining bytes */\n\tif (uart_fifo_read(cfg->uart, &h4->rx.hdr[h4->rx.hdr_len], h4->rx.remaining - h4->rx.hdr_len) != h4->rx.remaining - h4->rx.hdr_len) {\n\t\tLOG_ERR(\\\"Unable to read H:4 header\\\");\n\t\treturn;\n\t}\n\n\t/* Update remaining byte count */\n\th4->rx.hdr_len += h4->rx.remaining - h4->rx.hdr_len;\n}", "CodeBleu_score": 47.10079794180489}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t bytes_read = 0;\n\tuint8_t tmp[33];\n\n\twhile (len) {\n\t\tint ret;\n\n\t\tif (len > sizeof(tmp)) {\n\t\t\tret = uart_fifo_read(uart, tmp, sizeof(tmp));\n\t\t} else {\n\t\t\tret = uart_fifo_read(uart, tmp, len);\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn bytes_read;\n\t\t} else if (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_read += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 44.559303607006186}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tconst struct uart_config *cfg = uart->config;\n\tuint8_t tmp[33];\n\tsize_t bytes_read = 0;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tsize_t bytes_to_read = min(len, sizeof(tmp));\n\n\t\tret = uart_fifo_read(uart, tmp, bytes_to_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn bytes_read;\n\t\t}\n\n\t\tbytes_read += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 42.23868821728605}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t total = 0;\n\n\twhile (len) {\n\t\tint ret = uart_fifo_read(uart, buf, min(len, sizeof(buf)));\n\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn total;\n\t\t}\n\n\t\tlen -= ret;\n\t\ttotal += ret;\n\t}\n\n\treturn total;\n}", "CodeBleu_score": 53.54041907483159}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tk_spinlock_key_t key = k_spin_lock(&chan->data->lock);\n\tint16_t hop = ZBUS_PRIORITY_LOWEST;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;\n\t     i < limit; ++i) {\n\t\tconst struct zbus_observer *obs = STRUCT_SECTION_GET(zbus_channel_observation, i, &chan->data->observations)->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->priority < hop) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->data->hop = hop;\n\tk_spin_unlock(&chan->data->lock, key);\n}", "CodeBleu_score": 36.63645961561578}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tk_spinlock_key_t key = k_spin_lock(&chan->data->lock);\n\n\tuint16_t hop = 0;\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;\n\t     i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hop < obs->data->priority) {\n\t\t\thop = obs->data->priority;\n\t\t}\n\t}\n\n\tchan->data->hop = hop;\n\n\tk_spin_unlock(&chan->data->lock, key);\n}", "CodeBleu_score": 66.3224834652003}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tk_spinlock_key_t key = k_spin_lock(&chan->data->lock);\n\tint16_t hop = ZBUS_PRIORITY_LOWEST;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t_ZBUS_ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->data->priority < hop) {\n\t\t\thop = obs->data->priority;\n\t\t}\n\t}\n\n\tchan->data->hop = hop;\n\tk_spin_unlock(&chan->data->lock, key);\n}", "CodeBleu_score": 69.94027634443474}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > chan->data->highest_observer_priority) {\n\t\t\t\tchan_highest_observer_priority = chan->data->highest_observer_priority;\n\t\t\t}\n\t\t}\n\n\t\tobs->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 17.849396751541473}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint obs_highest_channel_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (obs_highest_channel_priority > chan->data->highest_observer_priority) {\n\t\t\t\tobs_highest_channel_priority = chan->data->highest_observer_priority;\n\t\t\t}\n\t\t}\n\t\tobs->data->highest_channel_priority = obs_highest_channel_priority;\n\t}\n}", "CodeBleu_score": 17.93137084879862}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tobs->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 17.981858682861713}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 76.3237572885521}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 76.3237572885521}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 76.3237572885521}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n}", "CodeBleu_score": 4.451885662912518}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t//    assert_param(IS_ETH_INT(Int));\n//    assert_param(IS_ETH_INT_EN(Int));\n\n    if (enable) {\n        ETH->INT_EN |= Int;\n        if (Int & ETH_INT_RX) {\n            ETH->INT_EN_b.NIS = TRUE;\n        } else if (Int & ETH_INT_TX) {\n            ETH->INT_EN_b.TIS = TRUE;\n        } else if (Int & ETH_INT_ERROR) {\n            ETH->INT_EN_b.ERIS = TRUE;\n        }\n    } else {\n        ETH->INT_EN &= ~Int;\n        if (ETH->INT_EN_b.NIS == FALSE) {\n            ETH->INT_EN_b.NIS = FALSE;\n        }\n        if (ETH->INT_EN_b.TIS == FALSE) {\n            ETH->INT_EN_b.TIS = FALSE;\n        }\n        if (ETH->INT_EN_b.ERIS == FALSE) {\n            ETH->INT_EN_b.ERIS = FALSE;\n        }\n    }\n}", "CodeBleu_score": 58.356572891028065}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t}", "CodeBleu_score": 4.451885662912518}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tuint32_t descAddr = ETH->TDESLA;\nuint32_t i;\nETH_TX_DESC *desc = (ETH_TX_DESC *)descAddr;\n\nfor (i = 0; i < 16; i++) {\nINNER_ETH_TX_DESC *innerDesc = (INNER_ETH_TX_DESC *)desc;\n\nif (innerDesc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_DEVICE) {\ndescAddr = descAddr + sizeof(ETH_TX_DESC);\n\nif (descAddr == ETH->TDESLA) {\nreturn 0;\n}\n\ndesc = (ETH_TX_DESC *)descAddr;\n} else {\nreturn desc;\n}\n}\n\nreturn 0;\n}", "CodeBleu_score": 43.1331496774916}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *buf = (ETH_TX_DESC *)ETH->TDESLA;\n\nwhile (1) {\nINNER_ETH_TX_DESC *desc = (INNER_ETH_TX_DESC *)buf;\nuint8_t first = desc->TX_0.TX0_b.FS;\nuint8_t last = desc->TX_0.TX0_b.LS;\n\nif (first == last) {\nif (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_DEVICE) {\nbuf->bufAddr = GLB_ConvertToMappingFromAddr(buf->bufAddr);\nbuf->nextDescAddr = GLB_ConvertToMappingFromAddr(buf->nextDescAddr);\nbuf = (ETH_TX_DESC *)buf->nextDescAddr;\n} else {\nreturn buf;\n}\n} else {\nbuf->bufAddr = GLB_ConvertToMappingFromAddr(buf->bufAddr);\nbuf->nextDescAddr = GLB_ConvertToMappingFromAddr(buf->nextDescAddr);\nbuf = (ETH_TX_DESC *)buf->nextDescAddr;\n}\n}\n}", "CodeBleu_score": 40.169009655178776}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESA;\n\tuint32_t i = 0;\n\n\twhile (i < ETH_TX_DESC_NUM) {\n\t\tif (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_DEVICE) {\n\t\t\tdesc = (ETH_TX_DESC *)desc->nextDescAddr;\n\t\t\ti++;\n\t\t} else {\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 42.2489466051651}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tcy_rslt_t result;\n\trt_uint32_t cyp_channel;\n\n\tRT_ASSERT(device != RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\t/* get current dac channel */\n\tcyp_channel = cyp_dac_get_channel(channel);\n\n\t/*DAC device init*/\n\tresult = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\n\tif (result != RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\n\t/*DAC Outputenable*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, value, &csdidac_context);\n\tif (result != RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 69.26364517111988}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tcy_rslt_t result;\n\trt_uint32_t cyp_channel;\n\tRT_ASSERT(device != RT_NULL);\n\tcyhal_dac_t *dac_device;\n\tdac_device = device->parent.user_data;\n\t/* get current dac channel*/\n\tcyp_channel = cyp_dac_get_channel(channel);\n\t/*DAC device init*/\n\tresult = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\tif (result != RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\t/*DAC Output Enable*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, value, &csdidac_context);\n\tif (result != RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 69.26364517111988}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_uint32_t cyp_channel;\n\tcy_rslt_t result;\n\trt_uint32_t dac_value;\n\n\tRT_ASSERT(device != RT_NULL);\n\tRT_ASSERT(value != RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\t/* get current dac channel */\n\tcyp_channel = cyp_dac_get_channel(channel);\n\n\t/* DAC device init */\n\tresult = Cy_CSDIDAC_Init(&dac_config[0].cyhal_dac_device, &csdidac_context);\n\n\tif (result != RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\n\tdac_value = *value;\n\n\t/* DAC output enable */\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, dac_value, &csdidac_context);\n\n\tif (result != RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 67.04409331110179}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t page = 0;\n\trt_uint32_t page_addr = 0;\n\trt_uint32_t i = 0;\n\trt_uint32_t ret = 0;\n\trt_uint32_t flash_addr = 0;\n\tcy_rslt_t err = CY_RSLT_SUCCESS;\n\n\tif (addr + size > block_info.size) {\n\t\tLOG_E(\"Read exceeds flash end address\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tpage = get_page_32k(addr);\n\n\tpage_addr = page;\n\tpage_addr = page_addr & 0x0000FFFF;\n\n\t/* Read the data from the flash memory */\n\tfor (i = 0; i < size; i++) {\n\t\tflash_addr = page_addr + addr + i;\n\t\terr = cyhal_flash_read(&flash_obj, flash_addr, &buf[i], 1, 0);\n\t\tif (CY_RSLT_SUCCESS != err) {\n\t\t\tLOG_E(\"Flash read failed\n\");\n\t\t\treturn -RT_ERROR;\n\t\t}\n\t}\n\n\tret = size;\n\n\treturn ret;\n}", "CodeBleu_score": 41.51462102641849}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t page_addr = 0;\n\trt_uint32_t page_offset = 0;\n\trt_uint32_t data_size = 0;\n\trt_uint32_t ret = 0;\n\tcy_rslt_t err = CY_RSLT_SUCCESS;\n\n\tif ((addr + size) > block_info.size) {\n\t\tLOG_E(\"Flash read operation exceeds the flash memory's end address\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\twhile (size) {\n\t\tpage_addr = get_page_32k(addr);\n\t\tpage_offset = addr - page_addr;\n\t\tdata_size = (IFX_EFLASH_PAGE_SIZE - page_offset) > size ? size : (IFX_EFLASH_PAGE_SIZE - page_offset);\n\n\t\terr = cyhal_flash_read(&flash_obj, page_addr, data_size, buf);\n\t\tif (CY_RSLT_SUCCESS != err) {\n\t\t\tLOG_E(\"Flash read failed\");\n\t\t\treturn -RT_ERROR;\n\t\t}\n\n\t\tret += data_size;\n\t\taddr += data_size;\n\t\tbuf += data_size;\n\t\tsize -= data_size;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 39.47694620002946}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\nRT_ASSERT(timer != RT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 41.92485948136012}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\nRT_ASSERT(timer != RT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n\n}", "CodeBleu_score": 41.92485948136012}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\nRT_ASSERT(timer != RT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 41.92485948136012}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\n}", "CodeBleu_score": 3.1131432122697555}, {"code": "void dfs_lock(void){\n\t#ifdef RT_USING_POSIX_STDIO\n    /* lock posix stdio */\n    _lock_stdio();\n#endif\n    /* lock filesystem */\n    rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 12.529977234715457}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.763792832616934}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\tfd = fd_slot_expand(fdt, startfd);\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\n\tfor (index = 0; index < startfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 41.360336161481925}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tif (startfd >= DFS_FD_MAX) {\n\t\treturn -1;\n\t}\n\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\tfd = fd_slot_expand(fdt, startfd);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (index = startfd; index < fd; index++) {\n\t\tfdt->fds[index] = NULL;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 46.64559245895939}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\tfd = fd_slot_expand(fdt, startfd);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 39.11299992664193}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n\t\tif (rt_errno_strs[i].error == error) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 66.66065188561711}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n\t\tif (rt_errno_strs[i].error == error) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 61.71701532062652}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n\t\tif (rt_errno_strs[i].error == error) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 61.71701532062652}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\trt_spin_lock(&_hook_spinlock);\n\n\t/* find an empty slot */\n\tfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock(&_hook_spinlock);\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 70.35948971405097}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_kprintf(\"set idle hook\n\");\n\tlevel = rt_hw_interrupt_disable();\n\trt_spin_lock(&_hook_spinlock);\n\tif (hook != RT_NULL) {\n\t\tif (idle_hook_list[0] == RT_NULL) {\n\t\t\tidle_hook_list[0] = hook;\n\t\t\tresult = RT_EOK;\n\t\t} else if (idle_hook_list[1] == RT_NULL) {\n\t\t\tidle_hook_list[1] = hook;\n\t\t\tresult = RT_EOK;\n\t\t} else if (idle_hook_list[2] == RT_NULL) {\n\t\t\tidle_hook_list[2] = hook;\n\t\t\tresult = RT_EOK;\n\t\t} else if (idle_hook_list[3] == RT_NULL) {\n\t\t\tidle_hook_list[3] = hook;\n\t\t\tresult = RT_EOK;\n\t\t} else {\n\t\t\tresult = -RT_EFULL;\n\t\t}\n\t} else {\n\t\tresult = -RT_EINVAL;\n\t}\n\trt_spin_unlock(&_hook_spinlock);\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 27.91805548478999}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\n#ifdef RT_USING_HOOK\n    rt_base_t level;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n    rt_spin_lock(&_hook_spinlock);\n\n    /* find an empty slot */\n    for (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            rt_spin_unlock(&_hook_spinlock);\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n    }\n\n    rt_spin_unlock(&_hook_spinlock);\n    rt_hw_interrupt_enable(level);\n\n    return -RT_EFULL;\n#else\n    return -RT_ENOSYS;\n#endif\n}", "CodeBleu_score": 66.44908150822582}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\nrt_base_t level;\nrt_err_t ret = -RT_ENOSYS;\n\nlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\nfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\nif (idle_hook_list[i] == hook) {\nidle_hook_list[i] = RT_NULL;\nret = RT_EOK;\nbreak;\n}\n}\n\nrt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\nreturn ret;\n}", "CodeBleu_score": 86.9327637476327}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\nrt_err_t ret = -RT_ENOSYS;\nrt_base_t level;\n\nlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\nfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\nif (idle_hook_list[i] == hook) {\nidle_hook_list[i] = RT_NULL;\nret = RT_EOK;\nbreak;\n}\n}\n\nrt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\nreturn ret;\n}", "CodeBleu_score": 91.6313043647393}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_err_t ret = -RT_ENOSYS;\n\trt_base_t level;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 91.9440969940395}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list != RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\trt_sched_thread_resume(thread);\n\n\t\t/* thread error should not be a negative value */\n\t\tif (thread_error >= 0) {\n\t\t\t/* set thread error code to notified resuming thread */\n\t\t\tthread->error = thread_error;\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.99618552876162}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list != RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\trt_sched_thread_ready(thread);\n\n\t\t/* thread error should not be a negative value */\n\t\tif (thread_error >= 0) {\n\t\t\t/* set thread error code to notified resuming thread */\n\t\t\tthread->error = thread_error;\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.979112979798906}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list != RT_NULL);\n\n\trt_enter_critical();\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t}\n\t\telse {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_exit_critical();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.010132666920065}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t#ifdef RT_USING_DEVICE\n    rt_device_t device, old_device;\n    old_device = _console_device;\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        LOG_E(\"set device %s failed, not found\", name);\n        return RT_NULL;\n    }\n    if (device == old_device) {\n        return device;\n    }\n    if (old_device != RT_NULL) {\n        if (rt_device_open(old_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n            LOG_E(\"set device %s failed, open failed\", name);\n            return RT_NULL;\n        }\n        rt_device_close(old_device);\n    }\n    if (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        LOG_E(\"set device %s failed, open failed\", name);\n        return RT_NULL;\n    }\n    _console_device = device;\n    return old_device;\n#else\n    RT_ASSERT(0);\n    return RT_NULL;\n#endif /* RT_USING_DEVICE */\n}", "CodeBleu_score": 59.528788668782205}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t device, old_device;\n\nold_device = _console_device;\ndevice = rt_device_find(name);\nif (device == RT_NULL) {\nreturn old_device;\n}\n\nif (old_device != RT_NULL && old_device != device) {\nrt_device_close(old_device);\n}\n\nif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == 0) {\n_console_device = device;\n}\n\nreturn old_device;\n}", "CodeBleu_score": 60.73072608609055}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t#ifdef RT_USING_POSIX_CONSOLE\n    if (rt_strcmp(name, \"posix\") == 0) {\n        return rt_console_set_device(\"console\");\n    }\n#endif\n    rt_device_t new_device = RT_NULL;\n    rt_device_t old_device = RT_NULL;\n\n    old_device = rt_console_get_device();\n    if (old_device != RT_NULL) {\n        if (rt_device_find(name, &new_device) != RT_EOK) {\n            LOG_E(\"The device named %s can't be found\", name);\n            return RT_NULL;\n        }\n        if (new_device == old_device) {\n            return old_device;\n        }\n        rt_device_close(old_device);\n    }\n\n    if (rt_device_find(name, &new_device) != RT_EOK) {\n        LOG_E(\"The device named %s can't be found\", name);\n        return RT_NULL;\n    }\n\n    if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        LOG_E(\"The device named %s can't be open\", name);\n        return RT_NULL;\n    }\n\n    _console_device = new_device;\n\n    return old_device;\n}", "CodeBleu_score": 56.173760522627305}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count;\n\tstruct rt_object_information *information;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) return 0;\n\n\t/* lock the object information */\n\trt_enter_critical();\n\n\t/* get the count of object */\n\tcount = information->object_list.number;\n\n\t/* release the object information */\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 31.37606299332316}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count;\n\tstruct rt_object_information *information;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) return 0;\n\n\trt_enter_critical();\n\tcount = information->object_list.number;\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 31.37606299332316}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tint count;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) return 0;\n\n\trt_enter_critical();\n\tcount = information->object_list.next->number;\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 31.472791466344084}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_ASSERT(object != RT_NULL);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* get object information */\n\tstruct rt_object_information *information = rt_object_get_information(object->type);\n\n\t/* lock object */\n\trt_base_t level = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove object from object list */\n\trt_list_remove(&(object->list));\n\n#ifdef RT_USING_MODULE\n\tif (object->module_id != RT_NULL) {\n\t\t/* remove object from module's object list */\n\t\trt_list_remove(&(object->list));\n\t}\n#endif /* RT_USING_MODULE */\n\n\t/* unlock object */\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 72.69832801766337}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check object */\n\tRT_ASSERT(object != RT_NULL);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* get object information */\n\tstruct rt_object_information *information = rt_object_get_information(object->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* enter critical */\n\trt_base_t level = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove object from object list */\n\trt_list_remove(&(object->list));\n\tobject->type = 0;\n\n#ifdef RT_USING_MODULE\n\t/* remove object from module list */\n\tif (object->module_id) {\n\t\trt_list_remove(&(object->list));\n\t\tobject->module_id = RT_NULL;\n\t}\n#endif /* RT_USING_MODULE */\n\n\t/* leave critical */\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n}", "CodeBleu_score": 69.62447294894974}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_DEBUG_LOG(RT_DEBUG_OBJECT, (\"detach object: %s\", object->name));\n\n\t/* check object */\n\tRT_ASSERT(object != RT_NULL);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* get object information */\n\tstruct rt_object_information *information = rt_object_get_information(object->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* enter critical */\n\trt_base_t level = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove object from information object list */\n\trt_list_remove(&(object->list));\n\n\t/* leave critical */\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 76.1857977941476}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tstruct rt_custom_object *cobj;\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n\tcobj = (struct rt_custom_object *)obj;\n\n\t/* invoke destroy callback */\n\tif (cobj->destroy != RT_NULL) {\n\t\tresult = cobj->destroy(cobj->data);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 61.8327698086165}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tstruct rt_custom_object *cobj;\nrt_err_t result;\n\nRT_DEBUG_NOT_IN_INTERRUPT;\n\n/* parameter check */\nRT_ASSERT(obj != RT_NULL);\n\n/* check object type */\nif (obj->type != RT_Object_Class_Custom)\nreturn -RT_EINVAL;\n\ncobj = (struct rt_custom_object *)obj;\n\n/* call destroy callback */\nif (cobj->destroy)\nresult = cobj->destroy(cobj->data);\n\n/* delete object */\nrt_object_delete(obj);\n\nreturn result;\n}", "CodeBleu_score": 61.94891509472941}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tstruct rt_custom_object *cobj;\n\trt_err_t result;\n\n\t/* check object */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n\tcobj = (struct rt_custom_object *)obj;\n\n\t/* call custom object destroy */\n\tif (cobj->destroy) {\n\t\tresult = cobj->destroy(cobj->data);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 63.78140769217735}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_base_t level;\n\trt_thread_t thread;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* check thread */\n\tif (thread == RT_NULL) {\n\t\t/* enable interrupt */\n\t\trt_hw_interrupt_enable(level);\n\n\t\t/* never reach here */\n\t\treturn;\n\t}\n\n\t/* set the thread state */\n\tthread->stat = RT_THREAD_CLOSE;\n\n\t/* release the schedule lock */\n\trt_schedule_lock();\n\n\t/* add to the defunct thread list */\n\trt_list_insert_before(&rt_defunct_thread_list, &thread->tlist);\n\n\t/* release the schedule lock */\n\trt_schedule_unlock();\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* check whether the thread is the last one in system */\n\tif (rt_object_is_systemobject((rt_object_t)thread)) {\n\t\t/* cleanup system object */\n\t\trt_system_object_delete((rt_object_t)thread);\n\t} else {\n\t\t/* detach thread object */\n\t\trt_object_detach((rt_object_t)thread);\n\t}\n\n\t/* yield to thread */\n\trt_schedule();\n}", "CodeBleu_score": 54.0907113374417}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\t/* get thread */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* check parameter */\n\tRT_DEBUG_ASSERT(thread != RT_NULL);\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* suspend thread */\n\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->suspend_thread));\n\n\t\t/* set thread error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* resume thread */\n\t\tthread->stat = RT_THREAD_READY;\n\n\t\t/* add to ready list */\n\t\trt_list_insert_before(&(rt_thread_ready_list), &(thread->tlist));\n\n\t\t/* enable interrupt */\n\t\trt_hw_interrupt_enable(level);\n\n\t\t/* yield to thread */\n\t\trt_schedule();\n\n\t\treturn;\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 56.86418256365853}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\n/* get current thread */\nthread = rt_thread_self();\n\n/* parameter check */\nRT_DEBUG_NOT_IN_INTERRUPT;\nRT_DEBUG_THREAD_NOT_SELF(thread);\n\n/* disable interrupt */\nrt_hw_interrupt_disable();\n\n/* lock scheduler */\nrt_enter_critical();\n\n/* check thread state */\nif (thread->stat != RT_THREAD_SUSPEND) {\nrt_exit_critical();\nrt_kprintf(\"thread %s is not suspend\n\", thread->name);\nreturn;\n}\n\n/* set error number */\nthread->error = -RT_ETIMEOUT;\n\n/* remove thread from suspend list */\nrt_list_remove(&(thread->thread_suspend_list));\n\n/* resume thread */\nrt_thread_resume(thread);\n\n/* unlock scheduler */\nrt_exit_critical();\n}", "CodeBleu_score": 42.156371887390385}, {"code": "static void _thread_timeout(void *parameter){\n\t#ifdef RT_USING_HOOK\n    /* invoke the thread timeout hook */\n    if (rt_object_get_type(&parameter->parent) == RT_Object_Class_Thread)\n    {\n        rt_object_call_hook(&(parameter->parent), RT_THREAD_HOOK_TIMEOUT);\n    }\n#endif /* RT_USING_HOOK */\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* check thread status */\n    if (parameter->stat != RT_THREAD_SUSPEND) {\n        /* unlock scheduler */\n        rt_exit_critical();\n\n        /* thread is not suspend, return */\n        return;\n    }\n\n    /* set thread error number */\n    parameter->error = -ETIME;\n\n    /* remove thread from suspend list */\n    rt_list_remove(&(parameter->suspend_thread));\n\n    /* resume thread */\n    parameter->stat = RT_THREAD_READY;\n\n    /* insert thread to ready list */\n    rt_list_insert_before(&(rt_thread_ready_list), &(parameter->tlist));\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    /* schedule thread */\n    rt_schedule();\n}", "CodeBleu_score": 36.82270614998647}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_mutex_t *mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\tmutex = thread->mutex;\n\tif (mutex) {\n\t\tif (mutex->owner == thread) {\n\t\t\tmutex->owner = RT_NULL;\n\t\t}\n\t\trt_list_remove(&(RT_THREAD_LIST_NODE(thread)));\n\t\tthread->mutex = RT_NULL;\n\t\tif (mutex->owner) {\n\t\t\trt_thread_resume(mutex->owner);\n\t\t}\n\t\trt_hw_interrupt_enable(level);\n\t\trt_mutex_release(mutex);\n\t} else {\n\t\trt_hw_interrupt_enable(level);\n\t}\n}", "CodeBleu_score": 35.07441694763533}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t self = rt_thread_self();\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->mutex != RT_NULL) {\n\t\tif (thread->mutex->owner == self) {\n\t\t\tthread->mutex->owner = RT_NULL;\n\t\t\trt_thread_resume(thread->mutex->owner);\n\t\t}\n\t\trt_mutex_detach(thread->mutex);\n\t}\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 25.17538152085026}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_mutex_t mutex;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->mutex_count == 0) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\tmutex = thread->mutex_list;\n\twhile (mutex) {\n\t\trt_mutex_detach(mutex, thread);\n\t\tmutex = mutex->owner_thread;\n\t}\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 28.25536227131732}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* parameter check */\n\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_ThreadType_Normal);\n\n\t/* log thread's name and priority */\n\trt_kprintf(\"thread %.*s, priority: %d\n\", RT_NAME_MAX, thread->name, thread->current_priority);\n\n\t/* calculate thread's priority attributes */\n\trt_thread_adjust_priority(thread);\n\n\t/* reset thread's state to suspended */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger a scheduler if available */\n\tif (rt_thread_self() != RT_NULL) {\n\t\trt_schedule();\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 51.616977454440004}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t#ifdef RT_USING_MODULE\n    rt_module_t module;\n#endif\n    rt_base_t lock;\n    rt_err_t result;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_ThreadType_Thread);\n\n#ifdef RT_USING_MODULE\n    module = rt_object_get_type(RT_Object(thread), RT_Object_Class_Module);\n    if (module != RT_NULL)\n    {\n        /* check module initialization */\n        if (module->parent.init_flag == 0)\n        {\n            /* module has not been initialized */\n            rt_kprintf(\"module %s is not initialized\n\", module->parent.name);\n            return -RT_ERROR;\n        }\n    }\n#endif\n\n    /* log thread's name and priority */\n    rt_kprintf(\"thread %s start\n\", thread->name);\n\n    /* calculate thread's priority attributes */\n    rt_thread_calc_priority(thread);\n\n    /* reset thread's state to suspended */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    lock = rt_hw_interrupt_disable();\n    thread->cleanup = RT_NULL;\n    thread->user_data = RT_NULL;\n    result = rt_thread_resume(thread);\n    rt_hw_interrupt_enable(lock);\n\n    /* trigger a scheduler if available */\n    if (result == RT_EOK)\n    {\n        rt_schedule();\n    }\n\n    return result;\n}", "CodeBleu_score": 45.62327711429253}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tint i;\nstruct rt_timer *timer;\n\nfor (i = RT_TIMER_SKIP_LIST_LEVEL - 1; i >= 0; i--) {\nif (!rt_list_isempty(&timer_list[i])) {\ntimer = rt_list_entry(timer_list[i].next, struct rt_timer, row[i]);\n*timeout_tick = timer->timeout_tick;\nreturn RT_EOK;\n}\n}\n\nreturn -RT_ETIMEOUT;\n}", "CodeBleu_score": 45.88439154656679}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_timer_t timer;\n\trt_uint8_t i;\n\trt_uint8_t level;\n\n\t/* get the highest level of the timer skip list */\n\tlevel = rt_hw_interrupt_disable();\n\tfor (i = RT_TIMER_SKIP_LIST_LEVEL - 1; i > 0; i--) {\n\t\tif (!rt_list_isempty(timer_list[i])) {\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\ttimer = rt_list_first_entry(timer_list[i], struct rt_timer, row[i]);\n\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\n\t/* if the highest level of the timer skip list is empty, return an error code */\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 42.045133183687874}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tstruct rt_timer *timer;\n\n\t/* parameter check */\n\tRT_ASSERT(name != RT_NULL);\n\tRT_ASSERT(timeout != RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\t/* allocate memory */\n\ttimer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL)\n\t\treturn RT_NULL;\n\n\t/* timer object initialization */\n\trt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\treturn timer;\n}", "CodeBleu_score": 83.72187355202993}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#define RT_TIMER_TICK_MAX (RT_TICK_MAX / 2)\n#define RT_TIMER_TICK_MIN (1)\n    struct rt_timer *timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TIMER_TICK_MAX);\n    RT_ASSERT(time >= RT_TIMER_TICK_MIN);\n\n    /* allocate memory for timer object */\n    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    rt_timer_init(timer, name, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 79.99430782226152}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\tstruct rt_timer *timer;\n\trt_base_t level;\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(timeout != RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\ttimer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize timer */\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\t/* register timer to system object */\n\tlevel = rt_hw_interrupt_disable();\n\tresult = rt_object_insert(&(rt_system_object), &(timer->parent));\n\trt_hw_interrupt_enable(level);\n\n\tif (result != RT_EOK) {\n\t\trt_object_delete(timer);\n\n\t\treturn RT_NULL;\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 82.2937721410657}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tfor _, handler := range a.handlers {\n\t\thandler(res, req)\n\t\tif res.Header().Get(\\\"Authorization\\\") == \\\"\\\" {\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 38.45822458776774}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tfor _, handler := range a.handlers {\n\t\thandler(res, req)\n\t\tif res.StatusCode == 401 {\n\t\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/plain\\\")\n\t\t\tres.WriteHeader(401)\n\t\t\tres.Write([]byte(\\\"Not Authorized\\\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 45.05595835418522}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\tdefer func() {\n\t\tfor k, v := range recorder.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tres.WriteHeader(recorder.Code)\n\t\tres.Write(recorder.Body.Bytes())\n\t}()\n\n\tfor _, handler := range a.handlers {\n\t\thandler(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\trecorder.Code = http.StatusForbidden\n\t\t\trecorder.Body.Write([]byte(\\\"Not Authorized\\\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(recorder, req)\n}", "CodeBleu_score": 54.09688386909269}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := strings.TrimPrefix(req.URL.Path, \\\"/\\\")\n\tif strings.Contains(path, \\\"..\\\") {\n\t\thttp.Error(res, \\\"Forbidden\\\", http.StatusForbidden)\n\t\treturn\n\t}\n\tif path == \\\"\\\" {\n\t\tpath = \\\"index.html\\\"\n\t}\n\text := path[len(path)-3:]\n\tvar asset []byte\n\tvar contentType string\n\tif ext == \\\"css\\\" {\n\t\tcontentType = \\\"text/css\\\"\n\t\tasset = robeaux.Asset(\\\"css/\\\" + path)\n\t} else if ext == \\\"js\\\" {\n\t\tcontentType = \\\"application/javascript\\\"\n\t\tasset = robeaux.Asset(\\\"js/\\\" + path)\n\t} else if ext == \\\"html\\\" {\n\t\tcontentType = \\\"text/html\\\"\n\t\tasset = robeaux.Asset(\\\"\\\" + path)\n\t}\n\tif asset == nil {\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\\\"Content-Type\\\", contentType)\n\tres.Write(asset)\n}", "CodeBleu_score": 36.79065737006001}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tvar asset []byte\n\tvar contentType string\n\tvar err error\n\tpath := strings.TrimPrefix(req.URL.Path, \\\"/\\\")\n\tif path == \\\"\\\" {\n\t\tpath = \\\"index.html\\\"\n\t}\n\tif path == \\\"index.html\\\" {\n\t\tcontentType = \\\"text/html\\\"\n\t\tasset, err = Asset(\\\"robeaux/\\\" + path)\n\t} else {\n\t\tcontentType = \\\"text/plain\\\"\n\t\tasset, err = Asset(\\\"robeaux/\\\" + path)\n\t}\n\tif err != nil {\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\\\"Content-Type\\\", contentType)\n\tres.Write(asset)\n}", "CodeBleu_score": 41.4582375590461}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\ta.robeaux = robeaux.New(true)\n\ta.robeaux.ServeHTTP(res, req)\n}", "CodeBleu_score": 14.523265123290518}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\\\":robot\\\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t})\n\ta.writeJSON(map[string]interface{}{\\\"connections\\\": jsonConnections}, res)\n} else {\n\ta.writeJSON(map[string]interface{}{\\\"error\\\": \\\"No Robot found with the name \\\" + req.URL.Query().Get(\\\":robot\\\")}, res)\n}\n}", "CodeBleu_score": 76.47430153434674}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\\\":robot\\\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\\\"connections\\\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": \\\"No Robot found with the name \\\" + req.URL.Query().Get(\\\":robot\\\")}, res)\n\t}\n}", "CodeBleu_score": 76.14216265518337}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\\\":robot\\\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\\\"connections\\\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\\\"error\\\": \\\"No Robot found with the name \\\" + req.URL.Query().Get(\\\":robot\\\")}, res)\n\t}\n}", "CodeBleu_score": 76.14216265518337}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int)  {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 61.60043928998594}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int)  {\n\t\treturn int(math.Min(math.Max(slope*input+intercept, float64(toMin)), float64(toMax)))\n\t}\n}", "CodeBleu_score": 53.95113872249897}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) int {\n\t\tvalue := int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 63.56125131143766}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\\\"AnalogSensorDriver not initialized\\\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\treturn rawValue, a.lastValue, nil\n}", "CodeBleu_score": 56.99555508000789}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection == nil {\n\t\treturn -1, -1, errors.New(\\\"AnalogSensorDriver not connected\\\")\n\t}\n\n\tif a.analogRead == nil {\n\t\treturn -1, -1, errors.New(\\\"AnalogSensorDriver does not support analog read\\\")\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err != nil {\n\t\treturn rawValue, value, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\n\treturn rawValue, a.lastValue, err\n}", "CodeBleu_score": 55.02130783535071}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, ErrUnsupportedConnection\n\t}\n\n\tif a.connection.AnalogRead == nil {\n\t\treturn -1, -1, ErrUnsupportedOperation\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn rawValue, -1, err\n\t}\n\n\tscaledValue := a.sensorCfg.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 53.734384533009795}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\treturn m*input + n\n\t}\n}", "CodeBleu_score": 38.87077340519989}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 42.79973249779121}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\treturn m*input + n\n\t}\n}", "CodeBleu_score": 38.87077340519989}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(\"vibration\")\n\n\tgo func() {\n\t\tfor data := range d.AnalogSensorDriver.Events(\"data\") {\n\t\t\tif data.(int) > 1000 {\n\t\t\t\td.Publish(d.Event(\"vibration\"), data)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &d\n}", "CodeBleu_score": 55.80644445055313}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(\"vibration\")\n\n\tgo func() {\n\t\tfor data := range d.AnalogSensorDriver.Events(\"data\") {\n\t\t\tif data.(int) > 1000 {\n\t\t\t\td.Publish(d.Event(\"vibration\"), data)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &d\n}", "CodeBleu_score": 55.80644445055313}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(func(data interface{}) {\n\t\tif val, ok := data.(int); ok {\n\t\t\tif val > 1000 {\n\t\t\t\td.Events.Publish(grove.Data{\n\t\t\t\t\tName:    d.Name(),\n\t\t\t\t\tValue:   val,\n\t\t\t\t\tRaw:     data,\n\t\t\t\t\tTime:    time.Now(),\n\t\t\t\t\tType:    \"vibration\",\n\t\t\t\t\tChannel: d.Pin,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t})\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn &d\n}", "CodeBleu_score": 67.62621110487643}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.State() {\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tperiod := 60.0 / d.bpm\n\tdelay := period / hz\n\n\tfor i := 0.0; i < duration; i += delay {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.42095459192586}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tnumCycles := int(duration * float64(d.bpm) / 60.0)\n\tfor i := 0; i < numCycles; i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 57.45599273908204}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tbeats := d.bpm / 60.0\n\ttoneDuration := beats / duration\n\tfor i := 0.0; i < toneDuration; i++ {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.76783532127421}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \\\"\\\" {\n\t\treturn fmt.Errorf(\\\"sleepPin is not set for '%s'\\\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 84.91650622733356}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \\\"\\\" {\n\t\treturn fmt.Errorf(\\\"sleepPin is not set for '%s'\\\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 84.91650622733356}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \\\"\\\" {\n\t\treturn fmt.Errorf(\\\"sleepPin is not set for '%s'\\\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 84.91650622733356}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif _, ok := a.pins[id]; ok {\n\t\treturn a.pins[id], nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 62.754052575345476}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif r {\n\t\tpin = NewAnalogReader(path, bufLen)\n\t} else if w {\n\t\tpin = NewAnalogWriter(path, bufLen)\n\t} else {\n\t\treturn nil, errors.New(\"pin does not support analog access\")\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 59.481756647201024}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor is not connected\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := sysfs.NewAnalogPin(path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 63.24300067189933}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\\\"DigitalPinsAdaptor is not connected to any pins\\\")\n\t}\n\tif a.pinOptions == nil {\n\t\ta.pinOptions = make(map[string][]func(gobot.DigitalPinOptioner) bool)\n\t}\n\n\tif _, ok := a.pins[id]; !ok {\n\t\tif pin, err := a.initPin(id); err == nil {\n\t\t\ta.pins[id] = pin\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\treturn nil, errors.New(\\\"DigitalPinsAdaptor is not connected to any pins\\\")\n\t}\n\tif opts != nil {\n\t\tif _, ok := a.pinOptions[id]; !ok {\n\t\t\ta.pinOptions[id] = make([]func(gobot.DigitalPinOptioner) bool, 0)\n\t\t}\n\t\ta.pinOptions[id] = append(a.pinOptions[id], opts...)\n\t}\n\tif a.pinOptions[id] != nil {\n\t\tfor _, opt := range a.pinOptions[id] {\n\t\t\topt(pin)\n\t\t}\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 49.79561923402388}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\\\"DigitalPinsAdaptor is not connected\\\")\n\t}\n\tif _, ok := a.pins[id]; !ok {\n\t\tif _, ok := a.pinOptions[id]; !ok {\n\t\t\treturn nil, fmt.Errorf(\\\"DigitalPinsAdaptor does not have pin %s\\\", id)\n\t\t}\n\t\topts = append(a.pinOptions[id], opts...)\n\t\ta.pins[id], _ = a.sysfs.NewDigitalPin(id, opts...)\n\t}\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 42.38698580946271}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\\\"DigitalPinsAdaptor is not connected to any pins\\\")\n\t}\n\tif _, ok := a.pins[id]; !ok {\n\t\tpin, err := a.newDigitalPin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\tpin, err := a.pins[id].DigitalPin()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 46.39334471935665}]}
