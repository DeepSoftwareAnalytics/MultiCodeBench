{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t#ifdef DEBUG_FILE_TRANSFER\n  std::cout << \\\"[Client] GetRequiredFiles(\\\" << folder << \\\", \\\" << download << \\\")\\\" << std::endl;\n#endif\n  return FileTransfer::GetRequiredFiles(folder, download);\n}", "CodeBleu_score": 22.411180029833407}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files = FileTransfer::GetRequiredFiles(folder);\n\tif (download) {\n\t\tfor (const auto &file : required_files) {\n\t\t\tif (!FileTransfer::Exists(file)) {\n\t\t\t\tstd::cout << \\\"[carla.Client] File \\\" << file << \\\" not found, downloading...\\\"\n;\n\t\t\t\tauto data = _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_file\\\", file);\n\n\t\t\t\tFileTransfer::Save(file, data);\n\n\t\t\t} else {\n\n\t\t\t\tstd::cout << \\\"[carla.Client] File \\\" << file << \\\" found in cache\\\"\n;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn required_files;\n\n}", "CodeBleu_score": 49.100155352381606}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tauto files_in_folder = FileTransfer::GetFilesInFolder(folder);\n\tfor (const auto &file : files_in_folder) {\n\t\tauto file_path = folder + file;\n\t\tif (download) {\n\t\t\tif (!FileTransfer::FileExists(file_path)) {\n\t\t\t\tFileTransfer::DownloadFile(file_path);\n\t\t\t} else {\n\t\t\t\tLOG_INFO(file_path << \" found in cache.\");\n\t\t\t}\n\t\t}\n\t\trequired_files.emplace_back(file_path);\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 45.92770450184487}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef CARLA_NO_EXCEPTIONS\n    try {\n#endif\n      if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        if (transform.location.z != 0.0f) {\n          log_warning(\"The requested transformation has a non-zero translation in the z axis. The actor will be spawned with a zero-translation instead.\");\n        }\n        transform.location = geom::Location(0.0f, 0.0f, 0.0f);\n      }\n\n      return _pimpl->CallAndWait<rpc::Actor>(\\\"spawn_actor_with_parent\\\", description, transform, parent, attachment_type, socket_name);\n#ifdef CARLA_NO_EXCEPTIONS\n    } catch (const std::exception &exception) {\n      throw_exception(\\\"Could not spawn actor with parent.\\\", exception);\n\n    }\n#endif\n  }", "CodeBleu_score": 42.77306890225623}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#ifdef LIBCARLA_WITH_PYTHON_SUPPORT\n  boost::python::gil_scoped_acquire acquire;\n#endif // LIBCARLA_WITH_PYTHON_SUPPORT\n  carla::streaming::detail::token_type thisToken(ActorId, GBufferId);\n  auto receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_gbuffer_token\\\", thisToken.get_stream_id());\n  _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 34.330538409494686}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tcarla::streaming::detail::token_type thisToken(ActorId, GBufferId);\n\tstreaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n\t_pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 36.70184905971214}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tcarla::streaming::detail::token_type thisToken(token);\n\tstreaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n\t_pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 35.0778306939857}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (_walker_navigation == nullptr) {\n\t\t_walker_navigation = std::make_shared<WalkerNavigation>();\n\t\ttry {\n\t\t\t_walker_navigation->SetEpisode(*this);\n\t\t}\n\t\tcatch (const std::exception &e) {\n\t\t\tlog_error(\"exception creating walker navigation: {}\", e.what());\n\t\t\t_walker_navigation.reset();\n\t\t}\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 43.83530641992686}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif(!_walker_navigation) {\n\t\tauto navigation = std::make_shared<WalkerNavigation>();\n\t\tif(!navigation->SetEpisode(*this)) {\n\t\t\tlog_error(\"WalkerNavigation could not be set.\");\n\t\t\treturn nullptr;\n\t\t}\n\t\t_walker_navigation = navigation;\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 37.09790481736359}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif(!_walker_navigation) {\n\t\ttry {\n\t\t\t_walker_navigation = std::make_shared<WalkerNavigation>(*this);\n      } catch (const std::exception &e) {\n        log_error(\\\"exception trying to create walker navigation:\\\", e.what());\n      }\n    }\n    return _walker_navigation;\n  }", "CodeBleu_score": 30.363363997029534}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst auto start_time = system_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tconst auto now = system_clock::now();\n\t\tif (now - start_time > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\ttraffic_manager.Tick(episode);\n\treturn true;\n}", "CodeBleu_score": 32.42123977161873}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tusing namespace std::chrono_literals;\n\tconst auto start_time = steady_clock::now();\n\twhile (episode.GetFrameNumber() < frame) {\n\t\tif (steady_clock::now() - start_time > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\ttraffic_manager::TrafficManager::Get().Tick();\n\treturn true;\n}", "CodeBleu_score": 33.71485025298657}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tusing namespace std::chrono_literals;\n\tusing clock = std::chrono::steady_clock;\n\n\tauto start = clock::now();\n\n\twhile (episode.GetFrameNumber() < frame) {\n\t\tauto now = clock::now();\n\t\tif (now - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\n\ttraffic_manager::TrafficManager::Get().Tick(episode);\n\n\treturn true;\n}", "CodeBleu_score": 37.108587737784646}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t", "CodeBleu_score": 3.4229654508845124}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tauto start = std::chrono::system_clock::now();\n\tauto timeout = std::chrono::milliseconds(5000);\n\tauto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\tauto end = std::chrono::system_clock::now();\n\tauto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n\twhile (diff < timeout) {\n\t\tstd::this_thread::yield();\n\t\tauto new_episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\t\tif (new_episode_id != episode_id) {\n\t\t\treturn EpisodeProxy(_client, new_episode_id);\n\t\t}\n\t\tend = std::chrono::system_clock::now();\n\t\tdiff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n\t}\n\tthrow TimeoutException(\"Failed to load episode within timeout.\");\n}", "CodeBleu_score": 42.276576881659935}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t#if LIBCARLA_WITH_PYTHON_SUPPORT\n  if (map_name.empty()) {\n    throw_exception(\"map_name must be non-empty.\");\n  }\n  if (map_layers.empty()) {\n    throw_exception(\"map_layers must be non-empty.\");\n  }\n#endif // LIBCARLA_WITH_PYTHON_SUPPORT\n\n  const auto start = std::chrono::system_clock::now();\n  const auto timeout = std::chrono::milliseconds(5000);\n\n  auto episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  auto end = std::chrono::system_clock::now();\n  auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n  if (timeout < diff) {\n    throw TimeoutException(\"timeout(\" + std::to_string(timeout.count()) + \"ms) exceded.\");\n  }\n\n  const auto new_episode_id = episode.GetId();\n  if (new_episode_id != _episode_id) {\n    _episode_id = new_episode_id;\n    _episode_start = std::chrono::system_clock::now();\n    _map = Map(episode.GetMap());\n    _traffic_manager = traffic_manager::TrafficManager(_client, _map, _gc_policy);\n    _light_manager->Clear();\n    _actor_factory = ActorFactory(_client, _traffic_manager, _map, _light_manager, _gc_policy);\n    _actor_factory.Reset();\n  }\n\n  return episode;\n}", "CodeBleu_score": 44.46635384719172}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode != nullptr);\n\tauto nav = _episode->CreateNavigationIfMissing();\n\tauto walker = nav->GetWalker(controller.GetWalkerId());\n\tif (walker == nullptr) {\n\t\tthrow_exception(std::runtime_error(\"Walker not found\"));\n\t}\n\tnav->RegisterAIController(controller, walker);\n}", "CodeBleu_score": 65.54716354373068}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode != nullptr);\n\tauto nav = _episode->CreateNavigationIfMissing();\n\tauto walker = nav->GetWalker(controller.GetWalkerId());\n\tif (!walker) {\n\t\tthrow_exception(std::runtime_error(\"Walker not found!\"));\n\t}\n\tnav->RegisterAIController(controller, walker);\n}", "CodeBleu_score": 61.262050766494426}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode != nullptr);\n\tauto nav = _episode->CreateNavigationIfMissing();\n\tauto walker = nav->GetWalkerById(controller.GetWalkerId());\n\tif (!walker) {\n\t\tthrow_exception(std::runtime_error(\"Walker not found!\"));\n\t}\n\tnav->RegisterAIController(controller, walker);\n}", "CodeBleu_score": 61.44753813499686}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tDEBUG_ASSERT(_episode != nullptr);\n\tauto actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n\tactor->Register();\n\treturn actor;\n}", "CodeBleu_score": 29.958540587649708}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tDEBUG_ASSERT(_episode != nullptr);\nsensor_id_to_callback_[sensor.GetId()] = callback;\n_client.SubscribeToStream(sensor.GetStream());\n}", "CodeBleu_score": 25.116872747744278}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifndef NDEBUG\n  if (callback == nullptr) {\n    throw_exception(\"Callback cannot be null.\");\n  }\n#endif\n\n  DEBUG_ASSERT(_episode != nullptr);\n  const auto frame = _client.SubscribeToStream(sensor.GetStreamId());\n  _episode->RegisterSensor(sensor);\n  _episode->RegisterSensorFrame(sensor, frame);\n  _episode->RegisterSensorCallback(sensor, callback);\n}", "CodeBleu_score": 40.01835734066847}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifndef NDEBUG\n  if (sensor.GetParent() == nullptr) {\n    throw_exception(std::runtime_error(\"Sensor must be attached to an actor\"));\n  }\n#endif\n  DEBUG_ASSERT(_episode != nullptr);\n  _episode->RegisterSensor(sensor);\n  _client.SubscribeToStream(sensor.GetId(), [this, callback](const rpc::SensorData &data) {\n    auto sensor_data = sensor::SensorData::Make(data, GetCurrentEpisode());\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 43.73675345535499}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto simulator = _simulator.lock();\n\tif (!simulator) {\n\t\treturn;\n\t}\n\n\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\tauto episode_state = episode->GetState();\n\n\t// Remove any walkers that no longer exist.\n\tfor (auto it = _walkers.begin(); it != _walkers.end();) {\n\t\tif (episode_state.find(it->first) == episode_state.end()) {\n\t\t\t_nav.RemoveAgent(it->first);\n\t\t\tit = _walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the crowd.\n\tfor (auto &walker_state : episode_state) {\n\t\tauto walker_id = walker_state.first;\n\t\tauto walker_state = walker_state.second;\n\t\tauto walker = walkers.find(walker_id);\n\t\tif (walker != walkers.end()) {\n\t\t\t_nav.UpdateAgent(walker_id, walker_state.transform, walker_state.speed);\n\t\t}\n\t}\n\n\t// Update the crowd.\n\t_nav.Update();\n\n\t// Apply the crowd state to the simulator.\n\tauto commands = _nav.Apply();\n\n\t// Check if any walker has been killed.\n\tfor (auto &command : commands) {\n\t\tif (command.type == rpc::Command::Destroy) {\n\t\t\tauto it = _walkers.find(command.id);\n\t\t\tif (it != _walkers.end()) {\n\t\t\t\t_nav.RemoveAgent(command.id);\n\t\t\t\t_walkers.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Send the commands to the server.\n\tsimulator->ApplyWalkerControls(commands);\n}", "CodeBleu_score": 42.349212297958324}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto simulator = _simulator.lock();\n\tif (!simulator) {\n\t\treturn;\n\t}\n\n\t// Load the walkers.\n\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Retrieve the current state of the episode.\n\tauto state = episode->GetState();\n\n\t// Remove any walkers that no longer exist.\n\tauto it = _walkers.begin();\n\twhile (it != _walkers.end()) {\n\t\tauto walker = it->second;\n\t\tif (state.find(walker->GetId()) == state.end()) {\n\t\t\t_nav.RemoveWalker(walker);\n\t\t\tit = _walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module.\n\t_nav.Update(state);\n\n\t// Apply the states of the walkers in a batch to the simulator.\n\tstd::vector<rpc::WalkerControl> controls;\n\tfor (auto &pair : _walkers) {\n\t\tauto walker = pair.second;\n\t\tauto state = episode->GetState().at(walker->GetId());\n\t\tauto transform = state.GetTransform();\n\t\tauto velocity = state.GetVelocity();\n\t\tauto angular_velocity = state.GetAngularVelocity();\n\t\tcontrols.emplace_back(rpc::WalkerControl{transform.location, velocity, angular_velocity});\n\t}\n\tsimulator->ApplyWalkerControls(controls);\n\n\t// Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n\tfor (auto &pair : _walkers) {\n\t\tauto walker = pair.second;\n\t\tif (state.at(walker->GetId()).IsAlive()) {\n\t\t\tcontinue;\n\t\t}\n\t\t_nav.RemoveWalker(walker);\n\t\t_walkers.erase(pair.first);\n\t}\n}", "CodeBleu_score": 47.28735109152928}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = _uid;\n\tdescription.id = _id;\n\tdescription.attributes.reserve(_attributes.size());\n\tfor (auto &item : _attributes) {\n\t\tauto id = item.first;\n\t\tauto &attribute = item.second;\n\t\tdescription.attributes.emplace_back(rpc::ActorAttribute{id, attribute.GetValue()});\n\t}\n\treturn description;\n}", "CodeBleu_score": 74.96587481301798}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = _uid;\n\tdescription.id = _id;\n\tdescription.attributes.reserve(_attributes.size());\n\tfor (auto &item : _attributes) {\n\t\tauto &attribute = item.second;\n\t\trpc::ActorAttribute description_attribute;\n\t\tdescription_attribute.id = attribute.GetId();\n\t\tdescription_attribute.type = attribute.GetType();\n\t\tdescription_attribute.value = attribute.GetValue();\n\t\tdescription.attributes.emplace_back(std::move(description_attribute));\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.79169548301411}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = _uid;\ndescription.id = _id;\ndescription.attributes.reserve(_attributes.size());\nfor (auto &item : _attributes) {\ndescription.attributes.emplace_back(std::move(item.second));\n}\nreturn description;\n}", "CodeBleu_score": 77.72627773615818}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tmap_type result;\n\tfor (auto &pair : _blueprints) {\n\t\tif (pair.second.HasAttribute(name)) {\n\t\t\tif (pair.second.GetAttribute(name).as_string() == value) {\n\t\t\t\tresult.emplace(pair);\n\t\t\t}\n\t\t}\n\t}\n\treturn SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 38.42832158861823}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tmap_type result;\n\tfor (auto &pair : _blueprints) {\n\t\tif (pair.second.HasAttribute(name)) {\n\t\t\tif (pair.second.HasAttributeValue(name, value)) {\n\t\t\t\tresult.emplace(pair);\n\t\t\t}\n\t\t}\n\t}\n\treturn SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 36.5767074659342}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\nfor (auto &pair : _blueprints) {\nif (pair.second.HasAttribute(name)) {\nconst ActorBlueprint &blueprint = pair.second;\nif (blueprint.GetAttribute(name).as_string() == value) {\nresult.emplace(pair);\n}\n}\n}\nreturn SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 41.83107809426874}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Check if the file already exists\n\tif (FileExists(path)) {\n\t\treturn false;\n\t}\n\n\t// Check if the base folder exists, if not, create it\n\tif (!FileExists(_filesBaseFolder)) {\n\t\tif (!CreateFolder(_filesBaseFolder)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Check if the path ends in a slash, add it otherwise\n\tif (path[path.size() - 1] != '/' && path[path.size() - 1] != '\\\\') {\n\t\tpath += \"/\";\n\t}\n\n\t// Construct the full path\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Check if the path exists, if not, create it\n\tif (!FileExists(path)) {\n\t\tif (!CreateFolder(path)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tFILE *file = fopen(fullpath.c_str(), \"wb\");\n\tif (file == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file\n\tfwrite(&content[0], sizeof(uint8_t), content.size(), file);\n\n\t// Close the file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 42.97477468801066}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Check if the path is empty\n\tif (path.empty()) return false;\n\n\t// Check that the path ends in a slash, add it otherwise\n\tif (path[path.size() - 1] != '/' && path[path.size() - 1] != '\\\\') {\n\t\tpath += \"/\";\n\t}\n\n\t// Check that the path exists\n\tif (!boost::filesystem::exists(path)) {\n\t\treturn false;\n\t}\n\n\t// Check that the path is a directory\n\tif (!boost::filesystem::is_directory(path)) {\n\t\treturn false;\n\t}\n\n\t// Construct the full file path\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file\n\tfile.write((char *)content.data(), content.size());\n\n\t// Close the file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 53.106998440383904}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Check that the file path is valid\n\tif (fullpath.find(\"\\\\\") != std::string::npos || fullpath.find(\"/\") != std::string::npos) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file\n\tfile.write(reinterpret_cast<const char *>(content.data()), content.size());\n\n\t// Close the file and return true\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 55.92986333306359}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t#ifdef CARLA_ENABLE_DEBUG_ASSERTIONS\n    const auto parent_bounding_box = _parent_bounding_box.MakeTransformed(transform);\n    DEBUG_ASSERT(parent_bounding_box.Contains(transform.location));\n#endif // CARLA_ENABLE_DEBUG_ASSERTIONS\n    const auto location = transform.location + _parent_bounding_box.location;\n    const auto yaw = transform.rotation.yaw;\n    const auto corners = std::array<geom::Location, 4u>{\n        Rotate(yaw + 90.0f, location),\n        Rotate(yaw - 90.0f, location),\n        Rotate(yaw + 180.0f, location),\n        Rotate(yaw, location)};\n    return MakeShared<Bounds>(Bounds{frame, corners});\n  }", "CodeBleu_score": 48.623495464846926}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t#if DEBUG_LANE_INVENTION_SENSOR\n    const auto &location = transform.location;\n    DEBUG_ASSERT(location.z >= 0.0f);\n\n#endif // DEBUG_LANE_INVENTION_SENSOR\n    const auto yaw = transform.rotation.yaw;\n    const auto bb = _parent_bounding_box;\n    const auto corners = std::array<geom::Location, 4u>{\n        Rotate(yaw, bb.location_ + location),\n        Rotate(yaw, bb.location_ + geom::Location(bb.extent.x, bb.extent.y, 0.0f) + location),\n        Rotate(yaw, bb.location_ + geom::Location(bb.extent.x, -bb.extent.y, 0.0f) + location),\n        Rotate(yaw, bb.location_ + geom::Location(-bb.extent.x, -bb.extent.y, 0.0f) + location)};\n    return MakeShared<Bounds>(frame, corners);\n\n}", "CodeBleu_score": 57.65037866699918}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t#ifdef CARLA_ENABLE_DEBUG_ASSERTIONS\n    const auto yaw = transform.rotation.yaw * geom::Math::Pi<float>() / 180.0f;\n    const auto cos = std::cos(yaw);\n    const auto sin = std::sin(yaw);\n#endif // CARLA_ENABLE_DEBUG_ASSERTIONS\n\n    const auto location = transform.location + _parent_bounding_box.location;\n\n    geom::Location corners[4u];\n    for (auto i = 0u; i < 4u; ++i) {\n#ifdef CARLA_ENABLE_DEBUG_ASSERTIONS\n        const auto corner = Rotate(yaw, _parent_bounding_box.extent);\n#else\n        const auto corner = Rotate(yaw, _parent_bounding_box.extent[i]);\n#endif // CARLA_ENABLE_DEBUG_ASSERTIONS\n        corners[i] = location + corner;\n    }\n\n    return MakeShared<const Bounds>(Bounds{frame, {corners[0], corners[1], corners[2], corners[3]}});\n}", "CodeBleu_score": 43.53589509530881}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tstd::vector<carla::rpc::LightState> server_lights_state = _light_state_client->GetLightStates();\n\tfor(auto server_light_state : server_lights_state) {\n\t\tLightId id = server_light_state.id;\n\t\tauto it = _lights_state.find(id);\n\t\tif(it == _lights_state.end()) {\n\t\t\t_lights_state[id] = server_light_state;\n\t\t\t_lights[id] = Light(server_light_state);\n\t\t} else {\n\t\t\t_lights_state[id] = server_light_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.766387087110616}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Query the state of all the lights from the server\nauto lights_state = _world.GetLightManager().GetLightState();\n\n// Update the local light states\nfor(auto& light_state : lights_state) {\nLightId id = light_state.first;\nLightState state = light_state.second;\n\n// If the light does not exist, create a new one\nauto it_light = _lights.find(id);\nif(it_light == _lights.end()) {\n_lights[id] = Light(id, state._color, state._intensity, state._group, state._active);\n}\nelse {\n// Otherwise, update the existing one\nLight& light = it_light->second;\nlight._color = state._color;\nlight._intensity = state._intensity;\nlight._group = state._group;\nlight._active = state._active;\n}\n\n// Update the local light states\n_lights_state[id] = state;\n}\n\n// Clear the light changes\n_lights_changes.clear();\n\n// Set the dirty flag to false\n_dirty = false;\n}", "CodeBleu_score": 42.74807282363619}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t_lights_state = _server.QueryLightsState();\n\n\tfor(auto it = _lights_state.begin(); it != _lights_state.end(); ++it) {\n\t\tLightId id = it->first;\n\t\tLightState& state = it->second;\n\n\t\t// If the light does not exist in the _lights map, create it\n\t\tif(_lights.find(id) == _lights.end()) {\n\t\t\t_lights[id] = Light(id, state._color, state._intensity, state._group);\n\t\t}\n\t\telse {\n\t\t\t// Update the local light state\n\t\t\tLight& light = _lights[id];\n\t\t\tlight._id = id;\n\t\t\tlight._color = state._color;\n\t\t\tlight._intensity = state._intensity;\n\t\t\tlight._group = state._group;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.33485878433315}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif(_dirty) {\nstd::vector<rpc::LightState> lights_state_to_send;\nfor(auto& it : _lights_state) {\nif(_lights_changes.find(it.first) != _lights_changes.end()) {\nlights_state_to_send.push_back(rpc::LightState(\nit.second._intensity,\nit.second._color.r,\nit.second._color.g,\nit.second._color.b,\nstatic_cast<int>(it.second._group),\nit.second._active,\nit.first));\n}\n}\nif(lights_state_to_send.size() > 0) {\n_episode.Lock()->ApplyLightState(lights_state_to_send, discard_client);\n}\n_lights_changes.clear();\n_dirty = false;\n}\n}", "CodeBleu_score": 49.74476674164737}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Check if there are any changes\nif(_dirty) {\n// Create message\nrpc::LightStateList lights_msg;\nfor(const auto& it : _lights_changes) {\nrpc::LightState state;\nstate._id = it.first;\nstate._intensity = it.second._intensity;\nstate._color = it.second._color;\nstate._group = static_cast<int>(it.second._group);\nstate._active = it.second._active;\nlights_msg._lights.push_back(state);\n}\n\n\n// Send message\n_episode.Lock()->ApplyLightState(lights_msg, discard_client);\n\n// Clear changes\n_lights_changes.clear();\n_dirty = false;\n}\n}", "CodeBleu_score": 48.48896118045738}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif(_dirty) {\nstd::vector<rpc::LightState> light_states;\nfor(const auto& it : _lights_changes) {\nlight_states.push_back(rpc::LightState(\nit.second._id,\nit.second._color.r,\nit.second._color.g,\nit.second._color.b,\nit.second._intensity,\nstatic_cast<int32_t>(it.second._group),\nit.second._active));\n}\n_episode.Lock()->ApplyLightsState(light_states, discard_client);\n_lights_changes.clear();\n_dirty = false;\n}\n}", "CodeBleu_score": 46.86798944586293}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"sending message to sensor\", GetDisplayId(), \"but sensor ID does not match. Ignoring message...\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendSensorData(*this, std::move(message));\n}", "CodeBleu_score": 53.2407007471206}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send() called on a sensor that is not v2x_custom. This function will not do anything.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendSensorData(GetContext(), message);\n}", "CodeBleu_score": 43.61380465228943}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId() != \\\"sensor.other.v2x_custom\\\") {\n\t\tlog_warning(GetDisplayId(), \\\": Send() called but sensor's ID is not \\\"sensor.other.v2x_custom\\\", so it is not sending anything. Make sure that the sensor's ID is correct.\\\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendSensorData(*this, message);\n}", "CodeBleu_score": 52.559375456900945}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tauto traffic_manager = client::detail::Simulator::Get().GetTrafficManager(tm_port);\n\t\ttraffic_manager->RegisterVehicle(_id);\n\t} else {\n\t\tauto traffic_manager = client::detail::Simulator::Get().GetTrafficManager(tm_port);\n\t\ttraffic_manager->UnregisterVehicle(_id);\n\t}\n}", "CodeBleu_score": 42.534116956140835}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\t_traffic_manager = std::make_shared<TM>(tm_port);\n\t\t_traffic_manager->RegisterVehicle(this);\n\t} else {\n\t\t_traffic_manager->UnregisterVehicle(this);\n\t\t_traffic_manager = nullptr;\n\t}\n}", "CodeBleu_score": 40.772463244013046}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tauto tm = _world.GetTrafficManager(tm_port);\n\tif (enabled) {\n\t\ttm->RegisterVehicle(_id);\n\t} else {\n\t\ttm->UnregisterVehicle(_id);\n\t}\n}", "CodeBleu_score": 41.85682321482328}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tDEBUG_ASSERT(GetActor());\n\tDEBUG_ASSERT(GetActor()->HasComponent<WalkerNavigation>());\n\n\tauto *nav = GetActor()->GetComponent<WalkerNavigation>();\n\tauto *sim = GetActor()->GetWorld().GetSimulator();\n\n\tDEBUG_ASSERT(nav);\n\tDEBUG_ASSERT(sim);\n\n\tnav->RegisterAIController(this);\n\n\t// Get the walker actor.\n\tauto walker = GetActor();\n\tDEBUG_ASSERT(walker);\n\n\t// Disable the physics simulation and collisions for the walker actor.\n\twalker->DisablePhysics(true);\n\twalker->SetSimulatePhysics(false);\n\twalker->SetEnableCollision(false);\n\twalker->SetAngularDamping(0.0f);\n\twalker->SetLinearDamping(0.0f);\n}", "CodeBleu_score": 48.26884279157714}, {"code": "void WalkerAIController::Start(){\n\t\n// 1. Get the walker actor.\n\n// 2. Add the walker actor to the navigation system.\n\n// 3. Disable the physics simulation for the walker actor.\n\n// 4. Disable collisions for the walker actor.\n\n}", "CodeBleu_score": 1.214060050085495}, {"code": "void WalkerAIController::Start(){\n\t\tDEBUG_ASSERT(GetActor());\n\tDEBUG_ASSERT(GetActor()->HasComponent<WalkerControl>());\n\tDEBUG_ASSERT(GetActor()->HasComponent<WalkerPhysicsControl>());\n\tDEBUG_ASSERT(GetActor()->HasComponent<WalkerAnimationControl>());\n\tDEBUG_ASSERT(GetActor()->HasComponent<WalkerNavigation>());\n\n\tGetActor()->DisablePhysics();\n\tGetActor()->SetSimulatePhysics(false);\n\tGetActor()->SetActorEnableCollision(false);\n\n\tauto *nav = GetActor()-> GetComponent<WalkerNavigation>();\n\tnav->AddWalker(*GetActor());\n\n\tauto *control = GetActor()-> GetComponent<WalkerControl>();\n\tcontrol->ApplyWalkerControl(control->GetWalkerControl());\n}", "CodeBleu_score": 42.698642328986516}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (nav != nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker != nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set maximum speed to \", max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set maximum speed to \", max_speed, \" (parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 79.67776687136127}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\nif (nav != nullptr) {\nauto walker = GetParent();\nif (walker != nullptr) {\nif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\nlog_warning(\"NAV: Failed to set walker speed to \", max_speed);\n}\n} else {\nlog_warning(\"NAV: Failed to set walker speed to \", max_speed, \" (parent does not exist)\");\n}\n}\n}", "CodeBleu_score": 80.5028161929099}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (nav != nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker != nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set walker max speed\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set walker max speed (parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 90.76487834364825}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(waypoints.size());\n\tfor (auto &waypoint : waypoints) {\n\t\tresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n\t}\n\treturn result;\n}", "CodeBleu_score": 97.7382971857276}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\nstd::vector<road::element::Signal> signals = GetSignalsInDistance(distance, stop_at_junction);\n\nfor (auto &signal : signals) {\n\n  auto signal_waypoint = SharedPtr<Waypoint>(new Waypoint(_parent, signal.GetReferencePoint()));\n\n  auto signal_landmark = SharedPtr<Landmark>(new Landmark(signal_waypoint, signal));\n\n  if (std::find(result.begin(), result.end(), signal_landmark) == result.end()) {\n\n    result.emplace_back(signal_landmark);\n\n  }\n\n}\n\nreturn result;\n\n}", "CodeBleu_score": 50.04270037198515}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\nauto signals = GetSignalsInDistance(distance);\n\nfor (auto &signal : signals) {\n\nif (stop_at_junction && signal->GetJunction() != nullptr) {\n\nbreak;\n\n}\n\nauto signal_waypoint = signal->GetWaypoint();\n\nauto signal_distance = signal_waypoint->GetDistance()\n\n- GetDistance();\n\nif (signal_distance < distance) {\n\nauto landmark = SharedPtr<Landmark>(new Landmark(std::move(signal)));\n\nresult.emplace_back(std::move(landmark));\n\n}\n\n}\n\nreturn result;\n\n}", "CodeBleu_score": 47.13880639199852}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\nstd::vector<SharedPtr<Landmark>> result;\n    std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n    for (auto &signal : signals) {\n      if (std::find(result.begin(), result.end(), signal) == result.end()) {\n        result.emplace_back(signal->GetLandmark());\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 35.44186751934485}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto settings_id = _episode.Lock()->ApplySettings(settings);\n\t_settings_timeout = std::min(timeout, _episode.Lock()->GetSettings().network_settings.fixed_delta_seconds);\n\t_settings_id = settings_id;\n\t_settings_attempts = 0;\n\t_settings_max_attempts = static_cast<uint32_t>(std::ceil(_settings_timeout / _settings_tick_time));\n\treturn settings_id;\n}", "CodeBleu_score": 26.10926526391455}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n#ifdef DEBUG_SYNC\n  if (settings.synchronous_mode) {\n    DEBUG_ASSERT(!settings.fixed_delta_seconds.has_value());\n    DEBUG_ASSERT(!settings.substepping);  // TODO(filcab): Enable substepping in synchronous mode.\n  }\n#endif  // DEBUG_SYNC\n  auto id = _episode.Lock()->ApplySettings(settings);\n  if (settings.synchronous_mode) {\n    _episode.Lock()->SetFixedDeltaTime(settings.fixed_delta_seconds.value_or(0.05));\n  }\n  _timeout = std::max(timeout, _episode.Lock()->GetNetworkingTimeout());\n  return id;\n}", "CodeBleu_score": 30.51616423667217}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto settings_id = _simulator->ApplySettings(settings, timeout);\n\t_settings_id = settings_id;\n\treturn settings_id;\n}", "CodeBleu_score": 13.68578864212433}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat segment_length = (segment.second - segment.first).Length();\nif (segment_length == 0.0f) {\nreturn {0.0f, (point - segment.first).Length()};\n}\nVector3D segment_vector = (segment.second - segment.first).MakeUnitVector();\nfloat segment_projected_length = Dot(segment_vector, point - segment.first);\nif (segment_projected_length < 0.0f) {\nreturn {(point - segment.first).Length(), 0.0f};\n}\nelse if (segment_projected_length > segment_length) {\nreturn {(point - segment.second).Length(), 0.0f};\n}\nelse {\nVector3D segment_projected = segment_vector * segment_projected_length;\nreturn {(point - segment_projected).Length(), (point - segment_projected).Length()};\n}\n}", "CodeBleu_score": 28.738213360551313}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\n}", "CodeBleu_score": 3.377623342886302}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segment_squared_length = (b - a).SquaredLength();\n\tif (segment_squared_length == 0.0f) {\n\t\treturn std::make_pair(0.0f, (a - point).Length());\n\t}\n\tVector2D segment_direction = (b - a) / segment_squared_length;\n\tVector2D segment_projection = a + segment_direction * Dot(point - a, segment_direction);\n\treturn std::make_pair((segment_projection - point).Length(), (segment_projection - point).Length());\n}", "CodeBleu_score": 30.19544869924683}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t if (vertices.size() == 0) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum() + 1;\n AddVertices(vertices);\n while (i < GetVerticesNum()) {\n AddIndex(i);\n AddIndex(0);\n AddIndex(i + 1);\n ++i;\n }\n }", "CodeBleu_score": 67.43401547223189}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t if (vertices.size() == 0) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum() + 1;\n AddVertices(vertices);\n while (i < GetVerticesNum()) {\n AddIndex(0);\n AddIndex(i - 1);\n AddIndex(i);\n ++i;\n }\n }", "CodeBleu_score": 64.73405923462742}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t if (vertices.size() == 0) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum() + 1;\n AddVertices(vertices);\n while (i < GetVerticesNum()) {\n AddIndex(0);\n AddIndex(i);\n        AddIndex(i + 1);\n        ++i;\n      }\n    }", "CodeBleu_score": 69.90996962266216}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n\nDEBUG_ASSERT(_socket.is_open());\n\nDEBUG_ASSERT(message->size() <= _buffer_pool->max_size());\n\n\nauto buffer = _buffer_pool->pop();\n\n\nif (buffer == nullptr) {\n\nLOG_WARNING(\\\"Primary::Write: buffer pool is empty\\\");\n\nreturn;\n\n}\n\n\nstd::memcpy(buffer.get(), message->data(), message->size());\n\n\nboost::asio::async_write(\n_socket,\n\nboost::asio::buffer(buffer.get(), message->size()),\n\nboost::asio::bind_executor(\n\n_strand,\n\n[this, buffer = std::move(buffer), message]() mutable {\n\nif (_socket.is_open()) {\n\n_deadline.expires_after(_timeout);\n\n_deadline.async_wait(\n\n[this, buffer = std::move(buffer), message](const boost::system::error_code &ec) {\n\nif (ec != boost::asio::error::operation_aborted) {\n\nif (ec) {\n\nLOG_WARNING(\\\"Primary::Write: error sending message: \\\" << ec.message());\n\n} else {\n\nLOG_WARNING(\\\"Primary::Write: timeout sending message\\\");\n\n}\n\nClose();\n\n}\n\n}\n\n});\n\n}\n\n));\n\n}", "CodeBleu_score": 47.77564490008508}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message != nullptr);\n\n\n\tif (_socket.is_open()) {\n\n\t\tconst auto buffer = _buffer_pool->Get();\n\n\t\tconst auto bytes_written = carla::streaming::detail::tcp::Write(*message, buffer.get());\n\n\t\tboost::asio::async_write(\n\n\t\t\t_socket,\n\n\t\t\tboost::asio::buffer(buffer.get(), bytes_written),\n\n\t\t\tboost::asio::bind_executor(\n\n\t\t\t\t_strand,\n\n\t\t\t\t[this, buffer, message](const boost::system::error_code &ec, std::size_t /*bytes_transferred*/) {\n\n\t\t\t\t\tif (ec) {\n\n\t\t\t\t\t\tLOG_ERROR(\\\"Error writing to socket: \\\" << ec.message());\n\n\t\t\t\t\t\tClose();\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_buffer_pool->Put(std::move(buffer));\n\n\t\t\t\t\t_server.OnMessageSent(message);\n\n\t\t\t\t}\n\n\t\t\t)\n\n\t\t);\n\n\t}\n\n}", "CodeBleu_score": 36.43675387101874}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message != nullptr);\n\n\t// ensure message is valid\n\tif (!message->IsValid()) {\n\t\tlog_warning(\"invalid message, closing connection\")\n\t\tClose();\n\t\treturn;\n\t}\n\n\t// post lambda to strand\n\tboost::asio::post(\n\t\t_strand, [this, message = std::move(message)]() mutable {\n\t\t\t// check if socket is open\n\t\t\tif (!_socket.is_open()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// set timeout\n\t\t\t_deadline.expires_after(_timeout);\n\n\t\t\t// write\n\t\t\tboost::asio::async_write(\n\t\t\t\t_socket,\n\t\t\t\tboost::asio::buffer(message->data(), message->size()),\n\t\t\t\tboost::asio::bind_executor(\n\t\t\t\t\t_strand, [this](const boost::system::error_code &ec, std::size_t) {\n\t\t\t\t\t\tif (ec) {\n\t\t\t\t\t\t\tlog_error(\"write failed: {}\", ec.message())\n\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tReadData();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n}", "CodeBleu_score": 38.38568805931173}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (_deadline.expires_at() != boost::asio::deadline_timer::traits_type::zero()) {\n_deadline.cancel();\n}\nif (!ec && _socket.is_open()) {\nboost::system::error_code ignored_ec;\n_socket.shutdown(boost::asio::socket_base::shutdown_both, ignored_ec);\n_socket.close();\n}\nif (_on_closed) {\n_on_closed(shared_from_this(), ec);\n}\nlog_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 54.057035024774315}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec == boost::asio::error::operation_aborted) {\n\t\treturn;\n\t}\n\tif (_deadline.expires_at() != boost::asio::deadline_timer::traits_type::zero()) {\n\t\t_deadline.cancel();\n\t}\n\tif (_socket.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\t_socket.shutdown(boost::asio::socket_base::shutdown_both, ignored_ec);\n\t\t_socket.close(ignored_ec);\n\t}\n\tif (_on_closed) {\n\t\t_on_closed(ec);\n\t}\n\tlog_debug(\"session \", _session_id, \" closed\");\n}", "CodeBleu_score": 56.36296016111857}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (_deadline.expires_at() != boost::asio::deadline_timer::traits_type::zero()) {\n\t\t_deadline.cancel();\n\t}\n\tif (!ec && _socket.is_open()) {\n\t\tboost::system::error_code e;\n\t\t_socket.shutdown(boost::asio::socket_base::shutdown_both, e);\n\t\t_socket.close(e);\n\t}\n\t_on_closed(_session_id);\n\tlog_debug(\"session \", _session_id, \" closed\");\n}", "CodeBleu_score": 56.22459624154934}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tlog_info(\"sending is alive command\");\n\tcarla::Buffer buf;\n\t_router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tauto response = _router->ReadFromNext(MultiGPUCommand::YOU_ALIVE).get();\n\tlog_info(\"got is alive response: \", response.buffer.size());\n}", "CodeBleu_score": 56.90379663152187}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((unsigned char *) \"Are you alive?\", 17);\n\t_router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tauto response = _router->ReadFromNext(MultiGPUCommand::YOU_ALIVE).get();\n\tlog_info(\"got an answer: \", response.buffer.size(), \" bytes\");\n}", "CodeBleu_score": 50.02786348861551}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 14);\n\tlog_info(\"sending alive command\");\n\t_router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tauto response = _router->ReadFromNext(MultiGPUCommand::YOU_ALIVE).get();\n\tlog_info(\"got alive response\");\n}", "CodeBleu_score": 50.35700755897275}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::string msg = \"Enable ROS for \" + std::to_string(sensor_id);\n\tcarla::Buffer buf((unsigned char *) msg.c_str(), (size_t) msg.size());\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\tauto response = fut.get();\n\tstd::string response_string(response.buffer.data());\n\tif (response_string == \"Sensor not found\") {\n\t\tlog_error(\"Sensor not found\");\n\t}\n}", "CodeBleu_score": 49.30977336616573}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tauto it = _router->GetSecondaryServers().begin();\n\twhile (it != _router->GetSecondaryServers().end()) {\n\t\tauto server = *it;\n\t\tif (server->HasSensor(sensor_id)) {\n\t\t\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, sizeof(stream_id));\n\t\t\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\t\t\tauto response = fut.get();\n\t\t\tif (response.command == MultiGPUCommand::ENABLE_ROS) {\n\t\t\t\tserver->AddSensor(sensor_id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tit++;\n\t}\n\tif (it == _router->GetSecondaryServers().end()) {\n\t\tlog_error(\"Sensor \", sensor_id, \" not found on any secondary server.\");\n\t}\n}", "CodeBleu_score": 62.532893490763485}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// log_info(\\\"asking for a token\\\");\n\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\tauto response = fut.get();\n\tstd::string response_str(reinterpret_cast<const char *>(response.buffer.data()));\n\tif (response_str == \\\"OK\\\") {\n\t\tlog_info(\\\"sensor \\\", sensor_id, \\\" enabled for ROS\\\");\n\t} else {\n\t\tlog_error(\\\"sensor \\\", sensor_id, \\\" not found\\\");\n\t}\n}", "CodeBleu_score": 56.525303643102774}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t//   log_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n//   log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 29.91616485140977}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\nauto it = _servers.find(sensor_id);\nif (it != _servers.end()) {\n  // log_info(\"sensor \", sensor_id, \" already enabled\");\n  return it->second;\n} else {\n  // log_info(\"sensor \", sensor_id, \" not enabled, enabling\");\n  // enable the sensor on a secondary server\n  SendEnableForROS(sensor_id);\n\n  // get a token from the secondary server\n  token_type new_token = SendGetToken(sensor_id);\n\n  // update the maps\n  _servers[sensor_id] = new_token;\n\n  return new_token;\n}\n}", "CodeBleu_score": 41.35528446251586}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// log_info(\\\"asking for a token\\\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 36.94964837266488}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t#ifdef CARLA_ENABLE_DEBUG_DRAW\n    _debug_helper.Clear();\n#endif // CARLA_ENABLE_DEBUG_DRAW\n\n    std::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n      return false;\n    }\n\n    // read the file into a vector\n    std::vector<unsigned char> file_data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    file.close();\n\n    return Load(file_data);\n  }", "CodeBleu_score": 50.694588947420804}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.seekg(0, std::ios::end);\n\tstd::streampos size = file.tellg();\n\tfile.seekg(0, std::ios::beg);\n\tstd::vector<unsigned char> data(size);\n\tfile.read(reinterpret_cast<char *>(data.data()), size);\n\tfile.close();\n\treturn Load(data);\n}", "CodeBleu_score": 49.529857023186736}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\n#ifdef _WIN32\n  std::ifstream file(filename, std::ios::binary);\n#else\n  std::ifstream file(filename, std::ios::in | std::ios::binary);\n#endif\n\n  if (!file.is_open()) {\n    return false;\n  }\n\n  file.seekg(0, std::ios::end);\n  size_t size = file.tellg();\n  file.seekg(0, std::ios::beg);\n\n  std::vector<unsigned char> data(size);\n  if (!file.read(reinterpret_cast<char *>(data.data()), size)) {\n    return false;\n  }\n\n  file.close();\n\n  return Load(data);\n}", "CodeBleu_score": 52.972447357294975}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t", "CodeBleu_score": 1.060187825043224}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t#ifndef NDEBUG\n  if (id == INVALID_ACTOR_ID) {\n    logging::log(\\\"[WARNING] Attempting to remove an invalid actor id!\\\", logging::kWarning);\n\n    return false;\n\n  }\n\n#endif  // NDEBUG\n\n  if (!_ready) {\n\n    return false;\n\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // check if this actor exists\n\n  auto it_walker = _mapped_walkers_id.find(id);\n\n  if (it_walker != _mapped_walkers_id.end()) {\n\n    // get the index found\n\n    int index = it_walker->second;\n\n    if (index != -1) {\n\n      // critical section, force single thread running this\n\n      std::lock_guard<std::mutex> lock(_mutex);\n\n      // remove the agent\n\n      _crowd->removeAgent(index);\n\n      // remove from the manager\n\n      _walker_manager.RemoveWalker(id);\n\n      // remove from the mapping\n\n      _mapped_walkers_id.erase(it_walker);\n\n      _mapped_by_index.erase(index);\n\n      _yaw_walkers.erase(id);\n\n      return true;\n\n    }\n\n  }\n\n  // check if this actor exists\n\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n\n  if (it_vehicle != _mapped_vehicles_id.end()) {\n\n    // get the index found\n\n    int index = it_vehicle->second;\n\n    if (index != -1) {\n\n      // critical section, force single thread running this\n\n      std::lock_guard<std::mutex> lock(_mutex);\n\n      // remove the agent\n\n      _crowd->removeAgent(index);\n\n      // remove from the mapping\n\n      _mapped_vehicles_id.erase(it_vehicle);\n\n      _mapped_by_index.erase(index);\n\n      return true;\n\n    }\n\n  }\n\n  return false;\n\n}", "CodeBleu_score": 63.549939268554546}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(_crowd != nullptr);\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    // check if this actor exists\n    auto it_walker = _mapped_walkers_id.find(id);\n    if (it_walker != _mapped_walkers_id.end()) {\n      // get the index found\n      int index = it_walker->second;\n      if (index != -1) {\n        // remove the agent\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          _crowd->removeAgent(index);\n        }\n\n        // update the walker manager\n        _walker_manager.RemoveWalker(id);\n\n        // remove the id from the mappings\n        _mapped_walkers_id.erase(it_walker);\n        _mapped_by_index.erase(index);\n        _yaw_walkers.erase(id);\n\n        return true;\n      }\n    }\n\n    // check if this actor exists\n    auto it_vehicle = _mapped_vehicles_id.find(id);\n    if (it_vehicle != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it_vehicle->second;\n      if (index != -1) {\n        // remove the agent\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          _crowd->removeAgent(index);\n        }\n\n        // remove the id from the mappings\n        _mapped_vehicles_id.erase(it_vehicle);\n        _mapped_by_index.erase(index);\n\n        return true;\n      }\n    }\n\n    return false;\n  }", "CodeBleu_score": 63.9142983613433}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n// check if all is ready\nif (!_ready) {\nreturn false;\n}\n\nDEBUG_ASSERT(_nav_query != nullptr);\n\n// get the internal index\nauto it = _mapped_walkers_id.find(id);\nif (it == _mapped_walkers_id.end()) {\nreturn false;\n}\n\n// get the index found\nint index = it->second;\nif (index == -1) {\nreturn false;\n}\n\n// get the walker\nconst dtCrowdAgent *agent;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nagent = _crowd->getAgent(index);\n}\n\nif (!agent->active) {\nreturn false;\n}\n\n// get the position of the walker\nfloat x = agent->npos[0];\nfloat y = agent->npos[2];\nfloat z = agent->npos[1];\n\n// compute the direction vector\nfloat dx = direction.x - x;\nfloat dy = direction.y - z;\nfloat dz = direction.z - y;\nfloat inv_sqr_magnitude = 1.0f / (dx * dx + dy * dy + dz * dz);\nfloat dir_x = dx * inv_sqr_magnitude;\nfloat dir_y = dy * inv_sqr_magnitude;\nfloat dir_z = dz * inv_sqr_magnitude;\n\n// find nearby vehicles\nfloat nearest_distance = distance;\nbool found = false;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nfound = _crowd->getNeighbourAgentDist(index, dir_x, dir_y, dir_z, nearest_distance, nullptr, nullptr);\n}\n\nreturn found;\n}", "CodeBleu_score": 54.169296581575}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current point\n\n\tWalkerRoutePoint &point = info.route[info.currentIndex];\n\n\t// create a visitor with the context\n\n\tWalkerEventVisitor visitor(id, info, delta);\n\n\n\t// process the event\n\n\treturn boost::apply_visitor(visitor, point.event);\n\n}", "CodeBleu_score": 51.5702863520087}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tWalkerRoutePoint &point = info.route[info.currentIndex];\n\t// create the visitor\n\tWalkerEventVisitor visitor(id, _simulator, _nav, point.location, delta);\n\t// process the event\n\treturn boost::apply_visitor(visitor, point.event);\n}", "CodeBleu_score": 60.83795383789356}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tWalkerRoutePoint &routePoint = info.route[info.currentIndex];\n\n\t// create the visitor\n\tWalkerEventVisitor visitor(id, info, delta);\n\n\t// process the event\n\tboost::variant2::visit(visitor, routePoint.event);\n\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 52.245192001961385}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\nfor (pugi::xml_node road_node : xml.children(\\\"road\\\")) {\n\n// Retrieve road ID\nconst std::string id = road_node.attribute(\\\"id\\\").value();\n\n// Iterate through each lane section\nfor (pugi::xml_node lane_section_node : road_node.children(\\\"lanes\\\")) {\n\n// Retrieve lane section s-offset\nconst double s_offset = lane_section_node.attribute(\\\"sOffset\\\").as_double();\n\n// Retrieve each lane node\npugi::xml_node left_lane_node = lane_section_node.child(\\\"left\\\");\npugi::xml_node center_lane_node = lane_section_node.child(\\\"center\\\");\npugi::xml_node right_lane_node = lane_section_node.child(\\\"right\\\");\n\n// Parse lanes\nParseLanes(left_lane_node, map_builder);\nParseLanes(center_lane_node, map_builder);\nParseLanes(right_lane_node, map_builder);\n\n// Call MapBuilder CreateRoad function\nmap_builder.CreateRoad(id, s_offset);\n}\n}\n}", "CodeBleu_score": 42.44185473182679}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n#ifdef DEBUG_LANE_PARSER\n  std::cout << \"Parsing Lane Sections\" << std::endl;\n#endif\n\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.children(\\\"road\\\")) {\n\n    // Retrieve road id\n    const std::string id = road_node.attribute(\\\"id\\\").value();\n\n    // Iterate through each lane section\n    for (pugi::xml_node lane_section_node : road_node.children(\\\"lanes\\\")) {\n\n      // Retrieve lane section id\n      const std::string lane_section_id = lane_section_node.attribute(\\\"id\\\").value();\n\n      // Iterate through each lane\n      for (pugi::xml_node lane_node : lane_section_node.children(\\\"lane\\\")) {\n\n        // Retrieve lane id\n        const std::string lane_id = lane_node.attribute(\\\"id\\\").value();\n\n        // Retrieve lane type\n        const std::string type = lane_node.attribute(\\\"type\\\").value();\n\n        // Retrieve lane width\n        const double width = lane_node.attribute(\\\"width\\\").as_double();\n\n        // Retrieve lane length\n        const double length = lane_node.attribute(\\\"length\\\").as_double();\n\n        // Retrieve lane s-offset\n        const double s_offset = lane_node.attribute(\\\"sOffset\\\").as_double();\n\n        // Retrieve lane left\n        const std::string left_lane_id = lane_node.attribute(\\\"left\\\").value();\n\n        // Retrieve lane right\n        const std::string right_lane_id = lane_node.attribute(\\\"right\\\").value();\n\n        // Retrieve lane center\n        const std::string center_lane_id = lane_node.attribute(\\\"center\\\").value();\n\n        // Parse lane\n        ParseLane(\n            lane_node,\n            map_builder,\n            id,\n            lane_section_id,\n            lane_id,\n            type,\n            width,\n            length,\n            s_offset,\n            left_lane_id,\n            right_lane_id,\n            center_lane_id);\n      }\n    }\n  }\n}", "CodeBleu_score": 42.52558575597549}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n  if (info.current_count_change == 1) {\n    _matched += 1;\n    if (_first_connected == false) {\n      _first_connected = true;\n      std::cout << \\\"First connection detected\\\" << std::endl;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched -= 1;\n  } else if (info.current_count_change != 0) {\n    std::cout << \\\"Unexpected count change\\\" << std::endl;\n  }\n}", "CodeBleu_score": 59.55664494909803}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\\tif (info.current_count_change == 1) {\n\\t\\t_matched = info.total_count;\n\\t\\tif (!_first_connected) {\n\\t\\t\\t_first_connected = true;\n\\t\\t}\n\\t} else if (info.current_count_change == -1) {\n\\t\\t_matched = info.total_count;\n\\t} else if (info.current_count_change != 0) {\n\\t\\tstd::cerr << \\\"Unexpected count change \\\" << info.current_count_change << \\\" detected on topic \\\" << writer->get_topic()->get_name() << std::endl;\n\\t}\n}", "CodeBleu_score": 58.41896029657592}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n\\tif (info.current_count_change == 1) {\n\\t\\t_matched++;\n\\t\\tif (_matched == 1) {\n\\t\\t\\t_first_connected = true;\n\\t\\t}\n\\t} else if (info.current_count_change == -1) {\n\\t\\tif (_matched > 0) {\n\\t\\t\\t_matched--;\n\\t\\t} else {\n\\t\\t\\tstd::cout << \\\"Error: Current count change \\\" << info.current_count_change << \\\" on topic \\\" << writer->get_topic()->get_name() << std::endl;\n\\t\\t}\n\\t} else {\n\\t\\tstd::cout << \\\"Error: Current count change \\\" << info.current_count_change << \\\" on topic \\\" << writer->get_topic()->get_name() << std::endl;\n\\t}\n}", "CodeBleu_score": 43.47309536511651}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\n  if (info.current_count_change == 1) {\n    // New match\n    _matched += 1;\n    if (!_first_connected) {\n      _first_connected = true;\n      _owner->set_connected(true);\n    }\n  } else if (info.current_count_change == -1) {\n    // Removed match\n    _matched -= 1;\n    if (_matched == 0) {\n      _owner->set_connected(false);\n      _owner->destroy_subscription();\n    }\n  } else {\n    // Other error\n    std::cout << \\\"Error \\\" << erc::toString(info.status) << \\\" in CarlaSubscriberListenerImpl::on_subscription_matched\\\" << std::endl;\n  }\n}", "CodeBleu_score": 58.02128104462879}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\\tif (info.current_count_change == 1) {\n\\t\\t_matched += 1;\n\\t\\tif (!_first_connected) {\n\\t\\t\\t_first_connected = true;\n\\t\\t}\n\\t} else if (info.current_count_change == -1) {\n\\t\\t_matched -= 1;\n\\t\\tif (_matched == 0) {\n\\t\\t\\t_owner->destroy_subscription();\n\\t\\t}\n\\t} else {\n\\t\\tstd::cout << \\\"Unexpected matched status \\\" << info.current_count_change << std::endl;\n\\t}\n}", "CodeBleu_score": 46.81775683007024}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t#if defined(VERBOSE_LOGGING)\n  std::cout << \\\"[CarlaSubscriberListenerImpl::on_subscription_matched] Matched \\\" << info.current_count_change << \\\" times. \\\" << std::endl;\n#endif\n  if (info.current_count_change == 1) {\n    _matched = info.total_count;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched = info.total_count;\n    if (_matched == 0) {\n      _owner->destroy();\n    }\n  } else {\n#if defined(VERBOSE_LOGGING)\n    std::cout << \\\"[CarlaSubscriberListenerImpl::on_subscription_matched] Unexpected current_count_change \\\" << info.current_count_change << std::endl;\n#endif\n  }\n}", "CodeBleu_score": 65.51589732806003}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#ifdef FASTCDR_IS_AVAILABLE\n    if (m_isGetKeyDefined) {\n        CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n        p_type->serializeKey(ser);\n        if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n            m_md5.init();\n            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n            m_md5.finalize();\n            for (uint8_t i = 0; i < 16; ++i) {\n                handle->value[i] = m_md5.digest[i];\n            }\n        } else {\n            for (uint8_t i = 0; i < 16; ++i) {\n                handle->value[i] = m_keyBuffer[i];\n            }\n        }\n        return true;\n    }\n#else\n    (void)data;\n    (void)handle;\n    (void)force_md5;\n#endif // FASTCDR_IS_AVAILABLE\n    return false;\n}", "CodeBleu_score": 92.76660656436415}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#ifdef FASTCDR_IS_AVAILABLE\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    if (m_isGetKeyDefined == false)\n    {\n        return false;\n    }\n\n    if (force_md5 || m_keyBuffer == nullptr)\n    {\n        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n        p_type->serializeKey(ser);\n        if (m_keyBuffer != nullptr)\n        {\n            MD5 md5;\n            md5.update(m_keyBuffer, ser.getSerializedDataLength());\n            md5.finalize();\n            for (int i = 0; i < 16; ++i)\n            {\n                handle->value[i] = md5.digest[i];\n            }\n        }\n        return true;\n    }\n    else\n    {\n        (void)memcpy(handle, m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n        return true;\n    }\n\n#else\n    (void)data;\n    (void)handle;\n    (void)force_md5;\n    return false;\n#endif // FASTCDR_IS_AVAILABLE\n}", "CodeBleu_score": 64.73184947321559}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#ifdef FASTCDR_IS_AVAILABLE\n            CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n            if (m_isGetKeyDefined == false) {\n                return false;\n            }\n\n            if (!m_keyBuffer) {\n                return false;\n            }\n\n            eprosima::fastcdr::FastBuffer fastbuffer(m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n            p_type->serializeKey(ser);\n            if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n                m_md5.init();\n                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n                m_md5.finalize();\n                for (uint8_t i = 0; i < 16; ++i) {\n                    handle->value[i] = m_md5.digest[i];\n                }\n            } else {\n                for (uint8_t i = 0; i < 16; ++i) {\n                    handle->value[i] = m_keyBuffer[i];\n                }\n            }\n            return true;\n\n#else\n            (void)data;\n            (void)handle;\n            (void)force_md5;\n            return false;\n#endif // FASTCDR_IS_AVAILABLE\n        }", "CodeBleu_score": 85.62955917807784}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t(void)data;\n    if (payload == nullptr) {\n        return false;\n    }\n\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr cdr(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    if (p_type->serialize(cdr)) {\n        payload->length = static_cast<uint32_t>(cdr.getSerializedDataLength()); //Get the serialized length\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 67.12509192538253}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t", "CodeBleu_score": 2.5978767707221393}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t#ifdef FASTCDR_IS_BIG_ENDIAN\n    eprosima::fastcdr::Cdr ser(\n        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,\n        eprosima::fastcdr::Cdr::DDS_CDR);\n#else\n    eprosima::fastcdr::Cdr ser(\n        eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,\n        eprosima::fastcdr::Cdr::DDS_CDR);\n#endif\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    payload->length = static_cast<uint32_t>(m_typeSize) + 4; /* Account for the encapsulation */\n\n    try\n    {\n        if (m_isGetKeyDefined)\n        {\n            CarlaEgoVehicleControl::serializeKey(ser, m_keyBuffer, m_keyBufferLength);\n            ser.serializeArray(m_keyBuffer, m_keyBufferLength);\n        }\n\n        ser.serialize(data, m_typeSize); // serialize the object:\n\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 61.55376445591073}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// decode\nmavlink_heartbeat_t packet;\nmavlink_msg_heartbeat_decode(&msg, &packet);\n\nif (packet.type == MAVLINK_TYPE_ONBOARD_CONTROLLER) {\n// we are tracking a controller\nif (tracker.g.sysid_target != 0) {\n// we are already tracking a controller\nreturn;\n}\ntracker.g.sysid_target = msg.sysid;\n\n// request streams from the target\ntracker.mavlink_send_command_long(tracker.g.sysid_target, tracker.g.compid_target, MAVLINK_CMD_REQUEST_MESSAGE, 0, 1, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 0, 0, 0, 0, 0, 0, 0, 0);\ntracker.mavlink_send_command_long(tracker.g.sysid_target, tracker.g.compid_target, MAVLINK_CMD_REQUEST_MESSAGE, 0, 1, MAVLINK_MSG_ID_SCALED_PRESSURE, 0, 0, 0, 0, 0, 0, 0, 0);\n}\n}", "CodeBleu_score": 44.68890052599865}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.g.sysid_target != 0) {\n\t\treturn;\n\t}\n\n\tmavlink_check_target_t packet;\n\tmavlink_msg_check_target_decode(&msg, &packet);\n\n\tif (packet.type != 0) {\n\t\treturn;\n\t}\n\n\ttracker.g.sysid_target = packet.target_system;\n\ttracker.g.compid_target = packet.target_component;\n\n\ttracker.stream_request(STREAM_RAW_SENSORS);\n\ttracker.stream_request(STREAM_EXTENDED_STATUS);\n\ttracker.stream_request(STREAM_POSITION);\n\ttracker.stream_request(STREAM_RAW_CONTROLLER);\n\ttracker.stream_request(STREAM_RC_CHANNELS);\n\ttracker.stream_request(STREAM_EXTRA1);\n\ttracker.stream_request(STREAM_EXTRA3);\n\ttracker.stream_request(STREAM_PARAMS);\n}", "CodeBleu_score": 41.55973386963356}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// decode\n\tmavlink_heartbeat_t packet;\n\tmavlink_msg_heartbeat_decode(&msg, &packet);\n\n\t// check if target has been set\n\tif (tracker.g.sysid_target != 0) {\n\t\treturn;\n\t}\n\n\t// check if we have a system ID\n\tif (packet.get_type() != MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\t// set the target system ID\n\ttracker.g.sysid_target = packet.get_system_id();\n\n\t// set the target system ID\n\ttracker.g.sysid_target = packet.get_system_id();\n\n\t// set the target system ID\n\ttracker.g.sysid_target = packet.get_system_id();\n\n\t// request position and pressure data streams\n\ttracker.gcs_mavlink.send_request_data_stream_send(tracker.g.sysid_target, tracker.g.compid_target, MAV_DATA_STREAM_POSITION, MAV_DATA_STREAM_PRESSURE, 1, 1);\n\ttracker.gcs_mavlink.send_request_data_stream_send(tracker.g.sysid_target, tracker.g.compid_target, MAV_DATA_STREAM_RAW_SENSORS, MAV_DATA_STREAM_PRESSURE, 1, 1);\n}", "CodeBleu_score": 49.32621711879776}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// decode\n\tmavlink_command_long_t packet;\n\tmavlink_msg_command_long_decode(&msg, &packet);\n\n\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// if the base class handler accepted the command, set the flag to indicate we need to do an altitude calibration on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\ttracker.set_altitude_calibration_needed(true);\n\t}\n\n\t// return result of base class handler\n\treturn result;\n}", "CodeBleu_score": 57.568918831361785}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t#if HAL_BARO_AVAILABLE\n    // decode\n    mavlink_command_long_t packet;\n    mavlink_msg_command_long_decode(&msg, &packet);\n\n    // call base class handler\n    MAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n    // if the base class handler accepted the command, set the flag to indicate that we need to do an altitude calibration on the next barometer update\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.g.calibrating_baro = true;\n    }\n\n    return result;\n#else\n    return MAV_RESULT_UNSUPPORTED;\n#endif\n}", "CodeBleu_score": 65.36736676932493}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\nmavlink_command_long_t cmd;\nmavlink_msg_command_long_decode(&msg, &cmd);\n\nreturn GCS_MAVLINK::preflight_check_result(cmd.command, cmd.result, _handle_command_preflight_calibration(msg));\n}", "CodeBleu_score": 33.26306532539567}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n    uint8_t arm;\n    arm = (uint8_t)packet.param1;\n#else\n    uint8_t arm;\n    mavlink_msg_command_int_get_arm(&packet, &arm);\n#endif\n\n    if (arm == 1.0) {\n        tracker.arm();\n        return MAV_RESULT_ACCEPTED;\n    } else if (arm == 0) {\n        tracker.disarm();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 57.47715883454143}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.gcs().arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.gcs().disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 57.91768138260942}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n    uint8_t arm = mavlink_msg_command_int_get_param1(msg);\n    uint8_t target_system = mavlink_msg_command_int_get_target_system(msg);\n    uint8_t target_component = mavlink_msg_command_int_get_target_component(msg);\n#else\n    uint8_t arm = mavlink_msg_command_int_get_param1(msg);\n    uint8_t target_system = mavlink_msg_command_int_get_target_system(msg);\n    uint8_t target_component = mavlink_msg_command_int_get_target_component(msg);\n#endif // MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n\n    if (arm == 1.0) {\n        tracker.gcs().arm_servos(target_system, target_component);\n        return MAV_RESULT_ACCEPTED;\n    } else if (arm == 0.0) {\n        tracker.gcs().disarm_servos(target_system, target_component);\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 47.96266670209732}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < NUM_GCS_CHANNELS; i++) {\n\t\tif (tracker.gcs_channels[i].available_payload_space() >= 20) {\n\t\t\ttracker.gcs_channels[i].send_datastream_position_request(sysid, compid);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.97756721719319}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < tracker.g.num_gcs; i++) {\n\t\tif (tracker.gcs[i].sysid == sysid && tracker.gcs[i].compid == compid) {\n\t\t\tif (tracker.gcs[i].num_channels_available() > 0) {\n\t\t\t\ttracker.gcs[i].request_datastream_position(tracker.gcs[i].channels[tracker.gcs[i].num_channels_used].chanid, tracker.gcs[i].channels[tracker.gcs[i].num_channels_used].rate);\n\t\t\t\ttracker.gcs[i].num_channels_used++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.26116323138966}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS\n    mavlink_message_t msg;\n    mavlink_request_data_stream_message_init(&msg, sysid, compid, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, 2, 12, 0, 0, 0, 0);\n#else\n    mavlink_message_t msg;\n    mavlink_request_data_stream_message_init_buf(&msg, sysid, compid, MAVLINK_MSG_ID_REQUEST_DATA_STREAM, 2, 12, 0, 0, 0, 0);\n#endif\n\n    for (int i = 0; i < MAVLINK_MAX_PAYLOAD_LEN; i++) {\n        if (i >= 2)\n            break;\n\n        if (MAVLINK_BYTE_LENGTH(msg) < 2)\n            break;\n\n        mavlink_msg_to_send_buffer(msg.pack_buffer, &msg, i);\n        this->send_message(&msg);\n    }\n}", "CodeBleu_score": 44.363829374119945}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tconst AP_AHRS &ahrs = AP::ahrs();\n\tfloat pitch_cos = ahrs.cos_pitch();\n\tif (pitch_cos != 0) {\n\t\tef_pitch = pitch * pitch_cos + ahrs.sin_pitch() * yaw;\n\t\tef_yaw = -ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 66.10545716559373}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = ahrs.cos_pitch() * pitch + ahrs.sin_pitch() * yaw;\n\tef_yaw = -ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\treturn true;\n}", "CodeBleu_score": 72.15057275727706}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch() != 0) {\n\t\tef_pitch = ahrs.cos_pitch() * pitch + ahrs.sin_pitch() * ahrs.cos_roll() * yaw;\n\t\tef_yaw = -ahrs.sin_pitch() * pitch + ahrs.cos_roll() * ahrs.cos_pitch() * yaw;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 71.23613725914271}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\tif (tracker.get_status() == Tracker::STATUS_INITIALIZING) {\n\t\treturn;\n\t}\n\n\t// Get the current yaw and pitch in centidegrees\n\tint16_t yaw_cd = tracker.get_yaw_cd();\n\tint16_t pitch_cd = tracker.get_pitch_cd();\n\n\t// Check if the direction is reversed\n\tif (tracker.get_direction() == Tracker::DIRECTION_REVERSE) {\n\t\tyaw_cd = -yaw_cd;\n\t\tpitch_cd = -pitch_cd;\n\t}\n\n\t// Calculate the error in centidegrees\n\tint16_t yaw_error_cd = yaw_cd - tracker.get_target_yaw_cd();\n\tint16_t pitch_error_cd = pitch_cd - tracker.get_target_pitch_cd();\n\n\t// Convert the error to body frame\n\tint16_t yaw_error_bf = tracker.yaw_cd_to_bf(yaw_error_cd);\n\tint16_t pitch_error_bf = tracker.pitch_cd_to_bf(pitch_error_cd);\n\n\t// Check if the target distance is valid or if no minimum distance is set\n\tif (tracker.get_target_distance() >= 0 || tracker.get_min_target_distance() < 0) {\n\t\t// Compute the angle error\n\t\tint16_t angle_error_bf = sqrt(yaw_error_bf * yaw_error_bf + pitch_error_bf * pitch_error_bf);\n\n\t\t// Check if the angle error is less than the threshold\n\t\tif (angle_error_bf < tracker.get_angle_error_bf()) {\n\t\t\t// Set the servos to the target angles\n\t\t\ttracker.set_servos(tracker.get_target_yaw_bf(), tracker.get_target_pitch_bf());\n\t\t} else {\n\t\t\t// Set the servos to the angle error\n\t\t\ttracker.set_servos(yaw_error_bf, pitch_error_bf);\n\t\t}\n\t} else {\n\t\t// Set the servos to the angle error\n\t\ttracker.set_servos(yaw_error_bf, pitch_error_bf);\n\t}\n}", "CodeBleu_score": 33.31185672499524}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t\tif (tracker.get_mode() != MODE_AUTO) {\n\t\treturn;\n\t}\n\tif (tracker.get_nav_status() == NAV_STATUS_NONE) {\n\t\treturn;\n\t}\n\tif (tracker.get_nav_status() == NAV_STATUS_LOST) {\n\t\ttracker.set_mode(MODE_LOST);\n\t\treturn;\n\t}\n\tif (tracker.get_nav_status() == NAV_STATUS_COMPLETE) {\n\t\ttracker.set_mode(MODE_COMPLETE);\n\t\treturn;\n\t}\n\n\t// Get the target yaw and pitch in centidegrees.\n\tint target_yaw = tracker.get_target_yaw();\n\tint target_pitch = tracker.get_target_pitch();\n\n\t// Check if the direction is reversed.\n\tbool direction_reversed = tracker.get_direction_reversed();\n\n\t// Calculate the angle error in centidegrees.\n\tint angle_error_yaw = tracker.get_angle_error_yaw();\n\tint angle_error_pitch = tracker.get_angle_error_pitch();\n\n\t// Convert the angle error from earth frame to body frame.\n\tint angle_error_yaw_body = angle_error_yaw;\n\tint angle_error_pitch_body = angle_error_pitch;\n\tif (direction_reversed) {\n\t\tangle_error_yaw_body = -angle_error_yaw;\n\t\tangle_error_pitch_body = -angle_error_pitch;\n\t}\n\n\t// Calculate the target distance.\n\tfloat target_distance = tracker.get_target_distance();\n\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos.\n\tif (target_distance >= tracker.get_min_distance() || tracker.get_min_distance() == 0.0f) {\n\t\t// Calculate the yaw and pitch in centidegrees.\n\t\tint yaw = tracker.get_yaw() + angle_error_yaw_body;\n\t\tint pitch = tracker.get_pitch() + angle_error_pitch_body;\n\n\t\t// Set the yaw and pitch.\n\t\ttracker.set_yaw(yaw);\n\t\ttracker.set_pitch(pitch);\n\t}\n}", "CodeBleu_score": 33.553033754098124}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}, {"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}, {"code": "void Tracker::update_GPS(void){\n\t#if GPS_TYPE == GPS_TYPE_UBLOX\n    ublox.update();\n#endif\n    gps.update();\n    if (gps.new_message) {\n        gps.new_message = false;\n        if (gps.status() >= 3) {\n            gps_countdown = GPS_COUNTDOWN;\n        }\n        if (gps_countdown > 0) {\n            gps_countdown--;\n            if (gps_countdown == 0) {\n                if (gps.status() >= 3) {\n                    if (gps.status() >= 3) {\n                        gps_home_valid = true;\n                        gps.get_position(gps_home_lat, gps_home_lon, gps_home_alt);\n                        gps.get_velocity(gps_home_vel_n, gps_home_vel_e, gps_home_vel_d);\n                        gps_home_time = hal.scheduler->micros();\n                        gps.get_time(gps_home_year, gps_home_month, gps_home_day, gps_home_hour, gps_home_min, gps_home_sec, gps_home_valid);\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 37.514657206393125}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t//    // calculate new servo position\n//    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n//\n//    // position limit pitch servo\n//    if (new_servo_out <= pitch_min_cd) {\n//        new_servo_out = pitch_min_cd;\n//        g.pidPitch2Srv.reset_I();\n//    }\n//    if (new_servo_out >= pitch_max_cd) {\n//        new_servo_out = pitch_max_cd;\n//        g.pidPitch2Srv.reset_I();\n//    }\n//    // rate limit pitch servo\n//    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n//\n//    if (pitch_servo_out_filt_init) {\n//        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n//    } else {\n//        pitch_servo_out_filt.reset(new_servo_out);\n//        pitch_servo_out_filt_init = true;\n//    }\n}", "CodeBleu_score": 4.699969814793938}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\n}", "CodeBleu_score": 4.699969814793938}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t}", "CodeBleu_score": 4.699969814793938}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t#if AP_BARO_ENABLED == 0\n    // barometer disabled\n    return true;\n#endif\n\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    // call base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro altitude vs inertial nav altitude\n    if (fabsf(baro.get_altitude() - inertial_nav.get_altitude()) > copter.g.baro_max_diff) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \\\"Baro altitude out of range\\\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 36.27004967917608}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.terrain_source == RangeFinder) {\n\t\treturn false;\n\t} else if (copter.terrain_source == TerrainDatabase && copter.g.RTL_alt_type == RTL_ALT_TERRAIN) {\n\t\treturn true;\n\t} else {\n\t\treturn AP_Arming::terrain_database_required();\n\t}\n}", "CodeBleu_score": 56.10382276372901}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t#if AP_TERRAIN_AVAILABLE\n    // If the terrain source is from a rangefinder, it returns false.\n    if (copter.terrain.get_terrain_source() == RangeFinder) {\n        return false;\n    }\n\n    // If the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true.\n    if (copter.terrain.get_terrain_source() == Database && copter.g.rtl_alt == RTL_ALT_TERRAIN) {\n        return true;\n    }\n#endif\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 64.25698459191732}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.terrain_source == RangeFinder) {\n\t\treturn false;\n\t}\n\tif (copter.terrain_source == TerrainDatabase && copter.g.RTL_ALT == RTL_ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.181548058867364}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\n//  if (!thread_running) {\n//      return;\n//  }\n\n//  if (should_exit) {\n//      thread_should_exit = true;\n//      return;\n//  }\n\n    // get the time of the last loop iteration\n    uint32_t now = hal.scheduler->micros();\n    uint32_t dt = now - loop_time;\n    loop_time = now;\n\n    // run the attitude controller\n    if (rc_type == RC_TYPE_PPM) {\n        // run the attitude controller\n        attitude_control.rate_controller_run(dt);\n    } else {\n        // run the attitude controller\n        attitude_control.rate_controller_run(dt);\n    }\n\n    // run the position controller\n    position_control.update_velocity_controller(dt);\n\n    // run the motor controller\n    motor_control.run(dt);\n}", "CodeBleu_score": 47.83400957233803}, {"code": "void Copter::run_rate_controller(){\n\t\n#if CLI_ENABLED == ENABLED\n    // update the loop time\n    loop_time_max = scheduler.get_loop_time_max();\n    loop_time_avg = scheduler.get_loop_time_avg();\n    loop_time_mark = scheduler.get_loop_time_mark();\n#endif\n\n    // run the attitude controller\n    attitude_control.rate_controller_run();\n\n    // run the position controller\n    position_control.update();\n\n    // run the motor controller\n    motor_control.update();\n}", "CodeBleu_score": 36.84944099133592}, {"code": "void Copter::run_rate_controller(){\n\t", "CodeBleu_score": 3.377031594114963}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t#if MODE_GUIDED_ENABLED == ENABLED\n    if (flightmode->in_guided_mode()) {\n        // get the next waypoint\n        Location target_loc;\n        if (!flightmode->get_wp(target_loc)) {\n            return false;\n        }\n\n        // if the target location hasn't changed, do nothing\n        if (old_loc.alt_relative == target_loc.alt_relative &&\n            old_loc.alt_frame == target_loc.alt_frame &&\n            old_loc.lat == target_loc.lat &&\n            old_loc.lng == target_loc.lng &&\n            old_loc.alt == target_loc.alt) {\n            return false;\n        }\n\n        // if the altitude frames of the old and new locations are the same, set the target location\n        if (old_loc.alt_frame == new_loc.alt_frame) {\n            set_target_location(target_loc);\n        }\n\n        // otherwise, return false\n        return false;\n    }\n#endif\n    return false;\n}", "CodeBleu_score": 50.861313336507116}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t", "CodeBleu_score": 6.3425680697773075}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t#if MODE_GUIDED_ENABLED == ENABLED\n    // only update target location if we are in guided mode\n    if (flightmode != &mode_guided) {\n        return false;\n    }\n\n    // if the old and new locations are the same, return true\n    if (old_loc.alt_relative == new_loc.alt_relative &&\n        old_loc.alt_frame == new_loc.alt_frame &&\n        old_loc.lat == new_loc.lat &&\n        old_loc.lng == new_loc.lng &&\n        old_loc.alt == new_loc.alt) {\n        return true;\n    }\n\n    // otherwise, set the new location as the target\n    return set_target_location(new_loc);\n#else\n    // mode guided not enabled, return false\n    return false;\n#endif\n}", "CodeBleu_score": 46.586838206584225}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t#if AP_AHRS_AVAILABLE\n    if (ch_flag == AuxSwitchPos::LOW && mode == copter.ahrs.get_mode()) {\n        // if the switch is in the LOW position and the mode is the same as the current AHRS mode,\n        // then reset the mode switch\n        rc().reset_mode_switch();\n    }\n#endif\n    if (ch_flag == AuxSwitchPos::HIGH && mode != copter.ahrs.get_mode()) {\n        // if the switch is in the HIGH position and the mode is not the same as the current AHRS mode,\n        // then set the mode\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    }\n}", "CodeBleu_score": 57.59834739098996}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\t// attempt to set the mode\n\t\tif (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t// check if the mode matches the current flight mode\n\t\tif (copter.flight_mode == mode) {\n\t\t\t// reset the mode switch\n\t\t\trc().reset_mode_switch(mode);\n\t\t}\n\t}\n}", "CodeBleu_score": 51.51722926809175}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (copter.mode == mode) {\n\t\t\trc().reset_mode_switch(mode);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.83375347729078}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t#if FRAME_CONFIG == HELI_FRAME\n    // TODO: implement heli trim saving\n    return;\n#endif\n\n    // get the trim values in degrees\n    float roll_trim_deg = (float)get_channel(ROLL_TRIM) / 100.0f;\n    float pitch_trim_deg = (float)get_channel(PITCH_TRIM) / 100.0f;\n\n    // convert to radians\n    float roll_trim_rad = roll_trim_deg * math::radians(1.0f);\n    float pitch_trim_rad = pitch_trim_deg * math::radians(1.0f);\n\n    // add the trim values to the AHRS\n    ahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n    // log the trim values\n    DataFlash.Log_Write_Float(ahrs.get_roll_trim_rad());\n    DataFlash.Log_Write_Float(ahrs.get_pitch_trim_rad());\n\n    // send a confirmation message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 53.91041324385411}, {"code": "void Copter::save_trim(){\n\t#if RC_CHANNELS == 8\n    const float roll_trim_adj = (ch(ROLL)-1500.0f)*0.001f;\n    const float pitch_trim_adj = (ch(PITCH)-1500.0f)*0.001f;\n#else\n    const float roll_trim_adj = (ch(ROLL)-1500.0f)*0.002f;\n    const float pitch_trim_adj = (ch(PITCH)-1500.0f)*0.002f;\n#endif\n\n    // convert trim values to radians\n    const float roll_trim = roll_trim_adj * (float)M_PI/180.0f;\n    const float pitch_trim = pitch_trim_adj * (float)M_PI/180.0f;\n\n    // add trim values to AHRS\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // log event\n    LOGGER_INFO(\"RC: Roll Trim = %.2f, Pitch Trim = %.2f\", roll_trim_adj, pitch_trim_adj);\n\n    // send confirmation message\n    gcs().send_text(MAV_SEVERITY_INFO, \"RC: Roll Trim = %.2f, Pitch Trim = %.2f\", roll_trim_adj, pitch_trim_adj);\n}", "CodeBleu_score": 46.335523591797475}, {"code": "void Copter::save_trim(){\n\t#if FRAME_CONFIG == QUAD_FRAME\n    // get the trim values from the radio\n    float roll_trim_in = rc.radio[roll_channel].control;\n    float pitch_trim_in = rc.radio[pitch_channel].control;\n\n    // convert trim values to radians\n    float roll_trim = radians(roll_trim_in);\n    float pitch_trim = radians(pitch_trim_in);\n\n    // add trim values to ahrs\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // log the event\n    LOGGER_INFO(\"RC trim: roll %4.1f, pitch %4.1f\", roll_trim_in, pitch_trim_in);\n#endif\n}", "CodeBleu_score": 45.5240693340119}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// get the velocity vector from the inertial navigation system\n\tVector3f vel_vector = copter.inertial_nav.get_velocity_vector();\n\n\t// get the speed squared\n\tfloat speed_squared = vel_vector.x * vel_vector.x + vel_vector.y * vel_vector.y;\n\n\t// if the copter's position is valid and the speed is above the minimum threshold, update the look-ahead yaw angle\n\tif (copter.inertial_nav.get_position_valid() && speed_squared > MIN_SPEED_SQUARED) {\n\t\t// calculate the look-ahead yaw angle\n\t\tlook_ahead_yaw_angle = atan2(vel_vector.y, vel_vector.x);\n\t}\n\n\t// return the look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 44.815068358854205}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t//    float speed_squared = copter.inertial_nav.get_velocity_xy_cm();\n//    speed_squared *= speed_squared;\n//    if (copter.inertial_nav.position_valid() && speed_squared > MIN_SPEED_SQUARED) {\n//        float yaw_rad = atan2f(copter.inertial_nav.get_velocity_xy_cm(), copter.inertial_nav.get_velocity_z_cm());\n//        return RAD_TO_DEG(yaw_rad);\n//    }\n//    return 0.0f;\n    return 0.0f;\n}", "CodeBleu_score": 2.5198533082890147}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat yaw = 0.0f;\n\tif (copter.inertial_nav.position_valid()) {\n\t\t// calculate speed squared\n\t\tfloat speed_squared = copter.inertial_nav.get_velocity_xy_cm_s() * copter.inertial_nav.get_velocity_xy_cm_s();\n\t\tif (speed_squared > MIN_SPEED_SQUARED) {\n\t\t\t// calculate the look-ahead yaw angle\n\t\t\tyaw = atan2(copter.inertial_nav.get_velocity_xy_cm_s(), copter.inertial_nav.get_velocity_z_cm_s());\n\t\t}\n\t}\n\treturn yaw;\n}", "CodeBleu_score": 35.30556788346885}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // in SITL mode, we always arm\n    return true;\n#endif\n\n    // check if arming checks are disabled\n    if (check_enabled(ARMING_CHECK_DISABLED) || AP_Watchdog::arming_disabled()) {\n        return true;\n    }\n\n    // check if watchdog was armed\n    if (AP_Watchdog::arming_check()) {\n        return true;\n    }\n\n    // call parent class checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 31.502500116222997}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\n#if HAL_CPU_CLASS == HAL_CPU_CLASS_SAMD\n    // check if we are in the air\n    if (hal.util->get_soft_armed()) {\n        // we are in the air, check if we are armed\n        if (!hal.util->get_soft_armed()) {\n            // we are not armed, fail the check\n            return false;\n        }\n    }\n#endif\n\n    // call parent class checks\n    if (!AP_Arming::arm_checks(method)) {\n        return false;\n    }\n\n    // additional plane specific checks\n    if (check_enabled(ARMING_CHECK_ARM)) {\n        if (plane.control_mode->get_name() == MAV_MODE_NAME_MANUAL) {\n            // check if we are in the air\n            if (hal.util->get_soft_armed()) {\n                // we are in the air, check if we are armed\n                if (!hal.util->get_soft_armed()) {\n                    // we are not armed, fail the check\n                    return false;\n                }\n            }\n        } else {\n            // check if we are armed\n            if (!hal.util->get_soft_armed()) {\n                // we are not armed, fail the check\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 48.99011758700856}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\nif (plane.aparm.rudder_min > 0) {\nreturn false;\n}\nif (plane.g.throttle != 0) {\nreturn false;\n}\n}\nif (plane.watchdog.armed()) {\nreturn true;\n}\nif (!plane.arming_checks_enabled()) {\nreturn true;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.17557664453878}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // in SITL mode we don't arm, we just pretend to\n    gcs().send_text(MAV_SEVERITY_INFO, \"Armed by %s\", AP_Arming::method_str(method));\n    return true;\n#endif\n\n    // check arming is not currently in progress\n    if (arming_in_progress()) {\n        return false;\n    }\n\n    // check if arming is allowed\n    if (!arming_allowed()) {\n        return false;\n    }\n\n    // set the arming in progress flag\n    arming_in_progress(true);\n\n    // arm the plane\n    bool success = AP_Arming::arm(method, do_arming_checks);\n\n    // update the home location\n    if (success) {\n        set_home_location();\n    }\n\n    // update the soft arm state\n    change_arm_state();\n\n    // set the delay arming flag\n    delay_arming(false);\n\n    // send a message to the GCS\n    if (success) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Armed by %s\", AP_Arming::method_str(method));\n    }\n\n    // clear the arming in progress flag\n    arming_in_progress(false);\n\n    // return the arming status\n    return success;\n}", "CodeBleu_score": 46.14536264842909}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// make sure the craft is not already armed\n\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\n\t// make sure the craft has a disarm button assigned before it is armed\n\t// check all the standard btn functions\n\tfor (uint8_t i = 0; i < 16; i++) {\n\t\tswitch (sub.get_button(i)->function(false)) {\n\t\t\tcase JSButton::k_shift :\n\t\t\t\t// check all the shift functions if there's shift assigned\n\t\t\t\tfor (uint8_t j = 0; j < 16; j++) {\n\t\t\t\t\tswitch (sub.get_button(j)->function(true)) {\n\t\t\t\t\t\tcase JSButton::k_arm_toggle :\n\t\t\t\t\t\tcase JSButton::k_disarm :\n\t\t\t\t\t\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t\t\tcase JSButton::k_arm_toggle :\n\t\t\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t\t\tcase JSButton::k_disarm :\n\t\t\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t\t}\n\t}\n\n\t// no disarm button assigned, display failure message if requested\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 47.29742021585886}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// make sure the craft has a disarm button assigned before it is armed\n\t// check all the standard btn functions\n\tfor (uint8_t i = 0; i < 16; i++) {\n\t\tswitch (sub.get_button(i)->function(false)) {\n\t\t\tcase JSButton::k_shift :\n\t\t\t\treturn pre_arm_checks_shift(display_failure);\n\t\t\tcase JSButton::k_arm_toggle :\n\t\t\t\treturn pre_arm_checks_arm_toggle(display_failure);\n\t\t\tcase JSButton::k_disarm :\n\t\t\t\treturn pre_arm_checks_disarm(display_failure);\n\t\t}\n\t}\n\n\t// check all the shift functions if there's shift assigned\n\tbool has_shift_function = false;\n\tfor (uint8_t i = 0; i < 16; i++) {\n\t\tswitch (sub.get_button(i)->function(true)) {\n\t\t\tcase JSButton::k_arm_toggle :\n\t\t\t\treturn pre_arm_checks_arm_toggle(display_failure);\n\t\t\tcase JSButton::k_disarm :\n\t\t\t\treturn pre_arm_checks_disarm(display_failure);\n\t\t\tcase JSButton::k_shift :\n\t\t\t\thas_shift_function = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_shift_function) {\n\t\treturn pre_arm_checks_shift(display_failure);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.07704110233831}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if the vehicle is already armed\n\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\n\t// check if a disarm button is configured\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tsub.notify_in_air(Arming_Checks_Failed, \"No Disarm Button Configured\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// perform standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 69.49154973202798}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\t// calculate the rotation matrix\n\tfloat cos_yaw = cosf(ahrs.getYaw_rad());\n\tfloat sin_yaw = sinf(ahrs.getYaw_rad());\n\tfloat rotation_matrix[2][2] = {{cos_yaw, -sin_yaw}, {sin_yaw, cos_yaw}};\n\n\t// rotate the coordinates\n\tfloat temp_x = x;\n\tfloat temp_y = y;\n\tx = rotation_matrix[0][0] * temp_x + rotation_matrix[0][1] * temp_y;\n\ty = rotation_matrix[1][0] * temp_x + rotation_matrix[1][1] * temp_y;\n}", "CodeBleu_score": 37.88812079687807}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\t// calculate the rotation matrix\n\tfloat cos_yaw = cosf(ahrs.getYawRadians());\n\tfloat sin_yaw = sinf(ahrs.getYawRadians());\n\tfloat rot_matrix[3][3] = {{cos_yaw, -sin_yaw, 0.0f}, {sin_yaw, cos_yaw, 0.0f}, {0.0f, 0.0f, 1.0f}};\n\n\t// rotate the vector\n\tfloat ne_x = rot_matrix[0][0]*x + rot_matrix[0][1]*y;\n\tfloat ne_y = rot_matrix[1][0]*x + rot_matrix[1][1]*y;\n\n\t// update x and y\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 55.53556012938966}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\t// Calculate the rotation matrix.\n\tfloat cos_yaw = cosf(ahrs.getYawRadians());\n\tfloat sin_yaw = sinf(ahrs.getYawRadians());\n\tfloat rotation_matrix[2][2] = {\n\t\t{cos_yaw, -sin_yaw},\n\t\t{sin_yaw, cos_yaw}\n\t};\n\n\t// Calculate the new coordinates.\n\tfloat ne_x = x * rotation_matrix[0][0] + y * rotation_matrix[0][1];\n\tfloat ne_y = x * rotation_matrix[1][0] + y * rotation_matrix[1][1];\n\n\t// Update the coordinates.\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 55.62718487848245}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if the yaw angle is within the acceptable range\n\tif (fabsf(packet.param1) > 90.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the yaw condition is within the acceptable range\n\tif (packet.param2 < 0.0f || packet.param2 > 2.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the yaw rate is within the acceptable range\n\tif (packet.param3 < -1.0f || packet.param3 > 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw condition\n\tsub.mode_auto.set_auto_yaw_condition(packet.param1, packet.param2, packet.param3);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 53.981371501030665}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tfloat yaw_angle = packet.param1;\n\tfloat yaw_rate = packet.param2;\n\n\tif (yaw_angle < -PI) {\n\t\tyaw_angle += 2*PI;\n\t}\n\telse if (yaw_angle > PI) {\n\t\tyaw_angle -= 2*PI;\n\t}\n\n\tif (fabsf(yaw_angle) > 0.5f*PI) {\n\t\treturn MAV_RESULT_FAILED;\n\t}\n\n\tif (fabsf(yaw_rate) > 100.0f) {\n\t\treturn MAV_RESULT_FAILED;\n\t}\n\n\tsub.set_desired_yaw(yaw_angle);\n\tsub.set_desired_yaw_rate(yaw_rate);\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 27.026706278801687}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 > 1 || packet.param4 < -1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param5 > 180 || packet.param5 < 0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (!sub.set_yaw_heading(packet.param5, packet.param4)) {\n\t\treturn MAV_RESULT_FAILED;\n\t}\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 43.206506700112044}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tAP_AHRS &ahrs = AP::ahrs();\n\tLocation global_position_current;\n\tUNUSED_RESULT(ahrs.get_location(global_position_current));\n\n\t//return units are 0.5 degrees\n\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn 0.5 * (sub.pos_control.get_pos_error_yaw_cd() + ahrs.yaw_error_cd());\n\t}\n\treturn 0;\n}", "CodeBleu_score": 69.19157804205834}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tAP_AHRS &ahrs = AP::ahrs();\nLocation global_position_current;\nUNUSED_RESULT(ahrs.get_location(global_position_current));\n\n//return units are 0.1 deg\nif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\nreturn (uint8_t)(0.1 * (sub.pos_control.get_bearing_cd() - 18000.0f));\n}\nreturn 0;\n\n}", "CodeBleu_score": 70.18308157033525}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tAP_AHRS &ahrs = AP::ahrs();\nLocation global_position_current;\nUNUSED_RESULT(ahrs.get_location(global_position_current));\n\n//return units are 0.01 deg\nif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\nreturn 0.01 * (global_position_current.yaw + sub.pos_control.get_pos_error_yaw_cd());\n}\nreturn 0;\n\n}", "CodeBleu_score": 69.07134048639978}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\nstruct log_Data_Int32t pkt = {\nLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\ntime_us     : AP_HAL::micros64(),\nid          : (uint8_t)id,\ndata_value  : value\n};\nlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}\n}", "CodeBleu_score": 92.0763982972105}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\nstruct log_Data_Int32t pkt = {\nLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\ntime_us     : AP_HAL::micros64(),\nid          : (uint8_t)id,\ndata_value  : value\n};\nlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}\n}", "CodeBleu_score": 92.0763982972105}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\nstruct log_Data_Int32t pkt = {\nLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\ntime_us : AP_HAL::micros64(),\nid : (uint8_t)id,\ndata_value : value\n};\nlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}\n}", "CodeBleu_score": 90.55283543104926}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\t// if we're already set, exit immediately\n\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\t// if the motors are armed, set the home to the current location\n\tif (motors_armed) {\n\t\t// set the home position to the current position\n\t\thome_position = position;\n\n\t\t// set the home_is_set flag to true\n\t\thome_is_set = true;\n\n\t\t// notify the user\n\t\tprintf(\\\"Setting home position to current position: (%.2f, %.2f, %.2f)\\\n\\\", position.x, position.y, position.z);\n\n\t\t// return immediately\n\t\treturn;\n\t}\n\n\t// if the motors are not armed, attempt to set the home to the current EKF location\n\tif (update_home_from_EKF_impl()) {\n\t\t// set the home_is_set flag to true\n\t\thome_is_set = true;\n\n\t\t// notify the user\n\t\tprintf(\\\"Setting home position to EKF position: (%.2f, %.2f, %.2f)\\\n\\\", position.x, position.y, position.z);\n\t}\n}", "CodeBleu_score": 17.089184416505493}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors_armed) {\n\t\thome_is_set = true;\n\t\thome.lat = ekf_home_pos.lat;\n\t\thome.lng = ekf_home_pos.lng;\n\t\thome.alt = ekf_home_pos.alt;\n\t\treturn;\n\t}\n\n\tif (get_ekf_home_position(ekf_home_pos)) {\n\t\thome_is_set = true;\n\t\thome.lat = ekf_home_pos.lat;\n\t\thome.lng = ekf_home_pos.lng;\n\t\thome.alt = ekf_home_pos.alt;\n\t}\n}", "CodeBleu_score": 15.757514819878388}, {"code": "void Sub::update_home_from_EKF(){\n\t", "CodeBleu_score": 2.5803837316206777}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// check if motors are armed\n\tif (!motors.armed()) {\n\t\t// motors are disarmed; set throttle to zero and exit\n\t\tmotors.set_throttle(0);\n\t\treturn;\n\t}\n\n\t// motors are armed; set spool state to unlimited throttle\n\tspool.set_state(Spool::State::UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to body rates\n\tfloat roll_rate = pilot.roll_body_rate();\n\tfloat pitch_rate = pilot.pitch_body_rate();\n\tfloat yaw_rate = pilot.yaw_body_rate();\n\n\t// run attitude controller with body rates\n\tattitude_control->run(roll_rate, pitch_rate, yaw_rate);\n\n\t// set forward and lateral motor inputs based on pilot controls\n\tmotors.set_throttle(pilot.throttle());\n\tmotors.set_roll_rate(pilot.roll_body_rate());\n\tmotors.set_pitch_rate(pilot.pitch_body_rate());\n}", "CodeBleu_score": 46.270059178848186}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\n//    if (g.control_mode == GUIDED_NO_GPS) {\n//        // in guided mode, but not using GPS.  use last known position\n//        posvel_pos_target_cm = Vector3f(g.last_known_pos_cm.x, g.last_known_pos_cm.y, g.last_known_pos_cm.z);\n//    } else {\n//        // in guided mode and using GPS.  use current position\n//        posvel_pos_target_cm = Vector3f(g.position_cm.x, g.position_cm.y, g.position_cm.z);\n//    }\n\n    // in guided mode and using GPS.  use current position\n    posvel_pos_target_cm = Vector3f(g.position_cm.x, g.position_cm.y, g.position_cm.z);\n\n    // set the target position to the stopping point\n    posvel_pos_target_cm = Vector3f(g.stopping_point_cm.x, g.stopping_point_cm.y, g.stopping_point_cm.z);\n\n    // initialize yaw using the default auto yaw mode\n    g.auto_yaw_mode = get_default_auto_yaw_mode(false);\n\n    // initialize waypoint controller\n    wp_controller.init(g.stopping_point_cm, g.auto_yaw_mode);\n\n    // set the update time\n    update_time_ms = millis();\n}", "CodeBleu_score": 37.340492435666214}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set to velocity control mode\n\tsub.guided_mode = Guided_Vel;\n\n\t// initialise velocity controllers\n\tsub.posvel.set_max_speeds(g.guided_vel_max_up_cms, g.guided_vel_max_down_cms, g.guided_vel_max_yaw_rate_degs);\n\tsub.posvel.set_accelerations(g.guided_vel_max_up_cms, g.guided_vel_max_down_cms, g.guided_vel_max_yaw_rate_degs);\n\tsub.posvel.set_vel_pid_gains(g.vel_pid_kp, g.vel_pid_ki, g.vel_pid_kd, g.vel_pid_kf);\n\tsub.posvel.set_yaw_pid_gains(g.yaw_rate_pid_kp, g.yaw_rate_pid_ki, g.yaw_rate_pid_kd, g.yaw_rate_pid_kf);\n\tsub.posvel.set_vel_pid_integrator_max(g.vel_pid_integrator_max);\n\tsub.posvel.set_vel_pid_integrator_min(g.vel_pid_integrator_min);\n\tsub.posvel.set_yaw_rate_pid_integrator_max(g.yaw_rate_pid_integrator_max);\n\tsub.posvel.set_yaw_rate_pid_integrator_min(g.yaw_rate_pid_integrator_min);\n\tsub.posvel.init();\n\n\t// initialise yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 37.5467289543332}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t", "CodeBleu_score": 2.0063663692733846}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set to velocity control mode\n\tsub.guided_mode = Guided_Vel;\n\n\t// initialise vertical control\n\tsub.vel_control.set_vertical_control_mode(VELOCITY_CONTROL_THROTTLE);\n\tsub.vel_control.set_max_vertical_speed_cms(g.pilot_max_v_cms);\n\tsub.vel_control.set_max_vertical_accel_cms(g.pilot_max_v_accel_cms);\n\tsub.vel_control.set_max_vertical_decel_cms(g.pilot_max_v_decel_cms);\n\n\t// initialise horizontal control\n\tsub.vel_control.set_horizontal_control_mode(VELOCITY_CONTROL_XY_VELOCITY);\n\tsub.vel_control.set_max_horizontal_accel_cms(g.pilot_max_h_accel_cms);\n\tsub.vel_control.set_max_horizontal_decel_cms(g.pilot_max_h_decel_cms);\n\n\t// initialise yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 38.87156253889873}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t//    // check for timeout\n//    uint32_t tnow = AP_HAL::millis();\n//    if (tnow - guided_limit.start_time > guided_limit.timeout_ms) {\n//        return true;\n//    }\n\n//    // check for altitude limit\n//    float alt_cm = inertial_nav.get_altitude_cm();\n//    if (alt_cm < guided_limit.alt_min_cm) {\n//        return true;\n//    }\n//    if (alt_cm > guided_limit.alt_max_cm) {\n//        return true;\n//    }\n\n//    // check for horizontal distance limit\n//    Vector3f pos = inertial_nav.get_position_neu_cm();\n//    float dist_cm = (pos - guided_limit.start_pos).length();\n//    if (dist_cm > guided_limit.horiz_max_cm) {\n//        return true;\n//    }\n\n//    // limits not exceeded\n//    return false;\n}", "CodeBleu_score": 1.339792654526442}, {"code": "bool ModeGuided::guided_limit_check(){\n\t//    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n//    uint32_t tnow = AP_HAL::millis();\n//    if (tnow - guided_limit.start_time > guided_limit.timeout_ms) {\n//        return true;\n//    }\n//\n//    // check altitude limits\n//    float alt_cm = inertial_nav.get_altitude_cm();\n//    if ((alt_cm < guided_limit.alt_min_cm) || (alt_cm > guided_limit.alt_max_cm)) {\n//        return true;\n//    }\n//\n//    // check horizontal limits\n//    Vector3f pos_delta_cm = inertial_nav.get_position_neu_cm() - guided_limit.start_pos;\n//    if (pos_delta_cm.length() > guided_limit.horiz_max_cm) {\n//        return true;\n//    }\n//\n//    // all checks passed\n//    return false;\n}", "CodeBleu_score": 1.339792654526442}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\n/*\n * Check if the timeout has been exceeded.\n */\n    if (AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n        return true;\n    }\n\n/*\n * Check if the current altitude is below a minimum threshold.\n */\n    if (inertial_nav.get_position_neu_cm().z < guided_limit.alt_min_cm) {\n        return true;\n    }\n\n/*\n * Check if the current altitude is above a maximum threshold.\n */\n    if (inertial_nav.get_position_neu_cm().z > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n/*\n * Check if the horizontal distance moved exceeds a specified limit.\n */\n    if (inertial_nav.get_position_neu_cm().distance(guided_limit.start_pos) > guided_limit.horiz_max_cm) {\n        return true;\n    }\n\n/*\n * If none of the above conditions are met, return false.\n */\n    return false;\n}", "CodeBleu_score": 45.067686647004265}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t#define MOTOR_TEST_TIMEOUT_MS 500\n    // check if we have received a motor test request in the last 500 ms\n    if (hal.scheduler->millis() - last_do_motor_test_ms > MOTOR_TEST_TIMEOUT_MS) {\n        // disable motor test\n        ap.motor_test = false;\n        // disarm motors\n        motors.disarm();\n        // record failure time\n        last_do_motor_test_fail_ms = hal.scheduler->millis();\n        // send timeout message\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 53.52107256218128}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n\n// Check if we have received motor test requests at least every 2 Hz\nif (tnow - last_motor_test_request_ms > 500) {\ngcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test failed: no motor test requests received\\\");\npass = false;\ndisable_motor_test();\nap.motors_armed = false;\nlast_do_motor_test_fail_ms = tnow;\nreturn false;\n}\n\nreturn true;\n}", "CodeBleu_score": 43.65914511809182}, {"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// get the roll and pitch targets from wp_nav\n\tfloat roll_cd = wp_nav.get_roll_cd();\n\tfloat pitch_cd = wp_nav.get_pitch_cd();\n\n\t// constrain the roll and pitch targets to a maximum angle\n\tfloat roll_max_cd = 10000; // 10 degrees\n\tfloat pitch_max_cd = 10000; // 10 degrees\n\tfloat roll_min_cd = -roll_max_cd;\n\tfloat pitch_min_cd = -pitch_max_cd;\n\troll_cd = constrain_float(roll_cd, roll_min_cd, roll_max_cd);\n\tpitch_cd = constrain_float(pitch_cd, pitch_min_cd, pitch_max_cd);\n\n\t// normalize the roll and pitch targets\n\tfloat roll_norm = (roll_cd - roll_min_cd) / (roll_max_cd - roll_min_cd);\n\tfloat pitch_norm = (pitch_cd - pitch_min_cd) / (pitch_max_cd - pitch_min_cd);\n\n\t// assign the normalized targets to the output variables\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 41.36104996056407}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// get roll and pitch targets from wp_nav in centidegrees\n\tfloat roll_cd = wp_nav->get_roll_cd();\n\tfloat pitch_cd = wp_nav->get_pitch_cd();\n\n\t// constrain roll and pitch targets to within the specified maximum angle range\n\troll_cd = constrain_float(roll_cd, -1000, 1000);\n\tpitch_cd = constrain_float(pitch_cd, -1000, 1000);\n\n\t// normalize roll and pitch targets\n\tfloat roll_norm = roll_cd / 1000.0f;\n\tfloat pitch_norm = pitch_cd / 1000.0f;\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 39.42033554872211}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// get roll and pitch targets from wp_nav in centidegrees\n\tfloat roll_cd = wp_nav.roll_cd();\n\tfloat pitch_cd = wp_nav.pitch_cd();\n\n\t// constrain roll and pitch targets within a specified maximum angle range\n\troll_cd = constrain_float(roll_cd, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\tpitch_cd = constrain_float(pitch_cd, -WPNAV_MAX_ANGLE_CD, WPNAV_MAX_ANGLE_CD);\n\n\t// normalize roll and pitch targets\n\tfloat roll_norm = roll_cd / (float)WPNAV_MAX_ANGLE_CD;\n\tfloat pitch_norm = pitch_cd / (float)WPNAV_MAX_ANGLE_CD;\n\n\t// assign normalized targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 46.505667956303064}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// update the barometer data\n\tif (barometer.read()) {\n\t\t// update the barometer calibration\n\t\tif (barometer.altitude_cm > 0) {\n\t\t\tbarometer_calibration_cm = barometer.altitude_cm;\n\t\t}\n\n\t\t// update the sensor health status\n\t\tif (barometer.health == Barometer::BAROMETER_HEALTH_OVERHEAT) {\n\t\t\tbarometer_health = Barometer::BAROMETER_HEALTH_OVERHEAT;\n\t\t} else if (barometer.health == Barometer::BAROMETER_HEALTH_OK) {\n\t\t\tbarometer_health = Barometer::BAROMETER_HEALTH_OK;\n\t\t} else if (barometer.health == Barometer::BAROMETER_HEALTH_UNHEALTHY) {\n\t\t\tbarometer_health = Barometer::BAROMETER_HEALTH_UNHEALTHY;\n\t\t} else if (barometer.health == Barometer::BAROMETER_HEALTH_WARNING) {\n\t\t\tbarometer_health = Barometer::BAROMETER_HEALTH_WARNING;\n\t\t} else {\n\t\t\tbarometer_health = Barometer::BAROMETER_HEALTH_UNKNOWN;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.29701340939301}, {"code": "void Sub::read_barometer(){\n\t\t// update the barometer data\n\t// update the barometer calibration\n\t// update the sensor health status\n}", "CodeBleu_score": 2.7652140501199507}, {"code": "void Sub::read_barometer(){\n\t\t// Update barometer calibration\n\tif (this->altitude > 0) {\n\t\tthis->barometer_calibration = this->altitude;\n\t}\n\n\t// Update sensor health status\n\tif (this->barometer_health) {\n\t\tthis->barometer_health = this->barometer_calibration > 0;\n\t}\n}", "CodeBleu_score": 14.029308372653022}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t#if AP_AHRS_EKF_AVAILABLE\n    if (ahrs.get_ekf_health() == AP_AHRS::EKF_HEALTH_OK) {\n        if (motors.armed()) {\n            // require EKF to be in a good state\n            if (ahrs.get_ekf_pos_ok() && ahrs.get_ekf_hgt_ok()) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            // allow EKF to be in a bad state when disarmed\n            return true;\n        }\n    } else {\n        return false;\n    }\n#else\n    return false;\n#endif\n}", "CodeBleu_score": 38.389681463765655}, {"code": "bool Sub::ekf_position_ok(){\n\t#if AP_AHRS_AVAILABLE\n    // if we're armed and EKF is not in constant position mode, check that we have a good absolute position\n    if (motors.armed() && !ins.using_constant_position_mode()) {\n        // check that we have a good absolute position\n        if (fabsf(ahrs.get_ekf_pos_z()) < 0.5f && fabsf(ahrs.get_ekf_pos_horiz_accuracy()) < 1.0f) {\n            return true;\n        }\n    } else {\n        // if we're not armed, or EKF is in constant position mode, accept a predicted position\n        return true;\n    }\n#endif\n    return false;\n}", "CodeBleu_score": 34.195954952334354}, {"code": "bool Sub::ekf_position_ok(){\n\t#if AP_AHRS_EKF_AVAILABLE\n    // If we have an EKF, check it's position estimate\n    if (ins.get_ekf_ok()) {\n        // Check if the EKF is in constant position mode\n        if (ins.get_ekf_const_pos_mode()) {\n            // EKF is in constant position mode\n            // Check if we have a good absolute position\n            if (ins.get_ekf_pos_valid()) {\n                // EKF position is good\n                return true;\n            } else {\n                // EKF position is bad\n                // We can't use the EKF if we don't have a good absolute position\n                return false;\n            }\n        } else {\n            // EKF is not in constant position mode\n            // Check if we have a good absolute position\n            if (ins.get_ekf_pos_valid()) {\n                // EKF position is good\n                // Check if we have a good predicted position\n                if (ins.get_ekf_pred_pos_valid()) {\n                    // EKF predicted position is good\n                    return true;\n                } else {\n                    // EKF predicted position is bad\n                    // We can't use the EKF if we don't have a good predicted position\n                    return false;\n                }\n            } else {\n                // EKF position is bad\n                // We can't use the EKF if we don't have a good absolute position\n                return false;\n            }\n        }\n    } else {\n        // No EKF\n        // We can't use the EKF if we don't have one\n        return false;\n    }\n#else\n    // No EKF\n    // We can't use the EKF if we don't have one\n    return false;\n#endif\n}", "CodeBleu_score": 45.95421761226445}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// perform parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if AHRS is ready\n\tif (!ahrs.initialised()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not initialised\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (!ahrs.using_gps()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (ahrs.get_ekf_pos_valid() != AHRS_EKF_OK) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF position invalid\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.681473880498665}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we are not requiring gps, return true\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// call parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if AHRS system is ready\n\tif (!ahrs.is_ready()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (ahrs.get_ekf_health() != AP_AHRS::EKF_OK) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (ahrs.get_status() != AP_AHRS::STATUS_OK) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"Position estimate invalid\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.970685936866765}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\t// perform parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\t// check if AHRS system is ready\n\tif (!ahrs.initialised()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not initialised\");\n\t\treturn false;\n\t}\n\t// check if EKF failsafe is active\n\tif (ahrs.get_ekf_ok() != AHRS_EKF_OK_YES) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe\");\n\t\treturn false;\n\t}\n\t// check if EKF is ready\n\tif (!ahrs.get_ekf_ok()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF not ready\");\n\t\treturn false;\n\t}\n\t// check if EKF position is valid\n\tif (!ahrs.get_position_valid()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF position invalid\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.14656620139085}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// if we are already armed then skip the checks\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// perform arming checks if required\n\tif (do_arming_checks) {\n\t\tif (!arm_checks(method)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set armed flag\n\tarmed = true;\n\n\t// set the home location\n\tif (home_location == NULL) {\n\t\thome_location = new Location();\n\t}\n\thome_location->set(location);\n\n\t// set the home heading\n\tif (home_heading == 0) {\n\t\thome_heading = heading;\n\t}\n\n\t// set the home heading for sailing vehicles\n\tif (rover.g2.sailboat.sail_enabled()) {\n\t\trover.g2.sailboat.set_home_heading(home_heading);\n\t}\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// send an arm/disarm status text\n\tsend_status_text();\n\n\treturn true;\n}", "CodeBleu_score": 51.15257999144946}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // arm the vehicle\n    if (do_arming_checks && !arm_checks(method)) {\n        return false;\n    }\n    armed = true;\n    return true;\n#else\n    // arm the vehicle\n    if (do_arming_checks && !arm_checks(method)) {\n        arming_failed();\n        return false;\n    }\n    armed = true;\n\n    // record home location\n    if (rover.control_mode->get_name() == \"SAIL\" && rover.g2.sailboat.sail_enabled()) {\n        // set home location\n        rover.gcs_send_home_position();\n    }\n\n    // set simple mode heading\n    if (rover.control_mode->get_name() == \"SIMPLE\") {\n        // set simple mode heading\n        rover.g2.simple_mode.set_heading(rover.ahrs.yaw_sensor);\n    }\n\n    // record home heading for sailing\n    if (rover.control_mode->get_name() == \"SAIL\" && rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.set_home_heading(rover.ahrs.yaw_sensor);\n    }\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    if (report_status) {\n        if (armed) {\n            rover.gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Armed by %s\", method_str(method));\n        } else {\n            rover.gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Disarmed by %s\", method_str(method));\n        }\n    }\n\n    return true;\n#endif\n}", "CodeBleu_score": 48.77912056475805}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// if we are already armed then skip the checks\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// do arming checks if required\n\tif (do_arming_checks && !arming_checks(method)) {\n\t\treturn false;\n\t}\n\n\t// arm motors\n\tif (!AP_Arming::arm(method)) {\n\t\treturn false;\n\t}\n\n\t// arm the rover\n\tarmed = true;\n\n\t// set the home location\n\tif (rover.gcs_location.flags.set_home) {\n\t\trover.gcs_location.set_home();\n\t}\n\n\t// initialize simple mode heading\n\tif (rover.simple_mode.initialise_heading()) {\n\t\t// record the home heading for sail vehicles\n\t\tif (rover.g2.sailboat.sail_enabled()) {\n\t\t\trover.g2.sailboat.set_home_heading(rover.simple_mode.get_heading_for_simple_mode());\n\t\t}\n\t}\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// send an arm/disarm status text\n\tsend_status_text(armed);\n\n\t// notify the user\n\tif (report_success) {\n\t\trover.console->println_P(PSTR(\"Rover armed\"));\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.24414855727595}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\n#ifdef ENABLE_CHARGING\n    // Check if charging is allowed.\n    if (charging_allowed) {\n        // Check if charging should be disabled.\n        if (!checkShouldCharge()) {\n            // Disable charging.\n            charging_allowed = false;\n            charging_disabled_time = millis();\n        }\n    } else {\n        // Check if charging should be enabled.\n        if (checkShouldCharge()) {\n            // Enable charging.\n            charging_allowed = true;\n            charging_disabled_time = 0;\n        } else {\n            // Check if charging should be disabled again.\n            if (millis() - charging_disabled_time > CHARGING_DISABLE_DELAY_MILLIS) {\n                // Disable charging.\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }\n        }\n    }\n#endif\n}", "CodeBleu_score": 63.0579716281218}, {"code": "void updateChargingEnabled(){\n\t#ifdef ENABLE_CHARGING_STATE_MACHINE\n    static uint32_t last_charge_millis = 0;\n    static bool last_charge_state = false;\n    static bool charge_retry_enable = false;\n    static uint32_t charge_retry_millis = 0;\n\n    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (last_charge_state) {\n                // charging was enabled, but should not be. Disable it.\n                last_charge_state = false;\n                charge_retry_enable = false;\n                charge_retry_millis = 0;\n                charging_state_machine.set_charge_state(CHARGE_STATE_DISABLE);\n            }\n        } else {\n            if (!last_charge_state) {\n                // charging was disabled, but should be. Enable it.\n                last_charge_state = true;\n                charge_retry_enable = true;\n                charge_retry_millis = 0;\n                charging_state_machine.set_charge_state(CHARGE_STATE_ENABLE);\n            }\n        }\n    } else {\n        if (last_charge_state) {\n            // charging was enabled, but should not be. Disable it.\n            last_charge_state = false;\n            charge_retry_enable = false;\n            charge_retry_millis = 0;\n            charging_state_machine.set_charge_state(CHARGE_STATE_DISABLE);\n        } else {\n            if (charge_retry_enable) {\n                if (charge_retry_millis == 0) {\n                    charge_retry_millis = millis();\n                } else if (millis() - charge_retry_millis > 10000) {\n                    // Retry enabling charging after 10 seconds\n                    charge_retry_enable = false;\n                    charge_retry_millis = 0;\n                    charging_state_machine.set_charge_state(CHARGE_STATE_ENABLE);\n                }\n            }\n        }\n    }\n#endif\n}", "CodeBleu_score": 49.135217780539875}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\t// Charging should be enabled\n\t\t\tif (checkShouldCharge()) {\n\t\t\t\t// Charging should be enabled\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_start_time = millis();\n\t\t\t} else {\n\t\t\t\t// Charging should not be enabled\n\t\t\t\tcharging_start_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\t// Charging is enabled\n\t\t\tif (!checkShouldCharge()) {\n\t\t\t\t// Charging should not be enabled\n\t\t\t\tcharging_start_time = millis();\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Charging is not allowed\n\t\tif (charging_enabled) {\n\t\t\t// Charging is enabled\n\t\t\tif (millis() - charging_start_time > CHARGING_RETRY_DELAY_MS) {\n\t\t\t\t// Charging should be disabled\n\t\t\t\tcharging_enabled = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 49.16999009074442}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ENABLE_ROS\n    if (ROS_running && size >= 4) {\n        uint16_t crc = crc16(message, size - 2);\n        ((uint16_t *) message)[size - 2] = crc;\n        packetSerial.send(message, size);\n    }\n#endif\n}", "CodeBleu_score": 41.01266643668544}, {"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ENABLE_ROS\n    if (ROS_running && size >= 4) {\n        uint16_t crc = crc16_buff(message, size);\n        struct msg_header *header = (struct msg_header *) message;\n        header->crc = crc;\n        packetSerial.write(message, size + sizeof(uint16_t));\n    }\n#endif\n}", "CodeBleu_score": 41.39032400355253}, {"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ROS_ENABLED\n    if (ROS_running && size >= 4) {\n        uint16_t crc = crc16(message, size - 2);\n        ((uint8_t*) message)[size - 2] = crc & 0xFF;\n        ((uint8_t*) message)[size - 1] = (crc >> 8) & 0xFF;\n        packetSerial.sendPacket(message, size);\n    }\n#endif\n}", "CodeBleu_score": 57.07181833001028}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\n//    Serial.begin(115200);\n//    delay(100);\n\n    soundSerial.begin(115200);\n    delay(100);\n\n    myMP3.begin(soundSerial);\n\n    this->anzSoundfiles = myMP3.getSDCardFiles();\n\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n\n    return this->sound_available;\n\n}", "CodeBleu_score": 51.58751725554305}, {"code": "bool MP3Sound::begin(){\n\t\n//    Serial.println(\"Initializing sound module\");\n\n    this->sound_available = false;\n\n    if (!soundSerial.begin()) {\n        Serial.println(\"Initializing serial communication for sound module failed\");\n        return false;\n    }\n\n    soundSerial.flush();\n\n    myMP3.init(soundSerial);\n\n    this->anzSoundfiles = myMP3.getSDCardFiles();\n\n    if (this->anzSoundfiles > 0) {\n        Serial.print(\"Number of sound files: \");\n        Serial.println(this->anzSoundfiles);\n        this->sound_available = true;\n    } else {\n        Serial.println(\"No sound files found on SD card\");\n    }\n\n    return this->sound_available;\n}", "CodeBleu_score": 44.53141173364938}, {"code": "bool MP3Sound::begin(){\n\t\n//    Serial.begin(115200);\n    soundSerial.begin(115200);\n    delay(1000);\n    soundSerial.flush();\n\n    myMP3.begin(soundSerial);\n    delay(1000);\n\n    this->anzSoundfiles = myMP3.getSDCardFiles();\n\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n    else {\n        this->sound_available = false;\n    }\n\n    return this->sound_available;\n}", "CodeBleu_score": 55.15950350635792}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\nint soundsToPlay = sounds2play();\n\nif (soundsToPlay == 0) {\nreturn 0;\n}\n\nif (playing) {\nreturn soundsToPlay;\n}\n\nint soundNr = active_sounds.back();\nactive_sounds.pop_back();\n\nplaySoundAdHoc(soundNr);\n\nreturn sounds2play();\n\n}", "CodeBleu_score": 49.10372044400577}, {"code": "int MP3Sound::processSounds(){\n\t\n//    if(sound_available == false) return 0;\n\n    if (active_sounds.size() == 0) return 0;\n\n    if (playing) return active_sounds.size();\n\n    int soundNr = active_sounds.back();\n\n    active_sounds.pop_back();\n\n    myMP3.play(soundNr);\n\n    playing = true;\n\n    return active_sounds.size();\n}", "CodeBleu_score": 55.14706380203355}, {"code": "int MP3Sound::processSounds(){\n\t\nint soundsToPlay = active_sounds.size();\n\nif (soundsToPlay == 0) {\nreturn soundsToPlay;\n}\n\nif (playing) {\nreturn soundsToPlay;\n}\n\nint sound = active_sounds.back();\nactive_sounds.pop_back();\n\nplaying = true;\nmyMP3.play(sound);\n\nreturn soundsToPlay;\n}", "CodeBleu_score": 56.95867299951806}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\nif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\nif (c->memory_mapped_file != NULL)\nfclose(c->memory_mapped_file);\nc->memory_mapped_file = fopen(request_read_string(r), \"r+\");\nif (c->memory_mapped_file == NULL) {\nfprintf(stderr, \"Error opening memory mapped file '%s'.\n\", request_read_string(r));\nreturn false;\n}\n// read header\nchar buffer[1024];\nfread(buffer, sizeof(char), 1024, c->memory_mapped_file);\n// check header\nif (strncmp(buffer, \"WEBOTS_IMAGE_FILE\", 17) != 0) {\nfprintf(stderr, \"Error: invalid memory mapped file.\n\");\nfclose(c->memory_mapped_file);\nc->memory_mapped_file = NULL;\nreturn false;\n}\n// read image size\nfread(buffer, sizeof(char), 1024, c->memory_mapped_file);\nint width, height, channels;\nsscanf(buffer, \"%d %d %d\", &width, &height, &channels);\nif (width != c->width || height != c->height) {\nfprintf(stderr, \"Error: invalid image size in memory mapped file.\n\");\nfclose(c->memory_mapped_file);\nc->memory_mapped_file = NULL;\nreturn false;\n}\n// read image data\nfseek(c->memory_mapped_file, 1024, SEEK_SET);\nreturn true;\n} else\nreturn false;\n}", "CodeBleu_score": 40.67610555900914}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n\nif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\nif (c->image->memory_mapped_file != NULL)\nimage_memory_mapped_file_cleanup(c->image);\n\nif (request_read_uchar(r) == 0) {\nc->image->memory_mapped_file = NULL;\n} else {\nconst char *filename = request_read_string(r);\nc->image->memory_mapped_file = image_memory_mapped_file_setup(filename, c->width, c->height, c->image->size);\n}\n\nrequest_read_uchar(r);  // end of packet\nreturn true;\n} else {\nreturn false;\n}\n}", "CodeBleu_score": 46.284218614025555}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\nif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\nif (c->memory_mapped_file) {\n#ifdef _WIN32\nUnmapViewOfFile(c->memory_mapped_file);\nCloseHandle(c->memory_mapped_file_mapping);\nCloseHandle(c->memory_mapped_file_handle);\n#else\nmunmap(c->memory_mapped_file, c->memory_mapped_file_size);\nclose(c->memory_mapped_file_handle);\n#endif\n}\nc->memory_mapped_file_handle = request_read_int32(r);\nc->memory_mapped_file_size = request_read_uint32(r);\n#ifdef _WIN32\nc->memory_mapped_file_handle = CreateFileMapping(c->memory_mapped_file_handle, NULL, PAGE_READWRITE, 0, c->memory_mapped_file_size, NULL);\nc->memory_mapped_file_mapping = MapViewOfFile(c->memory_mapped_file_handle, FILE_MAP_WRITE, 0, 0, c->memory_mapped_file_size);\nc->memory_mapped_file = c->memory_mapped_file_mapping;\n#else\nc->memory_mapped_file_handle = open(\"/dev/mem\", O_RDWR | O_SYNC);\nc->memory_mapped_file = mmap(NULL, c->memory_mapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, c->memory_mapped_file_handle, 0);\n#endif\nc->memory_mapped_file_pointer = c->memory_mapped_file;\nc->memory_mapped_file_end = c->memory_mapped_file + c->memory_mapped_file_size;\nreturn true;\n}\nreturn false;\n}", "CodeBleu_score": 40.63094885784382}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tAbstractCamera *c = d->pdata;\nint height = -1;\nrobot_mutex_lock();\nif (c)\nheight = c->height;\nrobot_mutex_unlock();\nreturn height;\n}", "CodeBleu_score": 58.383781737012306}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tAbstractCamera *c = d->pdata;\nint height = -1;\n\nrobot_mutex_lock();\nif (c)\nheight = c->height;\nrobot_mutex_unlock();\n\nreturn height;\n}", "CodeBleu_score": 58.383781737012306}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tAbstractCamera *ac = d->pdata;\nint height = -1;\nrobot_mutex_lock();\nif (ac)\nheight = ac->height;\nrobot_mutex_unlock();\nreturn height;\n}", "CodeBleu_score": 65.26604987966522}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint result = 0;\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn result;\n}", "CodeBleu_score": 57.17974911243553}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint result = 0;\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn result;\n}", "CodeBleu_score": 57.17974911243553}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nreturn dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\\\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn 0;\n}", "CodeBleu_score": 38.565755201329864}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *degreesMinutesSeconds = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = degreesMinutesSeconds;\n\tfree(degreesMinutesSeconds);\n\treturn result;\n}", "CodeBleu_score": 45.072946881320426}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.245249918562564}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *c = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring s = c;\n\tfree(c);\n\treturn s;\n}", "CodeBleu_score": 40.87156738794342}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass,\"argument not a box\");\n\tdVector3 p;\n\tp[0] = x - ((dxBox*)g)->final_posr->pos[0];\n\tp[1] = y - ((dxBox*)g)->final_posr->pos[1];\n\tp[2] = z - ((dxBox*)g)->final_posr->pos[2];\n\tdReal *s = ((dxBox*)g)->side;\n\tdReal n;\n\tif (fabs(p[0]) > (s[0] * 0.5f)) {\n\t\tn = -1.0f;\n\t}\n\telse {\n\t\tn = 1.0f;\n\t}\n\tplane[0] = n;\n\tplane[1] = 0.0f;\n\tplane[2] = 0.0f;\n\tplane[3] = -n * p[0];\n\tif (fabs(p[1]) > (s[1] * 0.5f)) {\n\t\tn = -1.0f;\n\t}\n\telse {\n\t\tn = 1.0f;\n\t}\n\tdReal t = n * p[1];\n\tif (fabs(t) > fabs(plane[3])) {\n\t\tplane[1] = n;\n\t\tplane[3] = t;\n\t}\n\tif (fabs(p[2]) > (s[2] * 0.5f)) {\n\t\tn = -1.0f;\n\t}\n\telse {\n\t\tn = 1.0f;\n\t}\n\tt = n * p[2];\n\tif (fabs(t) > fabs(plane[3])) {\n\t\tplane[2] = n;\n\t\tplane[3] = t;\n\t}\n}", "CodeBleu_score": 36.09783023992227}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\n\tconst dReal *const s = ((dxBox*) g)->side;\n\tdVector3 p;\n\tdGeomBoxPointDepth (g, x, y, z, p);\n\tdVector3 normal;\n\tdReal depth;\n\tif (dFabs(p[0]) >= (s[0] * 0.5)) {\n\t\tnormal[0] = 0;\n\t\tnormal[1] = (p[1] > 0) ? 1 : -1;\n\t\tnormal[2] = (p[2] > 0) ? 1 : -1;\n\t\tdepth = dFabs(p[1]) + dFabs(p[2]);\n\t}\n\telse if (dFabs(p[1]) >= (s[1] * 0.5)) {\n\t\tnormal[0] = (p[0] > 0) ? 1 : -1;\n\t\tnormal[1] = 0;\n\t\tnormal[2] = (p[2] > 0) ? 1 : -1;\n\t\tdepth = dFabs(p[0]) + dFabs(p[2]);\n\t}\n\telse {\n\t\tnormal[0] = (p[0] > 0) ? 1 : -1;\n\t\tnormal[1] = (p[1] > 0) ? 1 : -1;\n\t\tnormal[2] = 0;\n\t\tdepth = dFabs(p[0]) + dFabs(p[1]);\n\t}\n\tdNormalize3(normal);\n\tplane[0] = normal[0];\n\tplane[1] = normal[1];\n\tplane[2] = normal[2];\n\tplane[3] = depth;\n}", "CodeBleu_score": 33.19648391961064}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdIASSERT(box);\n\tdIASSERT(box->g1);\n\tdIASSERT(box->g1->body);\n\tdIASSERT(flags == 0 || flags == dxImmersionOutlineDisabled);\n\n\tsBoxImmersionData data(box, fluidPlane, flags);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 55.57802350777463}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#ifdef dSINGLE\n  const dReal VOLUME_ZERO_THRESHOLD = 1.0e-5f;\n#else\n  const dReal VOLUME_ZERO_THRESHOLD = 1.0e-12;\n#endif\n\n  dIASSERT(box);\n  dIASSERT(fluidPlane);\n  dIASSERT(immersion);\n  dIASSERT(box->g1);\n  dIASSERT(box->g1->body);\n  dIASSERT(box->g1->body->world);\n  dIASSERT(flags >= 0 && flags < 32);\n\n  sBoxImmersionData data(box, fluidPlane, flags);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 51.730389811741695}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdIASSERT(box && box->g1 && box->g1->body && fluidPlane && immersion);\n\tdIASSERT((flags & ~(dxImmersionOutlineDisabled | dxImmersionOutlineConvexHull)) == 0);\n\tsBoxImmersionData data(box, fluidPlane, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 58.31197559271575}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\n  return 0;\n\ndxBox *const box1 = (dxBox *) o1;\ndxCapsule *const capsule2 = (dxCapsule *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomBoxGetImmersionPlane(box1, fluidPlane);\n\nreturn dImmerseCapsule (capsule2, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 91.95738148117401}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\n  return 0;\n\ndxBox *const box = (dxBox *) o1;\ndxCapsule *const capsule = (dxCapsule *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\nreturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.27733694562066}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\n  return 0;\n\ndxBox *const box = (dxBox *) o1;\ndxCapsule *const capsule = (dxCapsule *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\nreturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.27733694562066}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn volume;\n}", "CodeBleu_score": 90.41849111478571}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn volume / (2.0 * M_PI);\n}", "CodeBleu_score": 88.17376458640065}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.26469117941497}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal singularityStart = singularityFactor * sinTheta1;\n\tdReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xIntegrand>(0.0, singularityStart, n, data);\n\tx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xIntegrand>(singularityStart, sinTheta1, n, data);\n\treturn x * m_fRadius / volume;\n}", "CodeBleu_score": 68.06663836573867}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst dReal singularityStart = singularityFactor * sinTheta1;\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\ndReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xIntegrand>(0.0, singularityStart, n, data);\nx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xIntegrand>(singularityStart, sinTheta1, n, data);\nreturn x * m_fRadius * volume;\n}", "CodeBleu_score": 66.73309144798407}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst dReal singularityStart = singularityFactor * sinTheta1;\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tdReal integral = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\tintegral += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\n\treturn m_fRadius * integral / volume;\n}", "CodeBleu_score": 65.55802163583144}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\nreturn 0;\n\nconst dxCapsule *const capsule = (dxCapsule *) o1;\ndxTriMesh *const trimesh = (dxTriMesh *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\nreturn dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 85.50813346041167}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\nreturn 0;\n\nconst dxCapsule *const capsule = (dxCapsule *) o1;\ndxTriMesh *const trimesh = (dxTriMesh *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\nreturn dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 85.50813346041167}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\nreturn 0;\n\nconst dxCapsule *const capsule = (dxCapsule *) o1;\ndxTriMesh *const trimesh = (dxTriMesh *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\nreturn dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 85.50813346041167}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t", "CodeBleu_score": 2.646795729915672}, {"code": "NodeStatus SleepNode::onStart(){\n\t", "CodeBleu_score": 2.646795729915672}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the input duration\n\tdouble duration = 0.0;\n\tif (!getInput(\"duration\", duration)) {\n\t\tROS_WARN_STREAM(\"Missing parameter [duration] in node: \" << getName());\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// If the duration is non-positive, return SUCCESS\n\tif (duration <= 0.0) {\n\t\tROS_WARN_STREAM(\"Duration must be positive in node: \" << getName());\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer to wake up the node after the specified duration\n\ttimer_ = nh_.createTimer(ros::Duration(duration / 1000.0), &SleepNode::timerCallback, this);\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_waiting_ = true;\n\ttimer_.setCallbackQueue(&callback_queue_);\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 48.27690266871396}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\n/*\n * The following lines are used to retrieve the entry from the blackboard.\n * The entry is retrieved using the key stored in entry_key_.\n * The entry is locked using a mutex.\n * The entry is retrieved using the method Entry::operator()\n */\n  auto entry = tree_.blackboard().get(entry_key_);\n  std::unique_lock<std::mutex> entry_lock(entry.mutex);\n\n/*\n * The following lines are used to retrieve the sequence ID from the entry.\n * The sequence ID is retrieved using the method Entry::sequence_id\n */\n  int64_t sequence_id = entry.sequence_id();\n\n/*\n * The following lines are used to retrieve the previously stored sequence ID from the blackboard.\n * The previously stored sequence ID is retrieved using the key stored in stored_sequence_id_key_.\n * The previously stored sequence ID is locked using a mutex.\n * The previously stored sequence ID is retrieved using the method Entry::operator()\n */\n  auto stored_sequence_id = tree_.blackboard().get(stored_sequence_id_key_);\n  std::unique_lock<std::mutex> stored_sequence_id_lock(stored_sequence_id.mutex);\n\n/*\n * The following lines are used to compare the sequence ID stored in the entry with the sequence ID stored in the blackboard.\n * If the IDs are different, the sequence ID stored in the blackboard is updated.\n */\n  if (sequence_id != stored_sequence_id.value<int64_t>()) {\n    stored_sequence_id = sequence_id;\n    stored_sequence_id_lock.unlock();\n    tree_.blackboard().set(stored_sequence_id_key_, stored_sequence_id);\n    return NodeStatus::SUCCESS;\n  }\n\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 46.95947103238064}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\n\\t// Retrieve the entry from the blackboard\n\\tEntry entry = blackboard_->get(entry_key_);\n\n\\t// If the entry is not found, return FAILURE\n\\tif(!entry) {\n\\t\\treturn NodeStatus::FAILURE;\n\\t}\n\n\\t// Retrieve the sequence ID from the entry\n\\tuint64_t seq = entry.sequence_id();\n\n\\t// If the sequence ID is different from the one stored in the blackboard, update it\n\\tif(seq != sequence_id_) {\n\\t\\tsequence_id_ = seq;\n\\t\\treturn NodeStatus::SUCCESS;\n\\t}\n\n\\t// Otherwise, return FAILURE\n\\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.406273905924465}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tEntry entry = blackboard_->get(entry_key_);\n\tif (!entry) {\n\t\tROS_WARN_STREAM(\"EntryUpdatedAction: Entry \" << entry_key_ << \" not found in the blackboard\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex\n\tstd::unique_lock<std::mutex> lock(entry.mutex);\n\n\t// Check if the sequence IDs are different\n\tif (entry.sequence_id != entry.last_sequence_id) {\n\t\tentry.last_sequence_id = entry.sequence_id;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.848414139673125}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\nreturn (children_nodes_.size() + success_threshold_);\n}\nreturn success_threshold_;\n}", "CodeBleu_score": 50.189394476729085}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif(success_threshold_ < 0)\n{\nreturn (children_nodes_.size() + success_threshold_);\n}\nelse\n{\nreturn success_threshold_;\n}\n}", "CodeBleu_score": 58.32475306146194}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size() + success_threshold_;\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.92709212356128}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\tif (_p->heartbeat_status != _p->last_heartbeat_status) {\n\t\t\t_p->last_heartbeat_status = _p->heartbeat_status;\n\t\t\tenableAllHooks(_p->heartbeat_status);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.425248080172285}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\t// sleep for 10 ms\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// check if the heartbeat is still active\n\t\tbool heartbeat_active = false;\n\t\t{\n\t\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\t\theartbeat_active = _p->heartbeat_active;\n\t\t}\n\n\t\t// if the heartbeat is active, do nothing\n\t\tif(heartbeat_active) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if the heartbeat is inactive, disable all breakpoints\n\t\t{\n\t\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\t\t\tfor(auto& [node_uid, hook] : _p->pre_hooks) {\n\t\t\t\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\t\t\t\thook->enabled = false;\n\t\t\t\t// when disabling, remember to wake up blocked ones\n\t\t\t\tif(!hook->enabled && hook->mode == Monitor::Hook::Mode::BREAKPOINT) {\n\t\t\t\t\tlk.unlock();\n\t\t\t\t\thook->wakeup.notify_all();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.83707667166136}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\tif (_p->heartbeat_status != _p->last_heartbeat_status) {\n\t\t\tif (_p->heartbeat_status == Monitor::Status::CONNECTED) {\n\t\t\t\tenableAllHooks(true);\n\t\t\t} else {\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t\t_p->last_heartbeat_status = _p->heartbeat_status;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.252692592487215}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tnlohmann::json bb_json;\n\tstd::vector<uint8_t> bb_dump;\n\n\t// split the list of blackboards\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\t// iterate through the list of blackboards\n\tfor (const std::string& bb_name : bb_names) {\n\t\t// find the blackboard\n\t\tBlackboard::Ptr bb = _p->blackboard_server->getBlackboard(bb_name);\n\t\tif (!bb) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" not found\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// lock the blackboard\n\t\tif (!bb->lock(500)) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" could not be locked\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// get the blackboard subtree\n\t\tBlackboard::Tree::Ptr subtree = bb->getTree();\n\t\tif (!subtree) {\n\t\t\tROS_ERROR_STREAM(\"Blackboard \" << bb_name << \" subtree not found\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// export the blackboard subtree to JSON\n\t\tnlohmann::json subtree_json = subtree->to_json();\n\n\t\t// add the blackboard subtree to the JSON object\n\t\tbb_json[bb_name] = subtree_json;\n\n\t\t// unlock the blackboard\n\t\tbb->unlock();\n\t}\n\n\t// convert the JSON object to MessagePack format\n\tbb_dump = nlohmann::json::to_msgpack(bb_json);\n\n\treturn bb_dump;\n}", "CodeBleu_score": 42.8036173910711}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\tauto bb_names = split(bb_list, ',');\n\tnlohmann::json bb_dump_json = nlohmann::json::object();\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto bb = _p->blackboard->getTree(bb_name);\n\t\tif (bb) {\n\t\t\tstd::unique_lock<std::mutex> lk(bb->mutex);\n\t\t\tbb_dump_json[bb_name] = bb->to_json();\n\t\t}\n\t}\n\tauto bb_dump_str = bb_dump_json.dump();\n\tbb_dump.resize(bb_dump_str.size());\n\tstd::copy(bb_dump_str.begin(), bb_dump_str.end(), bb_dump.begin());\n\treturn bb_dump;\n}", "CodeBleu_score": 49.18301378742972}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> msg;\n\tmsg.reserve(1024);\n\n\t// convert the string to a vector of blackboard names\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\t// create a json object to hold the dump\n\tnlohmann::json json_out;\n\n\tfor(const std::string& bb_name : bb_names) {\n\t\t// find the blackboard\n\t\tBlackboard::Ptr bb = _p->blackboard_server->getBlackboard(bb_name);\n\n\t\tif(bb) {\n\t\t\t// lock the blackboard\n\t\t\tstd::unique_lock<std::mutex> bb_lock(bb->mutex);\n\n\t\t\t// if the blackboard is valid, convert it to json and add it to the json object\n\t\t\tif(bb->valid) {\n\t\t\t\tnlohmann::json bb_json = bb->to_json();\n\t\t\t\tjson_out[bb_name] = bb_json;\n\t\t\t}\n\t\t}\n\t}\n\n\t// convert the json object to messagepack\n\tmsgpack::pack(msg, json_out);\n\n\treturn msg;\n}", "CodeBleu_score": 46.15024398998413}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\nauto it = _p->pre_hooks.find(node_uid);\nif(it == _p->pre_hooks.end())\n{\nreturn false;\n}\nauto hook = it->second;\n\nif(hook->mode != Monitor::Hook::Mode::BREAKPOINT)\n{\nreturn false;\n}\n\nstd::unique_lock<std::mutex> lk2(hook->mutex);\nhook->desired_status = result;\nhook->remove_when_done = remove;\nhook->ready = true;\nhook->wakeup.notify_all();\n\nreturn true;\n}", "CodeBleu_score": 52.59105236967506}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\nauto it = _p->pre_hooks.find(node_uid);\nif(it == _p->pre_hooks.end())\n{\n  return false;\n}\nauto hook = it->second;\n\nif(hook->mode != Monitor::Hook::Mode::BREAKPOINT)\n{\n  return false;\n}\n\nstd::unique_lock<std::mutex> lk_hook(hook->mutex);\nhook->desired_status = result;\nhook->remove_when_done = remove;\nhook->ready = true;\nhook->wakeup.notify_all();\n\nreturn true;\n}", "CodeBleu_score": 53.04874079478973}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\nauto it = _p->pre_hooks.find(node_uid);\nif(it == _p->pre_hooks.end()) {\nreturn false;\n}\nstd::shared_ptr<Monitor::Hook> hook = it->second;\n\n// lock the hook mutex\nstd::unique_lock<std::mutex> lk_hook(hook->mutex);\n\nif(hook->mode != Monitor::Hook::Mode::BREAKPOINT) {\nreturn false;\n}\n\nhook->desired_status = result;\nhook->remove_when_done = remove;\nhook->ready = true;\nhook->wakeup.notify_all();\nreturn true;\n}", "CodeBleu_score": 51.07524462579821}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// if the node is already running, do nothing\n\tif(status() == NodeStatus::RUNNING) {\n\t\treturn status();\n\t}\n\n\t// if the node is idle, reset the halt flag and start the thread\n\tif(status() == NodeStatus::IDLE) {\n\t\thalt_requested_ = false;\n\t\tthread_ = std::thread(&ThreadedAction::tickThread, this);\n\t\treturn NodeStatus::RUNNING;\n\t}\n\n\t// if the node is running, wait for the thread to finish\n\tif(status() == NodeStatus::RUNNING) {\n\t\tif(thread_.joinable()) {\n\t\t\tthread_.join();\n\t\t}\n\t\treturn status();\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 24.866445134516535}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tif (status() == NodeStatus::IDLE) {\nsetStatus(NodeStatus::RUNNING);\nhalt_requested_.store(false);\nstd::thread([this]() {\ntry {\ntick();\n} catch (std::exception& e) {\nROS_ERROR_STREAM(\n\"Exception in \" << name() << \" thread:\n\" << e.what());\n}\n}).detach();\n}\n\nif (status() == NodeStatus::RUNNING && halt_requested_.load()) {\nonHalted();\nresetStatus();\n}\n\nif (status() == NodeStatus::RUNNING && !halt_requested_.load()) {\nreturn NodeStatus::RUNNING;\n}\n\nreturn status();\n}", "CodeBleu_score": 32.275562179581854}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tNodeStatus prev_status = status();\n\n\tif(prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\tif(prev_status == NodeStatus::RUNNING) {\n\t\tstd::thread([this]() {\n\t\t\ttry {\n\t\t\t\thalt_requested_.store(false);\n\t\t\t\tNodeStatus new_status = tick();\n\t\t\t\tif(new_status == NodeStatus::IDLE) {\n\t\t\t\t\tthrow LogicError(\"ThreadedAction::tick() must not return IDLE\");\n\t\t\t\t}\n\t\t\t\tsetStatus(new_status);\n\t\t\t}\n\t\t\tcatch(std::exception& e) {\n\t\t\t\tROS_ERROR_STREAM(\"Exception caught in ThreadedAction::executeTick(): \" << e.what());\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t}\n\t\t}).detach();\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 43.782552520283105}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\nif(!root_node) {\nthrow LogicError(\"root_node is nullptr\");\n}\n\nstream << \"BehaviorTree structure:\n\n\";\n\nauto print_node = [&stream, &print_node](const TreeNode* node, unsigned int depth) {\nstream << std::string(depth * 2, ' ') << node->name() << std::endl;\n\nif(auto control = dynamic_cast<const ControlNode*>(node)) {\nfor(const auto& child : control->children()) {\nprint_node(child, depth + 1);\n}\n} else if(auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\nprint_node(decorator->child(), depth + 1);\n}\n};\n\nprint_node(root_node, 0);\n\nstream << \"End of BehaviorTree structure\n\n\";\n}", "CodeBleu_score": 44.424051143774854}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t", "CodeBleu_score": 3.8194029341999376}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif (!root_node) {\nthrow LogicError(\"root_node is nullptr\");\n}\n\nstream << \"BehaviorTree structure:\n\";\n\nstd::function<void(const TreeNode*, unsigned int)> print_helper;\nprint_helper = [&print_helper, &stream](const TreeNode* node, unsigned int depth) {\nstream << std::string(depth * 2, ' ');\nstream << node->name();\nstream << '\n';\n\nif (auto control = dynamic_cast<const ControlNode*>(node)) {\nfor (const auto& child : control->children()) {\nprint_helper(child, depth + 1);\n}\n} else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\nprint_helper(decorator->child(), depth + 1);\n}\n};\n\nprint_helper(root_node, 0);\n\nstream << \"End BehaviorTree structure\n\";\n}", "CodeBleu_score": 45.009880137523425}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) throw std::logic_error(\"The node parameter cannot be null\");\n\tvisitor(node);\n\tif (node->is_control_node()) {\n\t\tconst ControlNode* cn = static_cast<const ControlNode*>(node);\n\t\tfor (const TreeNode* child : cn->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->is_decorator_node()) {\n\t\tconst DecoratorNode* dn = static_cast<const DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(dn->child, visitor);\n\t}\n}", "CodeBleu_score": 56.2543989549282}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow std::invalid_argument(\"node is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const TreeNode* child : control->children()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 63.875919538331914}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\nthrow std::invalid_argument(\"node is nullptr\");\n}\nvisitor(node);\nconst ControlNode* control_node = dynamic_cast<const ControlNode*>(node);\nif (control_node) {\nfor (const auto& child : control_node->children()) {\napplyRecursiveVisitor(child.get(), visitor);\n}\n} else {\nconst DecoratorNode* decorator_node = dynamic_cast<const DecoratorNode*>(node);\nif (decorator_node) {\napplyRecursiveVisitor(decorator_node->child(), visitor);\n}\n}\n}", "CodeBleu_score": 62.03128800886951}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.count(manifest.registration_ID)) {\nthrow BehaviorTreeException(\"A node with ID '\" + manifest.registration_ID + \"' is already registered\");\n}\n_p->builders[manifest.registration_ID] = builder;\n_p->manifests[manifest.registration_ID] = manifest;\n_p->builtin_IDs.insert(manifest.registration_ID);\n}", "CodeBleu_score": 49.877035114801274}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.count(manifest.registration_ID) > 0) {\n\t\tthrow BehaviorTreeException(\"ID already exists: \" + manifest.registration_ID);\n\t}\n\n\t_p->builders[manifest.registration_ID] = builder;\n\t_p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 46.859739453178065}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builtinNodes().count(manifest.registration_ID)) {\n\t\tthrow LogicError(\"You can not override the builtin registration ID [\" + manifest.registration_ID + \"]\");\n\t}\n\tauto it = _p->builders.find(manifest.registration_ID);\n\tif (it != _p->builders.end()) {\n\t\tthrow LogicError(\"A builder with ID [\" + manifest.registration_ID + \"] is already registered\");\n\t}\n\t_p->builders[manifest.registration_ID] = builder;\n\t_p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 57.289180306909}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                       const NodeConfig& config) {\n  return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n};\n\nTreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 98.37118404609555}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor, ID](const std::string& name, const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n};\n\nTreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 95.26401864910622}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor, ID](const std::string& name,\nconst NodeConfig& config) {\nreturn std::make_unique<SimpleActionNode>(name, tick_functor, config);\n};\n\nTreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 94.81026625476845}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.subtrees.size());\n\tfor(const auto& subtree : tree.subtrees) {\n\t\tauto bb = std::make_shared<Blackboard>();\n\t\tsubtree->blackboard->cloneInto(*bb);\n\t\tbackup.push_back(bb);\n\t}\n\treturn backup;\n}", "CodeBleu_score": 58.38641601643945}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for(const auto& subtree : tree.subtrees)\n  {\n    auto bb = std::make_shared<Blackboard>();\n    subtree->blackboard->cloneInto(*bb);\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 60.29678614711565}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for(auto& subtree : tree.subtrees)\n  {\n    auto bb = std::make_shared<Blackboard>();\n    subtree->blackboard->cloneInto(*bb);\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 60.00605213958511}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\nif(executor.has_value()) {\nreturn executor.value()(env);\n}\nelse {\nreturn nonstd::make_unexpected(executor.error());\n}\n}", "CodeBleu_score": 84.36033091505746}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (executor.has_value()) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.37918082749243}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto result = ParseScript(script);\nif(result) {\nreturn result.value()(env);\n}\nelse {\nreturn nonstd::make_unexpected(result.error());\n}\n}", "CodeBleu_score": 68.74652843076726}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n  if (_handle) {\n    throw RuntimeError(\\\"SharedLibrary: A library is already loaded\\\");\n  }\n\n  _path = path;\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    auto error = std::string(dlerror());\n    throw RuntimeError(\\\"SharedLibrary: Failed to load library \\\\\\\"\\\" + path + \\\"\\\\\\\": \\\" + error);\n  }\n}", "CodeBleu_score": 53.4418763919968}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\n  std::unique_lock<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\\\"A library is already loaded\\\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    const char* error = dlerror();\n    if (error) {\n      throw RuntimeError(std::string(\\\"Failed to load library: \\\") + error);\n    }\n  }\n  _path = path;\n}", "CodeBleu_score": 62.92437127664816}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\n  std::unique_lock<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\\\"Library already loaded\\\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    auto msg = std::string(dlerror());\n    throw RuntimeError(\\\"Failed to load library \\\" + path + \\\": \\\" + msg);\n  }\n  _path = path;\n}", "CodeBleu_score": 55.57773395177571}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif(str.size() < 3) {\n\t\treturn false;\n\t}\n\tauto trimmed = str.trim();\n\tif(trimmed.front() != '{' || trimmed.back() != '}') {\n\t\treturn false;\n\t}\n\tif(stripped_pointer) {\n\t\t*stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 23.6880273833987}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif(str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.trim();\n\tif(stripped.front() != '{' || stripped.back() != '}') {\n\t\treturn false;\n\t}\n\n\tif(stripped_pointer != nullptr) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 23.768413053311182}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif(str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped_str = str;\n\tstripped_str.remove_prefix(str.find_first_not_of(' '));\n\tstripped_str.remove_suffix(str.size() - stripped_str.find_last_not_of(' ') - 1);\n\n\tif(stripped_str.front() != '{' || stripped_str.back() != '}') {\n\t\treturn false;\n\t}\n\n\tif(stripped_pointer) {\n\t\t*stripped_pointer = stripped_str.substr(1, stripped_str.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 30.414969635018174}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t//if the line is vertical, the cost is just the difference in y\n\tif(x0 == x1)\n\t\treturn y1 - y0;\n\n\t//if the line is horizontal, the cost is just the difference in x\n\tif(y0 == y1)\n\t\treturn x1 - x0;\n\n\t//otherwise, we need to calculate the slope of the line\n\tdouble slope = (y1 - y0) / (x1 - x0);\n\n\t//we'll use this to store the cost of the line\n\tdouble line_cost = 0.0;\n\n\t//this will be used to calculate the cost of each point\n\tdouble point_cost;\n\n\t//we'll use this to iterate through the line\n\tLineIterator iterator(costmap_, x0, y0, x1, y1);\n\n\t//iterate through the line\n\tfor(int i = 0; i < iterator.getCellCount(); ++i) {\n\t\t//get the cost of the point\n\t\tpoint_cost = getCost(iterator.getX(), iterator.getY());\n\n\t\t//if the point cost is no information, we can't calculate the cost of the line\n\t\tif(point_cost == NO_INFORMATION)\n\t\t\treturn NO_INFORMATION;\n\n\t\t//if the point cost is lethal, we know the line is lethal\n\t\tif(point_cost == LETHAL_OBSTACLE)\n\t\t\treturn LETHAL_OBSTACLE;\n\n\t\t//if the point cost is inscribed, we can add it to the line cost\n\t\tif(point_cost == INSCRIBED_INFLATED_OBSTACLE)\n\t\t\tline_cost += INSCRIBED_INFLATED_OBSTACLE_COST;\n\t\telse\n\t\t\tline_cost += point_cost;\n\n\t\t//increment the iterator\n\t\titerator.increment();\n\t}\n\n\t//we can now calculate the cost of the line\n\tline_cost *= std::abs(slope);\n\n\t//return the cost of the line\n\treturn line_cost;\n}", "CodeBleu_score": 52.10884545310051}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//  double line_cost = 0.0;\n\n  //calculate the distance between the two points\n  double dx = x1 - x0;\n  double dy = y1 - y0;\n  double dist = sqrt(dx * dx + dy * dy);\n\n  //if the points are the same, return the cost at that point\n  if(dist == 0.0)\n    return getCost(x0, y0);\n\n  //calculate the delta between the points\n  double delta_x = dx / dist;\n  double delta_y = dy / dist;\n\n  //initialize the line iterator\n  LineIterator it(x0, y0, delta_x, delta_y);\n\n  //iterate through each cell in the line\n  double point_cost;\n  double max_cost = 0.0;\n  while(!it.isDone()) {\n    //get the cost at the current cell\n    point_cost = getCost(it.getX(), it.getY());\n\n    //if the cost is not valid, we know the rest of the line will not be valid, so return\n    if(point_cost < 0)\n      return point_cost;\n\n    //update the line cost if the current cost is higher\n    max_cost = std::max(max_cost, point_cost);\n\n    //increment the iterator\n    it.increment();\n  }\n\n  //return the max cost\n  return max_cost;\n}", "CodeBleu_score": 49.90507357092373}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tfor(LineIterator liter(costmap_, x0, y0, x1, y1); liter != liter.end(); liter++) {\n\t\tunsigned char cost = costmap_.getCost(*liter);\n\t\tif(cost == LETHAL_OBSTACLE)\n\t\t\treturn LETHAL_OBSTACLE;\n\t\tif(cost == NO_INFORMATION)\n\t\t\treturn NO_INFORMATION;\n\t\tline_cost = std::max(line_cost, cost);\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 53.19891015067025}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty()) return;\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\tfor(unsigned int i=0; i<path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 78.87148045923776}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Local path is empty. Not publishing plan.\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Publishing plan\");\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 70.70497817480215}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN_STREAM(\"Path is empty, not publishing anything\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path.front().header.frame_id;\n\tgui_path.header.stamp = path.front().header.stamp;\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 71.78421223156383}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n//check to see if the robot is moving at all\nif (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.z) <= trans_stopped_velocity && fabs(base_odom.twist.twist.angular.x) <= rot_stopped_velocity && fabs(base_odom.twist.twist.angular.y) <= rot_stopped_velocity && fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n  return true;\n}\n\nreturn false;\n}", "CodeBleu_score": 70.21168783797226}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n//    ROS_INFO(\"rotational velocity: %f, translational velocity: %f\", base_odom.twist.twist.angular.z, base_odom.twist.twist.linear.x);\n\n    if(fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 66.26084209787105}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif(fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 85.62057223469895}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tuvw\n *  if(!initialized_) {\n    if(restore_defaults) {\n      config = default_config_;\n    }\n    else {\n      default_config_ = config;\n    }\n    setup_ = true;\n  }\n  else if(restore_defaults) {\n    config = default_config_;\n  }\n  config_mutex_.lock();\n  max_trans_vel_ = config.max_trans_vel;\n  min_trans_vel_ = config.min_trans_vel;\n  max_vel_x_ = config.max_vel_x;\n  min_vel_x_ = config.min_vel_x;\n  max_vel_theta_ = config.max_vel_theta;\n  min_vel_theta_ = config.min_vel_theta;\n  acc_lim_x_ = config.acc_lim_x;\n  acc_lim_theta_ = config.acc_lim_theta;\n  config_mutex_.unlock();\n}", "CodeBleu_score": 46.98131958729337}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n/*\n * The cost of a cell is defined as the cost of the cell's center plus the cost of the cell's four corners.\n * The cost of a cell's center is the cost of the cell's center in the costmap.\n * The cost of a cell's corners is the maximum of the cost of the cell's four corners in the costmap.\n * The cost of a cell's four corners is the maximum of the cost of the cell's four corners in the costmap.\n */\n  unsigned int cost_of_cell = costmap.getCost(check_cell->cx, check_cell->cy);\n  unsigned int cost_of_cell_center = cost_of_cell;\n  unsigned int cost_of_cell_corners = cost_of_cell;\n\n  //check the cost of the cell's center\n  if(cost_of_cell_center == costmap.getNoInformation()){\n    cost_of_cell_center = costmap.getObstacleCost();\n  }\n\n  //check the cost of the cell's corners\n  for(unsigned int i = 0; i < 4; ++i){\n    unsigned int cost_of_corner = costmap.getCost(check_cell->cx + corner_x[i], check_cell->cy + corner_y[i]);\n    if(cost_of_corner == costmap.getNoInformation()){\n      cost_of_corner = costmap.getObstacleCost();\n    }\n    if(cost_of_corner > cost_of_cell_corners){\n      cost_of_cell_corners = cost_of_corner;\n    }\n  }\n\n  //check if the cell is an obstacle\n  if(cost_of_cell_center == costmap.getObstacleCost() || cost_of_cell_corners == costmap.getObstacleCost()){\n    check_cell->target_distance = costmap.getObstacleCost();\n    return false;\n  }\n\n  //calculate the new target distance\n  unsigned int new_target_distance = cost_of_cell_center + cost_of_cell_corners;\n  if(new_target_distance < current_cell->target_distance){\n    check_cell->target_distance = new_target_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.69386987651221}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t", "CodeBleu_score": 6.181338956123423}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t", "CodeBleu_score": 6.181338956123423}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty, cannot calculate cost\");\n\t\treturn -9;\n\t}\n\n\t// initialize cost and scaling factor\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// for each point in the trajectory, calculate the footprint cost\n\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i), scaling_factor);\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 47.67219515156095}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//  ROS_DEBUG(\"scoreTrajectory called\");\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Footprint specification is empty, cannot calculate trajectory cost\");\n    return -9;\n  }\n\n  if (traj.getSpeed() > scaling_speed_) {\n    scaling_factor = max_scaling_factor_;\n  } else {\n    scaling_factor = max_scaling_factor_ * (1.0 - traj.getSpeed() / scaling_speed_);\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.getPoint(i), scaling_factor);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    } else if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 55.912857108555855}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_DEBUG(\"Footprint cost at position (%.2f, %.2f, %.2f) with scale %.2f\", x, y, th, scale);\n  double cost = 0;\n  double wx, wy;\n  if (!world_model->getWorldPose(x, y, th, wx, wy)) {\n//    ROS_DEBUG(\"Footprint cost at position (%.2f, %.2f, %.2f) is off the map\", x, y, th);\n    return -7.0;\n  }\n\n  //scale the footprint points by the given scale factor\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    footprint_spec[i].x *= scale;\n    footprint_spec[i].y *= scale;\n  }\n\n  //compute the footprint cost\n  cost = world_model->footprintCost(wx, wy, footprint_spec, costmap);\n\n  //if the footprint cost is negative, return -6.0\n  if (cost < 0) {\n    return -6.0;\n  }\n\n  //otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  return std::max(cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 52.89091352128731}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_INFO(\"footprintCost called\");\n\n  double footprint_cost = 0.0;\n  double mx, my, mth;\n  double cost;\n\n  //check if the point is off the map\n  if (!world_model->getRobotPose(mx, my, mth)) {\n    ROS_ERROR(\"Unable to get robot pose from world model\");\n    return -7.0;\n  }\n\n  //check if the point is in an obstacle\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    ROS_ERROR(\"Point is not in the costmap\");\n    return -6.0;\n  }\n\n  //scale the footprint\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    double xp = x + scale * footprint_spec[i].x;\n    double yp = y + scale * footprint_spec[i].y;\n    double thp = th + scale * footprint_spec[i].z;\n\n    if (!costmap->worldToMap(xp, yp, mx, my)) {\n      ROS_ERROR(\"Point is not in the costmap\");\n      return -6.0;\n    }\n\n    //get the cost at the point\n    cost = costmap->getCost(mx, my);\n\n    //check if the cost is valid\n    if (cost < 0) {\n      ROS_ERROR(\"Cost is not valid\");\n      return -6.0;\n    }\n\n    //add the cost to the footprint cost\n    footprint_cost += cost;\n  }\n\n  //get the cost at the footprint position\n  cost = costmap->getCost(mx, my);\n\n  //check if the cost is valid\n  if (cost < 0) {\n    ROS_ERROR(\"Cost is not valid\");\n    return -6.0;\n  }\n\n  //return the maximum of the footprint cost and the cell cost\n  if (footprint_cost > cost) {\n    return footprint_cost;\n  }\n  else {\n    return cost;\n  }\n}", "CodeBleu_score": 56.93710882815902}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tboost::mutex::scoped_lock lock(odom_mutex_);\n\tif (odom_topic != odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic.empty()) {\n\t\t\tROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to %s for odometry\", odom_topic_.c_str());\n\t\t\tsub_odom_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t\telse {\n\t\t\tROS_WARN_NAMED(\"dwa_local_planner\", \"Shutting down odometry subscriber\");\n\t\t\tsub_odom_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 40.215776566400876}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic != odom_topic_) {\n\t\tif (odom_topic != \"\") {\n\t\t\todom_sub_ = odom_nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\todom_topic_ = odom_topic;\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t\todom_topic_ = \"\";\n\t\t}\n\t}\n}", "CodeBleu_score": 41.54479228172034}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tboost::mutex::scoped_lock lock(odom_mutex_);\n\tif(odom_topic != odom_topic_) {\n\t\tif(!odom_topic.empty()) {\n\t\t\tROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to Odometry on topic '%s'\", odom_topic.c_str());\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\tROS_INFO_NAMED(\"dwa_local_planner\", \"Shutting down Odometry subscriber\");\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 38.4524746640899}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tdouble dx = pos.x() - prev.x();\n\tdouble dy = pos.y() - prev.y();\n\tdouble dist = dx * dx + dy * dy;\n\tif (dist > oscillation_reset_dist_ * oscillation_reset_dist_) {\n\t\tROS_INFO(\"resetting oscillation flags\");\n\t\tforward_pos_ = false;\n\t\tforward_neg_ = false;\n\t\tstrafe_pos_ = false;\n\t\tstrafe_neg_ = false;\n\t\trot_pos_ = false;\n\t\trot_neg_ = false;\n\t}\n\tdouble angle = atan2(dy, dx);\n\tdouble angle_diff = fmod(angle - prev.z(), 2 * M_PI);\n\tif (angle_diff > M_PI) {\n\t\tangle_diff -= 2 * M_PI;\n\t}\n\tif (fabs(angle_diff) > oscillation_reset_angle_) {\n\t\tROS_INFO(\"resetting oscillation flags\");\n\t\tforward_pos_ = false;\n\t\tforward_neg_ = false;\n\t\tstrafe_pos_ = false;\n\t\tstrafe_neg_ = false;\n\t\trot_pos_ = false;\n\t\trot_neg_ = false;\n\t}\n}", "CodeBleu_score": 42.884575303248}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tdouble dist = (pos - prev).squaredNorm();\n\tdouble angle = atan2(pos.y() - prev.y(), pos.x() - prev.x()) - atan2(prev.y(), prev.x());\n\tif (dist > oscillation_reset_dist_ * oscillation_reset_dist_ || fabs(angle) > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 50.627558923954076}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tif (oscillation_reset_dist_ > 0.0) {\n\t\tdouble sq_dist = (pos - prev).squaredNorm();\n\t\tif (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_) {\n\t\t\toscillation_flags_.reset();\n\t\t}\n\t}\n\tif (oscillation_reset_angle_ > 0.0) {\n\t\tdouble diff = pos.x() - prev.x();\n\t\tif (diff > 0.0) {\n\t\t\tif (diff > oscillation_reset_angle_) {\n\t\t\t\toscillation_flags_.reset();\n\t\t\t}\n\t\t} else {\n\t\t\tif (diff < -oscillation_reset_angle_) {\n\t\t\t\toscillation_flags_.reset();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.72609560232201}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\tif(!gridCoords(pt, gx, gy))\n\t\treturn;\n\t//get the index of the cell that contains the point\n\tunsigned int index = gridIndex(gx, gy);\n\t//get the cell at that index\n\tlist<geometry_msgs::Point32>& cell = cells_[index];\n\t//compute the distance to the nearest neighbor\n\tdouble min_dist = 1e10;\n\tfor(list<geometry_msgs::Point32>::iterator it = cell.begin(); it != cell.end(); ++it) {\n\t\tdouble dist = hypot(pt.x - it->x, pt.y - it->y);\n\t\tif(dist < min_dist)\n\t\t\tmin_dist = dist;\n\t}\n\t//if the distance is too small, don't insert the point\n\tif(min_dist < min_dist_)\n\t\treturn;\n\t//insert the point\n\tcell.push_back(pt);\n}", "CodeBleu_score": 64.94209250444231}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\tif(!gridCoords(pt, gx, gy))\n\t\treturn;\n\t//get the index of the cell\n\tunsigned int index = gridIndex(gx, gy);\n\n\t//get the cell\n\tlist<geometry_msgs::Point32>& cell = cells_[index];\n\n\t//if the cell is empty... we can insert the point\n\tif(cell.empty()){\n\t\tcell.push_back(pt);\n\t\treturn;\n\t}\n\n\t//if the cell is not empty... we have to check if the point is too close to its nearest neighbor\n\tdouble min_distance = 100000000.0; //a large number\n\tlist<geometry_msgs::Point32>::iterator it = cell.begin();\n\tfor(; it != cell.end(); ++it){\n\t\tdouble distance = distance2D(*it, pt);\n\t\tif(distance < min_distance){\n\t\t\tmin_distance = distance;\n\t\t}\n\t}\n\n\t//if the point is too close to its nearest neighbor... don't insert it\n\tif(min_distance < min_distance_){\n\t\treturn;\n\t}\n\n\t//if we get here, the point is valid and we can insert it\n\tcell.push_back(pt);\n}", "CodeBleu_score": 63.59349873602199}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\tif(!gridCoords(pt, gx, gy))\n\t\treturn;\n\t//get the index of the cell the point should be in\n\tunsigned int index = gridIndex(gx, gy);\n\t//get the cell\n\tlist<geometry_msgs::Point32>& cell = cells_[index];\n\t//check if the cell is empty\n\tif(cell.empty()) {\n\t\t//if the cell is empty, add the point to the cell\n\t\tcell.push_back(pt);\n\t\treturn;\n\t}\n\t//if the cell is not empty, check if the point is close to any point in the cell\n\tdouble min_dist = 1e10;\n\tlist<geometry_msgs::Point32>::iterator it;\n\tfor(it = cell.begin(); it != cell.end(); ++it) {\n\t\t//get the distance between the point and the current point in the cell\n\t\tdouble dist = dist2(*it, pt);\n\t\t//if the distance is less than the minimum distance, update the minimum distance\n\t\tif(dist < min_dist)\n\t\t\tmin_dist = dist;\n\t}\n\t//if the point is close to a point in the cell... don't insert the point\n\tif(min_dist < min_dist_)\n\t\treturn;\n\t//if the point is not close to any point in the cell... insert the point\n\tcell.push_back(pt);\n}", "CodeBleu_score": 64.25984954821445}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t", "CodeBleu_score": 6.285623149499962}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n//  ROS_DEBUG_NAMED(\\\"Generator\\\", \\\"Flag: %d, Loop_Vel %f, %f, %f\\\", continued_acceleration_, loop_vel[0], loop_vel[1], loop_vel[2]);\n\n  //initialize new velocity vector\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  //compute new velocities for each of the three velocity components\n  if (fabs(sample_target_vel[0]) > 1e-6) {\n    new_vel[0] = vel[0] + acclimits[0] * dt * sign(sample_target_vel[0] - vel[0]);\n  }\n  if (fabs(sample_target_vel[1]) > 1e-6) {\n    new_vel[1] = vel[1] + acclimits[1] * dt * sign(sample_target_vel[1] - vel[1]);\n  }\n  if (fabs(sample_target_vel[2]) > 1e-6) {\n    new_vel[2] = vel[2] + acclimits[2] * dt * sign(sample_target_vel[2] - vel[2]);\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 42.3769478493227}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n/*\n * This function, SimpleTrajectoryGenerator::computeNewVelocities, computes new velocities for an object based on target velocities, current velocities, acceleration limits, and time delta.\nIt initializes a new velocity vector to zero.\nFor each of the three velocity components, it increases or decreases the current velocity towards the target velocity within the acceleration limits.\nFinally, it returns the new velocity vector.\n */\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  //compute new velocities\n  for (int i = 0; i < 3; i++) {\n    //compute the distance to the target velocity\n    double dist_to_target_vel = sample_target_vel[i] - vel[i];\n\n    //check if we are already at the target velocity\n    if (fabs(dist_to_target_vel) < 1e-6) {\n      new_vel[i] = sample_target_vel[i];\n    } else {\n      //compute the distance to the maximum velocity\n      double dist_to_max_vel = acclimits[i] * dt;\n\n      //check if we are already at the maximum velocity\n      if (fabs(dist_to_max_vel) < 1e-6) {\n        new_vel[i] = vel[i] + dist_to_target_vel;\n      } else {\n        //compute the ratio of the distance to the maximum velocity to the distance to the target velocity\n        double ratio = dist_to_max_vel / dist_to_target_vel;\n\n        //check if we are already at the maximum velocity\n        if (ratio > 1.0) {\n          new_vel[i] = vel[i] + dist_to_target_vel;\n        } else {\n          //compute the new velocity\n          new_vel[i] = vel[i] + ratio * dist_to_target_vel;\n        }\n      }\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 63.4021597144827}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n//  ROS_DEBUG(\\\"Heading diff: (%d, %d) -> (%f, %f)\\\", cell_x, cell_y, x, y);\n\n\n  double goal_theta = atan2(y - cell_y, x - cell_x);\n\n  double diff = goal_theta - heading;\n\n  if(diff > M_PI) {\n\n    diff -= 2 * M_PI;\n\n  }\n\n  else if(diff < -M_PI) {\n\n    diff += 2 * M_PI;\n\n  }\n\n  return fabs(diff);\n\n}", "CodeBleu_score": 22.938662182797415}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n//  ROS_DEBUG(\\\"headingDiff: (%d, %d), (%f, %f), (%f)\\\", cell_x, cell_y, x, y, heading);\n\n  double min_angle = DBL_MAX;\n\n  unsigned int plan_size = global_plan_.size();\n\n  for(int i = plan_size - 1; i >= 0; --i){\n\n    double gx = global_plan_[i].pose.position.x;\n\n    double gy = global_plan_[i].pose.position.y;\n\n\n//    ROS_DEBUG(\\\"(%f, %f), (%f, %f)\\\", gx, gy, x, y);\n\n    unsigned int goal_cell_x, goal_cell_y;\n\n    if(!costmap_.worldToMap(gx, gy, goal_cell_x, goal_cell_y)){\n\n      continue;\n\n    }\n\n\n//    ROS_DEBUG(\\\"(%d, %d)\\\", goal_cell_x, goal_cell_y);\n\n    //check if we have line of sight to the goal\n\n    if(costmap_.computeRayCost(cell_x, cell_y, goal_cell_x, goal_cell_y) < 0){\n\n      continue;\n\n    }\n\n\n    //convert goal cell coordinates to world coordinates\n\n    double wx, wy;\n\n    costmap_.mapToWorld(goal_cell_x, goal_cell_y, wx, wy);\n\n\n    //compute the angle between the robot and the goal point\n\n    double angle = atan2(wy - y, wx - x);\n\n    angle = angle - heading;\n\n    angle = angle >= 0.0 ? angle : angle + 2.0 * M_PI;\n\n    angle = angle <= M_PI ? angle : angle - 2.0 * M_PI;\n\n\n//    ROS_DEBUG(\\\"angle: %f\\\", angle);\n\n    //check if the angle is the smallest we've seen so far\n\n    if(min_angle > angle){\n\n      min_angle = angle;\n\n    }\n\n  }\n\n\n//  ROS_DEBUG(\\\"min_angle: %f\\\", min_angle);\n\n  return min_angle;\n\n}", "CodeBleu_score": 53.49630786109153}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x, goal_y, goal_theta, dx, dy;\n\tdouble min_angle = DBL_MAX;\n\n\t//iterate through the global plan in reverse order\n\tfor(int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t//get the x and y position of the goal cell\n\t\tgoal_x = global_plan_[i].pose.position.x;\n\t\tgoal_y = global_plan_[i].pose.position.y;\n\n\t\t//convert the goal cell to world coordinates\n\t\tif(!costmap_.mapToWorld(cell_x, cell_y, goal_x, goal_y)) {\n\t\t\tROS_ERROR(\\\"Unable to convert goal cell to world coordinates.\\\");\n\t\t\treturn DBL_MAX;\n\t\t}\n\n\t\t//get the angle to the goal point\n\t\tgoal_theta = atan2(goal_y - y, goal_x - x);\n\n\t\t//get the angle between the robot's current heading and the goal heading\n\t\tdx = cos(goal_theta - heading);\n\t\tdy = sin(goal_theta - heading);\n\n\t\t//calculate the absolute value of the angle between the robot's current heading and the goal heading\n\t\tdouble angle = hypot(dx, dy);\n\n\t\t//if the angle is less than the current minimum angle, update the minimum angle\n\t\tif(angle < min_angle) {\n\t\t\tmin_angle = angle;\n\t\t}\n\t}\n\n\t//return the minimum angle\n\treturn min_angle;\n}", "CodeBleu_score": 55.57202724098032}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//  ROS_INFO(\\\"Checking trajectory with vx: %.2f, vy: %.2f, vtheta: %.2f\\\", vx_samp, vy_samp, vtheta_samp);\n\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN(\\\"Invalid trajectory with vx: %.2f, vy: %.2f, vtheta: %.2f, cost: %.2f\\\", vx_samp, vy_samp, vtheta_samp, cost);\n\n  }\n  return cost >= 0;\n}", "CodeBleu_score": 67.51412266949026}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//  ROS_INFO(\\\"Checking trajectory\\\");\n  double occ_cost = 0.0;\n  double path_dist = 0.0;\n  double goal_dist = 0.0;\n  double heading_diff = 0.0;\n  double cost = 0.0;\n\n  //check if the trajectory is valid\n  if (scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, occ_cost, path_dist, goal_dist, heading_diff, cost)) {\n    return true;\n  } else {\n    ROS_WARN(\\\"Invalid trajectory: vx: %.2f, vy: %.2f, vtheta: %.2f, cost: %f\\\", vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n}", "CodeBleu_score": 56.3137550168891}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//make sure the sample velocities are valid (not NaN or Inf)\n\tif (vx_samp == vx_samp && vy_samp == vy_samp && vtheta_samp == vtheta_samp) {\n\t\t//compute the cost of the trajectory\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\t\t//if the cost is non-negative, the trajectory is valid\n\t\tif (cost >= 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tROS_WARN(\\\"Trajectory cost is negative: (%f, %f, %f, %f, %f, %f, %f, %f, %f)\\\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tROS_WARN(\\\"Invalid sample velocities: (%f, %f, %f)\\\", vx_samp, vy_samp, vtheta_samp);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 64.79963129820813}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif(initialized_ && global_costmap_ && local_costmap_){\n\t\tROS_INFO(\\\"Clearing costmap recovery behavior started\\\");\n\n\t\tif(invert_area_to_clear_){\n\t\t\tROS_WARN(\\\"Clearing costmap recovery behavior will clear inside a specified area\\\");\n\t\t}\n\t\telse{\n\t\t\tROS_WARN(\\\"Clearing costmap recovery behavior will clear outside a specified area\\\");\n\t\t}\n\n\t\t//clear the costmaps\n\t\tif(affected_maps_ == \\\"local\\\" || affected_maps_ == \\\"both\\\"){\n\t\t\tif(force_updating_){\n\t\t\t\tROS_WARN(\\\"Forcing costmap update before clearing local costmap\\\");\n\t\t\t\tlocal_costmap_->updateMap();\n\t\t\t}\n\n\t\t\tROS_INFO(\\\"Clearing local costmap\\\");\n\t\t\tclearCostmap(local_costmap_);\n\t\t}\n\n\t\tif(affected_maps_ == \\\"global\\\" || affected_maps_ == \\\"both\\\"){\n\t\t\tif(force_updating_){\n\t\t\t\tROS_WARN(\\\"Forcing costmap update before clearing global costmap\\\");\n\t\t\t\tglobal_costmap_->updateMap();\n\t\t\t}\n\n\t\t\tROS_INFO(\\\"Clearing global costmap\\\");\n\t\t\tclearCostmap(global_costmap_);\n\t\t}\n\n\t\tROS_INFO(\\\"Clearing costmap recovery behavior completed\\\");\n\t}\n\telse{\n\t\tif(!initialized_){\n\t\t\tROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\n\t\t}\n\t\telse if(!global_costmap_){\n\t\t\tROS_ERROR(\\\"The global costmap is NULL, did you call initialize()?\\\");\n\t\t}\n\t\telse if(!local_costmap_){\n\t\t\tROS_ERROR(\\\"The local costmap is NULL, did you call initialize()?\\\");\n\t\t}\n\t}\n}", "CodeBleu_score": 37.435409747938195}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif(!initialized_){\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\tif(!global_costmap_ || !local_costmap_){\n\t\tROS_ERROR(\"This object must be initialized with non-NULL costmaps before runBehavior is called\");\n\t\treturn;\n\t}\n\n\t//check to see if we are clearing the whole costmap or just a portion of it\n\tif(affected_maps_ == \\\"both\\\") {\n\t\tclearCostmap(global_costmap_);\n\t\tclearCostmap(local_costmap_);\n\t}\n\telse if(affected_maps_ == \\\"global\\\") {\n\t\tclearCostmap(global_costmap_);\n\t}\n\telse if(affected_maps_ == \\\"local\\\") {\n\t\tclearCostmap(local_costmap_);\n\t}\n}", "CodeBleu_score": 24.958244770396263}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t", "CodeBleu_score": 5.034306355366355}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\n  // if the polygon is empty, there are no cells to return\n  if (polygon.empty())\n    return;\n\n  // get the first point in the polygon\n  MapLocation current_point = polygon[0];\n  unsigned int current_index = getIndex(current_point.x, current_point.y);\n\n  // iterate through the rest of the points in the polygon\n  for (unsigned int i = 1; i < polygon.size(); ++i)\n  {\n    // get the next point in the polygon\n    MapLocation next_point = polygon[i];\n    unsigned int next_index = getIndex(next_point.x, next_point.y);\n\n    // get the cells that are in between the current point and the next point\n    std::vector<MapLocation> cells = raytraceLine(current_point, next_point);\n\n    // add the cells to the output\n    polygon_cells.insert(polygon_cells.end(), cells.begin(), cells.end());\n\n    // update the current point\n    current_point = next_point;\n    current_index = next_index;\n  }\n\n  // if the polygon is not closed, connect the last point to the first\n  if (current_index != getIndex(polygon[0].x, polygon[0].y))\n  {\n    // get the cells that are in between the last point and the first point\n    std::vector<MapLocation> cells = raytraceLine(current_point, polygon[0]);\n\n    // add the cells to the output\n    polygon_cells.insert(polygon_cells.end(), cells.begin(), cells.end());\n  }\n}", "CodeBleu_score": 44.976401030507}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t// we assume the polygon is given in the global_frame... we need to transform it to map coordinates\n  std::vector<MapLocation> map_polygon;\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    MapLocation loc;\n    if (!worldToMap(polygon[i].x, polygon[i].y, loc.x, loc.y)) {\n      // (\\\"Polygon lies outside map bounds, so we can't fill it\\\");\n      return;\n    }\n    map_polygon.push_back(loc);\n  }\n\n  PolygonOutlineCells cells;\n  if (map_polygon.size() > 0) {\n    // add the first point\n    cells.add(map_polygon[0].x, map_polygon[0].y);\n    for (unsigned int i = 0; i < map_polygon.size() - 1; ++i) {\n      // add the cells between this point and the next one\n      raytraceLine(map_polygon[i].x, map_polygon[i].y, map_polygon[i + 1].x, map_polygon[i + 1].y, cells);\n    }\n    // close the polygon\n    raytraceLine(map_polygon[map_polygon.size() - 1].x, map_polygon[map_polygon.size() - 1].y, map_polygon[0].x, map_polygon[0].y, cells);\n  }\n\n  polygon_cells = cells.getCells();\n}", "CodeBleu_score": 54.38347045257539}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tif (!active_) {\n\t\tactive_ = true;\n\t\tprepareGrid();\n\t\tpublishGrid();\n\t}\n}", "CodeBleu_score": 50.29176133543739}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t//  ROS_DEBUG(\"New subscriber to costmap_2d\");\n\n  // prepare the grid\n  prepareGrid();\n\n  // publish the grid\n  publishGrid();\n}", "CodeBleu_score": 37.441300006476496}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_DEBUG(\"New subscriber to costmap_2d topic\");\n\tif (!active_) {\n\t\tactive_ = true;\n\t\tprepareGrid();\n\t\tpub.publish(grid_msg_);\n\t}\n}", "CodeBleu_score": 54.31094231093678}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// lock costmap\n\tboost::mutex::scoped_lock(costmap_->getMutex());\n\n\t// get resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// set grid header\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// set origin\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// resize grid data vector\n\txn_ = costmap_->getSizeInCellsX();\n\tyn_ = costmap_->getSizeInCellsY();\n\tgrid_.data.resize(xn_ * yn_);\n\n\t// populate grid data\n\tfor (int i = 0; i < yn_; i++) {\n\t\tfor (int j = 0; j < xn_; j++) {\n\t\t\tgrid_.data[i * xn_ + j] = cost_translation_table_[costmap_->getCost(j, i)];\n\t\t}\n\t}\n}", "CodeBleu_score": 61.293268426711855}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::mutex::scoped_lock lock(costmap_->getMutex());\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\txn_ = 0;\n\tyn_ = 0;\n\tx0_ = costmap_->getSizeInCellsX();\n\ty0_ = costmap_->getSizeInCellsY();\n\n\tif (xn_ != x0_ || yn_ != y0_) {\n\t\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t}\n\n\tfor (unsigned int i = 0; i < grid_.info.width * grid_.info.height; i++) {\n\t\tgrid_.data[i] = cost_translation_table_[costmap_->getCharMap()[i]];\n\t}\n}", "CodeBleu_score": 66.77466791670851}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::mutex::scoped_lock(costmap_->getMutex());\n\tdouble resolution = costmap_->getResolution();\n\tunsigned int width = costmap_->getSizeInCellsX();\n\tunsigned int height = costmap_->getSizeInCellsY();\n\tunsigned int size = width * height;\n\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = width;\n\tgrid_.info.height = height;\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\tif (xn_ != width || yn_ != height) {\n\t\txn_ = width;\n\t\tyn_ = height;\n\t\tgrid_.data.resize(xn_ * yn_);\n\t}\n\n\t// convert the map coordinates to world coordinates for the origin\n\tdouble ox = costmap_->getOriginX();\n\tdouble oy = costmap_->getOriginY();\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\tdouble dx = wx - ox;\n\tdouble dy = wy - oy;\n\n\t// set the origin's position and orientation\n\tgrid_.info.origin.position.x = dx;\n\tgrid_.info.origin.position.y = dy;\n\n\t// populate the grid data from the costmap's character map using a translation table\n\tunsigned char* charmap = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < size; i++) {\n\t\tgrid_.data[i] = cost_translation_table_[charmap[i]];\n\t}\n}", "CodeBleu_score": 64.02889827226494}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, return immediately.\n\tif (new_config.footprint_radius == old_config.footprint_radius &&\n\t\t\tnew_config.footprint == old_config.footprint) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, convert the string to a footprint and set it.\n\tif (!new_config.footprint.empty()) {\n\t\tfootprint_spec_.clear();\n\t\tfootprint_spec_.deserializeFromString(new_config.footprint);\n\t\tsetRobotFootprint(footprint_spec_);\n\t\treturn;\n\t}\n\n\t// If the footprint string is invalid, log an error.\n\tROS_ERROR(\"%s: The footprint parameter is invalid. Using the robot radius instead.\", name_.c_str());\n\n\t// If no valid footprint string is provided, set the footprint based on the robot radius.\n\tsetUnpaddedRobotFootprint(footprint_spec_);\n}", "CodeBleu_score": 45.75414522148355}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  if (footprint_initialized_ && new_config.footprint == old_config.footprint &&\n//      new_config.robot_radius == old_config.robot_radius) {\n//    return;\n//  }\n\n  if (footprint_initialized_ && new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (!costmap_2d::Costmap2D::deserializeFootprintFromMsg(new_config.footprint, footprint)) {\n      ROS_ERROR(\"Invalid footprint provided on the parameter server. Footprint ignored.\");\n    } else {\n      setRobotFootprint(footprint);\n    }\n  } else {\n    setRobotRadius(new_config.robot_radius);\n  }\n}", "CodeBleu_score": 53.93939539391921}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n//  if (new_config.footprint_spec != old_config.footprint_spec) {\n//    geometry_msgs::PolygonStamped footprint;\n//    if (footprint_from_string(new_config.footprint_spec, footprint)) {\n//      setRobotFootprint(footprint.polygon);\n//    } else {\n//      ROS_ERROR(\"Invalid footprint provided. Footprint must be a list of (x,y) tuples, separated by ' 's, with no spaces \"\n//                \"between tuples. For example: footprint: [[0.5, -0.5], [0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5]]\");\n//    }\n//  }\n//\n//  if (new_config.robot_radius != old_config.robot_radius) {\n//    setRobotRadius(new_config.robot_radius);\n//  }\n}", "CodeBleu_score": 4.80081231526899}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t//  if (getRobotPose(new_pose)) {\n    if (getRobotPose(new_pose)) {\n      // Only update the costmap if the robot has moved enough.\n      double dist = sqrt(pow(new_pose.x - old_pose.x, 2) + pow(new_pose.y - old_pose.y, 2));\n      if (dist >= transform_tolerance_) {\n        updateMap();\n      }\n    }\n    else {\n      ROS_WARN(\"Costmap2DROS: Robot pose not available for movement callback.  Cannot update costmap.\");\n      ros::shutdown();\n    }\n//  }\n//  else {\n//    ROS_WARN(\"Costmap2DROS: Robot pose not available for movement callback.  Cannot update costmap.\");\n//    ros::shutdown();\n//  }\n}", "CodeBleu_score": 44.97383019014949}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!initialized_) {\n\t\tROS_WARN(\"Costmap2DROS: Received movement event, but the costmap is not yet initialized. Ignoring event.\");\n\t\treturn;\n\t}\n\n\tif (!getRobotPose(new_pose_)) {\n\t\tROS_WARN(\"Costmap2DROS: Failed to get robot pose. Ignoring event.\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 48.00841163785265}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!initialized_) {\n\t\treturn;\n\t}\n\n\tgeometry_msgs::PoseStamped new_pose;\n\ttry {\n\t\tnew_pose = tf_.lookupTransform(global_frame_, robot_base_frame_, ros::Time(0));\n\t} catch (tf::TransformException &ex) {\n\t\tROS_WARN_THROTTLE(1.0, \"No transform from %s to %s.  Cannot update costmap.\", global_frame_.c_str(), robot_base_frame_.c_str());\n\t\treturn;\n\t}\n\n\t// check if the robot moved significantly\n\tif (new_pose.header.stamp != last_robot_pose_.header.stamp) {\n\t\tdouble dx = new_pose.pose.position.x - last_robot_pose_.pose.position.x;\n\t\tdouble dy = new_pose.pose.position.y - last_robot_pose_.pose.position.y;\n\t\tdouble dist = sqrt(dx * dx + dy * dy);\n\t\tdouble angle = atan2(dy, dx);\n\t\tdouble dtheta = angle - last_robot_pose_.pose.orientation.z;\n\t\tdtheta = fmod(dtheta + M_PI, 2.0 * M_PI) - M_PI;\n\t\tif (dist > transform_tolerance_ || fabs(dtheta) > transform_tolerance_) {\n\t\t\tlast_robot_pose_ = new_pose;\n\t\t\tcostmap_2d::Costmap2D::markCells(last_robot_pose_, footprint_padding_, costmap_, footprint_clearing_enabled_);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.61043293799817}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}, {"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}, {"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// if the observation_keep_time_ is zero, we don't need to purge anything\n\tif (observation_keep_time_ == 0)\n\t\treturn;\n\n\t// we'll iterate through the list in reverse order, so that we can remove observations without changing the list size\n\tlist<Observation>::iterator obs_it = observation_list_.end();\n\tfor (obs_it = observation_list_.begin(); obs_it != observation_list_.end(); ++obs_it) {\n\t\t// if the observation is too old, we can remove it\n\t\tif (ros::Time::now() - (*obs_it).timestamp_ > ros::Duration(observation_keep_time_)) {\n\t\t\tobservation_list_.erase(obs_it);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.17423208613877}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// if the observation_keep_time_ is zero, we don't need to do anything\n\tif (observation_keep_time_ == 0.0) {\n\t\treturn;\n\t}\n\n\t// if the observation_keep_time_ is non-zero, we need to iterate through the list and remove stale observations\n\tros::Time current_time = ros::Time::now();\n\tlist<Observation>::iterator obs_it = observation_list_.begin();\n\twhile (obs_it != observation_list_.end()) {\n\t\tif ((current_time - obs_it->time_received_).toSec() > observation_keep_time_) {\n\t\t\tobs_it = observation_list_.erase(obs_it);\n\t\t}\n\t\telse {\n\t\t\t++obs_it;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.89348034553275}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// if the observation keep time is zero, we don't need to do anything\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// get the iterator to the first observation in the list\n\tlist<Observation>::iterator obs_it = observation_list_.begin();\n\n\t// get the iterator to the last observation in the list\n\tlist<Observation>::iterator obs_it_end = observation_list_.end();\n\n\t// iterate through the list until we find a valid observation\n\twhile (obs_it != obs_it_end) {\n\t\t// get the observation\n\t\tObservation& obs = *obs_it;\n\n\t\t// if the observation is valid, we can stop looking\n\t\tif (current_time - obs.last_updated_ < observation_keep_time_) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// otherwise, we need to remove the observation from the list\n\t\tobs_it = observation_list_.erase(obs_it);\n\t\tobs_it_end = observation_list_.end();\n\t}\n}", "CodeBleu_score": 43.80034497672894}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n  if (start_index == end_index) return;\n  if (end_index < start_index) return;\n\n  // get the yaw angle at the start and end indices\n  double angle0 = tf2::getYaw(path[start_index].pose.orientation);\n  double angle1 = tf2::getYaw(path[end_index].pose.orientation);\n\n  // determine the shortest angular distance between the two angles\n  double diff = angles::shortest_angular_distance(angle0, angle1);\n\n  // compute the incremental change in angle for each pose\n  double incr = diff / (end_index - start_index + 1);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = angles::normalize_angle(tf2::getYaw(path[i].pose.orientation) + incr);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 62.949625019196006}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (end_index - start_index < 2) return;\n\tconst double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n\tconst double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\tconst double diff = angles::shortest_angular_distance(start_angle, end_angle);\n\tconst double step = diff / (end_index - start_index);\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tset_angle(&path[i], angles::normalize_angle(tf2::getYaw(path[i].pose.orientation) + step));\n\t}\n}", "CodeBleu_score": 57.743006841287794}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n//  if (end_index <= start_index) return;\n\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n  double angle_diff = angles::shortest_angular_distance(start_angle, end_angle);\n\n  if (fabs(angle_diff) < 0.001) return;\n\n  double angle_increment = angle_diff / (end_index - start_index);\n\n  for (int i = start_index + 1; i <= end_index; i++) {\n    double angle = start_angle + (i - start_index) * angle_increment;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 65.08298318349527}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make_plan request\");\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tif (!makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\tROS_ERROR(\"Failed to find a plan.\");\n\t\tresp.success = false;\n\t\treturn true;\n\t}\n\tresp.success = true;\n\treturn true;\n}", "CodeBleu_score": 37.84033871204729}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.status.status = resp.status.SUCCESS;\n\tif (!makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\tresp.status.status = resp.status.FAILURE;\n\t\treturn true;\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.41301372949676}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\n\tif (makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\tresp.status.status = resp.status.SUCCESS;\n\t\tROS_INFO(\"Found a plan to goal\");\n\t} else {\n\t\tresp.status.status = resp.status.FAILURE;\n\t\tROS_INFO(\"No plan found to goal\");\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.37932856863057}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tcmap_ = cmap;\n\tros::NodeHandle n;\n\tmake_plan_service_ = n.advertiseService(\\\"/make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n\tpose_sub_ = n.subscribe(\\\"/move_base_simple/goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 53.272361421996926}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\\\"~\\\" + name);\n\n\tcmap_ = cmap;\n\n\tmake_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n\n\tpose_sub_ = private_nh.subscribe(\\\"goal\\\", 10, &PlannerWithCostmap::poseCallback, this);\n\n}", "CodeBleu_score": 56.84465442568673}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t//    ROS_INFO(\"Initializing planner with name %s\", name.c_str());\n    cmap_ = cmap;\n    ros::NodeHandle n;\n    make_plan_service_ = n.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = n.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 71.29821707953326}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn false;\n\t}\n\n\t//check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n\t\treturn false;\n\n\t//calculate the map coordinates\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n\t//check if the map coordinates are within the costmap's size limits\n\tif (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY())\n\t\treturn false;\n\n\treturn true;\n}", "CodeBleu_score": 50.80710489663337}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn false;\n\t}\n\n\t//check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY())\n\t\treturn false;\n\n\t//calculate the map coordinates using the costmap's resolution and an offset\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n\t//check if the map coordinates are within the costmap's size limits\n\treturn mx >= 0 && my >= 0 && mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY();\n}", "CodeBleu_score": 47.767609094065236}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (!initialized_) {\nROS_ERROR(\n\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\nreturn false;\n}\n\n//check if the point is in the robot's footprint\nif (!costmap_->worldToMap(wx, wy, mx, my)) {\nROS_ERROR(\"The point (%f, %f) is not inside the robot's footprint\", wx, wy);\nreturn false;\n}\n\n//check if the point is in the costmap's bounds\nif (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\nROS_ERROR(\"The point (%f, %f) is outside the bounds of the costmap\", wx, wy);\nreturn false;\n}\n\nreturn true;\n}", "CodeBleu_score": 40.750666994763016}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses.push_back(path[i]);\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 79.73870799872496}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message object\n\tnav_msgs::Path gui_path;\n\n\t//set the frame ID\n\tgui_path.header.frame_id = frame_id_;\n\n\t//set the timestamp to be the current time\n\tgui_path.header.stamp = ros::Time::now();\n\n\t//append the waypoints to the path\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses.push_back(path[i]);\n\t}\n\n\t//publish the path\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 79.73870799872496}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_)  {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++)  {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 94.72540723710314}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\\\"move_base\\\", \\\"Received a goal_pose\\\");\n\tMoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 63.384858945795216}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\\\"move_base\\\", \\\"Received a goal_pose to execute\\\");\n\tMoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.header.frame_id = goal->header.frame_id;\n  action_goal.goal = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 61.65427983980525}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\\\"move_base\\\", \\\"Goal received: %s\\\", goal->header.frame_id.c_str());\n\t//create the action message\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t//set the header to the timestamp of the goal message\n\taction_goal.header = goal->header;\n\n\t//set the goal to the pose we received\n\taction_goal.goal.target_pose = *goal;\n\n\t//publish the goal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 56.89684417060913}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > limited_distance_ * limited_distance_) {\n\t\tROS_WARN(\\\"The robot has moved far enough to be considered safe.\\\");\n\t\tif (remove_limit_thread_ != NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 65.95500428593519}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\ngeometry_msgs::PoseStamped global_pose;\n    global_costmap_->getRobotPose(global_pose);\n    double x1 = global_pose.pose.position.x;\n    double y1 = global_pose.pose.position.y;\n\n    double x2 = speed_limit_pose_.pose.position.x;\n    double y2 = speed_limit_pose_.pose.position.y;\n\n    if(getSqDistance() > limited_distance_ * limited_distance_)\n    {\n      ROS_WARN(\\\"The robot has moved far enough to remove the speed limit.\\\");\n      if(remove_limit_thread_ != NULL)\n      {\n        remove_limit_thread_->join();\n        delete remove_limit_thread_;\n        remove_limit_thread_ = NULL;\n      }\n\n      remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n      distance_check_timer_.stop();\n    }\n  }", "CodeBleu_score": 55.727660236488944}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif(getSqDistance() > limited_distance_ * limited_distance_) {\n\t\tROS_WARN(\\\"The robot has moved more than the limited distance. Removing the speed limit.\\\");\n\t\tdistance_check_timer_.stop();\n\t\tif(remove_limit_thread_) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(&MoveSlowAndClear::removeLimit, this);\n\t}\n}", "CodeBleu_score": 68.09388188037799}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\\\"Received a new goal position to navigate to\\\");\n\tPoseStamped current_pose;\n\tcurrent_pose = getRobotPose();\n\tvector<PoseStamped> path;\n\tmakePlan(current_pose, goal, path);\n}", "CodeBleu_score": 44.11316986969932}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\n}", "CodeBleu_score": 9.627465531099475}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current robot pose from the costmap\n\tPoseStamped robot_pose = getRobotPose();\n\n\t// Generate a path from the current robot pose to the goal pose\n\tvector<PoseStamped> path;\n\tmakePlan(robot_pose, goal, path);\n}", "CodeBleu_score": 49.08506458805568}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_srv;\n\tparam_srv.request.param_id = param_set.param_id;\n\tparam_srv.request.value = param_set.value;\n\tparam_srv.request.param_type = param_set.param_type;\n\tthis->param_set_client_.call(param_srv);\n}", "CodeBleu_score": 60.14700558000001}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 62.826747042969785}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 62.826747042969785}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\n#ifdef DEBUG_PRINT\n    ROS_INFO(\\\"Server thread started.\\\");\n#endif\n\n    // \u7b49\u5f85\u8fde\u63a5\n    ROS_INFO(\\\"Waiting for connection...\\\");\n    this->server_socket_.listen(5);\n    this->server_socket_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n    this->server_socket_.set_option(boost::asio::socket_base::keep_alive(true));\n    this->server_socket_.set_option(boost::asio::socket_base::enable_connection_aborted(true));\n\n    // \u7b49\u5f85\u8fde\u63a5\n    boost::asio::ip::tcp::socket *client_socket = new boost::asio::ip::tcp::socket(this->io_service_);\n    this->server_socket_.accept(*client_socket);\n    ROS_INFO(\\\"Connection established.\\\");\n\n    // \u5faa\u73af\u5904\u7406\u8fde\u63a5\n    while (true) {\n        // \u63a5\u6536\u6570\u636e\n        std::string data;\n        boost::asio::read_until(*client_socket, boost::asio::dynamic_buffer(data), \\\"\\\n\\\");\n\n        // \u89e3\u7801\u6570\u636e\n        std::vector<std::string> decoded_data;\n        this->decode(data, decoded_data);\n\n        // \u5904\u7406\u6570\u636e\n        if (decoded_data.size() > 0) {\n            this->processData(decoded_data);\n        } else {\n            ROS_ERROR(\\\"Received empty data.\\\");\n        }\n    }\n}", "CodeBleu_score": 31.263207750398216}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t\tROS_INFO(\"serverFun\");\n\t// \u7b49\u5f85\u8fde\u63a5\n\twhile (true) {\n\t\t// ROS_INFO(\"serverFun1\");\n\t\t// \u7b49\u5f85\u8fde\u63a5\n\t\tint sock = accept(this->tcp_socket_, (struct sockaddr *) &this->server_addr_, &this->addrlen_);\n\t\tif (sock < 0) {\n\t\t\tROS_ERROR(\"serverFun: accept failed\");\n\t\t\treturn;\n\t\t}\n\t\t// ROS_INFO(\"serverFun2\");\n\t\t// \u63a5\u6536\u6570\u636e\n\t\tchar buffer[1024];\n\t\tint n = recv(sock, buffer, sizeof(buffer), 0);\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"serverFun: recv failed\");\n\t\t\tclose(sock);\n\t\t\treturn;\n\t\t}\n\t\t// ROS_INFO(\"serverFun3\");\n\t\t// \u89e3\u7801\u6570\u636e\n\t\t// ROS_INFO(\"serverFun4\");\n\t\t// \u53d1\u5e03\u6570\u636e\n\t\t// ROS_INFO(\"serverFun5\");\n\t\tclose(sock);\n\t}\n}", "CodeBleu_score": 33.0611256175285}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t// if (this->uav_basic_ != NULL) {\n\t//     this->uav_basic_->updateUAVCommand(uav_cmd);\n\t//     this->uav_basic_->uavCommandPub();\n\t// }\n\t// if (this->ugv_basic_ != NULL) {\n\t//     this->ugv_basic_->updateUGVCommand(uav_cmd);\n\t//     this->ugv_basic_->ugvCommandPub();\n\t// }\n\t// if (this->autonomous_landing_ != NULL) {\n\t//     this->autonomous_landing_->updateLandingCommand(uav_cmd);\n\t//     this->autonomous_landing_->landingCommandPub();\n\t// }\n\t// if (this->object_tracking_ != NULL) {\n\t//     this->object_tracking_->updateObjectTrackingCommand(uav_cmd);\n\t//     this->object_tracking_->objectTrackingCommandPub();\n\t// }\n\t// if (this->swarm_control_ != NULL && this->swarm_num_ != 0) {\n\t//     // \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n\t//     this->swarm_control_->updateAllUAVCommand(uav_cmd);\n\t//     // \u53d1\u5e03\u8bdd\u9898\n\t//     this->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n\t// }\n}", "CodeBleu_score": 2.714410252175482}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t#ifdef SIMULATION\n    // \u53d1\u5e03\u8bdd\u9898\n    if (this->swarm_control_ != NULL && this->swarm_num_ != 0) {\n        // \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->updateAllUAVCommand(uav_cmd);\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n    }\n#else\n    if (this->uav_basic_ != NULL) {\n        // \u53d1\u5e03\u8bdd\u9898\n        this->uav_basic_->uavCommandPub(uav_cmd);\n    }\n#endif\n}", "CodeBleu_score": 41.92652043815274}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->swarm_control_ != NULL && this->swarm_num_ != 0) {\n// \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\nthis->swarm_control_->updateAllUAVCommand(uav_cmd);\n// \u53d1\u5e03\u8bdd\u9898\nthis->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n}\n}", "CodeBleu_score": 27.641306590340903}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == ModeSelection::UseMode::USE_MODE_REBOOTNX) {\n\t\tROS_WARN(\\\"Received REBOOTNX ModeSwitch command\\\");\n\t\tsystem(\\\"sudo reboot\\\");\n\t}\n\telse if (mode_selection.use_mode == ModeSelection::UseMode::USE_MODE_EXITNX) {\n\t\tROS_WARN(\\\"Received EXITNX ModeSwitch command\\\");\n\t\tsystem(\\\"sudo poweroff\\\");\n\t}\n\telse if (mode_selection.use_mode == ModeSelection::UseMode::USE_MODE_CREATE) {\n\t\tROS_WARN(\\\"Received CREATE ModeSwitch command\\\");\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == ModeSelection::UseMode::USE_MODE_DELETE) {\n\t\tROS_WARN(\\\"Received DELETE ModeSwitch command\\\");\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 61.358918886487146}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t", "CodeBleu_score": 4.546652861136631}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t", "CodeBleu_score": 4.546652861136631}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create the filtering object\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.setResolution(0.01f);\n\toctree_compression.compress(0);\n\n\t// Get the compressed point cloud as a vector of bytes\n\tstd::vector<unsigned char> compressed_data = octree_compression.getData();\n\n\t// Convert the vector of bytes to a PointCloud2 message\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header.frame_id = msg.header.frame_id;\n\tcompressed_msg.height = 1;\n\tcompressed_msg.width = compressed_data.size() / sizeof(float);\n\tcompressed_msg.point_step = sizeof(float);\n\tcompressed_msg.row_step = compressed_msg.point_step * compressed_msg.width * compressed_msg.height;\n\tcompressed_msg.is_dense = false;\n\tcompressed_msg.data = std::vector<unsigned char>(compressed_data.begin(), compressed_data.end());\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 42.93222357400869}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\npcl::fromROSMsg(msg, *cloud);\n\n// \u521b\u5efa\u6ee4\u6ce2\u5668\u5bf9\u8c61\npcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\npcl::PassThrough<pcl::PointXYZ> pass;\npass.setInputCloud(cloud);\npass.setFilterFieldName(\"x\");  // \u6839\u636e\u9700\u8981\u9009\u62e9\u8fc7\u6ee4\u7684\u5b57\u6bb5\npass.setFilterLimits(-3 + uav_position_x , 3 + uav_position_x);  // \u8bbe\u7f6e\u8303\u56f4\npass.filter(*cloud_filtered);  // \u6267\u884c\u6ee4\u6ce2\u64cd\u4f5c\npass.setFilterFieldName(\"y\");  // \u6839\u636e\u9700\u8981\u9009\u62e9\u8fc7\u6ee4\u7684\u5b57\u6bb5\npass.setFilterLimits(-3 + uav_position_y , 3 + uav_position_y);  // \u8bbe\u7f6e\u8303\u56f4\npass.filter(*cloud_filtered);  // \u6267\u884c\u6ee4\u6ce2\u64cd\u4f5c\n\n// \u538b\u7f29\npcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\npcl::io::OctreePointCloudCompression<pcl::PointXYZ> compression;\ncompression.setInputCloud(cloud_filtered);\ncompression.setResolution(0.01f);\ncompression.compress(*cloud_compressed);\n\n// \u8f6c\u6362\u56de ROS \u70b9\u4e91\u6d88\u606f\nsensor_msgs::PointCloud2 compressed_msg;\npcl::toROSMsg(*cloud_compressed, compressed_msg);\ncompressed_msg.header = msg.header;\n\nreturn compressed_msg;\n}", "CodeBleu_score": 49.54939275891008}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); ++i) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 79.35602608296153}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); ++i) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 78.99116715478624}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\nint end_idx = q.cols() - order_;\ndouble a2 = 1.0 / pow(cps_.clearance, 2), b2 = 1.0 / pow(cps_.clearance, 2);\n\nfor (int i = order_; i < end_idx; i++) {\nEigen::Vector3d pos_err = cps_.points.col(i) - q.block(0, i, 3, 1);\nEigen::Vector3d vel_vec = cps_.velocity.col(i);\ndouble vel_err = vel_vec.norm();\nEigen::Vector3d vel_grad = vel_vec / vel_err;\n\nif (vel_err < 1e-6) {\ncost += a2 * pos_err.squaredNorm() + b2 * vel_err * vel_err;\ngradient.col(i) += -2.0 * a2 * pos_err + 2.0 * b2 * vel_err * vel_grad;\n} else {\nEigen::Vector3d pos_grad = -vel_vec / vel_err;\ncost += a2 * pos_err.dot(pos_grad) + b2 * vel_err * vel_err;\ngradient.col(i) += pos_grad.array() * (2.0 * a2 * pos_err.array() + 2.0 * b2 * vel_err * vel_grad.array()).matrix();\n}\n}\n}", "CodeBleu_score": 40.77463224344686}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tint end_idx = q.cols() - order_;\n\tdouble a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n\tfor (int i = order_; i < end_idx; i++) {\n\t\tEigen::Vector3d pos_err = cps_.points.col(i) - reference_points_.col(i);\n\t\tEigen::Vector3d vel = cps_.points.col(i + 1) - cps_.points.col(i);\n\t\tdouble dot_err = pos_err.dot(vel);\n\t\tdouble cross_err = pos_err.cross(vel).norm();\n\t\tdouble err = sqrt(dot_err * dot_err * inv_a2 + cross_err * cross_err * inv_b2);\n\t\tgradient.col(i) = -2.0 * (a * dot_err * inv_a2 + b * cross_err * inv_b2) * vel;\n\t\tcost += pow(err, 2);\n\t}\n}", "CodeBleu_score": 38.92143565172703}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tdouble jerk = 0.0;\n\nfor (int i = 0; i < getKnot().rows() - 3; ++i) {\nEigen::Vector3d p0 = evaluateDeBoorT(u_(i)), p1 = evaluateDeBoorT(u_(i + 1)), p2 = evaluateDeBoorT(u_(i + 2)), p3 = evaluateDeBoorT(u_(i + 3));\nEigen::Vector3d d0 = evaluateDeBoorT(u_(i + 1)) - evaluateDeBoorT(u_(i)), d1 = evaluateDeBoorT(u_(i + 2)) - evaluateDeBoorT(u_(i + 1)), d2 = evaluateDeBoorT(u_(i + 3)) - evaluateDeBoorT(u_(i + 2));\nEigen::Vector3d dd0 = evaluateDeBoorT(u_(i + 2)) - evaluateDeBoorT(u_(i + 1)) - evaluateDeBoorT(u_(i)) + evaluateDeBoorT(u_(i + 1)), dd1 = evaluateDeBoorT(u_(i + 3)) - evaluateDeBoorT(u_(i + 2)) - evaluateDeBoorT(u_(i + 1)) + evaluateDeBoorT(u_(i + 2));\n\njerk += (p0 - 3 * p1 + 3 * p2 - p3).squaredNorm() * (u_(i + 1) - u_(i)) + (d0 - 3 * d1 + 3 * d2).squaredNorm() * (u_(i + 2) - u_(i + 1)) + (dd0 - 3 * dd1).squaredNorm() * (u_(i + 3) - u_(i + 2));\n}\n\nreturn jerk;\n}", "CodeBleu_score": 39.93414082409053}, {"code": "double UniformBspline::getJerk(){\n\t", "CodeBleu_score": 1.1628100042452454}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0.0;\n\tdouble t_prev, t_curr, t_next;\n\tEigen::Vector3d p_prev, p_curr, p_next;\n\tEigen::Vector3d dp_prev, dp_curr, dp_next;\n\tEigen::Vector3d ddp_curr;\n\tfor (int i = 0; i < getKnot().rows() - 3; ++i) {\n\t\tt_prev = getKnot()(i);\n\t\tt_curr = getKnot()(i + 1);\n\t\tt_next = getKnot()(i + 2);\n\t\tp_prev = getControlPoint(i);\n\t\tp_curr = getControlPoint(i + 1);\n\t\tp_next = getControlPoint(i + 2);\n\t\tdp_prev = getDerivative(t_prev);\n\t\tdp_curr = getDerivative(t_curr);\n\t\tdp_next = getDerivative(t_next);\n\t\tddp_curr = getDerivative(t_curr, 2);\n\t\tjerk += pow(p_curr(0) - 2 * p_curr(0) + p_curr(0), 3) * (t_next - t_curr) + pow(p_curr(1) - 2 * p_curr(1) + p_curr(1), 3) * (t_next - t_curr) + pow(p_curr(2) - 2 * p_curr(2) + p_curr(2), 3) * (t_next - t_curr);\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 42.14654824422404}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d p;\n\tp(0) = (u-cx_)*depth/fx_;\n\tp(1) = (v-cy_)*depth/fy_;\n\tp(2) = depth;\n\tp(3) = 1.0;\n\treturn p;\n}", "CodeBleu_score": 58.61181267817146}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d p;\n\tp(0) = (u - cx_) * depth / fx_;\n\tp(1) = (v - cy_) * depth / fy_;\n\tp(2) = depth;\n\tp(3) = 1.0;\n\treturn p;\n}", "CodeBleu_score": 74.23140905047399}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\t// ROS_INFO(\\\"depth2Pos: u = %d, v = %d, depth = %f\\\", u, v, depth);\n\t// ROS_INFO(\\\"depth2Pos: cx_ = %f, cy_ = %f, fx_ = %f, fy_ = %f\\\", cx_, cy_, fx_, fy_);\n\t// ROS_INFO(\\\"depth2Pos: (u-cx_)/fx_ = %f\\\", (u-cx_)/fx_);\n\t// ROS_INFO(\\\"depth2Pos: (v-cy_)/fy_ = %f\\\", (v-cy_)/fy_);\n\tdouble x = (u-cx_)/fx_*depth;\n\tdouble y = (v-cy_)/fy_*depth;\n\tdouble z = depth;\n\treturn Eigen::Vector4d(x, y, z, 1.0);\n}", "CodeBleu_score": 35.07765140252085}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\nint drone_id = std::stoi(odom.child_frame_id.substr(4));\nrcvDroneOdomCallbackBase(odom, drone_id);\n} catch (const std::invalid_argument& ia) {\nROS_ERROR(\"invalid argument: %s\", ia.what());\n}\n}", "CodeBleu_score": 53.620539103937325}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id.substr(4));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: exception caught: %s\", e.what());\n\t}\n}", "CodeBleu_score": 55.69192259644553}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\nint drone_id = std::stoi(odom.child_frame_id.substr(5));\nrcvDroneOdomCallbackBase(odom, drone_id);\n} catch (std::invalid_argument const& ia) {\nROS_WARN(\"invalid argument: %s\", ia.what());\n} catch (std::out_of_range const& oor) {\nROS_WARN(\"out of range: %s\", oor.what());\n}\n}", "CodeBleu_score": 57.574437591093954}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// ROS_INFO(\"detect\");\n\tEigen::Vector4d true_pose_cam;\n\tif (checkTruePose(drone_id, true_pixel, true_pose_cam)) {\n\t\tEigen::Vector4d true_pose_world = cam2World(true_pose_cam);\n\t\tEigen::Vector4d true_pose_error = true_pose_world - drone_pose_world_[drone_id];\n\t\ttrue_pose_error_pub_[drone_id].publish(true_pose_error);\n\t\tif (debug_mode_) {\n\t\t\tstd::stringstream ss;\n\t\t\tss << \"true_pose_error: \" << true_pose_error.transpose();\n\t\t\tdebug_result_pub_[drone_id].publish(ss.str());\n\t\t}\n\t} else {\n\t\tif (debug_mode_) {\n\t\t\tdebug_result_pub_[drone_id].publish(\"no detection\");\n\t\t}\n\t}\n}", "CodeBleu_score": 42.16160666444303}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start_) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 75.61525628187657}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start_) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 78.19603049201824}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start_) {\n\t\tcurrent = cameFrom_[current->index];\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 67.63311520758879}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t", "CodeBleu_score": 2.802449016888383}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t", "CodeBleu_score": 2.802449016888383}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to grid index\n\tif (grid_map_->isInside(start_pt)) {\n\t\tstart_idx = grid_map_->World2Index(start_pt);\n\t} else {\n\t\tROS_WARN(\"Start point is inside an obstacle. Attempting to adjust...\");\n\t\tstart_idx = grid_map_->World2Index(start_pt + Vector3d(0.5, 0.5, 0.5));\n\t\tif (grid_map_->isInside(grid_map_->Index2World(start_idx))) {\n\t\t\tROS_WARN(\"Start point is inside an obstacle. Adjustment failed.\");\n\t\t\treturn false;\n\t\t}\n\t\tROS_WARN(\"Start point is inside an obstacle. Adjustment succeeded.\");\n\t}\n\n\t// Convert end point to grid index\n\tif (grid_map_->isInside(end_pt)) {\n\t\tend_idx = grid_map_->World2Index(end_pt);\n\t} else {\n\t\tROS_WARN(\"End point is inside an obstacle. Attempting to adjust...\");\n\t\tend_idx = grid_map_->World2Index(end_pt + Vector3d(0.5, 0.5, 0.5));\n\t\tif (grid_map_->isInside(grid_map_->Index2World(end_idx))) {\n\t\t\tROS_WARN(\"End point is inside an obstacle. Adjustment failed.\");\n\t\t\treturn false;\n\t\t}\n\t\tROS_WARN(\"End point is inside an obstacle. Adjustment succeeded.\");\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 31.769953547944908}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tmin_id << floor((min_pos(0) - mp_.map_origin_(0)) / mp_.resolution_), floor((min_pos(1) - mp_.map_origin_(1)) / mp_.resolution_), floor((min_pos(2) - mp_.map_origin_(2)) / mp_.resolution_);\n\tmax_id << floor((max_pos(0) - mp_.map_origin_(0)) / mp_.resolution_), floor((max_pos(1) - mp_.map_origin_(1)) / mp_.resolution_), floor((max_pos(2) - mp_.map_origin_(2)) / mp_.resolution_);\n\n\tif (min_id(0) < 0) min_id(0) = 0;\n\tif (min_id(1) < 0) min_id(1) = 0;\n\tif (min_id(2) < 0) min_id(2) = 0;\n\tif (max_id(0) >= mp_.map_voxel_num_(0)) max_id(0) = mp_.map_voxel_num_(0) - 1;\n\tif (max_id(1) >= mp_.map_voxel_num_(1)) max_id(1) = mp_.map_voxel_num_(1) - 1;\n\tif (max_id(2) >= mp_.map_voxel_num_(2)) max_id(2) = mp_.map_voxel_num_(2) - 1;\n\n\tfor (int x = min_id(0); x <= max_id(0); ++x) {\n\t\tfor (int y = min_id(1); y <= max_id(1); ++y) {\n\t\t\tfor (int z = min_id(2); z <= max_id(2); ++z) {\n\t\t\t\tint index = z * mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) + y * mp_.map_voxel_num_(0) + x;\n\t\t\t\tmd_.occupancy_buffer_inflate_[index] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 66.74069589109746}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = GridMap::getPositionIndexFromPosition(min_pos);\n\tEigen::Vector3i max_id = GridMap::getPositionIndexFromPosition(max_pos);\n\n\tfor (int i = min_id(0); i <= max_id(0); ++i) {\n\t\tfor (int j = min_id(1); j <= max_id(1); ++j) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); ++k) {\n\t\t\t\tint index = GridMap::getIndexFromPosition(i, j, k);\n\t\t\t\tmd_.occupancy_buffer_inflate_[index] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 49.903604120816894}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tmin_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n\tmax_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\tEigen::Vector3i index;\n\tfor (index[0] = min_id[0]; index[0] <= max_id[0]; index[0]++) {\n\t\tfor (index[1] = min_id[1]; index[1] <= max_id[1]; index[1]++) {\n\t\t\tfor (index[2] = min_id[2]; index[2] <= max_id[2]; index[2]++) {\n\t\t\t\tint index_int = getIndex(index);\n\t\t\t\tmd_.occupancy_buffer_inflate_[index_int] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.23440712058075}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_min = 0, y_min = 0, z_min = 0;\n\tdouble x_max = 0, y_max = 0, z_max = 0;\n\tif (diff(0) < 0) {\n\t\tx_min = 1;\n\t}\n\tif (diff(0) > 0) {\n\t\tx_max = 1;\n\t}\n\tif (diff(1) < 0) {\n\t\ty_min = 1;\n\t}\n\tif (diff(1) > 0) {\n\t\ty_max = 1;\n\t}\n\tif (diff(2) < 0) {\n\t\tz_min = 1;\n\t}\n\tif (diff(2) > 0) {\n\t\tz_max = 1;\n\t}\n\tdouble min_scale = 1e9, max_scale = -1e9;\n\tif (x_min == 1) {\n\t\tmin_scale = min(min_scale, diff(0) / mp_.resolution_);\n\t}\n\tif (x_max == 1) {\n\t\tmax_scale = max(max_scale, diff(0) / mp_.resolution_);\n\t}\n\tif (y_min == 1) {\n\t\tmin_scale = min(min_scale, diff(1) / mp_.resolution_);\n\t}\n\tif (y_max == 1) {\n\t\tmax_scale = max(max_scale, diff(1) / mp_.resolution_);\n\t}\n\tif (z_min == 1) {\n\t\tmin_scale = min(min_scale, diff(2) / mp_.resolution_);\n\t}\n\tif (z_max == 1) {\n\t\tmax_scale = max(max_scale, diff(2) / mp_.resolution_);\n\t}\n\tdouble scale = max(fabs(min_scale), fabs(max_scale));\n\tEigen::Vector3d pt_w = pt - diff / scale * mp_.resolution_;\n\treturn pt_w;\n}", "CodeBleu_score": 35.36450205902123}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d min_coeff, max_coeff;\n  min_coeff = max_coeff = Eigen::Vector3d::Zero();\n  double min_scale, max_scale;\n  for (int i = 0; i < 3; ++i)\n  {\n    if (diff(i) < 0)\n    {\n      min_coeff(i) = 1;\n      max_coeff(i) = -diff(i) / mp_.resolution_;\n    }\n    else\n    {\n      min_coeff(i) = -diff(i) / mp_.resolution_;\n      max_coeff(i) = 1;\n    }\n  }\n\n  min_scale = min_coeff.minCoeff();\n  max_scale = max_coeff.maxCoeff();\n\n  double scale = min(min_scale, max_scale);\n\n  return pt + scale * diff;\n}", "CodeBleu_score": 48.90812044300614}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat threshold_overlap = 0.8f;\n\t// float threshold = 0.95f;\n\n\tfloat fmeasure(0.f);\n\tunsigned int n_images = image_fns.size();\n\n\tfor (unsigned int i = 0; i < n_images; ++i) {\n\t\t// Load image\n\t\tMat3b img = imread(image_fns[i]);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error opening: \" << image_fns[i] << endl;\n\t\t\treturn 0.f;\n\t\t}\n\n\t\t// Load ground truth ellipses\n\t\tvector<Ellipse> ell_gt;\n\t\t_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\n\t\t// Load detected ellipses\n\t\tvector<Ellipse> ell_dt;\n\t\t_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n\t\t// Evaluate\n\t\tfmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\t}\n\n\treturn fmeasure / n_images;\n}", "CodeBleu_score": 61.12746751679159}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tunsigned n = image_fns.size();\n\n\tfloat f_sum = 0.f;\n\tfor (unsigned i = 0; i<n; ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> ell_gt;\n\t\tvector<Ellipse> ell_dt;\n\t\t_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n\t\tfloat f = _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\t\tf_sum += f;\n\t}\n\n\treturn f_sum / float(n);\n}", "CodeBleu_score": 56.819368945552675}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_sum = 0.0;\n\tfor (unsigned i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> ell_gt, ell_dt;\n\t\t_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\t\tfmeasure_sum += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\t}\n\treturn fmeasure_sum / float(image_fns.size());\n}", "CodeBleu_score": 69.55539550238548}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle;\n\tif (foci == NULL) {\n\t\tfprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\\\");\n\");\n\t\treturn 0.f;\n\t}\n\tangle = atan2(foci[1] - y, foci[0] - x);\n\tangle = angle_diff_signed(angle, atan2(foci[3] - y, foci[2] - x));\n\treturn angle;\n}", "CodeBleu_score": 32.444330736014415}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) fprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\");\n\tfloat angle_to_foci_1 = atan2(foci[1] - y, foci[0] - x);\n\tfloat angle_to_foci_2 = atan2(foci[3] - y, foci[2] - x);\n\tfloat normal_angle = angle_diff_signed(angle_to_foci_1, angle_to_foci_2);\n\twhile (normal_angle <= -M_PI) normal_angle += M_2__PI;\n\twhile (normal_angle >   M_PI) normal_angle -= M_2__PI;\n\treturn normal_angle;\n}", "CodeBleu_score": 53.253951355781126}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tif (foci == NULL) fprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\\\");\nif (foci[0] == foci[1] && foci[2] == foci[3]) fprintf(stderr, \"_ellipse_normal_angle: ellipse is a circle.\\\");\nfloat a1 = atan2(foci[0] - x, foci[1] - y);\nfloat a2 = atan2(foci[2] - x, foci[3] - y);\nfloat a = a1 - a2;\nwhile (a <= -M_PI) a += M_2__PI;\nwhile (a >   M_PI) a -= M_2__PI;\nreturn a;\n}", "CodeBleu_score": 46.394153874170826}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\nint integral_u(0), integral_d(0);\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nx_min = MIN(x_min, val.x);\nx_max = MAX(x_max, val.x);\ny_min = MIN(y_min, val.y);\ny_max = MAX(y_max, val.y);\n}\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nintegral_u += (val.y - y_min);\nintegral_d += (y_max - val.y);\n}\nif (integral_u > integral_d)\nreturn false;\nelse\nreturn true;\n}", "CodeBleu_score": 91.73184093893155}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u < integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 92.93345308179536}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\nint integral_u(0), integral_d(0);\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nx_min = MIN(x_min, val.x);\nx_max = MAX(x_max, val.x);\ny_min = MIN(y_min, val.y);\ny_max = MAX(y_max, val.y);\n}\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nintegral_u += (val.y - y_min);\nintegral_d += (y_max - val.y);\n}\nif (integral_u > integral_d)\nreturn false;\nelse\nreturn true;\n}", "CodeBleu_score": 91.73184093893155}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tint i;\n\tfor (i = 0; i < msg->detection_info_length; i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t}\n\t\telse {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tellipse_det = msg->detection_info[i];\n\t\t\tfloat temp_angle = ellipse_det.sight_angle;\n\t\t\tellipse_det.sight_angle = ellipse_det.yaw_angle;\n\t\t\tellipse_det.yaw_angle = temp_angle;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.74752097583533}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_info_size; i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tellipse_det = msg->detection_info[i];\n\t\t\tswap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n\t\t}\n\t}\n}", "CodeBleu_score": 59.45531184800027}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor(int i = 0; i < msg->detection_info_size; i++) {\n\t\tif(msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t}\n\t\telse {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t\tis_detected = false;\n\t\t}\n\t\tif(num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif(num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif(msg->detection_info[i].name == \"T\") {\n\t\t\tfloat temp = msg->detection_info[i].sight_angle;\n\t\t\tmsg->detection_info[i].sight_angle = msg->detection_info[i].sway_angle;\n\t\t\tmsg->detection_info[i].sway_angle = temp;\n\t\t}\n\t\tellipse_det = msg->detection_info[i];\n\t}\n}", "CodeBleu_score": 58.15469942280368}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// \u8ba1\u7b97\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u5728\u969c\u788d\u7269\u5185\n\tbool is_occupy = Occupy_map_ptr->isOccupy(cur_pos);\n\n\t// \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u5728\u969c\u788d\u7269\u5185\uff0c\u5219\u76f4\u63a5\u8fd4\u56defalse\n\tif (is_occupy) {\n\t\treturn false;\n\t}\n\n\t// \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u4e0d\u5728\u969c\u788d\u7269\u5185\uff0c\u5219\u68c0\u67e5\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u5728\u5b89\u5168\u8ddd\u79bb\u5185\n\t// \u8ba1\u7b97\u5f53\u524d\u4f4d\u7f6e\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n\tdouble distance = (cur_pos - goal_pos).norm();\n\n\t// \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u5c0f\u4e8e\u5b89\u5168\u8ddd\u79bb\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u4f4d\u7f6e\u662f\u5b89\u5168\u7684\n\tif (distance < safe_distance) {\n\t\treturn true;\n\t}\n\n\t// \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u5927\u4e8e\u5b89\u5168\u8ddd\u79bb\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u4f4d\u7f6e\u4e0d\u5b89\u5168\n\treturn false;\n}", "CodeBleu_score": 37.977979396517114}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\n}", "CodeBleu_score": 10.835833752087467}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (Occupy_map_ptr->checkOccupy(cur_pos, safe_distance)) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 39.21470617964126}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// \u9996\u5148\u5c06\u7ec8\u70b9\u52a0\u5165\u5230path_nodes_\u4e2d\n\tpath_nodes_.push_back(end_node);\n\t// \u7136\u540e\u4e00\u76f4\u6cbf\u7740\u7236\u8282\u70b9\u6307\u9488\u5f80\u56de\u8d70\uff0c\u76f4\u5230\u56de\u5230\u8d77\u70b9\n\twhile (end_node->parent != NULL) {\n\t\tend_node = end_node->parent;\n\t\tpath_nodes_.push_back(end_node);\n\t}\n\n\t// \u6700\u540e\u5c06path_nodes_\u4e2d\u7684\u8282\u70b9\u987a\u5e8f\u53cd\u8f6c\uff0c\u5373\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\u7684\u987a\u5e8f\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.536318072236064}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t// \u9996\u5148\u5224\u65ad\u662f\u5426\u627e\u5230\u8def\u5f84\uff0c\u5982\u679c\u6ca1\u627e\u5230\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\nif (end_node->parent == NULL) {\ncout << RED << \"Astar retrievePath: [ Astar can't find path: parent is NULL ]\"  << TAIL <<endl;\nreturn;\n}\n\n// \u627e\u5230\u4e86\u8def\u5f84\uff0c\u5219\u5c06\u7ec8\u70b9\u8bbe\u4e3a\u7ec8\u70b9\npath_nodes_.clear();\npath_nodes_.push_back(end_node);\n\n// \u5f00\u59cb\u56de\u6eaf\nNodePtr cur_node = end_node;\nwhile (cur_node->parent != NULL) {\ncur_node = cur_node->parent;\npath_nodes_.push_back(cur_node);\n}\n\n// \u53cd\u8f6c\u8def\u5f84\nreverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 78.87568160198137}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// \u5b58\u50a8\u8def\u5f84\u70b9\n\tpath_nodes_.clear();\n\n\t// \u5b58\u50a8\u8def\u5f84\u70b9\u7684\u6307\u9488\n\tNodePtr cur_node = end_node;\n\n\t// \u5faa\u73af\uff0c\u76f4\u5230\u5230\u8fbe\u8d77\u59cb\u70b9\n\twhile (cur_node != NULL)\n\t{\n\t\t// \u5b58\u50a8\u5f53\u524d\u8282\u70b9\n\t\tpath_nodes_.push_back(cur_node);\n\n\t\t// \u6307\u5411\u7236\u8282\u70b9\n\t\tcur_node = cur_node->parent;\n\t}\n\n\t// \u53cd\u8f6c\u8def\u5f84\u70b9\u7684\u987a\u5e8f\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 62.61878583043584}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n}", "CodeBleu_score": 3.2702242619030297}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n}", "CodeBleu_score": 3.2702242619030297}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t// cout << GREEN << \"nei_odom_cb\" << TAIL << endl;\n\t// cout << GREEN << \"id:\" << id << TAIL << endl;\n\t// cout << GREEN << \"odom:\" << odom->pose.pose.position.x << \" \" << odom->pose.pose.position.y << \" \" << odom->pose.pose.position.z << TAIL << endl;\n\n\tif(sim_mode)\n\t{\n\t\t// cout << GREEN << \"sim_mode\" << TAIL << endl;\n\t\tif(sqrt(pow(odom->pose.pose.position.x - start_pose.pose.position.x, 2) + pow(odom->pose.pose.position.y - start_pose.pose.position.y, 2)) > 5)\n\t\t{\n\t\t\t// cout << GREEN << \"get_nei_state:\" << id << \" false\" << TAIL << endl;\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// cout << GREEN << \"get_nei_state:\" << id << \" true\" << TAIL << endl;\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\n\tstate_nei[id] << odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z;\n}", "CodeBleu_score": 44.10169343280076}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 5.371612362555575}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n#ifdef DEBUG_TIME\n    static double last_time = 0.0;\n    double now = nh.now().toSec();\n    cout << \"GlobalPlannerUGV::Gpointcloud_cb, time: \" << now << endl;\n#endif\n\n    if (!odom_ready) {\n        return;\n    }\n\n    sensor_ready = true;\n    counter_search++;\n\n    if (counter_search > 5) {\n        Astar_ptr->Occupy_map_ptr->pointcloud_update(msg);\n        counter_search = 0;\n    }\n}", "CodeBleu_score": 66.76527716225287}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n#if 0\n    cout << \"GlobalPlannerUGV::Gpointcloud_cb\" << endl;\n#endif\n\n    if (!odom_ready) {\n        return;\n    }\n\n    if (update_counter == 0) {\n        Astar_ptr->Occupy_map_ptr->update_map(msg);\n    }\n    if (update_counter == 4) {\n        Astar_ptr->Occupy_map_ptr->update_map(msg);\n        update_counter = 0;\n    } else {\n        update_counter += 1;\n    }\n\n    sensor_ready = true;\n}", "CodeBleu_score": 64.6358134361718}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl)\n\t\treturn;\n\tget_gpcl = true;\n\n\t// \u5168\u5c40\u5730\u56fe\u70b9\u4e91\u6307\u9488\n\tglobal_point_cloud_map->header = global_point->header;\n\tglobal_point_cloud_map->height = global_point->height;\n\tglobal_point_cloud_map->width = global_point->width;\n\tglobal_point_cloud_map->is_dense = global_point->is_dense;\n\tglobal_point_cloud_map->is_bigendian = global_point->is_bigendian;\n\tglobal_point_cloud_map->point_step = global_point->point_step;\n\tglobal_point_cloud_map->row_step = global_point->row_step;\n\tglobal_point_cloud_map->data = global_point->data;\n\tglobal_point_cloud_map->fields = global_point->fields;\n\n\t// \u5168\u5c40\u5730\u56fe\u70b9\u4e91\u5b58\u50a8\n\tpcl::fromROSMsg(*global_point, *global_point_cloud_map);\n\n\t// \u5168\u5c40\u5730\u56fe\u70b9\u4e91\u81a8\u80c0\n\tinflate_pointcloud(global_point_cloud_map, cloud_inflate_vis_);\n\t// \u5168\u5c40\u5730\u56fe\u70b9\u4e91\u53d1\u5e03\n\tglobal_inflate_pcl_pub.publish(cloud_inflate_vis_);\n}", "CodeBleu_score": 49.2618589235107}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *pcl_ptr);\n\t\t// \u81a8\u80c0\u5168\u5c40\u70b9\u4e91\n\t\tcloud_inflate(pcl_ptr, cloud_inflate_vis_);\n\t\t// \u5b58\u50a8\u5168\u5c40\u70b9\u4e91\n\t\tpcl::toROSMsg(*cloud_inflate_vis_, global_point_cloud_map_msg);\n\t\tglobal_point_cloud_map_msg.header.frame_id = \\\"map\\\";\n\t\tglobal_point_cloud_map_msg.header.stamp = ros::Time::now();\n\t\tglobal_point_cloud_map_pub.publish(global_point_cloud_map_msg);\n\t}\n}", "CodeBleu_score": 51.84319611344694}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tlaser_cloud->header.frame_id = local_point->header.frame_id;\n\tlaser_cloud->header.stamp = local_point->header.stamp;\n\tlaser_cloud->height = 1;\n\tlaser_cloud->width = local_point->ranges.size();\n\tlaser_cloud->is_dense = false;\n\tfor(int i=0; i<local_point->ranges.size(); i++) {\n\t\tpcl::PointXYZ point;\n\t\tpoint.x = local_point->ranges[i]*cos(local_point->angle_min+i*local_point->angle_increment);\n\t\tpoint.y = local_point->ranges[i]*sin(local_point->angle_min+i*local_point->angle_increment);\n\t\tpoint.z = 0;\n\t\tlaser_cloud->points.push_back(point);\n\t}\n\tmap_update_lpcl(laser_cloud, odom);\n}", "CodeBleu_score": 39.30161536860346}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n// \u53d1\u5e03\u5168\u5c40\u70b9\u4e91\n    pcl::toROSMsg(*global_point_cloud_map, global_pcl_msg_);\n    global_pcl_msg_.header.frame_id = \"world\";\n    global_pcl_pub_.publish(global_pcl_msg_);\n\n// \u53d1\u5e03\u81a8\u80c0\u540e\u7684\u70b9\u4e91\n    pcl::toROSMsg(*cloud_inflate_vis_, inflate_pcl_msg_);\n    inflate_pcl_msg_.header.frame_id = \"world\";\n    inflate_pcl_pub_.publish(inflate_pcl_msg_);\n}", "CodeBleu_score": 55.595724220187556}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5927\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n\tif (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n\t\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t}\n}", "CodeBleu_score": 78.7040738011076}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odom_ready) {\nreturn;\n}\nsensor_ready = true;\n\n// \u56e0\u4e3a\u5168\u5c40\u70b9\u4e91\u4e00\u822c\u8f83\u5927\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\nif (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\nAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n}\n}", "CodeBleu_score": 80.3253332334329}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5168\u5c40\u70b9\u4e91\u4e00\u822c\u8f83\u5927\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n\tif (!Astar_ptr->Occupy_map_ptr->get_gpcl) {\n\t\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t}\n}", "CodeBleu_score": 78.7040738011076}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif(publish_foot_contacts_ && !in_gazebo_) {\nchamp_msgs::ContactsStamped contacts_msg;\n\ncontacts_msg.header.stamp = ros::Time::now();\ncontacts_msg.header.frame_id = \\\"/world\\\";\n\nfor(int i = 0; i < 4; i++) {\ncontacts_msg.contacts.push_back(champ_msgs::Contact());\ncontacts_msg.contacts[i].name = joint_names_[i * 3 + 2];\ncontacts_msg.contacts[i].contact = foot_contacts[i];\n}\n\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 66.5548949256592}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (publish_foot_contacts_ && !in_gazebo_) {\nchamp_msgs::ContactsStamped contacts_msg;\n\nfor (size_t i = 0; i < 4; ++i) {\ncontacts_msg.contacts.push_back(champ_msgs::Contact());\ncontacts_msg.contacts[i].name = joint_names_[i];\ncontacts_msg.contacts[i].contact = foot_contacts[i];\n}\n\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 58.65993925286297}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (publish_foot_contacts_ && !in_gazebo_) {\nchamp_msgs::ContactsStamped contacts_msg;\n\ncontacts_msg.header.stamp = ros::Time::now();\ncontacts_msg.header.frame_id = \\\"world\\\";\n\nfor (int leg_idx = 0; leg_idx < 4; leg_idx++) {\nchamp_msgs::Contact contact;\ncontact.foot_index = leg_idx;\ncontact.phase = (int)base_.getGaitPhase(leg_idx);\ncontact.contact = foot_contacts[leg_idx];\ncontacts_msg.contacts.push_back(contact);\n}\n\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 55.76823380242257}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tif (joints.name.size() != 12) {\n\t\trospy.logerr('JointsCalibratorRelay: Invalid joint command. Expected 12 joints, got %d', joints.name.size())\n\t\treturn\n\t}\n\n\tmsg = Joints()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.header.frame_id = 'base_link'\n\n\tfor i in range(0, 12) {\n\t\tmsg.position.append(joints.position[i])\n\t}\n\n\tself.joint_minimal_pub.publish(msg)\n\n\tmsg = JointTrajectory()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.joint_names = self.joint_names\n\tmsg.points.append(JointTrajectoryPoint())\n\tmsg.points[0].positions = msg.points[0].velocities = msg.points[0].accelerations = msg.points[0].effort = []\n\tfor i in range(0, 12) {\n\t\tmsg.points[0].positions.append(joints.position[i])\n\t}\n\tmsg.points[0].time_from_start = rospy.Duration(rospy.get_param('champ_controller/calibration_duration', 10.0))\n\n\tself.joint_trajectory_pub.publish(msg)\n}", "CodeBleu_score": 49.87783488656861}, {"code": "def joints_cmd_callback(self, joints){\n\t\n/*\n * First, construct a minimal joints message.\n */\nJoints minimal_joints;\nminimal_joints.header.stamp = rospy.Time.now();\nminimal_joints.header.frame_id = \\\"base_link\\\";\nminimal_joints.joint_names = self.joint_names;\n\nfor (int i = 0; i < 4; i++) {\nminimal_joints.position.append(joints.position[self.joint_names.index(self.joint_names[i])]);\n}\n\n/*\n * Then, publish the minimal joints message.\n */\nself.joint_minimal_pub.publish(minimal_joints);\n\n/*\n * Finally, construct a joint trajectory message.\n */\nJointTrajectory trajectory;\ntrajectory.header.stamp = rospy.Time.now();\ntrajectory.joint_names = self.joint_names;\n\nJointTrajectoryPoint point;\npoint.positions = minimal_joints.position;\npoint.time_from_start = rospy.Duration(1.0);\n\ntrajectory.points.append(point);\n\n/*\n * Publish the joint trajectory message.\n */\nself.joint_trajectory_pub.publish(trajectory);\n}", "CodeBleu_score": 49.915182206416254}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a minimal joints message with the first 12 joint positions\n\tjoints_msg = Joints()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tfor i in range(12):\n\t\tjoints_msg.position.append(joints.position[i])\n\n\t# Publish the minimal joints message\n\tself.joint_minimal_pub.publish(joints_msg)\n\n\t# Create a joint trajectory message with the same positions and a specified duration\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.joint_names = self.joint_names\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = joints_msg.position\n\tpoint.time_from_start = rospy.Duration.from_sec(0.5)\n\ttraj_msg.points.append(point)\n\n\t# Publish the joint trajectory message\n\tself.joint_trajectory_pub.publish(traj_msg)\n}", "CodeBleu_score": 58.67111621089825}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\n\t\tstd::vector<std::string> collision1_split;\n\t\tboost::split(collision1_split, collision1, boost::is_any_of(\"::\"));\n\t\tstd::vector<std::string> collision2_split;\n\t\tboost::split(collision2_split, collision2, boost::is_any_of(\"::\"));\n\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (collision1_split[1] == foot_links_[j] || collision2_split[1] == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 63.85107341533054}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t", "CodeBleu_score": 1.3983365370963055}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\t\tstd::vector<std::string> collision_split1, collision_split2;\n\t\tboost::split(collision_split1, collision1, boost::is_any_of(\"::\"));\n\t\tboost::split(collision_split2, collision2, boost::is_any_of(\"::\"));\n\t\tif (collision_split1.size() > 0 && collision_split2.size() > 0) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (collision_split1[collision_split1.size() - 1] == foot_links_[j]) {\n\t\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t\t}\n\t\t\t\tif (collision_split2[collision_split2.size() - 1] == foot_links_[j]) {\n\t\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 63.96797574235842}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t assert(acceleration);\n  assert(initialized_params_);\n  assert(controller_active_);\n\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  ComputePositionAndVelocityErrors(command_trajectory_, &position_error, &velocity_error);\n\n  // Calculate the desired acceleration.\n  *acceleration = -controller_parameters_.position_gain_ * position_error\n      - controller_parameters_.velocity_gain_ * velocity_error\n      - controller_parameters_.gravity_ - command_trajectory_.acceleration_ff_;\n  *acceleration /= vehicle_parameters_.mass_;\n}", "CodeBleu_score": 43.080156217038066}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n  assert(controller_active_);\n  assert(command_trajectory_.position_ns.size() == command_trajectory_.velocity_ns.size());\n\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  ComputePositionAndVelocityErrors(&position_error, &velocity_error);\n\n  // Calculate the desired acceleration.\n  *acceleration = -vehicle_parameters_.mass_ * vehicle_parameters_.gravity_ * odometry_.orientation.inverse().toRotationMatrix().col(2) -\n      normalized_attitude_gain_ * position_error - normalized_angular_rate_gain_ * velocity_error;\n}", "CodeBleu_score": 42.326141474891045}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t", "CodeBleu_score": 5.185615338987256}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 3.965771277166072}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  std::cout << \"desired_angular_acceleration_: \" << desired_angular_acceleration_.transpose() << std::endl;\n  // Check if input is valid.\n  if (!initialized_params_) {\n    std::cout << \"Parameters not initialized!\" << std::endl;\n    return;\n  }\n  if (!rotor_velocities) {\n    std::cout << \"Rotor velocities not initialized!\" << std::endl;\n    return;\n  }\n\n  // Resize rotor_velocities vector to match the number of rotors.\n  rotor_velocities->resize(amount_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      gain_attitude_ * (desired_angular_acceleration_ - angular_rate_bias_);\n\n  // Calculate the rotor velocities.\n  Eigen::Vector4d rotor_velocities_4d =\n      angular_acc_to_rotor_velocities_ * desired_angular_acceleration;\n  for (int i = 0; i < amount_rotors_; ++i) {\n    if (rotor_velocities_4d(i) < 0) {\n      rotor_velocities_4d(i) = 0;\n    }\n    rotor_velocities->coeffRef(i) = sqrt(rotor_velocities_4d(i));\n  }\n}", "CodeBleu_score": 38.1320177472951}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n//  std::cout << \"CalculateRotorVelocities()\" << std::endl;\n  CHECK(initialized_params_) << \"Parameters not initialized!\";\n  CHECK_NOTNULL(rotor_velocities);\n  CHECK_GT(amount_rotors_, 0);\n  CHECK_EQ(rotor_velocities->size(), 0);\n\n  // ensure the input is valid\n  CHECK_GE((*rotor_velocities).minCoeff(), 0.0);\n  CHECK_LE((*rotor_velocities).maxCoeff(), 1.0);\n\n  rotor_velocities->resize(amount_rotors_);\n\n  // calculate the desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  CalculateAngularAcceleration(&angular_acceleration);\n\n  // calculate the thrust reference\n  Eigen::VectorXd thrust_reference;\n  CalculateThrustReference(&thrust_reference);\n\n  // calculate the desired rotor velocities\n  (*rotor_velocities) = angular_acc_to_rotor_velocities_ *\n      (angular_acceleration - thrust_reference);\n\n  // ensure the rotor velocities are at least one\n  (*rotor_velocities) = (*rotor_velocities).cwiseMax(1.0);\n\n  // take the square root of the rotor velocities\n  (*rotor_velocities) = (*rotor_velocities).cwiseSqrt();\n}", "CodeBleu_score": 55.86823007114856}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices for the start and end times\n    start_index = numpy.argmax(self.bag_time >= start_time)\n    end_index = numpy.argmax(self.bag_time >= end_time)\n\n    # Copy the object\n    new_object = copy.deepcopy(self)\n\n    # Slice the object's attributes\n    new_object.time = self.time[start_index:end_index]\n    new_object.bag_time = self.bag_time[start_index:end_index]\n\n    return new_object\n\n", "CodeBleu_score": 25.280032710620297}, {"code": "def slice(self, start_time, end_time)\n\t\n    # find the indices of the start and end times\n    start_index = numpy.argmin(numpy.abs(self.bag_time - start_time))\n    end_index = numpy.argmin(numpy.abs(self.bag_time - end_time))\n    # make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n    # update each attribute of the copied object to contain only the sliced data\n    for attr in sliced_object.__dict__.keys():\n        if attr != \"bag_time\" and attr != \"time\":\n            sliced_object.__dict__[attr] = self.__dict__[attr][start_index:end_index]\n    return sliced_object\n\n", "CodeBleu_score": 34.77494068694905}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = numpy.where(self.bag_time >= start_time)[0][0]\n    end_index = numpy.where(self.bag_time <= end_time)[0][-1]\n    copy_of_object = copy.deepcopy(self)\n    for attribute in copy_of_object.__dict__.keys():\n        if isinstance(copy_of_object.__dict__[attribute], numpy.ndarray):\n            copy_of_object.__dict__[attribute] = copy_of_object.__dict__[attribute][start_index:end_index]\n        elif isinstance(copy_of_object.__dict__[attribute], list):\n            copy_of_object.__dict__[attribute] = copy_of_object.__dict__[attribute][start_index:end_index]\n    return copy_of_object\n\n", "CodeBleu_score": 31.74141309021985}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    point_msg = Point()\n    point_msg.x = waypoint_msg.pose.position.x\n    point_msg.y = waypoint_msg.pose.position.y\n    point_msg.z = waypoint_msg.pose.position.z\n    quat_msg = waypoint_msg.pose.orientation\n    quat_obj = QuatWithTime()\n    quat_obj.append_quaternion(quat_msg)\n    quat_obj.append_times(msg_time, bag_time)\n    euler_angles = tf.transformations.euler_from_quaternion(\\\n        [quat_obj.w[-1], quat_obj.x[-1], quat_obj.y[-1], quat_obj.z[-1]])\n    yaw = euler_angles[2]\n    if self.empty:\n        self.append_point(point_msg)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.empty = False\n    else:\n        if (point_msg.x != self.x[-1]) or (point_msg.y != self.y[-1]) or (point_msg.z != self.z[-1]) or (yaw != self.yaw[-1]):\n            self.append_point(point_msg)\n            self.yaw = numpy.append(self.yaw, yaw)\n\n", "CodeBleu_score": 32.77316943979955}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.append_times(msg_time, bag_time)\n    self.append_point(waypoint_msg.pose.pose.position)\n    quaternion = (waypoint_msg.pose.pose.orientation.x,\\\n                  waypoint_msg.pose.pose.orientation.y,\\\n                  waypoint_msg.pose.pose.orientation.z,\\\n                  waypoint_msg.pose.pose.orientation.w)\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    self.yaw = numpy.append(self.yaw, euler[2])\n    if not self.empty:\n        if not (self.x[-1] == waypoint_msg.pose.pose.position.x and\\\n                self.y[-1] == waypoint_msg.pose.pose.position.y and\\\n                self.yaw[-1] == euler[2]):\n            self.append_point(waypoint_msg.pose.pose.position)\n            self.yaw = numpy.append(self.yaw, euler[2])\n    else:\n        self.append_point(waypoint_msg.pose.pose.position)\n        self.yaw = numpy.append(self.yaw, euler[2])\n        self.empty = False\n\n", "CodeBleu_score": 22.672428685417735}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.append_point(waypoint_msg.pose.position)\n    quat = [waypoint_msg.pose.orientation.w, waypoint_msg.pose.orientation.x,\n            waypoint_msg.pose.orientation.y, waypoint_msg.pose.orientation.z]\n    (r, p, y) = tf.transformations.euler_from_quaternion(quat)\n    self.append_array([r, p, y])\n    if not self.empty:\n        if self.x[-1] != waypoint_msg.pose.position.x or self.y[-1] != waypoint_msg.pose.position.y or self.yaw[-1] != y:\n            self.append_times(msg_time, bag_time)\n            self.empty = False\n    else:\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 27.987422099862734}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic != imu_topic:\n            continue\n        elif \"Imu\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n        else:\n            print(\"Got unknown type: %s\" % type(msg))\n\n", "CodeBleu_score": 49.27099382926464}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic != imu_topic:\n            continue\n        else:\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 47.47517613947819}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic != imu_topic:\n            continue\n        elif \"Imu\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n        elif \"ImuStamped\" in str(type(msg)):\n            self.acc[index].append_point(msg.imu.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n        else:\n            print(\"Got unknown type: %s\" % type(msg))\n\n", "CodeBleu_score": 49.21320979247294}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                     box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n\n    if self.save_plots:\n        file_name = self.prefix + '_accelerations' if self.prefix else 'accelerations'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 71.54066285507355}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 76.10394649434275}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                     box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 70.30305820795944}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: Not enough pose indices to compare.\")\n        return\n    for index in pose_indeces:\n        if index > len(self.pos):\n            print(\"Error: Pose index out of range.\")\n            return\n    for index in range(len(pose_indeces) - 1):\n        compare_two_xyz(self, pose_indeces[index], pose_indeces[index + 1])\n\n", "CodeBleu_score": 42.96558170309945}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for index, pose_index in enumerate(pose_indeces):\n        for index2, pose_index2 in enumerate(pose_indeces[index+1:]):\n            self.compare_two_xyz(pose_index, pose_index2)\n\n", "CodeBleu_score": 33.707105520566245}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for index in pose_indeces:\n        for index2 in pose_indeces[index:]:\n            self.compare_two_xyz(index, index2)\n\n", "CodeBleu_score": 12.561736952458824}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time and end_time:\n            if start_time < collision.time < end_time:\n                collision_times.append(collision.time)\n        elif start_time:\n            if start_time < collision.time:\n                collision_times.append(collision.time)\n        elif end_time:\n            if collision.time < end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 41.32039934523526}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        if start_time and wrench.time < start_time:\n            continue\n        if end_time and wrench.time > end_time:\n            continue\n        if wrench.collision:\n            collision_times.append(wrench.time)\n    return collision_times\n", "CodeBleu_score": 42.60445696342152}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time and end_time:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n", "CodeBleu_score": 41.37554119670644}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n", "CodeBleu_score": 75.42305683412431}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 75.42305683412431}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 75.42305683412431}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t if (data == NULL) {\n   return;\n }\n\n const float multiplier = GetMultiplier(width, height);\n Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n const float rms_noise = GetRMSNoise(multiplier);\n const float noise = GetNoise(rms_noise, multiplier);\n for (uint32_t i = 0; i < width * height; i++) {\n   if (InRange(depth_data[i])) {\n     depth_data[i] += noise;\n   } else {\n     depth_data[i] = bad_point_value_;\n   }\n }\n}", "CodeBleu_score": 44.681880072178295}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t if (!data) {\n   return;\n }\n\n // Calculate the multiplier based on camera parameters.\n const float multiplier =\n     (this->max_depth - this->min_depth) / static_cast<float>(this->max_range);\n\n // Map the data to an Eigen vector.\n Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> depth_map(data, width * height);\n\n // Compute the RMS noise.\n const float rms_noise =\n     this->rms_noise_ * sqrt(static_cast<float>(width * height) / this->max_range);\n\n // Compute the noise values.\n const float min_noise = -rms_noise;\n const float max_noise = rms_noise;\n const float noise_range = max_noise - min_noise;\n\n // Add noise to the depth values.\n for (uint32_t i = 0; i < width * height; ++i) {\n   if (InRange(depth_map[i])) {\n     const float noise = min_noise + noise_range * this->rng_.Uniform(0.0, 1.0);\n     depth_map[i] += noise;\n   } else {\n     depth_map[i] = this->bad_point_value_;\n   }\n }\n}", "CodeBleu_score": 49.25583663328876}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t if (data == nullptr) {\n   return;\n }\n // Calculate the multiplier.\n const float multiplier =\n     this->depth_scale * this->noise_density / this->noise_scale;\n // Map the data to an Eigen vector.\n Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> depth_data(data, width * height);\n // Compute the RMS noise.\n const float rms_noise =\n     std::sqrt(multiplier * multiplier * this->noise_scale * this->noise_scale);\n // Compute the noise values.\n const float noise_min = -rms_noise;\n const float noise_max = rms_noise;\n // Add noise to the data.\n for (uint32_t i = 0; i < width * height; ++i) {\n   if (InRange(depth_data[i])) {\n     depth_data[i] += noise_min + (noise_max - noise_min) * this->noise_generator();\n   } else {\n     depth_data[i] = kBadPoint;\n   }\n }\n}", "CodeBleu_score": 55.88865318839764}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\tcommon::Time now = world_->SimTime();\nros::Time ros_now = ros::Time(now.sec, now.nsec);\nwriteBag(namespace_ + \\\"/\\\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 68.52021361072664}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\tcommon::Time now = world_->SimTime();\nros::Time ros_now = ros::Time(now.sec, now.nsec);\nwriteBag(namespace_ + \\\"/\\\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 68.52021361072664}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\tcommon::Time now = world_->SimTime();\nros::Time ros_now = ros::Time(now.sec, now.nsec);\nwriteBag(namespace_ + \\\"/\\\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 68.52021361072664}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n  if (!is_recording_) return;\n\n  // Convert the simulation time to a ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities.\n  mav_msgs::Actuators actuators_msg;\n  actuators_msg.header.stamp = ros_now;\n\n  // Iterate through the motor joints.\n  for (int i = 0; i < num_motors_; ++i) {\n    // Get the motor joint.\n    physics::JointPtr joint = GetMotorJoint(i);\n    if (joint == NULL) {\n      ROS_ERROR(\\\"Could not find joint %s\\\", motor_names_[i].c_str());\n      continue;\n    }\n\n    // Get the joint velocity.\n    double joint_vel = joint->GetVelocity(0);\n\n    // Get the joint position.\n    double joint_pos = joint->GetAngle(0).Radian();\n\n    // Get the motor direction.\n    double direction = motor_directions_[i];\n\n    // Get the motor velocity.\n    double motor_vel = direction * joint_vel;\n\n    // Add the motor velocity to the message.\n    actuators_msg.angular_velocities.push_back(motor_vel);\n    actuators_msg.angular_velocities_integrated.push_back(joint_pos);\n  }\n\n  // Write the message to the bag file.\n  writeBag(namespace_ + \\\"/\\\" + control_motor_speed_topic_, ros_now, &actuators_msg);\n}", "CodeBleu_score": 48.51730042373946}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n  if (is_recording_) {\n    // Convert the simulation time to ROS time.\n    ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n    // Prepare a message for actuator velocities.\n    mav_msgs::Actuators actuator_msg;\n    actuator_msg.header.stamp = ros_now;\n    actuator_msg.header.frame_id = \\\"world\\\";\n\n    // Iterate through the motor joints, calculate the slowed-down rotational velocities,\n    // and assign them to the message.\n    for (int i = 0; i < num_motors_; ++i) {\n      double rotational_velocity_rad_s =\n          joints_[i]->GetVelocity(0) / kMotorSpeedReduction;\n      actuator_msg.angular_velocities.push_back(rotational_velocity_rad_s);\n    }\n\n    // Write the message to the bag file.\n    writeBag(namespace_ + \\\"/\\\" + control_motor_speed_topic_, ros_now, &actuator_msg);\n  }\n}", "CodeBleu_score": 44.433769484298146}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\nif (!is_recording_) return;\n\nros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n// Prepare a message for actuator velocities.\nmav_msgs::Actuators actuators_msg;\nactuators_msg.header.stamp = ros_now;\nactuators_msg.header.frame_id = \\\"world\\\";\n\n// Iterate through the motor joints, calculate the slowed-down rotational\n// velocities, and assign them to the message.\nfor (int i = 0; i < num_motors_; ++i) {\n\n// Get the rotational velocity of the i-th motor.\ndouble rotational_velocity = joints_[i]->GetVelocity(0);\n\n// Slow down the rotational velocity.\ndouble slowed_down_rotational_velocity = rotational_velocity *\nslow_down_factor_;\n\n// Assign the slowed-down rotational velocity to the message.\nactuators_msg.angular_velocities.push_back(slowed_down_rotational_velocity);\n}\n\n\n// Write the message to a bag file.\nwriteBag(namespace_ + \\\"/\\\" + control_motor_speed_topic_, ros_now,\n&actuators_msg);\n}", "CodeBleu_score": 46.23743824200712}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\n}", "CodeBleu_score": 2.749413920229789}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (kPrintOnMsgCallback) {\ngzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n}\n\ndelta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\ndelta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\ndelta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\ndelta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\nthrottle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 60.96482860592405}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (kPrintOnMsgCallback) {\ngzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n}\n\ndelta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\ndelta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\ndelta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\ndelta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\nroll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\nthrottle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 60.96482860592405}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n}", "CodeBleu_score": 1.4726803394282788}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifndef __APPLE__\n  struct timeval timeout;\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _timeoutMs * 1000;\n\n  // poll for new data\n  int ret = poll(&poll_fds_[0], 2, _timeoutMs);\n  if (ret > 0) {\n    // read new data\n    if (poll_fds_[0].revents & POLLIN) {\n      mavlink_message_t msg;\n      while (mavlink_parse_char(MAVLINK_COMM_0, mavlink_fd_, &msg, 1) > 0) {\n        handleMavlinkMessage(&msg);\n      }\n    }\n\n    // send new data\n    if (poll_fds_[1].revents & POLLOUT) {\n      sendMavlinkMessage();\n    }\n  }\n\n  else if (ret < 0) {\n    gzerr << \"poll failed: \" << strerror(errno) << std::endl;\n  }\n#endif\n}", "CodeBleu_score": 41.74628159185186}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tif (mutex_.try_lock()) {\nif (serial_dev_.is_open()) {\ngzdbg << \"Closing serial device \" << device_ << \"\n\";\nserial_dev_.close();\n}\nif (io_service_thread_.joinable()) {\nio_service_thread_.join();\n}\nmutex_.unlock();\n}\n}", "CodeBleu_score": 52.59973358394381}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::recursive_mutex::scoped_lock lock(mutex_);\n\tif (serial_dev_.is_open()) {\n\t\tboost::system::error_code ec;\n\t\tio_service_.stop();\n\t\tserial_dev_.close(ec);\n\t\tif (serial_thread_.joinable()) {\n\t\t\tserial_thread_.join();\n\t\t}\n\t\tgzdbg << \"Closed serial device \" << device_ << \"\n\";\n\t}\n}", "CodeBleu_score": 53.233785774394974}, {"code": "void GazeboMavlinkInterface::close() {\n\tif (mutex_.try_lock()) {\nif (serial_dev_.is_open()) {\ntry {\nboost::asio::deadline_timer timer(io_service_, boost::posix_time::seconds(1));\nio_service_.stop();\nserial_dev_.close();\nif (io_thread_.joinable()) {\nio_thread_.join();\n}\n} catch (boost::system::system_error& err) {\ngzerr << \"Error closing serial device: \" << err.what() << \"\n\";\n}\n}\nmutex_.unlock();\n}\n}", "CodeBleu_score": 55.02454033855121}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x_0, x_1, y_0, y_1;\ndouble x, y;\ndouble x_diff, y_diff;\ndouble x_interp, y_interp;\n\nx_0 = x_0_ * res_x_;\nx_1 = x_1_ * res_x_;\ny_0 = y_0_ * res_y_;\ny_1 = y_1_ * res_y_;\n\nx_diff = x_1 - x_0;\ny_diff = y_1 - y_0;\n\nx = x_ * res_x_;\ny = y_ * res_y_;\n\nx_interp = (x - x_0) / x_diff;\ny_interp = (y - y_0) / y_diff;\n\nreturn ignition::math::Vector3d(u_[idx_x_[x_interp] + idx_y_[y_interp] * n_x_], v_[idx_x_[x_interp] + idx_y_[y_interp] * n_x_], w_[idx_x_[x_interp] + idx_y_[y_interp] * n_x_]);\n}", "CodeBleu_score": 31.266045048227948}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\n}", "CodeBleu_score": 4.3431191429652}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, y1, x2, y2, x, y;\nx1 = interpolation_points[0];\ny1 = interpolation_points[1];\nx2 = interpolation_points[2];\ny2 = interpolation_points[3];\nx = interpolation_points[4];\ny = interpolation_points[5];\n\ndouble m = (y2 - y1) / (x2 - x1);\ndouble b = y1 - m * x1;\n\nreturn ignition::math::Vector3d(m * x + b, y, 0);\n}", "CodeBleu_score": 42.27786672873105}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (this->timePos != _time) {\n\t\tthis->timePos = _time;\n\n\t\tif (this->loop) {\n\t\t\tthis->timePos = fmod(this->timePos, this->length);\n\t\t}\n\t\telse {\n\t\t\tthis->timePos = std::min(std::max(0.0, this->timePos), this->length);\n\t\t}\n\n\t\tthis->build = false;\n\t}\n}", "CodeBleu_score": 53.99409265061521}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time != this->timePos) {\n\t\tthis->timePos = _time;\n\t\tif (this->loop) {\n\t\t\tthis->timePos = fmod(this->timePos, this->length);\n\t\t}\n\t\telse {\n\t\t\tthis->timePos = std::min(this->timePos, this->length);\n\t\t\tthis->timePos = std::max(this->timePos, 0.0);\n\t\t}\n\t}\n}", "CodeBleu_score": 55.37614537552524}, {"code": "void Animation::SetTime(double _time){\n\tif (this->timePos != _time) {\n  this->timePos = _time;\n  if (this->loop) {\n    this->timePos = fmod(this->timePos, this->length);\n  } else {\n    this->timePos = std::max(0.0, this->timePos);\n    this->timePos = std::min(this->timePos, this->length);\n  }\n}\n}", "CodeBleu_score": 57.34870778859038}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.current_position)\n    self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\": \\\"flight mode: \\\"+self.flight_mode+\\\" \\\"+self.vehicle_type+'_'+self.vehicle_id+\\\": hovering at \\\"+str(self.current_position.x)+\", \"+str(self.current_position.y)+\", \"+str(self.current_position.z)+\", \"+str(yaw))\n\n", "CodeBleu_score": 60.14526510163384}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target()\n    print(self.vehicle_type+'_'+self.vehicle_id+\": \\\"HOVER\\\"\")\n\n", "CodeBleu_score": 45.71918590346499}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.current_position)\n    self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\": \\\"HOVER\\\"\")\n\n", "CodeBleu_score": 68.16248179715761}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+': '+self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+': failed to switch to '+self.flight_mode)\n            return False\n\n", "CodeBleu_score": 70.62793836052627}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    elif self.flight_mode == 'OFFBOARD':\n        self.offboard_state = self.offboard()\n        print(self.vehicle_type+'_'+self.vehicle_id+\": OFFBOARD \"+str(self.offboard_state))\n    elif self.flight_mode == 'AUTO.LAND':\n        self.land_state = self.land()\n        print(self.vehicle_type+'_'+self.vehicle_id+\": AUTO.LAND \"+str(self.land_state))\n    elif self.flight_mode == 'RTL':\n        self.rtl_state = self.rtl()\n        print(self.vehicle_type+'_'+self.vehicle_id+\": RTL \"+str(self.rtl_state))\n    else:\n        self.flight_mode_state = self.flightModeService(0, self.flight_mode)\n        if self.flight_mode_state == 0:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \\\"+self.flight_mode+\\\" failed!\\\"\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode+\\\" success!\\\"\n        return self.flight_mode_state\n\n\n\n", "CodeBleu_score": 37.965450326792975}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": flight mode switch failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 65.86455845701715}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 67.37959509180317}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        if self.hover_flag == 0:\n            self.flightModeService(custom_mode='OFFBOARD')\n            self.hover_flag = 1\n    if self.hover_flag == 1:\n        if self.flight_mode != 'HOVER':\n            self.flightModeService(custom_mode='HOVER')\n            self.flight_mode = 'HOVER'\n\n", "CodeBleu_score": 39.983298763869385}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flightModeService(custom_mode=\"OFFBOARD\")\n    if self.flightMode != \"HOVER\" and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.flightModeService(custom_mode=\"HOVER\")\n\n", "CodeBleu_score": 55.96864226346236}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        if self.flight_mode != 'OFFBOARD':\n            self.flight_mode = 'OFFBOARD'\n            self.arm()\n            self.flightModeService(custom_mode='OFFBOARD')\n            self.hover_flag = 0\n    else:\n        if self.flight_mode != 'HOVER':\n            self.flight_mode = 'HOVER'\n            self.flightModeService(custom_mode='HOVER')\n            self.hover_flag = 1\n\n", "CodeBleu_score": 40.123393133154586}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]\n    else:\n        q = Quaternion(q[3], q[0], q[1], q[2])\n        yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]\n    return yaw\n\n", "CodeBleu_score": 43.652962412926634}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 24.58575872254351}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]\n    else:\n        q = Quaternion(q)\n        yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]\n    return yaw\n\n", "CodeBleu_score": 45.692230386998254}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = self.construct_target()\n    print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n\n", "CodeBleu_score": 42.20787613364243}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \": Hover\")\n\n", "CodeBleu_score": 44.30037718586964}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw=self.current_yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n", "CodeBleu_score": 48.720150518592654}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode + \\\" failed!\\\")\n            return False\n\n\n", "CodeBleu_score": 70.60182686611888}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        return True\n    else:\n        if self.flightModeService(self.flight_mode) == True:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode + \\\" failed!\\\"\")\n            return False\n\n", "CodeBleu_score": 66.37564897861901}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        print(self.vehicle_type + '_' + self.vehicle_id + \": \\\"HOVER\\\"\")\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \\\"\\\" + self.flight_mode)\")\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode switch failed!\")\n            return False\n\n", "CodeBleu_score": 66.46645925843038}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n    return self.total_reward\n\n", "CodeBleu_score": 55.929247471399535}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.uav_id:\n        self.local_pose = msg\n        self.local_pose.pose.position.x += self.bias[i][0]\n        self.local_pose.pose.position.y += self.bias[i][1]\n        self.local_pose.pose.position.z += self.bias[i][2]\n        self.global_pose[self.uav_id] = self.local_pose\n        self.current_position[0] = self.local_pose.pose.position.x\n        self.current_position[1] = self.local_pose.pose.position.y\n        self.current_position[2] = self.local_pose.pose.position.z\n        self.current_heading = self.euler_from_quaternion(self.local_pose.pose.orientation)[2]\n        if self.form_flag == 1:\n            self.all_desired_position[self.uav_id][0] = self.current_position[0]\n            self.all_desired_position[self.uav_id][1] = self.current_position[1]\n            self.all_desired_position[self.uav_id][2] = self.current_position[2]\n            self.all_desired_position[self.uav_id][3] = self.current_heading\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose.pose.position.x = self.current_position[0]\n            self.takeoff_target_pose.pose.position.y = self.current_position[1]\n            self.takeoff_target_pose.pose.position.z = self.current_position[2]\n            self.takeoff_target_pose.pose.orientation = self.local_pose.pose.orientation\n            self.hover_target_pose.pose.position.x = self.current_position[0]\n            self.hover_target_pose.pose.position.y = self.current_position[1]\n            self.hover_target_pose.pose.position.z = self.current_position[2]\n            self.", "CodeBleu_score": 20.94684445508774}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == str(i):\n        self.local_pose = msg\n        self.local_pose.pose.position.x += self.bias_position[i][0]\n        self.local_pose.pose.position.y += self.bias_position[i][1]\n        self.local_pose.pose.position.z += self.bias_position[i][2]\n        self.global_pose[i] = msg\n        self.global_pose[i].pose.position.x += self.bias_position[i][0]\n        self.global_pose[i].pose.position.y += self.bias_position[i][1]\n        self.global_pose[i].pose.position.z += self.bias_position[i][2]\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose.pose.position.x = self.global_pose[i].pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.global_pose[i].pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.global_pose[i].pose.position.z + self.takeoff_height\n            self.hover_target_pose.pose.position.x = self.global_pose[i].pose.position.x\n            self.hover_target_pose.pose.position.y = self.global_pose[i].pose.position.y\n            self.hover_target_pose.pose.position.z = self.global_pose[i].pose.position.z + self.hover_height\n        elif self.gcs_cmd == 'FORM_0':\n            self.hover_target_pose.pose.position.x = self.global_pose[i].pose.position.x\n            self.hover_target_pose.pose.position.y = self.global_pose[i].pose.position.y\n            self.hover_target_pose.pose.position.z = self.global_pose[i].pose.position.z + self.hover_height\n        elif self.gcs_cmd == 'FORM_1':\n            self.hover_target_pose.pose.position.x = self.global_", "CodeBleu_score": 23.23881230738175}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.local_pose_bias[0]\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.local_pose_bias[1]\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.local_pose_bias[2]\n        self.local_pose.pose.orientation.x = self.local_pose.pose.orientation.x + self.local_pose_bias[3]\n        self.local_pose.pose.orientation.y = self.local_pose.pose.orientation.y + self.local_pose_bias[4]\n        self.local_pose.pose.orientation.z = self.local_pose.pose.orientation.z + self.local_pose_bias[5]\n        self.local_pose.pose.orientation.w = self.local_pose.pose.orientation.w + self.local_pose_bias[6]\n        self.global_pose[self.uav_id] = self.local_pose\n        self.current_heading = euler_from_quaternion([self.local_pose.pose.orientation.x, self.local_pose.pose.orientation.y, self.local_pose.pose.orientation.z, self.local_pose.pose.orientation.w])[2]\n        if self.gcs_cmd == 'TAKEOFF':\n            self.hover_target_pose = self.construct_target(self.takeoff_target_pose.pose.position.x, self.takeoff_target_pose.pose.position.y, self.takeoff_target_pose.pose.position.z, self.current_heading)\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = self.construct_target(self.hover_target_pose.pose.position.x, self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z, self.current_heading)\n        elif self.gcs_cmd", "CodeBleu_score": 22.0238851222084}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 80.06315890994992}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n\n    # The distance matrix is initialized.\n    dist_mat = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n\n    # The distance matrix is calculated.\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            dist_mat[i][j] = int(\n                numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))) - 50\n\n    return dist_mat\n\n", "CodeBleu_score": 44.26122392488002}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    adj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1), dtype=int)\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            adj_matrix[i][j] = int(numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))) - 50\n    return adj_matrix\n\n", "CodeBleu_score": 41.91381687722071}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    adj_matrix = numpy.zeros((self.uav_num, self.uav_num))\n    for i in range(self.uav_num):\n        for j in range(self.uav_num):\n            adj_matrix[i, j] = int(numpy.linalg.norm(orig_formation[i] - change_formation[j]))\n    return adj_matrix\n\n", "CodeBleu_score": 23.87795181978552}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 55.38826598160773}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0 and self.adj_matrix[i][j] == 1:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 55.0437959171836}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.adj_matrix[i][j] - self.label_right[j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            elif gap > self.slack_right[j]:\n                self.slack_right[j] = gap\n    return False\n\n", "CodeBleu_score": 51.030970720811}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    while True:\n        self.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n        self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n        self.match_right = numpy.array([-1] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        for i in range(self.uav_num - 1):\n            if not self.visit_left[i]:\n                if self.find_path(i):\n                    continue\n                min_slack = numpy.min(self.slack_right)\n                for j, slack in enumerate(self.slack_right, start=0):\n                    if slack == min_slack:\n                        self.label_left[i] += 1\n                        self.label_right[j] -= 1\n                        self.slack_right[j] = 100\n                        if self.find_path(i):\n                            break\n        if numpy.all(self.visit_right):\n            break\n    return self.match_right\n\n", "CodeBleu_score": 49.62139043138665}, {"code": "def KM(self)\n\t\n    for i in range(self.uav_num - 1):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n    for i in range(self.uav_num - 1):\n        if not self.visit_left[i]:\n            self.find_path(i)\n    for i in range(self.uav_num - 1):\n        if self.match_right[i] != -1:\n            self.label_left[self.match_right[i]] += self.label_right[i]\n            self.label_right[i] = 0\n    for i in range(self.uav_num - 1):\n        if self.match_right[i] != -1:\n            self.label_right[self.match_right[i]] += self.label_left[i]\n            self.label_left[i] = 0\n    for i in range(self.uav_num - 1):\n        if self.match_right[i] != -1:\n            if self.label_left[self.match_right[i]] > self.label_right[i]:\n                self.label_right[i] += self.label_left[self.match_right[i]] - self.label_right[i]\n                self.label_left[self.match_right[i]] = self.label_left[self.match_right[i]] - self.label_right[i]\n            else:\n                self.label_left[i] += self.label_right[self.match_right[i]] - self.label_left[i]\n                self.label_right[self.match_right[i]] = self.label_right[self.match_right[i]] - self.label_left[i]\n    for i in range(self.uav_num - 1):\n        if self.match_right[i] != -1:\n            if self.label_left[self.match_right[i]] > self.label_right[i]:\n                self.label_right[i] += self.label_left[self", "CodeBleu_score": 29.963649598576115}, {"code": "def KM(self)\n\t\n    for i in range(self.uav_num - 1):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n    for i in range(self.uav_num - 1):\n        while not self.visit_right[i]:\n            if not self.find_path(i):\n                min_slack = numpy.min(self.slack_right)\n                for j in range(self.uav_num - 1):\n                    if self.slack_right[j] == min_slack:\n                        self.label_right[j] -= min_slack\n                        self.slack_right[j] = 100\n    return self.match_right\n\n", "CodeBleu_score": 33.1051231241876}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    #lower_yellow = np.array([10,100,100])\n    #upper_yellow = np.array([40,255,255])\n    lower_yellow = np.array([18,100,100])\n    upper_yellow = np.array([40,255,255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    masked_image = cv2.bitwise_and(image, image, mask=mask)\n    return masked_image\n", "CodeBleu_score": 26.879014345622664}, {"code": "def yellow_dectection(image)\n\t\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Create a binary mask where white is what we want, black otherwise\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 22.008472449757843}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}]}
