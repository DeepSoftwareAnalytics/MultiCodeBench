{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * \\asf_license_stop\n *\n */", "CodeBleu_score": 9.616854472351543}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * \\asf_license_stop\n *\n */", "CodeBleu_score": 9.616854472351543}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * \\asf_license_stop\n *\n */", "CodeBleu_score": 9.616854472351543}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tsetting value\nstatic uint8_t udc_iface_setting = 0;\n\n//! Device Configuration number selected by the USB host\nCOMPILER_WORD_ALIGNED\nstatic uint8_t udc_num_configuration = 0;\n\n//! Pointer on the selected speed device configuration\nstatic udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;\n\n//! Pointer on interface descriptor used by SETUP request.\nstatic usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;\n\n//! @}", "CodeBleu_score": 7.4053766929479705}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tsetting value\nstatic uint8_t udc_iface_setting = 0;\n\n//! Device Configuration number selected by the USB host\nCOMPILER_WORD_ALIGNED\nstatic uint8_t udc_num_configuration = 0;\n\n//! Pointer on the selected speed device configuration\nstatic udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;\n\n//! Pointer on interface descriptor used by SETUP request.\nstatic usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;\n\n//! @}", "CodeBleu_score": 7.4053766929479705}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tsetting value\nstatic uint8_t udc_iface_setting = 0;\n\n//! Device Configuration number selected by the USB host\nCOMPILER_WORD_ALIGNED\nstatic uint8_t udc_num_configuration = 0;\n\n//! Pointer on the selected speed device configuration\nstatic udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;\n\n//! Pointer on interface descriptor used by SETUP request.\nstatic usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;\n\n//! @}", "CodeBleu_score": 7.4053766929479705}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\t}", "CodeBleu_score": 3.4510968920043625}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\t}", "CodeBleu_score": 3.4510968920043625}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\t}", "CodeBleu_score": 3.4510968920043625}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tfor (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;\n\t\t\tiface_num++) {\n\t\tif (!udc_iface_enable(iface_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.301196771709442}, {"code": "static bool udc_req_iface(void){\n\tfor (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;\n\t\t\tiface_num++) {\n\t\tif (!udc_iface_enable(iface_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.301196771709442}, {"code": "static bool udc_req_iface(void){\n\tfor (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;\n\t\t\tiface_num++) {\n\t\tif (!udc_iface_enable(iface_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.301196771709442}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\tendpoint OUT reception\n *\n * Called by:\n * - enable interface\n * - at the end of previous command after sending the CSW\n */\nstatic void udi_msc_cbw_wait(void);\n\n/**\n * \\brief Callback called after CBW reception\n * Called by UDD when a transfer is finished or aborted\n *\n * \\param status       UDD_EP_TRANSFER_OK, if transfer is finished\n * \\param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted\n * \\param nb_received  number of data transferred\n */\nstatic void udi_msc_cbw_received(udd_ep_status_t status,\n    iram_size_t nb_received, udd_ep_id_t ep);\n\n/**\n * \\brief Function to check the CBW length and direction\n * Call it after SCSI command decode to check integrity of command\n *\n * \\param alloc_len  number of bytes that device want transfer\n * \\param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)\n *\n * \\retval true if the command can be processed\n */\nstatic bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);\n//@}", "CodeBleu_score": 15.994918653689721}, {"code": "bool udi_msc_enable(void){\n\tendpoint OUT reception\n *\n * Called by:\n * - enable interface\n * - at the end of previous command after sending the CSW\n */\nstatic void udi_msc_cbw_wait(void);\n\n/**\n * \\brief Callback called after CBW reception\n * Called by UDD when a transfer is finished or aborted\n *\n * \\param status       UDD_EP_TRANSFER_OK, if transfer is finished\n * \\param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted\n * \\param nb_received  number of data transferred\n */\nstatic void udi_msc_cbw_received(udd_ep_status_t status,\n    iram_size_t nb_received, udd_ep_id_t ep);\n\n/**\n * \\brief Function to check the CBW length and direction\n * Call it after SCSI command decode to check integrity of command\n *\n * \\param alloc_len  number of bytes that device want transfer\n * \\param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)\n *\n * \\retval true if the command can be processed\n */\nstatic bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);\n//@}", "CodeBleu_score": 15.994918653689721}, {"code": "bool udi_msc_enable(void){\n\tendpoint OUT reception\n *\n * Called by:\n * - enable interface\n * - at the end of previous command after sending the CSW\n */\nstatic void udi_msc_cbw_wait(void);\n\n/**\n * \\brief Callback called after CBW reception\n * Called by UDD when a transfer is finished or aborted\n *\n * \\param status       UDD_EP_TRANSFER_OK, if transfer is finished\n * \\param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted\n * \\param nb_received  number of data transferred\n */\nstatic void udi_msc_cbw_received(udd_ep_status_t status,\n    iram_size_t nb_received, udd_ep_id_t ep);\n\n/**\n * \\brief Function to check the CBW length and direction\n * Call it after SCSI command decode to check integrity of command\n *\n * \\param alloc_len  number of bytes that device want transfer\n * \\param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)\n *\n * \\retval true if the command can be processed\n */\nstatic bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);\n//@}", "CodeBleu_score": 15.994918653689721}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\terror reset by setup\n  udd_ep_set_halt(UDI_MSC_EP_OUT);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);\n}", "CodeBleu_score": 21.499994971794123}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\terror reset by setup\n  udd_ep_set_halt(UDI_MSC_EP_OUT);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);\n}", "CodeBleu_score": 21.499994971794123}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\terror reset by setup\n  udd_ep_set_halt(UDI_MSC_EP_OUT);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);\n}", "CodeBleu_score": 21.499994971794123}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t_IN);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);\n}", "CodeBleu_score": 3.4742125347274597}, {"code": "static void udi_msc_csw_process(void){\n\t_IN);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);\n}", "CodeBleu_score": 3.4742125347274597}, {"code": "static void udi_msc_csw_process(void){\n\t_IN);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);\n}", "CodeBleu_score": 3.4742125347274597}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tUNUSED(port);\n  main_b_dtr_active = b_enable;\n  if (b_enable) {\n    // Cancel reset if any\n    cancelReset();\n  } else {\n    // If DTR rate is 1200, then reset\n    if (dwDTERate == 1200) {\n      // Schedule a reset\n      initiateReset();\n    }\n  }\n}", "CodeBleu_score": 53.0294762505706}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tUNUSED(port);\n  main_b_dtr_active = b_enable;\n  if (b_enable && dwDTERate == 1200) {\n    initiateReset();\n  } else {\n    cancelReset();\n  }\n}", "CodeBleu_score": 44.623723136914634}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tUNUSED(port);\n  main_b_dtr_active = b_enable;\n  if (b_enable && (dwDTERate == 1200)) {\n    initiateReset();\n  } else {\n    cancelReset();\n  }\n}", "CodeBleu_score": 44.68728210614254}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t01;\n\n      // Schedule delayed reset\n      initiateReset(250);\n    }", "CodeBleu_score": 0.9005771560166175}, {"code": "bool usb_task_other_requests(void){\n\t01;\n\n      // Schedule delayed reset\n      initiateReset(250);\n    }", "CodeBleu_score": 0.9005771560166175}, {"code": "bool usb_task_other_requests(void){\n\t01;\n\n      // Schedule delayed reset\n      initiateReset(250);\n    }", "CodeBleu_score": 0.9005771560166175}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tn        break;\n      default:\n        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU\n        spiTransferTx = (pfnSpiTransfer)spiTransferX;\n        spiTransferRx = (pfnSpiTransfer)spiTransferX;\n        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;\n        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;\n        break;\n    }", "CodeBleu_score": 9.845620920108681}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tn        break;\n      default:\n        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU\n        spiTransferTx = (pfnSpiTransfer)spiTransferX;\n        spiTransferRx = (pfnSpiTransfer)spiTransferX;\n        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;\n        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;\n        break;\n    }", "CodeBleu_score": 9.845620920108681}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tn        break;\n      default:\n        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU\n        spiTransferTx = (pfnSpiTransfer)spiTransferX;\n        spiTransferRx = (pfnSpiTransfer)spiTransferX;\n        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;\n        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;\n        break;\n    }", "CodeBleu_score": 9.845620920108681}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = nullptr;\n\n  // Get the address of the relocated table\n  pfnISR_Handler* isr_table = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  oldHandler = isr_table[irq + 16];\n\n  // Replace it with the new handler\n  isr_table[irq + 16] = newHandler;\n\n  // Reenable global interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 78.62404981826168}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = nullptr;\n  pfnISR_Handler* isr = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  oldHandler = isr[irq + 16];\n\n  // Replace it with the new handler\n  isr[irq + 16] = newHandler;\n\n  // Re-enable global interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 79.81519078338971}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = nullptr;\n\n  // Get the address of the relocated table\n  pfnISR_Handler* isr_table = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  oldHandler = isr_table[irq + 16];\n\n  // Replace it with the new handler\n  isr_table[irq + 16] = newHandler;\n\n  // Re-enable global interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 78.62404981826168}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (pending_char >= 0) return pending_char;\n  if (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  pending_char = udi_cdc_getc();\n  return pending_char;\n}", "CodeBleu_score": 64.72805965630928}, {"code": "int MarlinSerialUSB::peek(){\n\tif (pending_char >= 0) return pending_char;\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  return pending_char = udi_cdc_getc();\n}", "CodeBleu_score": 58.59105920930712}, {"code": "int MarlinSerialUSB::peek(){\n\tint c;\n  if (pending_char >= 0) {\n    c = pending_char;\n    pending_char = -1;\n  }\n  else if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready())\n    c = udi_cdc_getc();\n  else\n    c = -1;\n  return c;\n}", "CodeBleu_score": 48.478378767475704}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  int c = udi_cdc_getc();\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n  return c;\n}", "CodeBleu_score": 84.74953063651151}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  int c = udi_cdc_getc();\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n  return c;\n}", "CodeBleu_score": 84.74953063651151}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  int c = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n  return c;\n}", "CodeBleu_score": 84.74953063651151}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (pending_char >= 0) return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return 0;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return 1;\n}", "CodeBleu_score": 50.5611862423108}, {"code": "int MarlinSerialUSB::available(){\n\tif (pending_char >= 0) return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return 0;\n\n  pending_char = udi_cdc_getc();\n  return 1;\n}", "CodeBleu_score": 48.24552551587541}, {"code": "int MarlinSerialUSB::available(){\n\tif (pending_char >= 0) return 1;\n  if (!usb_task_cdc_isenabled()) return 0;\n  if (!udi_cdc_is_rx_ready()) return 0;\n  pending_char = udi_cdc_getc();\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n  return 1;\n}", "CodeBleu_score": 50.5611862423108}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// Adjust this block header to include the next one\n            buffer[i + 2] += buffer[inext + 2] + 1;\n\n            // Store data at the right place\n            buffer[i + 3 + blen] = data;\n\n            // Remove the next block header and append its data\n            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);\n\n            // Finally, as we have saved 2 bytes at the end, make sure to clean them\n            buffer[iend - 2] = 0xFF;\n            buffer[iend - 1] = 0xFF;\n\n          }", "CodeBleu_score": 26.41845469129334}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// Adjust this block header to include the next one\n            buffer[i + 2] += buffer[inext + 2] + 1;\n\n            // Store data at the right place\n            buffer[i + 3 + blen] = data;\n\n            // Remove the next block header and append its data\n            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);\n\n            // Finally, as we have saved 2 bytes at the end, make sure to clean them\n            buffer[iend - 2] = 0xFF;\n            buffer[iend - 1] = 0xFF;\n\n          }", "CodeBleu_score": 26.41845469129334}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// Adjust this block header to include the next one\n            buffer[i + 2] += buffer[inext + 2] + 1;\n\n            // Store data at the right place\n            buffer[i + 3 + blen] = data;\n\n            // Remove the next block header and append its data\n            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);\n\n            // Finally, as we have saved 2 bytes at the end, make sure to clean them\n            buffer[iend - 2] = 0xFF;\n            buffer[iend - 1] = 0xFF;\n\n          }", "CodeBleu_score": 26.41845469129334}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tn    // Change attenuation 100mV below the calibrated threshold\n    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);\n  }", "CodeBleu_score": 8.335003605447802}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tn    // Change attenuation 100mV below the calibrated threshold\n    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);\n  }", "CodeBleu_score": 8.335003605447802}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tn    // Change attenuation 100mV below the calibrated threshold\n    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);\n  }", "CodeBleu_score": 8.335003605447802}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAY_ARRAY_SIZE is not equal to the number of servos!\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n    #endif\n  }\n}", "CodeBleu_score": 59.83130552630493}, {"code": "void Servo::move(const int value){\n\tstatic_assert(NUM_SERVOS <= MAX_SERVOS, \"Too many servos in config.h\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n    #endif\n  }\n}", "CodeBleu_score": 56.962962222305926}, {"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(DELAY_BETWEEN_PULSES), \"DELAY_BETWEEN_PULSES must have 16 elements.\");\n\n  if (attach(pin)) {\n    write(value);\n    safe_delay(DELAY_BETWEEN_PULSES[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 47.21629628420972}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t.desc[0];\n\n  // stop i2s\n  i2s_stop(I2S_NUM_0);\n\n  // configure I2S data port interface.\n  i2s_reset_fifo(I2S_NUM_0);\n\n  //reset i2s\n  I2S0.conf.tx_reset = 1;\n  I2S0.conf.tx_reset = 0;\n  I2S0.conf.rx_reset = 1;\n  I2S0.conf.rx_reset = 0;\n\n  //reset dma\n  I2S0.lc_conf.in_rst = 1;\n  I2S0.lc_conf.in_rst = 0;\n  I2S0.lc_conf.out_rst = 1;\n  I2S0.lc_conf.out_rst = 0;\n\n  //Enable and configure DMA\n  I2S0.lc_conf.check_owner = 0;\n  I2S0.lc_conf.out_loop_test = 0;\n  I2S0.lc_conf.out_auto_wrback = 0;\n  I2S0.lc_conf.out_data_burst_en = 0;\n  I2S0.lc_conf.outdscr_burst_en = 0;\n  I2S0.lc_conf.out_no_restart_clr = 0;\n  I2S0.lc_conf.indscr_burst_en = 0;\n  I2S0.lc_conf.out_eof_mode = 1;\n\n  I2S0.conf2.lcd_en = 0;\n  I2S0.conf2.camera_en = 0;\n  I2S0.pdm_conf.pcm2pdm_conv_en = 0;\n  I2S0.pdm_conf.pdm2pcm_conv_en = 0;\n\n  I2S0.fifo_conf.dscr_en = 0;\n\n  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);\n  I2S0.fifo_conf.tx_fifo_mod = 0;\n  I2S0.conf.tx_mono = 0;\n\n  I2S0.conf_chan.rx_chan_mod = 0;\n  I2S0.fifo_conf.rx_fifo_mod = 0;\n  I2S0.conf.rx_mono = 0;\n\n  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo\n\n  I2S0.conf.tx_start = 0;\n  I2S0.conf.rx_start = 0;\n\n  I2S0.conf.tx_msb_right = 1;\n  I2S0.conf.tx_right_first = 1;\n\n  I2S0.conf.tx_slave_mod = 0; // Master\n  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;\n\n  I2S0.pdm_conf.rx_pdm_en = 0;\n  I2S0.pdm_conf.tx_pdm_en = 0;\n\n  I2S0.conf.tx_short_sync = 0;\n  I2S0.conf.rx_short_sync = 0;\n  I2S0.conf.tx_msb_shift = 0;\n  I2S0.conf.rx_msb_shift = 0;\n\n  // set clock\n  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference\n  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256\n  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)\n  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset\n\n  // fbck = fi2s / tx_bck_div_num\n  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6\n\n  // Enable TX interrupts\n  I2S0.int_ena.out_eof = 1;\n  I2S0.int_ena.out_dscr_err = 0;\n  I2S0.int_ena.out_total_eof = 0;\n  I2S0.int_ena.out_done = 0;\n\n  // Allocate and Enable the I2S interrupt\n  intr_handle_t i2s_isr_handle;\n  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);\n  esp_intr_enable(i2s_isr_handle);\n\n  // Create the task that will feed the buffer\n  xTaskCreatePinnedToCore(stepperTask, \\\"StepperTask\\\", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin\n\n  // Route the i2s pins to the appropriate GPIO\n  // If a pin is not defined, no need to configure\n  #if defined(I2S_DATA) && I2S_DATA >= 0\n    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);\n  #endif\n  #if defined(I2S_BCK) && I2S_BCK >= 0\n    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);\n  #endif\n  #if defined(I2S_WS) && I2S_WS >= 0\n    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);\n  #endif\n\n  // Start the I2S peripheral\n  return i2s_start(I2S_NUM_0);\n}", "CodeBleu_score": 21.074838668585727}, {"code": "void i2s_push_sample(){\n\t.desc[0];\n\n  // stop i2s\n  i2s_stop(I2S_NUM_0);\n\n  // configure I2S data port interface.\n  i2s_reset_fifo(I2S_NUM_0);\n\n  //reset i2s\n  I2S0.conf.tx_reset = 1;\n  I2S0.conf.tx_reset = 0;\n  I2S0.conf.rx_reset = 1;\n  I2S0.conf.rx_reset = 0;\n\n  //reset dma\n  I2S0.lc_conf.in_rst = 1;\n  I2S0.lc_conf.in_rst = 0;\n  I2S0.lc_conf.out_rst = 1;\n  I2S0.lc_conf.out_rst = 0;\n\n  //Enable and configure DMA\n  I2S0.lc_conf.check_owner = 0;\n  I2S0.lc_conf.out_loop_test = 0;\n  I2S0.lc_conf.out_auto_wrback = 0;\n  I2S0.lc_conf.out_data_burst_en = 0;\n  I2S0.lc_conf.outdscr_burst_en = 0;\n  I2S0.lc_conf.out_no_restart_clr = 0;\n  I2S0.lc_conf.indscr_burst_en = 0;\n  I2S0.lc_conf.out_eof_mode = 1;\n\n  I2S0.conf2.lcd_en = 0;\n  I2S0.conf2.camera_en = 0;\n  I2S0.pdm_conf.pcm2pdm_conv_en = 0;\n  I2S0.pdm_conf.pdm2pcm_conv_en = 0;\n\n  I2S0.fifo_conf.dscr_en = 0;\n\n  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);\n  I2S0.fifo_conf.tx_fifo_mod = 0;\n  I2S0.conf.tx_mono = 0;\n\n  I2S0.conf_chan.rx_chan_mod = 0;\n  I2S0.fifo_conf.rx_fifo_mod = 0;\n  I2S0.conf.rx_mono = 0;\n\n  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo\n\n  I2S0.conf.tx_start = 0;\n  I2S0.conf.rx_start = 0;\n\n  I2S0.conf.tx_msb_right = 1;\n  I2S0.conf.tx_right_first = 1;\n\n  I2S0.conf.tx_slave_mod = 0; // Master\n  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;\n\n  I2S0.pdm_conf.rx_pdm_en = 0;\n  I2S0.pdm_conf.tx_pdm_en = 0;\n\n  I2S0.conf.tx_short_sync = 0;\n  I2S0.conf.rx_short_sync = 0;\n  I2S0.conf.tx_msb_shift = 0;\n  I2S0.conf.rx_msb_shift = 0;\n\n  // set clock\n  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference\n  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256\n  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)\n  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset\n\n  // fbck = fi2s / tx_bck_div_num\n  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6\n\n  // Enable TX interrupts\n  I2S0.int_ena.out_eof = 1;\n  I2S0.int_ena.out_dscr_err = 0;\n  I2S0.int_ena.out_total_eof = 0;\n  I2S0.int_ena.out_done = 0;\n\n  // Allocate and Enable the I2S interrupt\n  intr_handle_t i2s_isr_handle;\n  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);\n  esp_intr_enable(i2s_isr_handle);\n\n  // Create the task that will feed the buffer\n  xTaskCreatePinnedToCore(stepperTask, \\\"StepperTask\\\", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin\n\n  // Route the i2s pins to the appropriate GPIO\n  // If a pin is not defined, no need to configure\n  #if defined(I2S_DATA) && I2S_DATA >= 0\n    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);\n  #endif\n  #if defined(I2S_BCK) && I2S_BCK >= 0\n    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);\n  #endif\n  #if defined(I2S_WS) && I2S_WS >= 0\n    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);\n  #endif\n\n  // Start the I2S peripheral\n  return i2s_start(I2S_NUM_0);\n}", "CodeBleu_score": 21.074838668585727}, {"code": "void i2s_push_sample(){\n\t.desc[0];\n\n  // stop i2s\n  i2s_stop(I2S_NUM_0);\n\n  // configure I2S data port interface.\n  i2s_reset_fifo(I2S_NUM_0);\n\n  //reset i2s\n  I2S0.conf.tx_reset = 1;\n  I2S0.conf.tx_reset = 0;\n  I2S0.conf.rx_reset = 1;\n  I2S0.conf.rx_reset = 0;\n\n  //reset dma\n  I2S0.lc_conf.in_rst = 1;\n  I2S0.lc_conf.in_rst = 0;\n  I2S0.lc_conf.out_rst = 1;\n  I2S0.lc_conf.out_rst = 0;\n\n  //Enable and configure DMA\n  I2S0.lc_conf.check_owner = 0;\n  I2S0.lc_conf.out_loop_test = 0;\n  I2S0.lc_conf.out_auto_wrback = 0;\n  I2S0.lc_conf.out_data_burst_en = 0;\n  I2S0.lc_conf.outdscr_burst_en = 0;\n  I2S0.lc_conf.out_no_restart_clr = 0;\n  I2S0.lc_conf.indscr_burst_en = 0;\n  I2S0.lc_conf.out_eof_mode = 1;\n\n  I2S0.conf2.lcd_en = 0;\n  I2S0.conf2.camera_en = 0;\n  I2S0.pdm_conf.pcm2pdm_conv_en = 0;\n  I2S0.pdm_conf.pdm2pcm_conv_en = 0;\n\n  I2S0.fifo_conf.dscr_en = 0;\n\n  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);\n  I2S0.fifo_conf.tx_fifo_mod = 0;\n  I2S0.conf.tx_mono = 0;\n\n  I2S0.conf_chan.rx_chan_mod = 0;\n  I2S0.fifo_conf.rx_fifo_mod = 0;\n  I2S0.conf.rx_mono = 0;\n\n  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo\n\n  I2S0.conf.tx_start = 0;\n  I2S0.conf.rx_start = 0;\n\n  I2S0.conf.tx_msb_right = 1;\n  I2S0.conf.tx_right_first = 1;\n\n  I2S0.conf.tx_slave_mod = 0; // Master\n  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;\n\n  I2S0.pdm_conf.rx_pdm_en = 0;\n  I2S0.pdm_conf.tx_pdm_en = 0;\n\n  I2S0.conf.tx_short_sync = 0;\n  I2S0.conf.rx_short_sync = 0;\n  I2S0.conf.tx_msb_shift = 0;\n  I2S0.conf.rx_msb_shift = 0;\n\n  // set clock\n  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference\n  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256\n  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)\n  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset\n\n  // fbck = fi2s / tx_bck_div_num\n  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6\n\n  // Enable TX interrupts\n  I2S0.int_ena.out_eof = 1;\n  I2S0.int_ena.out_dscr_err = 0;\n  I2S0.int_ena.out_total_eof = 0;\n  I2S0.int_ena.out_done = 0;\n\n  // Allocate and Enable the I2S interrupt\n  intr_handle_t i2s_isr_handle;\n  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);\n  esp_intr_enable(i2s_isr_handle);\n\n  // Create the task that will feed the buffer\n  xTaskCreatePinnedToCore(stepperTask, \\\"StepperTask\\\", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin\n\n  // Route the i2s pins to the appropriate GPIO\n  // If a pin is not defined, no need to configure\n  #if defined(I2S_DATA) && I2S_DATA >= 0\n    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);\n  #endif\n  #if defined(I2S_BCK) && I2S_BCK >= 0\n    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);\n  #endif\n  #if defined(I2S_WS) && I2S_WS >= 0\n    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);\n  #endif\n\n  // Start the I2S peripheral\n  return i2s_start(I2S_NUM_0);\n}", "CodeBleu_score": 21.074838668585727}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t count_value;\n  timer_get_counter_value(timer.group, timer.idx, &count_value);\n\n  return count_value;\n}", "CodeBleu_score": 85.72695487801299}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t count;\n  timer_get_counter_value(timer.group, timer.idx, &count);\n\n  return count;\n}", "CodeBleu_score": 82.90299767074694}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t count_value;\n  timer_get_counter_value(timer.group, timer.idx, &count_value);\n\n  return count_value;\n}", "CodeBleu_score": 85.72695487801299}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.2987045464282}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.2987045464282}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.2987045464282}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.01487595230046}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.01487595230046}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.01487595230046}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_TEMP:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      temp_timer.setCallbackPriority(TEMP_TIMER_PRIORITY);\n      break;\n    case TIMER_STEP:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      step_timer.setCallbackPriority(STEP_TIMER_PRIORITY);\n      break;\n    default:\n      ASSERT(false);\n      break;\n  }\n}", "CodeBleu_score": 37.21558825204551}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_TEMP:\n      temp_timer.Start(frequency, TIMER0_TEMP_PRESCALE);\n      __NVIC_SetPriority(TIMER02A_IRQn, TIMER0_TEMP_PRIORITY);\n      break;\n    case TIMER_STEP:\n      step_timer.Start(frequency, TIMER0_STEP_PRESCALE);\n      __NVIC_SetPriority(TIMER02B_IRQn, TIMER0_STEP_PRIORITY);\n      break;\n    default:\n      ASSERT(false);\n  }\n}", "CodeBleu_score": 28.26231353726671}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TEMP_TIMER_NUM:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      temp_timer.setCallback(Temp_Handler, TEMP_TIMER_PRIO);\n      break;\n    case STEP_TIMER_NUM:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      step_timer.setCallback(Step_Handler, STEP_TIMER_PRIO);\n      break;\n    default:\n      DEBUG_ASSERT(0);\n      break;\n  }\n}", "CodeBleu_score": 33.06709102058081}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tFILE *eeprom_file = fopen(filename, \"r+b\");\n  if (eeprom_file == NULL) {\n    eeprom_file = fopen(filename, \"w+b\");\n    if (eeprom_file == NULL) {\n      SERIAL_ECHO_MSG(\"EEPROM file open failed\");\n      return false;\n    }\n  }\n  size_t file_size = 0;\n  fseek(eeprom_file, 0, SEEK_END);\n  file_size = (size_t)ftell(eeprom_file);\n  fseek(eeprom_file, 0, SEEK_SET);\n  if (file_size < capacity()) {\n    memset(buffer, 0xFF, capacity());\n  }\n  else {\n    file_size = capacity();\n  }\n  size_t read_size = fread(buffer, 1, file_size, eeprom_file);\n  if (read_size != file_size) {\n    SERIAL_ECHO_MSG(\"EEPROM file read failed\");\n    fclose(eeprom_file);\n    return false;\n  }\n  fclose(eeprom_file);\n  return true;\n}", "CodeBleu_score": 46.40922065777849}, {"code": "bool PersistentStore::access_start(){\n\tFILE *eeprom_file = fopen(filename, \"r+b\");\n\n  if (eeprom_file == NULL) {\n    // File does not exist or cannot be opened\n    return false;\n  }\n\n  // Check file size\n  fseek(eeprom_file, 0, SEEK_END);\n  size_t file_size = ftell(eeprom_file);\n  rewind(eeprom_file);\n\n  if (file_size < capacity()) {\n    // File is smaller than expected; fill the buffer with a default erase value\n    memset(buffer, 0xFF, capacity());\n  }\n  else {\n    // File is of sufficient size; read the file's contents into the buffer\n    size_t read_size = fread(buffer, 1, capacity(), eeprom_file);\n    if (read_size < capacity()) {\n      // Read was incomplete; fill the remainder of the buffer with a default erase value\n      memset(buffer + read_size, 0xFF, capacity() - read_size);\n    }\n  }\n\n  fclose(eeprom_file);\n  return true;\n}", "CodeBleu_score": 50.72552157641783}, {"code": "bool PersistentStore::access_start(){\n\tFILE *eeprom_file = fopen(filename, \"rb+\");\n  if (!eeprom_file) {\n    fprintf(stderr, \"Failed to open EEPROM file %s\n\", filename);\n    return false;\n  }\n  size_t file_size = 0;\n  fseek(eeprom_file, 0, SEEK_END);\n  file_size = ftell(eeprom_file);\n  fseek(eeprom_file, 0, SEEK_SET);\n  if (file_size < capacity()) {\n    memset(buffer, 0xFF, capacity());\n    fprintf(stderr, \"EEPROM file %s is smaller than expected. Filling with default erase value.\n\", filename);\n  }\n  else {\n    fread(buffer, capacity(), 1, eeprom_file);\n  }\n  fclose(eeprom_file);\n  return true;\n}", "CodeBleu_score": 49.84892698886981}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n  for (uint8_t i = 0; i < 8; i++) {\n    WRITE(SCK_PIN, LOW);\n    WRITE(MOSI_PIN, TEST(b, 7));\n    b <<= 1;\n    r <<= 1;\n    r |= READ(MISO_PIN);\n    WRITE(SCK_PIN, HIGH);\n    _delay_ns(125);\n  }\n  return r;\n}", "CodeBleu_score": 49.27628303535916}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t ret = 0;\n  for (uint8_t i = 0; i < 8; i++) {\n    OUT_WRITE(SD_SCK_PIN, LOW);\n    OUT_WRITE(SD_MOSI_PIN, TEST(b, 7));\n    b <<= 1;\n    OUT_WRITE(SD_SCK_PIN, HIGH);\n    if (READ(SD_MISO_PIN)) SBI(ret, 7);\n    ret <<= 1;\n    delaySPIFunc();\n  }\n  return ret;\n}", "CodeBleu_score": 53.421930259049134}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n  for (uint8_t i = 0x80; i; i >>= 1) {\n    WRITE(SD_SCK_PIN, LOW);\n    if (b & i) SET_INPUT(SD_MOSI_PIN); else CLEAR_INPUT(SD_MOSI_PIN);\n    WRITE(SD_SCK_PIN, HIGH);\n    if (READ(SD_MISO_PIN)) r |= i;\n    WRITE(SD_SCK_PIN, LOW);\n  }\n  delaySPIFunc();\n  return r;\n}", "CodeBleu_score": 49.85092097478919}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 99.87715012496787}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 99.87715012496787}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 99.87715012496787}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c;\n  if (obj->rx_buff.head == obj->rx_buff.tail) {\n    // Overflow!\n    obj->rx_buff.overflow = 1;\n    obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n  else {\n    c = obj->rx_buff.buffer[obj->rx_buff.head];\n    if (obj->rx_buff.head == SERIAL_RX_BUFFER_SIZE - 1)\n      obj->rx_buff.head = 0;\n    else\n      obj->rx_buff.head++;\n  }\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n}", "CodeBleu_score": 44.909543882539175}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif (obj->rx_buff.head == obj->rx_buff.tail) return;\n\n  // Read byte\n  uint8_t data = serial_getc(obj);\n\n  // If RX buffer full, set the overflow flag and return\n  rx_buffer_index_t i = (rx_buffer_index_t)(obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n  if (i != obj->rx_buff.tail) {\n    obj->rx_buff.buffer[obj->rx_buff.head] = data;\n    obj->rx_buff.head = i;\n  }\n  else {\n    obj->rx_buff.buffer[obj->rx_buff.head] = data;\n    obj->rx_buff.head = i;\n    obj->rx_buff.overflow = true;\n  }\n\n  // Update emergency parser\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(data));\n}", "CodeBleu_score": 49.69858157892686}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t// Read byte\n  uint8_t data = HAL_HardwareSerial::read(obj);\n\n  // If RX buffer full, set the overflow flag and return\n  if (rx_buffer.isFull()) {\n    rx_buffer_overflow();\n    return;\n  }\n\n  // If we have an emergency message pending, don't overwrite it.\n  if (emergency_parser.state != e_parser_state::EP_RECEIVING) {\n    // Store the read byte in the buffer unless the buffer is full.\n    rx_buffer.store_value(data);\n  }\n\n  // Update the next read pointer\n  rx_buffer.advance(1);\n}", "CodeBleu_score": 25.507694808147864}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tSERIAL_TIMER_IRQ_PRIO\n    #define SWSERIAL_TIMER_IRQ_PRIO SWSERIAL_TIMER_IRQ_PRIO_DEFAULT\n  #endif", "CodeBleu_score": 3.346291866472951}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tSERIAL_TIMER_IRQ_PRIO\n    #define SWSERIAL_TIMER_IRQ_PRIO SWSERIAL_TIMER_IRQ_PRIO_DEFAULT\n  #endif", "CodeBleu_score": 3.346291866472951}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tSERIAL_TIMER_IRQ_PRIO\n    #define SWSERIAL_TIMER_IRQ_PRIO SWSERIAL_TIMER_IRQ_PRIO_DEFAULT\n  #endif", "CodeBleu_score": 3.346291866472951}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tIf the substring is not found, this returns -1.", "CodeBleu_score": 2.2148463648035204}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tIf the substring is not found, this returns -1.", "CodeBleu_score": 2.2148463648035204}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tIf the substring is not found, this returns -1.", "CodeBleu_score": 2.2148463648035204}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore(interrupt.Enabled())\n}", "CodeBleu_score": 48.50748985651314}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.Set(i2c.crINT)\n\ti2c.crReg.Set(i2c.crEN)\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\ti2c.drReg.Set(address<<1 | i2c.crEA)\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\ti2c.drReg.Set(address<<1 | i2c.crEA | i2c.crSTA | i2c.crSTO)\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n}", "CodeBleu_score": 40.85609652868657}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.crReg.Set(i2c.crINT) // clear interrupt flag\n\ti2c.crReg.Set(i2c.crSTA) // send start condition\n\ti2c.crReg.Set(i2c.crEN)  // enable I2C\n\n\t// wait for start condition to be transmitted\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\n\t// write address to bus\n\ti2c.drReg.Set(address << 1)\n\tif !write {\n\t\ti2c.drReg.Set(i2c.drReg.Get() | 1)\n\t}\n\n\t// wait for address to be transmitted\n\tfor !i2c.srReg.HasBits(i2c.srPS1) {\n\t}\n}", "CodeBleu_score": 36.89808710738941}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear interrupt flag.\n\ti2c.srReg.SetBits(i2c.srPS0)\n\t// Put start condition on SDA line.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\t// Enable I2C module.\n\ti2c.crReg.SetBits(i2c.crEN)\n\n\t// Wait for start condition to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\n\t// Write address to bus.\n\ti2c.drReg.Set(address << 1)\n\n\t// Wait for address to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\n\t// Clear interrupt flag.\n\ti2c.srReg.SetBits(i2c.srPS0)\n\n\t// If in write mode, set the R/W bit to 0, otherwise set it to 1.\n\tif write {\n\t\ti2c.drReg.ClearBits(1)\n\t} else {\n\t\ti2c.drReg.SetBits(1)\n\t}\n\n\t// Wait for address to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\n\t// Clear interrupt flag.\n\ti2c.srReg.SetBits(i2c.srPS0)\n}", "CodeBleu_score": 33.955491042898814}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.04571309596861}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.04571309596861}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.04571309596861}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Default I2C pins if not set.\n\tif config.SDA == 0 && config.SCL == 0 {\n\t\tconfig.SDA = SDA_PIN\n\t\tconfig.SCL = SCL_PIN\n\t}\n\n\t// do config\n\tsclPort, sclPin := config.SCL.getPortPin()\n\tsclPort.PIN_CNF[sclPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\tsdaPort, sdaPin := config.SDA.getPortPin()\n\tsdaPort.PIN_CNF[sdaPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\ti2c.setPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 18.016763273213826}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Default I2C pins if not set.\n\tif config.SDA == 0 && config.SCL == 0 {\n\t\tconfig.SDA = SDA_PIN\n\t\tconfig.SCL = SCL_PIN\n\t}\n\n\t// do config\n\tsclPort, sclPin := config.SCL.getPortPin()\n\tsclPort.PIN_CNF[sclPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\tsdaPort, sdaPin := config.SDA.getPortPin()\n\tsdaPort.PIN_CNF[sdaPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\ti2c.setPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 18.016763273213826}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Default I2C pins if not set.\n\tif config.SDA == 0 && config.SCL == 0 {\n\t\tconfig.SDA = SDA_PIN\n\t\tconfig.SCL = SCL_PIN\n\t}\n\n\t// do config\n\tsclPort, sclPin := config.SCL.getPortPin()\n\tsclPort.PIN_CNF[sclPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\tsdaPort, sdaPin := config.SDA.getPortPin()\n\tsdaPort.PIN_CNF[sdaPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\ti2c.setPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 18.016763273213826}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor to avoid messing with the one\n\t// the caller uses.\n\tdupFd, err := dupCloseOnExec(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\t// Use fdopendir to get a DIR pointer.\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil || err != syscall.EINTR {\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"fdopendir\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 52.342302583957824}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor to avoid the caller closing it\n\t// when they close the file.\n\tnewfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\t// Call fdopendir until it succeeds or returns an error other than EINTR.\n\tvar d uintptr\n\tfor {\n\t\td, err = syscall.Fdopendir(newfd)\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\tsyscall.Close(newfd)\n\t\treturn 0, \"fdopendir\", err\n\t}\n\n\treturn d, \"\", nil\n}", "CodeBleu_score": 78.35316233864562}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tnsfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\tfor {\n\t\td, err := syscall.Fdopendir(nsfd)\n\t\tif err == nil || err != syscall.EINTR {\n\t\t\treturn uintptr(unsafe.Pointer(d)), \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 51.61795730199836}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tinclude \\\"Esp.h\\\"", "CodeBleu_score": 2.128391891798727}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tinclude \\\"Esp.h\\\"", "CodeBleu_score": 2.128391891798727}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tinclude \\\"Esp.h\\\"", "CodeBleu_score": 2.128391891798727}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tense\\\");", "CodeBleu_score": 2.838583742703172}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tense\\\");", "CodeBleu_score": 2.838583742703172}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tense\\\");", "CodeBleu_score": 2.838583742703172}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\\\"APP size: %u (%u sectors)\\\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\\\"APP partition not found. Reading disabled\\\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\\\"OTA size: %u (%u sectors)\\\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\\\"OTA partition not found. Writing disabled\\\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\\\"USING FAT16\\\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\\\"USING FAT12\\\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\\\"FAT sector size: %u\\\", DISK_SECTOR_SIZE);\n  log_d(\\\"FAT data sectors: %u\\\", data_sectors);\n  log_d(\\\"FAT table sectors: %u\\\", msc_table_sectors);\n  log_d(\\\"FAT total sectors: %u (%uKB)\\\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}", "CodeBleu_score": 27.765865256435994}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\\\"APP size: %u (%u sectors)\\\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\\\"APP partition not found. Reading disabled\\\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\\\"OTA size: %u (%u sectors)\\\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\\\"OTA partition not found. Writing disabled\\\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\\\"USING FAT16\\\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\\\"USING FAT12\\\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\\\"FAT sector size: %u\\\", DISK_SECTOR_SIZE);\n  log_d(\\\"FAT data sectors: %u\\\", data_sectors);\n  log_d(\\\"FAT table sectors: %u\\\", msc_table_sectors);\n  log_d(\\\"FAT total sectors: %u (%uKB)\\\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}", "CodeBleu_score": 27.765865256435994}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\\\"APP size: %u (%u sectors)\\\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\\\"APP partition not found. Reading disabled\\\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\\\"OTA size: %u (%u sectors)\\\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\\\"OTA partition not found. Writing disabled\\\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\\\"USING FAT16\\\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\\\"USING FAT12\\\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\\\"FAT sector size: %u\\\", DISK_SECTOR_SIZE);\n  log_d(\\\"FAT data sectors: %u\\\", data_sectors);\n  log_d(\\\"FAT table sectors: %u\\\", msc_table_sectors);\n  log_d(\\\"FAT total sectors: %u (%uKB)\\\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}", "CodeBleu_score": 27.765865256435994}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  for (size_t i = 0; i < strlen(in); i++) {\n    uint8_t c = hex_char_to_byte(in[i]);\n    if (c < 0x10) {\n      if (len == maxlen) {\n        return len;\n      }\n      if (i & 1) {\n        out[len++] |= c;\n      } else {\n        out[len] = c << 4;\n      }\n    }\n  }\n  return len;\n}", "CodeBleu_score": 54.89840500329402}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  uint8_t high, low;\n  for (; len < maxlen; in++) {\n    high = hex_char_to_byte(*in);\n    if (high > 0x0F) {\n      break;\n    }\n    in++;\n    low = hex_char_to_byte(*in);\n    if (low > 0x0F) {\n      break;\n    }\n    *out++ = (high << 4) | low;\n    len++;\n  }\n  return len;\n}", "CodeBleu_score": 46.7414448318892}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i, j = 0;\n  for (i = 0; i < strlen(in); i++) {\n    uint8_t v = hex_char_to_byte(in[i]);\n    if (v <= 0xf) {\n      if (j >= maxlen) {\n        break;\n      }\n      if (i & 1) {\n        out[j++] |= v;\n      } else {\n        out[j] = v << 4;\n      }\n    }\n  }\n  return j;\n}", "CodeBleu_score": 47.9498632982158}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tn  //  SOF_TIMEOUT = 5;\n}", "CodeBleu_score": 3.2805215944581354}, {"code": "int HWCDC::availableForWrite(void){\n\tn  //  SOF_TIMEOUT = 5;\n}", "CodeBleu_score": 3.2805215944581354}, {"code": "int HWCDC::availableForWrite(void){\n\tn  //  SOF_TIMEOUT = 5;\n}", "CodeBleu_score": 3.2805215944581354}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  _onReceiveTimeout = onlyOnTimeout;\n  if (onlyOnTimeout) {\n    // only call the callback when the timeout is reached\n    uart_set_rx_timeout(_uart, _rxTimeout);\n  } else {\n    // call the callback when any data is received\n    uart_set_rx_timeout(_uart, 0);\n  }\n  if (function != NULL) {\n    // set the FIFO full threshold\n    _rxFIFOFull = _rxBufferSize / 2;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 60.9243440535826}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  // configure the receive timeout behavior\n  _onReceiveTimeout = onlyOnTimeout;\n  if (onlyOnTimeout) {\n    // set the FIFO full threshold to 1 byte\n    _rxFIFOFull = 1;\n    // set the receive timeout to 100 ms\n    _rxTimeout = 100;\n  } else {\n    // set the FIFO full threshold to 1/2 of the buffer size\n    _rxFIFOFull = _rxBufferSize / 2;\n    // set the receive timeout to 0 ms\n    _rxTimeout = 0;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 56.717767415813555}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  _onReceiveTimeout = onlyOnTimeout;\n  if (onlyOnTimeout) {\n    _rxFIFOFull = 1;\n  } else {\n    _rxFIFOFull = 0;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 48.7810208987016}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\ttarget), NULL, 0);\n}", "CodeBleu_score": 4.38763997183281}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\ttarget), NULL, 0);\n}", "CodeBleu_score": 4.38763997183281}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\ttarget), NULL, 0);\n}", "CodeBleu_score": 4.38763997183281}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone was called\");\n  if (_pin == -1) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else {\n    log_e(\"Tone is already running on pin %d\", _pin);\n  }\n}", "CodeBleu_score": 62.12989753920814}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone was called\");\n  if (_pin == -1 || _pin == pin) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else {\n    log_e(\"Tone is already running on given pin %d\", pin);\n  }\n}", "CodeBleu_score": 68.94123501442317}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone was called\");\n  if (pin == _pin) {\n    log_e(\"Tone is already running on given pin %d\", pin);\n  } else {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  }\n}", "CodeBleu_score": 63.47907632123378}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tPUSB::ESPUSB(size_t task_stack_size, uint8_t event_task_priority)\n  : vid(USB_VID), pid(USB_PID), product_name(USB_PRODUCT), manufacturer_name(USB_MANUFACTURER), serial_number(USB_SERIAL), fw_version(0x0100),\n    usb_version(0x0200)  // at least 2.1 or 3.x for BOS & webUSB\n    ,\n    usb_class(TUSB_CLASS_MISC), usb_subclass(MISC_SUBCLASS_COMMON), usb_protocol(MISC_PROTOCOL_IAD), usb_attributes(TUSB_DESC_CONFIG_ATT_SELF_POWERED),\n    usb_power_ma(500), webusb_enabled(USB_WEBUSB_ENABLED), webusb_url(USB_WEBUSB_URL), _started(false), _task_stack_size(task_stack_size),\n    _event_task_priority(event_task_priority) {\n  if (!arduino_usb_event_loop_handle) {\n    esp_event_loop_args_t event_task_args = {\n      .queue_size = 5,\n      .task_name = \\\"arduino_usb_events\\\",\n      .task_priority = _event_task_priority,\n      .task_stack_size = _task_stack_size,\n      .task_core_id = tskNO_AFFINITY\n    };\n    if (esp_event_loop_create(&event_task_args, &arduino_usb_event_loop_handle) != ESP_OK) {\n      log_e(\\\"esp_event_loop_create failed\\\");\n    }\n  }\n}\n", "CodeBleu_score": 37.441755404564354}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tPUSB::ESPUSB(size_t task_stack_size, uint8_t event_task_priority)\n  : vid(USB_VID), pid(USB_PID), product_name(USB_PRODUCT), manufacturer_name(USB_MANUFACTURER), serial_number(USB_SERIAL), fw_version(0x0100),\n    usb_version(0x0200)  // at least 2.1 or 3.x for BOS & webUSB\n    ,\n    usb_class(TUSB_CLASS_MISC), usb_subclass(MISC_SUBCLASS_COMMON), usb_protocol(MISC_PROTOCOL_IAD), usb_attributes(TUSB_DESC_CONFIG_ATT_SELF_POWERED),\n    usb_power_ma(500), webusb_enabled(USB_WEBUSB_ENABLED), webusb_url(USB_WEBUSB_URL), _started(false), _task_stack_size(task_stack_size),\n    _event_task_priority(event_task_priority) {\n  if (!arduino_usb_event_loop_handle) {\n    esp_event_loop_args_t event_task_args = {\n      .queue_size = 5,\n      .task_name = \\\"arduino_usb_events\\\",\n      .task_priority = _event_task_priority,\n      .task_stack_size = _task_stack_size,\n      .task_core_id = tskNO_AFFINITY\n    };\n    if (esp_event_loop_create(&event_task_args, &arduino_usb_event_loop_handle) != ESP_OK) {\n      log_e(\\\"esp_event_loop_create failed\\\");\n    }\n  }\n}\n", "CodeBleu_score": 37.441755404564354}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tPUSB::ESPUSB(size_t task_stack_size, uint8_t event_task_priority)\n  : vid(USB_VID), pid(USB_PID), product_name(USB_PRODUCT), manufacturer_name(USB_MANUFACTURER), serial_number(USB_SERIAL), fw_version(0x0100),\n    usb_version(0x0200)  // at least 2.1 or 3.x for BOS & webUSB\n    ,\n    usb_class(TUSB_CLASS_MISC), usb_subclass(MISC_SUBCLASS_COMMON), usb_protocol(MISC_PROTOCOL_IAD), usb_attributes(TUSB_DESC_CONFIG_ATT_SELF_POWERED),\n    usb_power_ma(500), webusb_enabled(USB_WEBUSB_ENABLED), webusb_url(USB_WEBUSB_URL), _started(false), _task_stack_size(task_stack_size),\n    _event_task_priority(event_task_priority) {\n  if (!arduino_usb_event_loop_handle) {\n    esp_event_loop_args_t event_task_args = {\n      .queue_size = 5,\n      .task_name = \\\"arduino_usb_events\\\",\n      .task_priority = _event_task_priority,\n      .task_stack_size = _task_stack_size,\n      .task_core_id = tskNO_AFFINITY\n    };\n    if (esp_event_loop_create(&event_task_args, &arduino_usb_event_loop_handle) != ESP_OK) {\n      log_e(\\\"esp_event_loop_create failed\\\");\n    }\n  }\n}\n", "CodeBleu_score": 37.441755404564354}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t0; i < copySize; i++) {\n            uint8_t ch = 0;\n            xQueueReceive(rx_queue, &ch, 0);\n            if (!xQueueSend(new_rx_queue, &ch, 0)) {\n              arduino_usb_cdc_event_data_t p;\n              p.rx_overflow.dropped_bytes = copySize - i;\n              arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n              log_e(\\\"CDC RX Overflow.\\\");\n              break;\n            }\n          }\n        }", "CodeBleu_score": 35.86730795853498}, {"code": "void USBCDC::_onRX(){\n\t0; i < copySize; i++) {\n            uint8_t ch = 0;\n            xQueueReceive(rx_queue, &ch, 0);\n            if (!xQueueSend(new_rx_queue, &ch, 0)) {\n              arduino_usb_cdc_event_data_t p;\n              p.rx_overflow.dropped_bytes = copySize - i;\n              arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n              log_e(\\\"CDC RX Overflow.\\\");\n              break;\n            }\n          }\n        }", "CodeBleu_score": 35.86730795853498}, {"code": "void USBCDC::_onRX(){\n\t0; i < copySize; i++) {\n            uint8_t ch = 0;\n            xQueueReceive(rx_queue, &ch, 0);\n            if (!xQueueSend(new_rx_queue, &ch, 0)) {\n              arduino_usb_cdc_event_data_t p;\n              p.rx_overflow.dropped_bytes = copySize - i;\n              arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n              log_e(\\\"CDC RX Overflow.\\\");\n              break;\n            }\n          }\n        }", "CodeBleu_score": 35.86730795853498}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tn}", "CodeBleu_score": 6.732822916177208}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tn}", "CodeBleu_score": 6.732822916177208}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tn}", "CodeBleu_score": 6.732822916177208}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t/:a\\\", a.robeaux)\n}", "CodeBleu_score": 3.6292410274637144}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t/:a\\\", a.robeaux)\n}", "CodeBleu_score": 3.6292410274637144}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t/:a\\\", a.robeaux)\n}", "CodeBleu_score": 3.6292410274637144}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\\\": gobot.NewJSONMaster(a.master).Commands}", "CodeBleu_score": 5.554519118485905}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\\\": gobot.NewJSONMaster(a.master).Commands}", "CodeBleu_score": 5.554519118485905}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\\\": gobot.NewJSONMaster(a.master).Commands}", "CodeBleu_score": 5.554519118485905}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.46233194456654}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconst basicAuthPrefix string = \"Basic \"\n\n\t\t// Get the Basic Authentication credentials\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Check whether the credentials match\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(basicAuthPrefix+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)))) != 1 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler\n\t\tr.Header.Del(\"Authorization\")\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 54.55668087989191}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconst basicAuthPrefix string = \"Basic \"\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif strings.HasPrefix(auth, basicAuthPrefix) {\n\t\t\t// Check credentials\n\t\t\tpayload, err := base64.StdEncoding.DecodeString(auth[len(basicAuthPrefix):])\n\t\t\tif err == nil {\n\t\t\t\tpair := bytes.SplitN(payload, []byte(\":\"), 2)\n\t\t\t\tif len(pair) == 2 && subtle.ConstantTimeCompare(pair[0], []byte(username)) == 1 && subtle.ConstantTimeCompare(pair[1], []byte(password)) == 1 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Request Basic Authentication otherwise\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 49.90272850131373}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\n//\t\\\"WithName\\\"", "CodeBleu_score": 2.8089516377280894}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\n//\t\\\"WithName\\\"", "CodeBleu_score": 2.8089516377280894}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\n//\t\\\"WithName\\\"", "CodeBleu_score": 2.8089516377280894}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.89758457915693}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(SoundDetected)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(SoundDetected), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.55779767180317}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.89758457915693}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\tif err := d.writeByteData(regCommand, cmdSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&cmdPowerDownBit == cmdPowerDownBit {\n\t\treturn errors.New(\"device did not reset in time\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 77.46607551576989}, {"code": "func (d *MFRC522Common) softReset() error{\n\tif err := d.writeByteData(regCommand, cmdPCDSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tif val, err := d.readByteData(regCommand); err != nil {\n\t\treturn err\n\t} else if val&cmdPCDSoftReset != 0 {\n\t\treturn errors.New(\"soft reset took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 72.57881511269865}, {"code": "func (d *MFRC522Common) softReset() error{\n\tif err := d.writeByteData(regCommand, commandRegSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&commandRegPowerDownBit != 0 {\n\t\treturn errors.New(\"soft reset did not complete\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 81.47454854063825}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tBit | comIEnRegLoAlertIEnBit\n\t\tirqEn = irqEn | comIEnRegIdleIEnBit | comIEnRegRxIEnBit | comIEnRegTxIEnBit\n\t\twaitIRq = uint8(comIrqRegIdleIRqBit | comIrqRegRxIRqBit)\n\t}", "CodeBleu_score": 9.327571310988032}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tBit | comIEnRegLoAlertIEnBit\n\t\tirqEn = irqEn | comIEnRegIdleIEnBit | comIEnRegRxIEnBit | comIEnRegTxIEnBit\n\t\twaitIRq = uint8(comIrqRegIdleIRqBit | comIrqRegRxIRqBit)\n\t}", "CodeBleu_score": 9.327571310988032}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tBit | comIEnRegLoAlertIEnBit\n\t\tirqEn = irqEn | comIEnRegIdleIEnBit | comIEnRegRxIEnBit | comIEnRegTxIEnBit\n\t\twaitIRq = uint8(comIrqRegIdleIRqBit | comIrqRegRxIRqBit)\n\t}", "CodeBleu_score": 9.327571310988032}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t.\n\tpiccCommandMFRegAUTHRegKEYRegA = 0x60 // Perform authentication with Key A\n\tpiccCommandMFRegAUTHRegKEYRegB = 0x61 // Perform authentication with Key B\n\t// Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\n\tpiccCommandMFRegREAD = 0x30\n\t// Writes one 16 byte block to the authenticated sector of the PICC. Called \\\"COMPATIBILITY WRITE\\\" for MIFARE Ultralight.\n\tpiccCommandMFRegWRITE     = 0xA0\n\tpiccWriteAck              = 0x0A // MIFARE Classic: 4 bit ACK, we use any other value as NAK (data sheet: 0h to 9h, Bh to Fh)\n\tpiccCommandMFRegDECREMENT = 0xC0 // Decrements the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegINCREMENT = 0xC1 // Increments the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegRESTORE   = 0xC2 // Reads the contents of a block into the internal data register.\n\tpiccCommandMFRegTRANSFER  = 0xB0 // Writes the contents of the internal data register to a block.\n\t// The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/dataRegsheet/MF0ICU1.pdf, Section 8.6)\n\t// The piccCommandMFRegREAD and piccCommandMFRegWRITE can also be used for MIFARE Ultralight.\n\t// piccCommandULRegWRITE = 0xA2 // Writes one 4 byte page to the PICC.", "CodeBleu_score": 12.29336851369342}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t.\n\tpiccCommandMFRegAUTHRegKEYRegA = 0x60 // Perform authentication with Key A\n\tpiccCommandMFRegAUTHRegKEYRegB = 0x61 // Perform authentication with Key B\n\t// Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\n\tpiccCommandMFRegREAD = 0x30\n\t// Writes one 16 byte block to the authenticated sector of the PICC. Called \\\"COMPATIBILITY WRITE\\\" for MIFARE Ultralight.\n\tpiccCommandMFRegWRITE     = 0xA0\n\tpiccWriteAck              = 0x0A // MIFARE Classic: 4 bit ACK, we use any other value as NAK (data sheet: 0h to 9h, Bh to Fh)\n\tpiccCommandMFRegDECREMENT = 0xC0 // Decrements the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegINCREMENT = 0xC1 // Increments the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegRESTORE   = 0xC2 // Reads the contents of a block into the internal data register.\n\tpiccCommandMFRegTRANSFER  = 0xB0 // Writes the contents of the internal data register to a block.\n\t// The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/dataRegsheet/MF0ICU1.pdf, Section 8.6)\n\t// The piccCommandMFRegREAD and piccCommandMFRegWRITE can also be used for MIFARE Ultralight.\n\t// piccCommandULRegWRITE = 0xA2 // Writes one 4 byte page to the PICC.", "CodeBleu_score": 12.29336851369342}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t.\n\tpiccCommandMFRegAUTHRegKEYRegA = 0x60 // Perform authentication with Key A\n\tpiccCommandMFRegAUTHRegKEYRegB = 0x61 // Perform authentication with Key B\n\t// Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\n\tpiccCommandMFRegREAD = 0x30\n\t// Writes one 16 byte block to the authenticated sector of the PICC. Called \\\"COMPATIBILITY WRITE\\\" for MIFARE Ultralight.\n\tpiccCommandMFRegWRITE     = 0xA0\n\tpiccWriteAck              = 0x0A // MIFARE Classic: 4 bit ACK, we use any other value as NAK (data sheet: 0h to 9h, Bh to Fh)\n\tpiccCommandMFRegDECREMENT = 0xC0 // Decrements the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegINCREMENT = 0xC1 // Increments the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegRESTORE   = 0xC2 // Reads the contents of a block into the internal data register.\n\tpiccCommandMFRegTRANSFER  = 0xB0 // Writes the contents of the internal data register to a block.\n\t// The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/dataRegsheet/MF0ICU1.pdf, Section 8.6)\n\t// The piccCommandMFRegREAD and piccCommandMFRegWRITE can also be used for MIFARE Ultralight.\n\t// piccCommandULRegWRITE = 0xA2 // Writes one 4 byte page to the PICC.", "CodeBleu_score": 12.29336851369342}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tData(regModWidth, modWidthRegReset); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00} // also called ATQA\n\tif err := d.piccRequest(piccCommandWakeUpA, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Printf(\\\"Card found: %v\n\n\\\", answer)\n\t}\n\tif err := d.piccHalt(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.49944193840323}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tData(regModWidth, modWidthRegReset); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00} // also called ATQA\n\tif err := d.piccRequest(piccCommandWakeUpA, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Printf(\\\"Card found: %v\n\n\\\", answer)\n\t}\n\tif err := d.piccHalt(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.49944193840323}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tData(regModWidth, modWidthRegReset); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00} // also called ATQA\n\tif err := d.piccRequest(piccCommandWakeUpA, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Printf(\\\"Card found: %v\n\n\\\", answer)\n\t}\n\tif err := d.piccHalt(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.49944193840323}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t, block}", "CodeBleu_score": 7.285898518018106}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t, block}", "CodeBleu_score": 7.285898518018106}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t, block}", "CodeBleu_score": 7.285898518018106}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\tstring\n", "CodeBleu_score": 1.7881658055722611}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tstring\n", "CodeBleu_score": 1.7881658055722611}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tstring\n", "CodeBleu_score": 1.7881658055722611}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\tbetween 2 consecutive measurements\n\thcsr04StartTransmitTimeout time.Duration = 100 * time.Millisecond // unfortunately takes sometimes longer than 60 ms\n\thcsr04ReceiveTimeout       time.Duration = 60 * time.Millisecond\n\thcsr04EmitTriggerDuration  time.Duration = 10 * time.Microsecond // according to specification\n\thcsr04MonitorUpdate        time.Duration = 200 * time.Millisecond\n\t// the resolution of the device is ~3 mm, which relates to 10 us (343 mm/ms = 0.343 mm/us)\n\t// the poll interval increases the reading interval to this value and adds around 3 mm inaccuracy\n\t// it takes only an effect for fast systems, because reading inputs is typically much slower, e.g. 30-50 us on raspi\n\t// so, using the internal edge detection with \\\"cdev\\\" is more precise\n\thcsr04PollInputIntervall time.Duration = 10 * time.Microsecond", "CodeBleu_score": 14.525785896520773}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\tbetween 2 consecutive measurements\n\thcsr04StartTransmitTimeout time.Duration = 100 * time.Millisecond // unfortunately takes sometimes longer than 60 ms\n\thcsr04ReceiveTimeout       time.Duration = 60 * time.Millisecond\n\thcsr04EmitTriggerDuration  time.Duration = 10 * time.Microsecond // according to specification\n\thcsr04MonitorUpdate        time.Duration = 200 * time.Millisecond\n\t// the resolution of the device is ~3 mm, which relates to 10 us (343 mm/ms = 0.343 mm/us)\n\t// the poll interval increases the reading interval to this value and adds around 3 mm inaccuracy\n\t// it takes only an effect for fast systems, because reading inputs is typically much slower, e.g. 30-50 us on raspi\n\t// so, using the internal edge detection with \\\"cdev\\\" is more precise\n\thcsr04PollInputIntervall time.Duration = 10 * time.Microsecond", "CodeBleu_score": 14.525785896520773}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\tbetween 2 consecutive measurements\n\thcsr04StartTransmitTimeout time.Duration = 100 * time.Millisecond // unfortunately takes sometimes longer than 60 ms\n\thcsr04ReceiveTimeout       time.Duration = 60 * time.Millisecond\n\thcsr04EmitTriggerDuration  time.Duration = 10 * time.Microsecond // according to specification\n\thcsr04MonitorUpdate        time.Duration = 200 * time.Millisecond\n\t// the resolution of the device is ~3 mm, which relates to 10 us (343 mm/ms = 0.343 mm/us)\n\t// the poll interval increases the reading interval to this value and adds around 3 mm inaccuracy\n\t// it takes only an effect for fast systems, because reading inputs is typically much slower, e.g. 30-50 us on raspi\n\t// so, using the internal edge detection with \\\"cdev\\\" is more precise\n\thcsr04PollInputIntervall time.Duration = 10 * time.Microsecond", "CodeBleu_score": 14.525785896520773}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t.", "CodeBleu_score": 6.696292702899796}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t.", "CodeBleu_score": 6.696292702899796}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t.", "CodeBleu_score": 6.696292702899796}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\tWithName\\\"", "CodeBleu_score": 5.784493156286427}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\tWithName\\\"", "CodeBleu_score": 5.784493156286427}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\tWithName\\\"", "CodeBleu_score": 5.784493156286427}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\taccess_token = os.getenv(\"PLATFORMIO_AUTH_ACCESS_TOKEN\")\n    if access_token:\n        return access_token\n    account = app.get_state_item(\"account\")\n    if not account:\n        raise AccountNotAuthorized()\n    auth = account.get(\"auth\")\n    if not auth:\n        raise AccountNotAuthorized()\n    if auth.get(\"expires_at\") > time.time():\n        return auth.get(\"access_token\")\n    if not auth.get(\"refresh_token\"):\n        raise AccountNotAuthorized()\n    self.refresh_authentication_token()\n    return auth.get(\"access_token\")\n\n", "CodeBleu_score": 36.71071644011678}, {"code": "def fetch_authentication_token(self)\n\ttry:\n        return os.getenv(\"PLATFORMIO_AUTH_TOKEN\")\n    except Exception as exc:\n        raise AccountNotAuthorized() from exc\n\n", "CodeBleu_score": 15.275480670843894}, {"code": "def fetch_authentication_token(self)\n\ttry:\n        return os.environ[\"PLATFORMIO_AUTH_TOKEN\"]\n    except KeyError:\n        pass\n    try:\n        account = app.get_state_item(\"account\")\n        if not account:\n            raise AccountNotAuthorized()\n        auth = account.get(\"auth\")\n        if not auth:\n            raise AccountNotAuthorized()\n        if time.time() < auth.get(\"expires_at\"):\n            return auth.get(\"access_token\")\n        if not auth.get(\"refresh_token\"):\n            raise AccountNotAuthorized()\n        result = self.post(\n            \"/v1/account/token\",\n            data={\"refresh_token\": auth.get(\"refresh_token\")},\n            headers={\"Authorization\": \"Bearer \" + auth.get(\"access_token\")},\n        )\n        auth.update(\n            {\n                \"access_token\": result[\"access_token\"],\n                \"refresh_token\": result[\"refresh_token\"],\n                \"expires_at\": time.time() + result[\"expires_in\"],\n            }\n        )\n        account[\"auth\"] = auth\n        app.set_state_item(\"account\", account)\n        return result[\"access_token\"]\n    except Exception as exc:\n        raise AccountNotAuthorized() from exc\n\n", "CodeBleu_score": 47.854760607751736}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\ttry:\n        refresh_token = self.get_refresh_token()\n    except AccountNotAuthorized:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 67.6533678931915}, {"code": "def logout(self)\n\ttry:\n        refresh_token = self.get_refresh_token()\n    except AccountError:\n        return True\n\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n\n    self.delete_local_session()\n    return True\n\n", "CodeBleu_score": 63.605917592103744}, {"code": "def logout(self)\n\ttry:\n        self.fetch_authentication_token()\n    except:  # pylint:disable=bare-except\n        return True\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % self.get_refresh_token()},\n        )\n    except AccountError:\n        pass\n    self.delete_local_session()\n    return True\n\n", "CodeBleu_score": 51.20598802194478}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tresult = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg:\n            continue\n        result.append(\n            {\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"url\": pkg.metadata.url if pkg.metadata.is_external else None,\n            }\n        )\n    return result\n\n", "CodeBleu_score": 52.166566181187605}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name, self.get_package_spec(name, options.get(\"version\")))\n        if not pkg:\n            continue\n        result.append({\"name\": pkg.metadata.name, \"version\": str(pkg.metadata.version)})\n        if pkg.metadata.spec.external:\n            result[-1][\"url\"] = pkg.metadata.spec.url\n    return result\n\n", "CodeBleu_score": 53.968844262677315}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name, self.get_package_spec(name, options.get(\"version\")))\n        if not pkg:\n            continue\n        result.append({\n            \"name\": pkg.metadata.name,\n            \"version\": str(pkg.metadata.version)\n        })\n        if pkg.metadata.spec.external:\n            result[-1][\"url\"] = pkg.metadata.spec.url\n    return result\n\n", "CodeBleu_score": 53.03921788344898}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tconfig = ProjectConfig.get_instance(env.get(\"PROJECT_CONFIG\"))\n    platform_spec = config.get(env.get(\"PIOENV\"), \"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env.get(\"PIOENV\"))\n    instance = cls.new(platform_spec, autoinstall)\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 27.060907889624037}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tproject_config = ProjectConfig.get_instance(env.get(\"PROJECT_CONFIG\"))\n    platform_spec = project_config.get_optional_dir(\"platformio\", env[\"PIOENV\"])\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env[\"PIOENV\"])\n    instance = cls.new(platform_spec, autoinstall)\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 25.734031227988556}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tconfig = ProjectConfig.get_instance()\n    platform_spec = config.get_optional_section(\"env:\" + env, \"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls.new(platform_spec, autoinstall)\n    instance.set_project_environment(env)\n    instance.configure_project_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 40.82941087705403}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire1.read();\n    }\n}", "CodeBleu_score": 90.69703617865814}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, (uint8_t)Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        *(Buff + i) = Wire1.read();\n    }\n}", "CodeBleu_score": 93.18706806230324}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire1.read();\n    }\n}", "CodeBleu_score": 90.69703617865814}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t8);\n    Write1Byte(0x28, ((buf & 0x0f) | (brightness << 4)));\n}", "CodeBleu_score": 6.356949172832146}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t8);\n    Write1Byte(0x28, ((buf & 0x0f) | (brightness << 4)));\n}", "CodeBleu_score": 6.356949172832146}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t8);\n    Write1Byte(0x28, ((buf & 0x0f) | (brightness << 4)));\n}", "CodeBleu_score": 6.356949172832146}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\tn{\n  tft.drawFastVLine(178, 0, 20, TFT_WHITE);\n  tft.setCursor(145, 21); tft.setTextColor(TFT_WHITE); tft.setTextSize(1); tft.print(text10); tft.print(set_channel);\n\n  key[4].initButton(&tft, // channel - box\n                        164,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"-\\\",\n                        2);\n  key[5].initButton(&tft, // channel + box\n                        193,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"+\\\",\n                        2);\n\n  key[4].setLabelDatum(1, 5, MC_DATUM);\n  key[5].setLabelDatum(1, 5, MC_DATUM);\n\n  key[4].drawButton();\n  key[5].drawButton();\n}\n", "CodeBleu_score": 17.158534246313724}, {"code": "int Display::scroll_line(uint32_t color){\n\tn{\n  tft.drawFastVLine(178, 0, 20, TFT_WHITE);\n  tft.setCursor(145, 21); tft.setTextColor(TFT_WHITE); tft.setTextSize(1); tft.print(text10); tft.print(set_channel);\n\n  key[4].initButton(&tft, // channel - box\n                        164,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"-\\\",\n                        2);\n  key[5].initButton(&tft, // channel + box\n                        193,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"+\\\",\n                        2);\n\n  key[4].setLabelDatum(1, 5, MC_DATUM);\n  key[5].setLabelDatum(1, 5, MC_DATUM);\n\n  key[4].drawButton();\n  key[5].drawButton();\n}\n", "CodeBleu_score": 17.158534246313724}, {"code": "int Display::scroll_line(uint32_t color){\n\tn{\n  tft.drawFastVLine(178, 0, 20, TFT_WHITE);\n  tft.setCursor(145, 21); tft.setTextColor(TFT_WHITE); tft.setTextSize(1); tft.print(text10); tft.print(set_channel);\n\n  key[4].initButton(&tft, // channel - box\n                        164,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"-\\\",\n                        2);\n  key[5].initButton(&tft, // channel + box\n                        193,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"+\\\",\n                        2);\n\n  key[4].setLabelDatum(1, 5, MC_DATUM);\n  key[5].setLabelDatum(1, 5, MC_DATUM);\n\n  key[4].drawButton();\n  key[5].drawButton();\n}\n", "CodeBleu_score": 17.158534246313724}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (this->has_ap) {\n    Serial.println(\"Evil Portal already running\");\n    return true;\n  }\n\n  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setupAP()) {\n    Serial.println(\"Evil Portal: Error setting up access points\");\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    Serial.println(\"Evil Portal: Error setting up HTML content\");\n    return false;\n  }\n\n  this->has_ap = true;\n  this->runServer = true;\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 51.73108501937095}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (ssids == nullptr || access_points == nullptr) {\n    return false;\n  }\n\n  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setHTML()) {\n    return false;\n  }\n\n  if (!this->setAccessPoints()) {\n    return false;\n  }\n\n  this->runServer = true;\n  this->startServer();\n\n  return true;\n}", "CodeBleu_score": 54.83423852414451}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (ssids == NULL || access_points == NULL) {\n    Serial.println(\"Evil Portal Failed: No SSIDs or Access Points\");\n    return false;\n  }\n\n  if (ssids->size() == 0 || access_points->size() == 0) {\n    Serial.println(\"Evil Portal Failed: No SSIDs or Access Points\");\n    return false;\n  }\n\n  if (!this->setSSIDs(ssids)) {\n    Serial.println(\"Evil Portal Failed: SSIDs could not be set\");\n    return false;\n  }\n\n  if (!this->setAccessPoints(access_points)) {\n    Serial.println(\"Evil Portal Failed: Access Points could not be set\");\n    return false;\n  }\n\n  this->runServer = true;\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 48.803006699830796}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tmea_sentence = std::string(nmea.getSentence());\n\n  if(nmea_sentence.length()){\n    this->notimp_nmea_sentence = nmea_sentence.c_str();\n\n    bool unparsed=1;\n    bool enqueue=1;\n\n    char system=nmea.getTalkerID();\n    String msg_id=nmea.getMessageID();\n    int length=nmea_sentence.length();\n\n    if(length>0&&length<256){\n      if(system){\n        if(msg_id==\\\"TXT\\\"){\n          if(length>8){\n            std::string content=nmea_sentence.substr(7,std::string::npos);\n\n            int tot_brk=content.find(',');\n            int num_brk=content.find(',',tot_brk+1);\n            int txt_brk=content.find(',',num_brk+1);\n            int chk_brk=content.rfind('*');\n\n            if(tot_brk!=std::string::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(unparsed)\n      this->notparsed_nmea_sentence = nmea_sentence.c_str();\n\n    if(this->queue_enabled_flag){\n      if(enqueue){\n        nmea_sentence_t line = { unparsed, msg_id, nmea_sentence.c_str() };\n\n        if(this->queue){\n          #ifdef GPS_NMEA_MAXQUEUE\n            if(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n          #else\n            if(this->queue->size()>=30)\n          #endif\n              this->flush_queue();\n        }\n        else\n           this->new_queue();\n\n        this->queue->add(line);\n      }\n      else\n        if(!this->queue)\n          this->new_queue();\n    }\n    else\n      this->flush_queue();\n  }\n  else\n    if(!this->queue_enabled_flag)\n      this->flush_queue();\n}\n\n\n\n", "CodeBleu_score": 31.61340024592125}, {"code": "void GpsInterface::enable_queue(){\n\tmea_sentence = std::string(nmea.getSentence());\n\n  if(nmea_sentence.length()){\n    this->notimp_nmea_sentence = nmea_sentence.c_str();\n\n    bool unparsed=1;\n    bool enqueue=1;\n\n    char system=nmea.getTalkerID();\n    String msg_id=nmea.getMessageID();\n    int length=nmea_sentence.length();\n\n    if(length>0&&length<256){\n      if(system){\n        if(msg_id==\\\"TXT\\\"){\n          if(length>8){\n            std::string content=nmea_sentence.substr(7,std::string::npos);\n\n            int tot_brk=content.find(',');\n            int num_brk=content.find(',',tot_brk+1);\n            int txt_brk=content.find(',',num_brk+1);\n            int chk_brk=content.rfind('*');\n\n            if(tot_brk!=std::string::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(unparsed)\n      this->notparsed_nmea_sentence = nmea_sentence.c_str();\n\n    if(this->queue_enabled_flag){\n      if(enqueue){\n        nmea_sentence_t line = { unparsed, msg_id, nmea_sentence.c_str() };\n\n        if(this->queue){\n          #ifdef GPS_NMEA_MAXQUEUE\n            if(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n          #else\n            if(this->queue->size()>=30)\n          #endif\n              this->flush_queue();\n        }\n        else\n           this->new_queue();\n\n        this->queue->add(line);\n      }\n      else\n        if(!this->queue)\n          this->new_queue();\n    }\n    else\n      this->flush_queue();\n  }\n  else\n    if(!this->queue_enabled_flag)\n      this->flush_queue();\n}\n\n\n\n", "CodeBleu_score": 31.61340024592125}, {"code": "void GpsInterface::enable_queue(){\n\tmea_sentence = std::string(nmea.getSentence());\n\n  if(nmea_sentence.length()){\n    this->notimp_nmea_sentence = nmea_sentence.c_str();\n\n    bool unparsed=1;\n    bool enqueue=1;\n\n    char system=nmea.getTalkerID();\n    String msg_id=nmea.getMessageID();\n    int length=nmea_sentence.length();\n\n    if(length>0&&length<256){\n      if(system){\n        if(msg_id==\\\"TXT\\\"){\n          if(length>8){\n            std::string content=nmea_sentence.substr(7,std::string::npos);\n\n            int tot_brk=content.find(',');\n            int num_brk=content.find(',',tot_brk+1);\n            int txt_brk=content.find(',',num_brk+1);\n            int chk_brk=content.rfind('*');\n\n            if(tot_brk!=std::string::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(unparsed)\n      this->notparsed_nmea_sentence = nmea_sentence.c_str();\n\n    if(this->queue_enabled_flag){\n      if(enqueue){\n        nmea_sentence_t line = { unparsed, msg_id, nmea_sentence.c_str() };\n\n        if(this->queue){\n          #ifdef GPS_NMEA_MAXQUEUE\n            if(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n          #else\n            if(this->queue->size()>=30)\n          #endif\n              this->flush_queue();\n        }\n        else\n           this->new_queue();\n\n        this->queue->add(line);\n      }\n      else\n        if(!this->queue)\n          this->new_queue();\n    }\n    else\n      this->flush_queue();\n  }\n  else\n    if(!this->queue_enabled_flag)\n      this->flush_queue();\n}\n\n\n\n", "CodeBleu_score": 31.61340024592125}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tstring::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }", "CodeBleu_score": 45.065097107500186}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tstring::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }", "CodeBleu_score": 45.065097107500186}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tstring::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }", "CodeBleu_score": 45.065097107500186}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t x, y;\n    uint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n    uint16_t x_end = area->x2;\n    uint16_t y_end = area->y2;\n\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.pushColors(&color_p->full, w * h, true);\n    display_obj.tft.endWrite();\n\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 55.850435338609614}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t x, y, w, h;\n    uint8_t *buf_u8 = (uint8_t *)color_p;\n    uint16_t *buf_u16 = (uint16_t *)color_p;\n    w = (area->x2 - area->x1 + 1);\n    h = (area->y2 - area->y1 + 1);\n    if (display_obj.tft.getRotation() == 0) {\n      display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    } else if (display_obj.tft.getRotation() == 1) {\n      display_obj.tft.setAddrWindow(display_obj.tft.width() - area->y2 - 1, area->x1, h, w);\n    } else if (display_obj.tft.getRotation() == 2) {\n      display_obj.tft.setAddrWindow(display_obj.tft.width() - area->x2 - 1, display_obj.tft.height() - area->y2 - 1, w, h);\n    } else if (display_obj.tft.getRotation() == 3) {\n      display_obj.tft.setAddrWindow(area->y1, display_obj.tft.height() - area->x2 - 1, h, w);\n    }\n    display_obj.tft.startWrite();\n    if (display_obj.tft.getColorMode() == TFT_COLOR_MODE_RGB) {\n      for (y = h; y > 0; y--) {\n        for (x = w; x > 0; x--) {\n          display_obj.tft.writePixel(color_p->ch.red, color_p->ch.green, color_p->ch.blue);\n          color_p++;\n        }\n        color_p += (LV_HOR_RES - w);\n      }\n    } else {\n      for (y = h; y > 0; y--) {", "CodeBleu_score": 49.28304623274505}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t x, y;\n    uint16_t width = (area->x2 - area->x1 + 1);\n    uint16_t height = (area->y2 - area->y1 + 1);\n    uint16_t *color_p16 = (uint16_t *)color_p;\n    uint16_t *color_p2;\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, width, height);\n    display_obj.tft.pushColors(&color_p16[width * (height - 1)], width * height, true);\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 54.072921065864385}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tleased())\n                delay(1);\n            }", "CodeBleu_score": 4.745305172214724}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tleased())\n                delay(1);\n            }", "CodeBleu_score": 4.745305172214724}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tleased())\n                delay(1);\n            }", "CodeBleu_score": 4.745305172214724}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t_obj.append(wardrive_line);\n              }", "CodeBleu_score": 4.6547414698816665}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t_obj.append(wardrive_line);\n              }", "CodeBleu_score": 4.6547414698816665}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t_obj.append(wardrive_line);\n              }", "CodeBleu_score": 4.6547414698816665}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print('Topic created: {}'.format(topic))\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)", "CodeBleu_score": 58.84444930080678}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)", "CodeBleu_score": 78.60092232133394}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 58.84444930080678}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        str(message.payload.decode('utf-8')), message.topic,\n        str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        print('capturing image')\n        #capture_image()\n        #upload_image()\n        #publish_image_url()\n        print('published image')\n    else:\n        print('off')\n\n", "CodeBleu_score": 30.43790617112044}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('on_message', message.topic, message.qos, str(message.payload))\n\n    # If the message is \"on\", capture a preview image, upload it to a bucket, and publish the URL to an MQTT event topic.\n    if message.payload == b'on':\n        print('Capturing image...')\n        # Capture a preview image from the camera.\n        # This returns a tuple containing the image data and the timestamp.\n        image, timestamp = camera.capture_preview()\n\n        # Save the image to a file.\n        # This is useful for debugging so you can see the image captured by the camera.\n        filename = '{}.jpg'.format(timestamp)\n        with open(filename, 'wb') as out:\n            out.write(image)\n\n        # Upload the image to a bucket.\n        bucket = storage.Client().get_bucket(BUCKET)\n        blob = bucket.blob(filename)\n        blob.upload_from_file(open(filename, 'rb'))\n\n        # The event topic is the same as the state topic, but with '/events' appended.\n        # The message payload is the URL of the image file in the bucket.\n        mqtt_client.publish(\n            event_topic, 'https://storage.googleapis.com/{}/{}'.format(BUCKET, filename), qos=1)\n\n    # If the message is not \"on\", just print \"off\".\n    elif message.payload == b'off':\n        print('off')\n\n", "CodeBleu_score": 41.14902594044779}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        str(message.payload.decode('utf-8')), message.topic, str(message.qos)))\n    if str(message.payload.decode('utf-8')) == 'on':\n        print('capturing preview image')\n        # capture preview image\n        os.system('fswebcam -r 640x480 --no-banner /home/pi/Desktop/image.jpg')\n        # upload preview image to bucket\n        print('uploading image to bucket')\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket('cloud-iot-images')\n        blob = bucket.blob('image.jpg')\n        blob.upload_from_filename('/home/pi/Desktop/image.jpg')\n        # get url of image\n        url = 'https://storage.googleapis.com/cloud-iot-images/image.jpg'\n        print('image url: {}'.format(url))\n        # publish image url to event topic\n        print('publishing image url')\n        client.publish('events', url, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 48.76255784094145}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name.')\n    parser.add_argument('--subscription_name', required=True, help='Google Pub/Sub subscription name.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 42.816212639993815}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name')\n    parser.add_argument('--subscription', required=True, help='Google Cloud Pub/Sub subscription name')\n    args = parser.parse_args()\n    return args\n", "CodeBleu_score": 47.81001695483498}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name')\n    parser.add_argument('--subscription_name', required=True, help='Google Cloud Pub/Sub subscription name')\n    parser.add_argument('--service_account_json', required=True, help='Path to service account json')\n    return parser.parse_args()\n\n", "CodeBleu_score": 46.272472853872266}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t# Set the required scopes\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n    # Set the discovery URL\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json\n    )\n    # Scoping the credentials to the required scopes\n    scoped_credentials = credentials.with_scopes(scopes)\n    # Create the client\n    client = discovery.build(\n        \"cloudiot\",\n        \"v1\",\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials,\n    )\n    return client\n\n", "CodeBleu_score": 23.964353319365973}, {"code": "def get_client(service_account_json)\n\t# Set the scopes\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n\n    # Build the credentials from the service account file\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Build the Google Cloud IoT Core API client\n    client = discovery.build(\n        \"cloudiot\", \"v1\", credentials=credentials, discoveryServiceUrl=DISCOVERY_URL\n    )\n\n    return client\n\n", "CodeBleu_score": 19.737001264176595}, {"code": "def get_client(service_account_json)\n\t# Scopes for the IoT Core service\n    scopes = ['https://www.googleapis.com/auth/cloud-platform',\n              'https://www.googleapis.com/auth/pubsub']\n    # Set the version of the API\n    version = 'v1'\n    # Discovery URL for the Cloud IoT Core service\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    # Scoping the credentials\n    credentials = credentials.with_scopes(scopes)\n    # Build the client\n    client = discovery.build(\n        'cloudiot',\n        version,\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials)\n    return client\n\n", "CodeBleu_score": 28.279789537154663}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \\\"\\\"\\\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    # Get random padding\n    padding = b''\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b'\\x00', b'')\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b''.join([b'\\x00\\x02',\n                     padding,\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 15.777389071229123}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \\\"\\\"\\\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    # Get random padding\n    padding = b''\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b'\\x00', b'')\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b''.join([b'\\x00\\x02',\n                     padding,\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 15.777389071229123}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \\\"\\\"\\\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    # Get random padding\n    padding = b''\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b'\\x00', b'')\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b''.join([b'\\x00\\x02',\n                     padding,\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 15.777389071229123}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 2.38466773815437}, {"code": "def verify(message, signature, pub_key)\n\t''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 2.38466773815437}, {"code": "def verify(message, signature, pub_key)\n\t''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 2.38466773815437}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    epoch = getTime();\n    if (epoch != 0) {\n        updateJWT(epoch);\n    }\n    imqtt_connect();\n    sendSubscribe = true;\n    debug_printInfo(\"CLOUD: MQTT Connection Attempted\");\n}", "CodeBleu_score": 29.59883212364445}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    bool timeValid = false;\n    timeValid = getEpochTime(&epoch);\n    if (timeValid) {\n        updateJWT(epoch);\n    }\n    if (connectMQTTSocket()) {\n        sendSubscribe = true;\n        debug_printInfo(\"CLOUD: MQTT Connection Attempt\");\n    } else {\n        debug_printError(\"CLOUD: MQTT Connection Failed\");\n    }\n}", "CodeBleu_score": 22.44876118144843}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    uint32_t epoch_temp = 0;\n\n    // Get the current time\n    epoch = getTime();\n\n    // If the time is valid, update the JWT\n    if (epoch != 0) {\n        epoch_temp = epoch + UNIX_OFFSET;\n        updateJWT(epoch_temp);\n    }\n\n    // Connect to the MQTT client\n    imqtt_connect();\n\n    // Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n    sendSubscribe = true;\n\n    // Print a debug message indicating the MQTT connection attempt\n    debug_printInfo(\"CLOUD: Connecting to MQTT\");\n}", "CodeBleu_score": 54.13298681262726}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tformat >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])\n    {\n        *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n    if (formatted_date == NULL)\n    {\n        return ATCACERT_E_SUCCESS;  // Caller just wanted\n\n    }\n    switch (format)\n    {\n    case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);\n    case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);\n    case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);\n    default: return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return ATCACERT_E_BAD_PARAMS;\n}", "CodeBleu_score": 31.399275423817564}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tformat >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])\n    {\n        *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n    if (formatted_date == NULL)\n    {\n        return ATCACERT_E_SUCCESS;  // Caller just wanted\n\n    }\n    switch (format)\n    {\n    case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);\n    case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);\n    case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);\n    default: return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return ATCACERT_E_BAD_PARAMS;\n}", "CodeBleu_score": 31.399275423817564}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tformat >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])\n    {\n        *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n    if (formatted_date == NULL)\n    {\n        return ATCACERT_E_SUCCESS;  // Caller just wanted\n\n    }\n    switch (format)\n    {\n    case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);\n    case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);\n    case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);\n    default: return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return ATCACERT_E_BAD_PARAMS;\n}", "CodeBleu_score": 31.399275423817564}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t_size)\n    {\n        *build_state->cert_size = build_state->cert_def->cert_template_size;\n        return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template\n    }\n\n    // Initialize the cert buffer with the cert template\n    *build_state->cert_size = build_state->cert_def->cert_template_size;\n    memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        // Set a fake signature that should result in the largest X.509 cert. This will ensure\n        // the cert buffer is large enough early in the cert rebuilding process.\n        uint8_t large_sig[64];\n        memset(large_sig, 0xFF, sizeof(large_sig));\n        ret = atcacert_set_signature(\n            build_state->cert_def,\n            build_state->cert,\n            build_state->cert_size,\n            build_state->max_cert_size,\n            large_sig);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (ca_public_key != NULL)\n    {\n        // Set the authority key ID\n        ret = atcacert_set_auth_key_id(\n            build_state->cert_def,\n            build_state->cert,\n            *build_state->cert_size,\n            ca_public_key);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 52.99749563677628}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t_size)\n    {\n        *build_state->cert_size = build_state->cert_def->cert_template_size;\n        return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template\n    }\n\n    // Initialize the cert buffer with the cert template\n    *build_state->cert_size = build_state->cert_def->cert_template_size;\n    memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        // Set a fake signature that should result in the largest X.509 cert. This will ensure\n        // the cert buffer is large enough early in the cert rebuilding process.\n        uint8_t large_sig[64];\n        memset(large_sig, 0xFF, sizeof(large_sig));\n        ret = atcacert_set_signature(\n            build_state->cert_def,\n            build_state->cert,\n            build_state->cert_size,\n            build_state->max_cert_size,\n            large_sig);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (ca_public_key != NULL)\n    {\n        // Set the authority key ID\n        ret = atcacert_set_auth_key_id(\n            build_state->cert_def,\n            build_state->cert,\n            *build_state->cert_size,\n            ca_public_key);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 52.99749563677628}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t_size)\n    {\n        *build_state->cert_size = build_state->cert_def->cert_template_size;\n        return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template\n    }\n\n    // Initialize the cert buffer with the cert template\n    *build_state->cert_size = build_state->cert_def->cert_template_size;\n    memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        // Set a fake signature that should result in the largest X.509 cert. This will ensure\n        // the cert buffer is large enough early in the cert rebuilding process.\n        uint8_t large_sig[64];\n        memset(large_sig, 0xFF, sizeof(large_sig));\n        ret = atcacert_set_signature(\n            build_state->cert_def,\n            build_state->cert,\n            build_state->cert_size,\n            build_state->max_cert_size,\n            large_sig);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (ca_public_key != NULL)\n    {\n        // Set the authority key ID\n        ret = atcacert_set_auth_key_id(\n            build_state->cert_def,\n            build_state->cert,\n            *build_state->cert_size,\n            ca_public_key);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 52.99749563677628}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                 ret = 0;\n  uint8_t             tbs_digest[32];\n  uint8_t             signature[64];\n  const uint8_t*      tbs_digest_ptr = NULL;\n  size_t              tbs_digest_size = 0;\n  const uint8_t*      signature_ptr = NULL;\n  size_t              signature_size = 0;\n  uint8_t             public_key[72];\n  uint8_t             num_in[NONCE_NUMIN_SIZE];\n  uint8_t             rand_out[RANDOM_NUM_SIZE];\n  uint8_t             other_data[13];\n  atca_verify_in_out  verify_params;\n  uint8_t             mode = VERIFY_MODE_EXTERNAL | VERIFY_MODE_SOURCE_TEMPKEY;\n  uint16_t            key_id = 0;\n  atca_temp_key_t     temp_key;\n  uint8_t             sn[9];\n  size_t              sn_size = 0;\n\n  if (cert_def == NULL || cert == NULL || ca_public_key == NULL)\n    return ATCACERT_E_BAD_PARAMS;\n\n  // Verify the TBS digest against the signature using the CA public key\n  ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n  if (ret != ATCACERT_E_SUCCESS)\n    return ret;\n\n  // Get pointers to the TBS digest and signature within the certificate\n  ret = atcacert_get_tbs_digest_ptr(cert_def, cert, &tbs_digest_ptr, &tbs_digest_size);\n  if (ret != ATCACERT_E_SUCCESS)\n    return ret;\n  ret = atcacert_get_signature_ptr(cert_def, cert, &signature_ptr, &signature_size);\n  if (ret != ATCACERT_E_", "CodeBleu_score": 59.15391208221068}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                 ret = 0;\n    uint8_t             tbs_digest[32];\n    const uint8_t*      signature = NULL;\n    size_t              signature_size = 0;\n    uint8_t             raw_signature[64];\n    uint8_t             public_key[72];\n    atcacert_device_loc_t ca_public_key_loc;\n    atcacert_device_loc_t cert_loc;\n    uint8_t             ca_public_key_slot = 0;\n    uint8_t             cert_slot = 0;\n    uint8_t             cert_block = 0;\n    uint8_t             ca_public_key_block = 0;\n    uint8_t             ca_public_key_offset = 0;\n    uint8_t             cert_offset = 0;\n    uint8_t             ca_public_key_sn[9];\n    uint8_t             cert_sn[9];\n    uint8_t             ca_public_key_sn_len = 0;\n    uint8_t             cert_sn_len = 0;\n    uint8_t             ca_public_key_sn_source = 0;\n    uint8_t             cert_sn_source = 0;\n    uint8_t             ca_public_key_gen_key_id = 0;\n    uint8_t             cert_gen_key_id = 0;\n    uint8_t             ca_public_key_pub_key_id = 0;\n    uint8_t             cert_pub_key_id = 0;\n    uint8_t             ca_public_key_key_type = 0;\n    uint8_t             cert_key_type = 0;\n    uint8_t             ca_public_key_template_id = 0;\n    uint8_t             cert_template_id = 0;\n    uint8_t             ca_public_key_template_locked = 0;\n    uint8_t             cert_template_locked = 0;\n    uint8_t             ca_", "CodeBleu_score": 19.25630541795477}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                 ret = ATCACERT_E_SUCCESS;\n    int                 comp_result = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    uint8_t             public_key[72];\n    uint8_t             num_in[NONCE_NUMIN_SIZE];\n    uint8_t             rand_out[RANDOM_NUM_SIZE];\n    uint8_t             temp_key[32];\n    uint8_t             read_key[32];\n    uint8_t             io_key[32];\n    uint8_t             gen_dig[32];\n    uint8_t             is_verified = 0;\n    uint8_t             mode = 0x11;\n    uint16_t            key_id = 0;\n    uint16_t            key_len = 0;\n    uint16_t            public_key_size = 0;\n    uint16_t            cert_sn_size = 0;\n    uint16_t            cert_sn_pos = 0;\n    uint16_t            cert_sn_len = 0;\n    uint16_t            auth_key_id = 0;\n    uint16_t            comp_cert_size = 0;\n    uint16_t            comp_cert_pos = 0;\n    uint16_t            comp_cert_len = 0;\n    uint16_t            tbs_digest_size = 0;\n    uint16_t            tbs_digest_pos = 0;\n    uint16_t            tbs_digest_len = 0;\n    uint16_t            signature_size = 0;\n    uint16_t            signature_pos = 0;\n    uint16_t            signature_len = 0;\n    uint16_t            read_key_id = 0;\n    uint16_t            io_key_id = 0;\n    uint16_t            temp_key_id = 0;", "CodeBleu_score": 19.23373306387887}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t, SPECIAL, PUNITIVE,\n    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND\n    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS\n    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE\n    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN\n    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,\n    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.\n\n    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE\n    TERMS.", "CodeBleu_score": 23.59023188520335}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t, SPECIAL, PUNITIVE,\n    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND\n    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS\n    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE\n    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN\n    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,\n    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.\n\n    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE\n    TERMS.", "CodeBleu_score": 23.59023188520335}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t, SPECIAL, PUNITIVE,\n    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND\n    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS\n    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE\n    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN\n    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,\n    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.\n\n    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE\n    TERMS.", "CodeBleu_score": 23.59023188520335}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tProtocol;\n   int8_t wincSocketReturn;\n\n\tswitch ((bsdDomain_t)domain)\n\t{\n\t\tcase PF_INET:\n\t\t\twincDomain = WINC_AF_INET;\n\t\tbreak;\n\t\tdefault:\t// Domain Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((bsdTypes_t)type)\n\t{\n\t\tcase BSD_SOCK_STREAM:\n\t\t\twincType = WINC_STREAM;\n\t\tbreak;\n\t\tcase BSD_SOCK_DGRAM:\n\t\t\twincType = WINC_DGRAM;\n\t\tbreak;\n\t\tdefault:\t// Type Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((wincSupportedProtocol_t)protocol)\n\t{\n\t\tcase WINC_NON_TLS:\n\t\tcase WINC_TLS:\n\t\t\twincProtocol = protocol;\n\t\tbreak;\n\t\tdefault:\t// Protocol Not Implemented by WINC\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t}\n\n   wincSocketReturn = socket((uint16_t)wincDomain, (uint8_t)wincType, (uint8_t)wincProtocol);\n   if (wincSocketReturn < 0)\t\t\t   // WINC Socket Access Denied always returns -1 for failure to get socket\n\t{\n      debug_printError(\\\"BSD: wincSocketReturn (%d)\\\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\n   return wincSocketReturn;\t\t// >= 0 represents SUCCESS\n}", "CodeBleu_score": 42.98164313752098}, {"code": "int BSD_close(int socket){\n\tProtocol;\n   int8_t wincSocketReturn;\n\n\tswitch ((bsdDomain_t)domain)\n\t{\n\t\tcase PF_INET:\n\t\t\twincDomain = WINC_AF_INET;\n\t\tbreak;\n\t\tdefault:\t// Domain Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((bsdTypes_t)type)\n\t{\n\t\tcase BSD_SOCK_STREAM:\n\t\t\twincType = WINC_STREAM;\n\t\tbreak;\n\t\tcase BSD_SOCK_DGRAM:\n\t\t\twincType = WINC_DGRAM;\n\t\tbreak;\n\t\tdefault:\t// Type Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((wincSupportedProtocol_t)protocol)\n\t{\n\t\tcase WINC_NON_TLS:\n\t\tcase WINC_TLS:\n\t\t\twincProtocol = protocol;\n\t\tbreak;\n\t\tdefault:\t// Protocol Not Implemented by WINC\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t}\n\n   wincSocketReturn = socket((uint16_t)wincDomain, (uint8_t)wincType, (uint8_t)wincProtocol);\n   if (wincSocketReturn < 0)\t\t\t   // WINC Socket Access Denied always returns -1 for failure to get socket\n\t{\n      debug_printError(\\\"BSD: wincSocketReturn (%d)\\\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\n   return wincSocketReturn;\t\t// >= 0 represents SUCCESS\n}", "CodeBleu_score": 42.98164313752098}, {"code": "int BSD_close(int socket){\n\tProtocol;\n   int8_t wincSocketReturn;\n\n\tswitch ((bsdDomain_t)domain)\n\t{\n\t\tcase PF_INET:\n\t\t\twincDomain = WINC_AF_INET;\n\t\tbreak;\n\t\tdefault:\t// Domain Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((bsdTypes_t)type)\n\t{\n\t\tcase BSD_SOCK_STREAM:\n\t\t\twincType = WINC_STREAM;\n\t\tbreak;\n\t\tcase BSD_SOCK_DGRAM:\n\t\t\twincType = WINC_DGRAM;\n\t\tbreak;\n\t\tdefault:\t// Type Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((wincSupportedProtocol_t)protocol)\n\t{\n\t\tcase WINC_NON_TLS:\n\t\tcase WINC_TLS:\n\t\t\twincProtocol = protocol;\n\t\tbreak;\n\t\tdefault:\t// Protocol Not Implemented by WINC\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t}\n\n   wincSocketReturn = socket((uint16_t)wincDomain, (uint8_t)wincType, (uint8_t)wincProtocol);\n   if (wincSocketReturn < 0)\t\t\t   // WINC Socket Access Denied always returns -1 for failure to get socket\n\t{\n      debug_printError(\\\"BSD: wincSocketReturn (%d)\\\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\n   return wincSocketReturn;\t\t// >= 0 represents SUCCESS\n}", "CodeBleu_score": 42.98164313752098}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tSOCK_ERR_BUFFER_FULL:\n\t\t\t    debug_printError(\\\"BSD: BSD: ERR_BUFFER_FULL\\\");\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n            default:\n\t\t\t\tdebug_printError(\\\"BSD: BSD: (%d)\\\", wincRecvReturn);\n            break;\n\t\t}", "CodeBleu_score": 15.966994144638175}, {"code": "int BSD_listen(int socket, int backlog){\n\tSOCK_ERR_BUFFER_FULL:\n\t\t\t    debug_printError(\\\"BSD: BSD: ERR_BUFFER_FULL\\\");\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n            default:\n\t\t\t\tdebug_printError(\\\"BSD: BSD: (%d)\\\", wincRecvReturn);\n            break;\n\t\t}", "CodeBleu_score": 15.966994144638175}, {"code": "int BSD_listen(int socket, int backlog){\n\tSOCK_ERR_BUFFER_FULL:\n\t\t\t    debug_printError(\\\"BSD: BSD: ERR_BUFFER_FULL\\\");\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n            default:\n\t\t\t\tdebug_printError(\\\"BSD: BSD: (%d)\\\", wincRecvReturn);\n            break;\n\t\t}", "CodeBleu_score": 15.966994144638175}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t= close((SOCKET)socket);\n\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincCloseReturn)\n\t\t{\n\t\t   case WINC_SOCK_ERR_INVALID_ARG:\n\t\t       bsd_setErrNo(EBADF);\n\t\t   break;\n\t\t   case WINC_SOCK_ERR_INVALID:\n\t\t       bsd_setErrNo(EIO);\n\t\t   break;\n\t\t   default:\n\t\t   break;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n        return BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 34.17801179533329}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t= close((SOCKET)socket);\n\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincCloseReturn)\n\t\t{\n\t\t   case WINC_SOCK_ERR_INVALID_ARG:\n\t\t       bsd_setErrNo(EBADF);\n\t\t   break;\n\t\t   case WINC_SOCK_ERR_INVALID:\n\t\t       bsd_setErrNo(EIO);\n\t\t   break;\n\t\t   default:\n\t\t   break;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n        return BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 34.17801179533329}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t= close((SOCKET)socket);\n\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincCloseReturn)\n\t\t{\n\t\t   case WINC_SOCK_ERR_INVALID_ARG:\n\t\t       bsd_setErrNo(EBADF);\n\t\t   break;\n\t\t   case WINC_SOCK_ERR_INVALID:\n\t\t       bsd_setErrNo(EIO);\n\t\t   break;\n\t\t   default:\n\t\t   break;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n        return BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 34.17801179533329}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    uint8_t i = 0;\n    bool timeValid = false;\n\n    // Get the current time in UNIX format\n    timeValid = getUnixTime(&epoch);\n\n    if (timeValid) {\n        // Update the JWT with the current time offset\n        updateJWT(epoch);\n\n        // Connect to the MQTT broker\n        MQTT_Connect();\n\n        // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n        sendSubscribe = true;\n    }\n}", "CodeBleu_score": 24.31728908557094}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    uint32_t time = 0;\n\n    // Get the current time in UNIX format\n    time = CLOCK_getTime();\n\n    // Check if the time is valid\n    if (time != 0) {\n        // Update the JWT with the current time offset\n        epoch = time + UNIX_OFFSET;\n        updateJWT(epoch);\n\n        // Initiate the MQTT connection\n        MQTT_Connect();\n\n        // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n        sendSubscribe = true;\n\n        debug_printInfo(\"CLOUD: Connecting to MQTT broker...\");\n    } else {\n        debug_printError(\"CLOUD: Failed to get time\");\n    }\n}", "CodeBleu_score": 52.367747555223154}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    uint32_t currentTime = 0;\n    uint32_t currentTimeOffset = 0;\n\n    currentTime = time(NULL);\n    if (currentTime != 0) {\n        currentTimeOffset = currentTime - UNIX_OFFSET;\n        updateJWT(currentTimeOffset);\n        debug_printInfo(\"CLOUD: Connecting to MQTT\");\n        if (MQTT_Connect() == 0) {\n            sendSubscribe = true;\n            waitingForMQTT = false;\n            timeout_delete(&mqttTimeoutTaskTimer);\n        } else {\n            debug_printError(\"CLOUD: MQTT connection failed\");\n        }\n    } else {\n        debug_printError(\"CLOUD: Invalid time\");\n    }\n}", "CodeBleu_score": 55.68957807552785}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tTHE DAMAGES ARE FORESEEABLE. TO\n    THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL\n    CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT\n    OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS\n    SOFTWARE.", "CodeBleu_score": 31.015968715959158}, {"code": "void CLOUD_disconnect(void){\n\tTHE DAMAGES ARE FORESEEABLE. TO\n    THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL\n    CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT\n    OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS\n    SOFTWARE.", "CodeBleu_score": 31.015968715959158}, {"code": "void CLOUD_disconnect(void){\n\tTHE DAMAGES ARE FORESEEABLE. TO\n    THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL\n    CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT\n    OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS\n    SOFTWARE.", "CodeBleu_score": 31.015968715959158}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tbool success = false;\n\n    if (passed_wifi_creds == 1) {\n        tstrNetworkId networkId;\n        tstrAuthPsk psk;\n        strcpy((char *) networkId.pu8Bssid, (char *) credentials_get()->ssid);\n        networkId.enuChannel = M2M_WIFI_CH_ALL;\n        strcpy((char *) psk.au8Psk, (char *) credentials_get()->password);\n        if (M2M_SUCCESS != m2m_wifi_connect_psk(networkId, psk)) {\n            debug_printError(\"WIFI CONNECT: m2m_wifi_connect_psk failed\");\n            success = false;\n        } else {\n            success = true;\n        }\n    } else {\n        tstrNetworkId networkId;\n        strcpy((char *) networkId.pu8Bssid, (char *) DEFAULT_WIFI_SSID);\n        networkId.enuChannel = M2M_WIFI_CH_ALL;\n        if (M2M_SUCCESS != m2m_wifi_connect_psk(networkId, DEFAULT_WIFI_PSK)) {\n            debug_printError(\"WIFI CONNECT: m2m_wifi_connect_psk failed\");\n            success = false;\n        } else {\n            success = true;\n        }\n    }\n\n    return success;\n}", "CodeBleu_score": 40.73449843547421}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tbool success = false;\n    uint8_t retries = 0;\n    uint8_t retry_limit = 3;\n    uint8_t auth_type = 0;\n    uint8_t *ssid = NULL;\n    uint8_t *password = NULL;\n    uint8_t *domain = NULL;\n    uint8_t *ip = NULL;\n    uint8_t *netmask = NULL;\n    uint8_t *gateway = NULL;\n    uint8_t *dns = NULL;\n    uint8_t *dhcp = NULL;\n    uint8_t *wifi_creds = NULL;\n\n    if (passed_wifi_creds == 0) {\n        // Use default Wi-Fi credentials\n        wifi_creds = DEFAULT_WIFI_CREDENTIALS;\n    } else {\n        // Use new Wi-Fi credentials\n        wifi_creds = NEW_WIFI_CREDENTIALS;\n    }\n\n    // Read credentials from flash\n    ssid = &wifi_creds[0];\n    auth_type = wifi_creds[32];\n    password = &wifi_creds[33];\n    domain = &wifi_creds[65];\n    ip = &wifi_creds[97];\n    netmask = &wifi_creds[129];\n    gateway = &wifi_creds[161];\n    dns = &wifi_creds[193];\n    dhcp = &wifi_creds[225];\n\n    // Check if DHCP is enabled\n    if (dhcp[0] == '0') {\n        // DHCP is disabled, so use static IP\n        tstrM2MIPConfig ipconfig;\n        ipconfig.u8DHCPEnable = 0;\n        ipconfig.u8DNSACquire = 0;\n        memcpy(ipconfig.au8StaticIP, ip, 4);\n        memcpy(ipconfig.au8SubnetMask, netmask, 4);\n        memcpy(ipconfig.au8DNSServer, dns", "CodeBleu_score": 34.21901399589641}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\ttstrNetworkId  strNetworkId;\n    tstrAuthPsk     strAuthPsk;\n    uint8_t         u8SecType;\n    bool            bRet = false;\n    bool            bStartConnect = false;\n    uint8_t         u8WifiMode = M2M_WIFI_MODE_NORMAL;\n    uint8_t         u8WifiState = M2M_WIFI_DISCONNECTED;\n    tstrM2mWifiWepParams strWepParams;\n    tstrM2MWPSConnect strWPS;\n\n    // If credentials are provided, use them\n    if (passed_wifi_creds) {\n        strcpy((char *)strNetworkId.au8SSID, (char *)wifi_credentials.ssid);\n        strcpy((char *)strAuthPsk.au8PSK, (char *)wifi_credentials.password);\n        strNetworkId.u8SSIDLen = strlen((char *)wifi_credentials.ssid);\n        strAuthPsk.u8KeyLen = strlen((char *)wifi_credentials.password);\n\n        if (wifi_credentials.auth_type == WIFI_AUTH_OPEN) {\n            u8SecType = M2M_WIFI_SEC_OPEN;\n        } else if (wifi_credentials.auth_type == WIFI_AUTH_WPA_PSK) {\n            u8SecType = M2M_WIFI_SEC_WPA_PSK;\n        } else if (wifi_credentials.auth_type == WIFI_AUTH_WEP) {\n            u8SecType = M2M_WIFI_SEC_WEP;\n            strWepParams.u8KeyIndx = wifi_credentials.wep_key_id;\n            strWepParams.u8KeySz = strAuthPsk.u8KeyLen;\n            memcpy(strWepParams.au8WepKey, strAuthPsk.au8PSK, strWepParams.u8KeySz);\n        } else {\n            debug_printError", "CodeBleu_score": 35.626516803928965}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tvar client = generateClient('api')\n    var sensorData = await client.query({ query: listSensors })\n    console.log(sensorData)\n    if (sensorData.data.listSensors.items) {\n        console.log('Retrieved sensors:', sensorData.data.listSensors.items)\n        sensorData.data.listSensors.items.forEach((sensor) => {\n            var sensorMarker = CreateSensorMarker(sensor)\n            var marker = new Marker({\n                element: sensorMarker,\n                anchor: 'bottom',\n                offset: [0, -10]\n            })\n            marker.setLngLat([sensor.longitude, sensor.latitude])\n            map.addMarker(marker)\n        })\n    }\n}", "CodeBleu_score": 47.03600994172277}, {"code": "async function DisplaySensors(map){\n\t// Generate a client\n    const client = generateClient('REST', {});\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.query({\n        query: listSensors,\n        authMode: 'AMAZON_COGNITO_USER_POOLS'\n    });\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor\n    if (response.data.listSensors.items) {\n        console.log('Retrieved sensors');\n        response.data.listSensors.items.forEach((sensor) => {\n\n            // Create a marker for each sensor\n            var marker = CreateSensorMarker(sensor);\n\n            // Add the marker to the map\n            new Marker(marker)\n                .setLngLat([sensor.location.longitude, sensor.location.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 53.178801225636164}, {"code": "async function DisplaySensors(map){\n\tconst apiName = 'SensorDataApi';\n    const client = generateClient(apiName);\n    const response = await client.query({\n        query: listSensors\n    });\n    console.log('API response:', response);\n    if (response.data.listSensors.items.length > 0) {\n        console.log('Retrieved sensors:', response.data.listSensors.items);\n        response.data.listSensors.items.forEach(sensor => {\n            const marker = CreateSensorMarker(sensor);\n            new Marker({\n                element: marker,\n                anchor: 'bottom'\n            }).setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n        });\n    }\n}", "CodeBleu_score": 49.33875190005009}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tvar marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.background = \"#000000\";\n    marker.style.border = \"3px solid #000000\";\n    return marker;\n}", "CodeBleu_score": 46.984522189259714}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = 'white';\n    marker.style.border = '2px solid black';\n    return marker;\n}", "CodeBleu_score": 45.41611395206983}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = 'white';\n  marker.style.border = '3px solid blue';\n  return marker;\n}", "CodeBleu_score": 43.618477228772264}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    module = await async_import_module(module_path)\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    if requirements and not hass.config.skip_pip:\n        processed = hass.data.get(DATA_REQS, set())\n        if module_name not in processed:\n            await requirements.async_process_requirements(hass)\n            processed.add(module_name)\n            hass.data[DATA_REQS] = processed\n    return module\n\n", "CodeBleu_score": 32.64117843718334}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule = None\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import multi-factor module %s: %s\", module_name, err\n        )\n        raise\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\"MFA module %s missing required CONFIG_SCHEMA\", module_name)\n        raise HomeAssistantError(f\"MFA module {module_name} missing required CONFIG_SCHEMA\")\n    if not hasattr(module, \"SetupFlow\"):\n        _LOGGER.error(\"MFA module %s missing required SetupFlow\", module_name)\n        raise HomeAssistantError(f\"MFA module {module_name} missing required SetupFlow\")\n    if not hasattr(module, \"MultiFactorAuthModule\"):\n        _LOGGER.error(\"MFA module %s missing required MultiFactorAuthModule\", module_name)\n        raise HomeAssistantError(f\"MFA module {module_name} missing required MultiFactorAuthModule\")\n    if not hasattr(module, \"STEP_SETUP\"):\n        _LOGGER.error(\"MFA module %s missing required STEP_SETUP\", module_name)\n        raise HomeAssistantError(f\"MFA module {module_name} missing required STEP_SETUP\")\n    if not hasattr(module, \"STEP_SETUP_DATA\"):\n        _LOGGER.error(\"MFA module %s missing required STEP_SETUP_DATA\", module_name)\n        raise HomeAssistantError(f\"MFA module {module_name} missing required STEP_SETUP_DATA\")\n    if not hasattr(module, \"STEP_USER\"):\n        _LOGGER.error(\"MFA module %s missing required STEP_USER\", module_name)\n        raise HomeAssistantError(f\"MFA module {module_name} missing required STEP_USER\")\n    if not hasattr(module", "CodeBleu_score": 34.74584214419081}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule = await async_import_module(f\"homeassistant.auth_mfa_module.{module_name}\")\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        module.CONFIG_SCHEMA = vol.Schema({}, extra=vol.ALLOW_EXTRA)\n    return module\n\n", "CodeBleu_score": 18.31480495880342}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    for entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 67.07728262512914}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 79.82935187713805}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    for entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 67.07728262512914}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        users = await self._user_store.async_load()\n        if users is None:\n            users = {}\n\n        self._user_settings = OrderedDict()\n        for user_id, user_data in users.items():\n            self._user_settings[user_id] = NotifySetting(**user_data)\n\n", "CodeBleu_score": 44.71801035591372}, {"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        self._user_settings = cast(_UsersDict, await self._user_store.async_load())\n        if self._user_settings is None:\n            self._user_settings = {}\n\n        for user_id in self._user_settings:\n            user_settings = self._user_settings[user_id]\n            self._user_settings[user_id] = NotifySetting(\n                user_settings[STORAGE_USER_ID],\n                user_settings[CONF_NOTIFY_SERVICE],\n                user_settings[CONF_TARGET],\n            )\n\n    def _async_save(self) -> None:\n        \"\"\"The function \"_async_save\" asynchronously saves user data to the user store.", "CodeBleu_score": 38.08404793419762}, {"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._user_settings is not None:\n            return\n        user_store_data = await self._user_store.async_load()\n        if user_store_data is None:\n            self._user_settings = {}\n            return\n        self._user_settings = OrderedDict()\n        for user_id, user_data in user_store_data[STORAGE_USERS].items():\n            self._user_settings[user_id] = NotifySetting(**user_data)\n\n", "CodeBleu_score": 44.94073157341938}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tCHEMA = MULTI_FACTOR_AUTH_MODULE_SCHEMA.extend(\n    {\n        vol.Optional(CONF_INCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_EXCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_MESSAGE, default=\\\"{} is your Home Assistant login code\\\"): str,\n    },\n    extra=vol.PREVENT_EXTRA,", "CodeBleu_score": 37.53850067062267}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tCHEMA = MULTI_FACTOR_AUTH_MODULE_SCHEMA.extend(\n    {\n        vol.Optional(CONF_INCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_EXCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_MESSAGE, default=\\\"{} is your Home Assistant login code\\\"): str,\n    },\n    extra=vol.PREVENT_EXTRA,", "CodeBleu_score": 37.53850067062267}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tCHEMA = MULTI_FACTOR_AUTH_MODULE_SCHEMA.extend(\n    {\n        vol.Optional(CONF_INCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_EXCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_MESSAGE, default=\\\"{} is your Home Assistant login code\\\"): str,\n    },\n    extra=vol.PREVENT_EXTRA,", "CodeBleu_score": 37.53850067062267}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 71.74497328585876}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get_device(\n        entity_entry.device_id, entity_entry.area_id\n    )\n    if device_entry is None:\n        return None\n    if device_entry.area_id is None:\n        return None\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 70.87333556584728}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t# Fetch the entity entry\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    # Fetch the device entry\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    # Fetch the area entry\n    area_entry = perm_lookup.area_registry.async_get(device_entry.area_id)\n    if area_entry is None:\n        return None\n\n    # Return the permissions for the area\n    return area_dict.get(area_entry.id)\n\n", "CodeBleu_score": 72.64464526471063}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tmerged_policy: PolicyType = {\n        \"Name\": \"Merged Policy\",\n        \"Version\": \"0.1\",\n        \"Statements\": [],\n    }\n    seen_categories: set[CategoryType] = set()\n\n    for policy in policies:\n        for category in policy[\"Statements\"]:\n            if category[\"Category\"] not in seen_categories:\n                seen_categories.add(category[\"Category\"])\n                merged_policy[\"Statements\"].append(category)\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 39.70965830904806}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tmerged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category] for policy in policies if category in policy]\n                )\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 59.427036717656826}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tnew_policy: PolicyType = {}\n    seen: set[CategoryType] = set()\n\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                new_policy[category] = merge_categories(\n                    [policy[category] for policy in policies if category in policy]\n                )\n\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 63.37567136735521}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tmodule = await async_import_module(f\"homeassistant.auth.{provider}\")\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        module.CONFIG_SCHEMA = vol.Schema({}, extra=vol.ALLOW_EXTRA)\n    return module\n\n", "CodeBleu_score": 18.76317090391079}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Unable to load auth provider %s: %s\", provider, err)\n        raise\n    else:\n        if not hasattr(module, \"CONFIG_SCHEMA\"):\n            _LOGGER.error(\n                \"Auth provider module %s missing CONFIG_SCHEMA\", provider\n            )\n            raise HomeAssistantError(f\"Auth provider {provider} missing CONFIG_SCHEMA\")\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n            _LOGGER.error(\n                \"Auth provider module %s missing AUTH_PROVIDER_SCHEMA\", provider\n            )\n            raise HomeAssistantError(f\"Auth provider {provider} missing AUTH_PROVIDER_SCHEMA\")\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\") or not hasattr(\n            module, \"CONFIG_SCHEMA\"\n        ):\n            raise HomeAssistantError(\n                f\"Auth provider {provider} missing required schema\"\n            )\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n            raise HomeAssistantError(\n                f\"Auth provider {provider} missing required schema\"\n            )\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n            raise HomeAssistantError(\n                f\"Auth provider {provider} missing required schema\"\n            )\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n            raise HomeAssistantError(\n                f\"Auth provider {provider} missing required schema\"\n            )\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n            raise HomeAssistantError(\n                f\"Auth provider {provider} missing required schema\"\n            )\n        if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n            raise HomeAssistantError(\n                f\"Auth provider {provider} missing required schema\"", "CodeBleu_score": 32.46234549116379}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tmodule = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider module %s does not have a CONFIG_SCHEMA\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider module {provider} does not have a CONFIG_SCHEMA\"\n        )\n\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider module %s does not have a AUTH_PROVIDER_SCHEMA\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider module {provider} does not have a AUTH_PROVIDER_SCHEMA\"\n        )\n\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider module %s does not have a AUTH_PROVIDER_SCHEMA\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider module {provider} does not have a AUTH_PROVIDER_SCHEMA\"\n        )\n\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider module %s does not have a AUTH_PROVIDER_SCHEMA\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider module {provider} does not have a AUTH_PROVIDER_SCHEMA\"\n        )\n\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider module %s does not have a AUTH_PROVIDER_SCHEMA\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider module {provider} does not have a AUTH_PROVIDER_SCHEMA\"\n        )\n\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        _LOGGER.error", "CodeBleu_score": 25.551547699805177}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tdata = cast(dict[str, list[dict[str, str]]], await self._store.async_load())\n\n    if data is None:\n        data = {}\n\n    self._data = data\n\n    if self.is_legacy:\n        return\n\n    for user_id, users in data.items():\n        for user in users:\n            if user[CONF_ID] != self.normalize_username(user[CONF_ID]):\n                _LOGGER.warning(\n                    \"Username %s for user %s is not normalized. Please add a migration to the auth provider to normalize usernames\",\n                    user[CONF_ID],\n                    user_id,\n                )\n\n", "CodeBleu_score": 33.67109595482696}, {"code": "async def async_load(self) -> None\n\tdata = cast(dict[str, list[dict[str, str]]], await self._store.async_load())\n\n    if data is None:\n        data = {}\n\n    self._data = data\n\n    for users in data.values():\n        for user in users:\n            username = user[CONF_ID]\n\n            if username != self.normalize_username(username):\n                self.is_legacy = True\n                break", "CodeBleu_score": 40.89786354390619}, {"code": "async def async_load(self) -> None\n\tdata = await self._store.async_load()\n    if data is None:\n        data = {}\n    self._data = data\n    self.is_legacy = any(\n        username != username.strip().casefold() for username in data.keys()\n    )\n\n", "CodeBleu_score": 40.90550852458725}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == normalized_username:\n            user_hash = base64.b64decode(user[\"password_hash\"])\n            if bcrypt.checkpw(password.encode(), user_hash):\n                return\n            raise InvalidAuth\n    raise InvalidAuth\n\n", "CodeBleu_score": 47.6827074615612}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == normalized_username:\n            stored_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            raise InvalidAuth\n\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 49.946345244267796}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            user_hash = base64.b64decode(user[\"password_hash\"])\n            if bcrypt.checkpw(password.encode(), user_hash):\n                return\n            raise InvalidAuth\n\n    # if we make it this far we raise a dummy hash to prevent timing attacks\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 52.205694048337094}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tAGE_VERSION = 1", "CodeBleu_score": 5.181409862762599}, {"code": "def async_remove_auth(self, username: str) -> None\n\tAGE_VERSION = 1", "CodeBleu_score": 5.181409862762599}, {"code": "def async_remove_auth(self, username: str) -> None\n\tAGE_VERSION = 1", "CodeBleu_score": 5.181409862762599}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t.hash_password(password, True).decode(),\n            }\n        )\n\n    @callback\n    def async_remove_auth(self, username: str) -> None:\n        \\\"\\\"\\\"Remove authentication.\\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        index = None\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                index = i\n                break\n\n        if index is None:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n        self.users.pop(index)\n\n    def change_password(self, username: str, new_password: str) -> None:\n        \\\"\\\"\\\"Update the password.\n\n        Raises InvalidUser if user cannot be found.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"password\\\"] = self.hash_password(new_password, True).decode()\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    @callback\n    def _validate_new_username(self, new_username: str) -> None:\n        \\\"\\\"\\\"Validate that username is normalized and unique.\n\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        normalized_username = self.normalize_username(\n            new_username, force_normalize=True\n        )\n        if normalized_username != new_username:\n            raise InvalidUsername(\n                translation_key=\\\"username_not_normalized\\\",\n                translation_placeholders={\\\"new_username\\\": new_username},\n            )\n\n        if any(\n            self.normalize_username(user[\\\"username\\\"]) == normalized_username\n            for user in self.users\n        ):\n            raise InvalidUsername(\n                translation_key=\\\"username_already_exists\\\",\n                translation_placeholders={\\\"username\\\": new_username},\n            )\n\n    @callback\n    def change_username(self, username: str, new_username: str) -> None:\n        \\\"\\\"\\\"Update the username.\n\n        Raises InvalidUser if user cannot be found.\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n        self._validate_new_username(new_username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"username\\\"] = new_username\n                assert self._data is not None\n                self._async_check_for_not_normalized_usernames(self._data)\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\\\"\\\"\\\"\n        if self._data is not None:\n            await self._store.async_save(self._data)\n\n", "CodeBleu_score": 34.43998125714642}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t.hash_password(password, True).decode(),\n            }\n        )\n\n    @callback\n    def async_remove_auth(self, username: str) -> None:\n        \\\"\\\"\\\"Remove authentication.\\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        index = None\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                index = i\n                break\n\n        if index is None:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n        self.users.pop(index)\n\n    def change_password(self, username: str, new_password: str) -> None:\n        \\\"\\\"\\\"Update the password.\n\n        Raises InvalidUser if user cannot be found.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"password\\\"] = self.hash_password(new_password, True).decode()\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    @callback\n    def _validate_new_username(self, new_username: str) -> None:\n        \\\"\\\"\\\"Validate that username is normalized and unique.\n\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        normalized_username = self.normalize_username(\n            new_username, force_normalize=True\n        )\n        if normalized_username != new_username:\n            raise InvalidUsername(\n                translation_key=\\\"username_not_normalized\\\",\n                translation_placeholders={\\\"new_username\\\": new_username},\n            )\n\n        if any(\n            self.normalize_username(user[\\\"username\\\"]) == normalized_username\n            for user in self.users\n        ):\n            raise InvalidUsername(\n                translation_key=\\\"username_already_exists\\\",\n                translation_placeholders={\\\"username\\\": new_username},\n            )\n\n    @callback\n    def change_username(self, username: str, new_username: str) -> None:\n        \\\"\\\"\\\"Update the username.\n\n        Raises InvalidUser if user cannot be found.\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n        self._validate_new_username(new_username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"username\\\"] = new_username\n                assert self._data is not None\n                self._async_check_for_not_normalized_usernames(self._data)\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\\\"\\\"\\\"\n        if self._data is not None:\n            await self._store.async_save(self._data)\n\n", "CodeBleu_score": 34.43998125714642}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t.hash_password(password, True).decode(),\n            }\n        )\n\n    @callback\n    def async_remove_auth(self, username: str) -> None:\n        \\\"\\\"\\\"Remove authentication.\\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        index = None\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                index = i\n                break\n\n        if index is None:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n        self.users.pop(index)\n\n    def change_password(self, username: str, new_password: str) -> None:\n        \\\"\\\"\\\"Update the password.\n\n        Raises InvalidUser if user cannot be found.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"password\\\"] = self.hash_password(new_password, True).decode()\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    @callback\n    def _validate_new_username(self, new_username: str) -> None:\n        \\\"\\\"\\\"Validate that username is normalized and unique.\n\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        normalized_username = self.normalize_username(\n            new_username, force_normalize=True\n        )\n        if normalized_username != new_username:\n            raise InvalidUsername(\n                translation_key=\\\"username_not_normalized\\\",\n                translation_placeholders={\\\"new_username\\\": new_username},\n            )\n\n        if any(\n            self.normalize_username(user[\\\"username\\\"]) == normalized_username\n            for user in self.users\n        ):\n            raise InvalidUsername(\n                translation_key=\\\"username_already_exists\\\",\n                translation_placeholders={\\\"username\\\": new_username},\n            )\n\n    @callback\n    def change_username(self, username: str, new_username: str) -> None:\n        \\\"\\\"\\\"Update the username.\n\n        Raises InvalidUser if user cannot be found.\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n        self._validate_new_username(new_username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"username\\\"] = new_username\n                assert self._data is not None\n                self._async_check_for_not_normalized_usernames(self._data)\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\\\"\\\"\\\"\n        if self._data is not None:\n            await self._store.async_save(self._data)\n\n", "CodeBleu_score": 34.43998125714642}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined_threads: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined_threads.add(thread)\n            continue\n        thread_timeout = timeout - (time.time() - thread._start_time)  # type: ignore[attr-defined]\n        if thread_timeout > 0:\n            thread.join(thread_timeout)\n        if not thread.is_alive() or not thread.ident:\n            joined_threads.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    return joined_threads\n\n", "CodeBleu_score": 51.54375593224596}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        timeout_at = time.monotonic() + timeout\n        while thread.is_alive() and time.monotonic() < timeout_at:\n            time.sleep(0.1)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        try:\n            async_raise(thread.ident, SystemExit)\n        except Exception:  # pylint: disable=broad-except\n            pass\n    return joined\n\n", "CodeBleu_score": 56.56351737334538}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        timeout_at = time.monotonic() + timeout\n        while time.monotonic() < timeout_at:\n            thread.join(timeout_at - time.monotonic())\n            if not thread.is_alive():\n                joined.add(thread)\n                break\n        else:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    return joined\n\n", "CodeBleu_score": 55.820645207643004}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\tthreads = list(\n        filter(\n            lambda thread: thread is not threading.main_thread()\n            and not thread.daemon\n            and thread.is_alive(),\n            threading.enumerate(),\n        )\n    )\n    if not threads:\n        return\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError as exception:\n            _LOGGER.warning(\n                \"Unable to join thread %s: %s\", thread.name, exception\n            )\n\n", "CodeBleu_score": 47.5218945170454}, {"code": "def deadlock_safe_shutdown() -> None\n\tthreads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    if threads:\n        timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n        for thread in threads:\n            try:\n                thread.join(timeout)\n            except RuntimeError:\n                _LOGGER.warning(\n                    \"Failed to join thread %s with id %s\",\n                    thread.name,\n                    thread.ident,\n                )\n\n", "CodeBleu_score": 43.45121495794568}, {"code": "def deadlock_safe_shutdown() -> None\n\tthreads = threading.enumerate()\n    threads_to_join = [thread for thread in threads if thread is not threading.current_thread() and not thread.daemon and thread.is_alive()]\n\n    if threads_to_join:\n        _LOGGER.info(\"Waiting for %s threads to finish\", len(threads_to_join))\n\n    for thread in threads_to_join:\n        timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads_to_join)\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            # Thread is already stopped\n            pass\n        except Exception:  # pylint: disable=broad-except\n            _LOGGER.warning(\"Failed to join %s\", thread.name, exc_info=True)\n\n", "CodeBleu_score": 38.39656949865875}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # Suppress overly verbose logs from libraries that aren't helpful\n    logging.getLogger(\\\"requests\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"urllib3\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"aiohttp.access\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"httpx\\\").setLevel(logging.WARNING)\n\n    sys.excepthook = lambda *args: logging.getLogger(None).exception(\n        \\\"Uncaught exception\\\", exc_info=args\n    )\n    threading.excepthook = lambda args: logging.getLogger(None).exception(\n        \\\"Uncaught thread exception\\\",\n        exc_info=(  # type: ignore[arg-type]\n            args.exc_type,\n            args.exc_value,\n            args.exc_traceback,\n        ),\n    )\n\n    # Log errors to a file if we have write access to file or config dir\n    if log_file is None:\n        err_log_path = hass.config.path(ERROR_LOG_FILENAME)\n    else:\n        err_log_path = os.path.abspath(log_file)\n\n    err_path_exists = os.path.isfile(err_log_path)\n    err_dir = os.path.dirname(err_log_path)\n\n    # Check if we can write to the error log if it exists or that\n    # we can create files in the containing directory if not.\n    if (err_path_exists and os.access(err_log_path, os.W_OK)) or (\n        not err_path_exists and os.access(err_dir, os.W_OK)\n    ):\n        err_handler = await hass.async_add_executor_job(\n            _create_log_file, err_log_path, log_rotate_days\n        )\n\n        err_handler.setLevel(logging.INFO if verbose else logging.WARNING)\n        err_handler.setFormatter(logging.Formatter(fmt, datefmt=FORMAT_DATETIME))\n\n        logger = logging.getLogger(\\\"\\\")\n        logger.addHandler(err_handler)\n        logger.setLevel(logging.INFO if verbose else logging.WARNING)\n\n        # Save the log file location for access by other components.\n        hass.data[DATA_LOGGING] = err_log_path\n    else:\n        _LOGGER.error(\\\"Unable to set up error log %s (access denied)\\\", err_log_path)\n\n    async_activate_log_queue_handler(hass)\n\n", "CodeBleu_score": 41.01324891771487}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # Suppress overly verbose logs from libraries that aren't helpful\n    logging.getLogger(\\\"requests\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"urllib3\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"aiohttp.access\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"httpx\\\").setLevel(logging.WARNING)\n\n    sys.excepthook = lambda *args: logging.getLogger(None).exception(\n        \\\"Uncaught exception\\\", exc_info=args\n    )\n    threading.excepthook = lambda args: logging.getLogger(None).exception(\n        \\\"Uncaught thread exception\\\",\n        exc_info=(  # type: ignore[arg-type]\n            args.exc_type,\n            args.exc_value,\n            args.exc_traceback,\n        ),\n    )\n\n    # Log errors to a file if we have write access to file or config dir\n    if log_file is None:\n        err_log_path = hass.config.path(ERROR_LOG_FILENAME)\n    else:\n        err_log_path = os.path.abspath(log_file)\n\n    err_path_exists = os.path.isfile(err_log_path)\n    err_dir = os.path.dirname(err_log_path)\n\n    # Check if we can write to the error log if it exists or that\n    # we can create files in the containing directory if not.\n    if (err_path_exists and os.access(err_log_path, os.W_OK)) or (\n        not err_path_exists and os.access(err_dir, os.W_OK)\n    ):\n        err_handler = await hass.async_add_executor_job(\n            _create_log_file, err_log_path, log_rotate_days\n        )\n\n        err_handler.setLevel(logging.INFO if verbose else logging.WARNING)\n        err_handler.setFormatter(logging.Formatter(fmt, datefmt=FORMAT_DATETIME))\n\n        logger = logging.getLogger(\\\"\\\")\n        logger.addHandler(err_handler)\n        logger.setLevel(logging.INFO if verbose else logging.WARNING)\n\n        # Save the log file location for access by other components.\n        hass.data[DATA_LOGGING] = err_log_path\n    else:\n        _LOGGER.error(\\\"Unable to set up error log %s (access denied)\\\", err_log_path)\n\n    async_activate_log_queue_handler(hass)\n\n", "CodeBleu_score": 41.01324891771487}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # Suppress overly verbose logs from libraries that aren't helpful\n    logging.getLogger(\\\"requests\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"urllib3\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"aiohttp.access\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"httpx\\\").setLevel(logging.WARNING)\n\n    sys.excepthook = lambda *args: logging.getLogger(None).exception(\n        \\\"Uncaught exception\\\", exc_info=args\n    )\n    threading.excepthook = lambda args: logging.getLogger(None).exception(\n        \\\"Uncaught thread exception\\\",\n        exc_info=(  # type: ignore[arg-type]\n            args.exc_type,\n            args.exc_value,\n            args.exc_traceback,\n        ),\n    )\n\n    # Log errors to a file if we have write access to file or config dir\n    if log_file is None:\n        err_log_path = hass.config.path(ERROR_LOG_FILENAME)\n    else:\n        err_log_path = os.path.abspath(log_file)\n\n    err_path_exists = os.path.isfile(err_log_path)\n    err_dir = os.path.dirname(err_log_path)\n\n    # Check if we can write to the error log if it exists or that\n    # we can create files in the containing directory if not.\n    if (err_path_exists and os.access(err_log_path, os.W_OK)) or (\n        not err_path_exists and os.access(err_dir, os.W_OK)\n    ):\n        err_handler = await hass.async_add_executor_job(\n            _create_log_file, err_log_path, log_rotate_days\n        )\n\n        err_handler.setLevel(logging.INFO if verbose else logging.WARNING)\n        err_handler.setFormatter(logging.Formatter(fmt, datefmt=FORMAT_DATETIME))\n\n        logger = logging.getLogger(\\\"\\\")\n        logger.addHandler(err_handler)\n        logger.setLevel(logging.INFO if verbose else logging.WARNING)\n\n        # Save the log file location for access by other components.\n        hass.data[DATA_LOGGING] = err_log_path\n    else:\n        _LOGGER.error(\\\"Unable to set up error log %s (access denied)\\\", err_log_path)\n\n    async_activate_log_queue_handler(hass)\n\n", "CodeBleu_score": 41.01324891771487}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif not config.specific_integrations:\n        current_content = config.cache.get(\"bluetooth.py\")\n        generated_content = generate_and_validate(integrations)\n        if current_content != generated_content:\n            config.add_error(\n                \"bluetooth\",\n                \"bluetooth.py is not up to date. Run script/gen_bluetooth.py to update it.\",\n                fixable=True,\n            )\n    else:\n        generate_and_validate(integrations)", "CodeBleu_score": 46.13684670372934}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif not config.specific_integrations:\n        bluetooth_path = config.cache_dir / \"bluetooth.py\"\n\n        if not bluetooth_path.exists():\n            return\n\n        current_bluetooth = bluetooth_path.read_text()\n        generated_bluetooth = generate_and_validate(integrations)\n\n        if current_bluetooth == generated_bluetooth:\n            return\n\n        config.add_error(\n            \"bluetooth\",\n            \"Bluetooth file is not up to date.\",\n            \"Run script/gen_bluetooth.py to update it.\",\n        )\n        return\n\n    config.add_error(\n        \"bluetooth\",\n        \"Bluetooth file is not up to date.\",\n        \"Run script/gen_bluetooth.py to update it.\",\n    )", "CodeBleu_score": 46.91155227906478}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif config.specific_integrations:\n        generated = generate_and_validate(integrations)\n        if config.cache.get(\"bluetooth\") != generated:\n            config.cache[\"bluetooth\"] = generated\n            config.add_error(\n                \"bluetooth\",\n                \"Bluetooth file is not up to date\",\n                \"Run script `develop.sh code_format` to fix this\",\n            )\n        return\n\n    current = config.cache.get(\"bluetooth\")\n    generated = generate_and_validate(integrations)\n    if current != generated:\n        config.add_error(\n            \"bluetooth\",\n            \"Bluetooth file is not up to date\",\n            \"Run script `develop.sh code_format` to fix this\",\n        )\n        config.cache[\"bluetooth\"] = generated\n    else:\n        config.cache[\"bluetooth\"] = current", "CodeBleu_score": 38.60383586436914}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 95.72900406179113}, {"code": "func (d *Dropbox) refreshToken() error{\n\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.72900406179113}, {"code": "func (d *Dropbox) refreshToken() error{\n\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 94.3460799351067}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar body []byte\n\tvar err error\n\tvar res *resty.Response\n\tvar e base.ErrorResp\n\tfor i := 0; i < 2; i++ {\n\t\tres, err = base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\t\tSetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).\n\t\t\tSetQueryParams(map[string]string{\n\t\t\t\t\"includeItemsFromAllDrives\": \"true\",\n\t\t\t\t\"supportsAllDrives\":         \"true\",\n\t\t\t}).\n\t\t\tSetBody(callback(url, method)).\n\t\t\tExecute(method, url)\n\t\tif err != nil {\n\t\t\treturn body, err\n\t\t}\n\t\tif e.Error != \"\" {\n\t\t\treturn body, fmt.Errorf(e.Error)\n\t\t}\n\t\tbody = res.Body()\n\t\tif res.StatusCode() == http.StatusUnauthorized {\n\t\t\terr = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn body, err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn body, err\n}", "CodeBleu_score": 43.766985745165286}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar err error\n\tvar res *resty.Response\n\tvar body []byte\n\tfor i := 0; i < 2; i++ {\n\t\tres, err = base.RestyClient.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetQueryParam(\"supportsAllDrives\", \"true\").SetQueryParam(\"includeItemsFromAllDrives\", \"true\").SetResult(resp).SetError(&base.ApiError{}).Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif res.IsError() {\n\t\t\tif res.StatusCode() == http.StatusUnauthorized {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(res.String())\n\t\t\t}\n\t\t} else {\n\t\t\tif callback != nil {\n\t\t\t\tcallback(res.Request.RawRequest)\n\t\t\t}\n\t\t\tbody = res.Body()\n\t\t\tbreak\n\t\t}\n\t}\n\treturn body, err\n}", "CodeBleu_score": 50.792981538592585}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.AccessToken == \"\" {\n\t\terr := d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tres, err := base.RestyClient.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetResult(resp).SetError(&base.TokenError{}).SetQueryParams(map[string]string{\n\t\t\"supportsAllDrives\": \"true\",\n\t}).Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\terr = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif callback != nil {\n\t\t\tcallback(res.Request)\n\t\t}\n\t\tres, err = base.RestyClient.R().SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken).SetResult(resp).SetError(&base.TokenError{}).SetQueryParams(map[string]string{\n\t\t\t\"supportsAllDrives\": \"true\",\n\t\t}).Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif res.StatusCode() >= http.StatusBadRequest {\n\t\treturn nil, fmt.Errorf(res.Status())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 57.7260451316735}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Calculate the chunk size.\n\tchunkSize := int64(1024 * 1024 * 5)\n\t// Get the file size.\n\tfileSize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Calculate the number of chunks.\n\tnumChunks := int(math.Ceil(float64(fileSize) / float64(chunkSize)))\n\t// Create a buffer to hold each chunk.\n\tbuf := make([]byte, chunkSize)\n\t// Create a buffer to hold the bytes read.\n\tvar bytesRead int64\n\t// Create a buffer to hold the bytes written.\n\tvar bytesWritten int64\n\t// Create a buffer to hold the bytes uploaded.\n\tvar bytesUploaded int64\n\t// Create a buffer to hold the upload ID.\n\tvar uploadID string\n\t// Create a buffer to hold the upload URL.\n\tvar uploadURL string\n\t// Create a buffer to hold the file ID.\n\tvar fileID string\n\t// Create a buffer to hold the file name.\n\tvar fileName string\n\t// Create a buffer to hold the file size.\n\tvar fileSizeString string\n\t// Create a buffer to hold the file mime type.\n\tvar fileMimeType string\n\t// Create a buffer to hold the file parent ID.\n\tvar fileParentID string\n\t// Create a buffer to hold the file created time.\n\tvar fileCreatedTime string\n\t// Create a buffer to hold the file modified time.\n\tvar fileModifiedTime string\n\t// Create a buffer to hold the file MD5 checksum.\n\tvar fileMD5Checksum string\n\t// Create a buffer to hold the file SHA1 checksum.\n\tvar fileSHA1Checksum string\n\t// Create a buffer to hold the file SHA256 checksum.\n\tvar fileSHA256Checksum string\n\t// Create a buffer to hold the file SHA512 checksum.\n\tvar fileSHA512Checksum string\n\t// Create a buffer to hold the file CRC32C checksum.\n\tvar fileCRC32CChecksum string\n\t// Create a buffer to hold the file path.", "CodeBleu_score": 23.67556465001421}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Calculate the chunk size based on the file size.\n\tchunkSize := int64(30 * 1024 * 1024) // 30 MB\n\tfileSize := stream.Size()\n\tif fileSize < chunkSize {\n\t\tchunkSize = fileSize\n\t}\n\n\t// Upload chunks sequentially.\n\tbytesUploaded := int64(0)\n\tfor {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Create a byte array of the chunk size.\n\t\tbyteChunk := make([]byte, chunkSize)\n\n\t\t// Read the chunk from the stream.\n\t\tn, err := stream.Read(byteChunk)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the chunk is empty, break the loop.\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Create a byte array of the actual chunk size.\n\t\tbyteChunk = byteChunk[:n]\n\n\t\t// Create the HTTP request.\n\t\treq, err := http.NewRequest(http.MethodPut, url, bytes.NewReader(byteChunk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the HTTP headers.\n\t\treq.Header.Set(\"Content-Length\", strconv.FormatInt(int64(len(byteChunk)), 10))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", bytesUploaded, bytesUploaded+int64(len(byteChunk))-1, fileSize))\n\n\t\t// Send the HTTP request.\n\t\tresp, err := base.RestyClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// If the status code is not 200, return the error.\n\t\tif resp", "CodeBleu_score": 44.945039040807764}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(30 * 1024 * 1024)\n\tfileSize := stream.Size()\n\tvar chunkCount int64\n\tif fileSize%chunkSize == 0 {\n\t\tchunkCount = fileSize / chunkSize\n\t} else {\n\t\tchunkCount = (fileSize / chunkSize) + 1\n\t}\n\tvar bytesRead int64\n\tvar bytesRemaining int64\n\tvar err error\n\tvar n int\n\tvar chunkBuffer []byte\n\tvar chunkReader io.Reader\n\tvar chunkResp ChunkUploadResp\n\tfor i := int64(0); i < chunkCount; i++ {\n\t\tbytesRemaining = fileSize - bytesRead\n\t\tif bytesRemaining < chunkSize {\n\t\t\tchunkSize = bytesRemaining\n\t\t}\n\t\tchunkBuffer = make([]byte, chunkSize)\n\t\tn, err = stream.Read(chunkBuffer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tchunkReader = bytes.NewReader(chunkBuffer[:n])\n\t\t_, err = d.request(url, http.MethodPost, func(req *resty.Request) {\n\t\t\treq.SetHeader(\"Content-Length\", strconv.FormatInt(chunkSize, 10))\n\t\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", bytesRead, bytesRead+chunkSize-1, fileSize))\n\t\t\treq.SetBody(chunkReader)\n\t\t}, &chunkResp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbytesRead += chunkSize\n\t\tif chunkResp.Done {\n\t\t\tbreak\n\t\t}\n\t\turl = chunkResp.UploadURL\n\t\tif err = ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.62952738926279}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t// var req model.MountPoint\n\t// if err := ctx.Bind(&req); err != nil {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t// \treturn\n\t// }\n\t// req.Validate()\n\n\t// logger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\t// if req.MountPoint == \"\" {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t// }\n\t// if err := service.MyService.Storage().UmountStorage(req.MountPoint); err != nil {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t// }\n\t// if err := service.MyService.Storage().DeleteConfig(req.MountPoint); err != nil {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t// }\n\t// return ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n\n\tvar req model.MountPoint\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"U", "CodeBleu_score": 30.040120042758932}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req model.MountPoint\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t\treturn\n\t}\n\terr := service.MyService.Storage().Umount(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\terr = service.MyService.Storage().DeleteConfig(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 70.7450992733477}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t// var req model.MountPoint\n\t// if err := ctx.Bind(&req); err != nil {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t// \treturn\n\t// }\n\t// req.Validate()\n\n\t// logger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\t// if err := service.MyService.Storage().UmountStorage(req.MountPoint); err != nil {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t// \treturn\n\t// }\n\t// if err := service.MyService.Storage().DeleteConfig(req.MountPoint); err != nil {\n\t// \treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t// \treturn\n\t// }\n\t// return ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n\n\tvar req model.MountPoint\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE", "CodeBleu_score": 44.05159200057056}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.34538068663039}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.34538068663039}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.34538068663039}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Bind message\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrWithData(err.Error()))\n\t}\n\n\t// Send notification\n\tif err := service.MyService.Notify().Send(ctx.Param(\"name\"), message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ErrWithData(err.Error()))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err.SUCCESS})\n}", "CodeBleu_score": 56.63291753468707}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Get the notification name from the request context\n\tname := ctx.Param(\"name\")\n\t// Get the notification message from the request body\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.NewBadRequest(err.Error())\n\t}\n\t// Send the notification\n\tif err := service.MyService.Notify().Send(name, message); err != nil {\n\t\treturn common_err.NewServerError(err.Error())\n\t}\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: oasis_err2.SUCCESS, Message: oasis_err2.GetMsg(oasis_err2.SUCCESS)})\n}", "CodeBleu_score": 66.09769365514255}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrorBinding(err))\n\t}\n\tif err := service.MyService.Notify().Send(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, \"ok\")\n}", "CodeBleu_score": 49.75562754838588}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tservice.WSChanMap.Add(ws)\n\tdefer service.WSChanMap.Delete(ws)\n\n\tservice.WSChanMap.Range(func(key, value interface{}) bool {\n\t\tfmt.Println(key, value)\n\t\treturn true\n\t})\n\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(msgType, msg)\n\t\tif string(msg) == \"notify\" {\n\t\t\tservice.WSChanMap.Range(func(key, value interface{}) bool {\n\t\t\t\tif key != ws {\n\t\t\t\t\tkey.(*websocket.Conn).WriteJSON(types.WSMessage{\n\t\t\t\t\t\tType: \"notify\",\n\t\t\t\t\t\tData: \"notify\",\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t})\n\t\t}\n\t}\n}", "CodeBleu_score": 44.28635321518616}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tservice.WSManager.Add(ws)\n\tdefer service.WSManager.Remove(ws)\n\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\", message)\n\n\t\tif string(message) == \"notify\" {\n\t\t\tservice.WSManager.SendMessage(types.Message{\n\t\t\t\tType: \"notify\",\n\t\t\t\tData: \"\",\n\t\t\t})\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.28549226601376}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tc, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(\"upgrade:\", err)\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\tservice.WSConn = append(service.WSConn, c)\n\tservice.WSRun = true\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\", message)\n\t\tif string(message) == \"notify\" {\n\t\t\tservice.NotifyWS()\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 53.85838973745416}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tpkg/utils\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/service\\\"\n\tmodel2 \\\"github.com/IceWhaleTech/CasaOS/service/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/types\\\"\n\t\\\"github.com/labstack/echo/v4\\\"\n\t\\\"github.com/tidwall/gjson\\\"", "CodeBleu_score": 11.53096653667843}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tpkg/utils\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/service\\\"\n\tmodel2 \\\"github.com/IceWhaleTech/CasaOS/service/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/types\\\"\n\t\\\"github.com/labstack/echo/v4\\\"\n\t\\\"github.com/tidwall/gjson\\\"", "CodeBleu_score": 11.53096653667843}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tpkg/utils\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/service\\\"\n\tmodel2 \\\"github.com/IceWhaleTech/CasaOS/service/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/types\\\"\n\t\\\"github.com/labstack/echo/v4\\\"\n\t\\\"github.com/tidwall/gjson\\\"", "CodeBleu_score": 11.53096653667843}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar running []string\n\tvar notRunning []string\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\tservicesMap := make(map[bool]*[]string)\n\tservicesMap[true] = &running\n\tservicesMap[false] = &notRunning\n\n\treturn servicesMap, nil\n}", "CodeBleu_score": 76.18616820483697}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Active {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\tresult := make(map[bool]*[]string)\n\tresult[true] = &running\n\tresult[false] = &notRunning\n\n\treturn result, nil\n}", "CodeBleu_score": 75.2956481839731}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 75.09700656072813}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tif message == nil {\n\t\tmessage = make(map[string]interface{})\n\t}\n\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"error serializing message: \"+err.Error(), zap.String(\"message\", fmt.Sprintf(\"%v\", message)))\n\t}\n\tlogger.Info(\"sending message\", zap.String(\"message\", string(msg)))\n\ti.Send(name, msg)\n}", "CodeBleu_score": 37.92036611423296}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to serialize message: \"+err.Error(), zap.Any(\"message\", message))\n\t\treturn\n\t}\n\tlogger.Info(\"Sending notification: \"+name, zap.Any(\"message\", message))\n\terr = common.SocketIOClient.Emit(name, msg)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to send notification: \"+err.Error(), zap.Any(\"message\", message))\n\t}\n}", "CodeBleu_score": 39.44478448855332}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(fmt.Sprintf(\"error marshalling message %v\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\ti.SendNotifyByJSON(name, jsonMessage)\n}", "CodeBleu_score": 20.55578256798329}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tclient := message_bus.NewClientWithResponses()\n\tclient.Server = \"http://127.0.0.1:8080\"\n\tclient.DefaultAuth = runtime.ClientAuthInfoWriterFunc(func(r runtime.ClientRequest, _ strfmt.Registry) error {\n\t\tr.SetHeaderParam(\"Authorization\", \"Bearer \"+config.GetToken())\n\t\treturn nil\n\t})\n\treturn client\n}", "CodeBleu_score": 30.88855038734735}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(config.MessageBusUrl)\n}", "CodeBleu_score": 7.413297624889117}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(c.gateway.GetMessageBusAddress())\n}", "CodeBleu_score": 8.387582158236656}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) == 0 {\n\t\tip = request.RemoteAddr\n\t}\n\tif len(ip) > 0 {\n\t\ti := strings.Index(ip, \":\")\n\t\tif i > 0 {\n\t\t\tip = ip[:i]\n\t\t}\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 64.56626539394293}, {"code": "func GetIP(request *http.Request) string{\n\tforwarded := request.Header.Get(\"X-FORWARDED-FOR\")\n\tif len(forwarded) > 0 {\n\t\treturn strings.Split(forwarded, \",\")[0]\n\t}\n\treturn strings.Split(request.RemoteAddr, \":\")[0]\n}", "CodeBleu_score": 24.950226133995628}, {"code": "func GetIP(request *http.Request) string{\n\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif len(forwarded) > 0 {\n\t\tparts := strings.Split(forwarded, \",\")\n\t\treturn strings.TrimSpace(parts[0])\n\t}\n\tip := strings.TrimSpace(request.RemoteAddr)\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 44.43785138213247}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\tmodulesDir := common.DirPath + \"/modules\"\n\tentryFile := common.DirPath + \"/entry.json\"\n\n\t// Ensure modules directory exists\n\tif _, err := os.Stat(modulesDir); os.IsNotExist(err) {\n\t\tlogger.Error(\"modules directory does not exist\", zap.String(\"modulesDir\", modulesDir))\n\t\treturn\n\t}\n\n\t// Ensure entry file exists\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\tlogger.Error(\"entry file does not exist\", zap.String(\"entryFile\", entryFile))\n\t\treturn\n\t}\n\n\t// Read modules directory\n\tdir, err := ioutil.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Error(\"error reading modules directory\", zap.String(\"modulesDir\", modulesDir), zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read each module directory for entry.json files\n\tvar entry []byte\n\tfor _, d := range dir {\n\t\t// Ensure module directory is a directory\n\t\tif d.IsDir() {\n\t\t\t// Read module directory for entry.json files\n\t\t\tfiles, err := ioutil.ReadDir(modulesDir + \"/\" + d.Name())\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"error reading module directory\", zap.String(\"moduleDir\", modulesDir+\"/\"+d.Name()), zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Read each entry.json file\n\t\t\tfor _, f := range files {\n\t\t\t\t// Ensure entry.json file is a file\n\t\t\t\tif !f.IsDir() {\n\t\t\t\t\t// Ensure entry.json file name is entry.json\n\t\t\t\t\tif f.Name() == \"entry.json\" {\n\t\t\t\t\t\t// Read entry.json file\n\t\t\t\t\t\tdata, err := ioutil.ReadFile(modulesDir + \"/\" + d.Name() + \"/\" + f.Name())\n\t\t\t\t\t\tif err != nil {", "CodeBleu_score": 43.392597661637915}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tpath := config.AppInfo.ProjectPath + \"/conf/module.json\"\n\t// Check if the entry file exists\n\tif !file.CheckNotExist(path) {\n\t\treturn\n\t}\n\n\t// Read the module directory\n\tdir, err := ioutil.ReadDir(config.AppInfo.ModulePath)\n\tif err != nil {\n\t\tlogger.Error(\"Read module directory error\", zap.Any(\"error\", err))\n\t\treturn\n\t}\n\n\t// Declare a variable to store the content of each entry file\n\tvar entryStr string\n\n\t// Traverse the module directory\n\tfor _, fi := range dir {\n\t\t// Skip directories that are not modules\n\t\tif !fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the path of the entry file in the module directory\n\t\tentryFile := config.AppInfo.ModulePath + \"/\" + fi.Name() + \"/conf/entry.json\"\n\n\t\t// Read the content of the entry file\n\t\tb, err := ioutil.ReadFile(entryFile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Read entry file error\", zap.Any(\"error\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add a comma to the end of the content of the entry file\n\t\tentryStr += string(b) + \",\"\n\t}\n\n\t// Remove the last comma\n\tentryStr = strings.TrimRight(entryStr, \",\")\n\n\t// Add brackets to the content of the entry file\n\tentryStr = \"[\" + entryStr + \"]\"\n\n\t// Write the content of the entry file to the entry file path\n\terr = ioutil.WriteFile(path, []byte(entryStr), 0755)\n\tif err != nil {\n\t\tlogger.Error(\"Write entry file error\", zap.Any(\"error\", err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 60.52088266057736}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tentryFilePath := config.AppInfo.ProjectPath + \"/conf/entry.json\"\n\tentryDirPath := config.AppInfo.ProjectPath + \"/conf/modules\"\n\n\tentryFile, err := os.OpenFile(entryFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)\n\tif err != nil {\n\t\tlogger.Error(\"open entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\tentries := []model.Entry{}\n\n\terr = filepath.Walk(entryDirPath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read entry dir error\", zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif !strings.HasSuffix(path, \"entry.json\") {\n\t\t\treturn nil\n\t\t}\n\t\tentryBytes, err := ioutil.ReadFile(path)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read entry file error\", zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t\tentry := model.Entry{}\n\t\terr = json.Unmarshal(entryBytes, &entry)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unmarshal entry file error\", zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t\tentries = append(entries, entry)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"walk entry dir error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tentryBytes, err := json.Marshal(entries)\n\tif err != nil {\n\t\tlogger.Error(\"marshal entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\t_, err = entryFile.Write(entryBytes)\n\tif err != nil {\n\t\tlogger.Error(\"write entry file error\", zap.Error(err))", "CodeBleu_score": 55.5974756629999}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tn\t\\\"os\\\"\n\t\\\"path/filepath\\\"\n\t\\\"runtime\\\"\n\t\\\"strconv\\\"\n\t\\\"strings\\\"\n\t\\\"time\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/command\\\"\n\texec2 \\\"github.com/IceWhaleTech/CasaOS-Common/utils/exec\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/file\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/common\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/config\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\\\"\n\t\\\"github.com/tidwall/gjson\\\"\n\t\\\"go.uber.org/zap\\\"\n\n\t\\\"github.com/shirou/gopsutil/v3/cpu\\\"\n\t\\\"github.com/shirou/gopsutil/v3/disk\\\"\n\t\\\"github.com/shirou/gopsutil/v3/host\\\"\n\t\\\"github.com/shirou/gopsutil/v3/mem\\\"\n\t\\\"github.com/shirou/gopsutil/v3/net\\\"", "CodeBleu_score": 31.26312490736105}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tn\t\\\"os\\\"\n\t\\\"path/filepath\\\"\n\t\\\"runtime\\\"\n\t\\\"strconv\\\"\n\t\\\"strings\\\"\n\t\\\"time\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/command\\\"\n\texec2 \\\"github.com/IceWhaleTech/CasaOS-Common/utils/exec\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/file\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/common\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/config\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\\\"\n\t\\\"github.com/tidwall/gjson\\\"\n\t\\\"go.uber.org/zap\\\"\n\n\t\\\"github.com/shirou/gopsutil/v3/cpu\\\"\n\t\\\"github.com/shirou/gopsutil/v3/disk\\\"\n\t\\\"github.com/shirou/gopsutil/v3/host\\\"\n\t\\\"github.com/shirou/gopsutil/v3/mem\\\"\n\t\\\"github.com/shirou/gopsutil/v3/net\\\"", "CodeBleu_score": 31.26312490736105}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tn\t\\\"os\\\"\n\t\\\"path/filepath\\\"\n\t\\\"runtime\\\"\n\t\\\"strconv\\\"\n\t\\\"strings\\\"\n\t\\\"time\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/command\\\"\n\texec2 \\\"github.com/IceWhaleTech/CasaOS-Common/utils/exec\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/file\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/common\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/config\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\\\"\n\t\\\"github.com/tidwall/gjson\\\"\n\t\\\"go.uber.org/zap\\\"\n\n\t\\\"github.com/shirou/gopsutil/v3/cpu\\\"\n\t\\\"github.com/shirou/gopsutil/v3/disk\\\"\n\t\\\"github.com/shirou/gopsutil/v3/host\\\"\n\t\\\"github.com/shirou/gopsutil/v3/mem\\\"\n\t\\\"github.com/shirou/gopsutil/v3/net\\\"", "CodeBleu_score": 31.26312490736105}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\n    if (pRequest == NULL) {\n        return TSC_FAILURE;\n    }\n\n    pRequest->refCount++;\n    pTscObj->requestCount++;\n\n    if (pTscObj->appInfo != NULL) {\n        pTscObj->appInfo->requestCount++;\n        pTscObj->appInfo->currentRequestCount++;\n    }\n\n    if (tscDbg.debug) {\n        logMessage(TSC_LOG_INFO, \"Registered request: %s\", pRequest->requestId);\n    }\n\n    return rc;\n}", "CodeBleu_score": 30.577617096274036}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t res = 0;\n    if (pRequest == NULL) {\n        return -1;\n    }\n    pRequest->refCount++;\n    pTscObj->requestCount++;\n    if (pTscObj->appInfo != NULL) {\n        pTscObj->appInfo->requestCount++;\n        pTscObj->appInfo->currentRequestCount++;\n    }\n    TSC_LOG(TSC_LOG_INFO, \"Registered request %d of %d for TSC %s\",\n            pTscObj->requestCount,\n            pTscObj->appInfo->requestCount,\n            pTscObj->appInfo->name);\n    return res;\n}", "CodeBleu_score": 27.15843216140259}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\n    // Add a reference to the request object\n    rc = trefAddRef(pRequest->ref, &clientReqRefPool);\n    if (rc < 0) {\n        TclLog(pRequest->pLog, TLOG_ERROR, \"registerRequest: failed to add reference to request object\");\n        return TSC_RC_ERROR;\n    }\n\n    // Increment the request count for the associated TSC object\n    pTscObj->requestCount++;\n\n    // If the TSC object has application information, update the application's request summary\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestCount++;\n        pTscObj->pAppInfo->currentRequestCount++;\n    }\n\n    // Log debug information about the new request\n    TclLog(pRequest->pLog, TLOG_DEBUG, \"registerRequest: registered request %p for TSC %p\", pRequest, pTscObj);\n\n    return TSC_RC_SUCCESS;\n}", "CodeBleu_score": 44.02460192890602}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tStop = -1;\n", "CodeBleu_score": 3.968972783639452}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tStop = -1;\n", "CodeBleu_score": 3.968972783639452}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tStop = -1;\n", "CodeBleu_score": 3.968972783639452}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t   cJSON_AddItemToObject(json, \\\"db\\\", cJSON_CreateString(pRequest->pDb));\n  }", "CodeBleu_score": 8.0237808840773}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t   cJSON_AddItemToObject(json, \\\"db\\\", cJSON_CreateString(pRequest->pDb));\n  }", "CodeBleu_score": 8.0237808840773}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t   cJSON_AddItemToObject(json, \\\"db\\\", cJSON_CreateString(pRequest->pDb));\n  }", "CodeBleu_score": 8.0237808840773}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t->metric.parseCostUs, pRequest->metric.ctgCostUs, pRequest->metric.analyseCostUs,\n               pRequest->metric.planCostUs, pRequest->metric.execCostUs);\n      atomic_add_fetch_64((int64_t *)&pActivity->insertElapsedTime, duration);\n      reqType = SLOW_LOG_TYPE_INSERT;\n    }", "CodeBleu_score": 19.21629705877469}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t->metric.parseCostUs, pRequest->metric.ctgCostUs, pRequest->metric.analyseCostUs,\n               pRequest->metric.planCostUs, pRequest->metric.execCostUs);\n      atomic_add_fetch_64((int64_t *)&pActivity->insertElapsedTime, duration);\n      reqType = SLOW_LOG_TYPE_INSERT;\n    }", "CodeBleu_score": 19.21629705877469}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t->metric.parseCostUs, pRequest->metric.ctgCostUs, pRequest->metric.analyseCostUs,\n               pRequest->metric.planCostUs, pRequest->metric.execCostUs);\n      atomic_add_fetch_64((int64_t *)&pActivity->insertElapsedTime, duration);\n      reqType = SLOW_LOG_TYPE_INSERT;\n    }", "CodeBleu_score": 19.21629705877469}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t taosArrayDestroy(pRequest->tableList);\n  taosArrayDestroy(pRequest->targetTableList);\n\n  destroyQueryExecRes(&pRequest->body.resInfo.execRes);\n\n  if (pRequest->self) {\n    deregisterRequest(pRequest);\n  }\n\n  taosMemoryFreeClear(pRequest->pDb);\n  taosArrayDestroy(pRequest->dbList);\n  if (pRequest->body.interParam) {\n    tsem_destroy(&((SSyncQueryParam *)pRequest->body.interParam)->sem);\n  }\n  taosMemoryFree(pRequest->body.interParam);\n\n  if (TSDB_CODE_SUCCESS == nodesSimAcquireAllocator(pRequest->allocatorRefId)) {\n    qDestroyQuery(pRequest->pQuery);\n    nodesSimReleaseAllocator(pRequest->allocatorRefId);\n  }\n  nodesDestroyAllocator(pRequest->allocatorRefId);\n\n  taosMemoryFreeClear(pRequest->effectiveUser);\n  taosMemoryFreeClear(pRequest->sqlstr);\n  taosMemoryFree(pRequest);\n  tscTrace(\\\"end to destroy request %\\\" PRIx64 \\\" p:%p\\\", reqId, pRequest);\n  destroyNextReq(nextReqRefId);\n}", "CodeBleu_score": 29.674262443224826}, {"code": "void tscStopCrashReport(){\n\t taosArrayDestroy(pRequest->tableList);\n  taosArrayDestroy(pRequest->targetTableList);\n\n  destroyQueryExecRes(&pRequest->body.resInfo.execRes);\n\n  if (pRequest->self) {\n    deregisterRequest(pRequest);\n  }\n\n  taosMemoryFreeClear(pRequest->pDb);\n  taosArrayDestroy(pRequest->dbList);\n  if (pRequest->body.interParam) {\n    tsem_destroy(&((SSyncQueryParam *)pRequest->body.interParam)->sem);\n  }\n  taosMemoryFree(pRequest->body.interParam);\n\n  if (TSDB_CODE_SUCCESS == nodesSimAcquireAllocator(pRequest->allocatorRefId)) {\n    qDestroyQuery(pRequest->pQuery);\n    nodesSimReleaseAllocator(pRequest->allocatorRefId);\n  }\n  nodesDestroyAllocator(pRequest->allocatorRefId);\n\n  taosMemoryFreeClear(pRequest->effectiveUser);\n  taosMemoryFreeClear(pRequest->sqlstr);\n  taosMemoryFree(pRequest);\n  tscTrace(\\\"end to destroy request %\\\" PRIx64 \\\" p:%p\\\", reqId, pRequest);\n  destroyNextReq(nextReqRefId);\n}", "CodeBleu_score": 29.674262443224826}, {"code": "void tscStopCrashReport(){\n\t taosArrayDestroy(pRequest->tableList);\n  taosArrayDestroy(pRequest->targetTableList);\n\n  destroyQueryExecRes(&pRequest->body.resInfo.execRes);\n\n  if (pRequest->self) {\n    deregisterRequest(pRequest);\n  }\n\n  taosMemoryFreeClear(pRequest->pDb);\n  taosArrayDestroy(pRequest->dbList);\n  if (pRequest->body.interParam) {\n    tsem_destroy(&((SSyncQueryParam *)pRequest->body.interParam)->sem);\n  }\n  taosMemoryFree(pRequest->body.interParam);\n\n  if (TSDB_CODE_SUCCESS == nodesSimAcquireAllocator(pRequest->allocatorRefId)) {\n    qDestroyQuery(pRequest->pQuery);\n    nodesSimReleaseAllocator(pRequest->allocatorRefId);\n  }\n  nodesDestroyAllocator(pRequest->allocatorRefId);\n\n  taosMemoryFreeClear(pRequest->effectiveUser);\n  taosMemoryFreeClear(pRequest->sqlstr);\n  taosMemoryFree(pRequest);\n  tscTrace(\\\"end to destroy request %\\\" PRIx64 \\\" p:%p\\\", reqId, pRequest);\n  destroyNextReq(nextReqRefId);\n}", "CodeBleu_score": 29.674262443224826}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tHashCleanup(vgInfo->vgHash);\n    taosMemoryFreeClear(vgInfo);\n  }", "CodeBleu_score": 11.23597202147885}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tHashCleanup(vgInfo->vgHash);\n    taosMemoryFreeClear(vgInfo);\n  }", "CodeBleu_score": 11.23597202147885}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tHashCleanup(vgInfo->vgHash);\n    taosMemoryFreeClear(vgInfo);\n  }", "CodeBleu_score": 11.23597202147885}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t: %s\n\\\", S3_get_status_name(status));\n    return -1;\n  }", "CodeBleu_score": 9.066531096038927}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t: %s\n\\\", S3_get_status_name(status));\n    return -1;\n  }", "CodeBleu_score": 9.066531096038927}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t: %s\n\\\", S3_get_status_name(status));\n    return -1;\n  }", "CodeBleu_score": 9.066531096038927}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tint32_t code = 0;\n\n    if (taosMkdir(tsCheckpointBackupDir, 0755) != 0) {\n        uError(\"[rsync] create checkpoint backup dir error, dir:%s, \" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    }\n\n    removeEmptyDir();\n\n    char confDir[PATH_MAX] = {0};\n    snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n\n    if (generateConfigFile(confDir) != 0) {\n        uError(\"[rsync] generate rsync conf file error, dir:%s\", confDir);\n        return;\n    }\n\n    char command[PATH_MAX * 4] = {0};\n\n#ifdef WINDOWS\n    snprintf(command, PATH_MAX * 4, \"rsync.exe --daemon --no-detach --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n#else\n    snprintf(command, PATH_MAX * 4, \"rsync --daemon --no-detach --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n#endif\n\n    code = execCommand(command);\n\n    if (code == 0) {\n        uDebug(\"[rsync] start rsync server successful\");\n    } else {\n        uError(\"[rsync] start rsync server failed, \" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    }\n}", "CodeBleu_score": 65.91333391282433}, {"code": "void startRsync(){\n\tint32_t code = taosMkdir(tsCheckpointBackupDir, 0755);\n    if (code != 0) {\n        uError(\"[rsync] create checkpoint backup dir error, dir:%s, \" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    }\n\n    removeEmptyDir();\n\n    char confDir[PATH_MAX] = {0};\n    snprintf(confDir, sizeof(confDir), \"%s%s\", tsCheckpointBackupDir, \"rsync.conf\");\n    if (generateConfigFile(confDir) != 0) {\n        return;\n    }\n\n    char command[PATH_MAX] = {0};\n    snprintf(command, sizeof(command), \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n    code = execCommand(command);\n    if (code != 0) {\n        uError(\"[rsync] start rsync server failed, \" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    } else {\n        uDebug(\"[rsync] start rsync server successful\");\n    }\n}", "CodeBleu_score": 70.08178369705703}, {"code": "void startRsync(){\n\tint32_t code = 0;\n    if (taosMkdir(tsCheckpointBackupDir, 0755) != 0) {\n        uError(\"[rsync] mkdir %s error, \" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    }\n\n    removeEmptyDir();\n\n    char confDir[PATH_MAX] = {0};\n    snprintf(confDir, sizeof(confDir), \"%srsync.conf\", tsCheckpointBackupDir);\n    if (generateConfigFile(confDir) != 0) {\n        uError(\"[rsync] generate config file error, confDir:%s\", confDir);\n        return;\n    }\n\n    char command[PATH_MAX * 4] = {0};\n    snprintf(command, sizeof(command), \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n    code = execCommand(command);\n    if (code != 0) {\n        uError(\"[rsync] start rsync server failed, \" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    } else {\n        uDebug(\"[rsync] start rsync server successful\");\n    }\n}", "CodeBleu_score": 66.67049200892198}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.remove(dispatcherId);\n    if (current == null) {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n    current.getExecutor().shutdownNow();\n}", "CodeBleu_score": 70.95038691983252}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.remove(dispatcherId);\n    if (current == null) {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n    current.getExecutor().shutdownNow();\n}", "CodeBleu_score": 70.95038691983252}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.remove(dispatcherId);\n    if (current == null) {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n    current.getExecutor().shutdownNow();\n}", "CodeBleu_score": 70.95038691983252}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tn * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "CodeBleu_score": 18.97676150267901}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tn * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "CodeBleu_score": 18.97676150267901}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tn * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "CodeBleu_score": 18.97676150267901}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && stopReason == TbActorStopReason.INIT_FAILED) {\n        tryInit(1);\n    } else {\n        msg.getCallback().onFailure(new TbActorStoppedException(selfId));\n    }\n}", "CodeBleu_score": 45.92447282906767}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyInProgress.get()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            tryInit(1);\n        } else {\n            msg.getCallback().onFailure(new TbActorStopException(stopReason));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(highPriority);\n    }\n}", "CodeBleu_score": 49.27135203071482}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n        if (stopReason == TbActorStopReason.INIT_FAILED) {\n            log.info(\"[{}] Received high-priority message while initialization is in progress, going to try to re-init actor.\", selfId);\n            tryInit(1);\n        } else {\n            msg.onTbActorStopped(this);\n        }\n    } else {\n        msg.onTbActorStopped(this);\n    }\n}", "CodeBleu_score": 60.646880506576615}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ttry {\n        int processed = 0;\n        while (processed < settings.getActorThroughput()) {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg == null) {\n                break;\n            }\n            try {\n                actor.process(this, msg);\n            } catch (TbActorException e) {\n                if (e.getCause() != null) {\n                    e = new TbActorException(e.getErrorCode(), e.getMessage(), e.getCause());\n                }\n                log.debug(\"[{}] Failed to process message: {}\", selfId, msg, e);\n                ProcessFailureStrategy strategy = actor.onProcessFailure(e);\n                if (strategy.isStop()) {\n                    log.info(\"[{}] Failed to process message, going to stop actor: {}\", selfId, msg, e);\n                    stopReason = TbActorStopReason.PROCESSING_FAILED;\n                    destroy(e);\n                    return;\n                } else {\n                    log.info(\"[{}] Failed to process message, going to retry: {}\", selfId, msg, e);\n                }\n            } catch (Throwable t) {\n                log.debug(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                ProcessFailureStrategy strategy = actor.onProcessFailure(t);\n                if (strategy.isStop()) {\n                    log.info(\"[{}] Failed to process message, going to stop actor: {}\", selfId, msg, t);\n                    stopReason = TbActorStopReason.PROCESSING_FAILED;\n                    destroy(t);\n                    return;\n                } else {\n                    log.info(\"[{}] Failed to process message, going to retry: {}\", selfId, msg, t);\n                }\n            }\n            processed++;\n        }\n    } finally {\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            busy.set(F", "CodeBleu_score": 46.86112449170009}, {"code": "private void processMailbox(){\n\tint processed = 0;\n    while (processed < settings.getActorThroughput()) {\n        TbActorMsg msg = highPriorityMsgs.poll();\n        if (msg == null) {\n            msg = normalPriorityMsgs.poll();\n        }\n        if (msg == null) {\n            busy.set(FREE);\n            tryProcessQueue(false);\n            return;\n        } else {\n            try {\n                actor.process(msg);\n            } catch (TbActorException t) {\n                if (t.getCause() != null) {\n                    t = (TbActorException) t.getCause();\n                }\n                if (t.getError() == TbActorError.INIT_FAILED) {\n                    log.info(\"[{}] Failed to process message: {}. Stopping actor due to initialization failure.\", selfId, msg);\n                    stopReason = TbActorStopReason.INIT_FAILED;\n                    destroy(t.getCause());\n                } else {\n                    log.info(\"[{}] Failed to process message: {}. Stopping actor due to processing failure.\", selfId, msg);\n                    stopReason = TbActorStopReason.PROCESSING_FAILED;\n                    destroy(t.getCause());\n                }\n                return;\n            } catch (Throwable t) {\n                log.info(\"[{}] Failed to process message: {}. Stopping actor due to unexpected failure.\", selfId, msg);\n                stopReason = TbActorStopReason.UNEXPECTED_FAILURE;\n                destroy(t);\n                return;\n            }\n            processed++;\n        }\n    }\n    dispatcher.getExecutor().execute(this::processMailbox);\n}", "CodeBleu_score": 49.95749145880673}, {"code": "private void processMailbox(){\n\ttry {\n        int throughput = settings.getActorThroughput();\n        int highPriorityCount = 0;\n        int normalPriorityCount = 0;\n        int totalCount = 0;\n        while (totalCount < throughput) {\n            if (highPriorityCount < throughput) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg != null) {\n                    process(msg);\n                    highPriorityCount++;\n                    totalCount++;\n                } else {\n                    highPriorityCount = throughput;\n                }\n            }\n            if (normalPriorityCount < throughput) {\n                TbActorMsg msg = normalPriorityMsgs.poll();\n                if (msg != null) {\n                    process(msg);\n                    normalPriorityCount++;\n                    totalCount++;\n                } else {\n                    normalPriorityCount = throughput;\n                }\n            }\n        }\n    } finally {\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            busy.set(FREE);\n            tryProcessQueue(false);\n        } else {\n            dispatcher.getExecutor().execute(this::processMailbox);\n        }\n    }\n}", "CodeBleu_score": 36.522209348275325}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tdispatcher.getExecutor().execute(() -> tryInit(1));\n    }", "CodeBleu_score": 3.157486095458322}, {"code": "public void destroy(Throwable cause){\n\tdispatcher.getExecutor().execute(() -> tryInit(1));\n    }", "CodeBleu_score": 3.157486095458322}, {"code": "public void destroy(Throwable cause){\n\tdispatcher.getExecutor().execute(() -> tryInit(1));\n    }", "CodeBleu_score": 3.157486095458322}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitKey key = new RateLimitKey(tenantId, api, level);\n    TbRateLimits rateLimits = this.rateLimits.get(key, k -> new TbRateLimits(rateLimitConfiguration));\n    boolean result = rateLimits.tryConsume();\n    if (!result) {\n        notificationRuleProcessor.processNotificationRule(tenantId, new RateLimitsTrigger(api, level));\n    }\n    return result;\n}", "CodeBleu_score": 54.091931506615445}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitKey rateLimitKey = new RateLimitKey(api, tenantId, level);\n    TbRateLimits rateLimits = this.rateLimits.getIfPresent(rateLimitKey);\n    if (rateLimits == null) {\n        rateLimits = new TbRateLimits(rateLimitConfiguration.getTenantProfileRateLimit(), rateLimitConfiguration.getTenantProfileRateLimitPeriod());\n        this.rateLimits.put(rateLimitKey, rateLimits);\n    }\n    boolean result = rateLimits.tryConsume();\n    if (!result) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"[{}] Rate limit detected for API: {}!\", tenantId, api);\n        }\n        if (rateLimitConfiguration.getTenantProfileRateLimitNotification() != null) {\n            RateLimitsTrigger rateLimitsTrigger = new RateLimitsTrigger();\n            rateLimitsTrigger.setApi(api);\n            rateLimitsTrigger.setEntityId(tenantId);\n            notificationRuleProcessor.process(tenantId, tenantProfile.getId(), rateLimitConfiguration.getTenantProfileRateLimitNotification(), rateLimitsTrigger);\n        }\n    }\n    return result;\n}", "CodeBleu_score": 48.366358224317146}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimitsTrigger();\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    RateLimitKey key = new RateLimitKey(tenantId, api, level);\n    TbRateLimits rateLimits = this.rateLimits.getIfPresent(key);\n    if (rateLimits == null) {\n        rateLimits = new TbRateLimits(rateLimitsTrigger.getConfiguration());\n        this.rateLimits.put(key, rateLimits);\n    }\n    boolean result = rateLimits.tryConsume();\n    if (!result) {\n        notificationRuleProcessor.process(tenantId, tenantProfile.getId(), api, level);\n    }\n    return result;\n}", "CodeBleu_score": 52.23820791118901}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlog.trace(\"Evicting DTLS sessions that have been inactive for more than {} seconds\", dtlsSessionInactivityTimeout);\n    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().removeIf(entry -> {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store due to inactivity: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\n            return true;\n        } else {\n            return false;\n        }\n    });\n}", "CodeBleu_score": 61.85688017879426}, {"code": "public void evictTimeoutSessions(){\n\tlog.trace(\"Evicting timeout DTLS sessions from in-memory store.\");\n    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().removeIf(entry -> {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store due to timeout: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\n            return true;\n        } else {\n            return false;\n        }\n    });\n}", "CodeBleu_score": 63.42511047662425}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().stream().filter(entry -> entry.getValue().getLastActivityTime() < expirationTime).forEach(entry -> {\n        log.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\n        dtlsSessionsMap.remove(entry.getKey());\n    });\n}", "CodeBleu_score": 59.496819275123826}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                long ts = value.get(TS).asLong();\n                KvEntry kvEntry = parseValue(key, value.get(VALUE));\n                result.add(new BasicTsKvEntry(ts, kvEntry));\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 56.988018460375756}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                KvEntry kvEntry = parseValue(key, value);\n                if (kvEntry.getDataType() != DataType.BOOLEAN && kvEntry.getDataType() != DataType.STRING) {\n                    kvEntry = new BasicTsKvEntry(kvEntry.getTs(), kvEntry);\n                }\n                result.add((TsKvEntry) kvEntry);\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 52.32577241631922}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                KvEntry kvEntry = parseValue(key, value);\n                if (kvEntry != null) {\n                    result.add(new BasicTsKvEntry(value.get(TS).asLong(), kvEntry));\n                }\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 56.15768058325001}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tthingsboard.server.common.data.id.UserId;", "CodeBleu_score": 1.574344451957297}, {"code": "public void refreshToken(){\n\tthingsboard.server.common.data.id.UserId;", "CodeBleu_score": 1.574344451957297}, {"code": "public void refreshToken(){\n\tthingsboard.server.common.data.id.UserId;", "CodeBleu_score": 1.574344451957297}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tboard.server.common.data.oauth2.OAuth2Info;", "CodeBleu_score": 1.4246777943117195}, {"code": " private void doLogin(){\n\tboard.server.common.data.oauth2.OAuth2Info;", "CodeBleu_score": 1.4246777943117195}, {"code": " private void doLogin(){\n\tboard.server.common.data.oauth2.OAuth2Info;", "CodeBleu_score": 1.4246777943117195}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t{\n            ResponseEntity<Dashboard> dashboard = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/dashboard/{dashboardId}\\\", null, Dashboard.class, customerId.getId(), dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }", "CodeBleu_score": 37.18034002556108}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t{\n            ResponseEntity<Dashboard> dashboard = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/dashboard/{dashboardId}\\\", null, Dashboard.class, customerId.getId(), dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }", "CodeBleu_score": 37.18034002556108}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t{\n            ResponseEntity<Dashboard> dashboard = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/dashboard/{dashboardId}\\\", null, Dashboard.class, customerId.getId(), dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }", "CodeBleu_score": 37.18034002556108}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tn\n    public Optional<Dashboard> unassignDashboardFromPublicCustomer(DashboardId dashboardId) {\n        try {\n            ResponseEntity<Dashboard> dashboard = restTemplate.exchange(baseURL + \\\"/api/customer/public/dashboard/{dashboardId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Dashboard.class, dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(TenantId tenantId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"tenantId\\\", tenantId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/{tenantId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getCustomerDashboards(CustomerId customerId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"customerId\\\", customerId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/customer/{customerId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    @Deprecated\n    public Dashboard createDashboard(Dashboard dashboard) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/dashboard\\\", dashboard, Dashboard.class).getBody();\n    }\n\n    @Deprecated\n    public List<DashboardInfo> findTenantDashboards() {\n        try {\n            ResponseEntity<PageData<DashboardInfo>> dashboards =\n                    restTemplate.exchange(baseURL + \\\"/api/tenant/dashboards?pageSize=100000\\\", HttpMethod.GET, null, new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                    });\n            return dashboards.getBody().getData();\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Collections.emptyList();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}\\\", Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceInfo> getDeviceInfoById(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceInfo> device = restTemplate.getForEntity(baseURL + \\\"/api/device/info/{deviceId}\\\", DeviceInfo.class, deviceId);\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Device saveDevice(Device device) {\n        return saveDevice(device, null);\n    }\n\n    public Device saveDevice(Device device, String accessToken) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device?accessToken={accessToken}\\\", device, Device.class, accessToken).getBody();\n    }\n\n    public void deleteDevice(DeviceId deviceId) {\n        restTemplate.delete(baseURL + \\\"/api/device/{deviceId}\\\", deviceId.getId());\n    }\n\n    public Optional<Device> assignDeviceToCustomer(CustomerId customerId, DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/device/{deviceId}\\\", null, Device.class, customerId.getId(), deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> unassignDeviceFromCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.exchange(baseURL + \\\"/api/customer/device/{deviceId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> assignDeviceToPublicCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/public/device/{deviceId}\\\", null, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceCredentials> getDeviceCredentialsByDeviceId(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceCredentials> deviceCredentials = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}/credentials\\\", DeviceCredentials.class, deviceId.getId());\n            return Optional.ofNullable(deviceCredentials.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public DeviceCredentials saveDeviceCredentials(DeviceCredentials deviceCredentials) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device/credentials\\\", deviceCredentials, DeviceCredentials.class).getBody();\n    }\n\n\n\n", "CodeBleu_score": 25.45344494018894}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tn\n    public Optional<Dashboard> unassignDashboardFromPublicCustomer(DashboardId dashboardId) {\n        try {\n            ResponseEntity<Dashboard> dashboard = restTemplate.exchange(baseURL + \\\"/api/customer/public/dashboard/{dashboardId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Dashboard.class, dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(TenantId tenantId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"tenantId\\\", tenantId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/{tenantId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getCustomerDashboards(CustomerId customerId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"customerId\\\", customerId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/customer/{customerId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    @Deprecated\n    public Dashboard createDashboard(Dashboard dashboard) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/dashboard\\\", dashboard, Dashboard.class).getBody();\n    }\n\n    @Deprecated\n    public List<DashboardInfo> findTenantDashboards() {\n        try {\n            ResponseEntity<PageData<DashboardInfo>> dashboards =\n                    restTemplate.exchange(baseURL + \\\"/api/tenant/dashboards?pageSize=100000\\\", HttpMethod.GET, null, new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                    });\n            return dashboards.getBody().getData();\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Collections.emptyList();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}\\\", Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceInfo> getDeviceInfoById(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceInfo> device = restTemplate.getForEntity(baseURL + \\\"/api/device/info/{deviceId}\\\", DeviceInfo.class, deviceId);\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Device saveDevice(Device device) {\n        return saveDevice(device, null);\n    }\n\n    public Device saveDevice(Device device, String accessToken) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device?accessToken={accessToken}\\\", device, Device.class, accessToken).getBody();\n    }\n\n    public void deleteDevice(DeviceId deviceId) {\n        restTemplate.delete(baseURL + \\\"/api/device/{deviceId}\\\", deviceId.getId());\n    }\n\n    public Optional<Device> assignDeviceToCustomer(CustomerId customerId, DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/device/{deviceId}\\\", null, Device.class, customerId.getId(), deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> unassignDeviceFromCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.exchange(baseURL + \\\"/api/customer/device/{deviceId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> assignDeviceToPublicCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/public/device/{deviceId}\\\", null, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceCredentials> getDeviceCredentialsByDeviceId(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceCredentials> deviceCredentials = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}/credentials\\\", DeviceCredentials.class, deviceId.getId());\n            return Optional.ofNullable(deviceCredentials.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public DeviceCredentials saveDeviceCredentials(DeviceCredentials deviceCredentials) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device/credentials\\\", deviceCredentials, DeviceCredentials.class).getBody();\n    }\n\n\n\n", "CodeBleu_score": 25.45344494018894}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tn\n    public Optional<Dashboard> unassignDashboardFromPublicCustomer(DashboardId dashboardId) {\n        try {\n            ResponseEntity<Dashboard> dashboard = restTemplate.exchange(baseURL + \\\"/api/customer/public/dashboard/{dashboardId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Dashboard.class, dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(TenantId tenantId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"tenantId\\\", tenantId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/{tenantId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getCustomerDashboards(CustomerId customerId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"customerId\\\", customerId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/customer/{customerId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    @Deprecated\n    public Dashboard createDashboard(Dashboard dashboard) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/dashboard\\\", dashboard, Dashboard.class).getBody();\n    }\n\n    @Deprecated\n    public List<DashboardInfo> findTenantDashboards() {\n        try {\n            ResponseEntity<PageData<DashboardInfo>> dashboards =\n                    restTemplate.exchange(baseURL + \\\"/api/tenant/dashboards?pageSize=100000\\\", HttpMethod.GET, null, new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                    });\n            return dashboards.getBody().getData();\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Collections.emptyList();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}\\\", Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceInfo> getDeviceInfoById(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceInfo> device = restTemplate.getForEntity(baseURL + \\\"/api/device/info/{deviceId}\\\", DeviceInfo.class, deviceId);\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Device saveDevice(Device device) {\n        return saveDevice(device, null);\n    }\n\n    public Device saveDevice(Device device, String accessToken) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device?accessToken={accessToken}\\\", device, Device.class, accessToken).getBody();\n    }\n\n    public void deleteDevice(DeviceId deviceId) {\n        restTemplate.delete(baseURL + \\\"/api/device/{deviceId}\\\", deviceId.getId());\n    }\n\n    public Optional<Device> assignDeviceToCustomer(CustomerId customerId, DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/device/{deviceId}\\\", null, Device.class, customerId.getId(), deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> unassignDeviceFromCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.exchange(baseURL + \\\"/api/customer/device/{deviceId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> assignDeviceToPublicCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/public/device/{deviceId}\\\", null, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceCredentials> getDeviceCredentialsByDeviceId(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceCredentials> deviceCredentials = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}/credentials\\\", DeviceCredentials.class, deviceId.getId());\n            return Optional.ofNullable(deviceCredentials.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public DeviceCredentials saveDeviceCredentials(DeviceCredentials deviceCredentials) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device/credentials\\\", deviceCredentials, DeviceCredentials.class).getBody();\n    }\n\n\n\n", "CodeBleu_score": 25.45344494018894}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tices || (options.addresses ? options.addresses.length : 1);\n\n    this.memory = Array(64).fill(0);\n\n    options.dims = options.dims || LedControl.MATRIX_DIMENSIONS[\\\"8x8\\\"];\n    if (typeof options.dims === \\\"string\\\") {\n      options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];\n    }\n    if (Array.isArray(options.dims)) {\n      options.dims = {\n        rows: options.dims[0],\n        columns: options.dims[1],\n      };\n    }\n    const state = {\n      devices,\n      digits: options.digits || 8,\n      isMatrix: !!options.isMatrix,\n      isBicolor: !!options.isBicolor,\n      rows: options.dims.rows,\n      columns: options.dims.columns\n    };\n\n    if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {\n      throw new Error(\\\"Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16\\\");\n    }\n\n    Object.defineProperties(this, {\n      devices: {\n        get() {\n          return state.devices;\n        }\n      },\n      digits: {\n        get() {\n          return state.digits;\n        }\n      },\n      isMatrix: {\n        get() {\n          return state.isMatrix;\n        }\n      },\n      isBicolor: {\n        get() {\n          return state.isBicolor;\n        }\n      },\n      rows: {\n        get() {\n          return state.rows;\n        }\n      },\n      columns: {\n        get() {\n          return state.columns;\n        }\n      }\n    });\n\n    priv.set(this, state);\n    this.initialize(options);\n  }", "CodeBleu_score": 36.29992121738668}, {"code": "brightness(addr, val){\n\tices || (options.addresses ? options.addresses.length : 1);\n\n    this.memory = Array(64).fill(0);\n\n    options.dims = options.dims || LedControl.MATRIX_DIMENSIONS[\\\"8x8\\\"];\n    if (typeof options.dims === \\\"string\\\") {\n      options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];\n    }\n    if (Array.isArray(options.dims)) {\n      options.dims = {\n        rows: options.dims[0],\n        columns: options.dims[1],\n      };\n    }\n    const state = {\n      devices,\n      digits: options.digits || 8,\n      isMatrix: !!options.isMatrix,\n      isBicolor: !!options.isBicolor,\n      rows: options.dims.rows,\n      columns: options.dims.columns\n    };\n\n    if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {\n      throw new Error(\\\"Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16\\\");\n    }\n\n    Object.defineProperties(this, {\n      devices: {\n        get() {\n          return state.devices;\n        }\n      },\n      digits: {\n        get() {\n          return state.digits;\n        }\n      },\n      isMatrix: {\n        get() {\n          return state.isMatrix;\n        }\n      },\n      isBicolor: {\n        get() {\n          return state.isBicolor;\n        }\n      },\n      rows: {\n        get() {\n          return state.rows;\n        }\n      },\n      columns: {\n        get() {\n          return state.columns;\n        }\n      }\n    });\n\n    priv.set(this, state);\n    this.initialize(options);\n  }", "CodeBleu_score": 36.29992121738668}, {"code": "brightness(addr, val){\n\tices || (options.addresses ? options.addresses.length : 1);\n\n    this.memory = Array(64).fill(0);\n\n    options.dims = options.dims || LedControl.MATRIX_DIMENSIONS[\\\"8x8\\\"];\n    if (typeof options.dims === \\\"string\\\") {\n      options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];\n    }\n    if (Array.isArray(options.dims)) {\n      options.dims = {\n        rows: options.dims[0],\n        columns: options.dims[1],\n      };\n    }\n    const state = {\n      devices,\n      digits: options.digits || 8,\n      isMatrix: !!options.isMatrix,\n      isBicolor: !!options.isBicolor,\n      rows: options.dims.rows,\n      columns: options.dims.columns\n    };\n\n    if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {\n      throw new Error(\\\"Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16\\\");\n    }\n\n    Object.defineProperties(this, {\n      devices: {\n        get() {\n          return state.devices;\n        }\n      },\n      digits: {\n        get() {\n          return state.digits;\n        }\n      },\n      isMatrix: {\n        get() {\n          return state.isMatrix;\n        }\n      },\n      isBicolor: {\n        get() {\n          return state.isBicolor;\n        }\n      },\n      rows: {\n        get() {\n          return state.rows;\n        }\n      },\n      columns: {\n        get() {\n          return state.columns;\n        }\n      }\n    });\n\n    priv.set(this, state);\n    this.initialize(options);\n  }", "CodeBleu_score": 36.29992121738668}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tfunction(device) {\n        this.off(device);\n      });\n    }", "CodeBleu_score": 3.2744538104954604}, {"code": "device(addr){\n\tfunction(device) {\n        this.off(device);\n      });\n    }", "CodeBleu_score": 3.2744538104954604}, {"code": "device(addr){\n\tfunction(device) {\n        this.off(device);\n      });\n    }", "CodeBleu_score": 3.2744538104954604}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[`${method}All`] = function(duration, callback) {\n      if (typeof duration === 'function') {\n        callback = duration;\n        duration = 1000;\n      }\n      callback = callback || noop;\n\n      const promises = [];\n\n      this.each(function(input) {\n        promises.push(input[method](duration));\n      });\n\n      Promise.all(promises).then(callback, callback);\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 42.35993070766838}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[`${method}All`] = function(duration = 1000, callback = noop) {\n      const length = this.length;\n      const promises = [];\n\n      for (let i = 0; i < length; i++) {\n        promises.push(this[i][method](duration));\n      }\n\n      Promise.all(promises).then(() => {\n        callback();\n      });\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 39.39802262024801}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[`${method}Sync`] = function(duration = 1000, callback = noop) {\n      const promises = [];\n      const length = this.length;\n\n      for (let i = 0; i < length; i++) {\n        promises.push(this[i][method](duration));\n      }\n\n      Promise.all(promises).then(() => callback(null), callback);\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 38.47931128660665}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tquency) {\n        const state = priv.get(this);\n\n        // Enforce maximum frequency of 10hz\n        if (frequency < 10) {\n          frequency = 10;\n        }\n\n        state.frequency = frequency;\n        this.sendCommand(`$PMTK220,${String(1000 / state.frequency)}`);\n      }\n    }", "CodeBleu_score": 22.314932768602567}, {"code": "listen(){\n\tquency) {\n        const state = priv.get(this);\n\n        // Enforce maximum frequency of 10hz\n        if (frequency < 10) {\n          frequency = 10;\n        }\n\n        state.frequency = frequency;\n        this.sendCommand(`$PMTK220,${String(1000 / state.frequency)}`);\n      }\n    }", "CodeBleu_score": 22.314932768602567}, {"code": "listen(){\n\tquency) {\n        const state = priv.get(this);\n\n        // Enforce maximum frequency of 10hz\n        if (frequency < 10) {\n          frequency = 10;\n        }\n\n        state.frequency = frequency;\n        this.sendCommand(`$PMTK220,${String(1000 / state.frequency)}`);\n      }\n    }", "CodeBleu_score": 22.314932768602567}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0U;\n\tsize_t needed_buffer_size;\n\n\tfor (uint8_t i = 0; i < AD559X_PIN_MAX; i++) {\n\t\tif (data->adc_conf & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= (1 + sequence->options->extra_samplings);\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.52773401906087}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tuint8_t channels = 0U;\n\tuint32_t buffer_size;\n\tuint32_t sample_size;\n\tuint32_t num_channels;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\n\tfor (uint8_t i = 0; i < AD559X_PIN_MAX; i++) {\n\t\tif (data->adc_conf & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tnum_channels = channels;\n\n\tif (sequence->options & ADC_RESOLUTION_12_BITS) {\n\t\tsample_size = 2U;\n\t} else {\n\t\tsample_size = 4U;\n\t}\n\n\tbuffer_size = num_channels * sample_size;\n\n\tif (sequence->options & ADC_REFERENCE_INTERNAL) {\n\t\tbuffer_size += num_channels * sample_size;\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small. Expected %d, got %d\",\n\t\t\tbuffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.72253014289348}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tuint8_t channels = 0U;\n\tsize_t needed_buffer_size;\n\n\tfor (uint8_t i = 0U; i < AD559X_PIN_MAX; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= (1U + sequence->options->extra_samplings);\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size too small. Needed %d, provided %d\",\n\t\t\tneeded_buffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.98798072544599}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint err;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0U) {\n\t\tLOG_ERR(\"oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels > AD559X_PIN_MAX) {\n\t\tLOG_ERR(\"unsupported channels\");\n\t\treturn -ENOTSUP;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->buffer;\n\tdata->channels = channels;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terr = k_thread_create(&data->thread, data->stack,\n\t\t\t      CONFIG_ADC_AD559X_ACQUISITION_THREAD_STACK_SIZE,\n\t\t\t      (k_thread_entry_t)adc_context_wait,\n\t\t\t      &data->ctx, &data->sem, NULL,\n\t\t\t      K_PRIO_COOP(CONFIG_ADC_AD559X_ACQUISITION_THREAD_PRIO),\n\t\t\t      0, K_NO_WAIT);\n\n\treturn err;\n}", "CodeBleu_score": 64.47798880477983}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint err;\n\tuint16_t *buffer;\n\tuint16_t *repeat_buffer;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & ~BIT_MASK(AD559X_PIN_MAX)) {\n\t\tLOG_ERR(\"unsupported channels in mask: 0x%08x\", sequence->channels);\n\t\treturn -ENOTSUP;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tbuffer = sequence->buffer;\n\n\tif (sequence->buffer_size == 0) {\n\t\tbuffer = data->repeat_buffer;\n\t}\n\n\tdata->buffer = buffer;\n\tdata->repeat_buffer = buffer;\n\tdata->channels = sequence->channels;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terr = adc_context_wait_for_completion(&data->ctx);\n\n\treturn err;\n}", "CodeBleu_score": 67.15465689865215}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint err;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels == 0U) {\n\t\tLOG_ERR(\"no channels selected\");\n\t\treturn -ENOTSUP;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\tLOG_ERR(\"insufficient buffer size\");\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->buffer;\n\tdata->channels = channels;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terr = adc_context_wait_for_completion(&data->ctx);\n\treturn err;\n}", "CodeBleu_score": 71.820469322042}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t_context.h\\\"\n", "CodeBleu_score": 11.71008504244409}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t_context.h\\\"\n", "CodeBleu_score": 11.71008504244409}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t_context.h\\\"\n", "CodeBleu_score": 11.71008504244409}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t59X_ADC_RES_IND_BIT BIT(15)", "CodeBleu_score": 2.3493487807572566}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t59X_ADC_RES_IND_BIT BIT(15)", "CodeBleu_score": 2.3493487807572566}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t59X_ADC_RES_IND_BIT BIT(15)", "CodeBleu_score": 2.3493487807572566}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tyr/drivers/adc.h>", "CodeBleu_score": 5.635092468682876}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tyr/drivers/adc.h>", "CodeBleu_score": 5.635092468682876}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tyr/drivers/adc.h>", "CodeBleu_score": 5.635092468682876}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tdt(&config->bus, msg, sizeof(msg));\n}", "CodeBleu_score": 14.763063739505563}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tdt(&config->bus, msg, sizeof(msg));\n}", "CodeBleu_score": 14.763063739505563}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tdt(&config->bus, msg, sizeof(msg));\n}", "CodeBleu_score": 14.763063739505563}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t112_CONFIG_DR_RATE_240_RES_12;\n\t\tready_time_us = (1000 * 1000) / 240;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}", "CodeBleu_score": 7.577593142112677}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t112_CONFIG_DR_RATE_240_RES_12;\n\t\tready_time_us = (1000 * 1000) / 240;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}", "CodeBleu_score": 7.577593142112677}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t112_CONFIG_DR_RATE_240_RES_12;\n\t\tready_time_us = (1000 * 1000) / 240;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}", "CodeBleu_score": 7.577593142112677}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tenum i2s_dir dir;\n\tenum i2s_state state;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"invalid state (%d)\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdir = I2S_DIR_RX;\n\t\tstate = I2S_STATE_RX;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"invalid state (%d)\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdir = I2S_DIR_RX;\n\t\tstate = I2S_STATE_READY;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"unsupported command (%d)\", cmd);\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = i2s_trigger(config->comm_master, dir, state);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"trigger failed (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->state = (state == I2S_STATE_RX) ? DMIC_STATE_ACTIVE : DMIC_STATE_CONFIGURED;\n\n\treturn 0;\n}", "CodeBleu_score": 70.72645836315188}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tenum i2s_dir i2s_dir;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"unexpected state %d\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\ti2s_dir = I2S_DIR_RX;\n\t\tret = i2s_trigger(config->comm_master, i2s_dir, I2S_TRIGGER_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"I2S_TRIGGER_START failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"unexpected state %d\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\ti2s_dir = I2S_DIR_RX;\n\t\tret = i2s_trigger(config->comm_master, i2s_dir, I2S_TRIGGER_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"I2S_TRIGGER_STOP failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"unexpected trigger command %d\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.83789403885999}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tenum i2s_state state = data->i2s_state;\n\tenum i2s_cmd i2s_cmd = I2S_CMD_NONE;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tswitch (state) {\n\t\tcase I2S_STATE_NOT_READY:\n\t\t\ti2s_cmd = I2S_CMD_PREPARE;\n\t\t\tstate = I2S_STATE_READY;\n\t\t\tbreak;\n\t\tcase I2S_STATE_READY:\n\t\t\ti2s_cmd = I2S_CMD_START;\n\t\t\tstate = I2S_STATE_ACTIVE;\n\t\t\tbreak;\n\t\tcase I2S_STATE_ACTIVE:\n\t\t\tLOG_ERR(\"START trigger: invalid state %d\", state);\n\t\t\treturn -EIO;\n\t\tdefault:\n\t\t\tLOG_ERR(\"START trigger: invalid state %d\", state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tswitch (state) {\n\t\tcase I2S_STATE_ACTIVE:\n\t\t\ti2s_cmd = I2S_CMD_STOP;\n\t\t\tstate = I2S_STATE_READY;\n\t\t\tbreak;\n\t\tcase I2S_STATE_READY:\n\t\t\ti2s_cmd = I2S_CMD_RELEASE;\n\t\t\tstate = I2S_STATE_NOT_READY;\n\t\t\tbreak;\n\t\tcase I2S_STATE_NOT_READY:\n\t\t\tLOG_ERR(\"STOP trigger: invalid state %d\", state);\n\t\t\treturn -EIO;\n\t\tdefault:\n\t\t\tLOG_ERR(\"STOP trigger: invalid state %d\", state);\n\t\t\treturn -EIO;", "CodeBleu_score": 54.02484375601262}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tMODE_8_BIT) {\n\t\t/* This index is reserved for internal driver usage */\n\t\tLOG_ERR(\\\"HD44780 mode must be 4 or 8-bit\\\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Configure and set GPIOs */\n\trc = gpio_pin_configure_dt(&config->rs_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of RS GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->rw_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->rw_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of RW GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = gpio_pin_configure_dt(&config->e_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of E GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\ti = 4;\n\t}\n\n\twhile (i < 8) {\n\t\tif (config->db_gpios[i].port) {\n\t\t\trc = gpio_pin_configure_dt(&config->db_gpios[i], GPIO_OUTPUT);\n\n\t\t\tif (rc < 0) {\n\t\t\t\tLOG_ERR(\\\"Configuration of DB%d GPIO failed: %d\\\", i, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT && i > 3) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing (DB4-DB7 needed for 4-bit mode)\\\", i);\n\t\t\treturn -EINVAL;\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing\\\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->backlight_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of backlight GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->backlight_gpio, 0);\n\t}\n\n\tdata->character_x = 0;\n\tdata->character_y = 0;\n\tdata->backlight_state = false;\n\tdata->cursor_enabled = false;\n\tdata->position_blink_enabled = false;\n\tdata->direction = AUXDISPLAY_DIRECTION_RIGHT;\n\n\tif (config->boot_delay != 0) {\n\t\t/* Boot delay is set, wait for a period of time for the LCD to become ready to\n\t\t * accept commands\n\t\t */\n\t\tk_sleep(K_MSEC(config->boot_delay));\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\t/* Reset display to known state in 8-bit mode */\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\n\t\t/* Put display into 4-bit mode */\n\t\tcmd = AUXDISPLAY_HD44780_CMD_SETUP;\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t}\n\n\tif (config->capabilities.rows > 1) {\n\t\tcmd |= AUXDISPLAY_HD44780_2_LINE_CONFIG;\n\t}\n\n\t/* Configure display */\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n\tauxdisplay_hd44780_set_display_mode(dev, true);\n\tauxdisplay_hd44780_set_entry_mode(dev);\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_CMD_CLEAR,\n\t\t\t\t   config->capabilities.mode);\n\n\tk_sleep(K_USEC(config->clear_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 47.68964851258848}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tMODE_8_BIT) {\n\t\t/* This index is reserved for internal driver usage */\n\t\tLOG_ERR(\\\"HD44780 mode must be 4 or 8-bit\\\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Configure and set GPIOs */\n\trc = gpio_pin_configure_dt(&config->rs_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of RS GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->rw_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->rw_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of RW GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = gpio_pin_configure_dt(&config->e_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of E GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\ti = 4;\n\t}\n\n\twhile (i < 8) {\n\t\tif (config->db_gpios[i].port) {\n\t\t\trc = gpio_pin_configure_dt(&config->db_gpios[i], GPIO_OUTPUT);\n\n\t\t\tif (rc < 0) {\n\t\t\t\tLOG_ERR(\\\"Configuration of DB%d GPIO failed: %d\\\", i, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT && i > 3) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing (DB4-DB7 needed for 4-bit mode)\\\", i);\n\t\t\treturn -EINVAL;\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing\\\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->backlight_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of backlight GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->backlight_gpio, 0);\n\t}\n\n\tdata->character_x = 0;\n\tdata->character_y = 0;\n\tdata->backlight_state = false;\n\tdata->cursor_enabled = false;\n\tdata->position_blink_enabled = false;\n\tdata->direction = AUXDISPLAY_DIRECTION_RIGHT;\n\n\tif (config->boot_delay != 0) {\n\t\t/* Boot delay is set, wait for a period of time for the LCD to become ready to\n\t\t * accept commands\n\t\t */\n\t\tk_sleep(K_MSEC(config->boot_delay));\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\t/* Reset display to known state in 8-bit mode */\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\n\t\t/* Put display into 4-bit mode */\n\t\tcmd = AUXDISPLAY_HD44780_CMD_SETUP;\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t}\n\n\tif (config->capabilities.rows > 1) {\n\t\tcmd |= AUXDISPLAY_HD44780_2_LINE_CONFIG;\n\t}\n\n\t/* Configure display */\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n\tauxdisplay_hd44780_set_display_mode(dev, true);\n\tauxdisplay_hd44780_set_entry_mode(dev);\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_CMD_CLEAR,\n\t\t\t\t   config->capabilities.mode);\n\n\tk_sleep(K_USEC(config->clear_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 47.68964851258848}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tMODE_8_BIT) {\n\t\t/* This index is reserved for internal driver usage */\n\t\tLOG_ERR(\\\"HD44780 mode must be 4 or 8-bit\\\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Configure and set GPIOs */\n\trc = gpio_pin_configure_dt(&config->rs_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of RS GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->rw_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->rw_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of RW GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = gpio_pin_configure_dt(&config->e_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of E GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\ti = 4;\n\t}\n\n\twhile (i < 8) {\n\t\tif (config->db_gpios[i].port) {\n\t\t\trc = gpio_pin_configure_dt(&config->db_gpios[i], GPIO_OUTPUT);\n\n\t\t\tif (rc < 0) {\n\t\t\t\tLOG_ERR(\\\"Configuration of DB%d GPIO failed: %d\\\", i, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT && i > 3) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing (DB4-DB7 needed for 4-bit mode)\\\", i);\n\t\t\treturn -EINVAL;\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing\\\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->backlight_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of backlight GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->backlight_gpio, 0);\n\t}\n\n\tdata->character_x = 0;\n\tdata->character_y = 0;\n\tdata->backlight_state = false;\n\tdata->cursor_enabled = false;\n\tdata->position_blink_enabled = false;\n\tdata->direction = AUXDISPLAY_DIRECTION_RIGHT;\n\n\tif (config->boot_delay != 0) {\n\t\t/* Boot delay is set, wait for a period of time for the LCD to become ready to\n\t\t * accept commands\n\t\t */\n\t\tk_sleep(K_MSEC(config->boot_delay));\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\t/* Reset display to known state in 8-bit mode */\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\n\t\t/* Put display into 4-bit mode */\n\t\tcmd = AUXDISPLAY_HD44780_CMD_SETUP;\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t}\n\n\tif (config->capabilities.rows > 1) {\n\t\tcmd |= AUXDISPLAY_HD44780_2_LINE_CONFIG;\n\t}\n\n\t/* Configure display */\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n\tauxdisplay_hd44780_set_display_mode(dev, true);\n\tauxdisplay_hd44780_set_entry_mode(dev);\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_CMD_CLEAR,\n\t\t\t\t   config->capabilities.mode);\n\n\tk_sleep(K_USEC(config->clear_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 47.68964851258848}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\"Configuration of busy interrupt failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}", "CodeBleu_score": 35.34045527442932}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\"Configuration of busy interrupt failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}", "CodeBleu_score": 35.34045527442932}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\"Configuration of busy interrupt failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}", "CodeBleu_score": 35.34045527442932}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02874204137314}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02874204137314}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02874204137314}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > config->size) {\n\t\tLOG_ERR(\"Requested read size %zu exceeds BBRAM size %d\", size, config->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Requested read size %zu exceeds BBRAM size %d\", size, config->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &emul_data->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 49.55765348205635}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *drv_data = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, drv_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 73.45565021103418}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, emul_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 68.42845053476468}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01712631282048}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01712631282048}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01712631282048}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device required\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 72.66145982432971}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint err;\n\tconst char *device_name;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device argument.\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_name = argv[1];\n\t*bbram_dev = device_get_binding(device_name);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device %s not found.\", device_name);\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_clear_status(*bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to clear BBRAM status.\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.98771146798087}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tconst char *device_name;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_name = argv[1];\n\n\t*bbram_dev = device_get_binding(device_name);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device %s not found\", device_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.79119126928676}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tuint8_t *hdr = (uint8_t *)&h4->rx.evt;\n\tuint8_t hdr_len = h4->rx.hdr_len;\n\tuint8_t read = hdr_len - h4->rx.remaining;\n\tint err;\n\n\terr = uart_fifo_read(cfg->uart, hdr + read, h4->rx.remaining);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Failed to read UART for header (%d)\", err);\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining -= err;\n}", "CodeBleu_score": 61.53653675851961}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tuint8_t *buf = (uint8_t *)&h4->rx.evt;\n\tsize_t len = h4->rx.hdr_len;\n\tsize_t read;\n\tint err;\n\n\tread = len - h4->rx.remaining;\n\n\terr = uart_fifo_read(cfg->uart, buf + read, h4->rx.remaining);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Unable to read H:4 packet header (%d)\", err);\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining -= err;\n}", "CodeBleu_score": 65.77373008348034}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tsize_t hdr_len = h4->rx.hdr_len;\n\tsize_t len;\n\tsize_t read;\n\n\tlen = hdr_len - h4->rx.remaining;\n\tread = uart_fifo_read(cfg->uart, h4->rx.hdr + len, h4->rx.remaining);\n\th4->rx.remaining -= read;\n\n\tif (read != h4->rx.remaining) {\n\t\tLOG_ERR(\"Unable to read full H:4 packet header (%u/%u)\",\n\t\t\tread + len, hdr_len);\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t}\n}", "CodeBleu_score": 66.2240328952733}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tn\t\th4->rx.remaining -= ret;\n\t}", "CodeBleu_score": 6.07277858175735}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tn\t\th4->rx.remaining -= ret;\n\t}", "CodeBleu_score": 6.07277858175735}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tn\t\th4->rx.remaining -= ret;\n\t}", "CodeBleu_score": 6.07277858175735}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tt timeout)", "CodeBleu_score": 6.099640716013399}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tt timeout)", "CodeBleu_score": 6.099640716013399}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tt timeout)", "CodeBleu_score": 6.099640716013399}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t->data->observers_end_idx;\n\t\t\t}", "CodeBleu_score": 10.595804393576385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t->data->observers_end_idx;\n\t\t\t}", "CodeBleu_score": 10.595804393576385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t->data->observers_end_idx;\n\t\t\t}", "CodeBleu_score": 10.595804393576385}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tpoint_timeout(end_time));\n\n\t\tif (cloned_buf == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnet_buf_put(obs->message_fifo, cloned_buf);\n\n\t\tbreak;\n\t}", "CodeBleu_score": 10.758565509750278}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tpoint_timeout(end_time));\n\n\t\tif (cloned_buf == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnet_buf_put(obs->message_fifo, cloned_buf);\n\n\t\tbreak;\n\t}", "CodeBleu_score": 10.758565509750278}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tpoint_timeout(end_time));\n\n\t\tif (cloned_buf == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnet_buf_put(obs->message_fifo, cloned_buf);\n\n\t\tbreak;\n\t}", "CodeBleu_score": 10.758565509750278}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \\\"observation must be not NULL\\\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 27.293356001899845}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \\\"observation must be not NULL\\\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 27.293356001899845}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \\\"observation must be not NULL\\\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 27.293356001899845}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t) {\n  ETH->BUS_MODE_b.PRWG = 0;\n    ETH->BUS_MODE_b.DA = ETH_DMA_ARBITRATION_ROUND_ROBIN;\n\n    ETH->BUS_MODE_b.TXPR = isRxPrior ? FALSE : TRUE;\n    ETH->BUS_MODE_b.PR = priorityRate;\n}\n", "CodeBleu_score": 20.674604538177967}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t) {\n  ETH->BUS_MODE_b.PRWG = 0;\n    ETH->BUS_MODE_b.DA = ETH_DMA_ARBITRATION_ROUND_ROBIN;\n\n    ETH->BUS_MODE_b.TXPR = isRxPrior ? FALSE : TRUE;\n    ETH->BUS_MODE_b.PR = priorityRate;\n}\n", "CodeBleu_score": 20.674604538177967}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t) {\n  ETH->BUS_MODE_b.PRWG = 0;\n    ETH->BUS_MODE_b.DA = ETH_DMA_ARBITRATION_ROUND_ROBIN;\n\n    ETH->BUS_MODE_b.TXPR = isRxPrior ? FALSE : TRUE;\n    ETH->BUS_MODE_b.PR = priorityRate;\n}\n", "CodeBleu_score": 20.674604538177967}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tyReg, uint32_t data) {\n    ETH->GMII_ADDR_b.PA = phyAddr;\n    ETH->GMII_ADDR_b.GR = phyReg;\n    ETH->GMII_ADDR_b.GW = PHY_OP_WRITE;\n  ETH->GMII_DATA = data;\n\n    ETH->GMII_ADDR_b.BUSY = TRUE;\n    while (ETH->GMII_ADDR_b.BUSY) ;\n}\n", "CodeBleu_score": 35.80475941862628}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tyReg, uint32_t data) {\n    ETH->GMII_ADDR_b.PA = phyAddr;\n    ETH->GMII_ADDR_b.GR = phyReg;\n    ETH->GMII_ADDR_b.GW = PHY_OP_WRITE;\n  ETH->GMII_DATA = data;\n\n    ETH->GMII_ADDR_b.BUSY = TRUE;\n    while (ETH->GMII_ADDR_b.BUSY) ;\n}\n", "CodeBleu_score": 35.80475941862628}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tyReg, uint32_t data) {\n    ETH->GMII_ADDR_b.PA = phyAddr;\n    ETH->GMII_ADDR_b.GR = phyReg;\n    ETH->GMII_ADDR_b.GW = PHY_OP_WRITE;\n  ETH->GMII_DATA = data;\n\n    ETH->GMII_ADDR_b.BUSY = TRUE;\n    while (ETH->GMII_ADDR_b.BUSY) ;\n}\n", "CodeBleu_score": 35.80475941862628}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_uint32_t cyp_channel;\n    cy_rslt_t result;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n    if (result != RT_EOK) {\n        LOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 80.93552573295392}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tcy_rslt_t result;\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC output enable*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n    if (result != RT_EOK) {\n        LOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n    return RT_EOK;\n}", "CodeBleu_score": 81.86851051221014}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_uint32_t cyp_channel;\n\n    cy_rslt_t result;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC free device*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n    if (result != RT_EOK) {\n        LOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n    return RT_EOK;\n}", "CodeBleu_score": 80.93552573295392}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page = get_page_32k(addr);\n    cy_rslt_t err = CY_RSLT_SUCCESS;\n\n    if (addr + size > flash_info.size) {\n        LOG_E(\"read outrange flash size! addr is (0x%p)\n\", (void*)(addr + size));\n        return -RT_EINVAL;\n    }\n\n    err = cyhal_flash_read(&flash_obj, page, buf, size);\n\n    if (CY_RSLT_SUCCESS != err) {\n        LOG_E(\"read flash failed\n\");\n        return -RT_ERROR;\n    }\n\n    return size;\n}", "CodeBleu_score": 49.960435283096444}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page = 0;\n    rt_uint32_t offset = 0;\n    rt_uint32_t read_size = 0;\n    rt_uint32_t read_addr = 0;\n    rt_uint32_t read_bytes = 0;\n    rt_uint32_t page_size = 0;\n    rt_uint32_t page_cnt = 0;\n    rt_uint32_t i = 0;\n    rt_uint32_t j = 0;\n\n    /* Check if the read operation would exceed the flash memory's end address */\n    if ((addr + size) > block_info.size) {\n        LOG_E(\"read outrange flash size! addr is (0x%p)\", (void*)(addr + size));\n        return -RT_EINVAL;\n    }\n\n    /* Calculate the page number of the address */\n    page = get_page_32k(addr);\n\n    /* Calculate the offset of the address */\n    offset = addr - page;\n\n    /* Calculate the size to read */\n    read_size = size;\n\n    /* Calculate the read address */\n    read_addr = page;\n\n    /* Calculate the read bytes */\n    read_bytes = size;\n\n    /* Calculate the page size */\n    page_size = IFX_EFLASH_PAGE_SIZE;\n\n    /* Calculate the page count */\n    page_cnt = read_size / page_size;\n\n    /* Read data from flash memory into the buffer */\n    for (i = 0; i < page_cnt; i++) {\n        cyhal_flash_read(&flash_obj, read_addr, buf + i * page_size, page_size);\n        read_addr += page_size;\n    }\n\n    /* Read the remaining data from flash memory into the buffer */\n    if (read_size % page_size != 0) {\n        cyhal_flash_read(&flash_obj, read_addr, buf + page_cnt * page_size, read_size % page_size", "CodeBleu_score": 55.33550641975062}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page = 0;\n    rt_uint32_t offset = 0;\n    rt_uint32_t addr_aligned = 0;\n    rt_uint32_t size_aligned = 0;\n    rt_uint32_t size_read = 0;\n    rt_uint32_t size_remain = 0;\n    rt_uint32_t size_copy = 0;\n    rt_uint32_t i = 0;\n    rt_uint8_t *p = RT_NULL;\n    rt_uint8_t *p_buf = RT_NULL;\n    cy_rslt_t err = CY_RSLT_SUCCESS;\n    if (addr + size > flash_info.size) {\n        LOG_E(\"Read out of flash size! addr is (0x%p)\", (void *)(addr + size));\n        return -RT_EINVAL;\n    }\n    addr_aligned = get_page_32k(addr);\n    size_aligned = get_page_32k(size);\n    size_remain = size_aligned - addr_aligned;\n    size_copy = size_aligned - addr_aligned;\n    p = (rt_uint8_t *)(addr_aligned);\n    p_buf = buf;\n    while (size_copy) {\n        if (size_copy > IFX_EFLASH_PAGE_SIZE) {\n            size_read = IFX_EFLASH_PAGE_SIZE;\n        } else {\n            size_read = size_copy;\n        }\n        err = cyhal_flash_read(&flash_obj, addr_aligned, p_buf, size_read);\n        if (CY_RSLT_SUCCESS != err) {\n            LOG_E(\"Read flash failed\");\n            return -RT_EIO;\n        }\n        addr_aligned += size_read;\n        p_buf += size_read;\n        size_copy -= size_read;\n    }\n    return size_aligned;\n}", "CodeBleu_score": 48.08233688235587}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 44.41255133467903}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 44.41255133467903}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 44.41255133467903}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (!fdt->fds[fd]) {\n            return fd;\n        }\n    }\n\n    /* try to expand the fd table */\n    if (fd_slot_expand(fdt, fd) == fd) {\n        return fd;\n    }\n\n    return -1;\n}", "CodeBleu_score": 35.525719458653136}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint index;\n\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* try to expand the fd table */\n    return fd_slot_expand(fdt, index);\n}", "CodeBleu_score": 29.866820107906598}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* try to expand the fd table */\n    fd = fdt->maxfd;\n    if (fd_slot_expand(fdt, fd) == fd) {\n        return fd;\n    }\n\n    return -1;\n}", "CodeBleu_score": 40.873821637163914}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\n        default:\n            if (str < end)\n            {\n                *str = '%';\n            }\n            ++ str;\n\n            if (*fmt)\n            {\n                if (str < end)\n                {\n                    *str = *fmt;\n                }\n                ++ str;\n            }\n            else\n            {\n                -- fmt;\n            }\n            continue;\n        }", "CodeBleu_score": 24.282408913325693}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n        default:\n            if (str < end)\n            {\n                *str = '%';\n            }\n            ++ str;\n\n            if (*fmt)\n            {\n                if (str < end)\n                {\n                    *str = *fmt;\n                }\n                ++ str;\n            }\n            else\n            {\n                -- fmt;\n            }\n            continue;\n        }", "CodeBleu_score": 24.282408913325693}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n        default:\n            if (str < end)\n            {\n                *str = '%';\n            }\n            ++ str;\n\n            if (*fmt)\n            {\n                if (str < end)\n                {\n                    *str = *fmt;\n                }\n                ++ str;\n            }\n            else\n            {\n                -- fmt;\n            }\n            continue;\n        }", "CodeBleu_score": 24.282408913325693}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_slist_t *list;\n    int i;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* find an empty hook */\n    list = &idle_hook_list[0];\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_slist_entry(list, struct idle_hook_list, list) == RT_NULL) {\n            break;\n        }\n        list = rt_slist_next(list);\n    }\n\n    /* no more hook */\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        rt_hw_interrupt_enable(level);\n        return -RT_EFULL;\n    }\n\n    /* install hook */\n    rt_slist_append(&idle_hook_list[i], &(struct idle_hook_list){hook});\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 52.28205006075915}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n    rt_base_t level;\n\n    level = rt_spin_lock(&_hook_spinlock);\n\n    /* find a empty list */\n    int i;\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)\n    {\n        if (idle_hook_list[i] == RT_NULL)\n        {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* no empty list */\n    if (i == RT_IDLE_HOOK_LIST_SIZE)\n    {\n        result = -RT_EFULL;\n    }\n\n    rt_spin_unlock(&_hook_spinlock);\n\n    return result;\n}", "CodeBleu_score": 76.47290770589554}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_slist_t *list;\n    rt_slist_t *node;\n    int i;\n\n    if (hook == RT_NULL) return -RT_EINVAL;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    /* find a empty list */\n    list = RT_NULL;\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            list = &idle_hook_list[i];\n            break;\n        }\n    }\n\n    if (list != RT_NULL) {\n        rt_slist_init(list);\n        node = rt_slist_first(list);\n        while (node) {\n            if (rt_slist_entry(node, struct idle_hook_list, list) == RT_NULL) {\n                rt_slist_append(list, &((struct idle_hook_list){hook}).list);\n                break;\n            }\n            node = rt_slist_next(node);\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    if (list == RT_NULL) {\n        return -RT_EFULL;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 63.967242917848665}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.40823173009815}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.40823173009815}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.40823173009815}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t0-25     Bernard      change the mb/mq receive timeout to 0 if the\n *                             re-calculated delta tick is a negative number.\n * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag\n *                             is RT_IPC_FLAG_PRIO\n * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.\n * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq\n * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete\n * 2010-11-10     Bernard      add IPC reset command implementation.\n * 2011-12-18     Bernard      add more parameter checking in message queue\n * 2013-09-14     Grissiom     add an option check in rt_event_recv\n * 2018-10-02     Bernard      add 64bit support for mailbox\n * 2019-09-16     tyx          add send wait support for message queue\n * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an\n *                             event without pending\n * 2020-10-11     Meco Man     add value overflow-check code\n * 2021-01-03     Meco Man     implement rt_mb_urgent()\n * 2021-05-30     Meco Man     implement rt_mutex_trytake()\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to ipc.c\n * 2022-01-24     THEWON       let rt_mutex_take return thread->error when using signal\n * 2022-04-08     Stanley      Correct descriptions\n * 2022-10-15     Bernard      add nested mutex feature\n * 2022-10-16     Bernard      add prioceiling feature in mutex\n * 2023-04-16     Xin-zheqi    redesigen queue recv and send function return real message size\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n */\n", "CodeBleu_score": 18.13451986974496}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t0-25     Bernard      change the mb/mq receive timeout to 0 if the\n *                             re-calculated delta tick is a negative number.\n * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag\n *                             is RT_IPC_FLAG_PRIO\n * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.\n * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq\n * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete\n * 2010-11-10     Bernard      add IPC reset command implementation.\n * 2011-12-18     Bernard      add more parameter checking in message queue\n * 2013-09-14     Grissiom     add an option check in rt_event_recv\n * 2018-10-02     Bernard      add 64bit support for mailbox\n * 2019-09-16     tyx          add send wait support for message queue\n * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an\n *                             event without pending\n * 2020-10-11     Meco Man     add value overflow-check code\n * 2021-01-03     Meco Man     implement rt_mb_urgent()\n * 2021-05-30     Meco Man     implement rt_mutex_trytake()\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to ipc.c\n * 2022-01-24     THEWON       let rt_mutex_take return thread->error when using signal\n * 2022-04-08     Stanley      Correct descriptions\n * 2022-10-15     Bernard      add nested mutex feature\n * 2022-10-16     Bernard      add prioceiling feature in mutex\n * 2023-04-16     Xin-zheqi    redesigen queue recv and send function return real message size\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n */\n", "CodeBleu_score": 18.13451986974496}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t0-25     Bernard      change the mb/mq receive timeout to 0 if the\n *                             re-calculated delta tick is a negative number.\n * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag\n *                             is RT_IPC_FLAG_PRIO\n * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.\n * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq\n * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete\n * 2010-11-10     Bernard      add IPC reset command implementation.\n * 2011-12-18     Bernard      add more parameter checking in message queue\n * 2013-09-14     Grissiom     add an option check in rt_event_recv\n * 2018-10-02     Bernard      add 64bit support for mailbox\n * 2019-09-16     tyx          add send wait support for message queue\n * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an\n *                             event without pending\n * 2020-10-11     Meco Man     add value overflow-check code\n * 2021-01-03     Meco Man     implement rt_mb_urgent()\n * 2021-05-30     Meco Man     implement rt_mutex_trytake()\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to ipc.c\n * 2022-01-24     THEWON       let rt_mutex_take return thread->error when using signal\n * 2022-04-08     Stanley      Correct descriptions\n * 2022-10-15     Bernard      add nested mutex feature\n * 2022-10-16     Bernard      add prioceiling feature in mutex\n * 2023-04-16     Xin-zheqi    redesigen queue recv and send function return real message size\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n */\n", "CodeBleu_score": 18.13451986974496}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t16bit word)\n * 2022-08-30     Yunjie       make rt_vsnprintf adapt to ti c28x (16bit int)\n * 2023-02-02     Bernard      add Smart ID for logo version show\n * 2023-10-16     Shell        Add hook point for rt_malloc services\n * 2023-10-21     Shell        support the common backtrace API which is arch-independent\n * 2023-12-10     xqyjlj       perf rt_hw_interrupt_disable/enable, fix memheap lock\n * 2024-03-10     Meco Man     move std libc related functions to rtklibc\n */\n", "CodeBleu_score": 14.181726744612325}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t16bit word)\n * 2022-08-30     Yunjie       make rt_vsnprintf adapt to ti c28x (16bit int)\n * 2023-02-02     Bernard      add Smart ID for logo version show\n * 2023-10-16     Shell        Add hook point for rt_malloc services\n * 2023-10-21     Shell        support the common backtrace API which is arch-independent\n * 2023-12-10     xqyjlj       perf rt_hw_interrupt_disable/enable, fix memheap lock\n * 2024-03-10     Meco Man     move std libc related functions to rtklibc\n */\n", "CodeBleu_score": 14.181726744612325}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t16bit word)\n * 2022-08-30     Yunjie       make rt_vsnprintf adapt to ti c28x (16bit int)\n * 2023-02-02     Bernard      add Smart ID for logo version show\n * 2023-10-16     Shell        Add hook point for rt_malloc services\n * 2023-10-21     Shell        support the common backtrace API which is arch-independent\n * 2023-12-10     xqyjlj       perf rt_hw_interrupt_disable/enable, fix memheap lock\n * 2024-03-10     Meco Man     move std libc related functions to rtklibc\n */\n", "CodeBleu_score": 14.181726744612325}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tINIT}", "CodeBleu_score": 8.059744140928478}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tINIT}", "CodeBleu_score": 8.059744140928478}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tINIT}", "CodeBleu_score": 8.059744140928478}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t*/\nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object))\n{\n    rt_object_put_hook = hook;\n}\n\n/**@}", "CodeBleu_score": 8.172267313922596}, {"code": "void rt_object_detach(rt_object_t object){\n\t*/\nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object))\n{\n    rt_object_put_hook = hook;\n}\n\n/**@}", "CodeBleu_score": 8.172267313922596}, {"code": "void rt_object_detach(rt_object_t object){\n\t*/\nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object))\n{\n    rt_object_put_hook = hook;\n}\n\n/**@}", "CodeBleu_score": 8.172267313922596}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}", "CodeBleu_score": 16.1107885441012}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}", "CodeBleu_score": 16.1107885441012}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}", "CodeBleu_score": 16.1107885441012}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n    register rt_base_t level;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(!rt_list_isempty(&thread->tlist));\n\n    /* detach object */\n    rt_object_detach((rt_object_t)thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* invoke thread cleanup */\n    if (thread->cleanup != RT_NULL) {\n        thread->cleanup(thread);\n    }\n\n    /* enable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* release thread stack */\n    RT_OBJECT_HOOK_CALL(rt_thread_exit_hook, (thread));\n\n    /* change stat */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* invoke scheduler */\n    rt_schedule();\n\n    /* never come here */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 56.00950489075331}, {"code": "static void _thread_exit(void){\n\trt_base_t level;\n    struct rt_thread *thread;\n    struct rt_thread *current_thread;\n    struct rt_thread *to_thread = RT_NULL;\n    rt_thread_t *ready_thread = RT_NULL;\n    rt_uint32_t exit_code;\n\n    /* get current thread */\n    current_thread = rt_thread_self();\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* get the next thread to run */\n    ready_thread = (rt_thread_t *)rt_list_entry(rt_thread_defunct.next,\n                                                struct rt_thread,\n                                                tlist);\n    /* remove thread from schedule */\n    rt_schedule_remove_thread(current_thread);\n\n    /* invoke thread cleanup */\n    if (current_thread->cleanup != RT_NULL)\n        current_thread->cleanup(current_thread);\n\n    /* change stat */\n    current_thread->stat = RT_THREAD_CLOSE;\n\n    /* exit code */\n    exit_code = current_thread->error;\n\n    /* release thread timer */\n    if (current_thread->thread_timer != RT_NULL)\n    {\n        rt_timer_detach(current_thread->thread_timer);\n        rt_free(current_thread->thread_timer);\n    }\n\n    /* close thread stack */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread[%.*s] stack space: %d", "CodeBleu_score": 54.47529573454701}, {"code": "static void _thread_exit(void){\n\tstruct rt_thread *thread;\n\n    thread = rt_thread_self();\n    RT_ASSERT(thread != RT_NULL);\n\n    rt_enter_critical();\n\n    /* detach thread object from thread list */\n    rt_list_remove(&(thread->tlist));\n\n    /* change stat */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* invoke thread cleanup */\n    if (thread->cleanup != RT_NULL) {\n        thread->cleanup(thread);\n    }\n\n    /* detach thread timer */\n    rt_timer_detach(&(thread->thread_timer));\n\n    /* release thread stack */\n    RT_OBJECT_HOOK_CALL(rt_thread_inited, (&(thread->parent)));\n\n    /* insert to defunct thread list */\n    rt_list_insert_after(&(rt_thread_defunct.list), &(thread->tlist));\n\n    /* do scheduler */\n    rt_schedule();\n\n    /* never come here */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 57.73873657549671}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n    rt_base_t critical_level;\n\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread != RT_NULL);\n\n    critical_level = rt_enter_critical();\n\n    /* thread is not waiting, return */\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_exit_critical_safe(critical_level);\n        return;\n    }\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* do scheduler */\n    rt_exit_critical_safe(critical_level);\n    rt_schedule();\n}", "CodeBleu_score": 58.088711708558094}, {"code": "static void _thread_timeout(void *parameter){\n\trt_thread_t thread;\n    rt_ubase_t  level;\n\n    thread = (rt_thread_t)parameter;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n    level = rt_hw_interrupt_disable();\n\n    if (thread->event_info & RT_THREAD_EVENT_EXIT)\n    {\n        /* thread is not suspended, do nothing */\n        rt_hw_interrupt_enable(level);\n        return;\n    }\n\n    /* thread is suspended, set error number and resume it */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* do schedule */\n    rt_hw_interrupt_enable(level);\n    rt_schedule();\n}", "CodeBleu_score": 46.810745682834586}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n    rt_base_t critical_level;\n\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n    critical_level = rt_enter_critical();\n\n    /* thread is not suspended, do nothing */\n    if (!(thread->stat & RT_THREAD_STAT_SUSPEND)) {\n        rt_exit_critical_safe(critical_level);\n        return;\n    }\n\n    /* remove thread on suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* thread stat */\n    thread->stat &= ~RT_THREAD_STAT_SUSPEND;\n    thread->error = -RT_ETIMEOUT;\n\n    /* insert to ready list */\n    rt_schedule_insert_thread(thread);\n\n    rt_exit_critical_safe(critical_level);\n\n    /* do schedule */\n    rt_schedule();\n}", "CodeBleu_score": 57.52573526683946}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_base_t level;\n    rt_object_t object;\n\n    level = rt_hw_interrupt_disable();\n    object = thread->spinlock_nested;\n    if (object != RT_NULL) {\n        rt_mutex_t mutex;\n\n        mutex = (rt_mutex_t)object;\n        rt_mutex_detach(mutex);\n    }\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 14.076165855238742}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tstruct rt_mutex *mutex;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n    mutex = thread->block_list_next;\n    if (mutex != RT_NULL) {\n        /* remove from mutex wait list */\n        rt_list_remove(&thread->tlist);\n        /* clear pending object */\n        thread->block_list_next = RT_NULL;\n        /* set error number */\n        thread->error = -RT_ETIMEOUT;\n    }\n    rt_hw_interrupt_enable(level);\n\n    /* release all mutexes the thread has taken */\n    while (mutex != RT_NULL) {\n        rt_mutex_release(mutex);\n        mutex = thread->block_list_next;\n    }\n}", "CodeBleu_score": 45.66673800572323}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_base_t lock;\n    rt_object_t object;\n\n    /* disable interrupt */\n    lock = rt_spin_lock_irqsave(&thread->spinlock);\n\n    /* remove thread from mutex's list */\n    object = thread->pending_object;\n    if (object != RT_NULL) {\n        /* remove thread from mutex's pending list */\n        rt_list_remove(&thread->tlist);\n\n        /* wake up the next thread */\n        rt_ipc_list_resume_all(&((struct rt_mutex *)object)->parent.suspend_thread);\n\n        /* clear thread pending object */\n        thread->pending_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->hold_mutex_list != RT_NULL) {\n        rt_mutex_release(thread->hold_mutex_list);\n    }\n\n    /* enable interrupt */\n    rt_spin_unlock_irqrestore(&thread->spinlock, lock);\n}", "CodeBleu_score": 45.58139739939416}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_GROWS_UPWARD\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (void *)((char *)thread->stack_addr),\n                                          (void *)_thread_exit);\n#else\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),\n                                          (void *)_thread_exit);\n#endif /* ARCH_CPU_STACK_GROWS_UPWARD */\n\n#ifdef RT_USING_MUTEX\n    rt_list_init(&thread->taken_object_list);\n    thread->pending_object = RT_NULL;\n#endif\n\n#ifdef RT_USING_EVENT\n    thread->event_set = 0;\n    thread->event_info = 0;\n#endif /* RT_USING_EVENT */\n\n    /* error and flags */\n    thread->error = RT_EOK;\n\n    /* lock init */\n#ifdef RT_USING_SMP\n    rt_atomic_store(&thread->cpus_lock_nest, 0);\n#endif\n\n    /* initialize cleanup function and user data */\n    thread->cleanup   = 0;\n    thread->user_data = 0;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  _thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_THREAD_TIMER);\n\n    /* initialize signal */\n#ifdef RT_USING_SIGNALS\n    thread->sig_mask    = 0x00;\n    thread->sig_pending = 0x00;\n\n#ifndef RT_USING_SMP\n    thread->sig_ret     = RT_NULL;\n#endif /* RT_USING_SMP */\n    thread->sig_vectors = RT_NULL;\n    thread->si_list     = RT_NULL;\n#endif /* RT_USING_SIGNALS */\n\n#ifdef RT_USING_SMART\n    thread->tid_ref_count = 0;\n    thread->lwp = RT_NULL;\n    thread->susp_recycler = RT_NULL;\n    thread->robust_list = RT_NULL;\n    rt_list_init(&(thread->sibling));\n\n    /* lwp thread-signal init */\n    rt_memset(&thread->signal.sigset_mask, 0, sizeof(lwp_sigset_t));\n    rt_memset(&thread->signal.sig_queue.sigset_pending, 0, sizeof(lwp_sigset_t));\n    rt_list_init(&thread->signal.sig_queue.siginfo_list);\n\n    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);\n\n    /* initialize user_time and system_time */\n    thread->user_time = 0;\n    thread->system_time = 0;\n#endif\n\n#ifdef RT_USING_CPU_USAGE\n    thread->duration_tick = 0;\n#endif /* RT_USING_CPU_USAGE */\n\n#ifdef RT_USING_PTHREADS\n    thread->pthread_data = RT_NULL;\n#endif /* RT_USING_PTHREADS */\n\n#ifdef RT_USING_MODULE\n    thread->parent.module_id = 0;\n#endif /* RT_USING_MODULE */\n\n    rt_spin_lock_init(&thread->spinlock);\n\n    RT_OBJECT_HOOKLIST_CALL(rt_thread_inited, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.85608241546392}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_GROWS_UPWARD\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (void *)((char *)thread->stack_addr),\n                                          (void *)_thread_exit);\n#else\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),\n                                          (void *)_thread_exit);\n#endif /* ARCH_CPU_STACK_GROWS_UPWARD */\n\n#ifdef RT_USING_MUTEX\n    rt_list_init(&thread->taken_object_list);\n    thread->pending_object = RT_NULL;\n#endif\n\n#ifdef RT_USING_EVENT\n    thread->event_set = 0;\n    thread->event_info = 0;\n#endif /* RT_USING_EVENT */\n\n    /* error and flags */\n    thread->error = RT_EOK;\n\n    /* lock init */\n#ifdef RT_USING_SMP\n    rt_atomic_store(&thread->cpus_lock_nest, 0);\n#endif\n\n    /* initialize cleanup function and user data */\n    thread->cleanup   = 0;\n    thread->user_data = 0;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  _thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_THREAD_TIMER);\n\n    /* initialize signal */\n#ifdef RT_USING_SIGNALS\n    thread->sig_mask    = 0x00;\n    thread->sig_pending = 0x00;\n\n#ifndef RT_USING_SMP\n    thread->sig_ret     = RT_NULL;\n#endif /* RT_USING_SMP */\n    thread->sig_vectors = RT_NULL;\n    thread->si_list     = RT_NULL;\n#endif /* RT_USING_SIGNALS */\n\n#ifdef RT_USING_SMART\n    thread->tid_ref_count = 0;\n    thread->lwp = RT_NULL;\n    thread->susp_recycler = RT_NULL;\n    thread->robust_list = RT_NULL;\n    rt_list_init(&(thread->sibling));\n\n    /* lwp thread-signal init */\n    rt_memset(&thread->signal.sigset_mask, 0, sizeof(lwp_sigset_t));\n    rt_memset(&thread->signal.sig_queue.sigset_pending, 0, sizeof(lwp_sigset_t));\n    rt_list_init(&thread->signal.sig_queue.siginfo_list);\n\n    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);\n\n    /* initialize user_time and system_time */\n    thread->user_time = 0;\n    thread->system_time = 0;\n#endif\n\n#ifdef RT_USING_CPU_USAGE\n    thread->duration_tick = 0;\n#endif /* RT_USING_CPU_USAGE */\n\n#ifdef RT_USING_PTHREADS\n    thread->pthread_data = RT_NULL;\n#endif /* RT_USING_PTHREADS */\n\n#ifdef RT_USING_MODULE\n    thread->parent.module_id = 0;\n#endif /* RT_USING_MODULE */\n\n    rt_spin_lock_init(&thread->spinlock);\n\n    RT_OBJECT_HOOKLIST_CALL(rt_thread_inited, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.85608241546392}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_GROWS_UPWARD\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (void *)((char *)thread->stack_addr),\n                                          (void *)_thread_exit);\n#else\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),\n                                          (void *)_thread_exit);\n#endif /* ARCH_CPU_STACK_GROWS_UPWARD */\n\n#ifdef RT_USING_MUTEX\n    rt_list_init(&thread->taken_object_list);\n    thread->pending_object = RT_NULL;\n#endif\n\n#ifdef RT_USING_EVENT\n    thread->event_set = 0;\n    thread->event_info = 0;\n#endif /* RT_USING_EVENT */\n\n    /* error and flags */\n    thread->error = RT_EOK;\n\n    /* lock init */\n#ifdef RT_USING_SMP\n    rt_atomic_store(&thread->cpus_lock_nest, 0);\n#endif\n\n    /* initialize cleanup function and user data */\n    thread->cleanup   = 0;\n    thread->user_data = 0;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  _thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_THREAD_TIMER);\n\n    /* initialize signal */\n#ifdef RT_USING_SIGNALS\n    thread->sig_mask    = 0x00;\n    thread->sig_pending = 0x00;\n\n#ifndef RT_USING_SMP\n    thread->sig_ret     = RT_NULL;\n#endif /* RT_USING_SMP */\n    thread->sig_vectors = RT_NULL;\n    thread->si_list     = RT_NULL;\n#endif /* RT_USING_SIGNALS */\n\n#ifdef RT_USING_SMART\n    thread->tid_ref_count = 0;\n    thread->lwp = RT_NULL;\n    thread->susp_recycler = RT_NULL;\n    thread->robust_list = RT_NULL;\n    rt_list_init(&(thread->sibling));\n\n    /* lwp thread-signal init */\n    rt_memset(&thread->signal.sigset_mask, 0, sizeof(lwp_sigset_t));\n    rt_memset(&thread->signal.sig_queue.sigset_pending, 0, sizeof(lwp_sigset_t));\n    rt_list_init(&thread->signal.sig_queue.siginfo_list);\n\n    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);\n\n    /* initialize user_time and system_time */\n    thread->user_time = 0;\n    thread->system_time = 0;\n#endif\n\n#ifdef RT_USING_CPU_USAGE\n    thread->duration_tick = 0;\n#endif /* RT_USING_CPU_USAGE */\n\n#ifdef RT_USING_PTHREADS\n    thread->pthread_data = RT_NULL;\n#endif /* RT_USING_PTHREADS */\n\n#ifdef RT_USING_MODULE\n    thread->parent.module_id = 0;\n#endif /* RT_USING_MODULE */\n\n    rt_spin_lock_init(&thread->spinlock);\n\n    RT_OBJECT_HOOKLIST_CALL(rt_thread_inited, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.85608241546392}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tRT-Thread Development Team\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Change Logs:\n * Date           Author       Notes\n * 2006-03-12     Bernard      first version\n * 2006-04-29     Bernard      implement thread timer\n * 2006-06-04     Bernard      implement rt_timer_control\n * 2006-08-10     Bernard      fix the periodic timer bug\n * 2006-09-03     Bernard      implement rt_timer_detach\n * 2009-11-11     LiJin        add soft timer\n * 2010-05-12     Bernard      fix the timer check bug.\n * 2010-11-02     Charlie      re-implement tick overflow issue\n * 2012-12-15     Bernard      fix the next timeout issue in soft timer\n * 2014-07-12     Bernard      does not lock scheduler when invoking soft-timer\n *                             timeout function.\n * 2021-08-15     supperthomas add the comment\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to timer.c\n * 2022-04-19     Stanley      Correct descriptions\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n * 2024-01-25     Shell        add RT_TIMER_FLAG_THREAD_TIMER for timer to sync with sched\n * 2024-05-01     wdfk-prog    The rt_timer_check and _soft_timer_check functions are merged\n */\n", "CodeBleu_score": 34.83336834500206}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tRT-Thread Development Team\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Change Logs:\n * Date           Author       Notes\n * 2006-03-12     Bernard      first version\n * 2006-04-29     Bernard      implement thread timer\n * 2006-06-04     Bernard      implement rt_timer_control\n * 2006-08-10     Bernard      fix the periodic timer bug\n * 2006-09-03     Bernard      implement rt_timer_detach\n * 2009-11-11     LiJin        add soft timer\n * 2010-05-12     Bernard      fix the timer check bug.\n * 2010-11-02     Charlie      re-implement tick overflow issue\n * 2012-12-15     Bernard      fix the next timeout issue in soft timer\n * 2014-07-12     Bernard      does not lock scheduler when invoking soft-timer\n *                             timeout function.\n * 2021-08-15     supperthomas add the comment\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to timer.c\n * 2022-04-19     Stanley      Correct descriptions\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n * 2024-01-25     Shell        add RT_TIMER_FLAG_THREAD_TIMER for timer to sync with sched\n * 2024-05-01     wdfk-prog    The rt_timer_check and _soft_timer_check functions are merged\n */\n", "CodeBleu_score": 34.83336834500206}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tRT-Thread Development Team\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Change Logs:\n * Date           Author       Notes\n * 2006-03-12     Bernard      first version\n * 2006-04-29     Bernard      implement thread timer\n * 2006-06-04     Bernard      implement rt_timer_control\n * 2006-08-10     Bernard      fix the periodic timer bug\n * 2006-09-03     Bernard      implement rt_timer_detach\n * 2009-11-11     LiJin        add soft timer\n * 2010-05-12     Bernard      fix the timer check bug.\n * 2010-11-02     Charlie      re-implement tick overflow issue\n * 2012-12-15     Bernard      fix the next timeout issue in soft timer\n * 2014-07-12     Bernard      does not lock scheduler when invoking soft-timer\n *                             timeout function.\n * 2021-08-15     supperthomas add the comment\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to timer.c\n * 2022-04-19     Stanley      Correct descriptions\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n * 2024-01-25     Shell        add RT_TIMER_FLAG_THREAD_TIMER for timer to sync with sched\n * 2024-05-01     wdfk-prog    The rt_timer_check and _soft_timer_check functions are merged\n */\n", "CodeBleu_score": 34.83336834500206}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t(&(timer->row[i]));\n    }", "CodeBleu_score": 11.502269186205163}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t(&(timer->row[i]));\n    }", "CodeBleu_score": 11.502269186205163}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t(&(timer->row[i]));\n    }", "CodeBleu_score": 11.502269186205163}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar recorder *httptest.ResponseRecorder\n\tfor _, handler := range a.handlers {\n\t\trecorder = httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == 401 {\n\t\t\tres.WriteHeader(401)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 55.4379578796558}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == 401 {\n\t\t\thttp.Error(res, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 74.6296077194149}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 88.17598582375837}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\n\tHost     string\n\tPort     string\n\tCert     string\n\tKey      string\n\thandlers []func(http.ResponseWriter, *http.Request)\n\tstart    func(*API)\n}", "CodeBleu_score": 5.916886751079038}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\n\tHost     string\n\tPort     string\n\tCert     string\n\tKey      string\n\thandlers []func(http.ResponseWriter, *http.Request)\n\tstart    func(*API)\n}", "CodeBleu_score": 5.916886751079038}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\n\tHost     string\n\tPort     string\n\tCert     string\n\tKey      string\n\thandlers []func(http.ResponseWriter, *http.Request)\n\tstart    func(*API)\n}", "CodeBleu_score": 5.916886751079038}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\ta.robeaux)\n}", "CodeBleu_score": 3.629241021632411}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\ta.robeaux)\n}", "CodeBleu_score": 3.629241021632411}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\ta.robeaux)\n}", "CodeBleu_score": 3.629241021632411}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconst basicAuthPrefix string = \"Basic \"\n\n\t\t// Get the Basic Authentication credentials\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif strings.HasPrefix(auth, basicAuthPrefix) {\n\t\t\t// Check credentials\n\t\t\tpayload, err := base64.StdEncoding.DecodeString(auth[len(basicAuthPrefix):])\n\t\t\tif err == nil {\n\t\t\t\tpair := bytes.SplitN(payload, []byte(\":\"), 2)\n\t\t\t\tif len(pair) == 2 && subtle.ConstantTimeCompare(pair[0], []byte(username)) == 1 && subtle.ConstantTimeCompare(pair[1], []byte(password)) == 1 {\n\t\t\t\t\t// Delegate request to the given handle\n\t\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Request Basic Authentication otherwise\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 49.581297998040725}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.296401627569836}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.06634350636688}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 56.46699756191311}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tscale := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - fromMin * scale\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * scale + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.78086973950729}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.05308152440402}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\toptions:", "CodeBleu_score": 2.86251711480364}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\toptions:", "CodeBleu_score": 2.86251711480364}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\toptions:", "CodeBleu_score": 2.86251711480364}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\t\t\td.sensorCfg.readInterval = o\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"'%s' can not be applied on '%s'\\\", opt, d.driverCfg.name))\n\t\t}", "CodeBleu_score": 16.638450365971686}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\t\t\td.sensorCfg.readInterval = o\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"'%s' can not be applied on '%s'\\\", opt, d.driverCfg.name))\n\t\t}", "CodeBleu_score": 16.638450365971686}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\t\t\td.sensorCfg.readInterval = o\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"'%s' can not be applied on '%s'\\\", opt, d.driverCfg.name))\n\t\t}", "CodeBleu_score": 16.638450365971686}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\td.AddEventHandler(Vibration, func(data interface{}) {\n\t\tval := data.(int)\n\t\tif val > 1000 {\n\t\t\td.Publish(Vibration, true)\n\t\t} else {\n\t\t\td.Publish(Vibration, false)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 71.8517732306772}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\tif err := d.AddEventHandler(Vibration, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 76.0327486277421}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\td.AddEventHandler(Vibration, func(data interface{}) {\n\t\tval := d.Read()\n\t\tif val > 1000 {\n\t\t\td.Publish(Vibration, true)\n\t\t} else {\n\t\t\td.Publish(Vibration, false)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 71.03217777701138}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t= 58.27\n\tB1   = 61.74\n\tC2   = 65.41\n\tDb2  = 69.30\n\tD2   = 73.42\n\tEb2  = 77.78\n\tE2   = 82.41\n\tF2   = 87.31\n\tGb2  = 92.50\n\tG2   = 98.00\n\tAb2  = 103.83\n\tA2   = 110.00\n\tBb2  = 116.54\n\tB2   = 123.47\n\tC3   = 130.81\n\tDb3  = 138.59\n\tD3   = 146.83\n\tEb3  = 155.56\n\tE3   = 164.81\n\tF3   = 174.61\n\tGb3  = 185.00\n\tG3   = 196.00\n\tAb3  = 207.65\n\tA3   = 220.00\n\tBb3  = 233.08\n\tB3   = 246.94\n\tC4   = 261.63\n\tDb4  = 277.18\n\tD4   = 293.66\n\tEb4  = 311.13\n\tE4   = 329.63\n\tF4   = 349.23\n\tGb4  = 369.99\n\tG4   = 392.00\n\tAb4  = 415.30\n\tA4   = 440.00\n\tBb4  = 466.16\n\tB4   = 493.88\n\tC5   = 523.25\n\tDb5  = 554.37\n\tD5   = 587.33\n\tEb5  = 622.25\n\tE5   = 659.25\n\tF5   = 698.46\n\tGb5  = 739.99\n\tG5   = 783.99\n\tAb5  = 830.61\n\tA5   = 880.00\n\tBb5  = 932.33\n\tB5   = 987.77\n\tC6   = 1046.50\n\tDb6  = 1108.73\n\tD6   = 1174.66\n\tEb6  = 1244.51\n\tE6   = 1318.51\n\tF6   = 1396.91\n\tGb6  = 1479.98\n\tG6   = 1567.98\n\tAb6  = 1661.22\n\tA6   = 1760.00\n\tBb6  = 1864.66\n\tB6   = 1975.53\n\tC7   = 2093.00\n\tDb7  = 2217.46\n\tD7   = 2349.32\n\tEb7  = 2489.02\n\tE7   = 2637.02\n\tF7   = 2793.83\n\tGb7  = 2959.96\n\tG7   = 3135.96\n\tAb7  = 3322.44\n\tA7   = 3520.00\n\tBb7  = 3729.31\n\tB7   = 3951.07\n\tC8   = 4186.01\n\tDb8  = 4434.92\n\tD8   = 4698.63\n\tEb8  = 4978.03\n\tE8   = 5274.04\n\tF8   = 5587.65\n\tGb8  = 5919.91\n\tG8   = 6271.93\n\tAb8  = 6644.88\n\tA8   = 7040.00\n\tBb8  = 7458.62\n\tB8   = 7902.13", "CodeBleu_score": 6.6115582048283645}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t= 58.27\n\tB1   = 61.74\n\tC2   = 65.41\n\tDb2  = 69.30\n\tD2   = 73.42\n\tEb2  = 77.78\n\tE2   = 82.41\n\tF2   = 87.31\n\tGb2  = 92.50\n\tG2   = 98.00\n\tAb2  = 103.83\n\tA2   = 110.00\n\tBb2  = 116.54\n\tB2   = 123.47\n\tC3   = 130.81\n\tDb3  = 138.59\n\tD3   = 146.83\n\tEb3  = 155.56\n\tE3   = 164.81\n\tF3   = 174.61\n\tGb3  = 185.00\n\tG3   = 196.00\n\tAb3  = 207.65\n\tA3   = 220.00\n\tBb3  = 233.08\n\tB3   = 246.94\n\tC4   = 261.63\n\tDb4  = 277.18\n\tD4   = 293.66\n\tEb4  = 311.13\n\tE4   = 329.63\n\tF4   = 349.23\n\tGb4  = 369.99\n\tG4   = 392.00\n\tAb4  = 415.30\n\tA4   = 440.00\n\tBb4  = 466.16\n\tB4   = 493.88\n\tC5   = 523.25\n\tDb5  = 554.37\n\tD5   = 587.33\n\tEb5  = 622.25\n\tE5   = 659.25\n\tF5   = 698.46\n\tGb5  = 739.99\n\tG5   = 783.99\n\tAb5  = 830.61\n\tA5   = 880.00\n\tBb5  = 932.33\n\tB5   = 987.77\n\tC6   = 1046.50\n\tDb6  = 1108.73\n\tD6   = 1174.66\n\tEb6  = 1244.51\n\tE6   = 1318.51\n\tF6   = 1396.91\n\tGb6  = 1479.98\n\tG6   = 1567.98\n\tAb6  = 1661.22\n\tA6   = 1760.00\n\tBb6  = 1864.66\n\tB6   = 1975.53\n\tC7   = 2093.00\n\tDb7  = 2217.46\n\tD7   = 2349.32\n\tEb7  = 2489.02\n\tE7   = 2637.02\n\tF7   = 2793.83\n\tGb7  = 2959.96\n\tG7   = 3135.96\n\tAb7  = 3322.44\n\tA7   = 3520.00\n\tBb7  = 3729.31\n\tB7   = 3951.07\n\tC8   = 4186.01\n\tDb8  = 4434.92\n\tD8   = 4698.63\n\tEb8  = 4978.03\n\tE8   = 5274.04\n\tF8   = 5587.65\n\tGb8  = 5919.91\n\tG8   = 6271.93\n\tAb8  = 6644.88\n\tA8   = 7040.00\n\tBb8  = 7458.62\n\tB8   = 7902.13", "CodeBleu_score": 6.6115582048283645}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t= 58.27\n\tB1   = 61.74\n\tC2   = 65.41\n\tDb2  = 69.30\n\tD2   = 73.42\n\tEb2  = 77.78\n\tE2   = 82.41\n\tF2   = 87.31\n\tGb2  = 92.50\n\tG2   = 98.00\n\tAb2  = 103.83\n\tA2   = 110.00\n\tBb2  = 116.54\n\tB2   = 123.47\n\tC3   = 130.81\n\tDb3  = 138.59\n\tD3   = 146.83\n\tEb3  = 155.56\n\tE3   = 164.81\n\tF3   = 174.61\n\tGb3  = 185.00\n\tG3   = 196.00\n\tAb3  = 207.65\n\tA3   = 220.00\n\tBb3  = 233.08\n\tB3   = 246.94\n\tC4   = 261.63\n\tDb4  = 277.18\n\tD4   = 293.66\n\tEb4  = 311.13\n\tE4   = 329.63\n\tF4   = 349.23\n\tGb4  = 369.99\n\tG4   = 392.00\n\tAb4  = 415.30\n\tA4   = 440.00\n\tBb4  = 466.16\n\tB4   = 493.88\n\tC5   = 523.25\n\tDb5  = 554.37\n\tD5   = 587.33\n\tEb5  = 622.25\n\tE5   = 659.25\n\tF5   = 698.46\n\tGb5  = 739.99\n\tG5   = 783.99\n\tAb5  = 830.61\n\tA5   = 880.00\n\tBb5  = 932.33\n\tB5   = 987.77\n\tC6   = 1046.50\n\tDb6  = 1108.73\n\tD6   = 1174.66\n\tEb6  = 1244.51\n\tE6   = 1318.51\n\tF6   = 1396.91\n\tGb6  = 1479.98\n\tG6   = 1567.98\n\tAb6  = 1661.22\n\tA6   = 1760.00\n\tBb6  = 1864.66\n\tB6   = 1975.53\n\tC7   = 2093.00\n\tDb7  = 2217.46\n\tD7   = 2349.32\n\tEb7  = 2489.02\n\tE7   = 2637.02\n\tF7   = 2793.83\n\tGb7  = 2959.96\n\tG7   = 3135.96\n\tAb7  = 3322.44\n\tA7   = 3520.00\n\tBb7  = 3729.31\n\tB7   = 3951.07\n\tC8   = 4186.01\n\tDb8  = 4434.92\n\tD8   = 4698.63\n\tEb8  = 4978.03\n\tE8   = 5274.04\n\tF8   = 5587.65\n\tGb8  = 5919.91\n\tG8   = 6271.93\n\tAb8  = 6644.88\n\tA8   = 7040.00\n\tBb8  = 7458.62\n\tB8   = 7902.13", "CodeBleu_score": 6.6115582048283645}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tTODO: Support selecting phase input instead of hard-wiring MS1 and MS2 to board truth table", "CodeBleu_score": 2.929630610059118}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tTODO: Support selecting phase input instead of hard-wiring MS1 and MS2 to board truth table", "CodeBleu_score": 2.929630610059118}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tTODO: Support selecting phase input instead of hard-wiring MS1 and MS2 to board truth table", "CodeBleu_score": 2.929630610059118}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := sysfs.NewAnalogPin(path)\n\tpin.SetReadBufferLen(bufLen)\n\tpin.SetReadable(r)\n\tpin.SetWritable(w)\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 56.04633861026605}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor is not yet initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := sysfs.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 61.177638101863494}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Analog pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := sysfs.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 62.36610886944389}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\todAccess can be used to change the default sysfs implementation to the character device Kernel ABI.", "CodeBleu_score": 17.024231217232394}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\todAccess can be used to change the default sysfs implementation to the character device Kernel ABI.", "CodeBleu_score": 17.024231217232394}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\todAccess can be used to change the default sysfs implementation to the character device Kernel ABI.", "CodeBleu_score": 17.024231217232394}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tmisoPin)\n\t}", "CodeBleu_score": 3.8226443298989103}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tmisoPin)\n\t}", "CodeBleu_score": 3.8226443298989103}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tmisoPin)\n\t}", "CodeBleu_score": 3.8226443298989103}]}
