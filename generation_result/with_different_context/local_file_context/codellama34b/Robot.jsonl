{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.lock();\n  if (navigation == nullptr) {\n    auto new_navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n    if (_walker_navigation.compare_exchange_strong(navigation, new_navigation)) {\n      navigation = new_navigation;\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 57.07650933621885}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> nav = _walker_navigation.lock();\n  if (nav == nullptr) {\n    nav = std::make_shared<WalkerNavigation>(shared_from_this());\n    _walker_navigation = nav;\n  }\n  return nav;\n}", "CodeBleu_score": 52.04527028037364}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.lock();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n    _walker_navigation = navigation;\n  }\n  return navigation;\n}", "CodeBleu_score": 48.06010516749406}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst auto end = steady_clock::now() + timeout;\n  while (steady_clock::now() < end) {\n    std::this_thread::yield();\n    if (episode.GetState()->GetTimestamp().frame >= frame) {\n      episode.Lock()->GetCurrentTickIndex();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.28242337055725}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst auto end = steady_clock::now() + timeout;\n  while (steady_clock::now() < end) {\n    if (episode.GetState()->GetTimestamp().frame < frame) {\n      std::this_thread::yield();\n    } else {\n      episode.Lock()->GetTm().Get()->Tick();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.99830531746817}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst time_point start = steady_clock::now();\n  while (episode.GetState()->GetTimestamp().frame < frame) {\n    if ((steady_clock::now() - start) > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTm().Get()->Tick();\n  return true;\n}", "CodeBleu_score": 34.517145237949215}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tconst auto id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  const auto start = std::chrono::system_clock::now();\n  for (size_t i = 0u; i < 60u; ++i) {\n    const auto episode = _client.GetCurrentEpisode();\n    if (episode != nullptr && episode->GetId() == id) {\n      return EpisodeProxy{shared_from_this(), episode};\n    }\n    std::this_thread::sleep_for(100ms);\n  }\n  throw_exception(std::runtime_error(\"failed to connect to newly created episode\"));\n}", "CodeBleu_score": 54.816064256248055}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// The client sends a request to load the episode to the server.\n  _client.LoadEpisode(map_name, reset_settings, map_layers);\n  // The client attempts to connect to the new episode.\n  const auto start_time = std::chrono::system_clock::now();\n  const auto timeout = 10s;\n  size_t attempts = 0u;\n  while (true) {\n    auto episode = _client.GetCurrentEpisode();\n    if (episode.GetId() != 0u) {\n      return EpisodeProxy{shared_from_this(), std::move(episode)};\n    }\n    ++attempts;\n    log_debug(\"failed to connect to new episode (attempt \" + std::to_string(attempts) + \")\");\n    std::this_thread::sleep_for(100ms);\n    auto now = std::chrono::system_clock::now();\n    if ((now - start_time) > timeout) {\n      throw_exception(std::runtime_error(\"failed to connect to new episode after \" + std::to_string(attempts) + \" attempts\"));\n    }\n  }\n}", "CodeBleu_score": 55.91892750748833}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tconst auto id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    const time_duration timeout = 10s;\n    auto start = std::chrono::system_clock::now();\n    auto end = std::chrono::system_clock::now();\n    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n    size_t attempts = 0u;\n    while (diff < timeout.to_chrono()) {\n        if (_client.GetCurrentEpisodeId() == id) {\n            return EpisodeProxy{shared_from_this(), id};\n        }\n        ++attempts;\n        std::this_thread::sleep_for(100ms);\n        end = std::chrono::system_clock::now();\n        diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n    }\n    log_error(\"failed to connect to newly created episode (id =\", id, \") after\", attempts, \"attempts\");\n    throw_exception(std::runtime_error(\"failed to connect to newly created episode\"));\n}", "CodeBleu_score": 55.01716293634469}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }\nEpisodeProxy Simulator::GetCurrentEpisode() {\n    GetReadyCurrentEpisode();\n    return EpisodeProxy{shared_from_this()};\n  }\n\n  bool Simulator::ShouldUpdateMap(rpc::MapInfo& map_info) {\n    if (!_cached_map) {\n      return true;\n    }\n    if (map_info.name != _cached_map->GetName() ||\n        _open_drive_file.size() != _cached_map->GetOpenDrive().size()) {\n      return true;\n    }\n    return false;\n  }\n\n  SharedPtr<Map> Simulator::GetCurrentMap() {\n    DEBUG_ASSERT(_episode != nullptr);\n    if (!_cached_map || _episode->HasMapChangedSinceLastCall()) {\n      rpc::MapInfo map_info = _client.GetMapInfo();\n      std::string map_name;\n      std::string map_base_path;\n      bool fill_base_string = false;\n      for (int i = map_info.name.size() - 1; i >= 0; --i) {\n        if (fill_base_string == false && map_info.name[i] != '/') {\n          map_name += map_info.name[i];\n        } else {\n          map_base_path += map_info.name[i];\n          fill_base_string = true;\n        }\n      }\n      std::reverse(map_name.begin(), map_name.end());\n      std::reverse(map_base_path.begin(), map_base_path.end());\n      std::string XODRFolder = map_base_path + \\\"/OpenDrive/\\\" + map_name + \\\".xodr\\\";\n      if (FileTransfer::FileExists(XODRFolder) == false) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }\n\n    return _cached_map;\n  }\n\n  // ===========================================================================\n  // -- Required files ---------------------------------------------------------\n  // ===========================================================================\n\n\n    bool Simulator::SetFilesBaseFolder(const std::string &path) {\n      return _client.SetFilesBaseFolder(path);\n    }\n\n    std::vector<std::string> Simulator::GetRequiredFiles(const std::string &folder, const bool download) const {\n      return _client.GetRequiredFiles(folder, download);\n    }\n\n    void Simulator::RequestFile(const std::string &name) const {\n      _client.RequestFile(name);\n    }\n\n    std::vector<uint8_t> Simulator::GetCacheFile(const std::string &name, const bool request_otherwise) const {\n      return _client.GetCacheFile(name, request_otherwise);\n    }\n\n  // ===========================================================================\n  // -- Tick -------------------------------------------------------------------\n  // ===========================================================================\n\n  WorldSnapshot Simulator::WaitForTick(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    auto result = _episode->WaitForState(timeout);\n    if (!result.has_value()) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return *result;\n  }\n\n  uint64_t Simulator::Tick(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n\n\n\n/*\n * This function, Simulator::RegisterAIController, registers an AI controller with a walker in the simulation.\nIt retrieves the walker associated with the controller and throws an exception if the walker is not found.\nIt asserts that the episode is not null, creates navigation if it is missing, and registers the walker with the controller's ID.\n */\nvoid Simulator::RegisterAIController(const WalkerAIController &controller) {\n  DEBUG_ASSERT(_episode != nullptr);\n  auto walker = _episode->GetActor(controller.GetParent());\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"unable to find walker for controller\"));\n  }\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterWalker(*walker, controller.GetId());\n}\n\n/*\n * This function, Simulator::UnregisterAIController, unregisters an AI controller with a walker in the simulation.\nIt retrieves the walker associated with the controller and throws an exception if the walker is not found.\nIt asserts that the episode is not null and unregisters the walker with the controller's ID.\n */\nvoid Simulator::UnregisterAIController(const WalkerAIController &controller) {\n  DEBUG_ASSERT(_episode != nullptr);\n  auto walker = _episode->GetActor(controller.GetParent());\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"unable to find walker for controller\"));\n  }\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->UnregisterWalker(*walker, controller.GetId());\n}\n\n// =============================================================================\n// -- Undef helper macros ------------------------------------------------------\n// =============================================================================\n\n#undef DEBUG_ASSERT\n#undef DEBUG_ONLY\n#undef RELEASE_ONLY\n#undef RELEASE_ASSERT\n\n}", "CodeBleu_score": 50.74543259776886}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n\n/*\n * This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.\nIt first ensures that the episode is valid, then subscribes to the sensor's data stream using the client's SubscribeToStream method.\nThe callback is set to deserialize the incoming data, associate it with the current episode, and then invoke the provided callback with the sensor data.\n */\nvoid Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto stream = sensor.GetStream();\n    auto callback_id = _client.SubscribeToStream(\n        stream,\n        [this, sensor, callback](auto buffer) {\n          auto data = sensor::Deserializer::Deserialize(\n              buffer,\n              sensor.GetActorDescription().GetSensorDescription(sensor.GetId()));\n          data->SetEpisode(*_episode);\n          callback(std::move(data));\n        });\n    _sensor_to_callback[sensor.GetId()] = callback_id;\n  }\n\n/*\n * This function, Simulator::UnSubscribeFromSensor, unsubscribes from a sensor's data stream.\nIt first ensures that the episode is valid, then unsubscribes from the sensor's data stream using the client's UnSubscribeFromStream method.\n */\nvoid Simulator::UnSubscribeFromSensor(const Sensor &sensor) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto it = _sensor_to_callback.find(sensor.GetId());\n    if (it != _sensor_to_callback.end()) {\n      _client.UnSubscribeFromStream(it->second);\n      _sensor_to_callback.erase(it);\n    }\n  }\n\n// =============================================================================\n// -- Undef helper macros ------------------------------------------------------\n// =============================================================================\n\n#undef DEBUG_ASSERT\n#undef DEBUG_ASSERT_WITH_THROW\n\n}", "CodeBleu_score": 49.84274301915909}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tauto walkers = episode->GetAllActors(true);\n  if (walkers.empty()) {\n    return;\n  }\n  auto episode_state = episode->GetState();\n  for (auto &&walker : _walkers) {\n    auto it = std::find_if(\n        walkers.begin(),\n        walkers.end(),\n        [walker](auto &&other) {\n          return walker.first == other.GetId();\n        });\n    if (it == walkers.end()) {\n      _walkers.erase(walker.first);\n    }\n  }\n  _nav.UpdateCrowd(episode_state, walkers);\n  for (auto &&walker : _walkers) {\n    auto it = std::find_if(\n        walkers.begin(),\n        walkers.end(),\n        [walker](auto &&other) {\n          return walker.first == other.GetId();\n        });\n    if (it == walkers.end()) {\n      continue;\n    }\n    auto transform = it->GetTransform();\n    auto speed = it->GetVelocity();\n    _nav.UpdateWalker(walker.first, transform, speed);\n  }\n  for (auto &&walker : _walkers) {\n    auto it = std::find_if(\n        walkers.begin(),\n        walkers.end(),\n        [walker](auto &&other) {\n          return walker.first == other.GetId();\n        });\n    if (it == walkers.end()) {\n      continue;\n    }\n    if (it->IsDead()) {\n      _nav.RemoveWalker(walker.first);\n      _walkers.erase(walker.first);\n    }\n  }\n}", "CodeBleu_score": 44.31194271889607}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tconst auto walkers = episode->GetAllWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->GetState();\n  auto remove_walkers = [&](auto &&walker) {\n    return walkers.find(walker) == walkers.end();\n  };\n  _nav.RemoveWalkers(remove_walkers);\n\n  _nav.Update(state);\n\n  const auto &crowd = _nav.GetCrowd();\n  crowd.ForEachMember([&](const auto &member) {\n    const auto &transform = member.GetTransform();\n    const auto &velocity = member.GetVelocity();\n    episode->Lock()->ApplyControlToWalker(member.GetActorId(), rpc::WalkerControl{transform, velocity});\n  });\n\n  const auto &debug_shapes = _nav.GetDebugShapes();\n  for (const auto &shape : debug_shapes) {\n    episode->Lock()->DrawDebugShape(shape);\n  }\n\n  // Check if any walker has been killed.\n  auto check_walker_killed = [&](auto &&walker) {\n    const auto &state = walker->GetActorInfo()->state;\n    if (state == ActorState::Dead) {\n      episode->Lock()->DestroyWalker(walker->GetId());\n      _nav.RemoveWalker(walker->GetId());\n      return true;\n    }\n    return false;\n  };\n  walkers.erase(std::remove_if(walkers.begin(), walkers.end(), check_walker_killed), walkers.end());\n}", "CodeBleu_score": 43.24700077651074}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// Get the current list of walkers.\n    auto walkers = episode->GetActors(\n        [](auto &&walker) { return walker->IsWalker(); });\n    if (walkers.empty()) {\n        return;\n    }\n    // Get the current state of the episode.\n    auto state = episode->Lock()->GetState();\n    // Remove any walkers that no longer exist.\n    _crowd.Remove(\n        [&walkers](auto &&id) { return walkers.find(id) == walkers.end(); });\n    // Update the vehicles in the crowd and the crowd itself.\n    _nav.Update(\n        [&walkers](auto &&id) { return walkers[id]->GetVehicleControl(); },\n        [&walkers](auto &&id) { return walkers[id]->GetTransform(); },\n        [&walkers](auto &&id) { return walkers[id]->GetVelocity(); },\n        [&walkers](auto &&id) { return walkers[id]->GetBoundingBox(); },\n        [&walkers](auto &&id) { return walkers[id]->GetWalkerControl(); },\n        [&walkers](auto &&id) { return walkers[id]->GetWalkerState(); },\n        state.GetTimeStamp().frame);\n    // Apply the walker states in a batch to the simulator.\n    episode->Lock()->ApplyBatch(\n        [&](auto &&batch) {\n            for (auto &&walker : walkers) {\n                walker->GetWalkerControl().ApplyControl(batch);\n            }\n        },\n        [&](auto &&batch) {\n            for (auto &&walker : walkers) {\n                walker->GetWalkerState().ApplyState(batch);\n            }\n        });\n    // Check if any walker has been killed.\n    for (auto &&walker : walkers) {\n        if (walker->IsDead()) {\n            _crowd.Remove(walker->GetId());\n            walker->Destroy();\n        }\n    }\n}", "CodeBleu_score": 38.41963110846397}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description(_uid, _id);\n  description.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.emplace_back(attribute.second.GetId(), attribute.second.GetValue());\n  }\n  return description;\n}", "CodeBleu_score": 59.3716139692384}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description(_uid, _id);\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.attributes.push_back(attribute.second.GetValue());\n  }\n  return description;\n}", "CodeBleu_score": 63.21315438065221}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.reserve(_attributes.size());\n  for (auto &&attribute : _attributes) {\n    description.emplace_back(attribute.second.GetValue());\n  }\n  return description;\n}", "CodeBleu_score": 76.28530293489568}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n    for (auto &pair : _blueprints) {\n      const auto &attributes = pair.second.GetAttributes();\n      auto it = attributes.find(name);\n      if (it != attributes.end()) {\n        if (it->second.has_value) {\n          if (it->second.value == value) {\n            result.emplace(pair);\n          }\n        }\n        else {\n          if (std::find(it->second.recommended_values.begin(), it->second.recommended_values.end(), value) != it->second.recommended_values.end()) {\n            result.emplace(pair);\n          }\n        }\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 59.88153426680649}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.MatchAttribute(name, value)) {\n        result.emplace(pair);\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 32.69952273688036}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.MatchAttribute(name, value)) {\n        result.emplace(pair);\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 32.69952273688036}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Check if the file exists or not\n  struct stat buffer;\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Create the directories if they don't exist\n  std::string dir = fullpath;\n  size_t pos = dir.find_last_of('/');\n  dir = dir.substr(0, pos);\n  if (!boost::filesystem::exists(dir)) {\n    boost::filesystem::create_directories(dir);\n  }\n\n  // Write the file\n  std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n  if (file.is_open()) {\n    file.write((char*)content.data(), content.size());\n    file.close();\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 58.91342200080095}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Check that the path ends in a slash, add it otherwise\n  if (path[path.size() - 1] != '/' && path[path.size() - 1] != '\\\\') {\n    path += \"/\";\n  }\n\n  // Check if the file exists or not\n  struct stat buffer;\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  if (stat(fullpath.c_str(), &buffer) == 0) {\n    return false;\n  }\n\n  // Open the file\n  std::ofstream file;\n  file.open(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // Write the content\n  file.write((char*)content.data(), content.size());\n\n  // Close the file\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 50.11395387826904}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Construct the full file path using a base folder and version information\n    std::string fullpath = _filesBaseFolder;\n    fullpath += \"/\";\n    fullpath += ::carla::version();\n    fullpath += \"/\";\n    fullpath += path;\n\n    // Validate the file path\n    if (path.empty() || path.find(\"../\") != std::string::npos) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\n    // If the file is successfully opened, write the content and close the file\n    if (file.is_open()) {\n        file.write(reinterpret_cast<char*>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n\n    // If the file cannot be opened, return false\n    return false;\n}", "CodeBleu_score": 55.01112928796725}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tstd::array<geom::Location, 4u> corners;\n\n  const geom::Location location = _parent_bounding_box.location + transform.location;\n  const geom::Vector3D extents = _parent_bounding_box.extent * transform.GetScale();\n  const float yaw = transform.rotation.yaw;\n\n  corners[0u] = Rotate(yaw, location + geom::Location(extents.x, extents.y, 0.0f));\n  corners[1u] = Rotate(yaw, location + geom::Location(-extents.x, extents.y, 0.0f));\n  corners[2u] = Rotate(yaw, location + geom::Location(-extents.x, -extents.y, 0.0f));\n  corners[3u] = Rotate(yaw, location + geom::Location(extents.x, -extents.y, 0.0f));\n\n  return std::make_shared<const Bounds>(Bounds{frame, corners});\n}", "CodeBleu_score": 48.94522551709911}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = _parent_bounding_box.location + transform.location;\n  const auto extents = _parent_bounding_box.extent;\n  const auto yaw = transform.rotation.yaw;\n  const auto &corners = std::array<geom::Location, 4u>{\n      Rotate(yaw, location + geom::Location{-extents.x, -extents.y}),\n      Rotate(yaw, location + geom::Location{-extents.x,  extents.y}),\n      Rotate(yaw, location + geom::Location{ extents.x,  extents.y}),\n      Rotate(yaw, location + geom::Location{ extents.x, -extents.y})};\n\n  return std::make_shared<const Bounds>(Bounds{frame, corners});\n}", "CodeBleu_score": 55.14954805329224}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = _parent_bounding_box.location + transform.location;\n    std::array<geom::Location, 4u> corners;\n    for (auto i = 0u; i < 4u; ++i) {\n      const auto corner = Rotate(transform.rotation.yaw, _parent_bounding_box.extent.corners[i]);\n      corners[i] = location + corner;\n    }\n    return std::make_shared<const Bounds>(Bounds{frame, corners});\n  }", "CodeBleu_score": 41.469856190403476}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"attempting to send message to sensor with ID \", GetDisplayId(), \" but this sensor is not a v2x_custom sensor\");\n        return;\n    }\n    GetEpisode().Lock()->SendSensorMessage(*this, message);\n}", "CodeBleu_score": 67.54774445196773}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"sensor ID is not sensor.other.v2x_custom: \", GetDisplayId());\n        return;\n    }\n    GetEpisode().Lock()->SendV2XMessage(GetId(), message);\n}", "CodeBleu_score": 66.1544832237684}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n  if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"attempting to send message to sensor with ID \", GetDisplayId(), \" but it is not a v2x_custom sensor\");\n    return;\n  }\n  GetEpisode().Lock()->SendV2XMessage(GetContext(), message);\n}", "CodeBleu_score": 65.48387067349657}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    if (!_is_autopilot_enabled) {\n      _is_autopilot_enabled = true;\n      _tm_port = tm_port;\n      _episode.Lock()->RegisterVehicle(*this, _tm_port);\n    }\n  } else {\n    if (_is_autopilot_enabled) {\n      _is_autopilot_enabled = false;\n      _episode.Lock()->UnregisterVehicle(*this);\n    }\n  }\n}", "CodeBleu_score": 40.76180081514262}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tGetEpisode().Lock()->SetVehicleLightState(GetId(), enabled);\n  if (enabled) {\n    if (!_is_tm_registered) {\n      _is_tm_registered = true;\n      TM::RegisterVehicle(*this, tm_port);\n    }\n  } else {\n    if (_is_tm_registered) {\n      _is_tm_registered = false;\n      TM::UnregisterVehicle(*this);\n    }\n  }\n}", "CodeBleu_score": 41.98308572077748}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    _episode.Lock()->RegisterVehicle(*this, tm_port);\n  } else {\n    _episode.Lock()->UnregisterVehicle(*this);\n  }\n}", "CodeBleu_score": 46.43648923191614}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t_walker = GetParent();\n  _navigation = GetEpisode().GetNavigation();\n  _navigation->RegisterWalker(_walker, _walker->GetLocation());\n  _walker->SetSimulatePhysics(false);\n  _walker->SetEnableGravity(false);\n}", "CodeBleu_score": 31.226009890850992}, {"code": "void WalkerAIController::Start(){\n\t_walker = GetParent();\n  _navigation = GetEpisode().GetNavigation();\n  _navigation->RegisterWalker(_walker->GetId(), _walker->GetLocation());\n  _walker->SetSimulatePhysics(false);\n  _walker->SetEnableGravity(false);\n}", "CodeBleu_score": 32.942522618339765}, {"code": "void WalkerAIController::Start(){\n\t_walker = GetParent();\n  _navigation = _episode.Lock()->GetNavigation();\n  _navigation->AddWalker(_walker->GetLocation());\n  _walker->SetSimulatePhysics(false);\n  _walker->SetCollisionEnabled(false);\n}", "CodeBleu_score": 28.02744082061132}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav != nullptr) {\n        auto walker = GetParent();\n        if (walker != nullptr) {\n            if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n                log_warning(\"NAV: Failed to set walker max speed\");\n            }\n        } else {\n            log_warning(\"NAV: Failed to set walker max speed (parent does not exist)\");\n        }\n    }\n}", "CodeBleu_score": 91.6249923993385}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set request to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \"(parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 82.08999417555408}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set request to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \"(parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 82.08999417555408}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }", "CodeBleu_score": 98.6771013387521}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }", "CodeBleu_score": 98.6771013387521}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }", "CodeBleu_score": 98.6771013387521}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tauto &episode = _episode.Lock();\n  const auto &old_settings = episode->GetEpisodeSettings();\n  if (settings.fixed_delta_seconds != old_settings.fixed_delta_seconds) {\n    _delta_seconds_checker.Reset(settings.fixed_delta_seconds);\n  }\n  const auto &result = episode->ApplyEpisodeSettings(settings);\n  _delta_seconds_checker.SetVerificationLength(result.ticks_per_second);\n  return result.frame;\n}", "CodeBleu_score": 24.668928440519966}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tif (timeout == time_duration::max()) {\n    timeout = _episode.Lock()->GetNetworkingTimeout();\n  }\n  uint64_t id = _episode.Lock()->SetEpisodeSettings(settings);\n  if (settings.fixed_delta_seconds > 0.0) {\n    const auto seconds_per_tick = _episode.Lock()->GetSecondsPerTick();\n    const auto drift_threshold = 0.01;\n    const auto drift = std::abs(seconds_per_tick - settings.fixed_delta_seconds);\n    if (drift > drift_threshold) {\n      log_warning(\n          \"unable to set a fixed delta seconds of\",\n          settings.fixed_delta_seconds,\n          \"s, actual value set is\",\n          seconds_per_tick,\n          \"(drift of\",\n          drift * 100.0,\n          \"percent)\");\n    }\n  }\n  return id;\n}", "CodeBleu_score": 42.62636874155509}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tif (settings.synchronous_mode) {\n    _episode.Lock()->SetTickTimeout(timeout);\n  }\n  if (settings.fixed_delta_seconds > 0.0) {\n    double seconds = settings.fixed_delta_seconds;\n    auto max_error = 0.01 * seconds;\n    auto min_ticks = 5u;\n    auto ticks = 0u;\n    auto error = 100.0 * max_error;\n    while (error > max_error && ticks < min_ticks) {\n      auto start = game_clock::now();\n      _episode.Lock()->Tick(seconds);\n      auto end = game_clock::now();\n      auto diff = end - start;\n      error = 100.0 * (diff.count() * _episode.Lock()->GetSecondsPerTick() - seconds) / seconds;\n      ++ticks;\n    }\n    if (error > max_error) {\n      log_warning(\n          \"failed to set fixed delta seconds (\",\n          seconds,\n          \") after \",\n          ticks,\n          \" ticks: average error \",\n          error,\n          \"%\");\n    }\n  }\n  return _episode.Lock()->ApplyEpisodeSettings(settings);\n}", "CodeBleu_score": 48.54621138007349}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tconst Vector2D &p,\n    const Vector2D &v,\n    const Vector2D &w) {\n  const float l2 = (v - w).SquaredLength();\n  if (l2 == 0.0f) {\n    return std::make_pair(0.0f, (p - v).Length());\n  }\n  const float t = std::max(0.0f, std::min(1.0f, Dot(p - v, w - v) / l2));\n  const Vector2D projection = v + t * (w - v);\n  return std::make_pair((projection - p).Length(), (projection - v).Length());\n}\n", "CodeBleu_score": 59.826462364830924}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tconst Vector2D segment_vector = segment_end - segment_start;\n  const float segment_length_squared = segment_vector.SquaredLength();\n  const float segment_length = std::sqrt(segment_length_squared);\n\n  if (segment_length_squared < std::numeric_limits<float>::epsilon()) {\n    return std::make_pair(0.0f, (point - segment_start).Length());\n  }\n\n  const float projection_factor = (point - segment_start).Dot(segment_vector) / segment_length_squared;\n  const float projection_factor_clamped = std::max(0.0f, std::min(1.0f, projection_factor));\n  const Vector2D projection = segment_start + projection_factor_clamped * segment_vector;\n  return std::make_pair(projection_factor_clamped * segment_length, (point - projection).Length());\n}", "CodeBleu_score": 38.400924591537574}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tconst Vector2D p = point - segment.a;\n  const Vector2D v = segment.b - segment.a;\n  const float c = Dot(p, v);\n  if (c <= 0.0f) {\n    return std::make_pair(0.0f, p.Length());\n  }\n  const float d = Dot(v, v);\n  if (c >= d) {\n    return std::make_pair(1.0f, (point - segment.b).Length());\n  }\n  return std::make_pair(c / d, p.Length() - (c / d) * v.Length());\n}", "CodeBleu_score": 43.35936214546673}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum() + 2;\n    AddVertices(vertices);\n    bool index_clockwise = true;\n    while (i < GetVerticesNum()) {\n      index_clockwise = !index_clockwise;\n      if (index_clockwise) {\n        AddIndex(i + 1);\n        AddIndex(i);\n        AddIndex(i - 1);\n      } else {\n        AddIndex(i - 1);\n        AddIndex(i);\n        AddIndex(i + 1);\n      }\n      ++i;\n    }\n  }", "CodeBleu_score": 67.30537635638825}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum() + 2;\n    AddVertices(vertices);\n    bool index_clockwise = true;\n    while (i < GetVerticesNum()) {\n      index_clockwise = !index_clockwise;\n      if (index_clockwise) {\n        AddIndex(i + 1);\n        AddIndex(i);\n        AddIndex(i - 1);\n      } else {\n        AddIndex(i - 1);\n        AddIndex(i);\n        AddIndex(i + 1);\n      }\n      ++i;\n    }\n  }", "CodeBleu_score": 67.30537635638825}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum() + 2;\n    AddVertices(vertices);\n    bool index_clockwise = true;\n    while (i < GetVerticesNum()) {\n      index_clockwise = !index_clockwise;\n      if (index_clockwise) {\n        AddIndex(i + 1);\n        AddIndex(i);\n        AddIndex(i - 1);\n      } else {\n        AddIndex(i - 1);\n        AddIndex(i);\n        AddIndex(i + 1);\n      }\n      ++i;\n    }\n  }", "CodeBleu_score": 67.30537635638825}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  boost::asio::post(_strand, [this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n    _deadline.expires_from_now(_timeout);\n    boost::asio::async_write(\n        _socket,\n        boost::asio::buffer(message->data(), message->size()),\n        boost::asio::bind_executor(\n            _strand,\n            std::bind(\n                &Primary::HandleSent,\n                shared_from_this(),\n                std::placeholders::_1,\n                std::placeholders::_2,\n                message)));\n  });\n}", "CodeBleu_score": 33.2964780196434}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  boost::asio::post(_strand, [this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n    _deadline.expires_from_now(_timeout);\n    boost::asio::async_write(\n        _socket,\n        boost::asio::buffer(message->data(), message->size()),\n        boost::asio::bind_executor(\n            _strand,\n            std::bind(\n                &Primary::HandleSent,\n                shared_from_this(),\n                std::placeholders::_1,\n                std::placeholders::_2,\n                message)));\n    _deadline.async_wait(_strand.wrap(std::bind(\n        &Primary::CheckDeadline,\n        shared_from_this(),\n        std::placeholders::_1)));\n  });\n}", "CodeBleu_score": 42.96092502366624}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  boost::asio::post(_strand, [this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n    _deadline.expires_from_now(_timeout);\n    _deadline.async_wait(boost::asio::bind_executor(_strand, [this](const boost::system::error_code ec) {\n      if (!ec) {\n        _socket.close();\n      }\n    }));\n    boost::asio::async_write(_socket, boost::asio::buffer(message->data(), message->size()),\n        boost::asio::bind_executor(_strand, [this, message](const boost::system::error_code ec, size_t) {\n          if (ec) {\n            log_error(ec, \"Primary::Write\");\n            _socket.close();\n          }\n        }));\n  });\n}", "CodeBleu_score": 44.5273580541344}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 15);\n  log_info(\"sending alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\"got a response: \", std::string(response.buffer.data(), response.buffer.size()));\n}", "CodeBleu_score": 65.20954568446977}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 14);\n  log_info(\"asking if the system is alive\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\"the system is alive\");\n}", "CodeBleu_score": 53.977284557216684}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 15);\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"got a response: \", std::string(response.buffer.data()));\n}", "CodeBleu_score": 53.24964412049407}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"sending enable for ros command\");\n    carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n    auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_FOR_ROS, std::move(buf));\n    auto response = fut.get();\n    log_info(\"response from enable for ros command: \", response.buffer.data());\n}", "CodeBleu_score": 51.47384965018381}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking if sensor is enabled for ROS\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::IS_ENABLED_FOR_ROS, std::move(buf));\n\n  auto response = fut.get();\n  if (response.command == MultiGPUCommand::IS_ENABLED_FOR_ROS) {\n    log_info(\"response from is enabled for ROS command: \", response.buffer.data());\n    if (strcmp((char *) response.buffer.data(), \"true\") == 0) {\n      log_info(\"sending enable for ROS command\");\n      _router->Write(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n    }\n  } else {\n    log_error(\"sensor not found on any secondary server\");\n  }\n}", "CodeBleu_score": 60.38379825075136}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"sending enable ros command\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  log_info(\"response from enable ros command: \", response.buffer.data());\n}", "CodeBleu_score": 50.18586872053036}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"sensor\", sensor_id, \" already activated\");\n    return it->second.token;\n  }\n  // enable the sensor on a secondary server\n  token_type new_token = SendGetToken(sensor_id);\n  // update the maps\n  _servers.insert(std::make_pair(sensor_id, Server(new_token)));\n  _tokens.insert(std::make_pair(new_token.get_stream_id(), new_token));\n  // log the action\n  log_info(\"sensor\", sensor_id, \" activated on server\", new_token.get_server_id(), \" with token\", new_token.get_stream_id());\n  return new_token;\n}", "CodeBleu_score": 53.047353286229004}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"getting token for sensor\", sensor_id);\n  // check if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // sensor already activated\n    token_type existing_token(it->first, it->second);\n    log_info(\"sensor\", sensor_id, \" already activated on server\", it->second);\n    return existing_token;\n  } else {\n    // sensor not activated yet\n    token_type new_token = SendGetToken(sensor_id);\n    _servers[sensor_id] = new_token.get_server_id();\n    log_info(\"sensor\", sensor_id, \" activated on server\", new_token.get_server_id());\n    return new_token;\n  }\n}", "CodeBleu_score": 56.162881475164596}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"token for sensor\", sensor_id, \" already exists\");\n    return it->second;\n  } else {\n    log_info(\"enabling sensor\", sensor_id);\n    token_type new_token = SendGetToken(sensor_id);\n    _servers.insert({sensor_id, new_token});\n    return new_token;\n  }\n}", "CodeBleu_score": 47.79799791600266}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream ifs(filename, std::ios::binary);\n  if (!ifs) {\n    return false;\n  }\n\n  // get length of file:\n  ifs.seekg (0, ifs.end);\n  int length = ifs.tellg();\n  ifs.seekg (0, ifs.beg);\n\n  std::vector<unsigned char> bytes(length);\n  ifs.read(reinterpret_cast<char*>(&bytes[0]), length);\n  ifs.close();\n\n  return Load(bytes);\n}", "CodeBleu_score": 48.85053734399253}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream infile(filename, std::ios::binary);\n  if (!infile) {\n    log_error(\"Could not open file \" + filename);\n    return false;\n  }\n\n  infile.seekg(0, std::ios::end);\n  std::streampos size = infile.tellg();\n  infile.seekg(0, std::ios::beg);\n\n  _binary_mesh.resize(size);\n  infile.read(&_binary_mesh[0], size);\n\n  infile.close();\n\n  return Load(_binary_mesh);\n}", "CodeBleu_score": 48.611741222516144}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream ifs(filename, std::ios::binary);\n  if (!ifs.is_open()) {\n    return false;\n  }\n\n  // get length of file:\n  ifs.seekg(0, ifs.end);\n  std::streampos length = ifs.tellg();\n  ifs.seekg(0, ifs.beg);\n\n  // allocate memory:\n  _binary_mesh.resize(static_cast<size_t>(length));\n\n  // read data as a block:\n  ifs.read(reinterpret_cast<char*>(&_binary_mesh[0]), length);\n  ifs.close();\n\n  return Load(_binary_mesh);\n}", "CodeBleu_score": 52.81090678223536}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n    if (info.current_count_change == 1) {\n        if (_matched != 0) {\n            std::cout << \"Unexpected change in publication count: \" << info.current_count_change << std::endl;\n        } else {\n            _matched = info.total_count;\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        if (_matched != 1) {\n            std::cout << \"Unexpected change in publication count: \" << info.current_count_change << std::endl;\n        } else {\n            _matched = info.total_count;\n        }\n    } else {\n        std::cout << \"Unexpected change in publication count: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 67.26401939975108}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    if (_matched != 0) {\n      std::cerr << \"Unexpected change in publication count: \" << info.current_count_change << std::endl;\n    } else {\n      _matched = info.total_count;\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    if (_matched == 0) {\n      std::cerr << \"Unexpected change in publication count: \" << info.current_count_change << std::endl;\n    } else {\n      _matched = info.total_count;\n    }\n  } else {\n    std::cerr << \"Unexpected change in publication count: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 70.87974694520899}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    if (_matched != 0) {\n      std::cout << \"Matched count not zero\" << std::endl;\n    }\n    _matched = info.total_count;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    if (_matched != info.total_count + 1) {\n      std::cout << \"Matched count change not -1\" << std::endl;\n    }\n    _matched = info.total_count;\n  } else {\n    std::cout << \"Invalid matched count change\" << std::endl;\n  }\n}", "CodeBleu_score": 72.8198026274445}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        _matched++;\n        if (!_first_connected) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched--;\n        if (_matched == 0) {\n            _owner->destroy_subscriber();\n        }\n    } else {\n        std::cerr << \"Invalid subscription change count: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 66.53043513805335}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    _matched++;\n    if (!_first_connected) {\n      _first_connected = true;\n      std::cout << \"First matched subscriber for topic \" << reader->get_topicdescription()->get_name() << std::endl;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched--;\n    if (_matched == 0) {\n      std::cout << \"Last subscriber unmatched for topic \" << reader->get_topicdescription()->get_name() << std::endl;\n      if (_owner) {\n        _owner->destroy();\n      }\n    }\n  } else {\n    std::cerr << \"Unexpected change in subscription count for topic \" << reader->get_topicdescription()->get_name() << std::endl;\n  }\n}", "CodeBleu_score": 58.66290625074997}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    std::cout << \"Subscriber matched.\n\";\n    _matched++;\n    if (!_first_connected) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Subscriber unmatched.\n\";\n    _matched--;\n    if (_matched == 0) {\n      std::cout << \"No more subscribers. Destroying subscriber.\n\";\n      _owner->Destroy();\n    }\n  } else {\n    std::cout << \"Bad matched status.\n\";\n  }\n}", "CodeBleu_score": 57.70514129829246}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!m_isGetKeyDefined)\n    {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Serialization.\n    FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    Cdr ser(fastbuffer, Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)\n    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i < 16;++i)\n        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else\n    {\n        for(uint8_t i = 0;i < 16;++i)\n        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 81.93814459345377}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined)\n    {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Serialization.\n    FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), CarlaCollisionEvent::getKeyMaxCdrSerializedSize()); // Object that manages the raw buffer.\n    Cdr ser(fastbuffer, Cdr::BIG_ENDIANNESS); // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)\n    {\n        // Hash the key.\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i)\n        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else\n    {\n        // Direct copy.\n        for (uint8_t i = 0; i < 16; ++i)\n        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 91.84924459257208}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 98.44374423067781}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl &msg = *(CarlaEgoVehicleControl*)data;\n        payload->message_length = static_cast<uint32_t>(ser.getSerializedDataLength());\n        ser << msg;\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 77.58376722834115}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl &carla_ego_vehicle_control = *(CarlaEgoVehicleControl*)data;\n        ser << carla_ego_vehicle_control;\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 73.79164242105301}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl &carla_ego_vehicle_control = *(CarlaEgoVehicleControl*)data;\n        ser << carla_ego_vehicle_control;\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 69.60097025845322}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < g.num_gcs; i++) {\n        if (gcs[i].initialized && gcs[i].system_id == sysid) {\n            gcs[i].request_datastream_position(compid);\n        }\n    }\n}", "CodeBleu_score": 31.754356849170172}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < g.num_gcs; i++) {\n        if (gcs[i].active() && gcs[i].available_payload() >= MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN) {\n            gcs[i].request_data_stream(sysid, compid, MAVLINK_MSG_ID_LOCAL_POSITION_NED, 20);\n        }\n    }\n}", "CodeBleu_score": 43.58233819160033}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// iterate over GCS channels\n    for (uint8_t i=0; i<g.num_gcs; i++) {\n        // check if there is space for a new stream\n        if (gcs[i].streams.available_space() > 0) {\n            // check if there is already a stream for the specified system and component ID\n            if (gcs[i].streams.find_stream(sysid, compid, MAVLINK_MSG_ID_GLOBAL_POSITION_INT) != -1) {\n                // stream already exists, so do nothing\n                return;\n            }\n            // check if there is already a stream for the specified system and component ID\n            if (gcs[i].streams.find_stream(sysid, compid, MAVLINK_MSG_ID_GPS_RAW_INT) != -1) {\n                // stream already exists, so do nothing\n                return;\n            }\n            // check if there is already a stream for the specified system and component ID\n            if (gcs[i].streams.find_stream(sysid, compid, MAVLINK_MSG_ID_GPS_RAW) != -1) {\n                // stream already exists, so do nothing\n                return;\n            }\n            // check if there is already a stream for the specified system and component ID\n            if (gcs[i].streams.find_stream(sysid, compid, MAVLINK_MSG_ID_GPS_STATUS) != -1) {\n                // stream already exists, so do nothing\n                return;\n            }\n            // check if there is already a stream for the specified system and component ID\n            if (gcs[i].streams.find_stream(sysid, compid, MAVLINK_MSG_ID_GPS2_RAW) != -1) {\n                // stream already exists, so do nothing\n                return;\n            }\n            // check if there is already a stream for the specified system and component ID\n            if (gcs[i].streams.find_stream(sysid, compid, MAVLINK_MSG_ID_GPS2_STATUS) != -1", "CodeBleu_score": 47.238158660103124}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch == 0) {\n        return false;\n    }\n    ef_pitch = atan2f(pitch * ahrs.sin_roll() + yaw * ahrs.cos_roll() * ahrs.sin_pitch(), cos_pitch) * 100;\n    ef_yaw = atan2f(yaw * ahrs.cos_roll() - pitch * ahrs.sin_roll() * ahrs.sin_pitch(), ahrs.cos_roll() * cos_pitch) * 100;\n    return true;\n}", "CodeBleu_score": 67.71414815561427}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch != 0.0) {\n        ef_pitch = ahrs.asin(ahrs.sin_roll() * sin(pitch) + cos(pitch) * cos(yaw) * ahrs.cos_roll());\n        ef_yaw = ahrs.atan2(-ahrs.sin_roll() * cos(pitch) + sin(yaw) * ahrs.cos_roll(), cos(pitch) * ahrs.cos_roll() - ahrs.sin_roll() * sin(yaw) * ahrs.sin_pitch());\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 62.79424205910911}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t// body frame to earth frame pitch and yaw conversion\n    const AP_AHRS &ahrs = AP::ahrs();\n    if (ahrs.cos_pitch() != 0) {\n        ef_pitch = ahrs.cos_pitch() * pitch - ahrs.sin_pitch() * ahrs.cos_roll() * yaw;\n        ef_yaw = ahrs.cos_roll() * yaw + ahrs.sin_roll() * ahrs.sin_pitch() * pitch;\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 73.7549844270742}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\tint16_t target_yaw_cd, target_pitch_cd, yaw_error_cd, pitch_error_cd;\n\t\n\t/*\n\t * Calculate the target yaw and pitch in centidegrees\n\t */\n\ttarget_yaw_cd = (int16_t) (((float) target_yaw_deg) * 100.0);\n\ttarget_pitch_cd = (int16_t) (((float) target_pitch_deg) * 100.0);\n\t\n\t/*\n\t * Check if the direction is reversed\n\t */\n\tif (target_yaw_cd < 0) {\n\t\ttarget_yaw_cd += 36000;\n\t}\n\tif (target_pitch_cd < 0) {\n\t\ttarget_pitch_cd += 36000;\n\t}\n\t\n\t/*\n\t * Calculate the angle errors in centidegrees\n\t */\n\tyaw_error_cd = target_yaw_cd - yaw_cd;\n\tpitch_error_cd = target_pitch_cd - pitch_cd;\n\t\n\t/*\n\t * Convert the errors from earth frame to body frame\n\t */\n\tif (yaw_error_cd > 18000) {\n\t\tyaw_error_cd -= 36000;\n\t} else if (yaw_error_cd < -18000) {\n\t\tyaw_error_cd += 36000;\n\t}\n\tif (pitch_error_cd > 18000) {\n\t\tpitch_error_cd -= 36000;\n\t} else if (pitch_error_cd < -18000) {\n\t\tpitch_error_cd += 36000;\n\t}\n\t\n\t/*\n\t * If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\t */\n\tif (target_distance_valid || !min_distance_set) {\n\t\tif (yaw_error_cd", "CodeBleu_score": 23.084181966445765}, {"code": "void Mode::update_auto(void){\n\t// Get the navigation status\n    nav_status = tracker.get_nav_status();\n\n    // Get the current position\n    position = tracker.get_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tracker.get_target_position();\n\n    // Get the current target position\n    target_position = tra", "CodeBleu_score": 19.275688331709013}, {"code": "void Mode::update_auto(void){\n\t/*\n   * Update the target yaw and pitch for the tracker based on navigation status and parameters.\n   */\n  int16_t target_yaw = 0;\n  int16_t target_pitch = 0;\n  int16_t yaw_error = 0;\n  int16_t pitch_error = 0;\n\n  /*\n   * Calculate the yaw and pitch in centidegrees.\n   */\n  target_yaw = (int16_t)(((float)tracker.nav.target_bearing / 360.0) * 32768);\n  target_pitch = (int16_t)(((float)tracker.nav.target_elevation / 180.0) * 32768);\n\n  /*\n   * Check if the direction is reversed.\n   */\n  if (tracker.nav.target_reverse) {\n    target_yaw = target_yaw + 16384;\n    if (target_yaw > 32767) {\n      target_yaw = target_yaw - 32768;\n    }\n  }\n\n  /*\n   * Compute the angle error.\n   */\n  yaw_error = target_yaw - tracker.yaw_centidegrees;\n  pitch_error = target_pitch - tracker.pitch_centidegrees;\n\n  /*\n   * Convert the errors from earth frame to body frame.\n   */\n  yaw_error = (int16_t)(yaw_error * cos(tracker.pitch_radians));\n  pitch_error = (int16_t)(pitch_error * cos(tracker.yaw_radians));\n\n  /*\n   * If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly.\n   */\n  if (tracker.nav.target_distance_valid || tracker.nav.target_minimum_distance == 0) {\n    tracker.pitch_servo_output = tracker.pitch_", "CodeBleu_score": 32.57051176430853}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tgps.update();\n    if (gps.status() != AP_GPS::GPS_OK_FIX_3D) {\n        return;\n    }\n    if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n        last_gps_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n            if (ground_start_countdown == 1) {\n                if (gps.location().lat != 0 && gps.location().lng != 0) {\n                    gps.set_home(gps.location());\n                    gps.set_home_alt(gps.altitude());\n                    gps.set_home_ground_level(true);\n                    ground_start_countdown = 0;\n                } else {\n                    ground_start_countdown = 5;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 54.212348088331495}, {"code": "void Tracker::update_GPS(void){\n\tif (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n        if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n            last_gps_message_time_ms = gps.last_message_time_ms();\n            if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n                if (ground_start_countdown > 0) {\n                    ground_start_countdown--;\n                }\n                if (ground_start_countdown == 1) {\n                    if (gps.location().lat != 0 && gps.location().lng != 0) {\n                        gps.set_home(gps.location());\n                        ground_start_countdown = 0;\n                        ground_start_countdown_ms = 0;\n                    } else {\n                        ground_start_countdown = 10;\n                        ground_start_countdown_ms = 0;\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 53.399498093267454}, {"code": "void Tracker::update_GPS(void){\n\tif (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n        // check if we have a valid location\n        if (gps.location().lat != 0 && gps.location().lng != 0) {\n            // we have a valid location\n            if (ground_start_countdown > 0) {\n                // we have a valid location and we have not yet set the home location\n                ground_start_countdown--;\n                if (ground_start_countdown == 0) {\n                    // we have a valid location and the countdown has reached zero\n                    // so set the home location\n                    gps.set_home(gps.location());\n                    // set the ground start flag so we don't try to set the home location again\n                    ground_started = true;\n                }\n            }\n        } else {\n            // we have an invalid location\n            // reset the countdown\n            ground_start_countdown = ground_start_countdown_max;\n        }\n    }\n}", "CodeBleu_score": 36.69811308287237}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= g.pitch_min) {\n        new_servo_out = g.pitch_min;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= g.pitch_max) {\n        new_servo_out = g.pitch_max;\n        g.pidPitch2Srv.reset_I();\n    }\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 38.810339993857355}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= g.pitch_min*100) {\n        new_servo_out = g.pitch_min*100;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= g.pitch_max*100) {\n        new_servo_out = g.pitch_max*100;\n        g.pidPitch2Srv.reset_I();\n    }\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 40.492766845784764}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= 0) {\n        new_servo_out = 0;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= 1000) {\n        new_servo_out = 1000;\n        g.pidPitch2Srv.reset_I();\n    }\n\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 38.30300833466055}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    if (!copter.barometer.get_state() ||\n        !copter.barometer.healthy(0) ||\n        !copter.barometer.calibrated() ||\n        !copter.barometer.get_last_altitude_relative_to_home()) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Barometer not healthy\");\n        return false;\n    }\n\n    if (labs(copter.barometer.get_altitude() - copter.baro_alt) > 500) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Baro altitude disparity\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 52.566506532248646}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (check_enabled(ARMING_CHECK_BARO)) {\n        // check baro reference\n        if (!baro_health_check()) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Baro ref\");\n            return false;\n        }\n\n        // check baro altitude\n        float baro_altitude = baro_altitude_cm() / 100.0f;\n        float inav_altitude = inertial_nav.get_altitude();\n        float alt_diff = fabsf(baro_altitude - inav_altitude);\n        if (alt_diff > copter.g.baro_alt_max_diff) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Baro diff %.1f\", alt_diff);\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 57.878992297669086}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (check_enabled(ARMING_CHECK_BARO)) {\n        if (copter.barometer->get_state() != AP_Baro::BARO_STATE_HEALTHY) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Baro not healthy\");\n            return false;\n        }\n\n        if (copter.barometer->get_altitude() > copter.current_loc.alt + 100 ||\n            copter.barometer->get_altitude() < copter.current_loc.alt - 100) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Baro altitude too far from GPS\");\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 52.37256220462477}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// update rate controller\n\trate_controller_run();\n\n\t// run attitude controllers\n\tattitude_control.rate_controller_run();\n\n\t// run position controllers\n\tpos_control.rate_controller_run();\n\n\t// run motor controllers\n\tmotor_control.rate_controller_run();\n\n}", "CodeBleu_score": 33.452588842933416}, {"code": "void Copter::run_rate_controller(){\n\t// update the rate controller loop time\n    attitude_control.set_dt(scheduler.interval_100());\n\n    // run attitude controllers\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 23.76937819313466}, {"code": "void Copter::run_rate_controller(){\n\t// get dt since last call\n    uint32_t dt = scheduler.time_since_last_call_us();\n\n    // update rate controllers\n    attitude_control.rate_controller_run(dt);\n\n    // output to motors\n    attitude_control.output_roll_pitch_yaw();\n}", "CodeBleu_score": 43.17287843863063}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}, {"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}, {"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// retrieve copter's velocity\n    Vector3f velocity = copter.inertial_nav.get_velocity();\n    // calculate speed squared\n    float speed_sq = velocity.length_squared();\n    // if the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n    if (copter.inertial_nav.get_position().is_valid() && speed_sq > 0.000001f) {\n        // update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw = atan2f(velocity.y, velocity.x) * 180.0f / PI;\n    }\n    // return the computed look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 47.69370136770091}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat speed_sq = copter.velocity_xy.length_squared();\n    if (copter.position_ok && speed_sq > 100.0f) {\n        // calculate look ahead yaw angle\n        look_ahead_yaw = atan2f(copter.velocity_xy.x, copter.velocity_xy.y);\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 36.839257344937714}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat look_ahead_yaw = 0;\n    Vector3f velocity = copter.inertial_nav.get_velocity();\n    float speed_sq = velocity.length_squared();\n    if (copter.inertial_nav.position_ok() && speed_sq > 0.0001f) {\n        look_ahead_yaw = atan2f(velocity.y, velocity.x);\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 49.996295765250295}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_shift :\n                has_shift_function = true;\n                break;\n            case JSButton::k_arm_toggle :\n                return true;\n            case JSButton::k_disarm :\n                return true;\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    if (has_shift_function) {\n        for (uint8_t i = 0; i < 16; i++) {\n            switch (sub.get_button(i)->function(true)) {\n                case JSButton::k_arm_toggle :\n                case JSButton::k_disarm :\n                    return true;\n            }\n        }\n    }\n\n    if (display_failure) {\n        GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"No disarm button assigned\");\n    }\n    return false;\n}", "CodeBleu_score": 52.21059241349505}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_shift :\n                has_shift_function = true;\n                break;\n            case JSButton::k_arm_toggle :\n                return true;\n            case JSButton::k_disarm :\n                return true;\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    if (has_shift_function) {\n        for (uint8_t i = 0; i < 16; i++) {\n            switch (sub.get_button(i)->function(true)) {\n                case JSButton::k_arm_toggle :\n                case JSButton::k_disarm :\n                    return true;\n            }\n        }\n    }\n\n    // no disarm button assigned\n    if (display_failure) {\n        sub.armed_error_msg = ARMED_ERROR_MSG_NO_DISARM;\n    }\n    return false;\n}", "CodeBleu_score": 50.16326281265864}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed) {\n        return true;\n    }\n\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"No disarm button\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 76.2517527818309}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat cos_yaw = cos(ahrs.yaw);\n    float sin_yaw = sin(ahrs.yaw);\n    float ne_x = x*cos_yaw + y*sin_yaw;\n    float ne_y = y*cos_yaw - x*sin_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.69678455142772}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n    float cos_yaw = cosf(ahrs.yaw);\n    float sin_yaw = sinf(ahrs.yaw);\n    ne_x = x * cos_yaw - y * sin_yaw;\n    ne_y = x * sin_yaw + y * cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 56.99492019085209}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// get yaw angle\n    float yaw = ahrs.yaw_sensor;\n\n    // rotate vector from vehicle's perspective to North-East frame\n    float ne_x = x*cosf(yaw*0.01745329252f) - y*sinf(yaw*0.01745329252f);\n    float ne_y = x*sinf(yaw*0.01745329252f) + y*cosf(yaw*0.01745329252f);\n\n    // update x and y with new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 55.30281836737865}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t// check if we have a valid home\n    if (home_is_set) {\n        return;\n    }\n    // check if we are flying\n    if (motors.armed()) {\n        // set home to current location\n        ahrs.set_home(inertial_nav.get_position());\n        home_is_set = true;\n    } else {\n        // attempt to set home to current EKF position\n        ahrs.set_home(ahrs.get_position());\n        home_is_set = ahrs.get_home().is_valid();\n    }\n}", "CodeBleu_score": 35.17994857464508}, {"code": "void Sub::update_home_from_EKF(){\n\t// if we've already set the home position, exit immediately\n    if (g.home_set) {\n        return;\n    }\n\n    // if we're in flight, set the home position to our current location\n    if (motors.armed()) {\n        set_home_to_current_location();\n        return;\n    }\n\n    // if we're on the ground, try to set the home position to our\n    // current EKF position. If we're not moving, it will fail.\n    set_home_to_EKF_pos();\n}", "CodeBleu_score": 36.37268131825287}, {"code": "void Sub::update_home_from_EKF(){\n\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location();\n\t} else {\n\t\t// we are not flying. Try to set the home position to the EKF position\n\t\tif (EKFWrapper::get_EKF_initialised()) {\n\t\t\tVector3f pos;\n\t\t\tEKFWrapper::get_EKF_origin(pos);\n\t\t\tset_home_position(pos);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.62315823082365}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t// exit immediately if not armed\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(SpoolState::kIdle);\n        attitude_control.relax_bf_rate_controllers();\n        attitude_control.relax_yaw_rate_controller();\n        attitude_control.set_desired_throttle(0.0f);\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    motors.set_desired_spool_state(SpoolState::kUnlimited);\n\n    // convert pilot inputs to desired body frame rates\n    Vector3f pilot_bf_rates = pilot.get_pilot_bf_rates();\n\n    // run attitude controllers\n    attitude_control.run_angle_bf_rate_controllers(pilot_bf_rates);\n    attitude_control.run_yaw_rate_controller(pilot.get_pilot_yaw_rate());\n\n    // set desired throttle\n    attitude_control.set_desired_throttle(pilot.get_throttle());\n\n    // set motor outputs\n    motors.set_desired_motor_bfs(attitude_control.get_desired_bfs());\n}", "CodeBleu_score": 44.22439185629308}, {"code": "void ModeAcro::run(){\n\t// if not armed, set throttle to zero and relax attitude controllers\n    if (!motors.armed()) {\n        motors.set_throttle_out(0);\n        position_control->relax_alt_hold_controllers(true);\n        return;\n    }\n\n    // if armed, set spool state to unlimited throttle\n    motors.set_spool_state(AP_Motors::UNLIMITED);\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate = sub.pilot_input.roll * ACRO_RATE_MAX;\n    float pitch_rate = sub.pilot_input.pitch * ACRO_RATE_MAX;\n    float yaw_rate = sub.pilot_input.yaw * ACRO_RATE_MAX;\n\n    // run attitude controller\n    position_control->run_acro(roll_rate, pitch_rate, yaw_rate);\n\n    // output pilot's throttle input without angle boost\n    motors.set_throttle_out(sub.pilot_input.throttle);\n\n    // set forward and lateral motor inputs based on pilot controls\n    motors.set_desired_spool_rates_from_radio();\n}", "CodeBleu_score": 45.951323211193525}, {"code": "void ModeAcro::run(){\n\tif (!motors.armed()) {\n        motors.set_throttle(0);\n        motors.set_spool_state(Motors::SpoolState::Unlimited);\n        position_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_spool_state(Motors::SpoolState::Unlimited);\n\n    // convert pilot inputs to desired body frame rates\n    // (we use the pilot's throttle input as a forward command)\n    float throttle = sub.rc_in.throttle();\n    float forward = throttle;\n    float right = sub.rc_in.roll();\n    float up = sub.rc_in.pitch();\n    float yaw = sub.rc_in.yaw();\n\n    // run attitude controller\n    position_control->run_attitude_controllers(forward, right, up, yaw);\n\n    // set motor outputs\n    motors.set_front_motor(forward);\n    motors.set_right_motor(right);\n    motors.set_back_motor(forward);\n    motors.set_left_motor(right);\n}", "CodeBleu_score": 49.218125692684495}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// set guided_mode to true\n    guided_mode = true;\n    // set guided_pos_control_mode to true\n    guided_pos_control_mode = true;\n    // set guided_yaw_mode to false\n    guided_yaw_mode = false;\n    // set guided_limit to false\n    guided_limit = false;\n    // set guided_limit_wp to false\n    guided_limit_wp = false;\n    // set guided_limit_wp_distance_max_cm to false\n    guided_limit_wp_distance_max_cm = false;\n    // set guided_limit_wp_bearing_max_cd to false\n    guided_limit_wp_bearing_max_cd = false;\n    // set guided_limit_wp_bearing_auto to false\n    guided_limit_wp_bearing_auto = false;\n    // set guided_limit_wp_bearing_relative to false\n    guided_limit_wp_bearing_relative = false;\n    // set guided_limit_wp_loiter_time_max_ms to false\n    guided_limit_wp_loiter_time_max_ms = false;\n    // set guided_limit_wp_land_complete to false\n    guided_limit_wp_land_complete = false;\n    // set guided_limit_wp_land_complete to false\n    guided_limit_wp_loiter_radius_cm = false;\n    // set guided_limit_wp_loiter_direction to false\n    guided_limit_wp_loiter_direction = false;\n    // set guided_limit_wp_loiter_angle_max_cd to false\n    guided_limit_wp_loiter_angle_max_cd = false;\n    // set guided_limit_wp_loiter_angle_offset_cd to false\n    guided_limit_wp_loiter_angle_offset_cd = false;\n    // set guided_limit_wp_acceptance_radius_cm to false\n    guided_limit_wp_acceptance_radius_cm =", "CodeBleu_score": 7.383870329076585}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// initialise position controller\n    pos_control.set_mode(POSITION_CONTROL);\n    pos_control.set_target(current_loc);\n\n    // initialise waypoint controller\n    wp_nav.set_wp_destination(current_loc);\n    wp_nav.set_guided_mode(true);\n    wp_nav.set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\n    // initialise guided_limit\n    guided_limit.timeout_ms = 0;\n    guided_limit.alt_min_cm = 0;\n    guided_limit.alt_max_cm = 0;\n    guided_limit.horiz_max_cm = 0;\n    guided_limit.start_time = 0;\n    guided_limit.start_pos = Vector3f(0,0,0);\n}", "CodeBleu_score": 33.234569016793955}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// initialize position controller\n    pos_control.set_mode(POSITION_CONTROL);\n    pos_control.set_alt_target(current_loc.alt);\n    pos_control.set_alt_target_from_climb_rate(current_loc.alt, 0, G_Dt);\n    pos_control.set_vel_xy_target(0, 0);\n    pos_control.set_yaw_target_to_current_heading();\n    pos_control.set_throttle_out(get_throttle_pre_takeoff(channel_throttle->control_in), true);\n    pos_control.set_accel_z(0);\n\n    // initialize waypoint controller\n    wp_nav.set_guided_waypoint_destination(current_loc.lat, current_loc.lng, current_loc.alt);\n    wp_nav.set_guided_heading_to_next_waypoint(current_loc.lat, current_loc.lng);\n    wp_nav.set_alt_target_from_climb_rate(current_loc.alt, 0, G_Dt);\n    wp_nav.set_wp_yaw_behavior(get_default_auto_yaw_mode(false));\n\n    // initialize guided limits\n    guided_limit.timeout_ms = 0;\n    guided_limit.alt_min_cm = 0;\n    guided_limit.alt_max_cm = 0;\n    guided_limit.horiz_max_cm = 0;\n    guided_limit.start_time = 0;\n    guided_limit.start_pos.zero();\n\n    // set guided mode flag\n    guided_mode = true;\n}", "CodeBleu_score": 44.28249007984998}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialize vertical maximum speeds and acceleration using pilot-defined parameters\n    float vel_max_z_up = g.pilot_velocity_z_max;\n    float vel_max_z_down = g.pilot_velocity_z_max;\n    float accel_z = g.pilot_accel_z;\n\n    // initialize vertical velocity controller\n    sub.vel_z_controller.set_accel_max(accel_z);\n    sub.vel_z_controller.set_vel_max(vel_max_z_up, vel_max_z_down);\n    sub.vel_z_controller.reset();\n\n    // initialize horizontal velocity controller\n    sub.vel_xy_controller.set_accel_max(g.pilot_accel_xy);\n    sub.vel_xy_controller.set_vel_max(g.pilot_velocity_xy_max);\n    sub.vel_xy_controller.reset();\n\n    // initialize yaw control mode\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 48.837008177662355}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical maximum speeds and acceleration\n    float vel_max_z_cm = g.pilot_velocity_z_max;\n    float accel_z_cm_s_s = g.pilot_accel_z;\n\n    // initialise vertical velocity controller\n    sub.vel_z_controller.set_accel_max(accel_z_cm_s_s);\n    sub.vel_z_controller.set_speed_max(vel_max_z_cm);\n    sub.vel_z_controller.set_speed_cms(0);\n\n    // initialise horizontal velocity controller\n    sub.vel_xy_controller.set_accel_max(g.pilot_accel_xy);\n    sub.vel_xy_controller.set_speed_max(g.pilot_velocity_xy_max);\n    sub.vel_xy_controller.set_speed_xy(0,0);\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 47.41494998602963}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical maximum speeds and acceleration using pilot-defined parameters\n    float vel_max_z_cm_s = g.pilot_velocity_z_max * 100.0f;\n    float accel_z_cm_s_s = g.pilot_accel_z * 100.0f;\n    sub.pos_control.set_speed_z(-vel_max_z_cm_s, vel_max_z_cm_s);\n    sub.pos_control.set_accel_z(accel_z_cm_s_s);\n\n    // initialise horizontal velocity controller\n    float vel_max_xy_cm_s = g.pilot_velocity_xy_max * 100.0f;\n    float accel_xy_cm_s_s = g.pilot_accel_xy * 100.0f;\n    sub.pos_control.set_speed_xy(vel_max_xy_cm_s, vel_max_xy_cm_s);\n    sub.pos_control.set_accel_xy(accel_xy_cm_s_s);\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 47.6627253801707}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}, {"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}, {"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n    if (tnow - last_do_motor_test_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test timed out. Disarming.\\\");\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 47.1535906259696}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = hal.scheduler->millis();\n    if (tnow - ap.motor_test_last_request_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test timed out.\\\");\n        ap.motor_test = false;\n        motors.output_disarmed();\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 55.43775412596138}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n    if (tnow - last_do_motor_test_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out.\");\n        ap.motor_test = false;\n        motors.output_disarmed();\n        motors.set_interlock(false);\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 61.79876001026115}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get roll and pitch targets from wp_nav\n    float roll_cd = wp_nav.get_roll_cd();\n    float pitch_cd = wp_nav.get_pitch_cd();\n\n    // constrain roll and pitch targets within a specified maximum angle range\n    float max_roll_pitch_cd = constrain_float(g.wp_nav_max_roll_pitch_cd, 0, 9000);\n    roll_cd = constrain_float(roll_cd, -max_roll_pitch_cd, max_roll_pitch_cd);\n    pitch_cd = constrain_float(pitch_cd, -max_roll_pitch_cd, max_roll_pitch_cd);\n\n    // normalize roll and pitch targets\n    float roll_pitch_norm = norm_angle(roll_cd) / 9000.0f;\n    float pitch_norm = norm_angle(pitch_cd) / 9000.0f;\n\n    // assign normalized values to lateral_out and forward_out\n    lateral_out = roll_pitch_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 41.4934439815752}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target_cd, pitch_target_cd;\n    wp_nav.get_roll_pitch_cd(roll_target_cd, pitch_target_cd);\n\n    // constrain targets within a maximum angle range\n    roll_target_cd = constrain_float(roll_target_cd, -wpnav_roll_max_cd, wpnav_roll_max_cd);\n    pitch_target_cd = constrain_float(pitch_target_cd, -wpnav_pitch_max_cd, wpnav_pitch_max_cd);\n\n    // normalize targets\n    float roll_target = roll_target_cd / 100.0f;\n    float pitch_target = pitch_target_cd / 100.0f;\n    float roll_pitch_norm = get_pythagorous2(roll_target, pitch_target);\n    if (roll_pitch_norm > 1.0f) {\n        roll_target /= roll_pitch_norm;\n        pitch_target /= roll_pitch_norm;\n    }\n\n    // set outputs\n    lateral_out = roll_target;\n    forward_out = pitch_target;\n}", "CodeBleu_score": 33.418250514960874}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// retrieve roll and pitch targets in centidegrees\n    float roll_cd = wp_nav.get_roll();\n    float pitch_cd = wp_nav.get_pitch();\n\n    // constrain targets within a specified maximum angle range\n    roll_cd = constrain_float(roll_cd, -g.wp_nav_max_roll_cd, g.wp_nav_max_roll_cd);\n    pitch_cd = constrain_float(pitch_cd, -g.wp_nav_max_pitch_cd, g.wp_nav_max_pitch_cd);\n\n    // normalize targets\n    float roll_norm = roll_cd / g.wp_nav_max_roll_cd;\n    float pitch_norm = pitch_cd / g.wp_nav_max_pitch_cd;\n\n    // assign normalized values to lateral_out and forward_out\n    lateral_out = roll_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 51.591193175356345}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t// Read barometer\n    bmp.read_barometer();\n\n    // Update barometer calibration if altitude is above zero\n    if (bmp.altitude() > 0) {\n        bmp.update_calibration();\n    }\n\n    // Update sensor health status based on barometer health\n    if (bmp.healthy()) {\n        sensors.set_healthy(Sensors::BMP);\n    } else {\n        sensors.set_unhealthy(Sensors::BMP);\n    }\n}", "CodeBleu_score": 47.12395468226547}, {"code": "void Sub::read_barometer(){\n\t// read barometer\n  sensor_baro_s baro_data;\n  if (baro_sub.update(&baro_data)) {\n    // update barometer calibration\n    if (baro_data.altitude_ellipsoid > 0.0f) {\n      baro_cal.update(baro_data.altitude_ellipsoid);\n    }\n    // update sensor health status\n    if (depth_sub.updated()) {\n      if (baro_data.altitude_ellipsoid < 0.0f) {\n        sensor_health.set_health_status(SENSOR_HEALTH_STATUS_DEAD, SENSOR_TYPE_BARO);\n      } else {\n        sensor_health.set_health_status(SENSOR_HEALTH_STATUS_OK, SENSOR_TYPE_BARO);\n      }\n    }\n  }\n}", "CodeBleu_score": 46.19058487895301}, {"code": "void Sub::read_barometer(){\n\tfloat pressure = barometer.readPressure();\n  float temperature = barometer.readTemperature();\n\n  if (pressure > 0) {\n    baro_calibration.update(pressure, temperature);\n    if (depth_sensor != NULL) {\n      depth_sensor->set_health(baro_calibration.get_health());\n    }\n  }\n}", "CodeBleu_score": 46.31663434950145}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}, {"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}, {"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we don't require GPS then we pass\n    if (!check_enabled(ARMING_CHECK_GPS)) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!rover.ahrs.initialised()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not initialised\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (rover.ahrs.get_ekf_status().failsafe) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position is valid\n    if (!rover.ahrs.get_position().is_valid()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"position not valid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 58.27025030603819}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we don't need position or velocity, skip the checks\n    if (!check_enabled(ARMING_CHECK_GPS)) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.initialised()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ahrs.get_ekf_status().failsafe) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.get_position().flags.position_valid) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"GPS position not valid\");\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 56.52218958548798}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we are not using GPS, return true\n    if (!check_enabled(ARMING_CHECK_GPS)) {\n        return true;\n    }\n\n    // check if AHRS is ready\n    if (!ahrs.initialised()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"Compass not initialised\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (g.ekf_action == 2) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!gps.status().status) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"GPS not available\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 38.43856404495822}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// if we are already armed then ignore this request\n    if (armed) {\n        return true;\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks && !arm_checks(method)) {\n        return false;\n    }\n\n    // record the time that we were armed\n    armed_time_ms = millis();\n\n    // set arming_failed event\n    armed = true;\n\n    // set the home location\n    rover.set_home_to_current_location();\n\n    // initialise simple mode heading\n    rover.simple_mode.init_heading();\n\n    // record the home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.record_home_heading();\n    }\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    if (report_arming_failure) {\n        AP_Notify::events.arming_disarming = 1;\n    } else {\n        AP_Notify::events.arming_disarming = 0;\n    }\n\n    return true;\n}", "CodeBleu_score": 56.37783488899084}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks && !arm_checks(method)) {\n        return false;\n    }\n    if (!armed) {\n        if (rover.g2.sailboat.sail_enabled()) {\n            // record home heading for sail vehicles\n            rover.sail_home_heading = rover.ahrs.yaw_sensor;\n        }\n        if (rover.g2.simple_mode.get_mode() == SIMPLE_MODE_STEERING) {\n            // initialise simple mode heading\n            rover.simple_mode_heading = rover.ahrs.yaw_sensor;\n        }\n        if (rover.g2.sailboat.sail_enabled() && rover.g2.windvane.enabled()) {\n            // set windvane to home heading\n            rover.g2.windvane.set_heading(rover.sail_home_heading);\n        }\n        if (rover.g2.simple_mode.get_mode() == SIMPLE_MODE_STEERING) {\n            // set simple mode heading\n            rover.g2.simple_mode.set_heading(rover.simple_mode_heading);\n        }\n        if (rover.g2.sailboat.sail_enabled()) {\n            // set windvane to home heading\n            rover.g2.windvane.set_heading(rover.sail_home_heading);\n        }\n        if (rover.g2.simple_mode.get_mode() == SIMPLE_MODE_STEERING) {\n            // set simple mode heading\n            rover.g2.simple_mode.set_heading(rover.simple_mode_heading);\n        }\n    }\n    armed = true;\n    rover.failsafe.set_state(AP_Rover::failsafe_state_t::FS_ARMED);\n    rover.failsafe.set_enabled(true);\n    rover.failsafe.set_radio_armed(true);", "CodeBleu_score": 44.59713494708723}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// if we are already armed then ignore the arm command\n    if (armed) {\n        return true;\n    }\n\n    // perform arming checks\n    if (do_arming_checks && !arm_checks(method)) {\n        return false;\n    }\n\n    // arm the motors\n    if (!motors_arm(method)) {\n        return false;\n    }\n\n    // set the SmartRTL home location\n    rover.set_smartrtl_home();\n\n    // initialise the simple mode heading\n    rover.init_simple_mode_heading();\n\n    // record the home heading for sail vehicles\n    rover.g2.sailboat.record_home_heading();\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arming_disarming_message(true);\n\n    return true;\n}", "CodeBleu_score": 51.06391173907806}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}, {"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}, {"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}, {"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}, {"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t// Initialize the serial communication\n    soundSerial.begin(9600);\n    soundSerial.clear();\n\n    // Initialize the sound module\n    myMP3.begin(soundSerial);\n\n    // Retrieve the number of sound files on the SD card\n    this->anzSoundfiles = myMP3.getTotalTrackNum();\n\n    // Check if there are sound files available\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n\n    // Return true if there are sound files available\n    return this->sound_available;\n}", "CodeBleu_score": 57.38162266266915}, {"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n    soundSerial.clear();\n\n    myMP3.begin(soundSerial);\n    myMP3.volume(20);\n    this->anzSoundfiles = myMP3.getTotalFiles();\n    this->sound_available = this->anzSoundfiles > 0;\n\n    return this->sound_available;\n}", "CodeBleu_score": 57.18085641923081}, {"code": "bool MP3Sound::begin(){\n\t// Setup serial communication\n    soundSerial.begin(9600);\n    soundSerial.setTimeout(100);\n    delay(50);\n\n    // Clear buffer\n    while (soundSerial.available()) {\n        soundSerial.read();\n    }\n\n    // Initialize sound module\n    myMP3.begin(soundSerial);\n    myMP3.volume(20);\n\n    // Get number of sound files available\n    this->anzSoundfiles = myMP3.readFileCounts();\n\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n\n    return this->sound_available;\n}", "CodeBleu_score": 62.02750358385971}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif ((active_sounds.size() == 0) || playing) return active_sounds.size();\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    playing = true;\n    myMP3.play(soundNr);\n    return active_sounds.size();\n}", "CodeBleu_score": 53.854572773943474}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || playing) {\n        return active_sounds.size();\n    }\n\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    playSoundAdHoc(soundNr);\n\n    return active_sounds.size();\n}", "CodeBleu_score": 47.03842566077473}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0 || playing) return active_sounds.size();\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    playing = true;\n    return active_sounds.size();\n}", "CodeBleu_score": 53.51282271594735}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int size = request_read_int32(r);\n      char *filename = request_read_string(r);\n      image_cleanup(c->image);\n      c->image = image_new();\n      image_setup_memory_mapped_file(c->image, filename, size);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 59.612819979992}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n#ifdef _WIN32\n      HANDLE file_handle = request_read_uint64(r);\n      c->file_handle = file_handle;\n      if (c->file_handle != NULL) {\n        c->file_size = request_read_uint64(r);\n        c->data = MapViewOfFile(c->file_handle, FILE_MAP_ALL_ACCESS, 0, 0, c->file_size);\n      }\n#else\n      int file_descriptor = request_read_int32(r);\n      c->file_descriptor = file_descriptor;\n      if (c->file_descriptor != -1) {\n        c->file_size = request_read_uint64(r);\n        c->data = mmap(0, c->file_size, PROT_READ | PROT_WRITE, MAP_SHARED, c->file_descriptor, 0);\n      }\n#endif\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 49.17593497834594}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {", "CodeBleu_score": 19.32335814026473}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock_step();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 68.42751015239642}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int result = -1;\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    result = ac->height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 77.33744667741847}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock_step();\n  int height = -1;\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 68.18028133501652}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.840755812614276}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.840755812614276}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.840755812614276}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dmsString);\n  free(dmsString);\n  return result;\n}", "CodeBleu_score": 41.67691198831675}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.11883455436265}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = string(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 44.61236026404989}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n\n    dVector3 v;\n    dGeomBoxGetRelPointPos(g, x, y, z, v);\n\n    const dReal *const s = ((dxBox*) g)->side;\n    dReal min_distance = dInfinity;\n    dVector3 min_normal;\n    dVector3 n;\n\n    // Check for proximity to each axis\n    if (dFabs(v[0]) < min_distance) {\n        min_distance = dFabs(v[0]);\n        dSetZero(min_normal, 3);\n        min_normal[0] = (v[0] > 0) ? 1 : -1;\n    }\n\n    if (dFabs(v[1]) < min_distance) {\n        min_distance = dFabs(v[1]);\n        dSetZero(min_normal, 3);\n        min_normal[1] = (v[1] > 0) ? 1 : -1;\n    }\n\n    if (dFabs(v[2]) < min_distance) {\n        min_distance = dFabs(v[2]);\n        dSetZero(min_normal, 3);\n        min_normal[2] = (v[2] > 0) ? 1 : -1;\n    }\n\n    // Check for proximity to each face\n    if (dFabs(v[0]) < min_distance) {\n        min_distance = dFabs(v[0]);\n        dSetZero(min_normal, 3);\n        min_normal[0] = (v[0] > 0) ? 1 : -1;\n        min_normal[1] = 0;\n        min_normal[2] = 0;\n    }\n\n    if (dFabs(v[1]) < min_distance) {\n        min_distance = dFabs(v[1]);\n        dSetZero(min_normal, 3);\n        min_normal[0] = 0;\n        min_normal[1] = (v[1] >", "CodeBleu_score": 31.45057106442578}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n\n    dxBox *box = (dxBox*) g;\n    dVector3 p, v;\n    dGeomBoxPointDepth(g, x, y, z, p);\n    dGeomBoxGetQuickNormal(g, p[0], p[1], p[2], v);\n    plane[0] = v[0];\n    plane[1] = v[1];\n    plane[2] = v[2];\n    plane[3] = -dDOT(v, p);\n}", "CodeBleu_score": 19.45411627262353}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n\n  dxBox* const b = (dxBox*) g;\n  const dReal* const s = b->side;\n\n  // Calculate the relative position of the point to the box center\n  dVector3 diff;\n  diff[0] = x - b->final_posr->pos[0];\n  diff[1] = y - b->final_posr->pos[1];\n  diff[2] = z - b->final_posr->pos[2];\n\n  // Check each axis for proximity to the box's surface\n  dReal dist = dInfinity;\n  dVector3 normal;\n  normal[0] = 0;\n  normal[1] = 0;\n  normal[2] = 0;\n  if (dFabs(diff[0]) <= s[0]) {\n    dist = dFabs(diff[0]);\n    normal[0] = (diff[0] > 0) ? 1 : -1;\n  }\n  if (dFabs(diff[1]) <= s[1]) {\n    if (dFabs(diff[1]) < dist) {\n      dist = dFabs(diff[1]);\n      normal[0] = 0;\n      normal[1] = (diff[1] > 0) ? 1 : -1;\n    }\n  }\n  if (dFabs(diff[2]) <= s[2]) {\n    if (dFabs(diff[2]) < dist) {\n      dist = dFabs(diff[2]);\n      normal[0] = 0;\n      normal[1] = 0;\n      normal[2] = (diff[2] > 0) ? 1 : -1;\n    }\n  }\n\n  // Set the plane's normal and distance based on the closest surface\n  plane[0] = normal[0];\n  plane[1] = normal[1];\n  plane[2] = normal[2];\n  plane[3] = -dist;\n}", "CodeBleu_score": 39.36067642768349}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\tNodeStatus status = StatefulActionNode::onStart();\n    if (status != NodeStatus::RUNNING) {\n        return status;\n    }\n\n    double duration = 0;\n    if (!getInput<double>(\"duration\", duration)) {\n        return NodeStatus::SUCCESS;\n    }\n\n    if (duration <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n    timer_waiting_ = true;\n    timer_.expires_from_now(std::chrono::milliseconds(static_cast<int>(duration)));\n    timer_.async_wait([this](const boost::system::error_code& ec) {\n        if (ec) {\n            timer_waiting_ = false;\n            return;\n        }\n\n        setStatus(NodeStatus::SUCCESS);\n    });\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 49.258708539171415}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds from the input.\n  if (!getInput<int>(\"ms\", sleep_ms_)) {\n    // If the input is missing or non-positive, return SUCCESS.\n    return NodeStatus::SUCCESS;\n  }\n  // If the duration is positive, set the node status to RUNNING, start a timer,\n  // and set a callback to emit a wake-up signal when the timer expires.\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_.expires_from_now(std::chrono::milliseconds(sleep_ms_));\n  timer_.async_wait([this](const boost::system::error_code& error) {\n    if (error) {\n      // If the timer is aborted, ensure the timer_waiting_ flag is reset.\n      timer_waiting_ = false;\n    } else {\n      // Otherwise, emit a wake-up signal.\n      emitWakeUpSignal();\n    }\n  });\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.1381506752416}, {"code": "NodeStatus SleepNode::onStart(){\n\tint duration_ms = getInput<int>(\"msec\");\n  if (!duration_ms || duration_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n\n  // Setup a callback to be called when the timer expires\n  timer_.expires_from_now(std::chrono::milliseconds(duration_ms));\n  timer_.async_wait(\n      [this](const boost::system::error_code& error) {\n        if (error) {\n          // If the timer was aborted, ensure the flag is reset\n          timer_waiting_ = false;\n          return;\n        }\n\n        // If the timer was not aborted, emit the wake-up signal\n        setStatus(NodeStatus::SUCCESS);\n        timer_waiting_ = false;\n      });\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 57.21040046137923}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\tconst auto* entry = getInput<Blackboard::Ptr>(\"blackboard\")->get<Blackboard::Ptr>(\"blackboard\")->get<uint64_t>(entry_key_);\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (entry->seq != last_seq_) {\n        last_seq_ = entry->seq;\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.52440897420787}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tconst auto& entry = getInput<Blackboard::Ptr>(\"entry\");\n  if (!entry) {\n    throw RuntimeError(\"missing required input [entry]: \", getInputPortName(\"entry\"));\n  }\n\n  Blackboard::Key key;\n  if (isBlackboardPointer(entry_key_, &key)) {\n    auto entry_ptr = entry->get<Blackboard::Ptr>(key);\n    if (!entry_ptr) {\n      throw RuntimeError(\"invalid entry: \", entry_key_);\n    }\n    return tick_impl(*entry_ptr);\n  }\n  return tick_impl(*entry);\n}", "CodeBleu_score": 38.64882387203522}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tconst auto entry = getInput<Blackboard::Ptr>(\"entry\");\n  const auto entry_key = entry_key_.c_str();\n  const auto entry_value = entry->get<unsigned int>(entry_key);\n  if (!entry_value) {\n    return NodeStatus::FAILURE;\n  }\n  if (*entry_value != sequence_id_) {\n    sequence_id_ = *entry_value;\n    return NodeStatus::SUCCESS;\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 50.833610209255895}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n    return std::max(static_cast<int>(children_nodes_.size()) + success_threshold_, 0);\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 55.882561909936925}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n    return std::max(static_cast<size_t>(1), children_nodes_.size() + success_threshold_);\n  }\n  return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 56.99152679453384}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n    return std::max(static_cast<int>(children_nodes_.size()) + success_threshold_, 0);\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 55.882561909936925}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tconst NodeStatus prev_status = status();\n    if (prev_status == NodeStatus::IDLE) {\n        halt_requested_.store(false);\n        setStatus(NodeStatus::RUNNING);\n        // Run tick function in a new thread\n        std::thread thread(&ThreadedAction::tickThread, this);\n        thread.detach();\n    }\n    if (prev_status == NodeStatus::RUNNING) {\n        if (halt_requested_.load()) {\n            setStatus(NodeStatus::IDLE);\n        }\n    }\n    if (exception_ptr_) {\n        std::rethrow_exception(exception_ptr_);\n    }\n    return status();\n}", "CodeBleu_score": 39.73659762158557}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tconst NodeStatus prev_status = status();\n  if (prev_status == NodeStatus::IDLE) {\n    halt_requested_.store(false);\n    setStatus(NodeStatus::RUNNING);\n    std::thread t([this]() {\n      try {\n        NodeStatus status = tick();\n        if (status != NodeStatus::RUNNING) {\n          setStatus(status);\n        }\n      } catch (std::exception& e) {\n        std::cerr << \"Caught exception in threaded node: \" << e.what() << std::endl;\n        setStatus(NodeStatus::IDLE);\n      } catch (...) {\n        std::cerr << \"Caught unknown exception in threaded node\" << std::endl;\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n    t.detach();\n  }\n  return prev_status;\n}", "CodeBleu_score": 46.46992222385368}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    std::thread thread([this] {\n      try {\n        NodeStatus status = tick();\n        if (!halt_requested_.load()) {\n          setStatus(status);\n        }\n      } catch (std::exception &exc) {\n        std::string str = std::string(\"Exception caught in ThreadedAction: \") + exc.what();\n        std::cerr << str << std::endl;\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n    thread.detach();\n  }\n  rethrow();\n  return status();\n}", "CodeBleu_score": 42.869682700928855}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif (!root_node) {\n    throw LogicError(\"The provided root_node is nullptr\");\n  }\n\n  auto print_tree = [&](const TreeNode* node, int depth) {\n    const std::string indent = std::string(depth * 2, ' ');\n    stream << indent << node->name() << '\n';\n\n    if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n      for (const auto& child : control->children()) {\n        print_tree(child, depth + 1);\n      }\n    } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n      if (decorator->child()) {\n        print_tree(decorator->child(), depth + 1);\n      }\n    }\n  };\n\n  stream << \"------------------------------------------------------------------------\n\";\n  print_tree(root_node, 0);\n  stream << \"------------------------------------------------------------------------\n\";\n}", "CodeBleu_score": 50.82838939632346}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tstream << \"------------------------------------------------------------------------\" << std::endl;\n  applyRecursiveVisitor(root_node, [&](const TreeNode* node) {\n    const auto depth = node->depth();\n    for (int i = 0; i < depth; ++i) {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n  });\n  stream << \"------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 33.85172573489966}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif(!root_node)\n  {\n    throw LogicError(\"The root_node is nullptr\");\n  }\n\n  auto print_node = [&stream](const TreeNode* node, size_t depth)\n  {\n    if(!node)\n    {\n      throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n    }\n\n    stream << std::string(depth*2, ' ') << node->name() << \"\n\";\n\n    if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n    {\n      for(const auto& child : control->children())\n      {\n        print_node(static_cast<const TreeNode*>(child), depth+1);\n      }\n    }\n    else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n    {\n      print_node(decorator->child(), depth+1);\n    }\n  };\n\n  stream << \"-------------------------------------------------------------------------------------------------------------------------------------------------------\n\";\n  print_node(root_node, 0);\n  stream << \"-------------------------------------------------------------------------------------------------------------------------------------------------------\n\";\n}", "CodeBleu_score": 51.50485616157374}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n        throw LogicError(\"Cannot apply visitor to null node\");\n    }\n    visitor(node);\n    if (node->type() == ControlNode::Type) {\n        const auto* control_node = static_cast<const ControlNode*>(node);\n        for (const auto& child : control_node->children()) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    } else if (node->type() == DecoratorNode::Type) {\n        const auto* decorator_node = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child(), visitor);\n    }\n}", "CodeBleu_score": 60.714047921342804}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (node == nullptr) {\n        throw LogicError(\"nullptr passed to applyRecursiveVisitor\");\n    }\n    visitor(node);\n    if (node->type() == NodeType::CONTROL) {\n        for (const auto& child : node->children()) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    } else if (node->type() == NodeType::DECORATOR) {\n        applyRecursiveVisitor(node->child(), visitor);\n    }\n}", "CodeBleu_score": 47.97898104762236}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control_node->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator_node->child(), visitor);\n  }\n}", "CodeBleu_score": 63.865970028610384}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.find(manifest.registration_ID) != _p->builders.end()) {\n    throw BehaviorTreeException(\"There is already a Builder registered with ID [\" +\n                                manifest.registration_ID + \"]\");\n  }\n  _p->builders[manifest.registration_ID] = builder;\n  _p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 53.496366935822834}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.count(manifest.registration_ID) != 0) {\n    throw BehaviorTreeException(\"There is already a Builder with ID [\" +\n                                manifest.registration_ID + \"]\");\n  }\n  _p->builders[manifest.registration_ID] = builder;\n  _p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 48.98937802769397}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.count(manifest.registration_ID) != 0) {\n    throw BehaviorTreeException(\"There is already a NodeBuilder registered \"\n                                \"with ID: \" +\n                                manifest.registration_ID);\n  }\n  _p->builders[manifest.registration_ID] = builder;\n  _p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 47.74791563172034}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 94.95952810948299}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 94.95952810948299}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 94.95952810948299}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(mutex_);\n\n  if (_handle) {\n    throw RuntimeError(\"SharedLibrary::load: a library is already loaded\");\n  }\n\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n  if (!_handle) {\n    throw RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n  }\n\n  _path = path;\n}", "CodeBleu_score": 55.96689095679257}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(_mutex);\n  if (_handle != nullptr) {\n    throw RuntimeError(\"SharedLibrary::load: a library is already loaded\");\n  }\n\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (_handle == nullptr) {\n    throw RuntimeError(\"SharedLibrary::load: unable to load library: \" + std::string(dlerror()));\n  }\n  _path = path;\n}", "CodeBleu_score": 56.31161968397519}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(mutex_);\n  if (_handle) {\n    throw RuntimeError(\"SharedLibrary::load: a library is already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    throw RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n  }\n  _path = path;\n}", "CodeBleu_score": 55.96689095679257}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//the cost of the line\n  double line_cost = 0.0;\n\n  //we want to iterate from the point with the lowest x value to the highest\n  //so we'll order our points accordingly\n  int x, y, dx, dy;\n  if(x0 < x1){\n    x = x0;\n    y = y0;\n    dx = x1 - x0;\n  }\n  else{\n    x = x1;\n    y = y1;\n    dx = x0 - x1;\n  }\n\n  //we also want to iterate from the point with the lowest y value to the highest\n  //so we'll order our points accordingly\n  if(y0 < y1){\n    y = y0;\n    dy = y1 - y0;\n  }\n  else{\n    y = y1;\n    dy = y0 - y1;\n  }\n\n  //now we can iterate over each cell in our line and add up the cost\n  LineIterator line(x, y, dx, dy);\n  for(; !line.isPastEnd(); ++line){\n    unsigned char point_cost = costmap_.getCost(line.getX(), line.getY());\n    if(point_cost == NO_INFORMATION)\n      return -2.0;\n    if(point_cost == LETHAL_OBSTACLE || point_cost == INSCRIBED_INFLATED_OBSTACLE)\n      return -1.0;\n    line_cost = std::max(line_cost, point_cost);\n  }\n  return line_cost;\n}", "CodeBleu_score": 58.04984798409279}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//the cost of the line\n  double line_cost = 0.0;\n\n  //the iterator that will be used to iterate through the line\n  LineIterator line(x0, y0, x1, y1);\n\n  //iterate through the line and calculate the line cost\n  for(; !line.isPastEnd(); ++line) {\n    //get the cost of the current point\n    unsigned char cost = costmap_.getCost(line.getX(), line.getY());\n\n    //if the point is an obstacle, return -1 immediately\n    if(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n      return -1.0;\n\n    //if the point is in an unknown area, return -2 immediately\n    if(cost == NO_INFORMATION)\n      return -2.0;\n\n    //otherwise, update the line cost with the current point cost\n    line_cost = std::max(line_cost, cost);\n  }\n\n  //return the line cost\n  return line_cost;\n}", "CodeBleu_score": 60.95270043327774}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0.0;\n  LineIterator line(x0, y0, x1, y1);\n  for(; !line.done(); ++line) {\n    unsigned char cost = costmap_.getCost(line.x, line.y);\n    if(cost == NO_INFORMATION)\n      return -2.0;\n    if(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n      return -1.0;\n    line_cost = std::max(line_cost, cost);\n  }\n  return line_cost;\n}", "CodeBleu_score": 59.963364264863706}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())  {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Copy the plan into a Path message and publish it\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 86.51787997649481}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (!path.empty()) {\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = path[0].header.frame_id;\n    path_msg.header.stamp = path[0].header.stamp;\n    path_msg.poses = path;\n    pub.publish(path_msg);\n  }\n}", "CodeBleu_score": 45.7348478948186}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (!path.empty()) {\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.header.frame_id = path[0].header.frame_id;\n\n    for (unsigned int i = 0; i < path.size(); i++) {\n      gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n  }\n}", "CodeBleu_score": 79.6237096732867}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_) {\n    if (restore_defaults) {\n      config = default_limits_;\n    }\n  } else {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  boost::mutex::scoped_lock lock(configuration_mutex_);\n  current_limits_ = config;\n}", "CodeBleu_score": 70.62217375570316}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_ && restore_defaults) {\n    ROS_INFO(\"Resetting Local Planner Limits to Defaults\");\n    config = default_limits_;\n  }\n\n  if (!setup_) {\n    ROS_INFO(\"Initializing Local Planner Limits\");\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  boost::mutex::scoped_lock l(configuration_mutex_);\n  current_limits_ = config;\n}", "CodeBleu_score": 70.13493213350466}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif(setup_) {\n\t\tif(restore_defaults) {\n\t\t\tconfig = default_limits_;\n\t\t}\n\t}\n\telse {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\tboost::mutex::scoped_lock l(configuration_mutex_);\n\tcurrent_limits_ = config;\n}", "CodeBleu_score": 67.13674538540428}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\n  //if the cell is an obstacle or has no information, we'll skip it\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION){\n    check_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\n    return false;\n  }\n\n  //otherwise, we'll calculate the new target distance\n  double new_dist = current_cell->target_dist + 1.0;\n\n  //if the new distance is better than the current target distance, we'll update it\n  if(new_dist < check_cell->target_dist){\n    check_cell->target_dist = new_dist;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 62.575536725605986}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\n  //if the cell is an obstacle, we'll set the target distance to the maximum cost\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\n    return false;\n  }\n\n  //otherwise, we'll calculate the target distance and update the cell's target distance if it's smaller\n  unsigned int new_dist = current_cell->target_dist + 1;\n  if(new_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_dist;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 63.49556453383196}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//check the cost of the current cell\n    unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\n    //if the current cell is an obstacle or has no information, return false\n    if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n        current_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\n        return false;\n    }\n\n    //calculate the new target distance\n    double new_dist = current_cell->target_dist + 1;\n\n    //if the new distance is shorter than the current target distance, update the target distance\n    if (new_dist < check_cell->target_dist)\n        check_cell->target_dist = new_dist;\n\n    return true;\n}", "CodeBleu_score": 63.57730182980825}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scaling_factor = 1.0;\n  double scaled_cost = 0.0;\n  double max_cost = 0.0;\n\n  // TODO: move this to prepare if possible\n  double max_trans_vel = 0.5;\n  double max_scaling_factor = 10.0;\n  double scaling_speed = 1.0;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"The footprint specification is empty. Please specify the footprint of the robot.\");\n    return -9;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = world_model_->footprintCost(traj.getPoint(i).getX(), traj.getPoint(i).getY(),\n                                                        traj.getPoint(i).getTheta(), footprint_spec_);\n\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    if (i == 0) {\n      scaling_factor = 1.0;\n    } else {\n      double dist = traj.getPoint(i).distance(traj.getPoint(i - 1));\n      double dist_max = max_trans_vel / scaling_speed;\n      if (dist > dist_max) {\n        scaling_factor = max_scaling_factor;\n      } else {\n        scaling_factor = max_scaling_factor * (1 - dist / dist_max);\n      }\n    }\n\n    scaled_cost = scaling_factor * footprint_cost;\n    if (sum_scores_) {\n      cost += scaled_cost;\n    } else {\n      if (scaled_cost > max_cost) {\n        max_cost = scaled_cost;\n      }\n    }\n  }\n\n  return sum_scores_ ? cost : max_cost;\n}", "CodeBleu_score": 49.83446480351332}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scaling_factor = 1.0;\n  double max_cost = 0.0;\n  double max_scaling_factor = 1.0;\n  double max_trans_vel = 0.0;\n\n  // TODO: move this to prepare if possible\n  max_trans_vel = max_trans_vel_;\n  max_scaling_factor = max_scaling_factor_;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified!\");\n    return -9;\n  }\n\n  for (int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = world_model_->footprintCost(traj.getPoint(i).x, traj.getPoint(i).y, traj.getPoint(i).th, footprint_spec_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    double trans_vel = traj.getVelocity(i);\n    if (trans_vel > max_trans_vel) {\n      trans_vel = max_trans_vel;\n    }\n    scaling_factor = max_scaling_factor - (max_scaling_factor - 1.0) * (trans_vel / max_trans_vel);\n    cost += scaling_factor * footprint_cost;\n    max_cost = std::max(max_cost, scaling_factor * footprint_cost);\n    max_scaling_factor = std::max(max_scaling_factor, scaling_factor);\n  }\n\n  if (sum_scores_) {\n    return cost;\n  } else {\n    return max_cost;\n  }\n}", "CodeBleu_score": 55.62520951831088}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scaling_factor = 1.0;\n  double max_cost = 0.0;\n  double max_scaling_factor = 0.0;\n  double max_trans_vel = 0.0;\n  double max_rot_vel = 0.0;\n  double trans_vel = 0.0;\n  double rot_vel = 0.0;\n  double max_trans_acc = 0.0;\n  double max_rot_acc = 0.0;\n  double trans_acc = 0.0;\n  double rot_acc = 0.0;\n\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (traj.getCost() < 0.0) {\n    return traj.getCost();\n  }\n  cost = traj.getCost();\n  scaling_factor = traj.getScalingFactor();\n  max_trans_vel = traj.getMaxTransVel();\n  max_rot_vel = traj.getMaxRotVel();\n  trans_vel = traj.getTransVel();\n  rot_vel = traj.getRotVel();\n  max_trans_acc = traj.getMaxTransAcc();\n  max_rot_acc = traj.getMaxRotAcc();\n  trans_acc = traj.getTransAcc();\n  rot_acc = traj.getRotAcc();\n\n  // if the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction: footprint specification is empty\");\n    return -9.0;\n  }\n\n  // for each point in the trajectory, calculate the footprint cost\n  for (std::size_t i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = calculateFootprintCost(traj.getPoint(i));\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += scaling_", "CodeBleu_score": 45.41499607775762}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// check if the footprint is legal\n  // get the cell cost at a given position\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  // check if the footprint is legal\n  if (!world_model->footprintCost(x, y, th, footprint_spec, scale, costmap->getCost(mx, my))) {\n    return -6.0;\n  }\n  // get the footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec, scale);\n  // return the maximum of the two costs\n  return std::max(footprint_cost, (double) costmap->getCost(mx, my));\n}", "CodeBleu_score": 43.8475394060359}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\tdouble footprint_cost = 0.0;\n  std::vector<geometry_msgs::Point> oriented_footprint;\n  if (!scaleFootprint(x, y, th, scale, footprint_spec, oriented_footprint)) {\n    return -6.0;\n  }\n\n  //check if the footprint is legal\n  if (!world_model->footprintCost(x, y, th, oriented_footprint, footprint_cost)) {\n    return -7.0;\n  }\n\n  //check if the footprint is legal\n  unsigned char cost = costmap->getCost(x, y);\n  if (cost == costmap_2d::NO_INFORMATION) {\n    ROS_WARN_THROTTLE(1.0, \"Robot footprint is off the map.\");\n    return -7.0;\n  }\n\n  return std::max(footprint_cost, cost);\n}", "CodeBleu_score": 43.83714357368641}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t//we need to scale the footprint based on the scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = scale * footprint_spec[i].x;\n    pt.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(pt);\n  }\n\n  //we need to rotate the footprint based on the robot's orientation\n  std::vector<geometry_msgs::Point> oriented_footprint;\n  for (unsigned int i = 0; i < scaled_footprint.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = scaled_footprint[i].x * cos(th) - scaled_footprint[i].y * sin(th);\n    pt.y = scaled_footprint[i].x * sin(th) + scaled_footprint[i].y * cos(th);\n    oriented_footprint.push_back(pt);\n  }\n\n  //now we need to shift the footprint based on the robot's position\n  std::vector<geometry_msgs::Point> translated_footprint;\n  for (unsigned int i = 0; i < oriented_footprint.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = oriented_footprint[i].x + x;\n    pt.y = oriented_footprint[i].y + y;\n    translated_footprint.push_back(pt);\n  }\n\n  //now we can compute the cost of the footprint\n  double footprint_cost = world_model->footprintCost(translated_footprint, costmap);\n  //if the footprint cost is negative, we'll return a negative cost\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  //we also need to check that the footprint is in bounds\n  double wx, wy;\n  costmap->world", "CodeBleu_score": 64.41999222680461}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t// If the new topic differs from the current one, update the topic\n  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    // If the new topic is not empty, subscribe to it\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribed to odom topic %s.\", odom_topic_.c_str());\n    }\n    // If the new topic is empty, shutdown the existing subscription\n    else {\n      odom_sub_.shutdown();\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Shutting down odom topic subscription.\");\n    }\n  }\n}", "CodeBleu_score": 47.21269348502477}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_ != odom_topic) {\n        odom_topic_ = odom_topic;\n        if (!odom_topic_.empty()) {\n            odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n        } else {\n            odom_sub_.shutdown();\n        }\n    }\n}", "CodeBleu_score": 50.28774717181518}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_ != odom_topic) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.34923301962302}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tdouble dist_sq = (pos - prev).squaredNorm();\n  double angle = std::acos(pos.normalized().dot(prev.normalized()));\n  if (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_ || angle > oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 37.082985104407406}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//check if we've moved far enough to reset the oscillation flags\n  double dist = (pos - prev).squaredNorm();\n  if(dist > oscillation_reset_dist_ * oscillation_reset_dist_){\n    //reset all flags\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  } else {\n    //check if we've rotated far enough to reset the oscillation flags\n    double angle = acos(pos.normalized().dot(prev.normalized()));\n    if(angle > oscillation_reset_angle_){\n      //reset all flags\n      forward_pos_only_ = false;\n      forward_neg_only_ = false;\n      strafe_pos_only_ = false;\n      strafe_neg_only_ = false;\n      rot_pos_only_ = false;\n      rot_neg_only_ = false;\n    }\n  }\n}", "CodeBleu_score": 35.85898376197307}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//calculate the squared distance\n  double dist_sq = (pos - prev).squaredNorm();\n\n  //calculate the angular difference\n  double angle = std::atan2(pos[1] - prev[1], pos[0] - prev[0]);\n  double angle_diff = std::fabs(angle - prev_angle_);\n  if (angle_diff > M_PI) {\n    angle_diff = 2 * M_PI - angle_diff;\n  }\n\n  //if we've moved far enough or rotated enough, reset the flags\n  if (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_ || angle_diff > oscillation_reset_angle_) {\n    //reset the flags\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n\n  //update the previous angle\n  prev_angle_ = angle;\n}", "CodeBleu_score": 53.01599625223903}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(!global_costmap_){\n    ROS_ERROR(\"The global_costmap_ pointer must be set before runBehavior is called\");\n    return;\n  }\n\n  if(!local_costmap_){\n    ROS_ERROR(\"The local_costmap_ pointer must be set before runBehavior is called\");\n    return;\n  }\n\n  ros::Time start = ros::Time::now();\n  if(invert_area_to_clear_){\n    ROS_WARN(\"Clearing the area inside the specified radius\");\n  }\n  else{\n    ROS_WARN(\"Clearing the area outside the specified radius\");\n  }\n\n  if(affected_maps_ == \"global\" || affected_maps_ == \"both\"){\n    global_costmap_->resetLayers(clearable_layers_, invert_area_to_clear_, reset_distance_);\n    if(force_updating_){\n      global_costmap_->updateMap(0,0,true);\n    }\n  }\n\n  if(affected_maps_ == \"local\" || affected_maps_ == \"both\"){\n    local_costmap_->resetLayers(clearable_layers_, invert_area_to_clear_, reset_distance_);\n    if(force_updating_){\n      local_costmap_->updateMap(0,0,true);\n    }\n  }\n\n  ros::Time end = ros::Time::now();\n  ros::Duration d(end.sec-start.sec, end.nsec-start.nsec);\n  ROS_INFO(\"Clearing the costmap took %.6f seconds\", d.toSec());\n}", "CodeBleu_score": 54.34130078272199}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(global_costmap_ == NULL){\n    ROS_ERROR(\"The pointer to the global costmap is NULL. Make sure that the global costmap has been properly initialized.\");\n    return;\n  }\n\n  if(local_costmap_ == NULL){\n    ROS_ERROR(\"The pointer to the local costmap is NULL. Make sure that the local costmap has been properly initialized.\");\n    return;\n  }\n\n  if(invert_area_to_clear_){\n    ROS_WARN(\"Clearing the costmap in the area surrounding the robot.\");\n  }\n  else{\n    ROS_WARN(\"Clearing the costmap in the area around the robot.\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n  if(affected_maps_ == \"global\" || affected_maps_ == \"both\"){\n    global_costmap_->resetLayers(clearable_layers_, invert_area_to_clear_, reset_distance_);\n  }\n  if(affected_maps_ == \"local\" || affected_maps_ == \"both\"){\n    local_costmap_->resetLayers(clearable_layers_, invert_area_to_clear_, reset_distance_);\n  }\n  ros::WallTime end = ros::WallTime::now();\n  ros::WallDuration elapsed = end - start;\n  ROS_INFO(\"Clearing the costmap took %f seconds.\", elapsed.toSec());\n\n  if(force_updating_){\n    start = ros::WallTime::now();\n    if(affected_maps_ == \"global\" || affected_maps_ == \"both\"){\n      global_costmap_->updateMap(0, 0, global_costmap_->getSizeInCellsX(), global_costmap_->getSizeInCellsY());\n    }\n    if(affected_maps_ == \"local\" || affected_maps_ == \"both\"){\n      local_costmap_->updateMap(0, 0, local_cost", "CodeBleu_score": 57.15932735451763}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\n    return;\n  }\n\n  if(!global_costmap_ || !local_costmap_){\n    ROS_ERROR(\\\"The costmaps passed to this object cannot be NULL\\\");\n    return;\n  }\n\n  if(invert_area_to_clear_){\n    ROS_WARN(\\\"This recovery behavior will clear all areas outside of the area to clear\\\");\n  }\n  else{\n    ROS_WARN(\\\"This recovery behavior will clear all areas inside of the area to clear\\\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n  clearCostmap(global_costmap_, affected_maps_ == \\\"global\\\" || affected_maps_ == \\\"both\\\");\n  ros::WallTime end = ros::WallTime::now();\n  ROS_INFO(\\\"It took %.4f seconds to clear the global costmap\\\", (end - start).toSec());\n\n  start = ros::WallTime::now();\n  clearCostmap(local_costmap_, affected_maps_ == \\\"local\\\" || affected_maps_ == \\\"both\\\");\n  end = ros::WallTime::now();\n  ROS_INFO(\\\"It took %.4f seconds to clear the local costmap\\\", (end - start).toSec());\n\n  if(force_updating_){\n    start = ros::WallTime::now();\n    global_costmap_->updateMap();\n    end = ros::WallTime::now();\n    ROS_INFO(\\\"It took %.4f seconds to update the global costmap\\\", (end - start).toSec());\n\n    start = ros::WallTime::now();\n    local_costmap_->updateMap();\n    end = ros::WallTime::now();\n    ROS_INFO(\\\"It took %.4f seconds to update the local costmap\\\", (end - start).toSec());\n  }\n}", "CodeBleu_score": 47.031753733005345}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tROS_DEBUG(\"New subscriber to costmap, publishing grid\");\n  nav_msgs::OccupancyGridPtr grid = prepareGrid();\n  pub.publish(grid);\n}", "CodeBleu_score": 53.65594626028044}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n    pub.publish(grid_);\n}", "CodeBleu_score": 96.31990523403505}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n    grid_.header.stamp = ros::Time::now();\n    grid_.header.frame_id = global_frame_;\n    grid_.info.resolution = costmap_->getResolution();\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    xn_ = costmap_->getSizeInCellsX();\n    yn_ = costmap_->getSizeInCellsY();\n    x0_ = costmap_->getSizeInCellsX();\n    y0_ = costmap_->getSizeInCellsY();\n\n    grid_.data.resize(xn_ * yn_);\n    for (unsigned int i = 0; i < xn_; i++) {\n        for (unsigned int j = 0; j < yn_; j++) {\n            grid_.data[i + j * xn_] = cost_translation_table_[costmap_->getCharMap()[i + j * x0_]];\n        }\n    }\n}", "CodeBleu_score": 60.02807074333328}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.frame_id = global_frame_;\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // compute the origin of the map\n  double origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin for later use\n  x0_ = origin_x / resolution;\n  y0_ = origin_y / resolution;\n\n  // resize the grid\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid\n  unsigned int span = grid_.info.width;\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.info.height; ++i) {\n    for (unsigned int j = 0; j < grid_.info.width; ++j) {\n      unsigned int index = i * span + j;\n      grid_.data[index] = cost_translation_table_[data[index]];\n    }\n  }\n}", "CodeBleu_score": 70.25159357675082}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tcostmap_->getSizeInCells(xn_, yn_);\n  if (x0_ != xn_ || y0_ != yn_ || grid_.data.size() != xn_ * yn_) {\n    grid_.header.frame_id = global_frame_;\n    grid_.info.resolution = costmap_->getResolution();\n    grid_.info.width = xn_;\n    grid_.info.height = yn_;\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n    x0_ = xn_;\n    y0_ = yn_;\n    grid_.data.resize(x0_ * y0_);\n  }\n\n  Costmap2D::mutex_t::scoped_lock lock(*(costmap_->getMutex()));\n  costmap_->getMapRegion(x0_, y0_, xn_, yn_, grid_.data.data(), x0_);\n}", "CodeBleu_score": 49.79493272486898}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}, {"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}, {"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n  double angle_diff = angles::shortest_angular_distance(start_angle, end_angle);\n\n  double increment = angle_diff / (end_index - start_index);\n\n  for (int i = start_index + 1; i < end_index; i++) {\n    double angle = start_angle + increment * (i - start_index);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 68.27098407635498}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n    double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n    double angle_increment = angles::shortest_angular_distance(start_angle, end_angle) / (end_index - start_index);\n\n    for (int i = start_index; i < end_index; i++) {\n        double angle = tf2::getYaw(path[i].pose.orientation) + (i - start_index + 1) * angle_increment;\n        set_angle(&path[i], angle);\n    }\n}", "CodeBleu_score": 60.42358720684224}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// calculate the yaw angle at the start and end indices\n    double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n    double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n    // determine the shortest angular distance between the start and end angles\n    double angle_change = angles::shortest_angular_distance(start_angle, end_angle);\n\n    // calculate the incremental change in angle for each pose\n    double incremental_angle = angle_change / (end_index - start_index);\n\n    // update the orientation of each pose in the specified range\n    for (int i = start_index + 1; i < end_index; ++i) {\n        double angle = tf2::getYaw(path[i - 1].pose.orientation) + incremental_angle;\n        set_angle(&path[i], angle);\n    }\n}", "CodeBleu_score": 64.74732824075218}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\treq.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n\n    bool success = makePlan(req.start, req.goal, resp.plan);\n\n    resp.plan_found = success;\n    return true;\n}", "CodeBleu_score": 62.08911419680353}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\treq.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    bool success = makePlan(req.start, req.goal, resp.plan);\n    resp.plan_found = success;\n    return true;\n}", "CodeBleu_score": 61.063469401570295}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\treq.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    resp.plan_found = makePlan(req.start, req.goal, resp.plan);\n    return true;\n}", "CodeBleu_score": 46.96629134516286}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 79.34674356464235}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    ros::NodeHandle private_nh(\"~\");\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 81.56848607549534}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    ros::NodeHandle private_nh(\"~\");\n    make_plan_service_ = private_nh.advertiseService(name + \"/make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe<PoseStamped>(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 75.61938498517442}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tvector<PoseStamped> path;\n\n  // Get the global pose of the robot\n  PoseStamped global_pose;\n  cmap_->getRobotPose(global_pose);\n\n  // Generate a path from the global pose to the goal pose\n  bool success = makePlan(global_pose, *goal, path);\n\n  // Publish the path\n  publishPlan(path);\n}", "CodeBleu_score": 68.35872393345169}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tvector<PoseStamped> path;\n    PoseStamped start;\n    tf2::fromMsg(cmap_->getRobotPose(), start.pose);\n    start.header.frame_id = \"map\";\n    bool success = makePlan(start, *goal, path);\n    resp.plan_found = success;\n    if (success) {\n        resp.path = path;\n    }\n}", "CodeBleu_score": 52.860416165530175}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tPoseStamped global_pose;\n    cmap_->getRobotPose(global_pose);\n    vector<PoseStamped> path;\n    bool success = makePlan(global_pose, *goal, path);\n    if (success) {\n        ROS_INFO(\"Got a plan!\");\n        ROS_INFO(\"Path size: %d\", (int)path.size());\n        ROS_INFO(\"Path:\n%s\", path[0].header.frame_id.c_str());\n        ROS_INFO(\"Path:\n%s\", path[0].pose.position.x);\n    } else {\n        ROS_INFO(\"Failed to get a plan!\");\n    }\n}", "CodeBleu_score": 62.71836530760353}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet set_param;\n    set_param.request.param_id = param_set.param_id;\n    set_param.request.value.real = param_set.value;\n\n    this->param_set_client_.call(set_param);\n}", "CodeBleu_score": 70.51125461198728}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_msg;\n    param_set_msg.request.param_id = param_set.param_id;\n    param_set_msg.request.value.real = param_set.param_value;\n    param_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 61.02043991398154}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet set_param;\n    set_param.request.param_id = param_set.param_id;\n    set_param.request.value.real = param_set.value;\n    this->param_set_client_.call(set_param);\n}", "CodeBleu_score": 70.51125461198728}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\tint server_fd, client_fd;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_addr_size;\n    int opt_val = 1;\n    int ret;\n    char buffer[BUFFER_SIZE];\n    int recv_len;\n    int send_len;\n    std::string str_buffer;\n    std::string str_send_buffer;\n    std::string str_send_buffer_1;\n    std::string str_send_buffer_2;\n    std::string str_send_buffer_3;\n    std::string str_send_buffer_4;\n    std::string str_send_buffer_5;\n    std::string str_send_buffer_6;\n    std::string str_send_buffer_7;\n    std::string str_send_buffer_8;\n    std::string str_send_buffer_9;\n    std::string str_send_buffer_10;\n    std::string str_send_buffer_11;\n    std::string str_send_buffer_12;\n    std::string str_send_buffer_13;\n    std::string str_send_buffer_14;\n    std::string str_send_buffer_15;\n    std::string str_send_buffer_16;\n    std::string str_send_buffer_17;\n    std::string str_send_buffer_18;\n    std::string str_send_buffer_19;\n    std::string str_send_buffer_20;\n    std::string str_send_buffer_21;\n    std::string str_send_buffer_22;\n    std::string str_send_buffer_23;\n    std::string str_send_buffer_24;\n    std::string str_send_buffer_25;\n    std::string str_send_buffer_26;\n    std::string str_send_buffer_27;\n    std::string str_send_buffer_28;\n    std::string str_send_buffer_29;\n    std::string str_send_buffer_30;", "CodeBleu_score": 7.122933135678119}, {"code": "void CommunicationBridge::serverFun(){\n\t// TCP\u670d\u52a1\u7aef\n    int server_fd;\n    int client_fd;\n    int ret;\n    int len;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len;\n    char buf[BUFFER_SIZE];\n    std::string msg_str;\n    std::string topic_name;\n    std::string topic_type;\n    int topic_id;\n    int topic_num;\n    int topic_type_size;\n    int topic_len;\n    int topic_data_len;\n    int topic_data_num;\n    int topic_data_type_size;\n    int topic_data_type;\n    int topic_data_type_id;\n    int topic_data_type_len;\n    int topic_data_type_num;\n    int topic_data_type_type_size;\n    int topic_data_type_type_id;\n    int topic_data_type_type_len;\n    int topic_data_type_type_num;\n    int topic_data_type_type_type_size;\n    int topic_data_type_type_type_id;\n    int topic_data_type_type_type_len;\n    int topic_data_type_type_type_num;\n    int topic_data_type_type_type_type_size;\n    int topic_data_type_type_type_type_id;\n    int topic_data_type_type_type_type_len;\n    int topic_data_type_type_type_type_num;\n    int topic_data_type_type_type_type_type_size;\n    int topic_data_type_type_type_type_type_id;\n    int topic_data_type_type_type_type_type_len;\n    int topic_data_type_type_type_type_type_num;\n    int topic_data_type_type_type_type_type_type_size;\n    int topic_data_type_type_type_type_type_type_id;\n    int topic_data_", "CodeBleu_score": 7.441118500818367}, {"code": "void CommunicationBridge::serverFun(){\n\t// TCP\u670d\u52a1\u7aef\n    std::cout << \"serverFun\" << std::endl;\n    // \u521d\u59cb\u5316socket\n    int sockfd, connfd;\n    struct sockaddr_in servaddr;\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    bzero(&servaddr, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(TCP_PORT);\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    int ret = bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr));\n    if (ret == -1) {\n        std::cout << \"bind error!\" << std::endl;\n        exit(1);\n    }\n    listen(sockfd, 5);\n\n    while (true) {\n        connfd = accept(sockfd, (struct sockaddr *)NULL, NULL);\n        if (connfd < 0) {\n            std::cout << \"accept error!\" << std::endl;\n            exit(1);\n        }\n        std::cout << \"accept a connection!\" << std::endl;\n        char buff[1024];\n        int n = recv(connfd, buff, 1024, 0);\n        if (n <= 0) {\n            std::cout << \"recv error!\" << std::endl;\n            close(connfd);\n            continue;\n        }\n        std::cout << \"recv a message!\" << std::endl;\n        buff[n] = '\\0';\n        std::cout << buff << std::endl;\n        // \u89e3\u6790\u6570\u636e\n        // std::string str = buff;\n        // std::cout << \"str: \" << str << std::endl;\n        // std::vector<std::string> vec;\n        // vec = split(str, \" \");\n        // std::cout << \"vec: \" << vec[0] << std::endl;\n        // if (vec[0] == \"1\") {\n        //     std::cout << \"vec[0]", "CodeBleu_score": 50.578176186703935}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tint drone_id = msg->drone_id;\n    // std::cout << \"drone_id: \" << drone_id << std::endl;\n    int num_traj = msg->num_traj;\n    // std::cout << \"num_traj: \" << num_traj << std::endl;\n    std::vector<std::vector<Eigen::Vector3d>> position_points;\n    std::vector<std::vector<double>> yaw_points;\n    std::vector<std::vector<double>> knots;\n    std::vector<std::vector<Eigen::Vector3d>> position_points_ex;\n    std::vector<std::vector<double>> yaw_points_ex;\n    std::vector<std::vector<double>> knots_ex;\n    std::vector<int> traj_id;\n    std::vector<int> traj_id_ex;\n    for (int i = 0; i < num_traj; i++) {\n        int traj_id_i = msg->traj_id[i];\n        traj_id.push_back(traj_id_i);\n        std::vector<Eigen::Vector3d> position_points_i;\n        std::vector<double> yaw_points_i;\n        std::vector<double> knots_i;\n        for (int j = 0; j < msg->trajs[i].position_points.size(); j++) {\n            Eigen::Vector3d position_point_ij(msg->trajs[i].position_points[j].x, msg->trajs[i].position_points[j].y, msg->trajs[i].position_points[j].z);\n            position_points_i.push_back(position_point_ij);\n            yaw_points_i.push_back(msg->trajs[i].yaw_points[j]);\n            knots_i.push_back(msg->trajs[i].knots[j]);\n        }\n        position_points.push_back(position_points_i);\n        yaw_points.push_back(yaw_points_", "CodeBleu_score": 42.64000297557459}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \"multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"msg->bsplines.size()\" << msg->bsplines.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].knots.size()\" << msg->bsplines[0].knots.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].position.size()\" << msg->bsplines[0].position.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].yaw.size()\" << msg->bsplines[0].yaw.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].knots[0]\" << msg->bsplines[0].knots[0] << std::endl;\n    // std::cout << \"msg->bsplines[0].position[0].x\" << msg->bsplines[0].position[0].x << std::endl;\n    // std::cout << \"msg->bsplines[0].yaw[0]\" << msg->bsplines[0].yaw[0] << std::endl;\n    // std::cout << \"msg->bsplines[1].knots.size()\" << msg->bsplines[1].knots.size() << std::endl;\n    // std::cout << \"msg->bsplines[1].position.size()\" << msg->bsplines[1].position.size() << std::endl;\n    // std::cout << \"msg->bsplines[1].yaw.size()\" << msg->bsplines[1].yaw.size() << std::endl;\n    // std::cout << \"msg->bsplines[1].knots[0]\" << msg->bsplines[1].knots[0] << std::endl;\n    // std::cout << \"msg->bsplines[1].position[0].x\" << msg->bsplines[1].position[0].x << std::endl;\n    // std::cout << \"msg->bsplines[1", "CodeBleu_score": 1.2533532611711897}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \"multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"drone_id_: \" << drone_id_ << std::endl;\n    // std::cout << \"msg->bsplines.size(): \" << msg->bsplines.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].knots.size(): \" << msg->bsplines[0].knots.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].position.size(): \" << msg->bsplines[0].position.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].yaw.size(): \" << msg->bsplines[0].yaw.size() << std::endl;\n    // std::cout << \"msg->bsplines[0].knots[0]: \" << msg->bsplines[0].knots[0] << std::endl;\n    // std::cout << \"msg->bsplines[0].position[0]: \" << msg->bsplines[0].position[0] << std::endl;\n    // std::cout << \"msg->bsplines[0].yaw[0]: \" << msg->bsplines[0].yaw[0] << std::endl;\n\n    // std::cout << \"msg->bsplines[1].knots.size(): \" << msg->bsplines[1].knots.size() << std::endl;\n    // std::cout << \"msg->bsplines[1].position.size(): \" << msg->bsplines[1].position.size() << std::endl;\n    // std::cout << \"msg->bsplines[1].yaw.size(): \" << msg->bsplines[1].yaw.size() << std::endl;\n    // std::cout << \"msg->bsplines[1].knots[0]: \" << msg->bsplines[1].knots[0] << std::endl;\n    // std::cout << \"msg->bsplines[1].position[0]: \"", "CodeBleu_score": 1.2533532797780256}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}, {"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}, {"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1;\n    return pos;\n}", "CodeBleu_score": 76.82254611363719}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1;\n    return pos;\n}", "CodeBleu_score": 76.82254611363719}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos_cam;\n    pos_cam(0) = (u-cx_)*depth/fx_;\n    pos_cam(1) = (v-cy_)*depth/fy_;\n    pos_cam(2) = depth;\n    pos_cam(3) = 1.0;\n    return pos_cam;\n}", "CodeBleu_score": 64.75393044129044}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 90.74899131089721}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 98.26143553100475}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 90.74899131089721}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// First, convert the coordinates to indices\n    start_idx = grid_map_->GetGridIndex(start_pt);\n    end_idx = grid_map_->GetGridIndex(end_pt);\n\n    // If either of the points are inside an obstacle, adjust them iteratively\n    if (grid_map_->GetGridValue(start_idx) > 0 || grid_map_->GetGridValue(end_idx) > 0) {\n        int iter = 0;\n        while (iter < 1000) {\n            iter++;\n            if (grid_map_->GetGridValue(start_idx) > 0) {\n                // If the start point is inside an obstacle, move it away from the end point\n                Vector3d new_start_pt = grid_map_->GetPositionFromIndex(start_idx);\n                Vector3d vec_to_end = end_pt - new_start_pt;\n                vec_to_end.normalize();\n                new_start_pt += vec_to_end * grid_map_->GetResolution();\n                start_idx = grid_map_->GetGridIndex(new_start_pt);\n            }\n            if (grid_map_->GetGridValue(end_idx) > 0) {\n                // If the end point is inside an obstacle, move it away from the start point\n                Vector3d new_end_pt = grid_map_->GetPositionFromIndex(end_idx);\n                Vector3d vec_to_start = start_pt - new_end_pt;\n                vec_to_start.normalize();\n                new_end_pt += vec_to_start * grid_map_->GetResolution();\n                end_idx = grid_map_->GetGridIndex(new_end_pt);\n            }\n\n            // If both points are now outside of obstacles, we're done\n            if (grid_map_->GetGridValue(start_idx) == 0 && grid_map_->GetGridValue(end_idx) == 0) {\n                break;\n            }\n        }\n\n        // If the iterative adjustment failed, return false\n        if (iter == 10", "CodeBleu_score": 34.7440673490049}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start and end points to grid indices\n    start_idx = grid_map_->GetGridIndex(start_pt);\n    end_idx = grid_map_->GetGridIndex(end_pt);\n\n    // If either point is inside an obstacle, adjust it\n    if (grid_map_->GetGridValue(start_idx) > 0 || grid_map_->GetGridValue(end_idx) > 0) {\n        // If the start point is inside an obstacle, adjust it\n        if (grid_map_->GetGridValue(start_idx) > 0) {\n            // Iteratively adjust the start point\n            Vector3d adjusted_start_pt = start_pt;\n            bool start_adjusted = false;\n            while (!start_adjusted) {\n                // Get the index of the adjusted start point\n                Vector3i adjusted_start_idx = grid_map_->GetGridIndex(adjusted_start_pt);\n\n                // If the adjusted start point is not in an obstacle, set the start point to the adjusted start point and break\n                if (grid_map_->GetGridValue(adjusted_start_idx) == 0) {\n                    start_pt = adjusted_start_pt;\n                    start_idx = adjusted_start_idx;\n                    start_adjusted = true;\n                    break;\n                }\n\n                // Otherwise, move the adjusted start point closer to the end point\n                Vector3d direction_to_end = end_pt - adjusted_start_pt;\n                direction_to_end.normalize();\n                adjusted_start_pt += direction_to_end;\n            }\n\n            // If the start point could not be adjusted, return false\n            if (!start_adjusted) {\n                return false;\n            }\n        }\n\n        // If the end point is inside an obstacle, adjust it\n        if (grid_map_->GetGridValue(end_idx) > 0) {\n            // Iteratively adjust the end point\n            Vector3d adjusted_end_pt = end_pt;\n            bool end_adjusted = false;\n            while", "CodeBleu_score": 37.598002527025976}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// First, convert the coordinates to indices.\n    start_idx = grid_map_->GetGridIndex(start_pt);\n    end_idx = grid_map_->GetGridIndex(end_pt);\n\n    // If either point is inside an obstacle, adjust it.\n    if (grid_map_->GetGridValue(start_idx) == 1 || grid_map_->GetGridValue(end_idx) == 1) {\n        // If the start point is inside an obstacle, adjust it.\n        if (grid_map_->GetGridValue(start_idx) == 1) {\n            // Get the direction to the end point.\n            Vector3d direction = (end_pt - start_pt).normalized();\n\n            // Iteratively adjust the start point by moving it away from the end point.\n            while (grid_map_->GetGridValue(start_idx) == 1) {\n                // Move the start point in the direction away from the end point.\n                start_pt += direction * grid_map_->GetResolution();\n\n                // Convert the new start point to an index.\n                start_idx = grid_map_->GetGridIndex(start_pt);\n            }\n        }\n\n        // If the end point is inside an obstacle, adjust it.\n        if (grid_map_->GetGridValue(end_idx) == 1) {\n            // Get the direction to the start point.\n            Vector3d direction = (start_pt - end_pt).normalized();\n\n            // Iteratively adjust the end point by moving it away from the start point.\n            while (grid_map_->GetGridValue(end_idx) == 1) {\n                // Move the end point in the direction away from the start point.\n                end_pt += direction * grid_map_->GetResolution();\n\n                // Convert the new end point to an index.\n                end_idx = grid_map_->GetGridIndex(end_pt);\n            }\n        }\n    }\n\n    // Return true if both points are not inside an obstacle.\n    if (grid_map_->GetGridValue(start_idx) != 1 && grid_map_->GetGridValue", "CodeBleu_score": 40.11366904546099}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->num_objs; i++) {\n        if (msg->obj_info[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n            is_detected = true;\n            loss_count = max_loss_count;\n            ellipse_det = msg->obj_info[i];\n            ellipse_det.sight_angle = msg->obj_info[i].sight_angle * PI / 180;\n            //printf_info(1, \"ellipse_det_cb: ellipse_det.sight_angle = %f\n\", ellipse_det.sight_angle);\n            break;\n        }\n    }\n    if (num_regain > VISION_THRES) {\n        num_regain = VISION_THRES;\n    }\n    if (num_lost > VISION_THRES) {\n        num_lost = VISION_THRES;\n    }\n    if (num_lost > 0) {\n        num_lost++;\n    }\n    if (num_regain > 0) {\n        num_regain++;\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n        num_lost = VISION_THRES;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n        num_regain = VISION_THRES;\n    }\n    if (is_detected) {\n        loss_count--;\n    } else {\n        loss_count++;\n    }\n    if (loss_count < 0) {\n        loss_count = 0;\n    }\n    if (loss_count > max_loss_count) {\n        loss_count = max_loss_count;\n    }\n}", "CodeBleu_score": 57.51891622030462}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tint num_detected = msg->num_objs;\n    bool is_detected_now = false;\n    for (int i = 0; i < num_detected; i++) {\n        if (msg->obj_info[i].obj_name == \"T\") {\n            is_detected_now = true;\n            break;\n        }\n    }\n    if (is_detected_now) {\n        num_regain++;\n        num_lost = 0;\n    } else {\n        num_lost++;\n        num_regain = 0;\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    if (is_detected) {\n        ellipse_det = msg->obj_info[0];\n        float temp = ellipse_det.sight_angle[0];\n        ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n        ellipse_det.sight_angle[1] = temp;\n    }\n}", "CodeBleu_score": 66.23599899677843}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t// \u68c0\u6d4b\u5230\u76ee\u6807\n    if (msg->detected) {\n        // \u68c0\u6d4b\u5230\u76ee\u6807\n        num_regain++;\n        num_lost = 0;\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n    } else {\n        // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n        num_regain = 0;\n        num_lost++;\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n    }\n\n    // \u68c0\u6d4b\u5230\u76ee\u6807\n    if (is_detected) {\n        // \u68c0\u6d4b\u5230\u76ee\u6807\n        // \u68c0\u6d4b\u5230\u76ee\u6807\n        if (msg->detected) {\n            // \u68c0\u6d4b\u5230\u76ee\u6807\n            // \u68c0\u6d4b\u5230\u76ee\u6807\n            ellipse_det = msg->detection_infos[0];\n            float temp = ellipse_det.sight_angle[0];\n            ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n            ellipse_det.sight_angle[1] = temp;\n            // \u68c0\u6d4b\u5230\u76ee\u6807\n            // \u68c0\u6d4b\u5230\u76ee\u6807\n            // \u68c0\u6d4b\u5230\u76ee\u6807\n        }\n        // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n        else {\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b\u5230\u76ee\u6807\n            // \u672a\u68c0\u6d4b", "CodeBleu_score": 56.98924497964111}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n    champ::Time current_time = rosTimeToChampTime(ros::Time::now());\n\n    // Get the current pose of the body\n    champ::Pose current_pose = kinematics_.update(current_time);\n\n    // Get the desired pose of the body\n    champ::Pose target_pose = body_controller_.update(current_time, current_pose, req_pose_);\n\n    // Set the target pose of the kinematics object\n    kinematics_.setTargetPose(target_pose);\n\n    // Get the target foot positions\n    std::vector<champ::Point> target_foot_positions = kinematics_.getTargetFootPositions();\n\n    // Get the current foot positions\n    std::vector<champ::Point> current_foot_positions = kinematics_.getFootPositions();\n\n    // Get the current joint positions\n    std::vector<double> current_joint_positions = kinematics_.getJointPositions();\n\n    // Get the current joint velocities\n    std::vector<double> current_joint_velocities = kinematics_.getJointVelocities();\n\n    // Get the target joint positions\n    std::vector<double> target_joint_positions = leg_controller_.update(current_time, current_foot_positions, target_foot_positions, current_joint_positions, current_joint_velocities);\n\n    // Publish foot contact information\n    if(publish_foot_contacts_) {\n        champ_msgs::ContactsStamped contacts;\n        contacts.header.stamp = ros::Time::now();\n        contacts.contacts.resize(4);\n        for(int i = 0; i < 4; i++) {\n            contacts.contacts[i] = leg_controller_.getContact(i);\n        }\n        foot_contacts_publisher_.publish(contacts);\n    }\n\n    // Publish joint states\n    if(publish_joint_states_) {\n        sensor_msgs::JointState joint_states;\n        joint_states.header.stamp = ros::Time::now();\n        joint_states.name = joint", "CodeBleu_score": 41.28694763921701}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // Get the current state of the robot\n    champ::RobotState robot_state = base_.getState();\n\n    // Get the current state of the body controller\n    champ::BodyController::State body_controller_state = body_controller_.getState();\n\n    // Get the current state of the leg controller\n    champ::LegController::State leg_controller_state = leg_controller_.getState();\n\n    // Get the current state of the kinematics\n    champ::Kinematics::State kinematics_state = kinematics_.getState();\n\n    // Get the current state of the gait\n    champ::Gait::State gait_state = gait_.getState();\n\n    // Get the current state of the joints\n    std::vector<double> joint_positions = robot_state.joint_positions;\n\n    // Get the current state of the joints\n    std::vector<double> joint_velocities = robot_state.joint_velocities;\n\n    // Get the current state of the joints\n    std::vector<double> joint_torques = robot_state.joint_torques;\n\n    // Get the current state of the joints\n    std::vector<double> joint_errors = robot_state.joint_errors;\n\n    // Get the current state of the joints\n    std::vector<double> joint_efforts = robot_state.joint_efforts;\n\n    // Get the current state of the joints\n    std::vector<double> joint_temperatures = robot_state.joint_temperatures;\n\n    // Get the current state of the joints\n    std::vector<bool> joint_status = robot_state.joint_status;\n\n    // Get the current state of the joints\n    std::vector<bool> joint_limits = robot_state.joint_limits;\n\n    // Get the current state of the joints\n    std::vector<double> joint_voltage = robot_state.joint_voltage;\n\n    // Get the current state of the joints\n    std::vector<double> joint_current =", "CodeBleu_score": 34.32077680654355}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get current time\n    const ros::Time time = ros::Time::now();\n    const champ::PhaseGenerator::Time champ_time = rosTimeToChampTime(time);\n\n    // Get current pose\n    champ::Pose pose;\n    kinematics_.getCurrentPose(pose);\n\n    // Get current joint positions\n    champ::Joints current_joints;\n    kinematics_.getCurrentJointPositions(current_joints);\n\n    // Get current joint velocities\n    champ::Joints current_velocities;\n    kinematics_.getCurrentJointVelocities(current_velocities);\n\n    // Get target joint positions\n    champ::Joints target_joints;\n    body_controller_.calculateTargetPose(req_pose_, pose, target_joints);\n\n    // Get target joint velocities\n    champ::Joints target_velocities;\n    body_controller_.calculateTargetVelocities(req_pose_, pose, target_velocities);\n\n    // Get target foot positions\n    champ::Legs target_feet;\n    body_controller_.calculateTargetFeet(req_pose_, pose, target_feet);\n\n    // Get joint commands\n    champ::Joints joint_commands;\n    leg_controller_.calculateJointCommands(target_joints, current_joints, target_velocities, current_velocities, target_feet, joint_commands);\n\n    // Publish joint commands\n    if(publish_joint_control_) {\n        trajectory_msgs::JointTrajectory joint_trajectory;\n        joint_trajectory.header.stamp = time;\n        joint_trajectory.joint_names = joint_names_;\n        trajectory_msgs::JointTrajectoryPoint point;\n        point.positions = joint_commands.position;\n        point.velocities = joint_commands.velocity;\n        point.accelerations.resize(joint_commands.position.size(), 0.0);\n        point.effort.resize(joint_commands.position.size(), 0.0);\n        point.time_from_", "CodeBleu_score": 42.79139277176897}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t# Create minimal joints message\n    minimal_joints = Joints()\n    minimal_joints.header.stamp = rospy.Time.now()\n    minimal_joints.header.frame_id = joints.header.frame_id\n    minimal_joints.position = joints.position[0:12]\n    self.joint_minimal_pub.publish(minimal_joints)\n\n    # Create joint trajectory message\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header.stamp = rospy.Time.now()\n    joint_trajectory.header.frame_id = joints.header.frame_id\n    joint_trajectory.joint_names = self.joint_names\n\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[0:12]\n    point.time_from_start = rospy.Duration.from_sec(0.5)\n    joint_trajectory.points.append(point)\n\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 57.14219777330979}, {"code": "def joints_cmd_callback(self, joints){\n\tmsg = Joints()\n    msg.name = self.joint_names\n    msg.position = joints.position[0:12]\n    self.joint_minimal_pub.publish(msg)\n\n    traj_msg = JointTrajectory()\n    traj_msg.joint_names = self.joint_names\n    traj_msg.header.stamp = rospy.Time.now()\n    traj_point = JointTrajectoryPoint()\n    traj_point.positions = joints.position[0:12]\n    traj_point.time_from_start = rospy.Duration(0.2)\n    traj_msg.points.append(traj_point)\n    self.joint_trajectory_pub.publish(traj_msg)\n}", "CodeBleu_score": 51.37911699177311}, {"code": "def joints_cmd_callback(self, joints){\n\t# Create a minimal joints message\n    msg_minimal = Joints()\n    msg_minimal.header = joints.header\n    msg_minimal.joints = joints.position[0:12]\n\n    # Publish the minimal joints message\n    self.joint_minimal_pub.publish(msg_minimal)\n\n    # Create a joint trajectory message\n    msg_traj = JointTrajectory()\n    msg_traj.header = joints.header\n    msg_traj.joint_names = self.joint_names\n\n    # Create a trajectory point\n    traj_point = JointTrajectoryPoint()\n    traj_point.positions = joints.position[0:12]\n    traj_point.velocities = [0.0] * 12\n    traj_point.accelerations = [0.0] * 12\n    traj_point.effort = [0.0] * 12\n    traj_point.time_from_start = rospy.Duration(0.01)\n\n    # Append the trajectory point\n    msg_traj.points.append(traj_point)\n\n    # Publish the trajectory message\n    self.joint_trajectory_pub.publish(msg_traj)\n}", "CodeBleu_score": 46.63697934509817}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < 4; i++) {\n    foot_contacts_[i] = false;\n  }\n\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string collision1 = _msg->contact(i).collision1();\n    std::string collision2 = _msg->contact(i).collision2();\n\n    std::vector<std::string> split1;\n    std::vector<std::string> split2;\n    boost::split(split1, collision1, boost::is_any_of(\"::\"));\n    boost::split(split2, collision2, boost::is_any_of(\"::\"));\n\n    for (int j = 0; j < 4; j++) {\n      if (split1.back() == foot_links_[j] || split2.back() == foot_links_[j]) {\n        foot_contacts_[j] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 66.35978813563888}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < 4; i++) {\n        foot_contacts_[i] = false;\n    }\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::vector<std::string> collision_names;\n        boost::split(collision_names, _msg->contact(i).collision2(), boost::is_any_of(\"::\"));\n        std::string link_name = collision_names[collision_names.size() - 2];\n        for (int j = 0; j < 4; j++) {\n            if (link_name == foot_links_[j]) {\n                foot_contacts_[j] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 64.64476538957771}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < 4; i++) {\n        foot_contacts_[i] = false;\n    }\n\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n\n        std::vector<std::string> split1;\n        boost::split(split1, collision1, boost::is_any_of(\"::\"));\n\n        std::vector<std::string> split2;\n        boost::split(split2, collision2, boost::is_any_of(\"::\"));\n\n        for (int j = 0; j < 4; j++) {\n            if (split1[1] == foot_links_[j] || split2[1] == foot_links_[j]) {\n                foot_contacts_[j] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 64.96691613679951}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(initialized_params_);\n  assert(attitude_estimate_);\n  assert(angular_velocity_estimate_);\n  assert(position_estimate_);\n  assert(linear_acceleration_estimate_);\n  assert(vehicle_parameters_.rotor_configuration_.rotors.size() == rotor_velocities->size());\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  Eigen::Vector3d body_z_axis = attitude_estimate_->orientation_W_B.toRotationMatrix().col(2);\n  Eigen::Vector3d body_x_axis = attitude_estimate_->orientation_W_B.toRotationMatrix().col(0);\n  Eigen::Vector3d body_y_axis = attitude_estimate_->orientation_W_B.toRotationMatrix().col(1);\n\n  Eigen::Vector3d thrust_desired_B = Eigen::Vector3d::Zero();\n  thrust_desired_B(2) = -controller_parameters_.mass_ * controller_parameters_.gravity_;\n\n  Eigen::Vector3d thrust_desired_W = attitude_estimate_->orientation_W_B.toRotationMatrix() * thrust_desired_B;\n\n  Eigen::Vector3d angular_acceleration_desired_B = Eigen::Vector3d::Zero();\n  angular_acceleration_desired_B(0) = controller_parameters_.k_p_yaw_ * (desired_attitude_.yaw - attitude_estimate_->yaw);\n  angular_acceleration_desired_B(1) = controller_parameters_.k_p_roll_ * (desired_attitude_.roll - attitude_estimate_->roll);\n  angular_acceleration_desired_B(2) = controller_parameters_.k_p_pitch_ * (desired_attitude_.pitch - attitude_estimate_->pitch", "CodeBleu_score": 49.49446244112249}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  if (!initialized_params_) {\n    ROS_ERROR(\"LeePositionController: Parameters are not initialized.\");\n    return;\n  }\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n\n  // Calculate desired thrust and torque.\n  Eigen::Vector3d desired_thrust;\n  Eigen::Vector3d desired_torque;\n  CalculateDesiredThrustAndTorque(&desired_thrust, &desired_torque);\n\n  // Project thrust onto the body z-axis.\n  double thrust_z = desired_thrust.dot(vehicle_parameters_.body_frame_sp_.block<3, 1>(0, 2));\n\n  // Combine thrust and torque into a single vector.\n  Eigen::Vector4d desired_rotor_acceleration;\n  desired_rotor_acceleration << thrust_z, desired_torque(0), desired_torque(1), desired_torque(2);\n\n  // Project onto body frame.\n  desired_rotor_acceleration = angular_acc_to_rotor_velocities_ * desired_rotor_acceleration;\n\n  // Calculate rotor velocities.\n  *rotor_velocities = desired_rotor_acceleration.cwiseSqrt();\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 0.0);\n  }\n}", "CodeBleu_score": 56.98212882806244}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(\n        vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n\n  assert(initialized_params_);\n\n  Eigen::Vector3d thrust_vector = thrust_force_to_body_frame_.head<3>();\n  Eigen::Vector3d body_z_axis = Eigen::Vector3d(0, 0, 1);\n\n  // Project thrust onto the body z-axis.\n  double thrust = thrust_vector.dot(body_z_axis);\n\n  // Calculate desired acceleration.\n  Eigen::Vector3d desired_acceleration =\n      desired_acceleration_ + Eigen::Vector3d(0, 0, 9.81);\n\n  // Calculate desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      normalized_attitude_gain_ * (attitude_quaternion_.inverse()\n          * (Eigen::Quaterniond(0, desired_rates_.x(), desired_rates_.y(),\n                                desired_rates_.z()) * attitude_quaternion_).vec());\n\n  // Combine thrust and desired acceleration into a single vector.\n  Eigen::Vector4d acceleration_command;\n  acceleration_command << desired_acceleration, thrust;\n\n  // Combine thrust and desired angular acceleration into a single vector.\n  Eigen::Vector4d angular_acceleration_command;\n  angular_acceleration_command << desired_angular_acceleration, 0;\n\n  // Project onto body frame.\n  acceleration_command =\n      attitude_quaternion_.toRotationMatrix() * acceleration_command;\n  angular_acceleration_command =\n      attitude_quaternion_.toRotationMatrix() * angular_acceleration_command;\n\n  // Calculate rotor velocities", "CodeBleu_score": 46.21144085464937}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n  // Position error.\n  const Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Velocity error.\n  const Eigen::Vector3d velocity_error = odometry_.velocity_B - command_trajectory_.velocity_W;\n\n  // Compute the desired acceleration.\n  *acceleration = (controller_parameters_.position_gain_ * position_error\n                   + controller_parameters_.velocity_gain_ * velocity_error\n                   + command_trajectory_.acceleration_W) / vehicle_parameters_.mass\n                  - Eigen::Vector3d(0.0, 0.0, 9.81);\n}", "CodeBleu_score": 44.19863674726733}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n  // Position errors.\n  const Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Velocity errors.\n  const Eigen::Vector3d velocity_error = odometry_.getRotation().toRotationMatrix() * odometry_.velocity\n      - command_trajectory_.velocity_W;\n\n  // Position controller.\n  const Eigen::Vector3d position_ee_error = command_trajectory_.getAcceleration()\n      + command_trajectory_.getAcceleration().cross(position_error);\n\n  // Velocity controller.\n  const Eigen::Vector3d velocity_ee_error = command_trajectory_.getAcceleration().cross(velocity_error);\n\n  // Compute the desired acceleration.\n  *acceleration = (position_ee_error + velocity_ee_error) / vehicle_parameters_.mass_\n      - Eigen::Vector3d(0.0, 0.0, 9.81);\n}", "CodeBleu_score": 50.98826392952146}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n\n  const EigenOdometry& odometry = odometry_;\n  const mav_msgs::EigenTrajectoryPoint& command_trajectory = command_trajectory_;\n\n  // Position error.\n  const Eigen::Vector3d position_error = odometry.position - command_trajectory.position_W;\n\n  // Velocity error.\n  Eigen::Vector3d velocity_error;\n  velocity_error = odometry.orientation.toRotationMatrix() * odometry.velocity\n      - command_trajectory.velocity_W;\n\n  // Compute the desired acceleration.\n  *acceleration = position_error.cwiseProduct(controller_parameters_.position_gain_)\n      - velocity_error.cwiseProduct(controller_parameters_.velocity_gain_)\n      + command_trajectory.acceleration_W;\n  *acceleration /= vehicle_parameters_.mass;\n  *acceleration += -9.81 * Eigen::Vector3d::UnitZ();\n}", "CodeBleu_score": 54.081293917507445}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(initialized_params_);\n  assert(attitude_);\n  assert(angular_rates_);\n  assert(attitude_thrust_command_);\n\n  Eigen::Vector3d angular_acceleration_desired = CalculateAngularAcceleration(attitude_thrust_command_->attitude_reference_,\n                                                                             attitude_thrust_command_->bodyrates_reference_,\n                                                                             attitude_, angular_rates_);\n\n  Eigen::VectorXd desired_rotor_velocities(amount_rotors_);\n  desired_rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_desired +\n                             angular_acc_to_rotor_velocities_ * attitude_thrust_command_->collective_thrust_ / mass_;\n  desired_rotor_velocities = desired_rotor_velocities.cwiseMax(Eigen::VectorXd::Ones(amount_rotors_));\n  *rotor_velocities = desired_rotor_velocities.cwiseSqrt();\n}", "CodeBleu_score": 40.24119545048628}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(initialized_params_);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(amount_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration = CalculateDesiredAngularAcc(attitude_reference_, attitude_);\n\n  // Combine the desired thrust and the angular acceleration into a single vector.\n  Eigen::VectorXd desired_acceleration(4);\n  desired_acceleration.head(3) = angular_acceleration;\n  desired_acceleration(3) = thrust_reference_;\n\n  // Calculate the rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * desired_acceleration;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < amount_rotors_; i++) {\n    if ((*rotor_velocities)(i) < 1.0) {\n      (*rotor_velocities)(i) = 1.0;\n    }\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 58.44570931716713}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(initialized_params_);\n  assert(attitude_reference_);\n  assert(angular_rate_reference_);\n  assert(thrust_reference_);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(amount_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  angular_acceleration = gain_attitude_ * (attitude_reference_->GetQuaternion()\n      .inverse() * attitude_estimate_->GetQuaternion()).toRotationMatrix()\n      * attitude_estimate_->GetAngularVelocity()\n      + gain_angular_rate_ * (angular_rate_reference_->GetAngularVelocity()\n      - attitude_estimate_->GetAngularVelocity());\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::Vector4d desired_acceleration;\n  desired_acceleration << angular_acceleration, thrust_reference_;\n\n  // Compute the rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * desired_acceleration;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < amount_rotors_; i++) {\n    if ((*rotor_velocities)(i) < 1.0) (*rotor_velocities)(i) = 1.0;\n  }\n\n  // Compute the square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 51.404878091756665}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\tstart_index = numpy.searchsorted(self.time, start_time)\n    end_index = numpy.searchsorted(self.time, end_time)\n    sliced = copy.deepcopy(self)\n    for attr in self.__dict__.keys():\n        if attr != 'time' and attr != 'bag_time':\n            sliced.__dict__[attr] = sliced.__dict__[attr][start_index:end_index]\n    return sliced\n\n", "CodeBleu_score": 36.833615275323474}, {"code": "def slice(self, start_time, end_time)\n\tstart_idx = numpy.searchsorted(self.time, start_time)\n    end_idx = numpy.searchsorted(self.time, end_time)\n\n    if start_idx == end_idx:\n        return None\n\n    sliced_obj = copy.deepcopy(self)\n    sliced_obj.time = sliced_obj.time[start_idx:end_idx]\n    sliced_obj.bag_time = sliced_obj.bag_time[start_idx:end_idx]\n\n    return sliced_obj\n\n", "CodeBleu_score": 23.250369679268204}, {"code": "def slice(self, start_time, end_time)\n\t# Get the indices of the start and end times\n    start_index = numpy.searchsorted(self.time, start_time)\n    end_index = numpy.searchsorted(self.time, end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_object.time = sliced_object.time[start_index:end_index]\n    sliced_object.bag_time = sliced_object.bag_time[start_index:end_index]\n\n    return sliced_object\n\n", "CodeBleu_score": 24.190235114030113}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Get the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion((rotation.x, rotation.y, rotation.z, rotation.w))\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one by comparing position and yaw values\n    if not self.empty and self.x[-1] == position.x and self.y[-1] == position.y and self.z[-1] == position.z and self.yaw[-1] == euler[2]:\n        return\n    # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n    self.append_point(point)\n    self.yaw = numpy.append(self.yaw, euler[2])\n    self.append_times(msg_time, bag_time)\n    self.empty = False\n\n", "CodeBleu_score": 26.458842802989878}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tself.append_point(waypoint_msg.pose.position)\n    self.yaw = numpy.append(self.yaw, self.get_yaw(waypoint_msg.pose.orientation))\n    self.append_times(msg_time, bag_time)\n    if not self.empty:\n        if (self.x[-1] != self.x[-2] or self.y[-1] != self.y[-2] or self.z[-1] != self.z[-2] or\n                self.yaw[-1] != self.yaw[-2]):\n            self.empty = False\n    else:\n        self.empty = False\n\n", "CodeBleu_score": 20.824650920377696}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tself.empty = False\n    if len(self.x) == 0:\n        self.x = numpy.append(self.x, waypoint_msg.pose.position.x)\n        self.y = numpy.append(self.y, waypoint_msg.pose.position.y)\n        self.z = numpy.append(self.z, waypoint_msg.pose.position.z)\n        self.yaw = numpy.append(self.yaw, self.get_yaw(waypoint_msg))\n        self.time = numpy.append(self.time, msg_time)\n        self.bag_time = numpy.append(self.bag_time, bag_time)\n    else:\n        if (waypoint_msg.pose.position.x != self.x[-1] or\n            waypoint_msg.pose.position.y != self.y[-1] or\n            waypoint_msg.pose.position.z != self.z[-1] or\n            self.get_yaw(waypoint_msg) != self.yaw[-1]):\n            self.x = numpy.append(self.x, waypoint_msg.pose.position.x)\n            self.y = numpy.append(self.y, waypoint_msg.pose.position.y)\n            self.z = numpy.append(self.z, waypoint_msg.pose.position.z)\n            self.yaw = numpy.append(self.yaw, self.get_yaw(waypoint_msg))\n            self.time = numpy.append(self.time, msg_time)\n            self.bag_time = numpy.append(self.bag_time, bag_time)\n\n", "CodeBleu_score": 34.03559180204883}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 23.585512207503058}, {"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 23.585512207503058}, {"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 23.585512207503058}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 18.82514932718058}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 18.82514932718058}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 18.82514932718058}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n\n  float multiplier = this->fx * this->baseline / this->focal_length_x;\n\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n  Eigen::VectorXf noise_values = Eigen::VectorXf::Zero(width * height);\n  float rms_noise = 0.0;\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vec[i])) {\n      float noise = this->noise_density * multiplier * data_vec[i];\n      rms_noise += noise * noise;\n      noise_values[i] = noise;\n    } else {\n      data_vec[i] = this->bad_point;\n    }\n  }\n\n  rms_noise = sqrt(rms_noise / (width * height));\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vec[i])) {\n      data_vec[i] += noise_values[i] * this->random_engine.gaussian(0.0, rms_noise);\n    }\n  }\n}", "CodeBleu_score": 52.87789163844736}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if the data pointer is null.\n  if (data == NULL) {\n    std::cout << \"Data pointer is null.\n\";\n    return;\n  }\n\n  // Calculate a multiplier based on camera parameters.\n  float multiplier = 0.001f * (float)width / (2.f * tan(0.5f * this->hfov));\n\n  // Map the data to an Eigen vector.\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute the RMS noise and the noise values.\n  float rms_noise = sqrt(this->sigma_read * this->sigma_read +\n                         this->sigma_read_bias * this->sigma_read_bias +\n                         this->sigma_temp * this->sigma_temp +\n                         this->sigma_temp_bias * this->sigma_temp_bias);\n  float noise_values[width * height];\n  for (uint32_t i = 0; i < width * height; ++i) {\n    noise_values[i] = rms_noise * multiplier *\n                      (this->sigma_read * this->sigma_temp * data_vec[i] +\n                       this->sigma_read_bias * this->sigma_temp_bias +\n                       this->sigma_read * this->sigma_temp_bias * data_vec[i] +\n                       this->sigma_read_bias * this->sigma_temp * data_vec[i]);\n  }\n\n  // Add noise to each pixel if it is in range.\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vec[i])) {\n      data_vec[i] += noise_values[i];\n    } else {\n      data_vec[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 45.98970270177823}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n\n  // Calculate the multiplier to convert from depth in millimeters to meters.\n  const float multiplier = 1.0 / 1000.0;\n\n  // Convert the data to an Eigen vector.\n  Eigen::Map<Eigen::VectorXf> data_eigen(data, width * height);\n\n  // Calculate the RMS noise and the noise values.\n  const float rms_noise = this->GetRmsNoise(multiplier);\n  const float noise_values = this->GetNoiseValues(multiplier);\n\n  // Apply noise to each pixel.\n  for (uint32_t i = 0; i < data_eigen.size(); i++) {\n    float depth = data_eigen(i);\n    if (this->InRange(depth)) {\n      depth += noise_values * rms_noise *\n          (this->random_noise_->GetNoise1() + this->random_noise_->GetNoise2());\n      data_eigen(i) = depth;\n    } else {\n      data_eigen(i) = this->bad_point_;\n    }\n  }\n}", "CodeBleu_score": 45.13871509064846}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}, {"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}, {"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t// If the new time differs from the current time, update the time position.\n  if (!math::equal(_time, this->timePos)) {\n    this->timePos = _time;\n    if (this->loop) {\n      // Wrap the time within the animation length.\n      this->timePos = std::fmod(this->timePos, this->length);\n      if (this->timePos < 0.0)\n        this->timePos += this->length;\n    }\n    else {\n      // Clamp the time between 0 and the animation length.\n      this->timePos = std::max(0.0, this->timePos);\n      this->timePos = std::min(this->length, this->timePos);\n    }\n  }\n}", "CodeBleu_score": 70.47327385007605}, {"code": "void Animation::SetTime(double _time){\n\tif (this->loop)\n    this->timePos = fmod(_time, this->length);\n  else\n    this->timePos = std::max(0.0, std::min(_time, this->length));\n}", "CodeBleu_score": 38.13314335294451}, {"code": "void Animation::SetTime(double _time){\n\tif (_time < 0)\n    _time = 0;\n  if (this->loop) {\n    _time = std::fmod(_time, this->length);\n    if (_time < 0)\n      _time += this->length;\n  } else {\n    _time = std::max(0.0, _time);\n    _time = std::min(_time, this->length);\n  }\n\n  if (this->timePos != _time) {\n    this->timePos = _time;\n    this->Build();\n  }\n}", "CodeBleu_score": 54.70707842456663}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}, {"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}, {"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}, {"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}, {"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}, {"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}, {"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}, {"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}, {"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}, {"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}, {"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 58.5840225418091}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 58.5840225418091}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 58.5840225418091}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}, {"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}, {"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}, {"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}, {"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\tdistance_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance_matrix[i][j] = int(\n                50 - numpy.linalg.norm(\n                    numpy.array(orig_formation[i]) - numpy.array(orig_formation[j])))\n    return distance_matrix\n\n", "CodeBleu_score": 42.59828865}, {"code": "def build_graph(self, orig_formation, change_formation)\n\tdistance_matrix = numpy.zeros([self.uav_num - 1, self.uav_num - 1])\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance_matrix[i, j] = int(50 - numpy.linalg.norm(orig_formation[i] - change_formation[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 40.73509448156404}, {"code": "def build_graph(self, orig_formation, change_formation)\n\tadj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            adj_matrix[i, j] = int(50 - numpy.linalg.norm(\n                numpy.array(orig_formation[i + 1]) - numpy.array(orig_formation[j + 1])) + 0.5)\n    return adj_matrix\n\n", "CodeBleu_score": 40.69346198252669}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0 and self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j] == 0:\n            self.visit_right[j] = 1\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        elif self.slack_right[j] > self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]:\n            self.slack_right[j] = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n    return False\n\n", "CodeBleu_score": 46.515053589252545}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0 and self.adj_matrix[i][j] == 0:\n            self.visit_right[j] = 1\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        elif self.slack_right[j] > self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]:\n            self.slack_right[j] = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n    return False\n\n", "CodeBleu_score": 47.825931749825195}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                if self.match_right[j] == -1:\n                    self.visit_right[j] = 1\n                    if self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        return True\n                else:\n                    if self.find_path(self.match_right[j]):\n                        return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 47.23798398387658}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\tfor i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        if self.find_path(i):\n            continue\n        min_slack = numpy.min(self.slack_right)\n        self.label_left += min_slack\n        self.label_right -= min_slack\n    return self.match_right\n\n", "CodeBleu_score": 37.171890121444015}, {"code": "def KM(self)\n\tfor i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        self.find_path(i)\n    return self.match_right\n\n", "CodeBleu_score": 29.75692094313716}, {"code": "def KM(self)\n\tfor i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            self.slack_right[j] = 100\n        self.find_path(i)\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            self.slack_right[j] = 100\n        self.find_path(i)\n        for j in range(self.uav_num - 1):\n            if self.visit_right[j]:\n                self.label_left[i] = max(self.label_left[i], self.slack_right[j])\n            else:\n                self.label_right[j] = max(self.label_right[j], self.slack_right[j])\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            self.slack_right[j] = 100\n        self.find_path(i)\n    return self.match_right\n\n", "CodeBleu_score": 35.676224444990886}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.299115066160905}, {"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.309278171150012}, {"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.299115066160905}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}]}
