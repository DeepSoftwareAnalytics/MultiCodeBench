{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tauto files = FileTransfer::GetRequiredFiles(folder);\n\tif (download) {\n\t\tfor (auto &file : files) {\n\t\t\tif (FileTransfer::IsFileCached(file)) {\n\t\t\t\tLOG_INFO_S << \"Found file in cache: \" << file;\n\t\t\t} else {\n\t\t\t\tLOG_INFO_S << \"Downloading file: \" << file;\n\t\t\t\tFileTransfer::DownloadFile(file);\n\t\t\t}\n\t\t}\n\t}\n\treturn files;\n}", "CodeBleu_score": 45.504670039591524}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t", "CodeBleu_score": 8.781990752468507}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t", "CodeBleu_score": 8.781990752468507}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.x == 0 && transform.location.y == 0 && transform.location.z!= 0) {\n        log_warning(\"Spawning a SpringArm or SpringArmGhost with a translation only in the 'z' axis may lead to undesired results. \"\n                    \"Please check the transform you are using.\");\n      }\n    }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n    return _pimpl->CallAndWait<rpc::Actor>(\n      \"spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n  }", "CodeBleu_score": 50.03817123074844}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t/*\n * This line calls the private function Client::_pimpl->CallAndWait<streaming::Token>(\"get_gbuffer_token\", ActorId, GBufferId) to retrieve a token for the G-buffer.\n */\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\"get_gbuffer_token\", ActorId, GBufferId);\n/*\n * This line copies the token data using the carla::streaming::detail::token_type class.\n */\n    carla::streaming::detail::token_type thisToken(receivedToken);\n/*\n * This line subscribes to the streaming client using the copied token and the provided callback function.\n */\n    _pimpl->streaming_client.Subscribe(thisToken, std::move(callback));\n  }", "CodeBleu_score": 46.5013735082943}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Retrieve the token for the G-buffer using the ActorId and GBufferId.\n\tstreaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\"get_gbuffer_token\", ActorId, GBufferId);\n\t// Copy the token data.\n\tstreaming::detail::token_type thisToken(receivedToken);\n\t// Subscribe to the streaming client using the copied token data and the provided callback function.\n\t_pimpl->streaming_client.Subscribe(thisToken, std::move(callback));\n}", "CodeBleu_score": 45.519807015153944}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t (_walker_navigation == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>(_client, GetState());\n\t\tif (_walker_navigation.compare_exchange(&new_navigation, nullptr)) {\n\t\t\t_walker_navigation = new_navigation;\n\t\t}\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 46.073423255761945}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t (_walker_navigation == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> navigation;\n\t\tdo {\n\t\t\tnavigation = std::make_shared<WalkerNavigation>(_client, GetState());\n\t\t} while (!_walker_navigation.compare_exchange(&navigation, navigation));\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 45.12297215345109}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t (_walker_navigation == nullptr) {\n\t\twhile (_walker_navigation == nullptr) {\n\t\t\tauto nav = std::make_shared<WalkerNavigation>(*this);\n\t\t\tif (_walker_navigation.compare_exchange(&nav, nullptr)) {\n\t\t\t\t_walker_navigation = nav;\n\t\t\t}\n\t\t}\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 50.941755273754374}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t", "CodeBleu_score": 2.6018891845533507}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start = std::chrono::system_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.TickTrafficManager();\n\treturn true;\n}", "CodeBleu_score": 38.3515996095348}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tifdef LIBCARLA_WITH_TRAFFIC_MANAGER\n  // Get the current frame of the episode state\n  const auto current_frame = episode.GetState().GetFrame();\n  // Check if the current frame is less than the given frame\n  if (current_frame < frame) {\n    // Yield control until the current frame is equal to or greater than the given frame\n    while (current_frame < frame) {\n      // Check if the timeout duration has been exceeded\n      if (timeout.count() <= 0) {\n        // Return false if the timeout duration is exceeded\n        return false;\n      }\n      // Yield control to the scheduler\n      std::this_thread::yield();\n      // Update the timeout duration\n      timeout -= std::chrono::milliseconds(10);\n    }\n  }\n  // Trigger a tick in the TrafficManager\n  episode.GetTrafficManager().Tick();\n  // Return true if synchronization is successful\n  return true;\n#else\n  // Return false if the TrafficManager is not enabled\n  return false;\n#endif\n}", "CodeBleu_score": 36.68030058443009}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tf (map_name.empty()) {\n\t\tmap_name = \"Town01\";\n\t}\n\n\tif (reset_settings) {\n\t\tlog_info(\"Resetting the simulator settings.\");\n\t\t_client.ApplySettings(rpc::ServerSettings());\n\t}\n\n\tlog_info(\"Loading new episode \\\"\", map_name, \"\\\"...\");\n\n\tauto episode_id = _client.LoadEpisode(map_name, map_layers);\n\tauto episode = Episode(_client, episode_id);\n\n\tlog_info(\"New episode loaded.\");\n\n\t// Try to connect to the new episode.\n\tconst size_t max_attempts = 10;\n\tsize_t attempts = 0;\n\twhile (episode.GetId()!= episode_id) {\n\t\tif (attempts >= max_attempts) {\n\t\t\tthrow_exception(std::runtime_error, \"Failed to connect to the new episode.\");\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::seconds(1));\n\t\tepisode = Episode(_client, episode_id);\n\t\tattempts++;\n\t}\n\n\tlog_info(\"Connected to episode.\");\n\n\treturn EpisodeProxy(episode);\n}", "CodeBleu_score": 47.88967484528401}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t/ TODO: check if map_name is a valid map name\n\t// TODO: check if map_layers is a valid map layer\n\t// TODO: check if reset_settings is a valid reset setting\n\n\t// Reset the client\n\n\t_client.Reset();\n\n\t// Connect to the new episode\n\n\tauto episode = _client.Connect(map_name, reset_settings, map_layers);\n\n\t// Validate the versions\n\n\tValidateVersions(_client);\n\n\t// Return the episode\n\n\treturn EpisodeProxy(episode, _client, _light_manager, _gc_policy);\n\n}", "CodeBleu_score": 24.700393148776772}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t", "CodeBleu_score": 3.4229654508845124}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode!= nullptr);\nauto nav = _episode->CreateNavigationIfMissing();\nauto walker = _episode->GetWalkerById(controller.GetId());\nif (walker == nullptr) {\nthrow_exception(std::runtime_error(\"walker not found\"));\n}\nnav->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 65.75371817650709}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode!= nullptr);\n\tauto nav = _episode->CreateNavigationIfMissing();\n\tauto walker = nav->GetWalker(controller.GetId());\n\tif (walker == nullptr) {\n\t\tthrow_exception(std::runtime_error(\"walker not found\"));\n\t}\n\tnav->RegisterController(controller.GetId(), controller);\n}", "CodeBleu_score": 66.3965151137451}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode!= nullptr);\nauto nav = _episode->CreateNavigationIfMissing();\n\nSharedPtr<Walker> walker = GetWalkerByID(controller.GetWalkerId());\nif (!walker) {\nthrow_exception(std::runtime_error(\"walker not found\"));\n}\n\nnav->RegisterAIController(controller);\n}", "CodeBleu_score": 57.64371558066048}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tDEBUG_ASSERT(_episode!= nullptr);\n\tauto actor = _episode->CreateActor(blueprint, transform, parent, attachment_type, socket_name);\n\tif (actor == nullptr) {\n\t  throw_exception(std::runtime_error(blueprint.GetDisplayId() + \": failed to create actor\"));\n\t}\n\tactor->SetGarbageCollectionPolicy(gc);\n\tlog_info(actor->GetDisplayId() + \": spawned\");\n\treturn actor;\n}", "CodeBleu_score": 38.688355679981555}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\tauto state = episode->GetState();\n\tfor (auto it = walkers.begin(); it!= walkers.end();) {\n\t\tif (state.find(*it) == state.end()) {\n\t\t\tit = walkers.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n\n\t_nav.UpdateVehicles(walkers, episode->GetTimestamp());\n\t_nav.UpdateCrowd(episode->GetTimestamp());\n\n\tstd::vector<rpc::WalkerControl> controls(walkers.size());\n\tfor (size_t i = 0; i < walkers.size(); ++i) {\n\t\tconst auto &walker = walkers[i];\n\t\tconst auto &transform = state.at(walker).transform;\n\t\tconst auto &speed = state.at(walker).speed;\n\t\tcontrols[i].set_id(walker);\n\t\tcontrols[i].set_transform(transform);\n\t\tcontrols[i].set_speed(speed);\n\t}\n\tepisode->ApplyWalkerControl(controls);\n\n\tfor (const auto &walker : walkers) {\n\t\tif (state.at(walker).killed) {\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\tepisode->DestroyWalkerController(walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 47.5118638744099}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n    auto walkers = episode->GetWalkers();\n    if (walkers.empty()) {\n      return;\n    }\n\n    auto state = episode->GetState();\n    for (auto it = walkers.begin(); it!= walkers.end();) {\n      if (state.find(it->first) == state.end()) {\n        it = walkers.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    _nav.UpdateVehicles(walkers);\n    _nav.UpdateCrowd(walkers);\n\n    std::vector<rpc::WalkerControl> controls;\n    controls.reserve(walkers.size());\n    for (auto &walker : walkers) {\n      auto &transform = walker.second.transform;\n      auto &speed = walker.second.speed;\n      controls.emplace_back(walker.first, transform.location.x, transform.location.y, transform.location.z, transform.rotation.yaw, speed);\n    }\n    episode->ApplyWalkerControl(controls);\n\n    for (auto &walker : walkers) {\n      if (walker.second.killed) {\n        _nav.RemoveAgent(walker.first);\n        episode->DestroyWalkerController(walker.first);\n      }\n    }\n  }", "CodeBleu_score": 49.9495380447282}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n    description.uid = _uid;\n    description.id = _id;\n    description.attributes.reserve(_attributes.size());\n    for (auto &item : _attributes) {\n      description.attributes.emplace_back(item.second.MakeAttribute());\n    }\n    return description;\n  }", "CodeBleu_score": 78.38325190018006}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n    description.uid = _uid;\n    description.id = _id;\n    description.attributes.reserve(_attributes.size());\n    for (auto &item : _attributes) {\n      description.attributes.emplace_back(item.second.MakeAttribute());\n    }\n    return description;\n  }", "CodeBleu_score": 78.38325190018006}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\ndescription.uid = _uid;\ndescription.id = _id;\ndescription.attributes.reserve(_attributes.size());\nfor (const auto &attribute : _attributes) {\n  description.attributes.emplace_back(attribute.second.MakeAttribute());\n}\nreturn description;\n}", "CodeBleu_score": 83.46852381342322}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\nfor (auto &pair : _blueprints) {\nif (pair.second.HasAttribute(name)) {\nauto &attr = pair.second.GetAttribute(name);\nif (attr.recommended_values.empty()) {\nif (attr.value == value) {\nresult.emplace(pair);\n}\n} else {\nif (std::find(attr.recommended_values.begin(), attr.recommended_values.end(), value)!= attr.recommended_values.end()) {\nresult.emplace(pair);\n}\n}\n}\n}\nreturn SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 52.54375864177601}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t", "CodeBleu_score": 7.837249333138888}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t", "CodeBleu_score": 7.837249333138888}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Construct the full file path\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Validate the file path\n\tif (!ValidateFilePath(fullpath)) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\n\t// Check if the file is successfully opened\n\tif (file.is_open()) {\n\t\t// Write the content\n\t\tfile.write(reinterpret_cast<char *>(content.data()), content.size());\n\n\t\t// Close the file\n\t\tfile.close();\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 51.93148239090082}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Construct the full file path\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Validate the file path\n\tif (fullpath.empty()) return false;\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\t// Write the content\n\t\tfile.write(reinterpret_cast<char *>(content.data()), content.size());\n\n\t\t// Close the file\n\t\tfile.close();\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 52.9679656996967}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Construct the full file path using the base folder and version information\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Validate the file path\n\tif (fullpath.empty()) return false;\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\n\t// If the file is successfully opened, write the content and close the file\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\t// If the file cannot be opened, return false\n\treturn false;\n}", "CodeBleu_score": 48.94684169328982}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// Compute the location of the bounding box by adding the parent's bounding box location to the transform's location.\n    const auto location = transform.location + _parent_bounding_box.location;\n    // Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n    const auto corners = std::array<geom::Location, 4u> {\n      Rotate(transform.rotation.yaw, _parent_bounding_box.extent),\n      Rotate(transform.rotation.yaw, geom::Location(-_parent_bounding_box.extent.x, _parent_bounding_box.extent.y, 0.0f)),\n      Rotate(transform.rotation.yaw, -_parent_bounding_box.extent),\n      Rotate(transform.rotation.yaw, geom::Location(_parent_bounding_box.extent.x, -_parent_bounding_box.extent.y, 0.0f))\n    };\n    // Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n    return MakeShared<Bounds>(frame, std::move(corners));\n  }", "CodeBleu_score": 52.02299584107595}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tstd::vector<carla::rpc::LightState> light_states = _client->GetLightState();\n\tfor (const auto &light_state : light_states) {\n\t\tLightId id = light_state.id;\n\t\tauto it_light = _lights.find(id);\n\t\tif (it_light == _lights.end()) {\n\t\t\t_lights[id] = Light(id);\n\t\t\tit_light = _lights.find(id);\n\t\t}\n\t\tLightState &state = const_cast<LightState &>(_lights_state[id]);\n\t\tstate._active = light_state.active;\n\t\tstate._color = light_state.color;\n\t\tstate._intensity = light_state.intensity;\n\t\tstate._group = static_cast<LightGroup>(light_state.group);\n\t\t_lights_changes[id] = state;\n\t\t_dirty = true;\n\t}\n}", "CodeBleu_score": 41.57097940765243}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n  std::lock_guard<std::mutex> lock(_mutex);\n  auto lights_state = _client->GetLightsState();\n  for (auto light_state : lights_state) {\n    LightId id = light_state.GetId();\n    auto it = _lights_state.find(id);\n    if (it == _lights_state.end()) {\n      auto it_light = _lights.find(id);\n      if (it_light == _lights.end()) {\n        _lights[id] = Light(id, light_state.GetTransform(), light_state.GetLightType());\n      }\n      _lights_state[id] = light_state;\n    } else {\n      it->second = light_state;\n    }\n  }\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n}", "CodeBleu_score": 42.72516320083191}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Query the light states from the server\nrpc::LightsState lights_state = _server->GetLightsState();\n\n// Update the local light states\nfor (const auto &light_state : lights_state) {\nLightId id = light_state.first;\nconst auto &state = light_state.second;\n\n// Update the local light state\n_lights_state[id] = state;\n\n// Create a new light object if it doesn't already exist\nauto it = _lights.find(id);\nif (it == _lights.end()) {\n_lights[id] = Light(id, state.color, state.intensity);\n}\n}\n\n// Remove any lights that are no longer in the server's state\nfor (auto it = _lights.begin(); it!= _lights.end();) {\nif (it->first >= lights_state.size()) {\nit = _lights.erase(it);\n} else {\n++it;\n}\n}\n}", "CodeBleu_score": 44.4827860022285}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t/*\n * This function, LightManager::UpdateServerLightsState, updates the server with the current state of lights if there have been changes.\nIt locks a mutex to ensure thread safety and checks if there are any changes.\nIf there are, it creates a message containing the updated light states and sends it to the server.\nAfter updating, it clears the changes and resets the dirty flag.\n */\nvoid LightManager::UpdateServerLightsState(bool discard_client) {\n  std::lock_guard<std::mutex> lock(_mutex);\n  if(!_dirty) {\n    return;\n  }\n\n  std::vector<rpc::LightState> lights_snapshot;\n  for(const auto& it : _lights_changes) {\n    const LightState& state = it.second;\n    rpc::LightState rpc_state;\n    rpc_state._id = it.first;\n    rpc_state._intensity = state._intensity;\n    rpc_state._color.r = state._color.r;\n    rpc_state._color.g = state._color.g;\n    rpc_state._color.b = state._color.b;\n    rpc_state._group = static_cast<rpc::LightState::LightGroup>(state._group);\n    rpc_state._active = state._active;\n    lights_snapshot.push_back(rpc_state);\n  }\n\n  _episode.Lock()->UpdateLightsState(lights_snapshot, discard_client);\n\n  _lights_changes.clear();\n  _dirty = false;\n}\n\nvoid LightManager::UpdateLightsState(const std::vector<rpc::LightState>& lights_snapshot) {\n  std::lock_guard<std::mutex> lock(_mutex);\n  for(const auto& it : lights_snapshot) {\n    _lights_state[it._id] = LightState(\n        it._intensity,\n        Color(it._color.r, it._color.g, it._color.b),\n        static_cast<LightState::LightGroup>(it._group),\n        it._active\n    );\n  }\n}\n\n}", "CodeBleu_score": 54.965871684158444}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t", "CodeBleu_score": 1.4421612766169787}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tif (!_dirty) {\n\t\treturn;\n\t}\n\n\trpc::LightStateUpdate message;\n\n\tfor (auto &it : _lights_changes) {\n\t\trpc::LightState &state = message._states.emplace_back();\n\t\tstate._id = it.first;\n\t\tstate._intensity = it.second._intensity;\n\t\tstate._color = rpc::Color{it.second._color.r, it.second._color.g, it.second._color.b};\n\t\tstate._group = static_cast<rpc::LightState::LightGroup>(it.second._group);\n\t\tstate._active = it.second._active;\n\t}\n\n\tif (discard_client) {\n\t\t_lights_changes.clear();\n\t\t_dirty = false;\n\t}\n\n\t_episode.Lock()->SendLightStateUpdate(message);\n}", "CodeBleu_score": 48.07986229321614}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"attempting to send message to sensor.other.v2x_custom, but sensor is \", GetDisplayId());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendToSensor(GetContext(), std::move(message));\n}", "CodeBleu_score": 63.46577770383641}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\tif (GetId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"attempting to send message to non-v2x sensor \", GetDisplayId());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendV2XMessage(context, std::move(message));\n}", "CodeBleu_score": 62.07305484249572}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"sensor.other.v2x_custom is not listening, ignoring message\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendToSensor(GetContext(), std::move(message));\n}", "CodeBleu_score": 66.30564795803559}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t#ifdef LIBCARLA_WITH_TRAFFICMANAGER\n  if (enabled) {\n    if (auto tm = TM::GetInstance(tm_port)) {\n      tm->RegisterVehicle(GetActorId());\n    } else {\n      throw_exception(std::runtime_error(\n          \\\"Could not get TrafficManager instance for port \\\" + std::to_string(tm_port)));\n    }\n  } else {\n    if (auto tm = TM::GetInstance(tm_port)) {\n      tm->UnregisterVehicle(GetActorId());\n    } else {\n      throw_exception(std::runtime_error(\n          \\\"Could not get TrafficManager instance for port \\\" + std::to_string(tm_port)));\n    }\n  }\n#else\n  throw_exception(std::runtime_error(\n      \\\"TrafficManager is not enabled in this build of CARLA\\\"));\n#endif\n}", "CodeBleu_score": 41.479448010005434}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t#ifdef LIBCARLA_WITH_TRAFFICMANAGER\n  if (enabled) {\n    if (TM::IsPortFree(tm_port)) {\n      TM::RegisterVehicle(GetActorId(), tm_port);\n    } else {\n      throw_exception(std::runtime_error(\"The port is already in use.\"));\n    }\n  } else {\n    TM::UnregisterVehicle(GetActorId());\n  }\n#else\n  throw_exception(std::runtime_error(\"Traffic Manager is not enabled.\"));\n#endif // LIBCARLA_WITH_TRAFFICMANAGER\n}", "CodeBleu_score": 42.653178113265206}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t", "CodeBleu_score": 1.0949963018106907}, {"code": "void WalkerAIController::Start(){\n\t\tauto simulator = GetSimulator();\n\tauto walker_actor = simulator->GetWalker(GetActorId());\n\tif (walker_actor) {\n\t\tauto navigation = simulator->GetWalkerNavigation();\n\t\tif (navigation) {\n\t\t\tauto transform = walker_actor->GetTransform();\n\t\t\tnavigation->AddWalker(walker_actor, transform.location);\n\t\t}\n\t\twalker_actor->SetSimulatePhysics(false);\n\t\twalker_actor->SetCollisionDetection(false);\n\t}\n}", "CodeBleu_score": 45.425684027879086}, {"code": "void WalkerAIController::Start(){\n\t\tauto episode = GetEpisode();\n\tif (episode) {\n\t\tauto walker = GetWalker();\n\t\tif (walker) {\n\t\t\tepisode->Lock();\n\t\t\tauto &navigation = episode->GetNavigation();\n\t\t\tnavigation.AddWalker(walker);\n\t\t\tepisode->Unlock();\n\t\t\twalker->SetPhysicsEnabled(false);\n\t\t\twalker->SetCollisionsEnabled(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.88553869842009}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tav = GetEpisode().Lock()->GetNavigation();\n\tif (nav!= nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker!= nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed, \"(parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 71.23302088248639}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tav = GetEpisode().Lock()->GetNavigation();\n\tif (nav!= nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker!= nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed, \"(parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 71.23302088248639}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tv = GetEpisode().Lock()->GetNavigation();\nif (nav!= nullptr) {\nauto walker = GetParent();\nif (walker!= nullptr) {\nif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\nlog_warning(\"NAV: Failed to set max speed \", max_speed);\n}\n} else {\nlog_warning(\"NAV: Failed to set max speed \", max_speed, \"(parent does not exist)\");\n}\n}\n}", "CodeBleu_score": 70.99966618913317}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(waypoints.size());\n\tfor (auto &waypoint : waypoints) {\n\t\tresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n\t}\n\treturn result;\n}", "CodeBleu_score": 97.7382971857276}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(waypoints.size());\n\tfor (auto &waypoint : waypoints) {\n\t\tresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n\t}\n\treturn result;\n}", "CodeBleu_score": 97.7382971857276}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t", "CodeBleu_score": 7.227538970210187}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tstd::set<SharedPtr<Signal>> unique_signals;\n\tfor (auto &signal : signals) {\n\t\tif (unique_signals.find(signal)!= unique_signals.end()) {\n\t\t\tcontinue;\n\t\t}\n\t\tunique_signals.insert(signal);\n\t\tSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(_parent, _waypoint));\n\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(signal, waypoint));\n\t\tresult.push_back(landmark);\n\t}\n\tif (stop_at_junction) {\n\t\tauto junction = _parent->GetMap().GetJunction(_waypoint);\n\t\tif (junction.has_value()) {\n\t\t\tSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(_parent, _waypoint));\n\t\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(junction.value(), waypoint));\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.016260566451564}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n    auto signals = GetSignalsInDistance(distance, stop_at_junction);\n    std::unordered_set<int> signal_ids;\n    for (const auto &signal : signals) {\n      if (signal_ids.find(signal->GetId()) == signal_ids.end()) {\n        signal_ids.insert(signal->GetId());\n        result.emplace_back(new Landmark(signal, SharedPtr<Waypoint>(new Waypoint(*this))));\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 46.02074827993533}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\treturn _episode.Lock()->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 13.739492062031477}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat sqr_length = (b - a).SquaredLength();\n\tif (sqr_length == 0.0f) {\n\t\treturn {0.0f, (a - p).Length()};\n\t}\n\tfloat t = Dot(p - a, b - a) / sqr_length;\n\tt = std::clamp(t, 0.0f, 1.0f);\n\treturn {t, (p - (a + t * (b - a))).Length()};\n}", "CodeBleu_score": 26.06463951434851}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n\t\tconst Vector2D segment_vector = segment_end - segment_start;\n\t\tconst float segment_squared_length = segment_vector.SquaredLength();\n\t\tif (segment_squared_length == 0.0f) {\n\t\t\treturn std::make_pair(0.0f, (point - segment_start).Length());\n\t\t}\n\t\tconst float projection = Dot(point - segment_start, segment_vector) / segment_squared_length;\n\t\tconst float clamped_projection = std::clamp(projection, 0.0f, 1.0f);\n\t\tconst Vector2D projection_point = segment_start + clamped_projection * segment_vector;\n\t\treturn std::make_pair(clamped_projection, (point - projection_point).Length());\n\t}\n}", "CodeBleu_score": 39.63568040341732}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n\t  const auto segment_length_squared = (segment_end - segment_start).SquaredLength();\n\t  if (segment_length_squared == 0.0f) {\n\t    return {0.0f, (point - segment_start).Length()};\n\t  }\n\t  const auto projection = Dot(point - segment_start, segment_end - segment_start) / segment_length_squared;\n\t  const auto clamped_projection = std::clamp(projection, 0.0f, 1.0f);\n\t  const auto projection_point = segment_start + (segment_end - segment_start) * clamped_projection;\n\t  return {clamped_projection, (point - projection_point).Length()};\n\t}\n}", "CodeBleu_score": 36.55422566778409}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t", "CodeBleu_score": 5.712762733113359}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t", "CodeBleu_score": 5.712762733113359}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tf (vertices.size() == 0) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum();\n AddVertices(vertices);\n AddIndex(i);\n for (size_t j = i + 1; j < GetVerticesNum() - 1; ++j) {\n AddIndex(j);\n AddIndex(j + 1);\n }\n }", "CodeBleu_score": 57.96141962689679}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\n\nconst auto &data = message->data();\n\nif (data.empty()) {\n  return;\n}\n\n_strand.post(boost::asio::bind_executor(\n    _strand,\n    [self = shared_from_this(), message]() {\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      self->SetDeadline();\n\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(message->data()),\n          boost::asio::bind_executor(\n              self->_strand,\n              [self, message](const boost::system::error_code &ec, std::size_t) {\n                if (ec) {\n                  if (ec == boost::asio::error::operation_aborted) {\n                    // Operation cancelled.\n                    return;\n                  }\n\n                  LOG_ERROR_S << \\\"Failed to send message to client \\\" << self->_session_id << \\\": \\\" << ec;\n                  self->Close();\n                  return;\n                }\n\n                // Send the response.\n                if (message->response()) {\n                  self->_on_response(message->response());\n                }\n              }));\n    }));\n}", "CodeBleu_score": 48.35542505280625}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t", "CodeBleu_score": 3.648604678563731}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t", "CodeBleu_score": 3.648604678563731}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (!_socket.is_open()) {\nreturn;\n}\n\n_deadline.cancel();\n\nif (!ec) {\nboost::system::error_code ignored_ec;\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n}\n\n_socket.close();\n\nif (_on_closed) {\n_on_closed(shared_from_this());\n}\n\nlog_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 63.930247143514876}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tDEBUG_ASSERT(!ec || ec == boost::asio::error::operation_aborted);\n_deadline.cancel();\nif (!ec && _socket.is_open()) {\nboost::system::error_code close_ec;\n_socket.shutdown(boost::asio::socket_base::shutdown_both, close_ec);\n_socket.close(close_ec);\n}\n_on_closed(shared_from_this());\nlog_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 59.6696041485866}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t", "CodeBleu_score": 4.868655198172263}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf(carla::Buffer::value_type * \"Are you alive?\", (size_t) sizeof(\"Are you alive?\"));\n\tlog_info(\"sending are you alive?\");\n\tauto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tauto response = fut.get();\n\tlog_info(\"got a response: \", response.buffer.data());\n}", "CodeBleu_score": 62.806147732295514}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 15);\n\tlog_info(\"sending are you alive command\");\n\tauto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n\tauto response = fut.get();\n\tlog_info(\"got a response: \", std::string(response.buffer.begin(), response.buffer.end()));\n}", "CodeBleu_score": 63.57417384484102}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((unsigned char *) \"Are you alive?\", 15);\n\tlog_info(\"sending alive command\");\n\tauto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tauto response = fut.get();\n\tlog_info(\"got response: \", response.buffer.data());\n}", "CodeBleu_score": 66.6720617523398}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tlog_info(\"sending enable for ros command\");\n\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\tauto response = fut.get();\n\tif (response.buffer.size() == 0) {\n\t\tlog_error(\"sensor not found on any server\");\n\t}\n}", "CodeBleu_score": 51.32823566958542}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t", "CodeBleu_score": 2.115550583146295}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Create a buffer with the sensor ID\n\tcarla::Buffer buf((carla::Buffer::value_type *)&sensor_id, (size_t)sizeof(stream_id));\n\t// Send an ENABLE_ROS command to the server using the router\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\t// Wait for and process the server's response\n\tauto response = fut.get();\n\t// If the sensor is not found on any server, log an error message\n\tif (response.buffer.size() == 0) {\n\t\tlog_error(\"Sensor not found on any server.\");\n\t}\n}", "CodeBleu_score": 44.2152552967732}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t search if the sensor has been activated in any secondary server\n\tauto it = _servers.find(sensor_id);\n\tif (it!= _servers.end()) {\n\t\tlog_info(\"token for sensor \", sensor_id, \" already exists\");\n\t\treturn _tokens[sensor_id];\n\t} else {\n\t\tlog_info(\"token for sensor \", sensor_id, \" does not exist\");\n\t\t// enable the sensor on a secondary server\n\t\tEnable(sensor_id);\n\t\t// get a new token\n\t\tauto new_token = SendGetToken(sensor_id);\n\t\t// update the maps\n\t\t_tokens[sensor_id] = new_token;\n\t\t_servers[sensor_id] = new_token.get_port();\n\t\tlog_info(\"new token for sensor \", sensor_id, \": \", new_token.get_stream_id(), \", \", new_token.get_port());\n\t\treturn new_token;\n\t}\n}", "CodeBleu_score": 55.495153042952914}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t search if the sensor has been activated in any secondary server\n\tauto it = _servers.find(sensor_id);\n\tif (it!= _servers.end()) {\n\t\tlog_info(\"token for sensor\", sensor_id, \"already exists\");\n\t\treturn _tokens[sensor_id];\n\t} else {\n\t\t// enable the sensor in a secondary server\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n\t\t                  (size_t) sizeof(stream_id));\n\t\tauto fut = _router->WriteToOne(0, MultiGPUCommand::ENABLE_SENSOR, std::move(buf));\n\n\t\tauto response = fut.get();\n\t\tbool res = (*reinterpret_cast<bool *>(response.buffer.data()));\n\t\tif (!res) {\n\t\t\tlog_error(\"failed to enable sensor\", sensor_id, \"on a secondary server\");\n\t\t\treturn token_type();\n\t\t}\n\n\t\t// get a new token\n\t\ttoken_type new_token = SendGetToken(sensor_id);\n\n\t\t// update maps\n\t\t_servers[sensor_id] = new_token.get_port();\n\t\t_tokens[sensor_id] = new_token;\n\t\tlog_info(\"new token for sensor\", sensor_id, \":\", new_token.get_stream_id(),\n\t\t         \",\", new_token.get_port());\n\n\t\treturn new_token;\n\t}\n}", "CodeBleu_score": 48.50272505957107}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n\t * This function, PrimaryCommands::GetToken, retrieves a token for a given sensor_id.\nIt first checks if the sensor is already activated and if so, returns the existing token, logging the action.\nIf the sensor is not activated, it enables the sensor on a secondary server, retrieves a new token, updates the maps, logs the action, and returns the new token.\n\t */\n\t// search if the sensor has been activated in any secondary server\n\tauto it = _servers.find(sensor_id);\n\tif (it!= _servers.end()) {\n\t\t// the sensor has been activated, return the token\n\t\tlog_info(\"sensor \", sensor_id, \" already activated on server \", it->second);\n\t\treturn _tokens[sensor_id];\n\t} else {\n\t\t// the sensor has not been activated, enable it on a secondary server\n\t\tlog_info(\"enabling sensor \", sensor_id, \" on a secondary server\");\n\t\tSendEnableForROS(sensor_id);\n\t\t// retrieve the token\n\t\tauto new_token = SendGetToken(sensor_id);\n\t\t// update the maps\n\t\t_servers[sensor_id] = new_token.get_port();\n\t\t_tokens[sensor_id] = new_token;\n\t\t// log the action\n\t\tlog_info(\"sensor \", sensor_id, \" activated on server \", new_token.get_port());\n\t\t// return the token\n\t\treturn new_token;\n\t}\n}", "CodeBleu_score": 45.18500730124846}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream file(filename, std::ios::binary);\nif (!file) {\nreturn false;\n}\nstd::vector<uint8_t> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\nfile.close();\nreturn Load(buffer);\n}", "CodeBleu_score": 55.50877223918322}, {"code": "bool Navigation::Load(const std::string &filename){\n\t", "CodeBleu_score": 4.792014253953123}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream file(filename, std::ios::binary);\nif (!file.is_open()) {\nreturn false;\n}\nstd::vector<char> buffer((std::istreambuf_iterator<char>(file)),\nstd::istreambuf_iterator<char>());\nfile.close();\nreturn Load(buffer);\n}", "CodeBleu_score": 55.12023294264154}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t", "CodeBleu_score": 1.060187825043224}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t", "CodeBleu_score": 1.060187825043224}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t", "CodeBleu_score": 1.060187825043224}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n// check if all is ready\nif (!_ready) {\nreturn false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// get the internal index\nauto it = _mapped_vehicles_id.find(id);\nif (it == _mapped_vehicles_id.end()) {\nit = _mapped_walkers_id.find(id);\nif (it == _mapped_walkers_id.end()) {\nreturn false;\n}\n}\n\n// get the index found\nint index = it->second;\nif (index == -1) {\nreturn false;\n}\n\n// get the vehicle\nconst dtCrowdAgent *agent;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nagent = _crowd->getAgent(index);\n}\n\nif (!agent->active) {\nreturn false;\n}\n\n// get the position in Unreal coordinates\nfloat pos[3] = { agent->npos[0], agent->npos[2], agent->npos[1] };\n\n// get the squared distance\nfloat sq_distance = distance * distance;\n\n// get the squared direction\nfloat sq_direction = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;\n\n// get the squared distance to the closest vehicle\nfloat sq_distance_to_vehicle = _crowd->getAgentNearestPos(pos, sq_distance, sq_direction);\n\n// return if there is a vehicle nearby\nreturn (sq_distance_to_vehicle < sq_distance);\n}", "CodeBleu_score": 64.93101095370844}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current point\n\tauto &point = info.route[info.currentIndex];\n\t// create the visitor\n\tWalkerEventVisitor visitor(id, point.location, delta);\n\t// execute the event\n\tboost::variant2::visit(visitor, point.event);\n\t// return the result\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 61.7453808769507}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current point\n        WalkerRoutePoint &point = info.route[info.currentIndex];\n        // create the visitor\n        WalkerEventVisitor visitor(id, info.from, info.to, delta);\n        // execute the event\n        boost::variant2::visit(visitor, point.event);\n        // return the result\n        return visitor.GetResult();\n    }", "CodeBleu_score": 62.562494381793165}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current point\n\tconst WalkerEvent &event = info.route[info.currentIndex].event;\n\t// create the visitor\n\tWalkerEventVisitor visitor(id, info.from, info.to, delta);\n\t// process the event\n\tboost::variant2::visit(visitor, event);\n\t// return the result\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 55.88598537945815}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  for (pugi::xml_node road_node : xml.children(\\\"road\\\")) {\n    const int id = road_node.attribute(\\\"id\\\").as_int();\n\n    // Get the road\n    auto road = map_builder.GetMap().GetRoad(id);\n\n    // If the road is not found, create it\n    if (!road) {\n      road = map_builder.CreateRoad(id);\n    }\n\n    // Parse the lanes\n    for (pugi::xml_node lanes_node : road_node.children(\\\"lanes\\\")) {\n      ParseLanes(lanes_node, map_builder, road);\n    }\n  }\n}", "CodeBleu_score": 25.278628071633275}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t++_matched;\n\t\t_first_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\t--_matched;\n\t} else {\n\t\tstd::cerr << \"CarlaListener: Invalid count change\" << std::endl;\n\t}\n}", "CodeBleu_score": 52.962590895749365}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t//  std::cout << \"CarlaListenerImpl::on_publication_matched\n\";\n  if (info.current_count_change == 1) {\n    _matched += info.current_count_change;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched += info.current_count_change;\n  } else {\n    std::cerr << \"CarlaListenerImpl::on_publication_matched: invalid count change: \" << info.current_count_change << \"\n\";\n  }\n}", "CodeBleu_score": 73.79786824762694}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t(void)writer;\nif (info.current_count_change == 1) {\n_matched += info.current_count_change;\n_first_connected = true;\n} else if (info.current_count_change == -1) {\n_matched += info.current_count_change;\n} else {\nstd::cerr << \"Listener: on_publication_matched: \" << info.current_count_change << \" is not a valid count change.\" << std::endl;\n}\n}", "CodeBleu_score": 63.5677438587779}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t_matched++;\n\t\t_first_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\t_matched--;\n\t\tif (_matched == 0) {\n\t\t\t_owner->_subscriber->destroy();\n\t\t\t_owner->_subscriber = nullptr;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Subscription matched count change is invalid: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 60.6932152482962}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t_matched++;\n\t\t_first_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\t_matched--;\n\t\tif (_matched == 0) {\n\t\t\t_owner->destroy();\n\t\t}\n\t} else {\n\t\tstd::cerr << \"CarlaEgoVehicleControlSubscriber::on_subscription_matched: \" << \"invalid change count\" << std::endl;\n\t}\n}", "CodeBleu_score": 57.25633115618894}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t_matched++;\n\t\t_first_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\t_matched--;\n\t\tif (_matched == 0) {\n\t\t\t_owner->_subscriber->destroy();\n\t\t\tdelete _owner->_listener;\n\t\t\t_owner->_listener = nullptr;\n\t\t\t_owner->_subscriber = nullptr;\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Error: invalid subscription matched count change: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 61.209648733275}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t(!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor(uint8_t i = 0;i<16;++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor(uint8_t i = 0;i<16;++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 79.96026390350413}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCheck if the key retrieval is defined.\nif (!m_isGetKeyDefined) {\n    return false;\n}\n\n// Check if the key handle is valid.\nif (handle == nullptr) {\n    return false;\n}\n\n// Serialize the key.\neprosima::fastcdr::FastBuffer fastbuffer(m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n// Object that manages the raw buffer.\neprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\n// Serialize encapsulation.\nser.serialize_encapsulation();\n\ntry {\n    // Serialize the object.\n    CarlaCollisionEvent::serializeKey(ser, *static_cast<CarlaCollisionEvent*>(data));\n} catch (eprosima::fastcdr::exception::NotEnoughMemoryException&) {\n    return false;\n}\n\n// Check if the key is defined.\nif (!force_md5 && CarlaCollisionEvent::getKeyMaxCdrSerializedSize() == 16) {\n    // Get key directly from serialized buffer.\n    memcpy(handle->value, m_keyBuffer, 16);\n    return true;\n}\n\n// Get the MD5 hash.\nm_md5.init();\nm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\nm_md5.finalize();\n\nfor (uint8_t i = 0; i < 16; ++i) {\n    handle->value[i] = m_md5.digest[i];\n}\n\nreturn true;\n}", "CodeBleu_score": 63.34158763415445}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\taCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\nif (!m_isGetKeyDefined) {\nreturn false;\n}\n\nserialized_data_t serialized_data;\nif (serialized_data.reserve(CarlaCollisionEvent::getKeyMaxCdrSerializedSize())) {\nCdr ser(serialized_data, ENDIAN);\np_type->serializeKey(ser);\n\nif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\nm_md5.init();\nm_md5.update(serialized_data.data(), serialized_data.size());\nm_md5.finalize();\nfor (uint8_t i = 0; i < 16; ++i) {\nhandle->value[i] = m_md5.digest[i];\n}\n} else {\nmemcpy(handle->value, serialized_data.data(), 16);\n}\n\nreturn true;\n}\n\nreturn false;\n}", "CodeBleu_score": 57.99437651235415}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t", "CodeBleu_score": 2.5978767707221393}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t/    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n//\n//    // Object that manages the raw buffer.\n//    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n//    // Object that serializes the data.\n//    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that manages the raw buffer.\n//    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n//    // Object that serializes the data.\n//    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n//\n//    try\n//    {\n//        // Serialize encapsulation.\n//        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n//        // Serialize the object.\n//        p_type->serialize(ser);\n//    }\n//    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n//    {\n//        return false;\n//    }\n//\n//    // Get the serialized length.\n//    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n//    return true;\n//\n//}", "CodeBleu_score": 8.645095475031745}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE; // Set the payload encapsulation to match the serialized data.\n\n\ttry {\n\t\t// Serialize encapsulation.\n\t\tser.serialize_encapsulation();\n\n\t\t// Serialize the object.\n\t\tp_type->serialize(ser); // Serialize the object:\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length and data.\n\n\treturn true;\n}", "CodeBleu_score": 86.85741478402215}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// return immediately if we already have a target\n    if (g.sysid_target!= 0) {\n\treturn;\n\t}\n\n\t// decode\n\tmavlink_heartbeat_t packet;\n\tmavlink_msg_heartbeat_decode(&msg, &packet);\n\n\t// check if we should track this target\n\tif (packet.type!= MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\t// set the target sysid if not already set\n\tif (g.sysid_target == 0) {\n\t\tg.sysid_target = msg.sysid;\n\t\t// request position and air pressure data streams from the target\n\t\trequest_data_stream(MAV_DATA_STREAM_POSITION, 1000000, 1);\n\t\trequest_data_stream(MAV_DATA_STREAM_EXTRA1, 1000000, 1);\n\t}\n\n\t// flag that we have set a target\n\ttarget_set = true;\n}", "CodeBleu_score": 39.72777210343297}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// return immediately if sysid_target is already set\n    if (g.sysid_target!= 0) {\n        return;\n    }\n\n    // decode\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // return immediately if message type is not one that should be tracked\n    if (packet.type!= MAV_TYPE_GCS) {\n        return;\n    }\n\n    // set sysid_target\n    g.sysid_target = msg.sysid;\n\n    // request position and air pressure data streams\n    request_data_stream(g.sysid_target, MAV_DATA_STREAM_POSITION, 1);\n    request_data_stream(g.sysid_target, MAV_DATA_STREAM_EXTRA3, 1);\n\n    // flag that target has been set\n    g.sysid_target_set = true;\n}", "CodeBleu_score": 44.483701373386744}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// return immediately if sysid_target has already been set\n\tif (g.sysid_target!= 0) {\n\t\treturn;\n\t}\n\n\t// decode\n\tmavlink_heartbeat_t packet;\n\tmavlink_msg_heartbeat_decode(&msg, &packet);\n\n\t// check if the message type is one that should be tracked\n\tif (packet.type!= MAV_TYPE_FIXED_WING && packet.type!= MAV_TYPE_QUADROTOR) {\n\t\treturn;\n\t}\n\n\t// set the sysid to the target\n\tg.sysid_target = msg.sysid;\n\n\t// request position and air pressure data streams from the target\n\trequest_data_stream(g.sysid_target, MAV_DATA_STREAM_POSITION, 1000000);\n\trequest_data_stream(g.sysid_target, MAV_DATA_STREAM_EXTRA1, 1000000);\n\n\t// flag that the target has been set\n\tg.sysid_target_set = true;\n}", "CodeBleu_score": 43.999925658324905}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK_Base::_handle_command_preflight_calibration_baro(msg);\n\n\t// if the result is MAV_RESULT_ACCEPTED, set the flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\tcalibration_needed = true;\n\t}\n\n\t// return the result of the base class handler\n\treturn result;\n}", "CodeBleu_score": 63.20414007160711}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\t// if base class handler returns MAV_RESULT_ACCEPTED, set flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\tbaro_calibration_needed = true;\n\t}\n\t// return result of base class handler\n\treturn result;\n}", "CodeBleu_score": 52.44872579755084}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// if the base class handler returned ACCEPTED, set the flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\t// return the result of the base class handler\n\treturn result;\n}", "CodeBleu_score": 53.421201075083324}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Decode\n\tmavlink_command_int_t packet;\n\tmavlink_msg_command_int_decode(&msg, &packet);\n\n\t// Check if the command is for this component\n\tif (packet.target_component!= tracker.g.companion_id) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for this system\n\tif (packet.target_system!= tracker.g.sysid_my_gcs) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for the servos\n\tif (packet.command!= MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command parameter is 1.0 (arm) or 0 (disarm)\n\tif (packet.param1!= 0.0f && packet.param1!= 1.0f) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Arm or disarm the servos\n\tif (packet.param1 == 1.0f) {\n\t\t// Arm the servos\n\t\t// TODO: Implement arm logic\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Disarm the servos\n\t\t// TODO: Implement disarm logic\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 51.82945784353596}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Decode\n\tmavlink_command_int_t packet_temp = packet;\n\tmavlink_msg_command_int_decode(&packet, &packet_temp);\n\n\t// Check if the command is to arm or disarm the servos\n\tif (packet_temp.param1 == 1.0f) {\n\t\t// Arm the servos\n\t\ttracker.motors.armed(true);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet_temp.param1 == 0.0f) {\n\t\t// Disarm the servos\n\t\ttracker.motors.armed(false);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Unsupported command parameter\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 49.326599451603805}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// check for valid command parameter\n    if (packet.param1 > 1.0f) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    // check for valid sysid and compid\n    if (packet.target_system!= tracker.g.sysid_my_gcs || packet.target_component!= MAV_COMP_ID_ALL) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    // set the arm command\n    tracker.arm_cmd = packet.param1;\n\n    // send the command to the autopilot\n    tracker.gcs().send_message(msg_arm_disarm);\n\n    // return accepted\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 56.51637848608828}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// This function, GCS_Tracker::request_datastream_position, sends a request to start streaming position data for a specified system and component ID.\nIt iterates over the available GCS channels and checks for available payload space.\nIf space is available, it sends a request to start the data stream on the corresponding channel with the specified update rate.\n\tfor (int i = 0; i < MAX_CHANNELS; i++) {\n\t\tif (channels[i].available_payload_space() >= 6) {\n\t\t\tchannels[i].send_message(MSG_REQUEST_DATA_STREAM, 6, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.240404679208886}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < C_MAX_GCS; i++) {\n\t\tif (gcs[i].available_payload_space() > 10) {\n\t\t\tgcs[i].send_message(MSG_REQUEST_DATA_STREAM, sysid, compid, 0, 0, 0, 0, 0, 1000000 / 20);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.47163051551717}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i=0; i<MAX_GCS; i++) {\n\t\tif (gcs[i].available_payload_space() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN) {\n\t\t\tgcs[i].send_message(msg_request_data_stream(sysid, compid, MAV_DATA_STREAM_POSITION, 1, 1));\n\t\t}\n\t}\n}", "CodeBleu_score": 44.35631324256772}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch()!= 0) {\n\t\tef_pitch = ahrs.cos_roll() * pitch + ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n\t\tef_yaw = -ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 62.281997577006585}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch()!= 0) {\n\t\tef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n\t\tef_yaw = ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 64.4881417090279}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tfloat cos_pitch = ahrs.cos_pitch();\n\tif (cos_pitch!= 0) {\n\t\tef_pitch = (ahrs.cos_roll() * pitch - ahrs.sin_roll() * yaw) / cos_pitch;\n\t\tef_yaw = (ahrs.sin_roll() * pitch + ahrs.cos_roll() * yaw) / cos_pitch;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.490741994287035}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t\t// Calculate the yaw and pitch in centidegrees\n\tint yaw = (int)(100.0 * (float)nav_bearing_cd());\n\tint pitch = (int)(100.0 * (float)nav_altitude_cd());\n\n\t// Check if the direction is reversed\n\tif (nav_direction_cd() < 0) {\n\t\tyaw = -yaw;\n\t\tpitch = -pitch;\n\t}\n\n\t// Compute the angle error\n\tint yaw_err = yaw - yaw_target;\n\tint pitch_err = pitch - pitch_target;\n\n\t// Convert the errors from earth frame to body frame\n\tint yaw_err_body = yaw_err * cos(pitch_err * 0.0001) + pitch_err * sin(yaw_err * 0.0001);\n\tint pitch_err_body = pitch_err * cos(yaw_err * 0.0001) - yaw_err * sin(pitch_err * 0.0001);\n\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\tif (nav_valid() || (min_dist_cd() == 0)) {\n\t\t// Update the pitch servo\n\t\tif (pitch_err_body < 0) {\n\t\t\tpitch_target -= (pitch_err_body / pitch_scale);\n\t\t} else {\n\t\t\tpitch_target += (pitch_err_body / pitch_scale);\n\t\t}\n\n\t\t// Update the yaw servo\n\t\tif (yaw_err_body < 0) {\n\t\t\tyaw_target -= (yaw_err_body / yaw_scale);\n\t\t} else {\n\t\t\tyaw_target += (yaw_err_body / yaw_scale);\n\t\t}\n\t}\n\n\t// Update the tracker with the new target yaw and pitch\n\ttracker.update(yaw_target, pitch_target);\n}", "CodeBleu_score": 34.720365474047796}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tif (GPS_update()) {\n\t\tif (GPS_last_message_time!= GPS.last_message_time) {\n\t\t\tGPS_last_message_time = GPS.last_message_time;\n\t\t\tif (GPS.status() >= AP_GPS::GPS_OK_FIX_3D) {\n\t\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t\tif (GPS.status() == AP_GPS::GPS_OK_FIX_3D && GPS.location.lat!= 0 && GPS.location.lng!= 0) {\n\t\t\t\t\t\t// set home location\n\t\t\t\t\t\tahrs.set_home(GPS.location);\n\t\t\t\t\t\t// set ground start countdown to 1\n\t\t\t\t\t\tground_start_countdown = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// reset ground start countdown\n\t\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.781601610932526}, {"code": "void Tracker::update_GPS(void){\n\t// check if the last message time has changed and if the GPS status is at least 3D fix\n\tif (gps.status() >= AP_GPS::GPS_OK_FIX_3D && gps.last_message_time()!= last_gps_message_time) {\n\t\t// update the last message time\n\t\tlast_gps_message_time = gps.last_message_time();\n\n\t\t// check if the ground start countdown has reached one\n\t\tif (ground_start_countdown == 1) {\n\t\t\t// check if the current location is valid\n\t\t\tif (gps.status() >= AP_GPS::GPS_OK_FIX_3D && gps.num_sats() >= 5) {\n\t\t\t\t// set the home location\n\t\t\t\tset_home_location(gps.location());\n\n\t\t\t\t// set the home altitude\n\t\t\t\tset_home_altitude(gps.altitude());\n\n\t\t\t\t// set the ground start countdown to zero\n\t\t\t\tground_start_countdown = 0;\n\n\t\t\t\t// set the ground start flag to true\n\t\t\t\tground_start_flag = true;\n\t\t\t} else {\n\t\t\t\t// reset the ground start countdown\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.7239440575439}, {"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tfloat pitch_min = g.pitch_min;\n\tfloat pitch_max = g.pitch_max;\n\tfloat pitch_trim = g.pitch_trim;\n\tfloat pitch_range = pitch_max - pitch_min;\n\tfloat pitch_mid = pitch_min + pitch_range / 2;\n\n\t// calculate new servo position\n\tfloat new_servo_out = pitch_mid + pitch_trim;\n\tif (pitch > pitch_mid) {\n\t\tnew_servo_out += (pitch - pitch_mid) * g.pitch_onoff_scale;\n\t} else {\n\t\tnew_servo_out -= (pitch_mid - pitch) * g.pitch_onoff_scale;\n\t}\n\n\t// position limit pitch servo\n\tif (new_servo_out <= pitch_min) {\n\t\tnew_servo_out = pitch_min;\n\t}\n\tif (new_servo_out >= pitch_max) {\n\t\tnew_servo_out = pitch_max;\n\t}\n\n\t// rate limit pitch servo\n\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n}", "CodeBleu_score": 44.129262448132955}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// calculate new servo position\n\tfloat new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n\t// position limit pitch servo\n\tif (new_servo_out <= 0) {\n\t\tnew_servo_out = 0;\n\t\tg.pidPitch2Srv.reset_I();\n\t}\n\tif (new_servo_out >= 100) {\n\t\tnew_servo_out = 100;\n\t\tg.pidPitch2Srv.reset_I();\n\t}\n\t// rate limit pitch servo\n\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n\tif (pitch_servo_out_filt_init) {\n\t\tpitch_servo_out_filt.apply(new_servo_out, G_Dt);\n\t} else {\n\t\tpitch_servo_out_filt.reset(new_servo_out);\n\t\tpitch_servo_out_filt_init = true;\n\t}\n}", "CodeBleu_score": 36.485357861594196}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// If the pitch angle is outside the limits, set the servo to the limit\n\tif (pitch > g.pitch_max) {\n\t\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.pitch_max * 100);\n\t} else if (pitch < g.pitch_min) {\n\t\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.pitch_min * 100);\n\t} else {\n\t\t// Otherwise, set the servo to the desired pitch angle\n\t\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, pitch * 100);\n\t}\n}", "CodeBleu_score": 31.82195238297798}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!check_enabled(ARMING_CHECK_BARO)) {\n\t\t// this check has been disabled\n\t\treturn true;\n\t}\n\n\t// check barometer reference\nIf the ARMING_CHECK_BARO is enabled, it checks the barometer reference and compares the barometer altitude with the inertial navigation altitude.\nIf the disparity exceeds a predefined limit, it logs a failure and returns false.\nOtherwise, it returns true.\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check baro altitude\nIf the ARMING_CHECK_BARO is enabled, it checks the barometer reference and compares the barometer altitude with the inertial navigation altitude.\nIf the disparity exceeds a predefined limit, it logs a failure and returns false.\nOtherwise, it returns true.\n\tif (fabsf(copter.barometer->get_altitude() - copter.inertial_nav.get_altitude()) > g.arming_check_baro_limit) {\n\t\tcheck_failed(ARMING_CHECK_BARO, display_failure, \"Baro alt %dmm, INS %dmm\", (int)copter.barometer->get_altitude(), (int)copter.inertial_nav.get_altitude());\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 46.702501279843666}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call base class's barometer_checks\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// if barometer check is not enabled, return true\n\tif (!check_enabled(ARMING_CHECK_BARO)) {\n\t\treturn true;\n\t}\n\n\t// check barometer reference\n\tif (!copter.barometer->healthy()) {\n\t\tcheck_failed(ARMING_CHECK_BARO, display_failure, \"Baro not healthy\");\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tconst float baro_alt = copter.barometer->get_altitude();\n\tif (baro_alt < 0.0f) {\n\t\tcheck_failed(ARMING_CHECK_BARO, display_failure, \"Baro alt below zero\");\n\t\treturn false;\n\t}\n\n\t// check baro altitude is within 10m of inertial altitude\n\tconst float diff = fabsf(baro_alt - copter.ahrs.get_altitude());\n\tif (diff > 10.0f) {\n\t\tcheck_failed(ARMING_CHECK_BARO, display_failure, \"Baro alt %0.1f, INS alt %0.1f\", baro_alt, copter.ahrs.get_altitude());\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 54.785087673369645}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t// if we are using a rangefinder, we don't need to load the terrain database\n\tif (copter.rangefinder_source() == RangeFinder::Source::RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\t// if we are using the terrain database and the RTL altitude type is terrain, we need to load the terrain database\n\tif (copter.rangefinder_source() == RangeFinder::Source::TERRAIN_DATABASE && copter.rtl_altitude_type == RTL_ALTITUDE_TERRAIN) {\n\t\treturn true;\n\t}\n\n\t// otherwise, defer to the base class implementation\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 63.08950088000221}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn copter.ap.terrain_source!= AP_Terrain::SOURCE_RANGEFINDER && (copter.ap.rtl_altitude_type == RTL_ALT_TERRAIN || AP_Arming::terrain_database_required());\n}", "CodeBleu_score": 36.351952237916386}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 19.751022366625605}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// update rate controllers and output to roll, pitch and yaw actuators\n\t//  called at 400hz by default\n\t// update_rate_contoller_loop_time();\n\t// run_rate_controller_loop();\n\t// update_rate_contoller_loop_time();\n\t// run_rate_controller_loop();\n\t// update_rate_contoller_loop_time();\n\t// run_rate_controller_loop();\n\t// update_rate_contoller_loop_time();\n\t// run_rate_controller_loop();\n}", "CodeBleu_score": 3.7146568610244484}, {"code": "void Copter::run_rate_controller(){\n\t\t// set loop time\n\tset_loop_times();\n\n\t// run low-level rate controllers that require only IMU data\n\tattitude_control.rate_controller_run();\n}", "CodeBleu_score": 11.989675650766152}, {"code": "void Copter::run_rate_controller(){\n\t", "CodeBleu_score": 3.377031594114963}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old location does not match the next waypoint\n\tLocation next_wp;\n\tif (!flightmode->get_wp(next_wp)) {\n\t\treturn false;\n\t}\n\n\tif (old_loc!= next_wp) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames are not the same\n\tif (old_loc.alt_frame()!= new_loc.alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\treturn flightmode->set_wp(new_loc);\n}", "CodeBleu_score": 61.85981099379057}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if the waypoint is the same, and the altitude frames are the same, then we can use the old target location\n    if (old_loc.id == new_loc.id && old_loc.alt_frame == new_loc.alt_frame) {\n        return true;\n    }\n\n    // otherwise we need to set the new location as the target\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 44.716944571617724}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old location does not match the next waypoint\n\tif (old_loc!= get_next_WP()) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames do not match\n\tif (old_loc.alt_frame()!= new_loc.alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\treturn set_target_location(new_loc);\n}", "CodeBleu_score": 56.877565993518395}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t", "CodeBleu_score": 6.660368524040123}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t  // if the switch is in the HIGH position, attempt to set the mode\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    } else if (copter.mode.get() == mode) {\n        // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 66.79700597721637}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t", "CodeBleu_score": 6.660368524040123}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat roll_trim = (ahrs.roll_sensor - ahrs.roll_sensor_offset) * radians(g.rc_3.radio_min) / g.rc_3.radio_max;\n\tfloat pitch_trim = (ahrs.pitch_sensor - ahrs.pitch_sensor_offset) * radians(g.rc_4.radio_min) / g.rc_4.radio_max;\n\n\t// add the trim values to the AHRS trim\n\tahrs.set_trim(roll_trim, pitch_trim, 0);\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send a confirmation message\n\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Trim saved\"));\n}", "CodeBleu_score": 45.75159666766774}, {"code": "void Copter::save_trim(){\n\t\t// calculate the trim values from the control inputs of the roll and pitch channels\n\tconst float roll_trim  = (float)g.rc_1.control_in * g.rc_1.radio_max / 1000000.0f;\n\tconst float pitch_trim = (float)g.rc_2.control_in * g.rc_2.radio_max / 1000000.0f;\n\n\t// convert them to radians\n\tconst float roll_trim_rad  = radians(roll_trim);\n\tconst float pitch_trim_rad = radians(pitch_trim);\n\n\t// add them to the AHRS trim\n\tahrs.set_trim(roll_trim_rad, pitch_trim_rad, 0.0f);\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tgcs_send_text_P(MAV_SEVERITY_INFO, PSTR(\"Trim saved\"));\n}", "CodeBleu_score": 44.99343204481067}, {"code": "void Copter::save_trim(){\n\t\t// calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat roll_trim  = (float)channel_roll->radio_in - (float)channel_roll->radio_trim;\n\tfloat pitch_trim = (float)channel_pitch->radio_in - (float)channel_pitch->radio_trim;\n\n\t// convert them to radians\n\troll_trim  = radians(roll_trim);\n\tpitch_trim = radians(pitch_trim);\n\n\t// add them to the AHRS trim\n\tahrs.set_trim(roll_trim, pitch_trim, 0);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LogEvent::TRIM_SAVE);\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 61.498000877305344}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// get velocity\n\tconst Vector3f& vel = copter.inertial_nav.get_velocity();\n\t// get speed squared\n\tfloat speed_squared = vel.length_squared();\n\t// if position is valid and speed exceeds threshold\n\tif (copter.inertial_nav.get_position_valid() && speed_squared > 0) {\n\t\t// update look-ahead yaw angle\n\t\tlook_ahead_yaw_cd = atan2_approx(vel.y, vel.x) * 100;\n\t}\n\t// return look-ahead yaw angle\n\treturn look_ahead_yaw_cd;\n}", "CodeBleu_score": 53.427665377945935}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tVector3f vel = copter.inertial_nav.get_velocity();\n\tfloat speed_sq = vel.length_squared();\n\n\tif (copter.inertial_nav.position_ok() && speed_sq > 0.01f) {\n\t\tlook_ahead_yaw_cd = atan2_approx(vel.y, vel.x) * 100;\n\t}\n\n\treturn look_ahead_yaw_cd;\n}", "CodeBleu_score": 46.963758073826256}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// get velocity\n\tVector2f vel = copter.inertial_nav.get_velocity();\n\t// calculate speed squared\n\tfloat speed_sq = vel.length_squared();\n\t// if position is valid and speed exceeds a minimum threshold\n\tif (copter.inertial_nav.get_position_ok() && speed_sq > 0.1f) {\n\t\t// update look-ahead yaw angle\n\t\tlook_ahead_yaw = atan2f(vel.y, vel.x);\n\t\t// return computed look-ahead yaw angle\n\t\treturn look_ahead_yaw;\n\t}\n\t// return look-ahead yaw angle\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 47.3899853327357}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t", "CodeBleu_score": 3.490344250163065}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// if rudder arming is disabled, return false\n\tif (method == AP_Arming::RUDDER && plane.g.rudder_arming_disabled) {\n\t\treturn false;\n\t}\n\n\t// if throttle is not zero, return false\n\tif (method == AP_Arming::RUDDER && plane.channel_throttle->get_control_in() > 0) {\n\t\treturn false;\n\t}\n\n\t// if arming checks are disabled, return true\n\tif (!check_enabled(ARMING_CHECK_ARM)) {\n\t\treturn true;\n\t}\n\n\t// if the watchdog was armed, bypass checks\n\tif (plane.watchdog.armed()) {\n\t\treturn true;\n\t}\n\n\t// call parent class checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.77854627372418}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tbool ret = true;\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (plane.g.rudder_arm == 0 || plane.channel_throttle->get_pwm()!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (check_enabled(ARMING_CHECK_DISABLED) || plane.watchdog.armed()) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 46.53307719413261}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// call parent class arm function\n\tif (!AP_Arming::arm(method, do_arming_checks)) {\n\t\treturn false;\n\t}\n\n\t// if we are arming, set home location\n\tif (method == AP_Arming::Method::SWITCH || method == AP_Arming::Method::RUDDER) {\n\t\t// set home location\n\t\tgcs().set_home_location();\n\n\t\t// set home location in AHRS system\n\t\tAP::ahrs().set_home(gcs().get_home_location());\n\n\t\t// update current location\n\t\tAP::ahrs().set_origin_to_current_position();\n\n\t\t// update soft armed state\n\t\tchange_arm_state();\n\n\t\t// set delay arming flag\n\t\tset_delay_arming_flag();\n\n\t\t// send status text\n\t\tgcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 55.610125997606794}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_failure = true;\n\t\t\tAP_Notify::flags.arming_failure_flags |= AP_Notify::ARMED_DISARM_BUTTON_REQUIRED;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.24368970286172}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// if we are already armed, just return true\n    if (is_armed()) {\n        return true;\n    }\n\n    // if we don't have a disarm function, display a failure message if requested and return false\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.arming_failure = true;\n        }\n        return false;\n    }\n\n    // perform the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.09319575141247}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 29.592044536541835}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat yaw_rad = ahrs.yaw_sensor * 0.01745329252f;\n\tfloat cos_yaw = cosf(yaw_rad);\n\tfloat sin_yaw = sinf(yaw_rad);\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 54.716652317415814}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// Rotate the vector from the body frame to the North-East frame using the yaw angle from the AHRS\n\tfloat cos_yaw = cosf(ahrs.yaw_sensor);\n\tfloat sin_yaw = sinf(ahrs.yaw_sensor);\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\n\t// Update the x and y coordinates with the rotated values\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 55.200227264210774}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat yaw = ahrs.yaw;\n\tfloat yaw_cos = cosf(yaw);\n\tfloat yaw_sin = sinf(yaw);\n\tfloat ne_x = yaw_cos * x + yaw_sin * y;\n\tfloat ne_y = -yaw_sin * x + yaw_cos * y;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 54.30469271360465}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle is within acceptable range\n\tif (packet.param1 < -180.0f || packet.param1 > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the param4 value is within acceptable range\n\tif (packet.param4 < 0.0f || packet.param4 > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\tsub.mode_auto.set_auto_yaw_heading(packet.param1, packet.param4);\n\n\t// Return MAV_RESULT_ACCEPTED\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.723333174909506}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 < 0.0f || packet.param4 > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tsub.mode_auto.set_auto_yaw_heading(packet.param4);\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 32.049194609274004}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\t// convert bearing from -18000->18000 to 0->360\n\t\tuint16_t bearing = (sub.pos_control.get_bearing_cd() + 1800000) % 36000;\n\t\treturn bearing / 200;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 78.13418819574625}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn 0.5f * (sub.pos_control.get_wp_bearing_cd() + 18000);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 76.13817983328681}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn (sub.pos_control.get_bearing_cd() + 18000) / 200;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 79.06519823215913}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\ttime_us: AP_HAL::micros64(),\n\t\t\tid: (uint8_t)id,\n\t\t\tdata_value: value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 80.52317053593573}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\ttime_us : AP_HAL::micros64(),\n\t\t\tid : (uint8_t)id,\n\t\t\tdata_value : value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 90.9941031113905}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\ttime_us : AP_HAL::micros64(),\n\t\t\tid : (uint8_t)id,\n\t\t\tdata_value : value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 90.9941031113905}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\n}", "CodeBleu_score": 3.79541649619327}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (_ahrs->get_home_position_set()) {\n\t\treturn;\n\t}\n\n\tif (_armed) {\n\t\t// set home to current location\n\t\t_ahrs->set_home_position();\n\t} else {\n\t\t// try to set home to current EKF location\n\t\t_ahrs->set_home_position_to_ekf_origin();\n\t}\n}", "CodeBleu_score": 26.574187246927277}, {"code": "void Sub::update_home_from_EKF(){\n\t\n}", "CodeBleu_score": 3.79541649619327}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\n    // if motors are not armed, just set throttle to zero and exit\n    if (!motors_armed) {\n        sub.set_throttle(0);\n        spool_state = SPOOL_UNLIMITED_THROTTLE;\n        attitude_controller->relax();\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    spool_state = SPOOL_UNLIMITED_THROTTLE;\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate_desired_radps = pilot_roll_rate_input_radps;\n    float pitch_rate_desired_radps = pilot_pitch_rate_input_radps;\n    float yaw_rate_desired_radps = pilot_yaw_rate_input_radps;\n\n    // run attitude controller with these rates\n    attitude_controller->run(roll_rate_desired_radps, pitch_rate_desired_radps, yaw_rate_desired_radps);\n\n    // output pilot's throttle input without angle boost\n    sub.set_throttle(pilot_throttle_input_pct);\n\n    // set forward and lateral motor inputs based on pilot controls\n    sub.set_motor_inputs_from_pilot_controls();\n}", "CodeBleu_score": 41.4647664677562}, {"code": "void ModeAcro::run(){\n\t\n    // if motors are not armed, set throttle to zero and exit\n    if (!motors_armed) {\n        // set throttle to zero\n        sub.set_throttle(0);\n\n        // relax attitude controllers\n        attitude_controller->relax();\n\n        // exit\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    spool_state = SpoolState::UNLIMITED_THROTTLE;\n\n    // convert pilot inputs to desired body frame rates\n    float desired_roll_rate = pilot_input.roll * (1.0f / 1000.0f) * sub.get_max_roll_rate();\n    float desired_pitch_rate = pilot_input.pitch * (1.0f / 1000.0f) * sub.get_max_pitch_rate();\n    float desired_yaw_rate = pilot_input.yaw * (1.0f / 1000.0f) * sub.get_max_yaw_rate();\n\n    // run attitude controller with desired rates\n    attitude_controller->run(desired_roll_rate, desired_pitch_rate, desired_yaw_rate);\n\n    // set forward and lateral motor inputs based on pilot controls\n    sub.set_forward_motor_input(pilot_input.forward);\n    sub.set_lateral_motor_input(pilot_input.lateral);\n\n    // set throttle input\n    sub.set_throttle(pilot_input.throttle);\n}", "CodeBleu_score": 45.225968481749085}, {"code": "void ModeAcro::run(){\n\t\n    if (!motors->armed()) {\n        // set throttle to zero\n        motors->set_throttle(0.0f);\n\n        // set spool state to unlimited\n        motors->set_spool_state(Motor::SPOOL_UNLIMITED);\n\n        // relax attitude controllers\n        attitude_control->relax();\n\n        // exit\n        return;\n    }\n\n    // set spool state to unlimited\n    motors->set_spool_state(Motor::SPOOL_UNLIMITED);\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate_desired = pilot_input->get_roll_rate_desired();\n    float pitch_rate_desired = pilot_input->get_pitch_rate_desired();\n    float yaw_rate_desired = pilot_input->get_yaw_rate_desired();\n\n    // run attitude controller with desired rates\n    attitude_control->run(roll_rate_desired, pitch_rate_desired, yaw_rate_desired);\n\n    // set throttle to pilot's throttle input without angle boost\n    motors->set_throttle(pilot_input->get_throttle_unboosted());\n\n    // set forward and lateral motor inputs based on pilot controls\n    motors->set_forward_lateral_inputs(pilot_input->get_forward_input(), pilot_input->get_lateral_input());\n}", "CodeBleu_score": 47.05867364965746}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// set to position control mode\n    wp_control.set_mode(WP_LOITER_POSITION);\n\n    // get stopping point\n    Vector3f stopping_point = get_stopping_point();\n\n    // set it as the waypoint destination\n    wp_control.set_destination(stopping_point);\n\n    // initialize yaw using the default auto yaw mode\n    auto_yaw_mode = get_default_auto_yaw_mode(false);\n    wp_control.set_auto_yaw_mode(auto_yaw_mode);\n}", "CodeBleu_score": 42.988267207031804}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set to position control mode\n    set_mode(GUIDED);\n\n    // set the stopping point as the waypoint destination\n    wp_nav.set_wp_from_position(sub.get_position());\n\n    // initialize the yaw using the default auto yaw mode\n    auto_yaw_mode = get_default_auto_yaw_mode(false);\n    auto_yaw_init();\n}", "CodeBleu_score": 18.35635570197507}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_Velocity;\n\n\t// set vertical velocity limits\n\tsub.wp_nav.set_vertical_velocity_limit_cms(g.guided_velz_max);\n\tsub.wp_nav.set_vertical_acceleration_limit_cms(g.guided_velz_accel);\n\n\t// initialise vertical velocity controller\n\tsub.wp_nav.init_velocity_controller_z();\n\n\t// initialise horizontal velocity controller\n\tsub.wp_nav.init_velocity_controller_xy();\n\n\t// initialise yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 40.34631428646556}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_Velocity;\n\n\t// initialise vertical velocity controller\n\t// set maximum vertical speeds and acceleration using pilot-defined parameters\n\tfloat max_climb_rate_cms = g.pilot_velocity_z_max * 100.0f;\n\tfloat max_climb_accel_cms = g.pilot_velocity_z_accel * 100.0f;\n\tfloat max_sink_rate_cms = g.pilot_velocity_z_max * 100.0f;\n\tfloat max_sink_accel_cms = g.pilot_velocity_z_accel * 100.0f;\n\tsub.vel_controller_v.set_max_climb_rate(max_climb_rate_cms);\n\tsub.vel_controller_v.set_max_climb_accel(max_climb_accel_cms);\n\tsub.vel_controller_v.set_max_sink_rate(max_sink_rate_cms);\n\tsub.vel_controller_v.set_max_sink_accel(max_sink_accel_cms);\n\n\t// initialise horizontal velocity controller\n\t// set maximum horizontal speeds and acceleration using pilot-defined parameters\n\tfloat max_speed_xy_cms = g.pilot_velocity_xy_max * 100.0f;\n\tfloat max_accel_xy_cms = g.pilot_velocity_xy_accel * 100.0f;\n\tsub.vel_controller_h.set_max_speed_xy(max_speed_xy_cms);\n\tsub.vel_controller_h.set_max_accel_xy(max_accel_xy_cms);\n\n\t// initialise yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 44.94481508482677}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_Velocity;\n\n\t// initialise vertical speeds\n\tsub.wp_nav.set_vertical_velocity_cms(g.guided_velz_max, g.guided_velz_max_up, g.guided_velz_max_dn, g.guided_velz_accel);\n\n\t// initialise horizontal speeds\n\tsub.wp_nav.set_horizontal_velocity_cms(g.guided_velxy_max, g.guided_velxy_accel);\n\n\t// initialise yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 41.064105806572606}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check for timeout\n    if (guided_limit.timeout_ms!= 0 && AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check for altitude limits\n    if (guided_limit.alt_min_cm!= 0.0f && inertial_nav.get_altitude_cm() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm!= 0.0f && inertial_nav.get_altitude_cm() > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // check for horizontal movement limit\n    if (guided_limit.horiz_max_cm!= 0.0f) {\n        // calculate distance moved\n        Vector2f pos_delta = guided_limit.start_pos.xy() - inertial_nav.get_position_neu_cm().xy();\n        float horiz_dist_moved = pos_delta.length();\n        if (horiz_dist_moved > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // no limits breached\n    return false;\n}", "CodeBleu_score": 66.6875637751498}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check timeout\n\tif (guided_limit.timeout_ms > 0 && AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// check altitude limits\n\tfloat altitude_cm = inertial_nav.get_altitude_cm();\n\tif (guided_limit.alt_min_cm > 0.0f && altitude_cm < guided_limit.alt_min_cm) {\n\t\treturn true;\n\t}\n\tif (guided_limit.alt_max_cm > 0.0f && altitude_cm > guided_limit.alt_max_cm) {\n\t\treturn true;\n\t}\n\n\t// check horizontal limits\n\tVector2f current_pos = inertial_nav.get_position_xy_cm();\n\tVector2f delta_pos = current_pos - guided_limit.start_pos;\n\tfloat horiz_distance_moved = delta_pos.length();\n\tif (guided_limit.horiz_max_cm > 0.0f && horiz_distance_moved > guided_limit.horiz_max_cm) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 59.98839610864985}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check timeout\n    if (guided_limit.timeout_ms > 0 && AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check altitude\n    if (guided_limit.alt_min_cm > 0.0f && inertial_nav.get_altitude_cm() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm > 0.0f && inertial_nav.get_altitude_cm() > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // check horizontal distance\n    if (guided_limit.horiz_max_cm > 0.0f && inertial_nav.get_distance_to_home_cm() > guided_limit.horiz_max_cm) {\n        return true;\n    }\n\n    // no limit breached\n    return false;\n}", "CodeBleu_score": 53.40424082633531}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (hal.util->millis() - last_do_motor_test_ms > 2000) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test timeout\\\");\n\t\tap.motor_test = false;\n\t\tmotors.armed(false);\n\t\tlast_do_motor_test_fail_ms = hal.util->millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 34.193511954888514}, {"code": "bool Sub::verify_motor_test(){\n\t\t// The motor test will fail if the interval between received\n\t// MAV_CMD_DO_SET_MOTOR requests exceeds a timeout period\n\t// Returns true if it is ok to proceed with new style motor test\n\tif (AP_HAL::millis() - last_do_motor_test_ms > 1000) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n\t\tap.motor_test = false;\n\t\tmotors.armed(false);\n\t\tlast_do_motor_test_fail_ms = AP_HAL::millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.85204265162695}, {"code": "bool Sub::verify_motor_test(){\n\t\n    static uint32_t last_motor_test_ms = 0;\n    uint32_t tnow = AP_HAL::millis();\n\n    // if we have not received a motor test request in 5 seconds, fail the test\n    if (tnow > last_motor_test_ms + 5000) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test timeout\\\");\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 50.395969144217624}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target_cd = wp_nav.get_roll_target_cd();\n\tfloat pitch_target_cd = wp_nav.get_pitch_target_cd();\n\tfloat roll_max_cd = wp_nav.get_roll_max_cd();\n\tfloat pitch_max_cd = wp_nav.get_pitch_max_cd();\n\n\t// constrain roll and pitch targets to max angle\n\troll_target_cd = constrain_int32(roll_target_cd, -roll_max_cd, roll_max_cd);\n\tpitch_target_cd = constrain_int32(pitch_target_cd, -pitch_max_cd, pitch_max_cd);\n\n\t// normalize roll and pitch targets\n\tlateral_out = (float)roll_target_cd / roll_max_cd;\n\tforward_out = (float)pitch_target_cd / pitch_max_cd;\n}", "CodeBleu_score": 45.38057594723271}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat lateral = wp_nav.get_desired_roll();\n\tfloat forward = wp_nav.get_desired_pitch();\n\tfloat max_angle = 4500.0f;\n\tlateral = constrain_float(lateral, -max_angle, max_angle);\n\tforward = constrain_float(forward, -max_angle, max_angle);\n\tlateral_out = lateral / max_angle;\n\tforward_out = forward / max_angle;\n}", "CodeBleu_score": 45.10632441958058}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t", "CodeBleu_score": 3.4981965412920477}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// check if the barometer is connected\n\tif (!baro) {\n\t\treturn;\n\t}\n\n\t// read the barometer data\n\tbaro->read_data();\n\n\t// update the barometer calibration\n\tif (baro->get_altitude() > 0) {\n\t\tbaro->calibrate();\n\t}\n\n\t// update the sensor health\n\tif (depth_sensor) {\n\t\tdepth_sensor->update_health(baro->get_health());\n\t}\n}", "CodeBleu_score": 55.09361146046674}, {"code": "void Sub::read_barometer(){\n\t\t// Read barometer\n\tbarometer.read();\n\n\t// Update barometer calibration if above zero\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.calibrate();\n\t}\n\n\t// Update sensor health if depth sensor is present\n\tif (depth_sensor.is_present()) {\n\t\tdepth_sensor.set_health(barometer.get_health());\n\t}\n}", "CodeBleu_score": 57.74022033727305}, {"code": "void Sub::read_barometer(){\n\t\tif(barometer_present) {\n\t\t// read barometer data\n\t\tbarometer.read();\n\t\t// update barometer calibration if altitude is above zero\n\t\tif(barometer.altitude > 0) {\n\t\t\tbarometer.calibrate();\n\t\t}\n\t\t// update barometer health status based on depth sensor health\n\t\tif(depth_sensor_present) {\n\t\t\tif(depth_sensor.health_status == 0) {\n\t\t\t\tbarometer.health_status = 0;\n\t\t\t} else {\n\t\t\t\tbarometer.health_status = 1;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 53.078835582634454}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t*\n * If inertial navigation is not available, it returns false.\n */\nif (!ahrs.have_position()) {\n\n/*\n * If the motors are disarmed, it accepts a predicted horizontal position.\n */\nif (motors.armed()) {\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\nif (!ahrs.ekf_pos_is_const()) {\n\n/*\n * It returns true if these conditions are met.\n */\nreturn true;\n\n/*\n * If inertial navigation is not available, it returns false.\n */\n} else {\n\n/*\n * If the motors are disarmed, it accepts a predicted horizontal position.\n */\nreturn false;\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\n}\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\n} else {\n\n/*\n * If inertial navigation is not available, it returns false.\n */\nreturn false;\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\n}\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\n}\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\nreturn false;\n\n/*\n * If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n */\n}", "CodeBleu_score": 36.93894652793126}, {"code": "bool Sub::ekf_position_ok(){\n\t/ return false if ekf failsafe has triggered\n\tif (failsafe.ekf) {\n\t\treturn false;\n\t}\n\n\t// check ekf position estimate\n\treturn (ekf_position_ok() || optflow_position_ok());\n}", "CodeBleu_score": 24.584057374837123}, {"code": "bool Sub::ekf_position_ok(){\n\t/ return false if ekf failsafe has triggered\n\tif (failsafe.ekf) {\n\t\treturn false;\n\t}\n\n\t// check ekf position estimate\n\treturn (ekf.position_ok() || optflow.position_ok());\n}", "CodeBleu_score": 26.288577044993044}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// check if we have a valid position\n\tif (!ahrs.get_gps().status_flags.position_ok) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"GPS position invalid\");\n\t\treturn false;\n\t}\n\n\t// check if we have a valid velocity\n\tif (!ahrs.get_gps().status_flags.velocity_ok) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"GPS velocity invalid\");\n\t\treturn false;\n\t}\n\n\t// check if we have a valid AHRS system\n\tif (!ahrs.healthy()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS system invalid\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (ahrs.get_ekf_failsafe()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check parent class's gps checks\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 48.85627041187403}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t", "CodeBleu_score": 1.9477481621875286}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// check if AHRS is healthy\n\tif (!ahrs->healthy) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not healthy\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (ahrs->get_ekf_failsafe()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (!ahrs->get_position_ok()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"Position estimate invalid\");\n\t\treturn false;\n\t}\n\n\t// call parent class's gps checks\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 44.89290260802675}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t perform arming checks if required\n    if (do_arming_checks &&!arm_checks(method)) {\n        return false;\n    }\n\n    // set the armed flag\n    armed = true;\n\n    // set the arming method\n    arming_method = method;\n\n    // set the last_arm_attempt_ms timer\n    last_arm_attempt_ms = AP_HAL::millis();\n\n    // set the last_disarm_attempt_ms timer\n    last_disarm_attempt_ms = 0;\n\n    // set the armed_time_ms timer\n    armed_time_ms = AP_HAL::millis();\n\n    // set the armed_time_ms timer\n    disarmed_time_ms = 0;\n\n    // call the event\n    AP::events.arming_state.trigger();\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_status_text();\n\n    return true;\n}", "CodeBleu_score": 41.93703008754185}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t check if we are already armed\n    if (armed) {\n        return true;\n    }\n\n    // check if we are in a mode that doesn't allow arming\n    if (rover.control_mode->get_mode() == AP_Rover_ControlMode::MODE_STABILIZE) {\n        check_failed(ARMING_CHECK_MODE, true, \\\"Cannot arm in stabilize mode\\\");\n        return false;\n    }\n\n    // run pre-arm checks\n    if (do_arming_checks &&!pre_arm_checks(true)) {\n        return false;\n    }\n\n    // run arm checks\n    if (do_arming_checks &&!arm_checks(method)) {\n        return false;\n    }\n\n    // set home location\n    rover.set_home();\n\n    // initialize simple mode heading\n    rover.set_simple_mode_heading();\n\n    // record home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.set_home_heading();\n    }\n\n    // set armed status\n    armed = true;\n    update_soft_armed();\n\n    // send arm/disarm status text\n    if (method == AP_Arming::Method::ARMING_SWITCH) {\n        AP::notify_arming_status(true);\n    } else {\n        AP::notify_arming_status(true, method);\n    }\n\n    return true;\n}", "CodeBleu_score": 48.44183320886631}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// if arming checks are disabled, we are always armed\n\tif (checks_to_perform == 0) {\n\t\treturn true;\n\t}\n\n\t// perform arming checks\n\tif (do_arming_checks &&!arm_checks(method)) {\n\t\treturn false;\n\t}\n\n\t// set armed state\n\tarmed = true;\n\n\t// update soft armed status\n\tupdate_soft_armed();\n\n\t// send arm/disarm status text\n\tsend_arm_disarm_status_text();\n\n\t// set armed event\n\tEvents::trigger(Events::Armed);\n\n\t// return success\n\treturn true;\n}", "CodeBleu_score": 43.75346993806916}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\t// If charging is allowed but should not continue, it disables charging and records the time.\n\tif (charging_allowed &&!checkShouldCharge()) {\n\t\tcharging_enabled = false;\n\t\tcharging_enabled_time = millis();\n\t}\n\n\t// If charging is not allowed, it retries enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n\tif (!charging_allowed && (millis() - charging_enabled_time) > 10000) {\n\t\tif (checkShouldCharge()) {\n\t\t\tcharging_enabled = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.695136325392507}, {"code": "void updateChargingEnabled(){\n\t\n#ifdef USB_DEBUG\n    DEBUG_SERIAL.println(\"updateChargingEnabled\");\n#endif\n\n    if (charging_allowed) {\n        if (charging_enabled) {\n            // charging is allowed and already enabled\n            if (!checkShouldCharge()) {\n                // charging should not continue, disable it\n                charging_enabled = false;\n                charging_enabled_time = millis();\n#ifdef USB_DEBUG\n                DEBUG_SERIAL.println(\"Disabling charging\");\n#endif\n                p.setChargingEnabled(false);\n            }\n        } else {\n            // charging is allowed but not enabled\n            if (checkShouldCharge()) {\n                // charging should continue, enable it\n                charging_enabled = true;\n                charging_enabled_time = millis();\n#ifdef USB_DEBUG\n                DEBUG_SERIAL.println(\"Enabling charging\");\n#endif\n                p.setChargingEnabled(true);\n            }\n        }\n    } else {\n        // charging is not allowed\n        if (charging_enabled) {\n            // charging is enabled, but not allowed\n            if (millis() - charging_enabled_time > 10000) {\n                // charging has been enabled for more than 10s, disable it\n                charging_enabled = false;\n                charging_enabled_time = millis();\n#ifdef USB_DEBUG\n                DEBUG_SERIAL.println(\"Disabling charging\");\n#endif\n                p.setChargingEnabled(false);\n            }\n        } else {\n            // charging is not enabled, but not allowed\n            if (millis() - charging_enabled_time > 10000) {\n                // charging has been disabled for more than 10s, enable it\n                charging_enabled = true;\n                charging_enabled_time = millis();\n#ifdef USB_DEBUG\n                DEBUG_SERIAL.println(\"Enabling charging\");\n#endif\n                p.setChargingEnabled(true);\n            }\n        }\n    }\n}", "CodeBleu_score": 53.21888348525694}, {"code": "void updateChargingEnabled(){\n\t#ifdef ENABLE_CHARGING\n    if (charging_allowed) {\n        if (!charging_enabled) {\n            // Charging is not allowed, but it should be, enable it\n            p.enableCharging();\n            charging_enabled = true;\n            charging_disabled_millis = 0;\n        }\n    } else {\n        if (charging_enabled) {\n            // Charging is allowed, but it should not be, disable it\n            p.disableCharging();\n            charging_enabled = false;\n            charging_disabled_millis = millis();\n        } else {\n            // Charging is not allowed, but it should not be either, check if it's time to enable it again\n            if (millis() - charging_disabled_millis > 10000) {\n                // It's been 10 seconds since we disabled charging, try enabling it again\n                p.enableCharging();\n                charging_enabled = true;\n            }\n        }\n    }\n#endif\n}", "CodeBleu_score": 50.82347011514378}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ROS_running && size >= 4) {\n\t\tuint32_t crc = crc32(message, size);\n\t\tmemcpy(((uint8_t *) message) + size, &crc, 4);\n\t\tpacketSerial.send((uint8_t *) message, size + 4);\n\t}\n}", "CodeBleu_score": 37.282145222919496}, {"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ENABLE_ROS\n    if (ROS_running && size >= 4) {\n        uint32_t crc = crc32(message, size);\n        memcpy(message + size, &crc, sizeof(crc));\n        size += sizeof(crc);\n        packetSerial.send(message, size);\n    }\n#else\n    packetSerial.send(message, size);\n#endif\n}", "CodeBleu_score": 41.82562217257302}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ROS_running && size >= 4) {\n\t\tuint8_t *msg = (uint8_t *) message;\n\t\tuint16_t crc = 0;\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tcrc = _crc_xmodem_update(crc, msg[i]);\n\t\t}\n\t\tmsg[size] = crc & 0xFF;\n\t\tmsg[size + 1] = (crc >> 8) & 0xFF;\n\t\tpacketSerial.send(msg, size + 2);\n\t}\n}", "CodeBleu_score": 57.33236550737679}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tif (soundSerial.begin(9600)) {\n\t\tsoundSerial.clear();\n\t\tmyMP3.begin(soundSerial);\n\t\tthis->anzSoundfiles = myMP3.numberOfSoundFiles();\n\t\tif (this->anzSoundfiles > 0) {\n\t\t\tthis->sound_available = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.35628130816241}, {"code": "bool MP3Sound::begin(){\n\t\n//    soundSerial.begin(9600);\n    soundSerial.begin(250000);\n    soundSerial.flush();\n\n    myMP3.begin(soundSerial);\n\n    myMP3.volume(15);\n\n    myMP3.EQ(DFPLAYER_EQ_NORMAL);\n\n    this->anzSoundfiles = myMP3.readFileCounts();\n\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n        return true;\n    } else {\n        return false;\n    }\n\n}", "CodeBleu_score": 55.163527681582636}, {"code": "bool MP3Sound::begin(){\n\t\n#ifdef DEBUG\n    Serial.println(F(\"MP3Sound::begin\"));\n#endif\n\n    soundSerial.begin(9600);\n    soundSerial.flush();\n\n    myMP3.begin(soundSerial);\n\n    myMP3.volume(25);\n\n    this->anzSoundfiles = myMP3.numberOfFiles();\n\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n\n    return this->sound_available;\n}", "CodeBleu_score": 56.00970273502968}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || playing) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\tint soundNr = active_sounds.back();\n\t\tactive_sounds.pop_back();\n\t\tmyMP3.play(soundNr);\n\t\tplaying = true;\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 50.757440496324804}, {"code": "int MP3Sound::processSounds(){\n\t\tint number_of_sounds = sounds2play();\n\tif (number_of_sounds == 0 || playing) {\n\t\treturn number_of_sounds;\n\t}\n\tint sound_to_play = active_sounds.back();\n\tactive_sounds.pop_back();\n\tmyMP3.play(sound_to_play);\n\tplaying = true;\n\treturn number_of_sounds - 1;\n}", "CodeBleu_score": 50.763504648022504}, {"code": "int MP3Sound::processSounds(){\n\t\t// Check if there are any active sounds\n\tif (active_sounds.empty()) {\n\t\treturn 0;\n\t}\n\n\t// Check if an MP3 is currently playing\n\tif (playing) {\n\t\treturn active_sounds.size();\n\t}\n\n\t// Retrieve and play the last sound from the active sounds list\n\tint soundNr = active_sounds.back();\n\tactive_sounds.pop_back();\n\tmyMP3.play(soundNr);\n\tplaying = true;\n\n\t// Return the updated number of active sounds\n\treturn active_sounds.size();\n}", "CodeBleu_score": 51.769392036913295}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    // clean up any existing memory-mapped file\n    if (c->file_mapping_handle!= NULL) {\n      CloseHandle(c->file_mapping_handle);\n      c->file_mapping_handle = NULL;\n    }\n    if (c->file_handle!= NULL) {\n      CloseHandle(c->file_handle);\n      c->file_handle = NULL;\n    }\n    if (c->file_view!= NULL) {\n      UnmapViewOfFile(c->file_view);\n      c->file_view = NULL;\n    }\n\n    // create a new memory-mapped file\n    char filename[1024];\n    request_read_string(r, filename, sizeof(filename));\n    c->file_handle = CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (c->file_handle == INVALID_HANDLE_VALUE) {\n      fprintf(stderr, \\\"Could not create memory-mapped file %s\\\n\\\", filename);\n      return true;\n    }\n    c->file_mapping_handle = CreateFileMapping(c->file_handle, NULL, PAGE_READWRITE, 0, 0, NULL);\n    if (c->file_mapping_handle == NULL) {\n      fprintf(stderr, \\\"Could not create memory-mapped file %s\\\n\\\", filename);\n      return true;\n    }\n    c->file_view = MapViewOfFile(c->file_mapping_handle, FILE_MAP_WRITE, 0, 0, 0);\n    if (c->file_view == NULL) {\n      fprintf(stderr, \\\"Could not create memory-mapped file %s\\\n\\\", filename);\n      return true;\n    }\n\n    // copy image data to the memory-mapped file\n    int size = c->width * c->height * 4;\n    memcpy(c->file_view, c->image->image, size);\n    return true;\n  } else {\n    // command not handled\n    return false;\n  }\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 41.61087447358477}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t", "CodeBleu_score": 6.48713104527464}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t", "CodeBleu_score": 6.48713104527464}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tnt height = -1;\nrobot_mutex_lock();\nAbstractCamera *ac = d->pdata;\nif (ac)\nheight = ac->height;\nrobot_mutex_unlock();\nreturn height;\n}", "CodeBleu_score": 66.19439541923501}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock();\n\tint height = -1;\n\tAbstractCamera *ac = d->pdata;\n\tif (ac)\n\t\theight = ac->height;\n\trobot_mutex_unlock();\n\treturn height;\n}", "CodeBleu_score": 67.24269038918153}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock();\n\tconst AbstractCamera *c = d->pdata;\n\tint height = -1;\n\tif (c)\n\t\theight = c->height;\n\trobot_mutex_unlock();\n\treturn height;\n}", "CodeBleu_score": 62.50557781422934}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tt result = 0;\n\trobot_mutex_lock();\n\tconst Accelerometer *dev = accelerometer_get_struct(tag);\n\tif (dev)\n\t\tresult = dev->sampling_period;\n\telse\n\t\tfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n\trobot_mutex_unlock();\n\treturn result;\n}", "CodeBleu_score": 55.801592995731}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t result = 0;\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn result;\n}", "CodeBleu_score": 67.36297258690965}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t", "CodeBleu_score": 2.4733389476382044}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\n}", "CodeBleu_score": 3.259132699907477}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *result = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(result);\n\tfree(result);\n\treturn dms;\n}", "CodeBleu_score": 38.348527263286094}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t#ifdef _WIN32\n  return string(wb_gps_convert_to_degrees_minutes_seconds(decimalDegree));\n#else\n  return string(wb_gps_convert_to_degrees_minutes_seconds(decimalDegree)).append(\"\\0\");\n#endif\n}", "CodeBleu_score": 38.25075634540131}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\n\tconst dReal *const s = ((dxBox*) g)->side;\n\tdReal dx = x - g->posr.pos[0];\n\tdReal dy = y - g->posr.pos[1];\n\tdReal dz = z - g->posr.pos[2];\n\tdReal dist = dInfinity;\n\tint closestAxis = -1;\n\tfor (int i = 0; i < 3; i++) {\n\t\tdReal d = s[i] - dFabs(g->posr.R[i][0] * dx + g->posr.R[i][1] * dy + g->posr.R[i][2] * dz);\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tclosestAxis = i;\n\t\t}\n\t}\n\tif (closestAxis == -1) {\n\t\tdSetZero (plane);\n\t\treturn;\n\t}\n\tdReal n[3];\n\tn[0] = g->posr.R[closestAxis][0];\n\tn[1] = g->posr.R[closestAxis][1];\n\tn[2] = g->posr.R[closestAxis][2];\n\tif (g->posr.R[closestAxis][0] * dx + g->posr.R[closestAxis][1] * dy + g->posr.R[closestAxis][2] * dz < 0.0) {\n\t\tn[0] = -n[0];\n\t\tn[1] = -n[1];\n\t\tn[2] = -n[2];\n\t}\n\tplane[0] = n[0];\n\tplane[1] = n[1];\n\tplane[2] = n[2];\n\tplane[3] = -dCalcVectorDot3 (n, g->posr.pos);\n}", "CodeBleu_score": 42.039371028375854}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#ifdef dNODEBUG\n  //dAASSERT (box->body);\n  //dAASSERT (flags & (dxImmersionEnabled | dxImmersionOutlineDisabled));\n#endif\n  sBoxImmersionData data(box, fluidPlane, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.546961362394356}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#ifdef dDEBUG\n  dIASSERT (box->body);\n  dIASSERT (flags & dxImmersionFlagsMask);\n#endif\n\n  sBoxImmersionData immersionData (box, fluidPlane, immersion, flags);\n  return immersionData.performImmersionChecking();\n}", "CodeBleu_score": 58.84379740661768}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#ifdef DEBUG\n  dAASSERT (box->body);\n  dAASSERT (flags >= 0 && flags < dxImmersionFlags);\n#endif\n  sBoxImmersionData data (box, fluidPlane, immersion, flags);\n  return data.performImmersionChecking ();\n}", "CodeBleu_score": 58.57279672162123}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tdxBox *const box = (dxBox *) o1;\n\tdxCapsule *const capsule = (dxCapsule *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n\treturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.15282584244419}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t#if 0\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  dxBox *const box = (dxBox *) o1;\n  dxCapsule *const capsule = (dxCapsule *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n#endif\n  return 0;\n}", "CodeBleu_score": 95.73363848149098}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.04166660842034}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.04166660842034}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn volume;\n}", "CodeBleu_score": 90.41849111478571}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst dReal singularityStart = singularityFactor * sinTheta1;\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tdReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\tx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\n\treturn x / volume;\n}", "CodeBleu_score": 65.63277876832706}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\tx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n\treturn x / volume;\n}", "CodeBleu_score": 65.57904207500475}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\tx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n\treturn x * m_fRadius / volume;\n}", "CodeBleu_score": 66.05631294507421}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t dIASSERT ((flags & NUMI_MASK) >= 1);\n dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n dContactGeom c[1];\n const int collision = dCollideTrimeshCapsule(o2, o1, 1, c, sizeof(dContact));\n if (collision == 0)\n   return 0;\n\n const dxCapsule *const capsule = (dxCapsule *) o1;\n dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n immersion->g1 = o1;\n immersion->g2 = o2;\n\n dVector4 fluidPlane;\n dGeomTrimeshGetImmersionPlane(trimesh, fluidPlane);\n\n return dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 86.41706000332968}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t#if 0\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideTrimeshCapsule(o2, o1, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  const dxCapsule *const capsule = (dxCapsule *) o1;\n  dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomTrimeshGetImmersionPlane(trimesh, fluidPlane);\n\n  return dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n#endif\n  return 0;\n}", "CodeBleu_score": 85.15855832691742}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideCapsuleTriMesh (o1, o2, 1, c, sizeof (dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomTriMeshGetImmersionPlane (trimesh, fluidPlane);\n\treturn dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 83.88966075283238}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\n  int duration_ms = 0;\n\n  if (!getInput<int>(\"duration_ms\", duration_ms) || duration_ms <= 0)\n\n  {\n\n    return NodeStatus::SUCCESS;\n\n  }\n\n  setStatus(NodeStatus::RUNNING);\n\n  timer_waiting_ = true;\n\n  timer_ = std::make_shared<TimerNode>(\n\n    [this]() {\n\n      timer_waiting_ = false;\n\n      onTimerExpired();\n\n    },\n\n    duration_ms);\n\n  return NodeStatus::RUNNING;\n\n}", "CodeBleu_score": 49.51708735314381}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tconst int64_t duration_ms = getInput<int64_t>(\"duration_ms\");\n\tif (duration_ms <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_waiting_ = true;\n\ttimer_.start(std::chrono::milliseconds(duration_ms));\n\ttimer_.setCallback([this]() {\n\t\ttimer_waiting_ = false;\n\t\temitSignal(\"wake_up\");\n\t});\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.459952407442145}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// TODO: Add your code here\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 5.133764615744537}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// TODO: implement\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 6.587279201093221}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tauto entry_ptr = getInput<Blackboard::Ptr>(\"entry\");\n\tif (!entry_ptr) {\n\t\tthrow RuntimeError(\"Missing input [entry] for action \", name());\n\t}\n\tauto entry_mutex = getInput<std::mutex>(\"entry_mutex\");\n\tif (!entry_mutex) {\n\t\tthrow RuntimeError(\"Missing input [entry_mutex] for action \", name());\n\t}\n\t// lock the mutex before accessing the entry\n\tstd::unique_lock<std::mutex> lock(*entry_mutex);\n\tauto entry_id = entry_ptr->getSequenceId(entry_key_);\n\tif (entry_id!= prev_entry_id_) {\n\t\tprev_entry_id_ = entry_id;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 43.00861262393474}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tauto entry_ptr = getInput<Any>(\\\"entry\\\");\n\tif (entry_ptr) {\n\t\t// Lock the entry's mutex\n\t\tentry_ptr->lock();\n\n\t\t// Get the current sequence ID\n\t\tauto current_seq_id = entry_ptr->getSequenceId();\n\n\t\t// Check if the sequence ID has changed\n\t\tif (current_seq_id!= prev_seq_id_) {\n\t\t\t// Update the stored sequence ID\n\t\t\tprev_seq_id_ = current_seq_id;\n\n\t\t\t// Unlock the entry's mutex\n\t\t\tentry_ptr->unlock();\n\n\t\t\t// Return SUCCESS\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\n\t\t// Unlock the entry's mutex\n\t\tentry_ptr->unlock();\n\t}\n\n\t// Return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 35.61874151395143}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tcess_threshold_ < 0) {\nreturn static_cast<size_t>(children_nodes_.size()) + success_threshold_;\n} else {\nreturn static_cast<size_t>(success_threshold_);\n}\n}", "CodeBleu_score": 48.83164341129089}, {"code": "size_t ParallelNode::successThreshold() const{\n\t success_threshold_ >= 0? success_threshold_ : children_nodes_.size() + success_threshold_;\n}", "CodeBleu_score": 41.758882923970944}, {"code": "size_t ParallelNode::successThreshold() const{\n\tcess_threshold_ < 0) {\nreturn children_nodes_.size() + success_threshold_;\n} else {\nreturn static_cast<size_t>(success_threshold_);\n}\n}", "CodeBleu_score": 46.44126554004443}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\n// 1. Create a std::chrono::steady_clock::time_point representing the current time.\n2. While the server is running:\n3. Check if the current time is greater than the last recorded heartbeat time plus the heartbeat interval.\n4. If so, the heartbeat is inactive. Disable all breakpoints.\n5. Otherwise, the heartbeat is active. Enable all breakpoints.\n6. Sleep for 10 milliseconds.\n7. Repeat the loop.\n\nwhile(_p->running)\n{\n  std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  auto const now = std::chrono::steady_clock::now();\n  if(now > _p->last_heartbeat + _p->heartbeat_interval)\n  {\n    enableAllHooks(false);\n  }\n  else\n  {\n    enableAllHooks(true);\n  }\n}\n\n}", "CodeBleu_score": 45.75358001087337}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t", "CodeBleu_score": 3.384455481167677}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif(std::chrono::system_clock::now() - _p->heartbeat_last_time > std::chrono::seconds(1)) {\n\t\t\tenableAllHooks(false);\n\t\t} else {\n\t\t\tenableAllHooks(true);\n\t\t}\n\t}\n}", "CodeBleu_score": 29.90118473613139}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tauto bb_names = split(bb_list, ',');\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto subtree = _p->tree->subtree(bb_name);\n\t\tif (subtree) {\n\t\t\tstd::unique_lock<std::mutex> lk(subtree->blackboard_mutex);\n\t\t\tauto json = subtree->blackboard->to_json();\n\t\t\tjson[\"name\"] = bb_name;\n\t\t\tresult = json.dump(4, '\\t', true, nlohmann::json::error_handler_t::ignore);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 48.20957042745293}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tauto json_out = nlohmann::json::object();\n\n\tstd::string str = bb_list;\n\tstd::replace(str.begin(), str.end(), ',','');\n\tstd::istringstream ss(str);\n\tstd::string token;\n\twhile (std::getline(ss, token,'')) {\n\t\tauto tree = _p->tree->findTree(token);\n\t\tif (tree) {\n\t\t\tstd::unique_lock<std::mutex> lk(tree->mutex);\n\t\t\tauto bb = tree->blackboard;\n\t\t\tif (bb) {\n\t\t\t\tjson_out[token] = bb->to_json();\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = nlohmann::json::to_msgpack(json_out);\n\treturn result;\n}", "CodeBleu_score": 46.54975774917449}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> output;\n\tauto json_out = nlohmann::json::object();\n\tauto const bb_names = split(bb_list, ',');\n\tfor(auto const& bb_name : bb_names) {\n\t\tauto const subtree = _p->tree->subtree(bb_name);\n\t\tif(!subtree) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::unique_lock<std::mutex> lk(subtree->blackboard_mutex);\n\t\tauto json_bb = subtree->blackboard->to_json();\n\t\tjson_out[bb_name] = json_bb;\n\t}\n\tauto const msgpack_out = nlohmann::json::to_msgpack(json_out);\n\toutput.insert(output.end(), msgpack_out.begin(), msgpack_out.end());\n\treturn output;\n}", "CodeBleu_score": 52.169107567754324}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto it = _p->pre_hooks.find(node_uid);\n\tif (it == _p->pre_hooks.end()) {\n\t\treturn false;\n\t}\n\tauto hook = it->second;\n\tlk.unlock();\n\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\tif (hook->mode!= Monitor::Hook::Mode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->desired_status = result;\n\thook->remove_when_done = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 55.57080254580997}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto it = _p->pre_hooks.find(node_uid);\n\tif (it == _p->pre_hooks.end()) {\n\t\treturn false;\n\t}\n\n\tauto hook = it->second;\n\tif (hook->mode!= Monitor::Hook::Mode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\thook->desired_status = result;\n\thook->remove_when_done = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 52.438627263454066}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto it = _p->pre_hooks.find(node_uid);\n\tif (it == _p->pre_hooks.end()) {\n\t\treturn false;\n\t}\n\tauto hook = it->second;\n\tlk.unlock();\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\tif (hook->mode == Monitor::Hook::Mode::BREAKPOINT) {\n\t\thook->desired_status = result;\n\t\thook->remove_when_done = remove;\n\t\thook->ready = true;\n\t\thook->wakeup.notify_all();\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.91987628455484}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tdeStatus prev_status = status();\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_.store(false);\n\t\ttry {\n\t\t\t// Create a new thread to execute the tick function\n\t\t\tstd::thread t([this]() {\n\t\t\t\ttry {\n\t\t\t\t\ttick();\n\t\t\t\t} catch (...) {\n\t\t\t\t\t// Catch any exceptions and store them\n\t\t\t\t\tstored_exception_ = std::current_exception();\n\t\t\t\t}\n\t\t\t});\n\t\t\tt.detach();\n\t\t} catch (...) {\n\t\t\t// Catch any exceptions and log them\n\t\t\ttry {\n\t\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cerr << \"Error in ThreadedAction::executeTick: \" << e.what() << std::endl;\n\t\t\t}\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t\t// Check for any stored exceptions and rethrow them if present\n\t\tif (stored_exception_) {\n\t\t\tstd::rethrow_exception(stored_exception_);\n\t\t}\n\t\treturn status();\n\t}\n\t// If the node status is not IDLE, check if it is RUNNING\n\tif (prev_status == NodeStatus::RUNNING) {\n\t\t// Check if the tick function completed without a halt request\n\t\tif (!halt_requested_.load()) {\n\t\t\t// Update the node status based on the result of the tick function\n\t\t\tNodeStatus new_status = tick();\n\t\t\tif (new_status == NodeStatus::IDLE) {\n\t\t\t\tthrow LogicError(\"ThreadedAction::tick() must not return IDLE\");\n\t\t\t}\n\t\t\treturn new_status;\n\t\t}\n\t}\n\treturn prev_status;\n}", "CodeBleu_score": 46.595617917451065}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t (status() == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_.store(false);\n\t\ttry {\n\t\t\t// start a new thread to run the tick function\n\t\t\tthread_ = std::thread([this]() {\n\t\t\t\ttry {\n\t\t\t\t\t// run the tick function\n\t\t\t\t\tNodeStatus new_status = tick();\n\t\t\t\t\tif (new_status == NodeStatus::IDLE) {\n\t\t\t\t\t\tthrow LogicError(\"ThreadedAction::tick() must not return IDLE\");\n\t\t\t\t\t}\n\t\t\t\t\t// update the node status\n\t\t\t\t\tsetStatus(new_status);\n\t\t\t\t} catch (...) {\n\t\t\t\t\t// catch any exception and log an error\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// store the exception in the exception_ variable\n\t\t\t\t\t\texception_ = std::current_exception();\n\t\t\t\t\t} catch (...) {\n\t\t\t\t\t\t// if storing the exception fails, log an error\n\t\t\t\t\t\tstd::cerr << \"Error storing exception in ThreadedAction::executeTick\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\t// set the node status to IDLE\n\t\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (...) {\n\t\t\t// catch any exception and log an error\n\t\t\tstd::cerr << \"Error starting thread in ThreadedAction::executeTick\" << std::endl;\n\t\t\t// set the node status to IDLE\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\t// check for any stored exceptions and rethrow them if present\n\tif (exception_) {\n\t\tstd::rethrow_exception(exception_);\n\t}\n\t// return the current status of the node\n\treturn status();\n}", "CodeBleu_score": 44.22549377183933}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t (status() == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_.store(false);\n\t\ttry {\n\t\t\tasync_thread_ = std::async(std::launch::async, [this]() {\n\t\t\t\tNodeStatus new_status = tick();\n\t\t\t\tif (new_status == NodeStatus::IDLE) {\n\t\t\t\t\tthrow LogicError(\"ThreadedAction::tick() must not return IDLE\");\n\t\t\t\t}\n\t\t\t\tsetStatus(new_status);\n\t\t\t});\n\t\t} catch (...) {\n\t\t\ttry {\n\t\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tlogError(e.what());\n\t\t\t} catch (...) {\n\t\t\t\tlogError(\"Unknown exception\");\n\t\t\t}\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\tif (async_thread_.valid()) {\n\t\tif (async_thread_.wait_for(std::chrono::milliseconds(0)) == std::future_status::ready) {\n\t\t\ttry {\n\t\t\t\tasync_thread_.get();\n\t\t\t} catch (...) {\n\t\t\t\tstored_exception_ = std::current_exception();\n\t\t\t}\n\t\t}\n\t}\n\tif (stored_exception_) {\n\t\tstd::rethrow_exception(stored_exception_);\n\t}\n\treturn status();\n}", "CodeBleu_score": 46.3226103749406}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Define a recursive lambda function to handle the printing\nauto printNode = [&stream](const TreeNode* node, int depth) {\n// Indent the output based on the node's depth\nfor (int i = 0; i < depth; ++i) {\nstream << \"  \";\n}\n// Print the node's name\nstream << node->name() << std::endl;\n// Recursively print the children for ControlNode or the child for DecoratorNode\nif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor (const auto& child : control->children()) {\nprintNode(static_cast<const TreeNode*>(child), depth + 1);\n}\n} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\nif (decorator->child()) {\nprintNode(decorator->child(), depth + 1);\n}\n}\n};\n// Begin and end with separator lines\nstream << \"------------------------------------------------------------\" << std::endl;\nprintNode(root_node, 0);\nstream << \"------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 58.22570720362082}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Define a recursive lambda function to handle the printing\n\tauto print_node = [&](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\t// Print the node's name\n\t\tstream << node->name() << std::endl;\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children()) {\n\t\t\t\tprint_node(static_cast<const TreeNode*>(child), depth + 1);\n\t\t\t}\n\t\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tif (decorator->child()) {\n\t\t\t\tprint_node(decorator->child(), depth + 1);\n\t\t\t}\n\t\t}\n\t};\n\t// Begin with a separator line\n\tstream << \"------------------------------------\" << std::endl;\n\t// Print the root node and its children recursively\n\tprint_node(root_node, 0);\n\t// End with a separator line\n\tstream << \"------------------------------------\" << std::endl;\n}", "CodeBleu_score": 57.03019339783763}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Define a recursive lambda function to handle the printing\n\tauto printNode = [&stream](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"  \";\n\t\t}\n\n\t\t// Print the node's name\n\t\tstream << node->name() << std::endl;\n\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (auto control = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children()) {\n\t\t\t\tprintNode(child, depth + 1);\n\t\t\t}\n\t\t} else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tif (decorator->child()) {\n\t\t\t\tprintNode(decorator->child(), depth + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\t// Begin and end with separator lines\n\tstream << \"-------------------------------------------------\" << std::endl;\n\tprintNode(root_node, 0);\n\tstream << \"-------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 53.76298059724392}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\n}", "CodeBleu_score": 7.736551633910178}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t", "CodeBleu_score": 7.6574026861868205}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t", "CodeBleu_score": 7.6574026861868205}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.count(manifest.registration_ID)) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Trying to register a new builder for ID [\", manifest.registration_ID,\n\t\t\t\"] that was already registered\");\n\t}\n\t_p->builders[manifest.registration_ID] = builder;\n\t_p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 52.2550242962837}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.count(manifest.registration_ID)) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"You can not register the same registration ID twice [\",\n\t\t\tmanifest.registration_ID, \"]\");\n\t}\n\t_p->builders[manifest.registration_ID] = builder;\n\t_p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 49.4106168288589}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.count(manifest.registration_ID)) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"The registration ID [\", manifest.registration_ID,\n\t\t\t\"] is already registered.\");\n\t}\n\t_p->builders[manifest.registration_ID] = builder;\n\t_p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 50.678804674941226}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t", "CodeBleu_score": 10.694302164157746}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor, ID](const std::string& name,\n\t                                          const NodeConfig& config) {\n\t\treturn std::make_unique<SimpleActionNode>(name, tick_functor, config);\n\t};\n\n\tTreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n\tregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 98.23532652103934}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t*\n * This lambda function, builder, is used to construct a SimpleActionNode.\n * It takes a name and a configuration as arguments and returns a unique_ptr to a SimpleActionNode.\n * The SimpleActionNode is constructed using the provided tick_functor and configuration.\n */\n  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n/*\n * This creates a TreeNodeManifest with the specified ID, node type (action), ports list, and no parameters.\n * It then calls registerBuilder to register the manifest and builder.\n */\n  TreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 85.45638461220338}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tbackup.push_back(std::make_shared<Blackboard>());\n\t\tsubtree->blackboard->cloneInto(*backup.back());\n\t}\n\treturn backup;\n}", "CodeBleu_score": 63.42390663172335}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tauto bb = std::make_shared<Blackboard>();\n\t\tsubtree->blackboard->cloneInto(*bb);\n\t\tbackup.push_back(bb);\n\t}\n\treturn backup;\n}", "CodeBleu_score": 57.982704096256676}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tauto bb = std::make_shared<Blackboard>();\n\t\tsubtree->blackboard->cloneInto(*bb);\n\t\tbackup.push_back(bb);\n\t}\n\treturn backup;\n}", "CodeBleu_score": 57.982704096256676}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tchar error_msgs_buffer[2048];\n\nauto input = lexy::string_input<lexy::utf8_encoding>(script);\nauto result =\nlexy::parse<BT::Grammar::stmt>(input, ErrorReport().to(error_msgs_buffer));\nif(result.has_value() && result.error_count() == 0)\n{\ntry\n{\nstd::vector<BT::Ast::ExprBase::Ptr> exprs = LEXY_MOV(result).value();\nif(exprs.empty())\n{\nreturn nonstd::make_unexpected(\"Empty Script\");\n}\n\nreturn [exprs, script](Ast::Environment& env) -> Any {\ntry\n{\nfor(auto i = 0u; i < exprs.size() - 1; ++i)\n{\nexprs[i]->evaluate(env);\n}\nreturn exprs.back()->evaluate(env);\n}\ncatch(RuntimeError& err)\n{\nthrow RuntimeError(StrCat(\"Error in script [\", script, \"]\n\", err.what()));\n}\n};\n}\ncatch(std::runtime_error& err)\n{\nreturn nonstd::make_unexpected(err.what());\n}\n}\nelse\n{\nreturn nonstd::make_unexpected(error_msgs_buffer);\n}\n}", "CodeBleu_score": 49.09410769577317}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t", "CodeBleu_score": 8.428463305663993}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (executor.has_value()) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.37918082749243}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t// Get the mutex lock\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// Check if a library is already loaded\n\tif (_handle) {\n\t\tthrow RuntimeError(\"A library is already loaded\");\n\t}\n\n\t// Attempt to load the library\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\t// Check if the load failed\n\tif (!_handle) {\n\t\tstd::string error(dlerror());\n\t\tthrow RuntimeError(\"Failed to load library: \" + error);\n\t}\n\n\t// Store the path of the loaded library\n\t_path = path;\n}", "CodeBleu_score": 60.71756300689868}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t/*\n\t * This function, SharedLibrary::load, loads a shared library from the specified path.\nIt acquires a unique lock on a mutex to ensure thread safety.\nIf a library is already loaded, it throws a RuntimeError.\nIt attempts to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags.\nIf the load fails, it retrieves the error message and throws a RuntimeError.\nIf successful, it stores the path of the loaded library.\n\t */\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\tif (_handle) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!_handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\t_path = path;\n}", "CodeBleu_score": 51.905888008948644}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t/*\n\t * This function, SharedLibrary::load, loads a shared library from the specified path.\nIt acquires a unique lock on a mutex to ensure thread safety.\nIf a library is already loaded, it throws a RuntimeError.\nIt attempts to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags.\nIf the load fails, it retrieves the error message and throws a RuntimeError.\nIf successful, it stores the path of the loaded library.\n\t */\n\tif (_handle!= nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\tif (_handle == nullptr) {\n\t\tthrow RuntimeError(\"Failed to load library: \" + std::string(dlerror()));\n\t}\n\n\t_path = path;\n}", "CodeBleu_score": 53.46039152320334}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str.front()!= '{' || str.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 21.87090316398646}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\t// Check if the string is at least 3 characters long\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\t// Strip leading and trailing spaces\n\tauto stripped = str.trim();\n\n\t// Check if the stripped string starts with '{' and ends with '}'\n\tif (stripped.front() == '{' && stripped.back() == '}') {\n\t\tif (stripped_pointer) {\n\t\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 23.94343641265626}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\t// strip leading and trailing spaces\n\twhile (str.size() > 0 && isspace(str[0])) {\n\t\tstr.remove_prefix(1);\n\t}\n\twhile (str.size() > 0 && isspace(str[str.size() - 1])) {\n\t\tstr.remove_suffix(1);\n\t}\n\n\tif (str[0]!= '{' || str[str.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 27.047607089497898}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t// initialize the line cost and iterator\n\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\n\t// iterate through each point on the line\n\tfor (LineIterator::iterator it = line.begin(); it!= line.end(); ++it) {\n\t\t// calculate the point cost\n\t\tunsigned char cost = costmap_.getCost(it->x, it->y);\n\n\t\t// if the point cost is negative, return it immediately\n\t\tif (cost == NO_INFORMATION)\n\t\t\treturn -2.0;\n\t\tif (cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n\t\t\treturn -1.0;\n\n\t\t// update the line cost if the point cost is higher\n\t\tline_cost = std::max(line_cost, (double) cost);\n\t}\n\n\t// return the total line cost\n\treturn line_cost;\n}", "CodeBleu_score": 51.532892050216276}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t//initialize the cost of the line\n\n\tdouble line_cost = 0.0;\n\n\t//get the line iterator\n\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\n\t//iterate through the points on the line\n\n\tfor (int i = 0; i < line.num_cells(); ++i, ++line) {\n\t\t//check the cost of the cell\n\n\t\tdouble point_cost = pointCost(*line);\n\n\t\t//if the cost is negative... we'll add it to the cost map, and return\n\n\t\tif (point_cost < 0)\n\t\t\treturn point_cost;\n\n\t\t//keep track of the cost of traversing the line\n\n\t\tline_cost = std::max(line_cost, point_cost);\n\t}\n\n\t//return the line cost\n\n\treturn line_cost;\n}", "CodeBleu_score": 55.14046516736608}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.num_cells(); ++i, ++line) {\n\t\tunsigned char cost = costmap_.getCost(line.getX(), line.getY());\n\t\tif (cost == NO_INFORMATION)\n\t\t\treturn -2.0;\n\t\tif (cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n\t\t\treturn -1.0;\n\t\tline_cost = std::max(line_cost, (double) cost);\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 53.17919989128468}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\n\t\tif (!path[0].header.frame_id.empty()) {\n\t\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\t}\n\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 75.62776120051133}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\nROS_DEBUG_NAMED(\"trajectory_planner_ros\", \"Empty plan.\");\nreturn;\n}\n//create a path message\nnav_msgs::Path gui_path;\ngui_path.poses.resize(path.size());\ngui_path.header.frame_id = path[0].header.frame_id;\ngui_path.header.stamp = path[0].header.stamp;\n// Extract the plan in world co-ordinates, we assume the path is all in the same frame\nThis yields a straight line in the costmap\nCopy it into a path message\nfor (unsigned int i = 0; i < path.size(); i++) {\ngui_path.poses[i] = path[i];\n}\npub.publish(gui_path);\n}", "CodeBleu_score": 74.09799345701195}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n// Get the linear and angular velocities from the odometry message\ndouble lin_vel = base_odom.twist.twist.linear.x;\ndouble ang_vel = base_odom.twist.twist.angular.z;\n\n// Check if the linear and angular velocities are below the given thresholds\nif (fabs(lin_vel) <= trans_stopped_velocity && fabs(ang_vel) <= rot_stopped_velocity) {\n  return true;\n}\n\nreturn false;\n}", "CodeBleu_score": 52.921293684229376}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t", "CodeBleu_score": 7.6923076923076925}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) &&\n\t\t(fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) &&\n\t\t(fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}", "CodeBleu_score": 68.95147261528456}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t}\n\n\tconfig_mutex_.lock();\n\tlimits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 60.69744840415224}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tgned int index = size_x_ * check_cell->cy + check_cell->cx;\n\tunsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n\tif (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcheck_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\t// Calculate the new target distance and update the cell's target distance if the new distance is shorter\n\tdouble dx = current_cell->cx - check_cell->cx;\n\tdouble dy = current_cell->cy - check_cell->cy;\n\tdouble new_dist = sqrt(dx * dx + dy * dy) + current_cell->target_dist;\n\tif (new_dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = new_dist;\n\t}\n\treturn true;\n}", "CodeBleu_score": 62.23907525648302}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\theck if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->cx, check_cell->cy) >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\t// Set the cell's target distance to the maximum obstacle cost and return false\n\t\tcheck_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\n\t// Calculate a new target distance\n\tdouble new_target_dist = current_cell->target_dist + hypot(current_cell->cx - check_cell->cx, current_cell->cy - check_cell->cy);\n\n\t// Update the cell's target distance if the new distance is shorter\n\tif (new_target_dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = new_target_dist;\n\t}\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 62.872195333379246}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tet the cost of the cell from the costmap\n\tunsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n\tif (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\tcheck_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\t// If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter\n\tint distance = current_cell->target_dist + 1;\n\tif (distance < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = distance;\n\t}\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 62.32689477376358}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/ TODO: make sure to set a cost for trajectories that move backwards\n\n  // initialize the cost and scaling factor\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (max_trans_vel_ > 0.0) {\n    double v_x = traj.xv_ * cos(traj.thetav_) + traj.yv_ * sin(traj.thetav_);\n    scaling_factor = std::min(max_trans_vel_ / v_x, max_scaling_factor_);\n  }\n\n  // if the footprint specification is empty, log an error and return -9\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\\\"Footprint specification is empty. Cannot score trajectory.\\\");\n    return -9.0;\n  }\n\n  // for each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x = traj.getPoint(i).x;\n    double y = traj.getPoint(i).y;\n    double theta = traj.getPoint(i).th;\n\n    // if the footprint cost is negative, return the cost immediately\n    double footprint_cost = footprintCost(x, y, theta);\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    // either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost * scaling_factor;\n    } else {\n      cost = std::max(cost, footprint_cost * scaling_factor);\n    }\n  }\n\n  // return the total cost\n  return cost;\n}", "CodeBleu_score": 51.60907669061506}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t Initialize the cost and scaling factor based on the trajectory and speed parameters\ndouble cost = 0.0;\ndouble scale = 1.0;\nif (max_trans_vel_ > 0.0) {\nscale = std::min(max_trans_vel_, traj.xv_) / max_trans_vel_;\n}\n\n// If the footprint specification is empty, log an error and return -9\nif (footprint_spec_.empty()) {\nROS_ERROR(\"Footprint specification is empty\");\nreturn -9;\n}\n\n// For each point in the trajectory, calculate the footprint cost\nfor (int i = 0; i < traj.getPointsSize(); ++i) {\ndouble footprint_cost = world_model_->footprintCost(traj.getX(i), traj.getY(i), traj.getTheta(i), footprint_spec_);\n\n// If the footprint cost is negative, return the cost immediately\nif (footprint_cost < 0) {\nreturn footprint_cost;\n}\n\n// Either sum the scores or take the maximum score based on the sum_scores_ flag\nif (sum_scores_) {\ncost += footprint_cost * scale;\n} else {\ncost = std::max(cost, footprint_cost * scale);\n}\n}\n\n// Return the total cost\nreturn cost;\n}", "CodeBleu_score": 51.05470117663471}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t TODO: make the scaling factor depend on the current velocity\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double max_trans_vel = max_trans_vel_;\n  double max_scaling_factor = max_scaling_factor_;\n  double scaling_speed = scaling_speed_;\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\\\"Footprint spec is empty\\\");\n    return -9;\n  }\n  for (int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = world_model_->footprintCost(traj.getPoint(i).pose.position.x, traj.getPoint(i).pose.position.y, traj.getPoint(i).theta, footprint_spec_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost * scaling_factor;\n    } else {\n      cost = std::max(cost, footprint_cost * scaling_factor);\n    }\n    // TODO: make the scaling factor depend on the current velocity\n    if (scaling_factor < max_scaling_factor) {\n      double current_trans_vel = hypot(traj.getPoint(i).v, traj.getPoint(i).w);\n      scaling_factor = std::min(max_scaling_factor, scaling_factor + scaling_speed * current_trans_vel / max_trans_vel);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 45.92013560916621}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t*\n * This function, ObstacleCostFunction::footprintCost, calculates the cost of a robot's footprint at a given position and orientation on a costmap.\n */\n  double footprint_cost = 0.0;\n  //if we have no footprint... do nothing\n  if (footprint_spec.size() < 3) {\n    return 0.0;\n  }\n\n  //build the oriented footprint\n  std::vector<geometry_msgs::Point> oriented_footprint = footprint_spec;\n  rotateFootprint(x, y, th, oriented_footprint);\n  scaleFootprint(scale, oriented_footprint);\n\n  //check if the footprint is legal\n  double footprint_cost = world_model->footprintCost(x, y, th, oriented_footprint, costmap);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  //check if the base position is legal\n  double cell_cost = costmap->getCost(costmap->getIndex(x, y));\n  if (cell_cost == costmap_2d::LETHAL_OBSTACLE) {\n    return -7.0;\n  }\n\n  //check if the orientation is legal\n  double orient_cost = world_model->footprintCost(x, y, th, footprint_spec, costmap);\n  if (orient_cost < 0) {\n    return -8.0;\n  }\n\n  //check if the point is legal\n  double point_cost = world_model->pointCost(x, y, costmap);\n  if (point_cost < 0) {\n    return -9.0;\n  }\n\n  return std::max(std::max(footprint_cost, cell_cost), std::max(orient_cost, point_cost));\n}", "CodeBleu_score": 55.359843439586434}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t*\n * This function, ObstacleCostFunction::footprintCost, calculates the cost of a robot's footprint at a given position and orientation on a costmap.\nIt scales the footprint points by a given scale factor.\nThen, it computes the footprint cost using a world model.\nIf the cost is negative, it returns -6.0.\nIf the position is off the map, it returns -7.0.\nOtherwise, it returns the maximum cost between the footprint cost and the cell cost at the given position.\n */\ndouble ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model) {\n  //check if the footprint is legal\n\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec, costmap, scale);\n\n  if (footprint_cost < 0) {\n\n    return -6.0;\n\n  }\n\n\n  //check if the center point is legal\n\n  unsigned int cell_x, cell_y;\n\n  if (costmap->worldToMap(x, y, cell_x, cell_y)) {\n\n    double point_cost = double(costmap->getCost(cell_x, cell_y)) / 100.0;\n\n    return std::max(footprint_cost, point_cost);\n\n  } else {\n\n    return -7.0;\n\n  }\n\n}\n\n\n\n/*\n * This function, ObstacleCostFunction::setSumScores, sets the sum_scores_ variable to the given value.\n */\nvoid ObstacleCostFunction::setSumScores(bool sum_scores) {\n  sum_scores_ = sum_scores;\n}\n\n}", "CodeBleu_score": 56.66326586271676}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\tROS_INFO(\"Subscribing to %s\", odom_topic_.c_str());\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\tROS_INFO(\"Unsubscribing from odometry topic\");\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 45.9165135307787}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif(odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\n\t\tif(!odom_topic_.empty()) {\n\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\n\t\t} else {\n\n\t\t\todom_sub_.shutdown();\n\n\t\t}\n\n\t}\n\n}", "CodeBleu_score": 48.58213558124181}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\n  if (odom_topic_!= odom_topic) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_!= \\\"\\\") {\n      ROS_INFO_NAMED(\\\"dwa_local_planner\\\", \\\"Subscribing to odometry topic: %s\\\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_INFO_NAMED(\\\"dwa_local_planner\\\", \\\"Unsubscribing from odometry topic.\\\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 46.1234792442052}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tdouble sq_dist = (pos - prev).squaredNorm();\n\tdouble angle = fabs(atan2(pos[1] - prev[1], pos[0] - prev[0]));\n\tif (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ || angle > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 55.728841687390826}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tdouble dist_sq = (pos - prev).squaredNorm();\n\tdouble angle = fabs(atan2(pos[1] - prev[1], pos[0] - prev[0]));\n\n\tif (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_) {\n\t\tresetOscillationFlags();\n\t} else if (angle > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 54.7466360963367}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//  ROS_DEBUG_NAMED(\"oscillation_cost\", \"resetOscillationFlagsIfPossible: pos: %.2f, %.2f, %.2f; prev: %.2f, %.2f, %.2f\",\n//                  pos.x(), pos.y(), pos.z(), prev.x(), prev.y(), prev.z());\n  double sq_dist = (pos - prev).squaredNorm();\n  double angle = std::abs(std::atan2(pos.y() - prev.y(), pos.x() - prev.x()));\n  if (sq_dist >= oscillation_reset_dist_ * oscillation_reset_dist_ || angle >= oscillation_reset_angle_) {\n    ROS_DEBUG_NAMED(\"oscillation_cost\", \"resetting oscillation flags\");\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 43.9729975948739}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tunsigned int gx, gy;\n\n//if the grid coordinates are outside the bounds of the grid... return\nif(!gridCoords(pt, gx, gy))\nreturn;\n//get the associated index\nunsigned int index = gridIndex(gx, gy);\n\n//if the point is too close to its nearest neighbor... return\nif(nearestNeighborDistance(pt, index) < min_distance_)\nreturn;\n\n//insert the point into the cell\ncells_[index].push_back(pt);\n}", "CodeBleu_score": 77.11042428246793}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//compute the grid coordinates of the point\nunsigned int gx, gy;\nif(!gridCoords(pt, gx, gy))\nreturn;\n\n//get the index of the cell\nunsigned int index = gridIndex(gx, gy);\n\n//get the cell\nlist<geometry_msgs::Point32>& cell = cells_[index];\n\n//if the cell is empty, we can insert the point\nif(cell.empty()){\ncell.push_back(pt);\nreturn;\n}\n\n//if the point is too close to the nearest neighbor, we can't insert it\nif(nearestNeighborDistance(pt, cell) < resolution_)\nreturn;\n\n//otherwise, we can insert the point\ncell.push_back(pt);\n}", "CodeBleu_score": 71.10137819197784}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tunsigned int gx, gy;\n\tif (!gridCoords(pt, gx, gy))\n\t\treturn;\n\tunsigned int index = gridIndex(gx, gy);\n\tif (!cells_[index].empty()) {\n\t\t//check to see if the point is too close to its nearest neighbor\n\t\tlist<geometry_msgs::Point32>::iterator it = cells_[index].begin();\n\t\tdouble min_dist = 0.0;\n\t\tfor (; it!= cells_[index].end(); ++it) {\n\t\t\tdouble dist = distance(pt, *it);\n\t\t\tif (min_dist == 0.0 || dist < min_dist)\n\t\t\t\tmin_dist = dist;\n\t\t}\n\t\tif (min_dist < min_dist_)\n\t\t\treturn;\n\t}\n\tcells_[index].push_back(pt);\n}", "CodeBleu_score": 62.10656395555243}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t", "CodeBleu_score": 6.285623149499962}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t", "CodeBleu_score": 6.285623149499962}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; ++i) {\n\t\tdouble delta = sample_target_vel[i] - vel[i];\n\t\tif (delta > 0) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 77.16154585783433}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//  ROS_INFO(\\\"HeadingDiff: x: %d, y: %d, x: %.2f, y: %.2f, heading: %.2f\\\", cell_x, cell_y, x, y, heading);\n  double min_dist = std::numeric_limits<double>::max();\n  double min_angle = std::numeric_limits<double>::max();\n  unsigned int min_cell_x = cell_x;\n  unsigned int min_cell_y = cell_y;\n  for (unsigned int i = 0; i < global_plan_.size(); ++i) {\n    unsigned int g_cell_x, g_cell_y;\n    if (!costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, g_cell_x, g_cell_y)) {\n      continue;\n    }\n    double dx = cell_x - g_cell_x;\n    double dy = cell_y - g_cell_y;\n    double dist = hypot(dx, dy);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_cell_x = g_cell_x;\n      min_cell_y = g_cell_y;\n    }\n  }\n  if (min_dist < std::numeric_limits<double>::max()) {\n    double wx, wy;\n    costmap_.mapToWorld(min_cell_x, min_cell_y, wx, wy);\n    double angle = atan2(wy - y, wx - x);\n    min_angle = angles::shortest_angular_distance(heading, angle);\n  }\n  return fabs(min_angle);\n}", "CodeBleu_score": 50.63009918228415}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x = global_plan_[global_plan_.size() - 1].pose.position.x;\n\tdouble goal_y = global_plan_[global_plan_.size() - 1].pose.position.y;\n\n\t// iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// get the world coordinates of the current point\n\t\tdouble x_i = global_plan_[i].pose.position.x;\n\t\tdouble y_i = global_plan_[i].pose.position.y;\n\n\t\t// check if the point is in the same cell as the robot's current cell\n\t\tif (costmap_.worldToMap(x_i, y_i, cell_x, cell_y)) {\n\t\t\t// check if the point is in a clear cell\n\t\t\tunsigned char cost = costmap_.getCost(cell_x, cell_y);\n\t\t\tif (cost < costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\t\t\t// convert the goal cell coordinates to world coordinates\n\t\t\t\tdouble goal_x = global_plan_[i].pose.position.x;\n\t\t\t\tdouble goal_y = global_plan_[i].pose.position.y;\n\n\t\t\t\t// calculate the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\t\t\t\tdouble heading_diff = fabs(angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x)));\n\n\t\t\t\treturn heading_diff;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DBL_MAX;\n}", "CodeBleu_score": 57.76747385053833}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory\");\n\t//ROS_INFO(\"x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\t//ROS_INFO(\"x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f\", x, y, theta, vx, vy, vtheta);\n\tTrajectory traj;\n\ttraj.xv_ = vx;\n\ttraj.yv_ = vy;\n\ttraj.thetav_ = vtheta;\n\ttraj.xv_samp_ = vx_samp;\n\ttraj.yv_samp_ = vy_samp;\n\ttraj.thetav_samp_ = vtheta_samp;\n\tscoreTrajectory(traj, x, y, theta);\n\tif (traj.cost_ < 0) {\n\t\tROS_WARN(\"Invalid Trajectory x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f, cost: %.2f\", x, y, theta, vx, vy, vtheta, traj.cost_);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 51.54167048566289}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t!initialized_){\nROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\nreturn;\n}\n\nif(global_costmap_ == NULL || local_costmap_ == NULL){\nROS_ERROR(\\\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\\\");\nreturn;\n}\n\nif(invert_area_to_clear_){\nROS_WARN(\\\"Clearing area outside the robot's footprint.\\\");\n}\nelse{\nROS_WARN(\\\"Clearing area inside the robot's footprint.\\\");\n}\n\nif(affected_maps_ == \\\"global\\\" || affected_maps_ == \\\"both\\\") {\nros::Time start = ros::Time::now();\nglobal_costmap_->clearArea(0, 0, global_costmap_->getSizeInCellsX(), global_costmap_->getSizeInCellsY(), reset_distance_, invert_area_to_clear_, clearable_layers_);\nros::Time end = ros::Time::now();\nROS_INFO(\\\"Clearing the global costmap took %.2f seconds\\\", (end - start).toSec());\n}\n\nif(affected_maps_ == \\\"local\\\" || affected_maps_ == \\\"both\\\") {\nros::Time start = ros::Time::now();\nlocal_costmap_->clearArea(0, 0, local_costmap_->getSizeInCellsX(), local_costmap_->getSizeInCellsY(), reset_distance_, invert_area_to_clear_, clearable_layers_);\nros::Time end = ros::Time::now();\nROS_INFO(\\\"Clearing the local costmap took %.2f seconds\\\", (end - start).toSec());\n}\n\nif(force_updating_){\nglobal_costmap_->updateMap();\nlocal_costmap_->updateMap();\n}\n}", "CodeBleu_score": 49.309966460137744}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t!initialized_){\nROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\nreturn;\n}\n\nif(global_costmap_ == NULL || local_costmap_ == NULL){\nROS_ERROR(\\\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\\\");\nreturn;\n}\n\nif(invert_area_to_clear_){\nROS_WARN(\\\"Clearing costmap outside of the robot footprint\\\");\n}\nelse{\nROS_WARN(\\\"Clearing costmap inside of the robot footprint\\\");\n}\n\nif(affected_maps_ == \\\"local\\\" || affected_maps_ == \\\"both\\\")\n{\nif(invert_area_to_clear_){\nclearCostmap(local_costmap_, global_costmap_, reset_distance_, true, force_updating_);\n}\nelse{\nclearCostmap(local_costmap_, global_costmap_, reset_distance_, false, force_updating_);\n}\n}\n\nif(affected_maps_ == \\\"global\\\" || affected_maps_ == \\\"both\\\")\n{\nif(invert_area_to_clear_){\nclearCostmap(global_costmap_, local_costmap_, reset_distance_, true, force_updating_);\n}\nelse{\nclearCostmap(global_costmap_, local_costmap_, reset_distance_, false, force_updating_);\n}\n}\n}", "CodeBleu_score": 38.816432330769004}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t!initialized_){\nROS_ERROR(\\\"This object must be initialized before runBehavior is called\\\");\nreturn;\n}\n\nif(global_costmap_ == NULL || local_costmap_ == NULL){\nROS_ERROR(\\\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\\\");\nreturn;\n}\n\nif(invert_area_to_clear_){\nROS_WARN(\\\"Clearing inside the area to clear\\\");\n}\nelse{\nROS_WARN(\\\"Clearing outside the area to clear\\\");\n}\n\nros::Time start_time = ros::Time::now();\n\nif(affected_maps_ == \\\"local\\\" || affected_maps_ == \\\"both\\\")\n{\nROS_INFO(\\\"Clearing local costmap\\\");\nclearCostmap(local_costmap_);\n}\n\nif(affected_maps_ == \\\"global\\\" || affected_maps_ == \\\"both\\\")\n{\nROS_INFO(\\\"Clearing global costmap\\\");\nclearCostmap(global_costmap_);\n}\n\nros::Time end_time = ros::Time::now();\n\nROS_INFO(\\\"Clearing costmap recovery took %.2f seconds\\\", (end_time - start_time).toSec());\n}", "CodeBleu_score": 40.217762415141266}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t}", "CodeBleu_score": 5.1108987274786815}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t}", "CodeBleu_score": 5.1108987274786815}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t}", "CodeBleu_score": 5.1108987274786815}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t", "CodeBleu_score": 10.992937465607893}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t", "CodeBleu_score": 10.992937465607893}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// TODO:\n\t// implement the function\n}", "CodeBleu_score": 12.553135460120322}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::recursive_mutex::scoped_lock lock(*(costmap_->getMutex()));\n\n\t// get the map resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// set the header information on the grid\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// convert the map coordinates to world coordinates for the origin of the grid\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\n\t// set the origin of the grid\n\tgrid_.info.origin.position.x = wx - resolution / 2;\n\tgrid_.info.origin.position.y = wy - resolution / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// save the origin coordinates\n\tx0_ = costmap_->getSizeInCellsX();\n\ty0_ = costmap_->getSizeInCellsY();\n\n\t// resize the grid data vector\n\tgrid_.data.resize(x0_ * y0_);\n\n\t// copy the costmap data into the grid data\n\tunsigned char* map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < x0_ * y0_; ++i) {\n\t\tgrid_.data[i] = cost_translation_table_[map[i]];\n\t}\n}", "CodeBleu_score": 81.39484300805695}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tcostmap_->getMutex().lock();\n\tdouble resolution = costmap_->getResolution();\n\tcostmap_->getMutex().unlock();\n\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// we need to call the parent's getMapOrigin (instead of getOrigin) because\n// getOrigin is not const-correct.  we actually need to make sure that we're\n// not writing to the costmap_2d_ros::Costmap2DROS object (via getMapOrigin)...\n\tcostmap_->getOrigin(grid_.info.origin.position.x,\n\t\t\tgrid_.info.origin.position.y);\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// init data array\n\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// initialize the data\n\n\tunsigned int index = 0;\n\n\tfor (int i = 0; i < grid_.info.height; ++i)\n\n\t{\n\n\t  for (int j = 0; j < grid_.info.width; ++j)\n\n\t  {\n\n\t    grid_.data[index] = cost_translation_table_[costmap_->getCharMap()[index]];\n\n\t    ++index;\n\n\t  }\n\n\t}\n\n}", "CodeBleu_score": 63.81930315883617}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n\tdouble resolution = costmap_->getResolution();\n\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\tgrid_.info.origin.position.x = wx - resolution / 2;\n\tgrid_.info.origin.position.y = wy - resolution / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\tx0_ = costmap_->getSizeInCellsX();\n\ty0_ = costmap_->getSizeInCellsY();\n\n\tgrid_.data.resize(x0_ * y0_);\n\n\tconst char* costmap_chars = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < x0_ * y0_; i++)\n\t{\n\t\tgrid_.data[i] = cost_translation_table_[costmap_chars[i]];\n\t}\n}", "CodeBleu_score": 81.08091122110702}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (new_config.footprint!= old_config.footprint) {\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n      return;\n    } else {\n      ROS_ERROR(\\\"Failed to parse footprint string '%s'\\\", new_config.footprint.c_str());\n    }\n  }\n\n  if (new_config.robot_radius!= old_config.robot_radius) {\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 63.046114848589255}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t", "CodeBleu_score": 4.722552995136935}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t/*\n * If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n */\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n/*\n * If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n */\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (costmap_2d::convertToPoints(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n      return;\n    } else {\n      ROS_ERROR(\"Failed to parse footprint, using previous footprint\");\n    }\n  }\n/*\n * If the footprint string is invalid, it logs an error.\n */\n/*\n * If no valid footprint string is provided, it sets the footprint based on the robot radius.\n */\n  setUnpaddedRobotFootprint(costmap_2d::calculateMinAndMaxDistances(new_config.robot_radius));\n}", "CodeBleu_score": 69.52048330720292}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0,\n\t\t\t\t\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t//we also want to check if the new pose has moved outside the tolerance we specified\n\tif (new_pose.header.frame_id!= global_frame_ && new_pose.header.frame_id!= robot_base_frame_) {\n\t\tROS_ERROR_THROTTLE(1.0,\n\t\t\t\t\"The costmap's global frame is not the same as the robot base frame. Cannot process movement data. Current frames are: \nGlobal frame: %s \nRobot Base Frame: %s\",\n\t\t\t\tglobal_frame_.c_str(), robot_base_frame_.c_str());\n\t\treturn;\n\t}\n\n\ttf::Stamped<tf::Pose> tf_pose;\n\ttf::poseStampedMsgToTF(new_pose, tf_pose);\n\n\t//we also want to check if the new pose has moved outside the tolerance we specified\n\ttf::Stamped<tf::Pose> tf_old_pose;\n\tpose_cache_.lookupTransform(global_frame_, ros::Time(), robot_base_frame_,\n\t\t\tros::Time(), global_frame_, tf_old_pose);\n\n\t//we'll assume the robot has moved if the new_pose is outside of the tolerance\n\tif (tf_old_pose.getOrigin().distance(tf_pose.getOrigin()) > transform_tolerance_) {\n\t\t//we need to call one update to clear the robot's footprint\n\t\tupdateMap();\n\n\t\t//update the old pose so we know for the next iteration\n\t\tpose_cache_.setTransform(tf_pose, global_frame_, robot_base_frame_);\n\t}\n}", "CodeBleu_score": 64.48832235456807}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t#ifdef HAVE_NEW_YAMLCPP\n  if (dsrv_ == NULL)\n  {\n    dsrv_ = new dynamic_reconfigure::Server<costmap_2d::Costmap2DConfig>(ros::NodeHandle(name_));\n    dynamic_reconfigure::Server<costmap_2d::Costmap2DConfig>::CallbackType cb = boost::bind(&Costmap2DROS::reconfigureCB,\n                                                                                                this, _1, _2);\n    dsrv_->setCallback(cb);\n  }\n#endif\n\n  // get the list of plugins to load\n  std::vector<boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n\n  // if the costmap is stopped, we need to re-subscribe to topics\n  if (stopped_)\n  {\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin)\n    {\n      (*plugin)->activate();\n    }\n\n    stopped_ = false;\n  }\n\n  stop_updates_ = false;\n\n  // wait for costmap to be ready\n  ros::Rate r(100.0);\n  while (!layered_costmap_->isSizeLocked() && ros::ok())\n  {\n    ROS_DEBUG(\\\"Waiting for costmap to be ready\\\");\n    r.sleep();\n  }\n\n  // wait for the first map to be published... we need this because the first map is published\n  // before the costmap is initialized, so we don't want to mark the costmap as being initialized\n  // until we get the first map\n  while (!layered_costmap_->isInitialized() && ros::ok())\n  {\n    ROS_DEBUG(\\\"Waiting for map to be published...\\\n\\\");\n    r.sleep();\n  }\n\n  // wait for the map update thread to start\n  while (map_update_thread_ == NULL && ros::ok())\n  {\n    ROS_DEBUG(\\\"Waiting for map update thread to start\\\");\n    r.sleep();\n  }\n}", "CodeBleu_score": 66.81350017657505}, {"code": "void Costmap2DROS::start(){\n\t#ifdef HAVE_NEW_YAMLCPP\n  if (dsrv_->isActive())\n  {\n    ROS_WARN(\\\"Time-limited reconfiguration feature is not available when using the new YAML-CPP API.  Please use the old API.  See http://wiki.ros.org/navigation/Tutorials/Navigation%20Tuning%20Guide for details.\\\");\n  }\n#endif\n\n  // block until the costmap is re-initialized.. make sure to leave adequate time for ROS\n  // to fill the buffer\n  ros::Rate r(100.0);\n  while (ros::ok() &&!initialized_) {\n    ROS_DEBUG(\\\"Waiting for costmap to be re-initialized...\\\");\n    r.sleep();\n  }\n\n  if (stopped_) {\n    stopped_ = false;\n    stop_updates_ = false;\n    // block until the costmap is re-initialized.. make sure to leave adequate time for ROS\n    // to fill the buffer\n    ros::Rate r(100.0);\n    while (ros::ok() &&!initialized_) {\n      ROS_DEBUG(\\\"Waiting for costmap to be re-initialized...\\\");\n      r.sleep();\n    }\n\n    // re-subscribe to topics\n    std::vector<boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n    if (plugins!= NULL) {\n      for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin();\n           plugin!= plugins->end(); ++plugin) {\n        (*plugin)->activate();\n      }\n    }\n  }\n}", "CodeBleu_score": 60.87658387454864}, {"code": "void Costmap2DROS::start(){\n\t#ifdef HAVE_NEW_YAMLCPP\n  if (dsrv_ == NULL)\n  {\n    dsrv_ = new dynamic_reconfigure::Server<costmap_2d::Costmap2DConfig>(ros::NodeHandle(name_));\n    dynamic_reconfigure::Server<costmap_2d::Costmap2DConfig>::CallbackType cb = boost::bind(\n        &Costmap2DROS::reconfigureCB, this, _1, _2);\n    dsrv_->setCallback(cb);\n  }\n#endif\n\n  if (stopped_)\n  {\n    stopped_ = false;\n    stop_updates_ = false;\n    // re-subscribe to topics\n    for (unsigned int i = 0; i < plugins_.size(); ++i)\n    {\n      plugins_[i]->activate();\n    }\n  }\n\n  // wait for the first map to arrive\n  while (ros::ok() &&!initialized_)\n  {\n    if (current_ == NULL)\n    {\n      ROS_WARN_THROTTLE(1.0, \\\"Waiting for the first map to be received...\\\");\n    }\n    else\n    {\n      ROS_WARN_THROTTLE(1.0, \\\"Received a %d X %d map at %f m/pix\\\", current_->getSizeInCellsX(),\n                         current_->getSizeInCellsY(), current_->getResolution());\n    }\n    ros::spinOnce();\n    ros::Duration(0.1).sleep();\n  }\n\n  // wait for the map update thread to start\n  while (ros::ok() && map_update_thread_ == NULL)\n  {\n    ROS_WARN_THROTTLE(1.0, \\\"Waiting for the map update thread to start...\\\");\n    ros::spinOnce();\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 39.723957422062206}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t", "CodeBleu_score": 1.4641945780713905}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t// TODO: Implement me!\n}", "CodeBleu_score": 1.543726824886217}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t/*\n * This function, ObservationBuffer::purgeStaleObservations, removes outdated observations from the observation list.\nIf the observation_keep_time_ is zero, it keeps only the most recent observation.\nOtherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n */\n// void ObservationBuffer::purgeStaleObservations()\n{\n  // if we're supposed to keep all observations, then we're done\n  if (observation_keep_time_ == 0.0)\n  {\n    return;\n  }\n\n  // otherwise, we'll remove observations that are older than the specified keep time\n  ros::Duration keep_time_duration(observation_keep_time_);\n  ros::Time keep_time = ros::Time::now() - keep_time_duration;\n  list<Observation>::iterator obs_it;\n  for (obs_it = observation_list_.begin(); obs_it!= observation_list_.end(); ++obs_it)\n  {\n    if (obs_it->cloud_->header.stamp > keep_time)\n    {\n      // we've found an observation that is newer than the keep time, so we're done\n      break;\n    }\n  }\n\n  // remove all observations before the one we just found\n  observation_list_.erase(observation_list_.begin(), obs_it);\n}\n\n\n}", "CodeBleu_score": 42.695452642738886}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between the start and end yaw angles\n\tdouble angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose in the specified range\n\tdouble angle_increment = angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble angle = start_yaw + angle_increment * (i - start_index);\n\t\tset_angle(&path[i], angle);\n\t}\n}", "CodeBleu_score": 70.61439396222009}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble angle_diff = angles::shortest_angular_distance(start_angle, end_angle);\n\tdouble angle_inc = angle_diff / (end_index - start_index);\n\tdouble current_angle = start_angle;\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tcurrent_angle += angle_inc;\n\t\tset_angle(&path[i], current_angle);\n\t}\n}", "CodeBleu_score": 61.092407518619666}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Check if the start and end indices are valid\n\tif (start_index < 0 || end_index < 0 || start_index >= path.size() || end_index >= path.size()) {\n\t\treturn;\n\t}\n\n\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the specified range\n\tdouble delta_angle = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble angle = start_yaw + delta_angle * (i - start_index);\n\t\tset_angle(&path[i], angle);\n\t}\n}", "CodeBleu_score": 66.32143963395359}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\treq.start.header.frame_id = \\\"map\\\";\n\treq.goal.header.frame_id = \\\"map\\\";\n\tmakePlan(req.start, req.goal, resp.plan);\n\tresp.success = last_status_;\n\treturn true;\n}", "CodeBleu_score": 39.264000278186415}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t//set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = cmap_->getGlobalFrameID();\n\treq.goal.header.frame_id = cmap_->getGlobalFrameID();\n\n\t//call makePlan to generate a path\n\tmakePlan(req.start, req.goal, resp.plan);\n\n\t//update the response with the success status and the generated path if a plan is found\n\tresp.code = (resp.plan.size() > 0)? navfn::MakeNavPlan::Response::OK : navfn::MakeNavPlan::Response::NO_PLAN_FOUND;\n\n\t//return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 40.98472806164225}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\treq.start.header.frame_id = cmap_->getGlobalFrameID();\n\treq.goal.header.frame_id = cmap_->getGlobalFrameID();\n\tmakePlan(req.start, req.goal, resp.plan.poses);\n\tresp.plan.header.frame_id = cmap_->getGlobalFrameID();\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.success = true;\n\treturn true;\n}", "CodeBleu_score": 43.351514399106016}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n    ros::NodeHandle private_nh(\\\"~/\\\");\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n    cmap_ = cmap;\n}", "CodeBleu_score": 56.0032356459288}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n/*\n * This constructor, PlannerWithCostmap::PlannerWithCostmap, initializes a PlannerWithCostmap object with a given name and Costmap2DROS pointer.\nIt calls the base class constructor with the planner name, costmap, and global frame ID.\nIt sets up a private ROS node handle, advertises a \"make_plan\" service, and subscribes to the \"goal\" topic to receive PoseStamped messages for planning purposes.\n */\n    ros::NodeHandle private_nh(\\\"~/\\\");\n    cmap_ = cmap;\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 60.69468618982713}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n    ros::NodeHandle private_nh(\\\"~/\\\");\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n    cmap_ = cmap;\n}", "CodeBleu_score": 56.0032356459288}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"The planner has not been initialized, please call initialize() to use the planner\");\n\t\treturn false;\n\t}\n\n\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution - convert_offset_;\n\tmy = (wy - origin_y) / resolution - convert_offset_;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 90.6621488121971}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\treturn costmap_->worldToMap(wx, wy, mx, my)\n\t\t\t&&!((mx < 0) || (my < 0) || (mx >= costmap_->getSizeInCellsX())\n\t\t\t\t\t|| (my >= costmap_->getSizeInCellsY()));\n}", "CodeBleu_score": 40.11569031705534}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n\t\treturn false;\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 51.514822574831285}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\\t\n\tnav_msgs::Path gui_path;\n\\tgui_path.poses.resize(path.size());\n\\t\n\\tgui_path.header.frame_id = frame_id_;\n\\tgui_path.header.stamp = ros::Time::now();\n\\t\n\\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\\t// Convert to message\n\\tfor (unsigned int i = 0; i < path.size(); i++) {\n\\t\\tgui_path.poses[i] = path[i];\n\\t}\n\\t\n\\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 72.09370450578461}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\n\tnav_msgs::Path gui_path;\n\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 87.40035896730734}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\nThis can be updated in the future\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    //publish the plan\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 87.40810145759838}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tstate_ = GOAL_RECEIVED;\n\n\t// We want to send a goal to the local planner so we need a goal in the local planner's frame.\n\tif(tf_->waitForTransform(global_frame_, goal->header.frame_id, goal->header.stamp, ros::Duration(0.5))) {\n\t\tgeometry_msgs::PoseStamped temp;\n\t\ttf_->transformPose(global_frame_, ros::Time(0), *goal, goal->header.frame_id, temp);\n\n\t\t// Fill out the action message\n\t\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\t\taction_goal.header.stamp = ros::Time::now();\n\t\taction_goal.goal_id.id = ros::this_node::getName();\n\t\taction_goal.goal.target_pose = temp;\n\n\t\t// Publish the goal\n\t\taction_goal_pub_.publish(action_goal);\n\n\t\t// Make sure we have a costmap for our planner\n\t\tcostmap_2d::Costmap2DROS* costmap = planner_costmap_ros_;\n\t\tif(tc_) {\n\t\t\tcostmap = tc_->getCostmap();\n\t\t}\n\n\t\tboost::recursive_mutex::scoped_lock lock(planner_mutex_);\n\t\tplanners_.push_back(std::make_tuple(temp, computeGoalDistance(temp), costmap, 0));\n\n\t\tROS_DEBUG(\"Received a %lf, %lf, %lf goal\", temp.pose.position.x, temp.pose.position.y, tf::getYaw(temp.pose.orientation));\n\t} else {\n\t\tROS_ERROR(\"This robot's frame (%s) is not related to the goal's frame (%s) as specified in the global_frame_ parameter. Unable to process goal.\", global_frame_.c_str(), goal->header.frame_id.c_str());\n\t}\n}", "CodeBleu_score": 47.24254158316793}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = \"move_base\";\n\n\tactionlib_msgs::GoalStatus status;\n\tstatus.status = actionlib_msgs::GoalStatus::ACTIVE;\n\tstatus.goal_id = goal_id;\n\tstatus.text = \"MoveBase received a new goal\";\n\n\tas_->publishFeedback(status);\n\n\t//we have a new goal so make sure we clear the plan\n\tboost::unique_lock<boost::recursive_mutex> lock(planner_mutex_);\n\tplanner_plan_->clear();\n\tlatest_plan_->clear();\n\tcontroller_plan_->clear();\n\trunPlanner_ = false;\n\trunController_ = false;\n\n\tstate_ = PLANNING;\n\n\t//wake the planner thread if it is paused\n\tplanner_cond_.notify_one();\n\tlock.unlock();\n\n\t//publish the goal so that the visualization thread doesn't block\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = goal->header.stamp;\n\taction_goal.goal_id = goal_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 57.179967951728706}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = \"move_base\";\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = goal_id.stamp;\n\taction_goal.goal_id = goal_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 65.6760072527766}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_dist = getSqDistance();\n\tif (sq_dist > limited_distance_ * limited_distance_) {\n\t\tROS_INFO(\"Moved far enough, removing speed limit.\");\n\n\t\t//join and delete any existing thread\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\n\t\t//start a new thread to remove the speed limit\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\n\t\t//stop the distance check timer\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 73.92922473301886}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = getSqDistance();\n\tif (sq_distance > limited_distance_ * limited_distance_) {\n\t\tROS_WARN(\"Move slow and clear recovery behavior finished.\");\n\t\tdistance_check_timer_.stop();\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(\n\t\t\t\tboost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t}\n}", "CodeBleu_score": 61.675718667927704}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = getSqDistance();\n\tif (sq_distance >= limited_distance_ * limited_distance_) {\n\t\tROS_WARN(\n\t\t\t\t\"Move slow and clear recovery behavior moved the robot %.2fm, removing speed limit.\",\n\t\t\t\tsqrt(sq_distance));\n\t\tdistance_check_timer_.stop();\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(\n\t\t\t\tboost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t}\n}", "CodeBleu_score": 58.96149344672882}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tvector<PoseStamped> path;\n\n\ngetRobotPose(req.start);\n\n\nbool success = makePlan(req.start, *goal, path);\n\n\nif (success) {\n\n\n// Publish the plan\n\n\npublishPlan(path);\n\n\n}\n\n\n}", "CodeBleu_score": 54.569898363739476}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tvector<PoseStamped> path;\n\trm::PoseStamped start;\n\tcmap_->getRobotPose(start);\n\tbool success = makePlan(start, *goal, path);\n\t// Publish the plan for visualization purposes\n\tpublishPlan(path);\n}", "CodeBleu_score": 62.34300308239074}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tvector<PoseStamped> path;\n\n\tbool success = makePlan(getRobotPose(), *goal, path);\n\n\tif (success) {\n\n\t\tpublishPlan(path);\n\n\t}\n\n}", "CodeBleu_score": 53.19936679523541}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 58.98215379719254}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 58.98215379719254}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet set_param;\n\tset_param.request.param_id = param_set.param_id;\n\tset_param.request.value = param_set.value;\n\tthis->param_set_client_.call(set_param);\n}", "CodeBleu_score": 63.14665185700059}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t:NodeHandle nh;\n\t// \u521b\u5efaTCP\u670d\u52a1\u7aef\n\tint server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_sockfd == -1) {\n\t\tROS_ERROR(\"Create Socket Failed!\");\n\t\texit(1);\n\t}\n\n\t// \u7ed1\u5b9a\u7aef\u53e3\n\tstruct sockaddr_in server_addr;\n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_addr.s_addr = htons(INADDR_ANY);\n\tserver_addr.sin_port = htons(TCP_PORT);\n\tif (bind(server_sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr))) {\n\t\tROS_ERROR(\"Server Bind Port : %d Failed!\", TCP_PORT);\n\t\texit(1);\n\t}\n\n\t// \u76d1\u542c\u7aef\u53e3\n\tif (listen(server_sockfd, LENGTH_OF_LISTEN_QUEUE)) {\n\t\tROS_ERROR(\"Server Listen Failed!\");\n\t\texit(1);\n\t}\n\n\t// \u63a5\u6536\u5ba2\u6237\u7aef\u8bf7\u6c42\n\tstruct sockaddr_in client_addr;\n\tsocklen_t length = sizeof(client_addr);\n\n\t// \u5faa\u73af\u7b49\u5f85\u63a5\u53d7\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8bf7\u6c42\n\twhile (1) {\n\t\t// \u63a5\u53d7\u4e00\u4e2a\u5ba2\u6237\u7aef\u8bf7\u6c42\n\t\tint new_server_sockfd = accept(server_sockfd, (struct sockaddr *)&client_addr, &length);\n\t\tif (new_server_sockfd < 0) {\n\t\t\tROS_ERROR(\"Server Accept Failed!\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// \u8fde\u63a5\u6210\u529f\uff0c\u521b\u5efa\u65b0\u7ebf\u7a0b\u8fdb\u884c\u8bfb\u5199\u64cd\u4f5c\n\t\tboost::thread *t = new boost::thread(boost::bind(&CommunicationBridge::server_thread, this, new_server_sockfd));\n\t\tt->detach();\n\t}\n\tclose(server_sockfd);\n}", "CodeBleu_score": 47.48746428901942}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t::cout << \"recvData uav_cmd\" << std::endl;\n\tif (this->is_simulation_ == 0) {\n\t\tif (this->uav_basic_!= NULL) {\n\t\t\tthis->uav_basic_->publishCommand(uav_cmd);\n\t\t}\n\t} else {\n\t\tif (this->swarm_control_simulation_!= NULL) {\n\t\t\tthis->swarm_control_simulation_->publishCommand(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.914186074268656}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\ts_simulation_) {\n\t\tif (uav_basic_!= NULL) {\n\t\t\tuav_basic_->publishUAVCommand(uav_cmd);\n\t\t}\n\t} else {\n\t\tif (swarm_control_simulation_!= NULL) {\n\t\t\tswarm_control_simulation_->publishUAVCommand(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.968107551836667}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tis->is_simulation_ == 0) {\n\t\tthis->uav_basic_->commandPub(uav_cmd);\n\t} else {\n\t\tif (this->swarm_control_simulation_!= NULL) {\n\t\t\tthis->swarm_control_simulation_->commandPub(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 28.995051624327473}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.mode) {\n\t\tcase ModeSelection::Mode::REBOOTNX:\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase ModeSelection::Mode::EXITNX:\n\t\t\tsystem(\"exit\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tif (mode_selection.use_mode) {\n\t\tcreateMode(mode_selection);\n\t} else {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 49.46575990258256}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// If the mode is REBOOTNX, execute the system command to reboot the NX\n\tif (mode_selection.mode == ModeSelection::Mode::REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t}\n\t// If the mode is EXITNX, execute the system command to exit the NX\n\telse if (mode_selection.mode == ModeSelection::Mode::EXITNX) {\n\t\tsystem(\"exit\");\n\t}\n\t// If the mode is CREATEMODE, call the createMode function\n\telse if (mode_selection.mode == ModeSelection::Mode::CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t}\n\t// If the mode is DELETEMODE, call the deleteMode function\n\telse if (mode_selection.mode == ModeSelection::Mode::DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 78.0344015318054}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.mode) {\n\tcase ModeSelection::Mode::REBOOTNX:\n\t\tsystem(\"reboot\");\n\t\tbreak;\n\tcase ModeSelection::Mode::EXITNX:\n\t\tsystem(\"shutdown -h now\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (mode_selection.use_mode) {\n\t\tcreateMode(mode_selection);\n\t} else {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 49.57124573545792}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\ttract drone ID and trajectory data from message\n\tint drone_id = msg->drone_id;\n\tstd::vector<prometheus_msgs::Bspline> bspline_list = msg->bspline_list;\n\n\t// For each trajectory, initialize a Bspline struct, set its attributes, and populate its knots, position points, and yaw points\n\tfor (int i = 0; i < bspline_list.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.id = bspline_list[i].id;\n\t\tbspline.num_of_points = bspline_list[i].num_of_points;\n\t\tbspline.num_of_knots = bspline_list[i].num_of_knots;\n\t\tbspline.knots = bspline_list[i].knots;\n\t\tbspline.pos_x = bspline_list[i].pos_x;\n\t\tbspline.pos_y = bspline_list[i].pos_y;\n\t\tbspline.pos_z = bspline_list[i].pos_z;\n\t\tbspline.yaw = bspline_list[i].yaw;\n\n\t\t// Encode the MultiBsplines data and send it via TCP using the communication module\n\t\tcommunication->sendMultiBsplines(drone_id, bspline_list);\n\t}\n}", "CodeBleu_score": 33.521062805047464}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a pcl::PointCloud from the ROS PointCloud2 message\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create a PointCloudCompression object\n\tpcl::PointCloudCompression<pcl::PointXYZ> compression(true);\n\n\t// Set the parameters for the compression\n\tcompression.setCompressionLevel(1);\n\tcompression.setPointResolution(0.01);\n\tcompression.setOctreeResolution(0.05);\n\n\t// Compress the point cloud\n\tstd::vector<unsigned char> compressed_data;\n\tcompression.compressPointCloud(cloud, compressed_data);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.width = 1;\n\tcompressed_msg.height = 1;\n\tcompressed_msg.is_dense = false;\n\tcompressed_msg.is_bigendian = false;\n\tcompressed_msg.fields.resize(1);\n\tcompressed_msg.fields[0].name = \"data\";\n\tcompressed_msg.fields[0].offset = 0;\n\tcompressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\tcompressed_msg.fields[0].count = 1;\n\tcompressed_msg.point_step = compressed_data.size();\n\tcompressed_msg.row_step = compressed_data.size();\n\tcompressed_msg.data.resize(compressed_data.size());\n\tmemcpy(&compressed_msg.data[0], &compressed_data[0], compressed_data.size());\n\n\t// Release the dynamically allocated memory\n\tcompressed_data.clear();\n\tcompressed_data.shrink_to_fit();\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 37.54011494085388}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(compression_bits_);\n\toctree.setInputCloud(cloud_ptr);\n\toctree.encodePointCloud(compressed_data_);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = msg.height;\n\tcompressed_msg.width = msg.width;\n\tcompressed_msg.fields = msg.fields;\n\tcompressed_msg.is_bigendian = msg.is_bigendian;\n\tcompressed_msg.point_step = msg.point_step;\n\tcompressed_msg.row_step = msg.row_step;\n\tcompressed_msg.is_dense = msg.is_dense;\n\tcompressed_msg.data = compressed_data_;\n\n\t// Release dynamically allocated memory\n\tcompressed_data_.clear();\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 39.23305981642177}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a PointCloud2 message to store the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create an octree compression object\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(128, true);\n\n\t// Compress the point cloud\n\tstd::vector<unsigned char> compressed_data;\n\toctree.encodePointCloud(cloud, compressed_data);\n\n\t// Store the compressed data in the compressed message\n\tcompressed_msg.data = compressed_data;\n\tcompressed_msg.header = msg.header;\n\n\t// Release dynamically allocated memory\n\toctree.deleteTree();\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 34.99025418136606}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t// Iterate through the list of UAV states\n\tfor (int i = 0; i < multi_uav_state_.uav_state_all.size(); i++) {\n\t\t// If the UAV ID matches the current UAV state, replace it with the new uav_state data\n\t\tif (multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 63.93285949307581}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tprometheus_msgs::MultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_num = 0;\n\n\tfor (auto it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); it++) {\n\t\tprometheus_msgs::UGVState ugv_state;\n\t\tugv_state.ugv_id = (*it).ugv_id;\n\t\tugv_state.state = (*it).state;\n\t\tugv_state.location_source = (*it).location_source;\n\t\tugv_state.gps_status = (*it).gps_status;\n\t\tugv_state.gps_num = (*it).gps_num;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tugv_state.position[i] = (*it).position[i];\n\t\t\tugv_state.velocity[i] = (*it).velocity[i];\n\t\t\tugv_state.attitude[i] = (*it).attitude[i];\n\t\t}\n\t\tugv_state.attitude_q.x = (*it).attitude_q.x;\n\t\tugv_state.attitude_q.y = (*it).attitude_q.y;\n\t\tugv_state.attitude_q.z = (*it).attitude_q.z;\n\t\tugv_state.attitude_q.w = (*it).attitude_q.w;\n\t\tugv_state.battery_state = (*it).battery_state;\n\t\tugv_state.battery_percetage = (*it).battery_percetage;\n\n\t\tmulti_ugv_state.ugv_num++;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// \u53d1\u5e03\u8bdd\u9898\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 84.78932147249736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tprometheus_msgs::MultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_num = 0;\n\n\tfor (auto it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); it++) {\n\t\tprometheus_msgs::UGVState ugv_state;\n\t\tugv_state.ugv_id = (*it).ugv_id;\n\t\tugv_state.location_source = (*it).location_source;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tugv_state.position[i] = (*it).position[i];\n\t\t\tugv_state.velocity[i] = (*it).velocity[i];\n\t\t\tugv_state.attitude[i] = (*it).attitude[i];\n\t\t}\n\t\tugv_state.attitude_q.x = (*it).attitude_q.x;\n\t\tugv_state.attitude_q.y = (*it).attitude_q.y;\n\t\tugv_state.attitude_q.z = (*it).attitude_q.z;\n\t\tugv_state.attitude_q.w = (*it).attitude_q.w;\n\t\tthis->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// \u53d1\u5e03\u8bdd\u9898\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 82.86157699155225}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tprometheus_msgs::MultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_num = 0;\n\n\tfor (auto it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); it++) {\n\t\tprometheus_msgs::UGVState ugv_state;\n\t\tugv_state.ugv_id = (*it).ugv_id;\n\t\tugv_state.battery_state = (*it).battery_state;\n\t\tugv_state.battery_percetage = (*it).battery_percetage;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tugv_state.position[i] = (*it).position[i];\n\t\t\tugv_state.velocity[i] = (*it).velocity[i];\n\t\t\tugv_state.attitude[i] = (*it).attitude[i];\n\t\t}\n\t\tugv_state.attitude_q.x = (*it).attitude_q.x;\n\t\tugv_state.attitude_q.y = (*it).attitude_q.y;\n\t\tugv_state.attitude_q.z = (*it).attitude_q.z;\n\t\tugv_state.attitude_q.w = (*it).attitude_q.w;\n\n\t\tmulti_ugv_state.ugv_num++;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// \u53d1\u5e03\u8bdd\u9898\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 86.37803212885828}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\nint end_idx = q.cols() - order_;\nconst double CLEARANCE = 1.5;\ndouble t_now = ros::Time::now().toSec();\n\nfor (int i = order_; i < end_idx; i++) {\ndouble time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\nfor (int id = 0; id < moving_objs_->getObjNums(); id++) {\nEigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\ndouble dist = (cps_.points.col(i) - obj_prid).norm();\n//cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\ndouble dist_err = CLEARANCE - dist;\nEigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\nif (dist_err < 0) {\n/* do nothing */\n} else {\ncost += pow(dist_err, 2);\ngradient.col(i) += -2.0 * dist_err * dist_grad;\n}\n}\n// cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n// cout << \\\"--\\\" << endl;\n}\n// cout << \\\"---------------\\\" << endl;\n}", "CodeBleu_score": 37.273445573333845}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\t// Compute the third derivative of the spline\n\tEigen::MatrixXd third_derivative = getDerivative(3);\n\n\t// Get the knot times and control points of the jerk trajectory\n\tEigen::VectorXd knot_times = getKnot();\n\tEigen::MatrixXd jerk_control_points = third_derivative;\n\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble total_jerk = 0.0;\n\tfor (int i = 0; i < jerk_control_points.cols() - 1; i++) {\n\t\tfor (int j = 0; j < jerk_control_points.rows(); j++) {\n\t\t\ttotal_jerk += pow(jerk_control_points(j, i), 2) * (knot_times(i + 1) - knot_times(i));\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn total_jerk;\n}", "CodeBleu_score": 51.06099836415328}, {"code": "double UniformBspline::getJerk(){\n\t", "CodeBleu_score": 1.1628100042452454}, {"code": "double UniformBspline::getJerk(){\n\t\n// Compute the third derivative of the spline to obtain the jerk trajectory\n\nEigen::MatrixXd jerk_traj = getDerivative(3);\n\n// Retrieve the knot times and control points of the jerk trajectory\n\nEigen::VectorXd knot_times = jerk_traj.row(0);\nEigen::MatrixXd ctrl_pts = jerk_traj.block(1, 0, 3, jerk_traj.cols() - 1);\n\n// Initialize the total jerk value to zero\n\ndouble total_jerk = 0.0;\n\n// Iterate through the control points and dimensions\n\nfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\nfor (int j = 0; j < 3; j++) {\n\n// Sum the squared control point values multiplied by the differences in knot times\n\ntotal_jerk += pow(ctrl_pts(j, i), 2) * (knot_times(i + 1) - knot_times(i));\n\n}\n\n}\n\n// Return the total jerk value\n\nreturn total_jerk;\n\n}", "CodeBleu_score": 52.28843744539502}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u-cx_)*depth/fx_;\n\tpos(1) = (v-cy_)*depth/fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 59.96635432842913}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u-cx_)*depth/fx_;\n\tpos(1) = (v-cy_)*depth/fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 58.816077944516444}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.67477930149333}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\tstd::string child_frame_id = odom.child_frame_id;\n\tstd::string drone_id_str = child_frame_id.substr(child_frame_id.length() - 1, 1);\n\tint drone_id;\n\ttry {\n\t\tdrone_id = std::stoi(drone_id_str);\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::exception& e) {\n\t\tROS_WARN(\"Failed to extract drone ID from child_frame_id: %s\", e.what());\n\t}\n}", "CodeBleu_score": 52.59969609125568}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\t// Extract drone ID from odometry message\n\tstd::string child_frame_id = odom.child_frame_id;\n\tsize_t pos = child_frame_id.find(\"drone\");\n\tif (pos == std::string::npos) {\n\t\tROS_ERROR_STREAM(\"Failed to extract drone ID from odometry message: \" << odom);\n\t\treturn;\n\t}\n\tint drone_id = std::stoi(child_frame_id.substr(pos + 5));\n\n\t// Call rcvDroneOdomCallbackBase with extracted drone ID\n\ttry {\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Failed to process odometry message for drone \" << drone_id << \": \" << e.what());\n\t}\n}", "CodeBleu_score": 49.83076107299502}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string id = odom.child_frame_id.substr(odom.child_frame_id.size() - 1);\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(id));\n\t} catch (std::exception& e) {\n\t\tROS_WARN(\"Failed to extract drone ID from odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 46.93464834152075}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// ROS_WARN(\"detect\");\n\tEigen::Vector4d true_pose_cam;\n\tif (checkPose(drone_id, true_pixel, true_pose_cam)) {\n\t\tEigen::Vector4d true_pose_world = cam2world(true_pose_cam);\n\t\tEigen::Vector4d pose_error = true_pose_world - drone_pose_world_[drone_id];\n\t\tdebug_result_[drone_id].pose_error = pose_error;\n\t\tdebug_result_[drone_id].status = 1;\n\t\t// ROS_WARN(\"pose_error = %lf\", pose_error.norm());\n\t\tpose_error_pub_.publish(pose_error);\n\t} else {\n\t\tdebug_result_[drone_id].status = 0;\n\t}\n}", "CodeBleu_score": 36.55211408292871}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tpath.push_back(current->cameFrom);\n\t\tcurrent = current->cameFrom;\n\t}\n\treturn path;\n}", "CodeBleu_score": 74.26614895712476}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\nwhile (current!= nullptr) {\npath.push_back(current);\ncurrent = current->cameFrom;\n}\nreturn path;\n}", "CodeBleu_score": 58.44871543303414}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert the start and end points to indices\n\tstart_idx = grid_map_->coord2idx(start_pt);\n\tend_idx = grid_map_->coord2idx(end_pt);\n\n\t// If the start or end point is inside an obstacle, adjust it\n\tif (grid_map_->isOccupied(start_idx)) {\n\t\tVector3d dir = end_pt - start_pt;\n\t\tdouble dist = dir.norm();\n\t\tdir.normalize();\n\t\twhile (grid_map_->isOccupied(start_idx)) {\n\t\t\tstart_pt += dir * 0.1;\n\t\t\tstart_idx = grid_map_->coord2idx(start_pt);\n\t\t\tdist -= 0.1;\n\t\t\tif (dist <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (grid_map_->isOccupied(end_idx)) {\n\t\tVector3d dir = start_pt - end_pt;\n\t\tdouble dist = dir.norm();\n\t\tdir.normalize();\n\t\twhile (grid_map_->isOccupied(end_idx)) {\n\t\t\tend_pt += dir * 0.1;\n\t\t\tend_idx = grid_map_->coord2idx(end_pt);\n\t\t\tdist -= 0.1;\n\t\t\tif (dist <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.96266019299399}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tVector3d start_pt_copy = start_pt;\n\tVector3d end_pt_copy = end_pt;\n\n\t// Convert start and end points to indices\n\tif (!grid_map_->ConvertToIndex(start_pt, start_idx) ||!grid_map_->ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If start or end point is inside an obstacle, adjust it\n\tif (grid_map_->IsOccupied(start_idx)) {\n\t\tVector3d diff = end_pt_copy - start_pt_copy;\n\t\tVector3d direction = diff.normalized();\n\t\tdouble distance = diff.norm();\n\n\t\t// Adjust start point until it is no longer inside an obstacle\n\t\twhile (grid_map_->IsOccupied(start_idx)) {\n\t\t\tstart_pt_copy += direction * 0.01;\n\t\t\tif (!grid_map_->ConvertToIndex(start_pt_copy, start_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (grid_map_->IsOccupied(end_idx)) {\n\t\tVector3d diff = start_pt_copy - end_pt_copy;\n\t\tVector3d direction = diff.normalized();\n\t\tdouble distance = diff.norm();\n\n\t\t// Adjust end point until it is no longer inside an obstacle\n\t\twhile (grid_map_->IsOccupied(end_idx)) {\n\t\t\tend_pt_copy += direction * 0.01;\n\t\t\tif (!grid_map_->ConvertToIndex(end_pt_copy, end_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update start and end points\n\tstart_pt = start_pt_copy;\n\tend_pt = end_pt_copy;\n\n\treturn true;\n}", "CodeBleu_score": 40.013286955479245}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tVector3d start_pt_tmp = start_pt;\n\tVector3d end_pt_tmp = end_pt;\n\n\t// Convert start and end points to grid indices\n\tif (!grid_map_->ConvertToIndex(start_pt_tmp, start_idx))\n\t\treturn false;\n\tif (!grid_map_->ConvertToIndex(end_pt_tmp, end_idx))\n\t\treturn false;\n\n\t// Check if start or end point is inside an obstacle\n\tif (grid_map_->IsOccupied(start_idx)) {\n\t\t// If start point is inside an obstacle, adjust it by moving it away from the end point until it is no longer in an obstacle\n\t\twhile (grid_map_->IsOccupied(start_idx)) {\n\t\t\tstart_pt_tmp = start_pt_tmp + (end_pt - start_pt).normalized() * 0.01;\n\t\t\tif (!grid_map_->ConvertToIndex(start_pt_tmp, start_idx))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tif (grid_map_->IsOccupied(end_idx)) {\n\t\t// If end point is inside an obstacle, adjust it by moving it away from the start point until it is no longer in an obstacle\n\t\twhile (grid_map_->IsOccupied(end_idx)) {\n\t\t\tend_pt_tmp = end_pt_tmp + (start_pt - end_pt).normalized() * 0.01;\n\t\t\tif (!grid_map_->ConvertToIndex(end_pt_tmp, end_idx))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Update start and end points\n\tstart_pt = start_pt_tmp;\n\tend_pt = end_pt_tmp;\n\n\treturn true;\n}", "CodeBleu_score": 49.346848750738964}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// \u91cd\u7f6e\u5730\u56fe\n  Eigen::Vector3i min_id = world2grid(min_pos);\n  Eigen::Vector3i max_id = world2grid(max_pos);\n  for (int i = min_id(0); i <= max_id(0); ++i) {\n    for (int j = min_id(1); j <= max_id(1); ++j) {\n      for (int k = min_id(2); k <= max_id(2); ++k) {\n        md_.occupancy_buffer_inflate_[grid2index(i, j, k)] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 58.409885620132854}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// \u5c06\u8f93\u5165\u7684\u91cd\u7f6e\u8303\u56f4\u8f6c\u6362\u4e3avoxel\u5750\u6807\n\tEigen::Vector3i min_id = pos2id(min_pos);\n\tEigen::Vector3i max_id = pos2id(max_pos);\n\n\t// \u8fed\u4ee3\u91cd\u7f6evoxel\u5750\u6807\u8303\u56f4\u5185\u7684voxel\n\tfor (int x = min_id(0); x <= max_id(0); ++x)\n\t\tfor (int y = min_id(1); y <= max_id(1); ++y)\n\t\t\tfor (int z = min_id(2); z <= max_id(2); ++z) {\n\t\t\t\t// \u91cd\u7f6e\u5360\u636e\u6982\u7387\n\t\t\t\tmd_.occupancy_buffer_inflate_[id2idx(x, y, z)] = 0;\n\t\t\t}\n}", "CodeBleu_score": 75.53295948122837}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// \u5c06min_pos\u548cmax_pos\u8f6c\u6362\u4e3a\u5bf9\u5e94\u7684grid\u5750\u6807\n\tEigen::Vector3i min_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n\tEigen::Vector3i max_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\n\t// \u786e\u4fddmin_id\u548cmax_id\u5728\u5408\u7406\u7684\u8303\u56f4\u5185\n\tmin_id = min_id.cwiseMax(Eigen::Vector3i::Zero());\n\tmax_id = max_id.cwiseMin(mp_.map_voxel_num_ - Eigen::Vector3i::Ones());\n\n\t// \u8fed\u4ee3\u904d\u5386min_id\u548cmax_id\u4e4b\u95f4\u7684\u533a\u57df\uff0c\u5e76\u5c06\u5bf9\u5e94\u7684\u5143\u7d20\u8bbe\u7f6e\u4e3a\u96f6\n\tfor (int i = min_id(0); i <= max_id(0); i++) {\n\t\tfor (int j = min_id(1); j <= max_id(1); j++) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); k++) {\n\t\t\t\tint index = i + j * mp_.map_voxel_num_(0) + k * mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1);\n\t\t\t\tmd_.occupancy_buffer_inflate_[index] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.556738739824304}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_trans = std::numeric_limits<double>::max();\n\tdouble min_trans = std::numeric_limits<double>::min();\n\n\tdouble trans_x = max_trans, trans_y = max_trans, trans_z = max_trans;\n\tif (diff(0) > 0) {\n\t\ttrans_x = (mp_.map_bound_max_(0) - camera_pt(0)) / diff(0);\n\t} else if (diff(0) < 0) {\n\t\ttrans_x = (mp_.map_bound_min_(0) - camera_pt(0)) / diff(0);\n\t}\n\tif (diff(1) > 0) {\n\t\ttrans_y = (mp_.map_bound_max_(1) - camera_pt(1)) / diff(1);\n\t} else if (diff(1) < 0) {\n\t\ttrans_y = (mp_.map_bound_min_(1) - camera_pt(1)) / diff(1);\n\t}\n\tif (diff(2) > 0) {\n\t\ttrans_z = (mp_.map_bound_max_(2) - camera_pt(2)) / diff(2);\n\t} else if (diff(2) < 0) {\n\t\ttrans_z = (mp_.map_bound_min_(2) - camera_pt(2)) / diff(2);\n\t}\n\n\tdouble min_trans_x = std::min(trans_x, 1.0);\n\tdouble min_trans_y = std::min(trans_y, 1.0);\n\tdouble min_trans_z = std::min(trans_z, 1.0);\n\n\tdouble min_trans = std::min(min_trans_x, std::min(min_trans_y, min_trans_z));\n\n\treturn camera_pt + diff * min_trans;\n}", "CodeBleu_score": 38.22908641169016}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_trans(mp_.local_range_ / 2, mp_.local_range_ / 2, mp_.local_range_ / 2);\n\tEigen::Vector3d min_trans(-mp_.local_range_ / 2, -mp_.local_range_ / 2, -mp_.local_range_ / 2);\n\tEigen::Vector3d trans_coef(1, 1, 1);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (diff(i) > 0) {\n\t\t\ttrans_coef(i) = (max_trans(i) - camera_pt(i)) / diff(i);\n\t\t} else if (diff(i) < 0) {\n\t\t\ttrans_coef(i) = (min_trans(i) - camera_pt(i)) / diff(i);\n\t\t}\n\t}\n\tdouble min_scale = trans_coef.minCoeff();\n\tEigen::Vector3d res = camera_pt + diff * min_scale;\n\treturn res;\n}", "CodeBleu_score": 47.772419594278745}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n  Eigen::Vector3d diff = pt - camera_pt;\n  double max_trans_coeff = 1.0;\n  double min_trans_coeff = 1.0;\n\n  for (int i = 0; i < 3; ++i)\n  {\n    if (diff(i) > 0)\n    {\n      max_trans_coeff = std::min(max_trans_coeff, (md_.bound_max_(i) - camera_pt(i)) / diff(i));\n    }\n    else if (diff(i) < 0)\n    {\n      min_trans_coeff = std::min(min_trans_coeff, (md_.bound_min_(i) - camera_pt(i)) / diff(i));\n    }\n  }\n\n  Eigen::Vector3d pt_in_map = pt - (max_trans_coeff + min_trans_coeff) / 2.0 * diff;\n  return pt_in_map;\n}", "CodeBleu_score": 45.46712555061047}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t//  printf(\"updateOccupancyCallback\n\");\n  // update last occupancy update time\n  md_.last_occupancy_update_time_ = ros::Time::now();\n\n  // update local map if needed\n  if (md_.local_map_updated_) {\n    clearLocalMap();\n    inflateLocalMap();\n    md_.local_map_updated_ = false;\n  }\n\n  // update occupancy grid\n  if (md_.update_occupancy_needed_) {\n    // printf(\"update_occupancy_needed_:\n\");\n    // update occupancy grid\n    if (md_.depth_image_updated_) {\n      // printf(\"depth_image_updated_:\n\");\n      // project depth image into points\n      vector<Eigen::Vector3f> points;\n      vector<Eigen::Vector3f> normals;\n      vector<Eigen::Vector2f> uv;\n      projectDepthImage(points, normals, uv);\n\n      // process points with raycasting\n      if (points.size() > 0) {\n        raycast(points, normals, uv);\n      }\n    }\n\n    // handle timeout errors\n    if (md_.depth_image_timeout_) {\n      // printf(\"depth_image_timeout_:\n\");\n      md_.depth_image_timeout_ = false;\n      md_.update_occupancy_needed_ = false;\n      md_.depth_image_updated_ = false;\n      md_.depth_image_updated_ = false;\n      md_.depth_image_updated_ = false;\n    }\n\n    if (md_.odom_timeout_) {\n      // printf(\"odom_timeout_:\n\");\n      md_.odom_timeout_ = false;\n      md_.update_occupancy_needed_ = false;\n    }\n  }\n}", "CodeBleu_score": 56.32525443831386}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_sum = 0.f;\n\tfor (unsigned i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> ell_gt, ell_dt;\n\t\t_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\t\tfmeasure_sum += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\t}\n\treturn fmeasure_sum / float(image_fns.size());\n}", "CodeBleu_score": 69.59769492001237}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_avg(0.f);\n\tunsigned sz = image_fns.size();\n\n\tfor (unsigned i = 0; i < sz; ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tfmeasure_avg += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\tfmeasure_avg /= float(sz);\n\treturn fmeasure_avg;\n}", "CodeBleu_score": 58.52322697932946}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat total_fmeasure = 0.0;\n\tint num_images = image_fns.size();\n\n\tfor (int i = 0; i < num_images; i++) {\n\t\tstring image_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\n\t\tMat3b img = imread(image_fn, IMREAD_COLOR);\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\ttotal_fmeasure += fmeasure;\n\t}\n\n\tfloat avg_fmeasure = total_fmeasure / num_images;\n\treturn avg_fmeasure;\n}", "CodeBleu_score": 50.79657357233657}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat theta1, theta2, theta;\n\tif (foci == NULL) {\n\t\tfprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\n\");\n\t\treturn 0.0;\n\t}\n\ttheta1 = atan2(y - foci[1], x - foci[0]);\n\ttheta2 = atan2(y - foci[3], x - foci[2]);\n\ttheta = angle_diff_signed(theta1, theta2);\n\treturn theta;\n}", "CodeBleu_score": 54.51152688147397}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2, angle;\n\tif (foci == NULL) {\n\t\tfprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\n\");\n\t\treturn 0.0;\n\t}\n\tangle1 = atan2(y - foci[1], x - foci[0]);\n\tangle2 = atan2(y - foci[3], x - foci[2]);\n\tangle = angle_diff_signed(angle1, angle2);\n\treturn angle;\n}", "CodeBleu_score": 51.57765141518601}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x_angle, y_angle, angle;\n\n\t/* check parameters */\n\tif (foci == NULL) fprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\");\n\n\t/* calculate angle to each focus */\n\ta = foci[0] - x;\n\tb = foci[1] - y;\n\tc = foci[2] - x;\n\td = foci[3] - y;\n\te = sqrt(a * a + b * b);\n\tf = sqrt(c * c + d * d);\n\n\t/* calculate normal angle */\n\tg = acos(a / e);\n\th = acos(c / f);\n\ti = angle_diff_signed(g, h);\n\tj = a * b;\n\tk = c * d;\n\tl = a * d;\n\tm = b * c;\n\tn = j + k;\n\to = l - m;\n\tp = sqrt(n * n + o * o);\n\tq = a * a + b * b;\n\tr = c * c + d * d;\n\ts = q + r;\n\tt = sqrt(s);\n\tu = n / t;\n\tv = o / t;\n\tw = atan(v / u);\n\tx_angle = w;\n\ty_angle = w + M_PI_2;\n\tangle = angle_diff_signed(i, x_angle);\n\n\t/* adjust angle to lie within [-\u03c0, \u03c0] */\n\twhile (angle <= -M_PI) angle += M_2__PI;\n\twhile (angle > M_PI) angle -= M_2__PI;\n\n\treturn angle;\n}", "CodeBleu_score": 53.496538740487956}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u < integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 92.93345308179536}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u < integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 92.93345308179536}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u < integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 92.93345308179536}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// Iterate through each detection info\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\t// Update the ellipse_det variable\n\t\tellipse_det = msg->detection_info[i];\n\n\t\t// If an object named \"T\" is detected, increment num_regain and reset num_lost\n\t\tif (ellipse_det.name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\t// Otherwise, reset num_regain and increment num_lost\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\n\t\t// If num_lost exceeds VISION_THRES, set is_detected to false\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\n\t\t// If num_regain exceeds VISION_THRES, set is_detected to true\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\n\t\t// Swap the sight_angle values of ellipse_det\n\t\tfloat temp = ellipse_det.sight_angle[0];\n\t\tellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n\t\tellipse_det.sight_angle[1] = temp;\n\t}\n}", "CodeBleu_score": 69.45104108139999}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// \u904d\u5386\u6bcf\u4e2a\u68c0\u6d4b\u4fe1\u606f\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\t// \u5982\u679c\u68c0\u6d4b\u5230\u76ee\u6807\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\t// \u589e\u52a0\u8ba1\u6570\u5668\n\t\t\tnum_regain++;\n\t\t\t// \u91cd\u7f6e\u8ba1\u6570\u5668\n\t\t\tnum_lost = 0;\n\t\t\t// \u76ee\u6807\u5df2\u68c0\u6d4b\n\t\t\tis_detected = true;\n\t\t} else {\n\t\t\t// \u91cd\u7f6e\u8ba1\u6570\u5668\n\t\t\tnum_regain = 0;\n\t\t\t// \u589e\u52a0\u8ba1\u6570\u5668\n\t\t\tnum_lost++;\n\t\t\t// \u76ee\u6807\u672a\u68c0\u6d4b\n\t\t\tis_detected = false;\n\t\t}\n\t\t// \u5982\u679c\u4e22\u5931\u8ba1\u6570\u5668\u8d85\u8fc7\u9608\u503c\n\t\tif (num_lost > VISION_THRES) {\n\t\t\t// \u76ee\u6807\u672a\u68c0\u6d4b\n\t\t\tis_detected = false;\n\t\t}\n\t\t// \u5982\u679c\u68c0\u6d4b\u8ba1\u6570\u5668\u8d85\u8fc7\u9608\u503c\n\t\tif (num_regain > VISION_THRES) {\n\t\t\t// \u76ee\u6807\u5df2\u68c0\u6d4b\n\t\t\tis_detected = true;\n\t\t}\n\t\t// \u5982\u679c\u68c0\u6d4b\u5230\u76ee\u6807\n\t\tif (is_detected) {\n\t\t\t// \u76ee\u6807\u4fe1\u606f\n\t\t\tellipse_det = msg->detection_info[i];\n\t\t\t// \u4ea4\u6362\u89c6\u89d2\u89d2\u5ea6\n\t\t\tstd::swap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n\t\t}\n\t}\n}", "CodeBleu_score": 62.12658301368862}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// Iterate through each detection info\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\t// Update ellipse_det if object name is \"T\"\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tellipse_det = msg->detection_info[i];\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\n\t\t// Update is_detected based on num_lost and num_regain\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t} else if (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\n\t\t// Swap the sight_angle values of ellipse_det\n\t\tfloat temp = ellipse_det.sight_angle[0];\n\t\tellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n\t\tellipse_det.sight_angle[1] = temp;\n\t}\n}", "CodeBleu_score": 67.1416308438734}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// \u8ba1\u7b97\u5f53\u524d\u4f4d\u7f6e\u7684\u7d22\u5f15\n\tEigen::Vector3i cur_pos_index = posToIndex(cur_pos);\n\n\t// \u8ba1\u7b97\u5b89\u5168\u8ddd\u79bb\u5bf9\u5e94\u7684\u7d22\u5f15\n\tint safe_distance_index = ceil(safe_distance / resolution_);\n\n\t// \u904d\u5386\u5f53\u524d\u4f4d\u7f6e\u5468\u56f4\u7684\u7d22\u5f15\uff0c\u68c0\u67e5\u662f\u5426\u5b58\u5728\u88ab\u5360\u636e\u7684\u7d22\u5f15\n\tfor (int i = -safe_distance_index; i <= safe_distance_index; i++) {\n\t\tfor (int j = -safe_distance_index; j <= safe_distance_index; j++) {\n\t\t\tfor (int k = -safe_distance_index; k <= safe_distance_index; k++) {\n\t\t\t\tEigen::Vector3i index(cur_pos_index(0) + i, cur_pos_index(1) + j, cur_pos_index(2) + k);\n\t\t\t\tif (Occupy_map_ptr->is_occupy(index)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.899806933386884}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Check if the current position is within the map boundaries\n\tif (cur_pos(0) < origin_(0) || cur_pos(0) > origin_(0) + map_size_(0) * resolution_ || cur_pos(1) < origin_(1) ||\n\t\t\tcur_pos(1) > origin_(1) + map_size_(1) * resolution_ || cur_pos(2) < origin_(2) ||\n\t\t\tcur_pos(2) > origin_(2) + map_size_(2) * resolution_) {\n\t\treturn false;\n\t}\n\n\t// Check if the current position is within the safe distance of any obstacle\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tEigen::Vector3d check_pos = cur_pos + Eigen::Vector3d(i - 1, j - 1, k - 1) * resolution_;\n\t\t\t\tif (Occupy_map_ptr->getCost(check_pos) > safe_distance) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 40.01840024493788}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Check if the current position is within the bounds of the Occupy_map_ptr\n\tif (cur_pos[0] < Occupy_map_ptr->min_x_ || cur_pos[0] > Occupy_map_ptr->max_x_ ||\n\t\tcur_pos[1] < Occupy_map_ptr->min_y_ || cur_pos[1] > Occupy_map_ptr->max_y_ ||\n\t\tcur_pos[2] < Occupy_map_ptr->min_z_ || cur_pos[2] > Occupy_map_ptr->max_z_) {\n\t\treturn false;\n\t}\n\n\t// Check if the current position is within the safe distance of any obstacle\n\tfor (int i = 0; i < Occupy_map_ptr->obstacle_list_.size(); ++i) {\n\t\tif (cur_pos.norm() < Occupy_map_ptr->obstacle_list_[i].pos_.norm() + safe_distance) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 40.5224971643094}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Clear the path nodes vector\n\tpath_nodes_.clear();\n\n\t// Start from the end node and trace the path back to the start node\n\tNodePtr cur_node = end_node;\n\twhile (cur_node!= NULL) {\n\t\tpath_nodes_.push_back(cur_node);\n\t\tcur_node = cur_node->parent;\n\t}\n\n\t// Reverse the order of path_nodes_ to present the path from start to end\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 59.39731847414313}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// \u8def\u5f84\u70b9\u7684\u4e2a\u6570\n\tint path_num = 0;\n\t// \u8bb0\u5f55\u5f53\u524d\u8282\u70b9\n\tNodePtr cur_node = end_node;\n\t// \u8bb0\u5f55\u5f53\u524d\u8282\u70b9\u7684\u7236\u8282\u70b9\n\tNodePtr parent_node = end_node->parent;\n\n\t// \u5faa\u73af\uff0c\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u8d77\u59cb\u70b9\n\twhile (parent_node!= NULL) {\n\t\t// \u5c06\u5f53\u524d\u8282\u70b9\u52a0\u5165\u5230\u8def\u5f84\u70b9\u4e2d\n\t\tpath_nodes_.push_back(cur_node);\n\t\t// \u8def\u5f84\u70b9\u7684\u4e2a\u6570+1\n\t\tpath_num++;\n\t\t// \u66f4\u65b0\u5f53\u524d\u8282\u70b9\n\t\tcur_node = parent_node;\n\t\t// \u66f4\u65b0\u7236\u8282\u70b9\n\t\tparent_node = cur_node->parent;\n\t}\n\t// \u6700\u540e\u5c06\u8d77\u59cb\u70b9\u52a0\u5165\u5230\u8def\u5f84\u70b9\u4e2d\n\tpath_nodes_.push_back(cur_node);\n\t// \u8def\u5f84\u70b9\u7684\u4e2a\u6570+1\n\tpath_num++;\n\n\t// \u8def\u5f84\u70b9\u7684\u4e2a\u6570\n\tpath_num_ = path_num;\n\n\t// \u53cd\u8f6c\u8def\u5f84\u70b9\u7684\u987a\u5e8f\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 54.11224525831443}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t", "CodeBleu_score": 2.946422658534493}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id] << odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z;\n\tget_nei_state[id] = true;\n\tif(sim_mode)\n\t{\n\t\tdouble dist = (state_nei[id] - state_init).norm();\n\t\tif(dist > 5.0)\n\t\t{\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.28561891687018}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    state_nei[id] << odom->pose.pose.position.x,\n                    odom->pose.pose.position.y,\n                    odom->pose.pose.position.z;\n\n    if(sim_mode)\n    {\n        if( (state_nei[id].block<2,1>(0,0) - odom_start.block<2,1>(0,0)).norm() > 5.0 )\n        {\n            get_nei_state[id] = false;\n        }\n        else\n        {\n            get_nei_state[id] = true;\n        }\n    }\n    else\n    {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 57.96825788367379}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//    if (!odom_ready)\n//        return;\n//\n//    sensor_ready = true;\n//    update_counter++;\n//\n//    if (update_counter % 5!= 0)\n//        return;\n//\n//    update_counter = 0;\n//\n//    // \u8f6c\u6362\u4e3apcl\u683c\u5f0f\n//    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n//    pcl::fromROSMsg(*msg, *cloud);\n//\n//    // \u66f4\u65b0\u5730\u56fe\n//    Astar_ptr->Occupy_map_ptr->update_map(cloud, ugv_odom.pose.pose.position);\n}", "CodeBleu_score": 5.524728674891709}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n/*\n * If the odometry is not ready, return immediately.\n */\n    if (!odom_ready) {\n        return;\n    }\n\n/*\n * Set the sensor_ready flag to true and increment an update counter.\n */\n    sensor_ready = true;\n    update_counter++;\n\n/*\n * Every fifth update, update the Astar map with the new point cloud data and reset the update counter.\n */\n    if (update_counter >= 5) {\n        Astar_ptr->Occupy_map_ptr->update_map(msg, ugv_odom);\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 60.87570581530118}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tsensor_ready = true;\n\tcounter_search++;\n\n\t// update the map every 5th update\n\tif (counter_search >= 5) {\n\t\tcounter_search = 0;\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg, ugv_odom);\n\t}\n}", "CodeBleu_score": 53.600282673185994}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\t// \u70b9\u4e91\u8f6c\u6362\n\t\tpcl::fromROSMsg(*global_point, *global_point_cloud_map);\n\t\t// \u81a8\u80c0\u70b9\u4e91\n\t\tinflate_point_cloud(global_point_cloud_map, cloud_inflate_vis_, enum_p_ugv, inflate_index_ugv);\n\t\t// \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\n\t\tpcl::toROSMsg(*cloud_inflate_vis_, global_inflate_pcl_msg);\n\t\tglobal_inflate_pcl_msg.header.stamp = ros::Time::now();\n\t\tglobal_inflate_pcl_pub.publish(global_inflate_pcl_msg);\n\t}\n}", "CodeBleu_score": 52.578165532526725}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\t// \u8f6c\u6362\u5168\u5c40\u70b9\u4e91\n\t\tpcl::fromROSMsg(*global_point, *input_point_cloud);\n\t\t// \u81a8\u80c0\u5168\u5c40\u70b9\u4e91\n\t\tinflate_pcl(input_point_cloud, cloud_inflate_vis_, ifn);\n\t\t// \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\n\t\tpcl::toROSMsg(*cloud_inflate_vis_, global_inflate_pcl);\n\t\tglobal_inflate_pcl.header.frame_id = \"world\";\n\t\tglobal_inflate_pcl_pub.publish(global_inflate_pcl);\n\t}\n}", "CodeBleu_score": 53.7195333287539}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\tlaser_scan_to_pcl(local_point, input_point_cloud);\n\t// \u5c40\u90e8\u5730\u56fe\n\tlocal_point_cloud_map = input_point_cloud;\n\t// \u5c40\u90e8\u5730\u56fe\u81a8\u80c0\n\tinflate_point_cloud();\n\t// \u5c40\u90e8\u5730\u56fe\u5408\u5e76\u5230\u5168\u5c40\u5730\u56fe\n\tif (!sim_mode) {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 57.423544634214785}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\t// 1. \u5148\u5c06laser\u6570\u636e\u8f6c\u4e3a\u70b9\u4e91\u6570\u636e\n\t// 2. \u518d\u5c06\u70b9\u4e91\u6570\u636e\u8f6c\u4e3apcl::PointCloud<pcl::PointXYZ>\n\tlaser_geometry::LaserProjection projector_;\n\tprojector_.projectLaser(*local_point, *input_point_cloud);\n\n\thas_global_point = true;\n\n\tif (sim_mode) {\n\t\tif (queue_size <= 0) // without slide windows\n\t\t{\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *input_point_cloud;\n\t\t} else // with slide windows\n\t\t{\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor (iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 54.91003168799645}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\tlaser_scan_to_pcl(local_point, input_point_cloud);\n\n\tif (sim_mode) {\n\t\tif (queue_size <= 0) // without slide windows\n\t\t{\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *input_point_cloud;\n\t\t} else // with slide windows\n\t\t{\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor (iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 55.41865807117854}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tif (has_global_point) {\n\t\t// Convert global point cloud map to ROS message\n\t\tsensor_msgs::PointCloud2 global_pcl_msg;\n\t\tpcl::toROSMsg(*global_point_cloud_map, global_pcl_msg);\n\t\tglobal_pcl_msg.header.frame_id = \"world\";\n\t\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t\t// Convert inflated point cloud to ROS message\n\t\tsensor_msgs::PointCloud2 inflate_pcl_msg;\n\t\tpcl::toROSMsg(*cloud_inflate_vis_, inflate_pcl_msg);\n\t\tinflate_pcl_msg.header.frame_id = \"world\";\n\t\tinflate_pcl_pub.publish(inflate_pcl_msg);\n\t}\n}", "CodeBleu_score": 64.4242170183514}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// cout << BLUE << \\\"33333 \\\" << TAIL <<endl;\n\n    // \u53d1\u5e03\u5168\u5c40\u5730\u56fe\u70b9\u4e91\n    if(has_global_point)\n    {\n        if(get_gpcl)\n        {\n            sensor_msgs::PointCloud2 cloud_msg;\n            pcl::toROSMsg(*global_point_cloud_map, cloud_msg);\n            cloud_msg.header.frame_id = \\\"world\\\";\n            global_pcl_pub.publish(cloud_msg);\n        }\n    }\n\n    // \u53d1\u5e03\u81a8\u80c0\u540e\u7684\u70b9\u4e91\n    sensor_msgs::PointCloud2 cloud_msg;\n    pcl::toROSMsg(*cloud_inflate_vis_, cloud_msg);\n    cloud_msg.header.frame_id = \\\"world\\\";\n    inflate_pcl_pub.publish(cloud_msg);\n}", "CodeBleu_score": 51.97909371786146}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// Update the A* algorithm's map using the new point cloud data and current UAV odometry.\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom);\n}", "CodeBleu_score": 86.05320470815471}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u8f83\u5c0f\uff0c\u9700\u8981\u9891\u7e41\u66f4\u65b0\n\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_pos);\n}", "CodeBleu_score": 92.16990203078916}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// Update the A* algorithm's map using the new point cloud data and current UAV odometry.\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_pos, uav_yaw);\n}", "CodeBleu_score": 74.87603654771921}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t/ Calculate target foot positions based on the desired pose using the body controller.\n\tbody_controller_.update(req_pose_, rosTimeToChampTime(event.current_real));\n\n\t// Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions.\n\tleg_controller_.update(body_controller_.getFootPositions(), rosTimeToChampTime(event.current_real));\n\tkinematics_.update(leg_controller_.getLegVelocities(), rosTimeToChampTime(event.current_real));\n\n\t// Publish foot contact information.\n\tif (publish_foot_contacts_) {\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.contacts = leg_controller_.getFootContacts();\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n\n\t// Publish joint positions.\n\tif (publish_joint_states_) {\n\t\tsensor_msgs::JointState joint_state_msg;\n\t\tjoint_state_msg.header.stamp = ros::Time::now();\n\t\tjoint_state_msg.name = joint_names_;\n\t\tjoint_state_msg.position = kinematics_.getJointPositions();\n\t\tjoint_states_publisher_.publish(joint_state_msg);\n\t}\n\n\t// Publish joint commands.\n\tif (publish_joint_control_) {\n\t\ttrajectory_msgs::JointTrajectory joint_command_msg;\n\t\tjoint_command_msg.header.stamp = ros::Time::now();\n\t\tjoint_command_msg.joint_names = joint_names_;\n\t\tjoint_command_msg.points.resize(1);\n\t\tjoint_command_msg.points[0].positions = kinematics_.getJointPositions();\n\t\tjoint_commands_publisher_.publish(joint_command_msg);\n\t}\n}", "CodeBleu_score": 35.799263488359216}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t/ Calculate target foot positions based on the desired pose using the body controller.\n\tchamp::Pose target_pose = body_controller_.update(req_pose_, rosTimeToChampTime(event.current_real));\n\n\t// Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions.\n\tleg_controller_.update(target_pose, rosTimeToChampTime(event.current_real));\n\tkinematics_.update(leg_controller_.getJointCommands(), rosTimeToChampTime(event.current_real));\n\n\t// Publish foot contact information and joint positions.\n\tif (publish_foot_contacts_) {\n\t\tchamp_msgs::ContactsStamped foot_contacts;\n\t\tfoot_contacts.header.stamp = ros::Time::now();\n\t\tfoot_contacts.contacts = leg_controller_.getFootContacts();\n\t\tfoot_contacts_publisher_.publish(foot_contacts);\n\t}\n\n\tif (publish_joint_states_ &&!in_gazebo_) {\n\t\tsensor_msgs::JointState joint_states;\n\t\tjoint_states.header.stamp = ros::Time::now();\n\t\tjoint_states.name = joint_names_;\n\t\tjoint_states.position = kinematics_.getJointPositions();\n\t\tjoint_states.velocity = kinematics_.getJointVelocities();\n\t\tjoint_states.effort = kinematics_.getJointEfforts();\n\t\tjoint_states_publisher_.publish(joint_states);\n\t}\n\n\tif (publish_joint_control_) {\n\t\ttrajectory_msgs::JointTrajectory joint_commands;\n\t\tjoint_commands.header.stamp = ros::Time::now();\n\t\tjoint_commands.joint_names = joint_names_;\n\t\tjoint_commands.points.resize(1);\n\t\tjoint_commands.points[0].positions = kinematics_.getJointPositions();\n\t\tjoint_commands.points[0].velocities = kinematics_.getJointVelocities();\n\t\tjoint_commands.points[0].effort = kinematics_.getJointEfforts();\n\t\tjoint_commands.points[0].time_from_start = ros::Duration(0.01);\n\t\tjoint_commands_publisher_.publish(joint_commands);\n\t}\n}", "CodeBleu_score": 35.170480801705835}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t/ Calculate target foot positions based on the desired pose using the body controller\n\tchamp::Pose target_pose;\n\tbody_controller_.update(req_pose_, target_pose);\n\n\t// Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions\n\tchamp::PhaseGenerator::Time time = rosTimeToChampTime(event.current_real);\n\tleg_controller_.update(target_pose, time);\n\tkinematics_.update(leg_controller_.getLegStates(), target_joint_positions_);\n\n\t// Publish foot contact information and joint positions\n\tif (publish_foot_contacts_) {\n\t\tpublishFootContacts();\n\t}\n\tif (publish_joint_states_) {\n\t\tpublishJointStates();\n\t}\n\tif (publish_joint_control_) {\n\t\tpublishJointCommands();\n\t}\n}", "CodeBleu_score": 40.145375072500386}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\n\t\tfor (size_t i = 0; i < 4; ++i) {\n\t\t\tcontacts_msg.contact_states.push_back(foot_contacts[i]);\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 57.134850887701475}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.contacts.resize(4);\n\n\t\tfor (size_t i = 0; i < 4; ++i) {\n\t\t\tcontacts_msg.contacts[i].phase = leg_controller_.getPhase(i);\n\t\t\tcontacts_msg.contacts[i].contact = foot_contacts[i];\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 66.78555043141299}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped foot_contacts_msg;\n\n\t\tfoot_contacts_msg.header.stamp = ros::Time::now();\n\t\tfoot_contacts_msg.contact.resize(4);\n\n\t\tfor (size_t i = 0; i < 4; ++i) {\n\t\t\tfoot_contacts_msg.contact[i].leg_index = i;\n\t\t\tfoot_contacts_msg.contact[i].is_in_contact = foot_contacts[i];\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(foot_contacts_msg);\n\t}\n}", "CodeBleu_score": 59.617789057704165}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a minimal joints message with the first 12 joint positions\n\tjoints_minimal = Joints()\njoints_minimal.header.stamp = rospy.Time.now()\njoints_minimal.joint_names = self.joint_names\njoints_minimal.joint_angles = joints.position[:12]\nself.joint_minimal_pub.publish(joints_minimal)\n\n// Create a joint trajectory message with the same positions and a specified duration\ntrajectory = JointTrajectory()\ntrajectory.header.stamp = rospy.Time.now()\ntrajectory.joint_names = self.joint_names\npoint = JointTrajectoryPoint()\npoint.positions = joints.position[:12]\npoint.time_from_start = rospy.Duration(0.25)\ntrajectory.points.append(point)\n\n// Publish the trajectory message to the joint trajectory topic\nself.joint_trajectory_pub.publish(trajectory)\n\nif __name__ == '__main__':\n    rospy.init_node('joints_calibrator_relay')\n    try:\n        JointsCalibratorRelay()\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n\n}", "CodeBleu_score": 53.7204738355554}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contacts_[0] = false;\n\tfoot_contacts_[1] = false;\n\tfoot_contacts_[2] = false;\n\tfoot_contacts_[3] = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision_name = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> strs;\n\t\tboost::split(strs, collision_name, boost::is_any_of(\":\"));\n\n\t\tif (strs[0] == foot_links_[0])\n\t\t\tfoot_contacts_[0] = true;\n\t\telse if (strs[0] == foot_links_[1])\n\t\t\tfoot_contacts_[1] = true;\n\t\telse if (strs[0] == foot_links_[2])\n\t\t\tfoot_contacts_[2] = true;\n\t\telse if (strs[0] == foot_links_[3])\n\t\t\tfoot_contacts_[3] = true;\n\t}\n\n\tpublishContactState();\n}", "CodeBleu_score": 45.297788521244875}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> collision_split;\n\t\tboost::split(collision_split, collision, boost::is_any_of(\"::\"));\n\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (collision_split[1] == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tchamp_msgs::ContactsStamped contact_msg;\n\tcontact_msg.header.stamp = ros::Time::now();\n\tcontact_msg.header.frame_id = \\\"\\\";\n\tcontact_msg.left_front_contact = foot_contacts_[0];\n\tcontact_msg.left_rear_contact = foot_contacts_[1];\n\tcontact_msg.right_front_contact = foot_contacts_[2];\n\tcontact_msg.right_rear_contact = foot_contacts_[3];\n\tcontacts_publisher_.publish(contact_msg);\n}", "CodeBleu_score": 64.19455649096754}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contacts_[0] = false;\n\tfoot_contacts_[1] = false;\n\tfoot_contacts_[2] = false;\n\tfoot_contacts_[3] = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> collision_parts;\n\t\tboost::split(collision_parts, collision, boost::is_any_of(\"::\"));\n\t\tif (collision_parts.size() > 1) {\n\t\t\tstd::string link = collision_parts[1];\n\t\t\tif (link == foot_links_[0])\n\t\t\t\tfoot_contacts_[0] = true;\n\t\t\telse if (link == foot_links_[1])\n\t\t\t\tfoot_contacts_[1] = true;\n\t\t\telse if (link == foot_links_[2])\n\t\t\t\tfoot_contacts_[2] = true;\n\t\t\telse if (link == foot_links_[3])\n\t\t\t\tfoot_contacts_[3] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 49.8987317847959}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n//  assert(initialized_params_);\n//  assert(controller_active_);\n//  assert(command_rotor_speeds_.size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n//\n//  // Calculate thrust and angular acceleration.\n\n//  const Eigen::Vector3d thrust = CalculateThrust(command_thrust_.value);\n//  const Eigen::Vector3d angular_acceleration = CalculateAngularAcceleration();\n//\n//  // Combine thrust and angular acceleration into a single vector.\n\n//  Eigen::Vector4d desired_acceleration;\n\n//  desired_acceleration.head<3>() = thrust;\n\n//  desired_acceleration(3) = angular_acceleration.norm();\n//\n//  // Project thrust onto the body z-axis.\n\n//  desired_acceleration.head<3>() = desired_acceleration.head<3>()\n//      / desired_acceleration.head<3>().norm() * desired_acceleration(3);\n//\n//  // Compute the rotor velocities.\n\n//  *rotor_velocities = angular_acc_to_rotor_velocities_ * desired_acceleration;\n//  // Ensure non-negative values.\n\n//  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n//  // Take the square root of each component.\n\n//  *rotor_velocities = rotor_velocities->cwiseSqrt();\n//\n//  // If the rotor speeds are not specified, we use the current rotor velocities.\n\n//  if (!command_rotor_speeds_.active) {\n\n//    *rotor_velocities = command_rotor_speeds_.value;\n\n//  }\n}", "CodeBleu_score": 3.0243722721573207}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n  // Calculate thrust acceleration.\n  const Eigen::Vector3d thrust_acceleration = CalculateThrustAcceleration();\n  // Calculate angular acceleration.\n  const Eigen::Vector3d angular_acceleration = CalculateAngularAcceleration(thrust_acceleration);\n  // Project thrust acceleration onto the body z-axis.\n  const double thrust_z = thrust_acceleration.dot(vehicle_parameters_.gravity_vector_);\n  // Combine thrust and angular acceleration.\n  Eigen::Vector4d angular_acc_thrust;\n  angular_acc_thrust << angular_acceleration, thrust_z;\n  // Calculate rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acc_thrust;\n  // Ensure non-negative values.\n  for (int i = 0; i < rotor_velocities->size(); ++i) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 0.0);\n  }\n  // Take square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 59.090773669252414}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n  // Compute position error.\n  Eigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position;\n  // Compute velocity error.\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity_W - odometry_.velocity;\n  // Transform velocity error to world frame.\n  velocity_error = odometry_.orientation.toRotationMatrix().transpose() * velocity_error;\n  // Compute acceleration.\n  *acceleration = controller_parameters_.position_gain_ * position_error\n      + controller_parameters_.velocity_gain_ * velocity_error\n      + command_trajectory_.acceleration_W;\n  // Adjust for mass and gravity.\n  *acceleration -= vehicle_parameters_.gravity_ * Eigen::Vector3d::UnitZ()\n      + Eigen::Vector3d::UnitZ() * vehicle_parameters_.mass_ * vehicle_parameters_.gravity_;\n}", "CodeBleu_score": 53.276661695900785}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Calculate position error.\n\nEigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position;\n\n// Calculate velocity in world frame.\n\nEigen::Vector3d velocity_W = odometry_.orientation.toRotationMatrix()\n\n* odometry_.velocity;\n\n// Calculate velocity error.\n\nEigen::Vector3d velocity_error = command_trajectory_.velocity_W - velocity_W;\n\n// Calculate desired acceleration.\n\n*acceleration = controller_parameters_.position_gain_.cwiseProduct(position_error)\n\n+ controller_parameters_.velocity_gain_.cwiseProduct(velocity_error)\n\n- vehicle_parameters_.gravity_ * Eigen::Vector3d::UnitZ()\n\n+ command_trajectory_.acceleration_W;\n\n*acceleration /= vehicle_parameters_.mass_;\n\n}", "CodeBleu_score": 50.18142281105757}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t", "CodeBleu_score": 5.185615338987256}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!initialized_params_) {\n\t\tstd::cout << \"Attitude controller not initialized\" << std::endl;\n\t\treturn;\n\t}\n\n\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == amount_rotors_);\n\n\tEigen::Vector4d angular_acc_ref;\n\tEigen::Vector4d angular_acc_cmd;\n\n\t// Calculate the angular acceleration reference\n\tangular_acc_ref = CalculateAngularAccRef();\n\n\t// Calculate the angular acceleration command\n\tangular_acc_cmd = CalculateAngularAccCmd(angular_acc_ref);\n\n\t// Combine the angular acceleration command and thrust reference into a single vector\n\tEigen::VectorXd angular_acc_thrust_ref(4);\n\tangular_acc_thrust_ref << angular_acc_cmd, thrust_ref_;\n\n\t// Calculate the rotor velocities\n\t*rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acc_thrust_ref;\n\n\t// Ensure the rotor velocities are at least one\n\tfor (int i = 0; i < amount_rotors_; i++) {\n\t\tif ((*rotor_velocities)(i) < 1) {\n\t\t\t(*rotor_velocities)(i) = 1;\n\t\t}\n\t}\n\n\t// Take the square root of each component\n\t*rotor_velocities = (*rotor_velocities).cwiseSqrt();\n}", "CodeBleu_score": 52.58170425487151}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n//  if (!initialized_params_) {\n    std::cerr << \\\"[AttitudeControllerSamy] Parameters not initialized.\\\"\n        << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->size()!= amount_rotors_) {\n    rotor_velocities->resize(amount_rotors_);\n  }\n\n  // Check validity of input data.\n  if (command_thrust_.value < 0 || command_thrust_.value > 1) {\n    std::cerr << \\\"[AttitudeControllerSamy] Invalid thrust command: \\\"\n        << command_thrust_.value << std::endl;\n    return;\n  }\n\n  if (command_angular_velocity_ff_.value.norm() > 1) {\n    std::cerr << \\\"[AttitudeControllerSamy] Invalid angular velocity command: \\\"\n        << command_angular_velocity_ff_.value.transpose() << std::endl;\n    return;\n  }\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acc_command;\n  angular_acc_command = inertia_matrix_ * (gain_attitude_.asDiagonal() * (command_angular_velocity_ff_.value - command_angular_velocity_.value) + gain_angular_rate_.asDiagonal() * (command_angular_acceleration_.value - command_angular_acceleration_ff_.value));\n\n  // Combine desired angular acceleration with thrust reference.\n  Eigen::Vector4d angular_acc_and_thrust;\n  angular_acc_and_thrust << angular_acc_command, command_thrust_.value;\n\n  // Calculate rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acc_and_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(amount_rotors_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 50.89137193026784}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 3.965771277166072}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the corresponding indices for the start and end times\n    start_idx = numpy.searchsorted(self.time, start_time)\n    end_idx = numpy.searchsorted(self.time, end_time)\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n    # Update each attribute of the copied object to contain only the sliced data\n    for attr in dir(sliced_object):\n        if isinstance(getattr(sliced_object, attr), numpy.ndarray):\n            setattr(sliced_object, attr, getattr(sliced_object, attr)[start_idx:end_idx])\n    return sliced_object\n\n", "CodeBleu_score": 30.822640084969642}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.searchsorted(self.time, start_time)\n    end_idx = numpy.searchsorted(self.time, end_time)\n    if start_idx == end_idx:\n        return None\n    obj_copy = copy.deepcopy(self)\n    for attr in dir(obj_copy):\n        if not attr.startswith('__'):\n            attr_value = getattr(obj_copy, attr)\n            if isinstance(attr_value, numpy.ndarray):\n                setattr(obj_copy, attr, attr_value[start_idx:end_idx])\n    return obj_copy\n\n", "CodeBleu_score": 30.189052973769854}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the corresponding indices for the start and end times\n    start_idx = numpy.where(self.time >= start_time)[0][0]\n    end_idx = numpy.where(self.time <= end_time)[0][-1]\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_object.time = self.time[start_idx:end_idx + 1]\n    sliced_object.bag_time = self.bag_time[start_idx:end_idx + 1]\n\n    return sliced_object\n\n", "CodeBleu_score": 22.685620509423998}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.position\n    rotation = waypoint_msg.rotation\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    point = Point(position.x, position.y, position.z)\n    if self.empty or (self.x[-1]!= point.x or self.y[-1]!= point.y or self.z[-1]!= point.z or self.yaw[-1]!= euler[2]):\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, euler[2])\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 26.37304922178569}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    quaternion = [rotation.x, rotation.y, rotation.z, rotation.w]\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    point = Point(position.x, position.y, position.z)\n    if self.empty or point!= self.points[-1] or euler[2]!= self.yaw[-1]:\n        self.points.append(point)\n        self.yaw = numpy.append(self.yaw, euler[2])\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 26.657485742909813}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation.\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles.\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object.\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one.\n    if self.empty or not numpy.array_equal(self.x[-1:], point.x) or not numpy.array_equal(self.y[-1:], point.y) or not numpy.array_equal(self.z[-1:], point.z) or not numpy.array_equal(self.yaw[-1:], euler[2]):\n        self.empty = False\n        # Append the new point, yaw, and corresponding times to their respective arrays.\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, euler[2])\n        self.append_times(msg_time, bag_time)\n", "CodeBleu_score": 29.781513464403393}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        elif \"Imu\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n            self.ang_vel[index].append_point(msg.angular_velocity)\n            self.ang_vel[index].append_times(msg_time, bag_time)\n        elif \"PointStamped\" in str(type(msg)):\n            self.acc[index].append_point(msg.point)\n            self.acc[index].append_times(msg_time, bag_time)\n            self.ang_vel[index].append_point(Point(0, 0, 0))\n            self.ang_vel[index].append_times(msg_time, bag_time)\n        else:\n            print(\"Got unknown type: %s\" % type(msg))\n\n", "CodeBleu_score": 41.69517472428561}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        self.acc[index].append_point(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n        self.ang_vel[index].append_point(msg.angular_velocity)\n        self.ang_vel[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 51.33747319242813}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        self.acc[index].append_point(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n        self.ang_vel[index].append_point(msg.angular_velocity)\n        self.ang_vel[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 51.33747319242813}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, xyz in enumerate(self.xyz):\n        a_x.plot(xyz.time, xyz.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(xyz.time, xyz.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(xyz.time, xyz.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_accelerations' if self.prefix else 'accelerations'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 71.75604525287116}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, xyz in enumerate(self.xyz):\n        a_x.plot(xyz.time, xyz.x, 'b', label='x')\n        a_x.plot(xyz.time, xyz.y, 'r', label='y')\n        a_x.plot(xyz.time, xyz.z, 'g', label='z')\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_accelerations' if self.prefix else 'accelerations'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 62.07287590714372}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acc' if self.prefix else 'acc'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 80.66429621624074}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        rospy.logerr('Not enough poses to compare')\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 38.41320557156384}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        rospy.logerr(\"Not enough poses to compare\")\n        return\n    for index, pose_index in enumerate(pose_indeces):\n        if index + 1 >= len(pose_indeces):\n            break\n        for pose_index_2 in pose_indeces[index + 1:]:\n            self.compare_two_xyz(pose_index, pose_index_2)\n\n", "CodeBleu_score": 47.99464111732363}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        rospy.logerr(\"Need at least two poses to compare\")\n        return\n    for pose_index in pose_indeces:\n        for other_pose_index in pose_indeces[pose_indeces.index(pose_index) + 1:]:\n            self.compare_two_xyz(pose_index, other_pose_index)\n\n", "CodeBleu_score": 37.36361429310515}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if collision.time >= start_time and collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.39398851604464}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n", "CodeBleu_score": 37.93512643360498}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench.time:\n        if start_time <= collision <= end_time:\n            collision_times.append(collision)\n    return collision_times\n\n", "CodeBleu_score": 37.460618616313575}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(start_time=start_time, end_time=end_time, settling_time=absolute_settling_time, x_range=x_range, plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(set_point=[0, 0, 0], start_time=start_time, end_time=end_time, settling_time=absolute_settling_time, x_range=x_range, y_range=[-1.5, 1.5], plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 63.083109257273065}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 80.71965627740988}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(start_time=start_time, end_time=end_time, settling_time=absolute_settling_time, x_range=x_range, plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(set_point=[0, 0, 0], settling_radius=0.1, start_time=start_time, end_time=end_time, settling_time=absolute_settling_time, x_range=x_range, y_range=[-1.5, 1.5], plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 62.46828214300913}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n  if (!data) {\n    return;\n  }\n\n  const float multiplier = 1.0 / 1000.0;\n  const Eigen::VectorXf data_vec =\n      Eigen::Map<const Eigen::VectorXf>(data, width * height);\n  const float rms_noise =\n      multiplier * std::sqrt(this->depth_noise_variance * data_vec.mean());\n  const float noise_val =\n      multiplier * this->depth_noise_mean +\n      rms_noise * this->noise_generator->GaussianSample();\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data[i])) {\n      data[i] += noise_val;\n    } else {\n      data[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 48.65796977237746}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n  if (!data) {\n    return;\n  }\n  const float multiplier = 1.0 / 1000.0;\n  const Eigen::VectorXf data_eigen = Eigen::Map<Eigen::VectorXf>(data, width * height);\n  const float rms_noise = this->CalculateRMSNoise(data_eigen);\n  const Eigen::VectorXf noise = this->GenerateNoise(rms_noise, width * height);\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (this->InRange(data[i] * multiplier)) {\n      data[i] += noise[i];\n    } else {\n      data[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 46.961131850204154}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n  if (!data) {\n    return;\n  }\n\n  const float multiplier = 1.0f / 1000.0f;\n  const Eigen::VectorXf depth_data =\n      Eigen::Map<const Eigen::VectorXf>(data, width * height);\n  const float rms_noise =\n      this->CalculateRmsNoise(depth_data, width, height);\n  const Eigen::VectorXf noise = this->GenerateNoise(width, height, rms_noise);\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (this->InRange(depth_data(i))) {\n      data[i] =\n          std::max(0.0f, (depth_data(i) + noise(i)) * multiplier);\n    } else {\n      data[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 48.85606143060684}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t", "CodeBleu_score": 8.432682072468962}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time.\n\tcommon::Time now = world_->SimTime();\n\t// Convert the simulation time to ROS time.\n\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\t// Write the trajectory message to the bag file.\n\twriteBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 98.31156858288664}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t", "CodeBleu_score": 8.432682072468962}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert the simulation time to ROS time.\nros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n// Prepare a message for actuator velocities.\nmav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators());\nactuator_msg->angular_velocities.resize(num_rotors_);\n\n// Iterate through the motor joints.\nfor (int i = 0; i < num_rotors_; ++i) {\n// Calculate the slowed-down rotational velocities.\ndouble rotor_velocity = motor_joint_controllers_[i].GetVelocity(0);\ndouble slowed_down_rotor_velocity = rotor_velocity * motor_velocity_slowdown_factors_[i];\n\n// Assign the slowed-down rotational velocities to the message.\nactuator_msg->angular_velocities[i] = slowed_down_rotor_velocity;\n}\n\n// Set the message timestamp.\nactuator_msg->header.stamp = ros_now;\n\n// Write the data to a bag file using the specified namespace and motor topic.\nwriteBag(namespace_ + \"/\" + motor_velocity_topic_, ros_now, actuator_msg);\n}", "CodeBleu_score": 55.00373320585484}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\tmav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n\n\tfor (unsigned int i = 0; i < motor_joint_names_.size(); i++) {\n\t\tdouble velocity = motor_joint_states_[i].GetVelocity(0);\n\t\tactuator_msg->angular_velocities.push_back(velocity);\n\t}\n\n\tactuator_msg->header.stamp = ros_now;\n\twriteBag(namespace_ + \"/\" + motor_topic_, ros_now, actuator_msg);\n}", "CodeBleu_score": 47.025703679351594}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t", "CodeBleu_score": 3.558047406471674}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t", "CodeBleu_score": 2.6366947450589233}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (kPrintOnMsgCallback) {\ngzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n}\n\ndelta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n    roll_pitch_yawrate_thrust_msg->normalized_roll());\ndelta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n    roll_pitch_yawrate_thrust_msg->normalized_roll());\ndelta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n    roll_pitch_yawrate_thrust_msg->normalized_pitch());\ndelta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n    roll_pitch_yawrate_thrust_msg->normalized_yaw_rate());\n\nthrottle_ = roll_pitch_yawrate_thrust_msg->normalized_thrust();\n}", "CodeBleu_score": 76.52576653056707}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\tif (kPrintOnMsgCallback) {\n\t\tgzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n\t}\n\n\tdelta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n\t\t\troll_pitch_yawrate_thrust_msg->roll());\n\tdelta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n\t\t\troll_pitch_yawrate_thrust_msg->roll());\n\tdelta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n\t\t\troll_pitch_yawrate_thrust_msg->pitch());\n\tdelta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n\t\t\troll_pitch_yawrate_thrust_msg->yaw_rate());\n\n\tthrottle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 89.50532565008751}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef HAVE_LIBUSB\n  if (use_usb_ &&!usb_connected_) {\n    // check for new USB devices\n    usb_connected_ = mavlink_interface_->checkUSBConnection();\n    if (usb_connected_) {\n      mavlink_interface_->startReceiveThread();\n    }\n  }\n#endif\n\n  // poll for MAVLink messages\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // poll for new data\n  int poll_ret = poll(&fd, 1, _timeoutMs);\n  if (poll_ret < 0) {\n    gzerr << \"poll failed [\" << errno << \"] \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  if (poll_ret == 0) {\n    // timeout\n    return;\n  }\n\n  if (fd.revents & POLLIN) {\n    // receive data\n    char buffer[BUFFER_LENGTH];\n    int nbytes = ::read(fd.fd, buffer, BUFFER_LENGTH);\n    if (nbytes < 0) {\n      gzerr << \"read failed [\" << errno << \"] \" << strerror(errno) << \"\n\";\n      return;\n    }\n\n    if (nbytes > 0) {\n      // forward data to serial connection\n      if (serial_enabled_) {\n        serial_connection_->writeData(buffer, nbytes);\n      }\n\n      // parse buffer\n      mavlink_message_t message;\n      mavlink_status_t status;\n\n      unsigned int i = 0;\n\n      while (i < (unsigned int)nbytes) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message, &status)) {\n          // handle message\n          handleMessage(&message);\n        }\n\n        i++;\n      }\n    }\n  }\n}", "CodeBleu_score": 51.96257448930235}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\t/* code for function GazeboMavlinkInterface::close */\n}", "CodeBleu_score": 2.7184155487971795}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(this->mutex_);\n\tif (this->serial_dev_.is_open()) {\n\t\tthis->serial_dev_.cancel();\n\t\tthis->serial_dev_.close();\n\t\tif (this->io_thread_.joinable()) {\n\t\t\tthis->io_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 30.300259772362093}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (serial_dev_.is_open()) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t}\n\tif (io_thread_.joinable()) {\n\t\tio_thread_.join();\n\t}\n}", "CodeBleu_score": 60.64055831175883}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tconst ignition::math::Vector3d& position,\n\tconst ignition::math::Vector3d& position_1,\n\tconst ignition::math::Vector3d& position_2,\n\tconst ignition::math::Vector3d& value_1,\n\tconst ignition::math::Vector3d& value_2\n}", "CodeBleu_score": 26.34443120273147}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t", "CodeBleu_score": 2.227760700530013}, {"code": "void Animation::SetTime(double _time){\n\t\t// TODO: implement this function\n\tthrow \"Not implemented yet.\";\n}", "CodeBleu_score": 2.3054225114383256}, {"code": "void Animation::SetTime(double _time){\n\t\tthis->timePos = _time;\n\tif (this->loop) {\n\t\tthis->timePos = fmod(this->timePos, this->length);\n\t} else {\n\t\tthis->timePos = std::max(0.0, std::min(this->timePos, this->length));\n\t}\n}", "CodeBleu_score": 41.1980378701006}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n", "CodeBleu_score": 78.14949303738996}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\": HOVER\")\n", "CodeBleu_score": 78.77633621880963}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+': HOVER')\n\n", "CodeBleu_score": 75.49712306082542}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n    elif self.flightModeService(self.flight_mode):\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" failed!\")\n        return False\n", "CodeBleu_score": 75.8214065960374}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    elif self.flightModeService(self.flight_mode):\n        print(self.vehicle_type+'_'+self.vehicle_id+': '+self.flight_mode+' mode enabled')\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+': '+self.flight_mode+' mode failed')\n        return False\n\n", "CodeBleu_score": 73.63482354742102}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        print(self.vehicle_type+'_'+self.vehicle_id+': Hovering')\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+': '+self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+': '+self.flight_mode+' failed')\n            return False\n", "CodeBleu_score": 73.11018463997074}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flightModeService(custom_mode=\\\"OFFBOARD\\\")\n    if self.flight_mode!= \\\"HOVER\\\" and self.hover_flag == 0 and abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n        self.hover_flag = 1\n        self.flightModeService(custom_mode=\\\"HOVER\\\")\n        self.hold_flag = 0\n        self.hold_state_transition(0, 0, 0, 0, 'flu')\n\n", "CodeBleu_score": 54.56230614697086}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flightModeService(custom_mode='OFFBOARD')\n    if (self.flightModeService.call(custom_mode='HOVER').mode_sent == True and self.hover_flag == 0):\n        self.hover_flag = 1\n        self.flightModeService(custom_mode='HOVER')\n        self.hover_action()\n\n", "CodeBleu_score": 49.79478182492879}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flightModeService(custom_mode='OFFBOARD')\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"flight mode changed to OFFBOARD\\\")\n    if self.flight_mode!= 'HOVER' and self.hover_flag == 0 and abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n        self.hover_flag = 1\n        self.flightModeService(custom_mode='HOVER')\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"flight mode changed to HOVER\\\")\n        self.hover_action()\n\n", "CodeBleu_score": 55.436722201909916}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 26.04957448605886}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 26.04957448605886}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw=self.current_yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \": hovering\")\n\n", "CodeBleu_score": 46.51598937673749}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw=self.current_yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \": hovering\")\n\n", "CodeBleu_score": 46.51598937673749}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \": hovering\")\n\n", "CodeBleu_score": 41.90997300858014}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": switching to \\\" + self.flight_mode + \\\" failed!\\\")\n            return False\n\n", "CodeBleu_score": 70.00080353429254}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hold_flag = 1\n        self.hover()\n        return True\n\n    elif self.flightModeService(self.flight_mode):\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + self.flight_mode)\n        return True\n\n    else:\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": switching to \\\" + self.flight_mode + \\\": failed!\\\")\n        return False\n\n", "CodeBleu_score": 69.75254084347576}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": switching flight mode failed!\\\")\n            return False\n\n", "CodeBleu_score": 69.3880909794181}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[i] = self.construct_global_pose(self.local_pose.pose.position.x + self.global_pose_bias[i][0],\n                                                         self.local_pose.pose.position.y + self.global_pose_bias[i][1],\n                                                         self.local_pose.pose.position.z + self.global_pose_bias[i][2],\n                                                         self.local_pose.pose.orientation.x,\n                                                         self.local_pose.pose.orientation.y,\n                                                         self.local_pose.pose.orientation.z,\n                                                         self.local_pose.pose.orientation.w)\n\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose = self.construct_target(self.local_pose.pose.position.x, self.local_pose.pose.position.y,\n                                                             self.takeoff_height, self.current_heading)\n        if self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = self.construct_target(self.local_pose.pose.position.x, self.local_pose.pose.position.y,\n                                                           self.hover_height, self.current_heading)\n\n", "CodeBleu_score": 25.73472598565636}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq % 10 == 0:\n        if i == self.uav_id:\n            self.local_pose = msg\n            self.current_heading = self.local_pose.pose.orientation.z\n            self.current_pitch = self.local_pose.pose.orientation.y\n            self.current_roll = self.local_pose.pose.orientation.x\n            self.global_pose[i] = self.local_pose\n            self.global_pose[i].pose.position.x += self.global_pose_bias[0]\n            self.global_pose[i].pose.position.y += self.global_pose_bias[1]\n            self.global_pose[i].pose.position.z += self.global_pose_bias[2]\n\n            if self.gcs_cmd == 'TAKEOFF':\n                self.takeoff_target_pose.pose.position.x = self.global_pose[i].pose.position.x\n                self.takeoff_target_pose.pose.position.y = self.global_pose[i].pose.position.y\n                self.takeoff_target_pose.pose.position.z = self.global_pose[i].pose.position.z + self.takeoff_height\n                self.takeoff_target_pose.pose.orientation.z = self.global_pose[i].pose.orientation.z\n                self.takeoff_target_pose.pose.orientation.y = self.global_pose[i].pose.orientation.y\n                self.takeoff_target_pose.pose.orientation.x = self.global_pose[i].pose.orientation.x\n                self.takeoff_target_pose.pose.orientation.w = self.global_pose[i].pose.orientation.w\n\n            elif self.gcs_cmd == 'HOVER':\n                self.hover_target_pose.pose.position.x = self.global_pose[i].pose.position.x\n                self.hover_target_pose.pose.position.y = self.global_pose[i].pose.position.y\n                self.hover_target_pose.pose.position.z = self.global_pose[i].pose.position.z\n                self.hover_target_pose.pose.orientation.", "CodeBleu_score": 26.815400541828833}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.namespace:\n        self.local_pose = msg\n        self.global_pose[i] = self.local_to_global(msg)\n\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose = self.construct_target(self.local_pose.pose.position.x, self.local_pose.pose.position.y, self.takeoff_height, self.current_heading)\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = self.construct_target(self.local_pose.pose.position.x, self.local_pose.pose.position.y, self.hover_height, self.current_heading)\n\n", "CodeBleu_score": 31.39624585414733}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 80.06315890994992}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t    # Build a distance matrix for UAVs.\n    # The distance matrix is adjusted by subtracting it from 50 and converted to integers.\n    adj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1), dtype=numpy.int)\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            adj_matrix[i, j] = int(50 - numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])))\n    return adj_matrix\n\n", "CodeBleu_score": 43.57373990555439}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t    # The distance matrix is initialized with zeros\n    distance_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    # The distance between UAVs in the original formation is calculated\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance_matrix[i][j] = numpy.linalg.norm(orig_formation[i] - orig_formation[j])\n    # The distance between UAVs in the changed formation is calculated\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance_matrix[i][j] -= numpy.linalg.norm(change_formation[i] - change_formation[j])\n    # The distances are adjusted by subtracting them from 50 and converted to integers\n    distance_matrix = 50 - distance_matrix\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n\n", "CodeBleu_score": 44.385420806672606}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    # This function is used to build a graph for KM algorithm.\n    #", "CodeBleu_score": 1.3540510543840176}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0 and self.adj_matrix[i][j] == 0:\n            gap = self.label_left[i] + self.label_right[j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n    def KM(self):\n        \"\"\"This function, KM, is the main function for the Kuhn-Munkres algorithm.", "CodeBleu_score": 51.101227529809265}, {"code": "def find_path(self, i)\n\t    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0 and self.adj_matrix[i][j] == 1:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n    # KM algorithm.\n    def KM(self):\n        \"\"\"This function, KM, implements the Kuhn-Munkres algorithm.", "CodeBleu_score": 52.82909854101479}, {"code": "def find_path(self, i)\n\t    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0 and self.adj_matrix[i][j] == 1:\n            self.visit_right[j] = 1\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], self.label_left[i] + self.label_right[j] - 2)\n    return False\n\n    # 'KM' function is determined for KM algorithm.\n    # It iterates through left vertices and finds augmenting paths.\n    # It updates labels of left and right vertices and updates the slack value.\n    # The function returns an array of changed UAV IDs.\n    def KM(self):\n        changed_id = []\n        for i in range(self.uav_num - 1):\n            while True:\n                self.visit_left = numpy.array([0] * (self.uav_num - 1))\n                self.visit_right = numpy.array([0] * (self.uav_num - 1))\n                if self.find_path(i):\n                    break\n                delta = numpy.min(self.slack_right)\n                for j in range(self.uav_num - 1):\n                    if self.visit_left[j] == 1:\n                        self.label_left[j] -= delta\n                for j in range(self.uav_num - 1):\n                    if self.visit_right[j] == 1:\n                        self.label_right[j] += delta\n                        self.slack_right[j] -= delta\n        for i in range(self.uav_num - 1):\n            if self.match_right[i]!= -1:\n                changed_id.append(i)\n        return changed_id\n\n    # Get a", "CodeBleu_score": 39.682692818714116}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t    changed_id = []\n    for i, _ in enumerate(self.adj_matrix, start=0):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        if self.find_path(i):\n            changed_id.append(i)\n        else:\n            delta = numpy.min(self.slack_right)\n            self.label_left[i] -= delta\n            for j, visit in enumerate(self.visit_right, start=0):\n                if visit:\n                    self.label_right[j] += delta\n    return changed_id\n\n    # Get the new formation pattern of UAVs based on KM.\n    def get_new_formation(self, changed_id, change_formation):\n        new_formation = numpy.zeros((3, self.uav_num - 1))\n        for i in range(self.uav_num - 1):\n            if i in changed_id:\n                new_formation[:, i] = change_formation[:, self.match_right[i]]\n            else:\n                new_formation[:, i] = self.origin_formation[:, i]\n        return new_formation\n\n    # Get the communication topology of UAVs based on KM.\n    def get_communication_topology(self, new_formation):\n        communication_topology = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n        for i in range(self.uav_num - 1):\n            for j in range(self.uav_num - 1):\n                if numpy.linalg.norm(new_formation[:, i] - new_formation[:, j]) <= 10:\n                    communication_topology[i][j] = 1\n        return communication_topology\n\n    def timer_callback(self):\n        if self.formation_config!= 'waiting':\n           ", "CodeBleu_score": 46.1048231464448}, {"code": "def KM(self)\n\t    for i in range(self.uav_num - 1):\n        self.label_left[i] = 0\n        self.visit_left[i] = False\n        self.visit_right[:] = False\n        self.slack_right[:] = 100\n        while True:\n            if self.find_path(i):\n                break\n            delta = numpy.min(self.slack_right[self.slack_right > 0])\n            self.label_left[self.visit_left] += delta\n            self.label_right[:] -= delta\n            self.slack_right[self.visit_right] = 100\n    return self.match_right\n\n", "CodeBleu_score": 24.58724914853651}, {"code": "def KM(self)\n\t    for i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        while not self.find_path(i):\n            self.label_left[i] -= numpy.min(self.slack_right)\n            for j in range(self.uav_num - 1):\n                if self.visit_right[j]:\n                    self.label_right[j] += numpy.min(self.slack_right)\n    return self.match_right\n\n", "CodeBleu_score": 46.19496880537225}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([50, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([10, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.702901312592527}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\treturn false;\n}", "CodeBleu_score": 1.6921632792600123}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\treturn this->findStandaloneTagDescription(id, descriptionContainer, printWarning);\n}", "CodeBleu_score": 5.005486156102185}]}
