{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc < udc_get_eof_conf()) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 42.40262066712908}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bDescriptorType!= desc_id && desc->bDescriptorType!=\n\t\t\tUSB_DT_INTERFACE && desc->bDescriptorType!= USB_DT_CONFIG) {\n\t\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t\tif (desc >= udc_get_eof_conf()) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 47.43833869793408}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * eof_conf;\n\n\teof_conf = udc_get_eof_conf();\n\twhile (desc < eof_conf) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 50.30312450754486}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;\n\n\t// Check if a valid configuration is selected\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Get pointer on first interface descriptor\n\tiface_desc = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t *)\n\t\t\tudc_ptr_conf->desc + sizeof(usb_conf_desc_t));\n\n\t// Get pointer on end of configuration descriptor\n\tptr_eof_desc = udc_get_eof_conf();\n\n\t// Check each interface descriptor\n\twhile (ptr_eof_desc > iface_desc) {\n\t\tif (iface_desc->bInterfaceNumber == iface_num) {\n\t\t\tif (iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\tudc_ptr_iface = iface_desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Go to next interface descriptor\n\t\tiface_desc = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t *)\n\t\t\t\tiface_desc + iface_desc->bLength);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 63.00450313230077}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\tuint8_t iface_num_desc;\n\tuint8_t setting_num_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tptr_eof_desc = udc_get_eof_conf();\n\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_conf->desc;\n\tiface_desc = NULL;\n\twhile (ptr_eof_desc > desc) {\n\t\tif (USB_DT_INTERFACE == desc->bDescriptorType) {\n\t\t\tiface_num_desc = ((usb_iface_desc_t *) desc)->bInterfaceNumber;\n\t\t\tsetting_num_desc = ((usb_iface_desc_t *) desc)->bAlternateSetting;\n\t\t\tif ((iface_num_desc == iface_num) && (setting_num_desc == setting_num)) {\n\t\t\t\tiface_desc = (usb_iface_desc_t *) desc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc + desc->bLength);\n\t}\n\n\tif (iface_desc) {\n\t\tudc_ptr_iface = iface_desc;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 60.317264231725765}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *conf_desc;\n\tuint8_t i;\n\n\t// Check if a valid configuration is selected\n\tif (NULL == udc_ptr_conf) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Start at the beginning of the configuration descriptor\n\tconf_desc = udc_ptr_conf->desc;\n\n\t// Iterate through the descriptors\n\tfor (i = 0; i < iface_num; i++) {\n\t\t// Get the next interface descriptor\n\t\tiface_desc = (usb_iface_desc_t *) ((uint8_t *) conf_desc + conf_desc->bLength);\n\t\t// Check if the descriptor is a valid interface descriptor\n\t\tif (iface_desc->bDescriptorType!= USB_DT_INTERFACE) {\n\t\t\treturn false;\n\t\t}\n\t\t// Advance to the next descriptor\n\t\tconf_desc = (usb_conf_desc_t *) ((uint8_t *) iface_desc + iface_desc->bLength);\n\t}\n\n\t// Check if the descriptor is a valid interface descriptor\n\tiface_desc = (usb_iface_desc_t *) ((uint8_t *) conf_desc + conf_desc->bLength);\n\tif (iface_desc->bDescriptorType!= USB_DT_INTERFACE) {\n\t\treturn false;\n\t}\n\n\t// Check if the setting number is valid\n\tif (setting_num >= iface_desc->bNumEndpoints) {\n\t\treturn false;\n\t}\n\n\t// Update the internal pointer to the interface descriptor\n\tudc_ptr_iface = iface_desc;\n\n\treturn true;\n}", "CodeBleu_score": 53.31982324326319}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_status;\n\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tep_status = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tep_status = 1;\n\t}\n\n\tudd_set_setup_payload(&ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 50.01405431474175}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\n\tuint16_t ep_status = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tep_status = CPU_TO_LE16(USB_EP_STATUS_HALT);\n\t}\n\n\tudd_set_setup_payload((uint8_t *) &ep_status, sizeof(uint16_t));\n\treturn true;\n}", "CodeBleu_score": 37.94352198956262}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udc_ep_status)) {\n\t\treturn false;\n\t}\n\n\tudc_ep_status = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tudc_ep_status = 1;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) &udc_ep_status, sizeof(udc_ep_status));\n\treturn true;\n}", "CodeBleu_score": 59.942219740103276}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\tif (!udc_num_configuration) {\n\t\treturn false;\n\t}\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\tif (!udc_update_iface_desc(iface_num, udc_iface_setting)) {\n\t\treturn false;\n\t}\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\treturn udi_api->setup();\n}", "CodeBleu_score": 73.63803031716309}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\n\tif (udd_g_ctrlreq.req.wLength) {\n\t\treturn false; // Error in request\n\t}\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Select default setting of the interface to update udc_ptr_iface\n\t// before call iface->setup()\n\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\t// Select current alternate setting of the interface to update udc_ptr_iface\n\t// before call iface->setup()\n\n\tif (!udc_update_iface_desc(iface_num, udc_iface_setting)) {\n\t\treturn false;\n\t}\n\t// Send SETUP request to UDI\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\treturn udi_api->setup();\n}", "CodeBleu_score": 73.95661685507744}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Check if the external enable function is implemented\n\tif (!udi_msc_enable_ext()) {\n\t\treturn false;\n\t}\n\n\t// Set initial states for several flags\n\tudi_msc_b_abort_trans = false;\n\tudi_msc_b_reset_trans = true;\n\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_data_dir = false;\n\n\t// Retrieves the number of Logical Unit Numbers (LUNs)\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\n\t// Check if there are any LUNs available\n\tif (udi_msc_nb_lun == 0) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tudi_msc_unload_medium();\n\n\t// Start the MSC process by waiting for a Command Block Wrapper (CBW) reception\n\tudi_msc_cbw_wait();\n\n\t// Return \"true\"\n\treturn true;\n}", "CodeBleu_score": 29.127368633542883}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t\t// Reset the CBW transfer\n\tudi_msc_cbw_wait();\n\t// Reset the CSW transfer\n\tudi_msc_csw_wait();\n\t// Reset the sense data\n\tudi_msc_clear_sense();\n\t// Reset the abort transfer flag\n\tudi_msc_abort_trans = false;\n\t// Reset the reset transfer flag\n\tudi_msc_b_reset_trans = true;\n\t// Reset the LUN number\n\tudi_msc_lun_nb = 0;\n\t// Check if the external enable function returns true\n\tif (udi_msc_enable_ext()) {\n\t\t// Check if there is at least one LUN available\n\t\tif (udi_msc_lun_nb) {\n\t\t\t// Unload the medium on each LUN\n\t\t\twhile (udi_msc_lun_nb--) {\n\t\t\t\tudi_msc_lun_unload(udi_msc_lun_nb);\n\t\t\t}\n\t\t\t// Start the MSC process by waiting for a CBW reception\n\t\t\tudi_msc_cbw_wait();\n\t\t\t// Return true\n\t\t\treturn true;\n\t\t}\n\t}\n\t// Return false\n\treturn false;\n}", "CodeBleu_score": 42.693036386017305}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n// Check status of transfer\nif (UDD_EP_TRANSFER_OK!= status) {\n// Transfer aborted\n// Now wait MSC setup reset to relaunch CBW reception\nreturn;\n}\n// Update CSW residue field\nudi_msc_csw.dCSWDataResidue -= nb_sent;\n// Process CSW\nudi_msc_csw_process();\n}", "CodeBleu_score": 71.18296283562331}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n// Check status of transfer\nif (UDD_EP_TRANSFER_OK!= status) {\n// Transfer aborted\n// Now wait MSC setup reset to relaunch CBW reception\nreturn;\n}\n// Update CSW residue\nudi_msc_csw.dCSWDataResidue -= nb_sent;\n// Process CSW\nudi_msc_csw_process();\n}", "CodeBleu_score": 71.18296283562331}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\t// Check status of transfer\n\tif (UDD_EP_TRANSFER_OK!= status) {\n\t\t// Transfer aborted\n\t\t// Now wait MSC setup reset to relaunch CBW reception\n\t\treturn;\n\t}\n\t// Update CSW residue field with the size sent\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 71.42777844254691}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// Check if CSW residue is zero\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\t// Prepare CSW tag\n\t\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\t\t// Convert CSW residue to little-endian format\n\t\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t\t// Stall IN or OUT endpoint as appropriate\n\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\t// Stall IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n\t\t} else {\n\t\t\t// Stall OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n\t\t}\n\t\t// Send CSW\n\t\tudi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n\t} else {\n\t\t// Prepare CSW tag\n\t\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\t\t// Convert CSW residue to little-endian format\n\t\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t\t// Send CSW\n\t\tudi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n\t}\n}", "CodeBleu_score": 56.74540532409107}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check if data residue is zero\n\tif (udi_msc_csw.dCSWDataResidue == 0) {\n\t\t// If data residue is zero, then check status\n\t\tif (udi_msc_csw.bCSWStatus == CSW_STATUS_CMD_PASSED) {\n\t\t\t// If status is good, then wait next CBW\n\t\t\tudi_msc_cbw_wait();\n\t\t} else {\n\t\t\t// If status is not good, then wait a reset\n\t\t\tudi_msc_reset();\n\t\t}\n\t} else {\n\t\t// If data residue is not zero, then stall endpoint\n\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\t// If direction is IN, then stall IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_reset);\n\t\t} else {\n\t\t\t// If direction is OUT, then stall OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_reset);\n\t\t}\n\t}\n\t// Prepare CSW\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = le32_to_cpu(udi_msc_csw.dCSWDataResidue);\n\t// Send CSW\n\tudi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 66.02442207298147}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check if there is a data residue\nIf there is, stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\t// Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n\t\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\t// Stall the next request from the USB host on the Bulk In endpoint\n\t\t\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n\t\t\t// Exit\n\t\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t// Stall the next request from the USB host on the Bulk Out endpoint\n\t\t\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t\t// If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n\t\t\t\t\tudd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n\t\t\t// Exit\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}", "CodeBleu_score": 42.56148342859349}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tmain_b_dtr_active = b_enable;\n\tif (b_enable) {\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Schedule a delayed system reset\n\t\t\tinitiateReset(10000);\n\t\t}\n\t} else {\n\t\t// Cancel any scheduled reset\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 51.452344775931635}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\t// Update DTR status\n\tmain_b_dtr_active = b_enable;\n\t// Check if DTR rate is 1200\n\tif (dwDTERate == 1200) {\n\t\t// Check if DTR signal is disabled\n\t\tif (!main_b_dtr_active) {\n\t\t\t// Schedule a delayed system reset\n\t\t\tREG_WDT_MR = WDT_MR_WDRSTEN | WDT_MR_WDD(0xFF) | WDT_MR_WDV(0xFF);\n\t\t\tinitiateReset();\n\t\t}\n\t} else {\n\t\t// Cancel any scheduled reset\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 45.73696281163821}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\n\t// Store last DTR status\n\tmain_b_dtr_active = b_enable;\n\n\t// If DTR is disabled and DTE rate is 1200, schedule a system reset\n\tif (!b_enable && (dwDTERate == 1200)) {\n\t\t// Schedule a system reset\n\t\tinitiateReset(RESET_SYSTEM_RESET);\n\t}\n}", "CodeBleu_score": 36.38622351381168}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tswitch (udd_g_ctrlreq.req.bRequest) {\n\t\tcase GET_DESCRIPTOR:\n\t\t\tswitch (udd_g_ctrlreq.req.wValue >> 8) {\n\t\t\t\tcase MS_OS_20_DESCRIPTOR_TYPE:\n\t\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t\t\t\tudd_g_ctrlreq.payload_size = microsoft_compatible_id_descriptor.dwLength;\n\t\t\t\t\treturn true;\n\t\t\t\tcase MS_EXT_PROP_DESCRIPTOR_TYPE:\n\t\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t\t\t\tudd_g_ctrlreq.payload_size = microsoft_extended_properties_descriptor.dwLength;\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SET_FEATURE:\n\t\t\tif (udd_g_ctrlreq.req.wValue == 0x01) {\n\t\t\t\t// Enable CDC_DTR_EVENT\n\t\t\t\tmain_b_dtr_event = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.07809968064881}, {"code": "bool usb_task_other_requests(void){\n\t\tif (udd_g_ctrlreq.req.bmRequestType!= (USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_DEVICE))\n\t\treturn false;\n\n\tswitch (udd_g_ctrlreq.req.bRequest) {\n\tcase 0x04:\n\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\treturn true;\n\n\tcase 0x05:\n\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_extended_properties_descriptor);\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 23.710454637265315}, {"code": "bool usb_task_other_requests(void){\n\t\tif (UDI_VENDOR_REQ_GET_MS_DESCRIPTOR == udd_g_ctrlreq.req.bRequest) {\n\t\tswitch (udd_g_ctrlreq.req.wValue >> 8) {\n\t\t\tcase 0x04:\n\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_extended_properties_descriptor);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// if the descriptor is larger than request length, then cut it\n\t\tif (udd_g_ctrlreq.payload_size > udd_g_ctrlreq.req.wLength) {\n\t\t\tudd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 25.525653064552213}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\t// send dummy byte and read data\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN);\n\t\tWHILE_TX(0);\n\t\tWHILE_RX(0);\n\t\tbuf[i] = SPI0->SPI_RDR;\n\t}\n\n\t// read last byte\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 71.44349918149337}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN);\n\t\tWHILE_TX(0);\n\t\tWHILE_RX(0);\n\t\tbuf[i] = SPI0->SPI_RDR;\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 71.44349918149337}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\twhile (nbyte--) {\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN);\n\t\tWHILE_TX(0);\n\t\tWHILE_RX(0);\n\t\t*buf++ = SPI0->SPI_RDR;\n\t}\n\t*buf = spiRec();\n}", "CodeBleu_score": 47.98044819138632}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t// Get the address of the relocated interrupt vector table\npfnISR_Handler* isr_table = get_relocated_table_addr();\n\n// Disable global interrupts\nCRITICAL_SECTION_START();\n\n// Get the current handler for the specified IRQ\npfnISR_Handler oldHandler = isr_table[irq];\n\n// Replace the current handler with the new handler\nisr_table[irq] = newHandler;\n\n// Re-enable interrupts\nCRITICAL_SECTION_END();\n\n// Return the original ISR handler\nreturn oldHandler;\n}", "CodeBleu_score": 69.94380962217646}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated table\n\tpfnISR_Handler* table = get_relocated_table_addr();\n\n\t// Disable global interrupts\n\tCRITICAL_SECTION_START();\n\n\t// Get the current handler\n\tpfnISR_Handler oldHandler = table[irq];\n\n\t// Install the new handler\n\ttable[irq] = newHandler;\n\n\t// Reenable interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the old handler\n\treturn oldHandler;\n}", "CodeBleu_score": 69.12946333313121}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* isr_table = get_relocated_table_addr();\n\n\t// Disable global interrupts\n\tCRITICAL_SECTION_START();\n\n\t// Get the current ISR handler for the specified IRQ\n\tpfnISR_Handler oldHandler = isr_table[irq];\n\n\t// Replace the current ISR handler with the new handler\n\tisr_table[irq] = newHandler;\n\n\t// Re-enable global interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 69.97052955628138}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t", "CodeBleu_score": 1.8457006082025527}, {"code": "int MarlinSerialUSB::peek(){\n\t", "CodeBleu_score": 1.8457006082025527}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (pending_char >= 0) return pending_char;\n\tif (!usb_task_cdc_isenabled()) return -1;\n\tif (!usb_task_cdc_dtr_active()) return -1;\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\tint c = udi_cdc_getc();\n\tif (c >= 0) {\n\t\tif (EMERGENCY_PARSER_ENABLED) {\n\t\t\tif (c == '!' || c == '?' || c == 'M' || c == 'G' || c == 'T') {\n\t\t\t\tpending_char = c;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 57.430287472041094}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tint c = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n\treturn c;\n}", "CodeBleu_score": 82.04364536024487}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tint c = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n\treturn c;\n}", "CodeBleu_score": 82.04364536024487}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tint c = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n\treturn c;\n}", "CodeBleu_score": 82.04364536024487}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if EMERGENCY_PARSER\n  if (emergency_parser.is_active())\n    return emergency_parser.available();\n#endif\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 36.01399590685575}, {"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.is_enabled())\n    return emergency_parser.available();\n#endif\n\n  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n}", "CodeBleu_score": 40.14862400265729}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (pending_char >= 0)\n\t\treturn 1;\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn 0;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn 0;\n\n\treturn 1;\n}", "CodeBleu_score": 30.08916915057386}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\twhile (size--) {\n\t\tuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n\t\tif (value) *value = ee_Read(uint32_t(p));\n\t\tcrc16(crc, p, 1);\n\t\tpos++;\n\t\tvalue++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 54.494606281902705}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\n\tif (writing) {\n\t\twhile (size--) {\n\t\t\tif (value) *value = ee_Read(uint32_t(p));\n\t\t\tcrc16(crc, value, 1);\n\t\t\tpos++;\n\t\t\tvalue++;\n\t\t}\n\t}\n\telse {\n\t\twhile (size--) {\n\t\t\t*value = ee_Read(uint32_t(p));\n\t\t\tcrc16(crc, value, 1);\n\t\t\tpos++;\n\t\t\tvalue++;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.909454361569196}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\twhile (size--) {\n\t\tuint8_t v = ee_Read(REAL_EEPROM_ADDR(pos));\n\t\tif (writing) {\n\t\t\tif (value) *value = v;\n\t\t\tvalue++;\n\t\t}\n\t\tcrc16(crc, &v, 1);\n\t\tpos++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 61.34973521988226}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\n#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(value, 0, _BV(res)-1, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(value, 0, _BV(res)-1, 0, _BV(res)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 47.08886511860571}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin == 127) {\n\t\t// Set the PWM frequency for all pins\n\t\tpwm_freq = freq;\n\t\treturn;\n\t}\n\n\t// Set the PWM frequency for this pin\n\tset_pwm_frequency(pin, freq);\n\n\t// Set the PWM duty cycle for this pin\n\tset_pwm_duty(pin, value, _BV(res) - 1);\n}", "CodeBleu_score": 17.81836018267309}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\t#if ENABLED(I2S_STEPPER_STREAM)\n\t\tif (pin > 127) {\n\t\t\tconst uint8_t pinlo = pin & 0x7F;\n\t\t\tpwm_pin_t &pindata = pwm_pin_data[pinlo];\n\t\t\tconst uint32_t duty = map(value, 0, _BV(res)-1, 0, pindata.pwm_cycle_ticks);\n\t\t\tif (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n\t\t\t\tpindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n\t\t\t\tduty? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n\t\t\t}\n\t\t\telse\n\t\t\t\tpindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n\t\t\treturn;\n\t\t}\n\t#endif\n\n\tconst int8_t cid = get_pwm_channel(pin, freq, res);\n\tif (cid >= 0) {\n\t\tconst uint32_t duty = map(value, 0, _BV(res)-1, 0, _BV(PWM_RESOLUTION)-1);\n\t\tledcWrite(cid, duty);\n\t}\n}", "CodeBleu_score": 45.887674337008264}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= 16\n#error \"The servo delay array length is not equal to 16. Please check the SERVO_DELAY_ARRAY_LENGTH macro definition.\"\n#endif\n\n  if (attach(pin) >= 0) {\n    write(value);\n    delay(SERVO_DELAY_ARRAY[channel]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n#endif\n  }\n}", "CodeBleu_score": 38.367625199503195}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= 12\n  STATIC_ASSERT(SERVO_DELAY_ARRAY_LENGTH == 12, \"SERVO_DELAY_ARRAY_LENGTH!= 12\");\n#endif\n  if (attach(0) >= 0) {\n    write(value);\n    delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 54.08838843990876}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= 16\n#error \"Servo delay array length must be 16\"\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    delay(servo_delay[channel]);\n  }\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n}", "CodeBleu_score": 38.29376620705723}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n  if (i2s_port_data!= I2S0.conf_single_data)\n    I2S0.conf_single_data = i2s_port_data;\n#endif\n  // If the PWM tick count reaches zero, toggle the pin state\n  // and set the tick count for the next transition\n  for (uint8_t pin = 0; pin < I2S_STEPPER_PIN_COUNT; pin++) {\n    if (i2s_pin_duty[pin] > 0) {\n      if (--i2s_pin_ticks[pin] == 0) {\n        i2s_pin_ticks[pin] = i2s_pin_duty[pin];\n        i2s_write(pin,!i2s_state(pin));\n      }\n    }\n  }\n\n  // Write the data to the DMA buffer\n  *(uint32_t *)dma.buf_pos = i2s_port_data;\n  dma.buf_pos = (dma.buf_pos + 4) % DMA_BUF_SIZE;\n}", "CodeBleu_score": 28.3840385409711}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\n/*\n * The function \"HAL_timer_get_count\" retrieves the current counter value of a specified hardware timer.\nIt takes a timer number as input, accesses the corresponding timer configuration, and fetches the current counter value from the timer.\nThe function then returns this counter value.\n */\n  const tTimerConfig timer = timer_config[timer_num];\n  uint64_t counter_value;\n  timer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n  return counter_value;\n}", "CodeBleu_score": 99.85673391755866}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n\treturn counter_value;\n}", "CodeBleu_score": 97.86105963185919}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n\treturn counter_value;\n}", "CodeBleu_score": 97.86105963185919}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing)\n\t\t\tvalue[i] = HAL_eeprom_data[pos + i];\n\n\t\tcrc16(crc, HAL_eeprom_data + pos + i, 1);\n\t}\n\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 73.82778136168548}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t", "CodeBleu_score": 8.5836493051307}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t v = HAL_eeprom_data[pos + i];\n\t\tif (writing) value[i] = v;\n\t\tcrc16(crc, v);\n\t}\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 78.93850187599321}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 73.2521382568653}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 80.05454715617007}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 73.2521382568653}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\n  switch (timer_num) {\n\n    case TIMER_TEMP:\n\n      temp_timer.start(frequency, TIMER_PRESCALE_TEMP);\n\n      NVIC_SetPriority(TIMER02_INT_TEMP_IRQn, IRQ_PRI_TEMP);\n\n      break;\n\n    case TIMER_STEP:\n\n      step_timer.start(frequency, TIMER_PRESCALE_STEP);\n\n      NVIC_SetPriority(TIMER02_INT_STEP_IRQn, IRQ_PRI_STEP);\n\n      break;\n\n    default:\n\n      ASSERT(false);\n\n      break;\n\n  }\n\n}", "CodeBleu_score": 27.963799281598522}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t#if ENABLED(TEMP_TIMER_PIN_DEBUG)\n  if (timer_num == TEMP_TIMER_NUM) WRITE(TEMP_TIMER_PIN, HIGH);\n#endif\n\n  if (timer_num == TEMP_TIMER_NUM) {\n    temp_timer.init(frequency, TEMP_TIMER_PRESCALE);\n    temp_timer.setPriority(TEMP_TIMER_PRIORITY);\n  } else if (timer_num == STEP_TIMER_NUM) {\n    step_timer.init(frequency, STEPPER_TIMER_PRESCALE);\n    step_timer.setPriority(STEPPER_TIMER_PRIORITY);\n  } else {\n    SERIAL_ERROR_MSG(\\\"Invalid timer channel: \\\", timer_num);\n    HAL_ASSERT(false);\n  }\n\n#if ENABLED(TEMP_TIMER_PIN_DEBUG)\n  if (timer_num == TEMP_TIMER_NUM) WRITE(TEMP_TIMER_PIN, LOW);\n#endif\n}", "CodeBleu_score": 55.86220267686913}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\t\tcase TEMP_TIMER_NUM:\n\t\t\ttemp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n\t\t\tNVIC_SetPriority(TEMP_TIMER_IRQn, TEMP_TIMER_IRQ_PRIORITY);\n\t\t\tbreak;\n\t\tcase STEP_TIMER_NUM:\n\t\t\tstep_timer.start(frequency, STEP_TIMER_PRESCALE);\n\t\t\tNVIC_SetPriority(STEP_TIMER_IRQn, STEP_TIMER_IRQ_PRIORITY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassertion_failure(PSTR(\\\"Invalid timer channel\\\"), 0);\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 28.765651343969278}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tFILE *fp = fopen(filename, \\\"rb\\\");\n\tif (fp) {\n\t\tsize_t size = fread(buffer, 1, sizeof(buffer), fp);\n\t\tif (size < capacity()) {\n\t\t\tmemset(buffer + size, 0xFF, capacity() - size);\n\t\t}\n\t\tfclose(fp);\n\t}\n\treturn true;\n}", "CodeBleu_score": 24.508186502501605}, {"code": "bool PersistentStore::access_start(){\n\t\tFILE *fp = fopen(filename, \\\"rb\\\");\n\tif (!fp) {\n\t\tfp = fopen(filename, \\\"wb\\\");\n\t\tif (!fp) return false;\n\t\tmemset(buffer, 0xFF, MARLIN_EEPROM_SIZE);\n\t\tfwrite(buffer, 1, MARLIN_EEPROM_SIZE, fp);\n\t\tfclose(fp);\n\t\tfp = fopen(filename, \\\"rb\\\");\n\t\tif (!fp) return false;\n\t}\n\tfseek(fp, 0, SEEK_END);\n\tif (ftell(fp) < MARLIN_EEPROM_SIZE) {\n\t\tmemset(buffer, 0xFF, MARLIN_EEPROM_SIZE);\n\t\tfseek(fp, 0, SEEK_SET);\n\t\tfread(buffer, 1, ftell(fp), fp);\n\t} else {\n\t\tfseek(fp, 0, SEEK_SET);\n\t\tfread(buffer, 1, MARLIN_EEPROM_SIZE, fp);\n\t}\n\tfclose(fp);\n\treturn true;\n}", "CodeBleu_score": 37.03472100947579}, {"code": "bool PersistentStore::access_start(){\n\t#ifdef DEBUG_EEPROM\n  printf(\\\"Opening EEPROM file: %s\\\n\\\", filename);\n#endif\n  FILE *f = fopen(filename, \\\"r+b\\\");\n  if (!f) {\n    f = fopen(filename, \\\"w+b\\\");\n    if (!f) {\n#ifdef DEBUG_EEPROM\n      printf(\\\"ERROR: Could not open EEPROM file for writing.\\\n\\\");\n#endif\n      return false;\n    }\n    memset(buffer, 0xff, MARLIN_EEPROM_SIZE);\n  }\n  else {\n    fseek(f, 0, SEEK_END);\n    size_t file_size = ftell(f);\n    if (file_size < MARLIN_EEPROM_SIZE) {\n      fseek(f, 0, SEEK_SET);\n      memset(buffer, 0xff, MARLIN_EEPROM_SIZE);\n      fread(buffer, 1, file_size, f);\n    }\n    else {\n      fseek(f, 0, SEEK_SET);\n      fread(buffer, 1, MARLIN_EEPROM_SIZE, f);\n    }\n  }\n  fclose(f);\n  return true;\n}", "CodeBleu_score": 40.016832967474016}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\tif (b & 0x80) OUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\telse OUT_WRITE(SD_MOSI_PIN, LOW);\n\t\tb <<= 1;\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\tif (READ(SD_MISO_PIN)) r |= 0x01;\n\t\tr <<= 1;\n\t}\n\tOUT_WRITE(SD_SCK_PIN, LOW);\n\tr >>= 1;\n\treturn r;\n}", "CodeBleu_score": 45.55406712463934}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t ret = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\tif (b & 0x80) OUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\telse           OUT_WRITE(SD_MOSI_PIN, LOW);\n\t\tb <<= 1;\n\t\tdelaySPIFunc();\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\tif (IN_READ(SD_MISO_PIN)) ret |= 0x01;\n\t\tif (i < 7) ret <<= 1;\n\t\tdelaySPIFunc();\n\t}\n\treturn ret;\n}", "CodeBleu_score": 50.88928782418384}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (uint8_t i = 8; i--;) {\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\tif (b & 0x80) OUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\telse OUT_WRITE(SD_MOSI_PIN, LOW);\n\t\tb <<= 1;\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\tr <<= 1;\n\t\tif (READ(SD_MISO_PIN)) r |= 1;\n\t\t(*delaySPIFunc)();\n\t}\n\treturn r;\n}", "CodeBleu_score": 46.73729754310626}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/ Check the parameters\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 81.98695565583968}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/ Check the parameters\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 81.98695565583968}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/ Check the parameters\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 81.98695565583968}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t data = obj->read();\n\n\tif (obj->availableForWrite() > 0) {\n\t\tif (rx_buffer_head == rx_buffer_tail) {\n\t\t\tif (++rx_buffer_tail >= SERIAL_RX_BUFFER_SIZE)\n\t\t\t\trx_buffer_tail = 0;\n\t\t}\n\t\trx_buffer[rx_buffer_head++] = data;\n\t\tif (rx_buffer_head >= SERIAL_RX_BUFFER_SIZE)\n\t\t\trx_buffer_head = 0;\n\t}\n\n\t// If the emergency parser is enabled, pass the byte to it\n\tTERN_(EMERGENCY_PARSER, e_parser.process_char(data));\n}", "CodeBleu_score": 31.633645489864783}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t// Read the byte and store it in the buffer if there is space\n\tconst uint8_t c = obj->read();\n\tif (rx_buffer_head!= rx_buffer_tail) {\n\t\trx_buffer[rx_buffer_head] = c;\n\t\trx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\t}\n\t// Update the emergency parser\n\tTERN_(EMERGENCY_PARSER, eParser.process_char(c));\n}", "CodeBleu_score": 27.92504780825008}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif ENABLED(EMERGENCY_PARSER)\n  static uint8_t last_byte = 0;\n#endif\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    // Buffer overflow\n    rx_buffer_overflow = true;\n  }\n  else {\n    // If data is available, read it and store it in the buffer\n    uint8_t b = read();\n\n#if ENABLED(EMERGENCY_PARSER)\n    if (emergency_parser_enabled) {\n      // If the last byte was a CR and the current byte is a LF, ignore the LF\n      if (last_byte == '\\r' && b == '\n')\n        return;\n      // Otherwise, pass the byte to the emergency parser\n      emergency_parser_push(b);\n      last_byte = b;\n    }\n#endif\n\n    rx_buffer[rx_buffer_head] = b;\n    rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n  }\n}", "CodeBleu_score": 28.79664848255335}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 79.63791451529256}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t#if ENABLED(DEBUG_HAL_TIMER)\n  SERIAL_ECHOPGM(\"HAL_timer_enable_interrupt(\");\n  SERIAL_ECHO(timer_num);\n  SERIAL_ECHOPGM(\")\n\");\n#endif\n  if (HAL_timer_initialized(timer_num)) {\n    if (!HAL_timer_interrupt_attached(timer_num)) {\n      switch (timer_num) {\n        case MF_TIMER_STEP:\n          timer_instance[timer_num]->attachInterrupt(Step_Handler);\n          break;\n        case MF_TIMER_TEMP:\n          timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 76.58625547499733}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 79.63791451529256}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 54.645031780937636}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := n - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[len(s)-n:]) == string(sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashss && string(s[i:i+n]) == string(sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 70.6246874706484}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := len(s) - n; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t\tif i > 0 {\n\t\t\th -= pow * uint32(s[i+n-1])\n\t\t}\n\t\tif h == hashss && string(s[i:i+n]) == string(sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 48.54786214868045}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t// disable interrupts\n\tinterrupt.Disable()\n\n\t// check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// send data to USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\n\t// set waitTxc to false if there is no data in the transmit buffer\n\tif usbcdc.txBuffer.Used() == 0 {\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 43.95125297204547}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.sendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.6539765235238}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.waitTxc = false\n\tinterrupt.Enable()\n}", "CodeBleu_score": 38.2731015982802}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\tClear interrupt flag.\n\ti2c.crReg.SetBits(i2c.crINT)\n\n\t// Send start condition.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Enable I2C module.\n\ti2c.crReg.SetBits(i2c.crEN)\n\n\t// Wait for start condition to be transmitted.\n\tfor!i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Write address to bus.\n\ti2c.writeByte(address << 1)\n\n\t// Set read flag if needed.\n\tif!write {\n\t\ti2c.writeByte(1)\n\t}\n}", "CodeBleu_score": 38.08314899533176}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\tClear interrupt flag, send start condition, enable TWI.\n\ti2c.crReg.Set(i2c.crINT | i2c.crEN | i2c.crSTA)\n\n\t// Wait for TWI start condition to be transmitted.\n\tfor!i2c.srReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Send peripheral address, set read flag if needed.\n\ti2c.writeByte(address | byte(!write))\n}", "CodeBleu_score": 43.42623289371736}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\tClear the interrupt flag.\n\ti2c.crReg.Set(i2c.crINT)\n\n\t// Send start condition and wait for it to be transmitted.\n\ti2c.crReg.Set(i2c.crSTA | i2c.crEN)\n\tfor i2c.crReg.Get()&i2c.crINT == 0 {\n\t}\n\n\t// Send peripheral address and wait for it to be transmitted.\n\ti2c.writeByte(address << 1 | boolToUint8(!write))\n\tfor i2c.crReg.Get()&i2c.crINT == 0 {\n\t}\n}", "CodeBleu_score": 38.94071415442695}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errFlashInvalidBlockRange\n\t}\n\tif start+len > f.Size()/f.EraseBlockSize() {\n\t\treturn errFlashInvalidBlockRange\n\t}\n\n\tstartAddress := FlashDataStart() + uintptr(start*f.EraseBlockSize())\n\tendAddress := startAddress + uintptr(len*f.EraseBlockSize())\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor address := startAddress; address < endAddress; address += f.EraseBlockSize() {\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 60.08498849542707}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := FlashDataStart() + uintptr(start)*uintptr(f.EraseBlockSize())\n\tendAddress := startAddress + uintptr(len)*uintptr(f.EraseBlockSize())\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor address := startAddress; address < endAddress; address += uintptr(f.EraseBlockSize()) {\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0xFFFFFFFF\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.85419779352792}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 {\n\t\treturn errFlashInvalidBlock\n\t}\n\n\tif start+len > Flash.Size()/Flash.EraseBlockSize() {\n\t\treturn errFlashInvalidBlock\n\t}\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := start; i < start+len; i++ {\n\t\taddress := FlashDataStart() + uintptr(i*Flash.EraseBlockSize())\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0xffffffff\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 66.68193594267589}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t", "CodeBleu_score": 2.041834266629872}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\t// Calculate the start address for writing\n\tstart := FlashDataStart() + uintptr(off)\n\n\t// Pad the byte slice to fit the write block size\n\tblockSize := 8\n\tpadded := make([]byte, blockSize)\n\tcopy(padded, p)\n\tfor i := len(p); i < blockSize; i++ {\n\t\tpadded[i] = 0xFF\n\t}\n\n\t// Enable write mode on the flash memory controller\n\tnrf.NVMC.SetCONFIG(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// Write the data in blocks and wait for the flash memory to be ready after each write operation\n\tfor i := 0; i < len(padded); i += blockSize {\n\t\t// Write the block of data to the flash memory\n\t\t*(*uint64)(unsafe.Pointer(start + uintptr(i))) = *(*uint64)(unsafe.Pointer(&padded[i]))\n\n\t\t// Wait for the flash memory to be ready\n\t\tfor nrf.NVMC.GetREADY()!= nrf.NVMC_READY_READY_Ready {\n\t\t}\n\t}\n\n\t// Return the number of bytes written or an error if the operation fails\n\treturn len(p), nil\n}", "CodeBleu_score": 49.75542387182328}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tstart := FlashDataStart() + uintptr(off)\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(start)), len(p))\n\tcopy(data, p)\n\n\t// Pad the data with 0xFF to fill the write block size.\n\tpadded := make([]byte, (len(data)+nrf.FICR.CODEPAGESIZE.Get())/nrf.FICR.CODEPAGESIZE.Get()*nrf.FICR.CODEPAGESIZE.Get())\n\tcopy(padded, data)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetMODE(nrf.NVMC_MODE_MODE_Write)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(padded); i += nrf.FICR.CODEPAGESIZE.Get() {\n\t\t// Write the block to flash memory.\n\t\tflashAddress := unsafe.Pointer(start + uintptr(i))\n\t\tblock := unsafe.Slice((*byte)(flashAddress), nrf.FICR.CODEPAGESIZE.Get())\n\t\tflash.Write(block)\n\n\t\t// Wait for the flash memory to be ready.\n\t\tfor nrf.NVMC.GetREADY() == 0 {\n\t\t}\n\t}\n\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.SetMODE(nrf.NVMC_MODE_MODE_Read)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 47.803722067091414}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tDuplicate the file descriptor so that it can be closed if an error occurs.\n\tdupFd, err := dup(fd)\n\tif err!= nil {\n\t\treturn 0, \"dup\", err\n\t}\n\t// Attempt to open the directory using \"syscall.Fdopendir\".\n\t// This function is not available on all Darwin systems, so it may return \"syscall.ENOSYS\".\n\t// If this occurs, we continue to attempt to open the directory using \"syscall.Open\" until either \"syscall.Fdopendir\" is available or an error other than \"syscall.EINTR\" is encountered.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil && err!= syscall.ENOSYS {\n\t\tclose(dupFd)\n\t\treturn 0, \"fdopendir\", err\n\t}\n\t// If \"syscall.Fdopendir\" is not available, attempt to open the directory using \"syscall.Open\".\n\tfor dir == 0 && err == syscall.ENOSYS {\n\t\tdir, err = syscall.Open(fd, syscall.O_RDONLY|syscall.O_DIRECTORY, 0)\n\t\tif err!= nil && err!= syscall.EINTR {\n\t\t\tclose(dupFd)\n\t\t\treturn 0, \"open\", err\n\t\t}\n\t}\n\t// If the directory was successfully opened, close the duplicated file descriptor and return the directory pointer.\n\tif dir!= 0 {\n\t\tclose(dupFd)\n\t}\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 53.31041474322471}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tDuplicate the file descriptor to avoid closing it when the\n\t// directory is closed.\n\tr0, _, e1 := syscall.Syscall(syscall.SYS_DUP, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\treturn 0, \"dup\", e1\n\t}\n\tfd = syscallFd(r0)\n\tdefer syscall.Close(fd)\n\n\t// Try to open the directory.\n\tfor {\n\t\tr0, _, e1 := syscall.Syscall(syscall.SYS_FDopendir, uintptr(fd), 0, 0)\n\t\tif e1 == 0 {\n\t\t\treturn r0, \"\", nil\n\t\t}\n\t\tif e1!= syscall.EINTR {\n\t\t\treturn 0, \"fdopendir\", e1\n\t\t}\n\t}\n}", "CodeBleu_score": 48.25591970426408}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tDuplicate the file descriptor so that we can close it if the syscall fails.\n\tdupfd, err := dup(fd)\n\tif err!= nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\t// Keep trying to open the directory until we either succeed or encounter an error other than EINTR.\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor if the syscall failed.\n\tif err!= nil {\n\t\tclose(dupfd)\n\t}\n\n\treturn dir, \"opendir\", err\n}", "CodeBleu_score": 60.386019389293544}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t#if defined(ESP32) || defined(ESP8266)\n  uint32_t size = 0;\n  uint32_t free = 0;\n  esp_app_desc_t *app_desc = esp_ota_get_app_description();\n  if (app_desc!= NULL) {\n    size = app_desc->image_len;\n    free = app_desc->image_len - app_desc->image_size;\n    if (response == SKETCH_SIZE_FREE) {\n      return free;\n    } else {\n      return size;\n    }\n  }\n  return 0;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 41.53516872994296}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tconst esp_partition_t *running = esp_ota_get_running_partition();\n\tif (running == NULL) {\n\t\treturn 0;\n\t}\n\tesp_app_desc_t running_app_info;\n\tif (esp_ota_get_partition_description(running, &running_app_info)!= ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response == SIZESKETCH) {\n\t\treturn running_app_info.image_len;\n\t} else {\n\t\treturn running_app_info.image_len - running_app_info.image_size;\n\t}\n}", "CodeBleu_score": 48.174823278653264}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t#if CONFIG_IDF_TARGET_ESP32 || CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C2 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6 || CONFIG_IDF_TARGET_ESP32H2\n  esp_app_desc_t running_app = {};\n  esp_app_get_description(&running_app);\n  if (running_app.project_name == nullptr) {\n    return 0;\n  }\n  const esp_partition_t *running_partition = esp_ota_get_running_partition();\n  if (running_partition == nullptr) {\n    return 0;\n  }\n  const esp_partition_t *update_partition = esp_ota_get_next_update_partition(nullptr);\n  if (update_partition == nullptr) {\n    return 0;\n  }\n  const esp_partition_t *factory_partition = esp_ota_get_partition_description_by_label(running_app.project_name);\n  if (factory_partition == nullptr) {\n    return 0;\n  }\n  if (running_partition->address == factory_partition->address) {\n    return 0;\n  }\n  if (response == FREE_SPACE) {\n    return update_partition->size - running_partition->size;\n  }\n  return running_partition->size;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 46.33990030317378}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tize_t total_sectors = msc_update_get_required_disk_sectors();\n\tmsc_ram_disk = (uint8_t *)calloc(total_sectors, DISK_SECTOR_SIZE);\n\tif (msc_ram_disk == NULL) {\n\t\tlog_e(\\\"RAM disk allocation failed\\\");\n\t\treturn false;\n\t}\n\tmsc_boot = (fat_boot_sector_t *)msc_ram_disk;\n\tmsc_table = msc_ram_disk + DISK_SECTOR_SIZE;\n\tfat_init_boot_sector(msc_boot, total_sectors, mcs_is_fat16, USB_FW_MSC_VOLUME_NAME, USB_FW_MSC_SERIAL_NUMBER);\n\tfat_init_file_allocation_table(msc_table, msc_table_sectors, total_sectors, mcs_is_fat16);\n\n\tif (msc_run_partition) {\n\t\tfw_start_sector = 32;\n\t\tfw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size);\n\t\tfw_entry = fat_add_dir_entry(msc_boot, msc_table, fw_start_sector, fw_end_sector, \\\"FIRMWARE\\\", \\\"BIN\\\", 0);\n\t\tlog_d(\\\"Added firmware file to root directory\\\");\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 43.29712539057805}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tize_t total_sectors = msc_update_get_required_disk_sectors();\n\tmsc_ram_disk = (uint8_t *)malloc(total_sectors * DISK_SECTOR_SIZE);\n\tif (!msc_ram_disk) {\n\t\tlog_e(\\\"Failed to allocate memory for ramdisk\\\");\n\t\treturn false;\n\t}\n\tmsc_boot = (fat_boot_sector_t *)msc_ram_disk;\n\tmsc_table = (uint8_t *)msc_ram_disk + (total_sectors - msc_table_sectors) * DISK_SECTOR_SIZE;\n\tmsc_total_sectors = total_sectors;\n\n\tif (!fat_init_boot_sector(msc_boot, mcs_is_fat16, total_sectors, volume_label, serial_number)) {\n\t\tlog_e(\\\"Failed to initialize boot sector\\\");\n\t\treturn false;\n\t}\n\n\tif (!fat_init_file_allocation_table(msc_table, msc_table_sectors, msc_boot->sectors_per_fat, msc_boot->sectors_per_cluster)) {\n\t\tlog_e(\\\"Failed to initialize file allocation table\\\");\n\t\treturn false;\n\t}\n\n\tif (msc_run_partition) {\n\t\tfw_start_sector = 2 + msc_boot->sectors_per_fat * msc_boot->number_of_fats;\n\t\tfw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size);\n\t\tfw_entry = fat_add_dir_entry(msc_ram_disk, msc_boot, \\\"FIRMWARE.BIN\\\", fw_size, fw_start_sector, false);\n\t\tif (!fw_entry) {\n\t\t\tlog_e(\\\"Failed to add firmware entry\\\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.23585844536643}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->erase_size!= 0) {\n\t\tlog_e(\"Offset not aligned to sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tlog_e(\"Failed to erase flash: %s\", esp_err_to_name(err));\n\t\treturn err;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 51.3704115514958}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t//  log_d(\\\"MSC update write: %u bytes @ 0x%08X\\\", size, offset);\n  if (offset % partition->erase_size!= 0) {\n    log_e(\\\"MSC update write: offset is not aligned with flash sector size\\\");\n    return ESP_ERR_INVALID_ARG;\n  }\n  if (size % partition->erase_size!= 0) {\n    log_e(\\\"MSC update write: size is not aligned with flash sector size\\\");\n    return ESP_ERR_INVALID_ARG;\n  }\n  if (size == 0) {\n    return ESP_OK;\n  }\n  uint32_t sector = offset / partition->erase_size;\n  if (sector >= partition->size / partition->erase_size) {\n    log_e(\\\"MSC update write: offset is beyond partition size\\\");\n    return ESP_ERR_INVALID_ARG;\n  }\n  if (sector + (size / partition->erase_size) > partition->size / partition->erase_size) {\n    log_e(\\\"MSC update write: size is beyond partition size\\\");\n    return ESP_ERR_INVALID_ARG;\n  }\n  if (esp_partition_erase_range(partition, offset, size)!= ESP_OK) {\n    log_e(\\\"MSC update write: failed to erase flash sector\\\");\n    return ESP_FAIL;\n  }\n  if (esp_partition_write(partition, offset, data, size)!= ESP_OK) {\n    log_e(\\\"MSC update write: failed to write data to flash\\\");\n    return ESP_FAIL;\n  }\n  return ESP_OK;\n}", "CodeBleu_score": 41.275806080743166}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = 0;\n\twhile (*in) {\n\t\tuint8_t c = hex_char_to_byte(*in++);\n\t\tif (c > 0x0F)\n\t\t\tcontinue;\n\t\tuint8_t c2 = hex_char_to_byte(*in++);\n\t\tif (c2 > 0x0F)\n\t\t\tcontinue;\n\t\tif (len < maxlen)\n\t\t\tout[len] = (c << 4) | c2;\n\t\tlen++;\n\t}\n\treturn len;\n}", "CodeBleu_score": 40.712333094955206}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i, j = 0;\n\tunsigned char c;\n\tfor (i = 0; in[i]!= 0 && j < maxlen; i++) {\n\t\tc = hex_char_to_byte(in[i]);\n\t\tif (c == 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i & 1) {\n\t\t\tout[j++] |= c;\n\t\t} else {\n\t\t\tout[j] = c << 4;\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 43.69436390775754}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tuint8_t c;\n\twhile (i < maxlen && *in) {\n\t\tc = hex_char_to_byte(*in++);\n\t\tif (c == 0x10)\n\t\t\tcontinue;\n\t\tc <<= 4;\n\t\tc |= hex_char_to_byte(*in++);\n\t\tif (c == 0x10)\n\t\t\tcontinue;\n\t\t*out++ = c;\n\t\ti++;\n\t}\n\treturn i;\n}", "CodeBleu_score": 36.577760428751766}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buf == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) == pdTRUE) {\n\t\tsize_t free = xRingbufferGetCurFreeSize(tx_ring_buf);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 72.7615234472816}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buf == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) == pdTRUE) {\n\t\tsize_t free_size = xRingbufferGetCurFreeSize(tx_ring_buf);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free_size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 83.84954328875273}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!tx_ring_buf ||!tx_lock) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, (TickType_t) 10) == pdTRUE) {\n\t\tsize_t free_size = xRingbufferGetCurFreeSize(tx_ring_buf);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free_size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 60.05101974142888}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tEX_LOCK();\n\t// function may be NULL to cancel onReceive() from its respective task\n\t_onReceiveCB = function;\n\t_onReceiveTimeout = onlyOnTimeout;\n\t// this can be called after Serial.begin(), therefore it shall create the event task\n\tif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n\t\t_createEventTask(this);\n\t}\n\tHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 33.477121935227736}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tEX_LOCK();\n\t// function may be NULL to cancel onReceive() from its respective task\n\t_onReceiveCB = function;\n\t_onReceiveTimeout = onlyOnTimeout;\n\t// this can be called after Serial.begin(), therefore it shall create the event task\n\tif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n\t\t_createEventTask(this);\n\t}\n\tHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 33.477121935227736}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tEX_LOCK();\n\t// function may be NULL to cancel onReceive() from its respective task\n\t_onReceiveCB = function;\n\t// this can be called after Serial.begin(), therefore it shall create the event task\n\tif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n\t\t_createEventTask(this);\n\t}\n\tHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 26.341643165694524}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char) c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 71.68091652394908}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) break;\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 76.20201251609464}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1)\n\t\treturn 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator)\n\t\t\tbreak;\n\t\t*buffer++ = (char) c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 74.58143021928475}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (_pin == -1) {\n\t\tif (tone_init()) {\n\t\t\ttone_msg_t tone_msg = {\n\t\t\t\t.tone_cmd = TONE_START,\n\t\t\t\t.pin = pin,\n\t\t\t\t.frequency = frequency,\n\t\t\t\t.duration = duration,\n\t\t\t};\n\t\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t\t}\n\t} else {\n\t\tlog_e(\"Tone is already running on pin %d\", _pin);\n\t}\n}", "CodeBleu_score": 56.39278619077373}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (_pin == -1) {\n\t\tif (tone_init()) {\n\t\t\ttone_msg_t tone_msg = {\n\t\t\t\t.tone_cmd = TONE_START,\n\t\t\t\t.pin = pin,\n\t\t\t\t.frequency = frequency,\n\t\t\t\t.duration = duration,\n\t\t\t};\n\t\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t\t}\n\t} else {\n\t\tlog_e(\"Tone is already running on pin %d\", _pin);\n\t}\n}", "CodeBleu_score": 56.39278619077373}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (_pin == -1) {\n\t\tif (tone_init()) {\n\t\t\ttone_msg_t tone_msg = {\n\t\t\t\t.tone_cmd = TONE_START,\n\t\t\t\t.pin = pin,\n\t\t\t\t.frequency = frequency,\n\t\t\t\t.duration = duration,\n\t\t\t};\n\t\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t\t}\n\t} else {\n\t\tlog_e(\"Tone is already running on pin %d\", _pin);\n\t}\n}", "CodeBleu_score": 56.39278619077373}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!_started) {\n\t\twebusb_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tusb_version = 0x0210;\n\t\t}\n\t}\n\treturn!_started;\n}", "CodeBleu_score": 60.05180255844106}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CFG_TUD_WEBUSB\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (webusb_enabled) {\n      usbVersion(0x0210);\n    }\n  }\n  return!_started;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 57.46881455252787}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CFG_TUD_WEBUSB\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usbVersion(0x0210);\n    }\n  }\n  return!_started;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 54.532969417875755}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\t// Read data into a buffer\n\tuint8_t buf[64];\n\tsize_t len = 0;\n\twhile (len < sizeof(buf)) {\n\t\tint c = read();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf[len++] = c;\n\t}\n\n\t// Attempt to send each byte to the receive queue\n\tif (rx_queue) {\n\t\tfor (size_t i = 0; i < len; i++) {\n\t\t\tif (!xQueueSend(rx_queue, &buf[i], 0)) {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = len - i;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Post a receive event with the length of the received data\n\tif (len > 0) {\n\t\tarduino_usb_cdc_event_data_t p;\n\t\tp.rx.len = len;\n\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 61.846201354159525}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t ch;\n\tsize_t rx_queue_len = rx_queue? uxQueueSpacesAvailable(rx_queue) + uxQueueMessagesWaiting(rx_queue) : 0;\n\twhile (available()) {\n\t\tread(&ch, 1);\n\t\tif (rx_queue) {\n\t\t\tif (xQueueSend(rx_queue, &ch, 0)!= pdTRUE) {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = 1;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (rx_queue_len!= (uxQueueSpacesAvailable(rx_queue) + uxQueueMessagesWaiting(rx_queue))) {\n\t\tarduino_usb_cdc_event_data_t p;\n\t\tp.rx_data.len = rx_queue_len - (uxQueueSpacesAvailable(rx_queue) + uxQueueMessagesWaiting(rx_queue));\n\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 49.54602147552742}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[64];\n\tint len = 0;\n\twhile (len < sizeof(data) && usb_cdc_read_available()) {\n\t\tdata[len++] = usb_cdc_read_char();\n\t}\n\n\tif (len) {\n\t\tif (rx_queue) {\n\t\t\tsize_t queueSpace = uxQueueSpacesAvailable(rx_queue);\n\t\t\tif (queueSpace < len) {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = len - queueSpace;\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t}\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (!xQueueSend(rx_queue, &data[i], 0)) {\n\t\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\t\tp.rx_overflow.dropped_bytes = len - i;\n\t\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tarduino_usb_cdc_event_data_t p;\n\t\tp.rx_data.len = len;\n\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 57.58214854673054}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif device, err := a.jsonDeviceFor(req.URL.Query().Get(\":robot\"), req.URL.Query().Get(\":device\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.executeCommand(device.Command(req.URL.Query().Get(\":command\")), res, req)\n\t}\n}", "CodeBleu_score": 59.433898315339015}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif device, err := a.jsonDeviceFor(req.URL.Query().Get(\":robot\"), req.URL.Query().Get(\":device\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.executeCommand(device.Command(req.URL.Query().Get(\":command\")), res, req)\n\t}\n}", "CodeBleu_score": 59.433898315339015}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif device, err := a.jsonDeviceFor(req.URL.Query().Get(\":robot\"), req.URL.Query().Get(\":device\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.executeCommand(device.Commands[req.URL.Query().Get(\":command\")], res, req)\n\t}\n}", "CodeBleu_score": 58.40120582479609}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\texpected := base64.StdEncoding.EncodeToString([]byte(username + \\\":\\\" + password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\\\"Authorization\\\")\n\t\tif auth == \\\"Basic \\\"+expected {\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\\\"WWW-Authenticate\\\", \\\"Basic realm=Restricted\\\")\n\t\thttp.Error(w, \\\"Unauthorized.\\\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 52.818577731653995}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\texpected := base64.StdEncoding.EncodeToString([]byte(username + \\\":\\\" + password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\\\"Authorization\\\")\n\t\tif auth == \\\"\\\" || subtle.ConstantTimeCompare([]byte(auth[6:]), []byte(expected))!= 1 {\n\t\t\tw.Header().Set(\\\"WWW-Authenticate\\\", \\\"Basic realm=\\\\\\\"Restricted\\\\\\\"\\\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\\\"Unauthorized\n\\\"))\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.96751788313399}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// Check if the header is present and starts with \"Basic \"\n\t\tif authHeader == \"\" ||!strings.HasPrefix(authHeader, \"Basic \") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the base64-encoded credentials from the header\n\t\tcredentials, err := base64.StdEncoding.DecodeString(authHeader[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Invalid credentials.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the credentials into username and password\n\t\tparts := strings.SplitN(string(credentials), \":\", 2)\n\t\tif len(parts)!= 2 {\n\t\t\thttp.Error(w, \"Invalid credentials.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the provided username and password with the expected values\n\t\tif subtle.ConstantTimeCompare([]byte(parts[0]), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(parts[1]), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// The request has been authenticated, so proceed to the next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.77797088337565}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.(AnalogReader).AnalogReadSupported() {\n\t\treturn -1, -1, errors.New(\\\"analog read not supported\\\")\n\t}\n\n\trawValue, err := a.connection.(AnalogReader).AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 46.48479856858422}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, errors.New(\\\"AnalogSensorDriver connection is nil\\\")\n\t}\n\n\tif!a.connection.AnalogReader() {\n\t\treturn -1, -1, errors.New(\\\"AnalogSensorDriver connection does not support analog reading\\\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 50.16827330761866}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.AnalogReader() {\n\t\treturn -1, -1, errors.New(\\\"analog sensor not supported\\\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 45.575295658644144}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 66.51736880538208}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 72.3854272107521}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 66.51736880538208}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, cmdSoftReset); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif val&cmdPowerDownBit!= 0 {\n\t\treturn errors.New(\"reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.1621553683773}, {"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, pcdCmdSoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif val&pcdCmdSoftReset!= 0 {\n\t\treturn fmt.Errorf(\"initialization took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 66.93597897558719}, {"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, commandRegSoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tif cmd, err := d.readByteData(regCommand); err!= nil {\n\t\treturn err\n\t} else if cmd&commandRegPowerDownBit!= 0 {\n\t\treturn errors.New(\\\"soft reset failed\\\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 62.178876106704294}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tfifoLen, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif int(fifoLen)!= len(backData) {\n\t\treturn 0, fmt.Errorf(\"fifoLen: %d, backData: %d\", fifoLen, len(backData))\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\trxLastBits = rxLastBits & controlRegRxLastBitsMask\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 56.3498786826907}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// the register command is always the same, the pointer in FIFO is incremented automatically after each read\n\t// the number of bytes available in the FIFO is stored in the FIFO level register\n\tfifoLen, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif fifoLen!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\\\"number of bytes in FIFO (%d) does not match expected length (%d)\\\", fifoLen, len(backData))\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\trxLastBits = rxLastBits & controlRegRxLastBitsMask\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 56.69953915039147}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// get the number of bytes currently in FIFO\n\tfifoLen, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif pcdDebug {\n\t\tfmt.Printf(\"fifoLen: 0x%02x\n\", fifoLen)\n\t}\n\t// check if the number of bytes in FIFO matches the expected length of the byte slice\n\tif len(backData)!= int(fifoLen) {\n\t\treturn 0, fmt.Errorf(\"the number of bytes in FIFO does not match the expected length of the byte slice\")\n\t}\n\t// read the bytes from FIFO into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// read the control register to get the last bits received\n\tlastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tlastBits = lastBits & controlRegRxLastBitsMask\n\tif pcdDebug {\n\t\tfmt.Printf(\"lastBits: 0x%02x\n\", lastBits)\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 53.22470949554705}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"Halt PICC\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{piccCommandHLTA, 0}\n\n\t// Calculate CRC_A\n\tcrc := piccCRC(cmd)\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Send the command.\n\tif err := d.piccSendRecv(cmd, 0); err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the CRC_A register to the result of the CRC_A calculation.\n\tif err := d.writeByteData(regCRCResultRegL, crc[0]); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regCRCResultRegH, crc[1]); err!= nil {\n\t\treturn err\n\t}\n\n\t// Stop now if we are going to read the response.\n\tif piccDebug {\n\t\tfmt.Println(\"Halt PICC done\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.11150170656658}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"halt\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{piccCommandHLTA, 0x00} // The command code\n\tcmd = append(cmd, d.calculateCRC(cmd)...)\n\tcmd = append(cmd, 0x00) // The last byte must be 0x00. This is a workaround.\n\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHLTA command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this way: Only a timeout must be seen as 'not acknowledge'.\n\tif err := d.sendCommand(cmd); err!= nil {\n\t\tif piccDebug {\n\t\t\tfmt.Println(\"piccHalt: error sending command\")\n\t\t}\n\t\treturn err\n\t}\n\n\t// Set the CRC back to the default value.\n\tif err := d.writeByteData(regDivIrq, irqInvertRegReset); err!= nil {\n\t\tif piccDebug {\n\t\t\tfmt.Println(\"piccHalt: error resetting irq invert reg\")\n\t\t}\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Println(\"piccHalt: success\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.59684776182561}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"Halt PICC\")\n\t}\n\n\tcommand := []byte{piccCommandHalt}\n\tif err := d.calculateCRC(command); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := d.sendCommand(piccCommandHalt, command); err!= nil {\n\t\treturn err\n\t}\n\n\treturn d.readError()\n}", "CodeBleu_score": 32.03578584469831}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Println(\"backData\", backData)\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 77.9755093388608}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\t// MIFARE Classic protocol requires two steps to perform a read.\nStep 1: Tell the PICC we want to read from block blockAddr.\n\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\tif piccDebug {\n\t\tfmt.Println(\"backData\", backData)\n\t}\n\n\t// Step 2: Receive the data\n\n\tif err := d.calculateCRC(backData, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\tif backData[len(backData)-2]!= crcResult[0] || backData[len(backData)-1]!= crcResult[1] {\n\t\treturn nil, fmt.Errorf(\"read failed, CRC did not match\")\n\t}\n\n\treturn backData[:len(backData)-2], nil\n}", "CodeBleu_score": 71.20410287224632}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 79.52241532257402}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tswitch reqMode {\n\tcase piccCommandMFRegREQA:\n\t\ttxLastBits = 0x07 // only 7 bits of the last byte\n\tcase piccCommandMFRegWUPA:\n\t\ttxLastBits = 0x07 // only 7 bits of the last byte\n\t}\n\n\tif err := d.communicateWithPICC(commandRegTransceive, []byte{reqMode}, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 66.51873885128367}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err!= nil {\n\t\treturn err\n\t}\n\tswitch reqMode {\n\tcase piccCommandREQA, piccCommandWUPA:\n\t\tif err := d.setRegisterBitMask(regBitFraming, bitFramingRegTxLastBits7); err!= nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\tif err := d.clearRegisterBitMask(regBitFraming, bitFramingRegTxLastBits7); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := d.communicateWithPICC(commandRegTransceive, []byte{reqMode}, answer, 0, false); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.30143848786134}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\ttxLastBits := uint8(0x00)\n\tswitch reqMode {\n\tcase piccCommandMFRegREQRegA:\n\t\ttxLastBits = 0x07\n\tcase piccCommandMFRegREQRegB:\n\t\ttxLastBits = 0x07\n\t}\n\tif err := d.communicateWithPICC(commandRegTransceive, []byte{reqMode}, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.34138572243498}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 72.40718860754066}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == StepperDriverForward {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\treturn nil\n}", "CodeBleu_score": 72.40718860754066}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 72.40718860754066}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\terr := d.measureDistance()\n\t\t\tif err!= nil {\n\t\t\t\tfmt.Printf(\"error on measure distance: %v\n\", err)\n\t\t\t}\n\n\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 63.25624380320987}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tcase <-time.After(hcsr04MonitorUpdate):\n\t\t\t\terr := d.measureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tfmt.Printf(\"error on distance measure: %v\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 62.21956072816468}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\terr := d.measureDistance()\n\t\t\tif err!= nil {\n\t\t\t\tfmt.Printf(\\\"error on measure distance: %v\n\\\", err)\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tcase <-time.After(hcsr04MonitorUpdate):\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 52.30132952619566}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar pulseStart time.Time\n\treturn func(pin int, timestamp time.Duration, pinName string, pinValue uint32, timestampNS uint32) {\n\t\tif pinValue == 1 {\n\t\t\tpulseStart = time.Now()\n\t\t} else {\n\t\t\tpulseDuration := time.Since(pulseStart)\n\t\t\td.delayMicroSecChan <- pulseDuration.Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 38.176863533883385}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\n\treturn func(_ int, _ time.Duration, _ string, _ uint32, _ uint32) {\n\t\tswitch d.echoPin.Read() {\n\t\tcase 0:\n\t\t\t// rising edge\n\t\t\tstart = time.Now()\n\t\tcase 1:\n\t\t\t// falling edge\n\t\t\td.delayMicroSecChan <- int64(time.Since(start).Microseconds())\n\t\t}\n\t}\n}", "CodeBleu_score": 39.157817067774324}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\n\treturn func(pin int, ts time.Duration, pinName string, seq uint32, level uint32) {\n\t\tif level == 1 {\n\t\t\tstart = ts\n\t\t} else {\n\t\t\td.delayMicroSecChan <- ts.Sub(start).Microseconds()\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.02414686638509}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerMeasurement(); err!= nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\t\treturn nil\n\tcase <-time.After(hcsr04MaxMeasurementTime):\n\t\treturn fmt.Errorf(\\\"timeout for '%s'\\\", d.driverCfg.name)\n\t}\n}", "CodeBleu_score": 58.90035891419701}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerMeasurement(); err!= nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\\\"timeout waiting for echo signal\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.615093584292}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerPin.Write(1); err!= nil {\n\t\treturn fmt.Errorf(\\\"error on trigger pin write: %v\\\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerDuration)\n\tif err := d.triggerPin.Write(0); err!= nil {\n\t\treturn fmt.Errorf(\\\"error on trigger pin write: %v\\\", err)\n\t}\n\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\t\treturn nil\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\\\"timeout while waiting for distance measure\\\")\n\t}\n}", "CodeBleu_score": 57.2689840171847}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if os.getenv(\"PLATFORMIO_ACCOUNT_TOKEN\"):\n        return os.getenv(\"PLATFORMIO_ACCOUNT_TOKEN\")\n    if not app.get_state_item(\"account\"):\n        raise AccountNotAuthorized()\n    auth = app.get_state_item(\"account\").get(\"auth\")\n    if not auth or not auth.get(\"access_token\") or not auth.get(\"expires_at\") or auth.get(\"expires_at\") < time.time():\n        if not auth or not auth.get(\"refresh_token\") or not self.get_refresh_token():\n            raise AccountNotAuthorized()\n        try:\n            data = self.fetch_json_data(\"token\", method=\"POST\", data=dict(grant_type=\"refresh_token\", refresh_token=self.get_refresh_token()))\n        except AccountError as exc:\n            raise AccountNotAuthorized() from exc\n        auth = app.get_state_item(\"account\").get(\"auth\", {})\n        auth.update(data)\n        auth.update(expires_at=time.time() + data.get(\"expires_in\"))\n        app.set_state_item(\"account\", dict(app.get_state_item(\"account\"), auth=auth))\n    return auth.get(\"access_token\")\n\n\n    def fetch_account_info(self):\n        \"\"\"The function \"fetch_account_info\" retrieves the account information for the current user.", "CodeBleu_score": 47.09476964089889}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.environ.get(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.environ[\"PLATFORMIO_AUTH_TOKEN\"]\n    if not app.get_state_item(\"account\"):\n        raise AccountNotAuthorized()\n    auth = app.get_state_item(\"account\").get(\"auth\")\n    if not auth or not auth.get(\"access_token\"):\n        raise AccountNotAuthorized()\n    if auth.get(\"expires_at\") and auth[\"expires_at\"] < time.time():\n        if not auth.get(\"refresh_token\"):\n            raise AccountNotAuthorized()\n        try:\n            response = self.fetch_json_data(\n                \\\"/auth/refresh\\\", json=dict(refresh_token=auth[\"refresh_token\"])\n            )\n        except AccountError as exc:\n            raise AccountNotAuthorized() from exc\n        auth = response.get(\\\"auth\\\")\n        auth[\"expires_at\"] = time.time() + auth[\"expires_in\"]\n        app.set_state_item(\n            \\\"account\\\", dict(auth=auth, email=app.get_state_item(\\\"account\\\")[\\\"email\\\"])\n        )\n    return auth[\"access_token\"]\n\n\n", "CodeBleu_score": 46.46009681100522}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.environ.get(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.environ.get(\"PLATFORMIO_AUTH_TOKEN\")\n    try:\n        account = app.get_state_item(\"account\")\n        if not account:\n            raise AccountNotAuthorized()\n        auth = account.get(\"auth\")\n        if not auth:\n            raise AccountNotAuthorized()\n        if not auth.get(\"access_token\"):\n            raise AccountNotAuthorized()\n        if not auth.get(\"expires\"):\n            raise AccountNotAuthorized()\n        if auth.get(\"expires\") < time.time():\n            if not auth.get(\"refresh_token\"):\n                raise AccountNotAuthorized()\n            try:\n                auth_data = self.fetch_json_data(\n                    \"auth/refresh\", params={\"refresh_token\": auth.get(\"refresh_token\")}\n                )\n                auth[\"access_token\"] = auth_data.get(\"access_token\")\n                auth[\"expires\"] = auth_data.get(\"expires\")\n                auth[\"refresh_token\"] = auth_data.get(\"refresh_token\")\n                app.set_state_item(\"account\", account)\n            except HTTPClientError as exc:\n                raise AccountError(exc) from exc\n        return auth.get(\"access_token\")\n    except Exception as exc:\n        raise AccountNotAuthorized() from exc\n\n\n", "CodeBleu_score": 53.325231811287466}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n    except AccountNotAuthorized:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\"post\", \"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 69.39725141830601}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\"post\", \"/v1/logout\", headers={\"Authorization\": \"Bearer %s\" % refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 57.3756067157047}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\"post\", \"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 64.12456878827638}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    return [\n        {\n            \"name\": pkg.metadata.name,\n            \"version\": str(pkg.metadata.version),\n            \"url\": pkg.metadata.url\n            if pkg.metadata.external\n            else None,\n        }\n        for pkg in self.get_installed_packages()\n        if not pkg.metadata.optional\n    ]\n\n", "CodeBleu_score": 24.60964972087066}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for name, options in self.packages.items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg:\n            continue\n        data = {\n            \"name\": name,\n            \"version\": str(pkg.metadata.version),\n        }\n        if pkg.metadata.external:\n            data[\"url\"] = pkg.metadata.url\n        packages.append(data)\n    return packages\n\n", "CodeBleu_score": 52.92853578919657}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg:\n            continue\n        result.append(\n            {\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"url\": pkg.metadata.url if pkg.metadata.external else None,\n            }\n        )\n    return result\n\n", "CodeBleu_score": 52.66188323496015}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = PlatformFactory.new(\n            ProjectConfig.get_instance(env.project_dir).get_env_data(env.name)[\n                \"platform\"\n            ],\n            autoinstall=autoinstall,\n        )\n    except KeyError:\n        raise UndefinedEnvPlatformError(env.name)\n    platform.set_project_env(env)\n    platform.configure_packages(env.name, targets)\n    return platform\n\n", "CodeBleu_score": 38.989317172427306}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = cls.new(\n            env.get_setting(\"platform\"), autoinstall=autoinstall\n        )\n    except UnknownPlatform as e:\n        raise UndefinedEnvPlatformError(str(e)) from e\n    platform.set_project_env(env)\n    platform.configure_packages(env.get_project_packages(), targets=targets)\n    return platform\n\n", "CodeBleu_score": 37.46314657189971}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not isinstance(env, str):\n        raise TypeError(\n            \"The parameter 'env' should be of type'str', not '%s'\"\n            % type(env).__name__\n        )\n    if targets is not None and not isinstance(targets, (list, tuple)):\n        raise TypeError(\n            \"The parameter 'targets' should be of type 'list' or 'tuple', not '%s'\"\n            % type(targets).__name__\n        )\n    if not isinstance(autoinstall, bool):\n        raise TypeError(\n            \"The parameter 'autoinstall' should be of type 'bool', not '%s'\"\n            % type(autoinstall).__name__\n        )\n    config = ProjectConfig.get_instance()\n    platform_spec = config.get_env_option(env, \"platform\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls.new(platform_spec, autoinstall)\n    instance.set_project_env(env)\n    instance.configure_default_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 40.00700012594031}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\t// Enable timer wakeup\n\t\tWrite1Byte(0x32, 0x01);\n\t\t// Set timer duration\n\t\tWrite2Bytes(0x33, (uint16_t)(time_in_us / 1000));\n\t} else {\n\t\t// Disable timer wakeup\n\t\tWrite1Byte(0x32, 0x00);\n\t}\n\t// Initiate deep sleep\n\tWrite1Byte(0x31, Read8bit(0x31) | 0x80);\n}", "CodeBleu_score": 41.241017590408426}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t", "CodeBleu_score": 1.6688059799790205}, {"code": "int Display::scroll_line(uint32_t color){\n\t//  Serial.println(F(\"scroll_line()\"));\n  int yTemp = yStart;\n  tft.fillRect(0, yStart, TFT_WIDTH, TEXT_HEIGHT, color);\n  yStart += TEXT_HEIGHT;\n  if (yStart >= YMAX - BOT_FIXED_AREA) yStart = TOP_FIXED_AREA;\n  if (yStart == TOP_FIXED_AREA_2) yStart = TOP_FIXED_AREA;\n  return yTemp;\n}", "CodeBleu_score": 30.203884134365822}, {"code": "int Display::scroll_line(uint32_t color){\n\t\t//Serial.println(F(\"scroll_line()\"));\n\tint yTemp = yStart;\n\ttft.fillRect(0, yStart, TFT_WIDTH, TEXT_HEIGHT, color);\n\tyStart += TEXT_HEIGHT;\n\tif (yStart >= YMAX - BOT_FIXED_AREA) yStart = TOP_FIXED_AREA;\n\tif (tteBar) {\n\t\tif (yStart >= YMAX - BOT_FIXED_AREA) yStart = TOP_FIXED_AREA_2;\n\t}\n\ttft.setScroll(yStart);\n\treturn yTemp;\n}", "CodeBleu_score": 38.37900323008085}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->ssids = ssids;\n\tthis->access_points = access_points;\n\n\tif (!this->setupAccessPoints()) {\n\t\treturn false;\n\t}\n\n\tif (!this->setupHTML()) {\n\t\treturn false;\n\t}\n\n\tthis->runServer = true;\n\tthis->server.begin();\n\n\treturn true;\n}", "CodeBleu_score": 54.75449601450442}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Set up the access points\n\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t// Set up the HTML content\n\tif (!this->setupHTMLContent()) {\n\t\treturn false;\n\t}\n\n\t// Start the portal\n\tthis->runServer = true;\n\n\t// Return true if everything went well\n\treturn true;\n}", "CodeBleu_score": 45.62741628040228}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\tif (!this->setupHTML(ssids)) {\n\t\treturn false;\n\t}\n\n\tthis->runServer = true;\n\tthis->server.begin();\n\treturn true;\n}", "CodeBleu_score": 54.951879564853975}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tthis->queue_enabled_flag=true;\n\tif(!this->queue) this->new_queue();\n\tif(!this->text) this->text=new LinkedList<String>;\n\tif(!this->text_in) this->text_in=new LinkedList<String>;\n}", "CodeBleu_score": 44.426935146884986}, {"code": "void GpsInterface::enable_queue(){\n\t\tthis->queue_enabled_flag = true;\n\tif (this->queue == NULL) {\n\t\tthis->new_queue();\n\t}\n\tif (this->text == NULL) {\n\t\tthis->text = new LinkedList<String>;\n\t}\n\tif (this->text_in == NULL) {\n\t\tthis->text_in = new LinkedList<String>;\n\t}\n}", "CodeBleu_score": 29.29971348285837}, {"code": "void GpsInterface::enable_queue(){\n\t\tthis->queue_enabled_flag = true;\n\tthis->flush_queue();\n}", "CodeBleu_score": 10.020428380323605}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n\t\tdelete delme;\n\t} else\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 53.05822203953265}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n\t\tdelete delme;\n\t} else\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 53.05822203953265}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n\t\tdelete delme;\n\t} else\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 53.05822203953265}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tif defined(HAS_TFT_ESPI)\n    uint16_t c;\n    uint16_t x, y;\n    uint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    for (y = 0; y < h; y++) {\n      for (x = 0; x < w; x++) {\n        c = color_p->full;\n        display_obj.tft.writeColor(c, 1);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n#endif\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 67.03194245311657}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/    uint32_t w = (area->x2 - area->x1 + 1);\n//    uint32_t h = (area->y2 - area->y1 + 1);\n//\n//    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n//\n//    display_obj.tft.pushColors((uint16_t *)color_p, w * h);\n//\n//    lv_disp_flush_ready(disp);\n//  }", "CodeBleu_score": 13.514294875162644}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/    Serial.printf(\\\"my_disp_flush: %d %d %d %d\\\n\\\", area->x1, area->y1, area->x2, area->y2);\n    uint16_t c;\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        c = color_p->full;\n        display_obj.tft.writeColor(c, 1);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 88.53224147637155}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\t// Iterate through all menu nodes and print each node's name with indentation proportional to the layer level\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\t// Get the current menu node\n\t\tMenuNode node = menu->list->get(i);\n\n\t\t// Print the node's name with indentation proportional to the layer level\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tdisplay_obj.tft.print(\"    \");\n\t\t}\n\t\tdisplay_obj.tft.println(node.name);\n\n\t\t// If the current node has a submenu, recursively call showMenuList to print its submenu nodes\n\t\tif (node.submenu!= NULL) {\n\t\t\tshowMenuList(node.submenu, layer + 1);\n\t\t}\n\t}\n\n\t// Print an empty line after listing all nodes\n\tdisplay_obj.tft.println();\n}", "CodeBleu_score": 56.06150686011537}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tint i = 0;\n\tfor (i = 0; i < menu->list->size(); i++) {\n\t\tif (menu->list->get(i).layer == layer) {\n\t\t\tdisplay_obj.tft.print(menu->list->get(i).name);\n\t\t\tdisplay_obj.tft.println();\n\t\t}\n\t}\n\tdisplay_obj.tft.println();\n}", "CodeBleu_score": 52.13776640257151}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\t// If the node is a submenu, print its name with indentation and call the function recursively to list its submenu nodes.\n\t\tif (menu->list->get(i).submenu!= NULL) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tSerial.print(\"  \");\n\t\t\t}\n\t\t\tSerial.print(menu->list->get(i).name);\n\t\t\tSerial.print(\" >\n\");\n\t\t\tshowMenuList(menu->list->get(i).submenu, layer + 1);\n\t\t}\n\t\t// If the node is not a submenu, print its name with indentation.\n\t\telse {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tSerial.print(\"  \");\n\t\t\t}\n\t\t\tSerial.print(menu->list->get(i).name);\n\t\t\tSerial.print(\"\n\");\n\t\t}\n\t}\n\tSerial.print(\"\n\");\n}", "CodeBleu_score": 60.18206296246906}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint generated_count = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString essid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tessid += (char)random(65, 90);\n\t\t}\n\t\taddSSID(essid);\n\t\tgenerated_count++;\n\t}\n\treturn generated_count;\n}", "CodeBleu_score": 30.742591555147204}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num_generated = 0;\n\tString essid;\n\tfor (int i = 0; i < count; i++) {\n\t\tessid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tessid += char(random(65, 90));\n\t\t}\n\t\tif (addSSID(essid)) {\n\t\t\tnum_generated++;\n\t\t}\n\t}\n\treturn num_generated;\n}", "CodeBleu_score": 29.888333779516763}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num_generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString essid = \"\";\n\t\tfor (int j = 0; j < 6; j++)\n\t\t\tessid += (char)random(65, 91);\n\t\taddSSID(essid);\n\t\tnum_generated++;\n\t}\n\treturn num_generated;\n}", "CodeBleu_score": 31.12381721168281}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Created topic: {}\".format(topic))\n\n", "CodeBleu_score": 52.440354719519014}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.58447548238634}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 47.407721850208304}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \\\"iat\\\": datetime.datetime.utcnow(),\n        \\\"exp\\\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        \\\"aud\\\": project_id\n    }\n    with open(private_key_file, \\\"r\\\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 43.22411310736748}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print(\"Taking preview image\")\n        #camera.capture('preview.jpg')\n        #upload_blob(\"my-iot-bucket\", \"preview.jpg\")\n        #publish_messages(\"my-iot-project\", \"my-iot-topic\", \"https://storage.googleapis.com/my-iot-bucket/preview.jpg\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 22.332088587675553}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('on')\n        # Capture a preview image\n        subprocess.call(\"raspistill -w 640 -h 480 -q 100 -o /home/pi/Desktop/image.jpg -t 1000\", shell=True)\n        # Upload the image to a specified bucket\n        bucket_name = \"iot-demo-bucket\"\n        source_file_name = \"/home/pi/Desktop/image.jpg\"\n        destination_blob_name = \"image.jpg\"\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(bucket_name)\n        blob = bucket.blob(destination_blob_name)\n        blob.upload_from_filename(source_file_name)\n        print(\"File {} uploaded to {}.\".format(source_file_name, destination_blob_name))\n        # Publish the file's URL to an MQTT event topic\n        url = \"https://storage.googleapis.com/\" + bucket_name + \"/\" + destination_blob_name\n        publish_messages(project_id, topic_name, url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 44.771163969741515}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('on')\n        # Capture a preview image\n        print('Capturing image...')\n        os.system('fswebcam -r 1280x720 --no-banner /home/pi/Desktop/image.jpg')\n        print('Image captured')\n        # Upload the image to a specified bucket\n        print('Uploading image...')\n        bucket_name = 'image-bucket-280321'\n        source_file_name = '/home/pi/Desktop/image.jpg'\n        destination_blob_name = 'image.jpg'\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(bucket_name)\n        blob = bucket.blob(destination_blob_name)\n        blob.upload_from_filename(source_file_name)\n        print('Image uploaded')\n        # Publish the image's URL to an MQTT event topic\n        print('Publishing image URL...')\n        url = 'https://storage.googleapis.com/{}/{}'.format(bucket_name, destination_blob_name)\n        publish_messages(project_id, topic_name, url)\n        print('Image URL published')\n    else:\n        print('off')\n\n", "CodeBleu_score": 46.123717948514496}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Pub/Sub subscription name')\n    parser.add_argument(\n        '--service_account_json',\n        default=os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\"),\n        help='Path to service account json file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default=os.path.join(os.path.dirname(__file__), 'roots.pem'),\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        type=int,\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--client_id',\n        default='projects/{}/locations/{}/registries/{}/devices/{}'.format(\n            parser.parse_args().project_id,\n            'us-central1',\n           'my-registry',\n           'my-device'),\n        help='MQTT client id, if not set it will be generated from the other '\n             'arguments.')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id',\n        default='my-registry',\n        help='Cloud IoT registry id')\n    parser.add_argument(\n        '--device_id',\n        default='my-device',\n        help='Cloud IoT device id')\n    parser.add_argument(\n        '--private_key_file',\n       ", "CodeBleu_score": 40.189961040248804}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Pub/Sub subscription name')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--client_id',\n        default='projects/{}/locations/us-central1/registries/{}/devices/{}'.format(\n            os.environ.get('GOOGLE_CLOUD_PROJECT'),\n            os.environ.get('GOOGLE_CLOUD_REGISTRY_ID'),\n            os.environ.get('GOOGLE_CLOUD_DEVICE_ID')),\n        help='MQTT client ID used to connect to MQTT bridge.')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id',\n        default=os.environ.get('GOOGLE_CLOUD_REGISTRY_ID'),\n        help='Cloud IoT registry ID')\n    parser.add_argument(\n        '--device_id',\n        default=os.environ.get('GOOGLE_CLOUD_DEVICE_ID'),\n        help='Cloud IoT device ID')\n    parser.add_argument(\n        '--private_key_file',\n        default='rsa_private.pem',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',", "CodeBleu_score": 34.76358315793891}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Pub/Sub subscription name')\n    parser.add_argument(\n        '--service_account_json',\n        help='Path to service account json file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.goog/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        type=int,\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event','state'),\n        default='event',\n        help='Whether the message to be published is a \"event\" or a \"state\".')\n    parser.add_argument(\n        '--message_data',\n        default='{}',\n        help='Data to include in the message.')\n    parser.add_argument(\n        '--gateway_id',\n        required=True,\n        help='Gateway ID')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Device ID')\n    parser.add_argument(\n        '--private_key_file',\n        required=True,\n        help='Path to private key file.')\n    parser.add_argument(\n        '--version',\n        action='store_true',\n        help='Print version string.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        type=int,\n        default=20,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add", "CodeBleu_score": 35.52808298277954}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the API scope and discovery URL\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scope the credentials to the appropriate API scope\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    # Build the client for the Cloud IoT Core service using the discovery API URL\n    client = discovery.build('cloudiot', api_version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials)\n\n    return client\n\n", "CodeBleu_score": 28.813985272275982}, {"code": "def get_client(service_account_json)\n\t\n    # Define the necessary API scopes, version, and discovery URL\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=api_scopes\n    )\n\n    # Scopes the credentials appropriately and uses them to build the client\n    scoped_credentials = credentials.with_scopes(api_scopes)\n    return discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 27.76863509633213}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\n        'https://www.googleapis.com/auth/cloud-platform',\n        'https://www.googleapis.com/auth/pubsub',\n    ]\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json,\n        scopes=scopes,\n    )\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build(\n        'cloudiot',\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials,\n    )\n\n", "CodeBleu_score": 28.141610606032323}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = hash_method.get_asn1_code()\n    if not asn1_code:\n        raise ValueError('Invalid hash method')\n\n    hash_value = asn1_code + hash_value\n    padded = _pad_for_signing(hash_value, common.byte_size(priv_key.n))\n    payload = transform.bytes2int(padded)\n    encrypted = core.encrypt_int(payload, priv_key.e, priv_key.n)\n    block = transform.int2bytes(encrypted, common.byte_size(priv_key.n))\n\n    return block\n\n", "CodeBleu_score": 51.97337885298169}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = _asn1_codes.get(hash_method, None)\n    if asn1_code is None:\n        raise ValueError('Invalid hash method %s' % hash_method)\n\n    hash_value_with_code = b''.join([asn1_code, hash_value])\n    padded = _pad_for_signing(hash_value_with_code, common.byte_size(priv_key.n))\n    payload = transform.bytes2int(padded)\n    encrypted = core.encrypt_int(payload, priv_key.d, priv_key.n)\n    block = transform.int2bytes(encrypted, common.byte_size(priv_key.n))\n\n    return block\n\n", "CodeBleu_score": 53.1402919629364}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = _get_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError('Invalid hash method')\n    block = b''.join([asn1_code, hash_value])\n    block = _pad_for_signing(block, common.byte_size(priv_key.n))\n    payload = transform.bytes2int(block)\n    encrypted = priv_key.blinded_decrypt(payload)\n    block = transform.int2bytes(encrypted, common.byte_size(priv_key.n))\n    return block\n\n", "CodeBleu_score": 47.15398862447015}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n    # Decrypt the signature to obtain the clear signature\n    clear_signature = core.decrypt_int(signature_int, pub_key.e, pub_key.n)\n    clear_signature_bytes = transform.int2bytes(clear_signature, common.byte_size(pub_key.n))\n    # Determine the hash method used\n    hash_method = None\n    for method, asn1code in HASH_ASN1.items():\n        if clear_signature_bytes.startswith(asn1code):\n            hash_method = method\n            break\n    if hash_method is None:\n        raise VerificationError(\"Signature doesn't start with a valid hash method\")\n    # Compute the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(HASH_ASN1[hash_method] + msg_hash, common.byte_size(pub_key.n))\n    # Compare the expected padded hash with the clear signature\n    if expected_padded_hash!= clear_signature_bytes:\n        raise VerificationError(\"Signature doesn't match\")\n    # If the verification is successful, return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 39.795608300125366}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n    # Decrypt the signature\n    decrypted_signature = core.decrypt_int(signature_int, pub_key.e, pub_key.n)\n    # Convert the decrypted signature back to a byte string\n    decrypted_signature_bytes = transform.int2bytes(decrypted_signature, common.byte_size(pub_key.n))\n    # Find the hash method used\n    hash_method = _find_hash_method(decrypted_signature_bytes)\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(HASH_ASN1[hash_method] + message_hash, common.byte_size(pub_key.n))\n    # Verify the signature\n    if decrypted_signature_bytes!= expected_padded_hash:\n        raise VerificationError(\"Signature verification failed\")\n    # Return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 28.38439828085257}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer and decrypt it to obtain the clear signature\n    sig_int = transform.bytes2int(signature)\n    clear_sig = core.decrypt_int(sig_int, pub_key.e, pub_key.n)\n    clear_sig_bytes = transform.int2bytes(clear_sig, common.byte_size(pub_key.n))\n\n    # Determine the hash method used\n    for hash_method, asn1_code in HASH_ASN1.items():\n        if clear_sig_bytes.startswith(asn1_code):\n            break\n    else:\n        raise VerificationError(\"Could not determine hash method\")\n\n    # Compute the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(asn1_code + msg_hash, common.byte_size(pub_key.n))\n\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if clear_sig_bytes!= expected_padded_hash:\n        raise VerificationError(\"Signature verification failed\")\n\n    # If the verification is successful, return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 38.88724599668303}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch;\n\tuint8_t status;\n\n\t// Get current time\n\tepoch = time(NULL);\n\tif (epoch!= (uint32_t) - 1) {\n\t\t// Update the JWT using the current UNIX time\n\t\tupdateJWT(epoch);\n\t}\n\t// Connect to the MQTT client\n\tstatus = connectMQTTSocket();\n\tif (status == 0) {\n\t\t// Set flag to send MQTT SUBSCRIBE packet after connection is established\n\t\tsendSubscribe = true;\n\t\tdebug_printInfo(\\\"CLOUD: MQTT connection attempt\\\");\n\t}\n}", "CodeBleu_score": 48.808422080869356}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tuint32_t status = 0;\n\n\t// Get the current time\n\tepoch = getEpoch();\n\n\t// If the time is valid, update the JWT\n\tif (epoch!= 0) {\n\t\tupdateJWT(epoch);\n\t}\n\n\t// Connect to the MQTT client\n\tstatus = connectMQTTSocket();\n\n\t// Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n\tsendSubscribe = true;\n\n\t// Print a debug message indicating the MQTT connection attempt\n\tdebug_printError(\\\"CLOUD: MQTT connection attempt\\\");\n}", "CodeBleu_score": 45.41675177000005}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\n\tif (getEpochTime(&epoch) == 0) {\n\n\t\tupdateJWT(epoch);\n\n\t\tconnectMQTTSocket();\n\n\t\twaitingForMQTT = true;\n\n\t\ttimeout_create(&mqttTimeoutTaskTimer, CLOUD_MQTT_TIMEOUT_COUNT);\n\n\t\tsendSubscribe = true;\n\n\t\tdebug_printInfo(\\\"CLOUD: Attempting to connect to MQTT\\\");\n\n\t}\n\n}", "CodeBleu_score": 43.55916196255247}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t ret = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tret *= 10;\n\t\tret += *str - '0';\n\t\tstr++;\n\t}\n\n\t*num = ret;\n\treturn str;\n}", "CodeBleu_score": 27.643277391259787}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t n = 0;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (*str++ - '0');\n\t}\n\n\t*num = n;\n\treturn str;\n}", "CodeBleu_score": 27.962249070463198}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\t*num = 0;\n\twhile (width--) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\t*num = *num * 10 + (*str - '0');\n\t\tstr++;\n\t}\n\treturn str;\n}", "CodeBleu_score": 25.18294286376344}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tif (build_state == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\tif (build_state->cert_def->type == CERTTYPE_X509) {\n\t\tif (build_state->is_device_sn) {\n\t\t\tint ret = atcacert_set_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->max_cert_size, build_state->device_sn, build_state->cert_def->cert_sn_dev_loc.count);\n\t\t\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (build_state->cert_def->public_key_dev_loc.count == 64) {\n\t\t\tuint8_t public_key[64];\n\t\t\tint ret = atcacert_get_subj_public_key(build_state->cert_def, build_state->cert, build_state->cert_size, public_key);\n\t\t\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = atcacert_set_signature(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->max_cert_size, public_key);\n\t\t\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 58.307536236804935}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t 226 \"C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Temp\\\\1\\\\tmp4172.tmp\\\\timeout.c\"\n    if(list == NULL) return false;\n    if(timer == NULL) return false;\n\n    timerStruct_t *prev = NULL;\n    timerStruct_t *curr = *list;\n    while(curr!= NULL)\n    {\n        if(curr == timer)\n        {\n            if(prev == NULL)\n            {\n                *list = curr->next;\n            }\n            else\n            {\n                prev->next = curr->next;\n            }\n            return true;\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    return false;\n}", "CodeBleu_score": 42.477126639837756}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\timer == NULL)\n\t{\n\t\treturn false;\n\t}\n\ttimerStruct_t *prev = NULL;\n\ttimerStruct_t *next = *list;\n\twhile(next!= NULL)\n\t{\n\t\tif(next == timer)\n\t\t{\n\t\t\tif(prev == NULL)\n\t\t\t{\n\t\t\t\t*list = next->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprev->next = next->next;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprev = next;\n\t\tnext = next->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 30.109922323316628}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\timer == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\ttimerStruct_t *prevPoint = NULL;\n\ttimerStruct_t *insertPoint = *list;\n\n\twhile(insertPoint!= NULL)\n\t{\n\t\tif(insertPoint == timer)\n\t\t{\n\t\t\tif(prevPoint == NULL)\n\t\t\t{\n\t\t\t\t*list = insertPoint->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprevPoint->next = insertPoint->next;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprevPoint = insertPoint;\n\t\tinsertPoint = insertPoint->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 31.24773554791337}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t}\n\tif (close(socket) < 0) {\n\t\tswitch (getErrno()) {\n\t\tcase EBADF:\n\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 50.02971023923468}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif(bsdSocket)\n\t{\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t}\n\tif (close(socket) < 0)\n\t{\n\t\tswitch(bsdErrorNumber)\n\t\t{\n\t\t\tcase EBADF:\n\t\t\t\tdebug_printError(\"BSD: close error EBADF\");\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tdebug_printError(\"BSD: close error ENOTSOCK\");\n\t\t\t\tbreak;\n\t\t\tcase EINTR:\n\t\t\t\tdebug_printError(\"BSD: close error EINTR\");\n\t\t\t\tbreak;\n\t\t\tcase EIO:\n\t\t\t\tdebug_printError(\"BSD: close error EIO\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdebug_printError(\"BSD: close error unknown error number\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n\t\tdebug_printGOOD(\"BSD: close success\");\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 52.0505209375369}, {"code": "int BSD_close(int socket){\n\t\twincSocketResponses_t wincCloseReturn;\n\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t}\n\n\twincCloseReturn = close(socket);\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincCloseReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 69.97786808895813}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d) \", socket);\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 76.54766760955363}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d) \", socket);\n\n\twincListenReturn = listen((SOCKET) socket, (uint8_t) backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 80.32677814662381}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d) \", socket);\n\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else if (backlog < 0) {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 71.39609935403658}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\tstatic wincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn < 0) {\n\t\tswitch(wincAcceptReturn) {\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if (addr!= NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if (*addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn wincAcceptReturn;\n\t}\n}", "CodeBleu_score": 80.0586398516957}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptResponse;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family)\n\t{\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptResponse = accept((int8_t)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptResponse!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincAcceptResponse)\n\t\t{\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr!= NULL)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == 0)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 74.77655101935974}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptResponse;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptResponse = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptResponse < 0) {\n\t\tswitch(wincAcceptResponse) {\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t} else if (addr!= NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t} else if (addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 79.43574537930016}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n   uint32_t ret;\n\n   if (cloudInitialized) {\n      return;\n   }\n\n   if (!isResetting) {\n      // Get the current time in UNIX format\n      epoch = getUnixTime();\n      if (epoch == 0) {\n         debug_printError(\\\"CLOUD: Failed to get time\\\");\n         return;\n      }\n   }\n\n   // Update the JWT with the current time offset\n   updateJWT(epoch);\n\n   // Initialize the MQTT connection\n   debug_printInfo(\\\"CLOUD: Initializing MQTT connection\\\");\n   ret = mqtt_init();\n   if (ret == MQTT_SUCCESS) {\n      // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n      sendSubscribe = true;\n   }\n}", "CodeBleu_score": 46.71659438855012}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tint8_t ret = 0;\n\n\tepoch = getUnixTime();\n\tif (epoch > 0)\n\t{\n\t\tupdateJWT(epoch);\n\t\tret = connectMQTTSocket();\n\t\tif (ret == 0)\n\t\t{\n\t\t\tdebug_printError(\\\"CLOUD: MQTT Connect\\\");\n\t\t\twaitingForMQTT = true;\n\t\t\ttimeout_create(&mqttTimeoutTaskTimer, CLOUD_MQTT_TIMEOUT_COUNT);\n\t\t\tsendSubscribe = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 21.837718637624835}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\n\t// Retrieve the current time in UNIX format\n\tepoch = getUnixTime();\n\n\t// Check if the time is valid\n\tif (epoch == 0) {\n\t\t// If not valid, print a debug message\n\t\tdebug_printError(\\\"CLOUD: Invalid time, cannot connect to MQTT\\\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time offset\n\tupdateJWT(epoch);\n\n\t// Initiate the MQTT connection\n\tdebug_printError(\\\"CLOUD: Connecting to MQTT\\\");\n\twaitingForMQTT = true;\n\ttimeout_create(&mqttTimeoutTaskTimer, CLOUD_MQTT_TIMEOUT_COUNT);\n\n\t// Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n\tsendSubscribe = true;\n}", "CodeBleu_score": 20.691635171887686}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tdebug_printInfo(\"CLOUD: Disconnecting\");\n\tif (MQTT_CLIENT_isConnected()) {\n\t\tclientInfo_t clientInfo;\n\t\tMQTT_CLIENT_getClientInfo(&clientInfo);\n\t\tMQTT_CLIENT_disconnect();\n\t}\n}", "CodeBleu_score": 25.64705327576997}, {"code": "void CLOUD_disconnect(void){\n\tif (MQTT_GetClientConnectionState() == MQTT_CLIENT_CONNECTED) {\n\t\tclientConnectionInfo_t clientConnectionInfo;\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_CLIENT_disconnect();\n\t\tdebug_printInfo(\"CLOUD: Disconnect\");\n\t}\n}", "CodeBleu_score": 54.09599794106327}, {"code": "void CLOUD_disconnect(void){\n\tdebug_printInfo(\"CLOUD: Disconnecting from MQTT\");\n\tif (MQTT_CLIENT_isConnected()) {\n\t\tmqttClientConnectionInfo_t clientConnectionInfo;\n\t\tMQTT_CLIENT_getConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_CLIENT_disconnect();\n\t}\n}", "CodeBleu_score": 24.893331419781813}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiConnInfo apConfig;\n\tint8_t ret = M2M_SUCCESS;\n\n\tif(passed_wifi_creds == WIFI_CRED_DEFAULT)\n\t{\n\t\tret = m2m_wifi_connect((char *) WIFI_DEFAULT_SSID, strlen(WIFI_DEFAULT_SSID), WIFI_DEFAULT_AUTH, (void *) WIFI_DEFAULT_PASSWORD, M2M_WIFI_CH_ALL);\n\t}\n\telse\n\t{\n\t\tret = m2m_wifi_connect((char *) WIFI_SSID, strlen(WIFI_SSID), WIFI_AUTH, (void *) WIFI_PASSWORD, M2M_WIFI_CH_ALL);\n\t}\n\n\tif (ret!= M2M_SUCCESS) {\n\t\tdebug_printError(\\\"Failed to connect to Wi-Fi AP\\\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.14480969068799}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tnst api = generateClient();\n\tconst response = await api.graphql({\n\t\tquery: listSensors,\n\t});\n\tconsole.log(response);\n\tif (response.data) {\n\t\tconsole.log('retrieved sensors');\n\t\tresponse.data.listSensors.items.forEach((sensor) => {\n\t\t\tvar marker = new Marker(CreateSensorMarker(sensor))\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 47.82286135482221}, {"code": "async function DisplaySensors(map){\n\t Create a client\nconst api = generateClient({\nauthMode: 'API_KEY',\n});\n\n// Send a GraphQL query to fetch sensor data\nconst { data } = await api.graphql({\nquery: listSensors,\n});\n\n// Log the API response\nconsole.log(data);\n\n// If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\nif (data.listSensors.items) {\nconsole.log('Retrieved sensors:');\ndata.listSensors.items.forEach((sensor) => {\n\n// Create a marker for the sensor\nconst marker = new Marker({\nelement: CreateSensorMarker(sensor),\nanchor: 'bottom',\n});\n\n// Place the marker on the map at the sensor's geographical coordinates\nmarker.setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n});\n}\n}", "CodeBleu_score": 39.622719224043635}, {"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tonst marker = document.createElement(\\\"div\\\");\n\tmarker.id = sensor.id;\n\tmarker.className = \\\"sensor-marker\\\";\n\tmarker.style.backgroundColor = \\\"#3bb2d0\\\";\n\tmarker.style.border = \\\"1px solid #3bb2d0\\\";\n\treturn marker;\n}", "CodeBleu_score": 36.425565135893756}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tr marker = document.createElement('div');\nmarker.id = sensor.id;\nmarker.className ='marker';\nmarker.style.backgroundColor ='red';\nmarker.style.border = '2px solid white';\nreturn marker;\n}", "CodeBleu_score": 42.71618268253607}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tr marker = document.createElement('div');\nmarker.id = sensor.id;\nmarker.className ='sensor-marker';\nmarker.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\nmarker.style.border = '1px solid #333';\nmarker.style.width = '10px';\nmarker.style.height = '10px';\nmarker.style.borderRadius = '50%';\nreturn marker;\n}", "CodeBleu_score": 46.416190507564515}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    if module_name not in MULTI_FACTOR_AUTH_MODULES:\n        module_path = \\\"homeassistant.components.auth.mfa_modules.{}\\\"\n        try:\n            module = await async_import_module(hass, module_path.format(module_name))\n        except ImportError as err:\n            _LOGGER.error(\n                \\\"Error while loading multi-factor module %s: %s\\\",\n                module_name,\n                err,\n            )\n            raise\n\n        if module_name not in DATA_REQS[hass]:\n            if module.REQUIREMENTS:\n                if not requirements.async_process_requirements(\n                    hass,\n                    module_name,\n                    module.REQUIREMENTS,\n                    skip_pip=False,\n                ):\n                    raise HomeAssistantError(\n                        \\\"Unable to install required packages for multi-factor module \\\"\n                        f\\\"{module_name}\\\"\n                    )\n            DATA_REQS[hass].add(module_name)\n\n        MULTI_FACTOR_AUTH_MODULES[module_name] = module\n\n    return MULTI_FACTOR_AUTH_MODULES[module_name]\n\n", "CodeBleu_score": 34.96700037058724}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    if DATA_REQS not in hass.data:\n        hass.data[DATA_REQS] = set()\n\n    reqs = hass.data[DATA_REQS]\n\n    if module_name not in reqs:\n        module_path = \\\"homeassistant.components.auth.mfa_modules.\\\" + module_name\n\n        try:\n            module = await async_import_module(hass, module_path)\n        except ImportError as err:\n            _LOGGER.error(\\\"Unable to import mfa module %s: %s\\\", module_name, err)\n            raise\n\n        if hasattr(module, \\\"REQUIREMENTS\\\"):\n            if not hass.config.skip_pip:\n                await requirements.async_process_requirements(\n                    hass,\n                    module_name,\n                    module.REQUIREMENTS,\n                    True,\n                )\n\n            reqs.add(module_name)\n\n    return module\n\n", "CodeBleu_score": 46.77791936194543}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    if module_name in hass.data.get(DATA_REQS, {}):\n        return await async_import_module(f\\\".mfa_modules.{module_name}\\\", __name__)\n\n    module_path = f\\\".mfa_modules.{module_name}\\\"\n    try:\n        module = await async_import_module(module_path, __name__)\n    except ImportError as err:\n        _LOGGER.error(\n            \\\"Error importing multi-factor auth module %s: %s\\\",\n            module_name,\n            err,\n        )\n        raise\n\n    if module.REQUIREMENTS:\n        if not requirements.async_process_requirements(hass, module.REQUIREMENTS):\n            raise HomeAssistantError(f\\\"Could not install requirements for {module_name}\\\")\n\n    hass.data.setdefault(DATA_REQS, {})[module_name] = set()\n    hass.data[DATA_REQS][module_name].update(module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 42.234132406476476}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    if user_id in self._data:\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self._data[user_id] = {\"user_id\": user_id, \"pin\": setup_data[\"pin\"]}\n\n    return user_id\n\n", "CodeBleu_score": 41.152593249247694}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    if user_id in self._data:\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self._data[user_id] = {\"user_id\": user_id, \"pin\": setup_data[\"pin\"]}\n    return self._data[user_id]\n\n    async def async_validate_login(self, user_id: str, input_data: Any) -> Any:\n        \\\"\\\"\\\"Validate user login. The function checks if the user ID and PIN provided in the input data match an entry in the internal data list.\n        If a match is found, it returns the entry; otherwise, it raises an exception indicating an invalid login attempt.\n        \\\"\\\"\\\"\n        if user_id in self._data:\n            if self._data[user_id][\"pin\"] == input_data[\"pin\"]:\n                return self._data[user_id]\n        raise InvalidAuth(\\\"Invalid PIN\\\")\n\n    @property\n    def async_is_setup(self) -> bool:\n        \\\"\\\"\\\"Return True if the module has been set up for at least one user.\\\"\\\"\\\"\n        return bool(self._data)\n\n    async def async_reset(self) -> None:\n        \\\"\\\"\\\"Reset the module to a fresh state.\\\"\\\"\\\"\n        self._data = {}\n\n    async def async_remove_user(self, user_id: str) -> None:\n        \\\"\\\"\\\"Remove a user from the module.\\\"\\\"\\\"\n        if user_id in self._data:\n            del self._data[user_id]\n\n    async def async_async_get_users(self) -> list[str]:\n        \\\"\\\"\\\"Return a list of user IDs that have been set up.\\\"\\\"\\\"\n        return list(self._data.keys())\n\n    async def async_get_user_data(self, user_id: str) -> Any:\n        \\\"\\\"\\\"Return the data for a specific user.\\\"\\\"\\\"\n        if user_id in self._data:\n            return self._data[user_id]\n        return None\n\n    async def async_get_user_data_by_pin(self, pin: str) ->", "CodeBleu_score": 35.96981269168072}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    if any(user[\"user_id\"] == user_id for user in self._data):\n        for user in self._data:\n            if user[\"user_id\"] == user_id:\n                user[\"pin\"] = setup_data[\"pin\"]\n                break\n    else:\n        self._data.append({\"user_id\": user_id, \"pin\": setup_data[\"pin\"]})\n\n    return setup_data\n\n", "CodeBleu_score": 46.697405101160065}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        data = await self._user_store.async_load()\n        if not data:\n            self._user_settings = {}\n        else:\n            self._user_settings = {\n                user_id: NotifySetting(**user_data)\n                for user_id, user_data in data[STORAGE_USERS].items()\n            }\n\n    @property\n    def user_settings(self) -> _UsersDict:\n        \\\"\\\"\\\"Return user settings.\\\"\\\"\\\"\n        return cast(_UsersDict, self._user_settings)\n\n    @callback\n    def async_get_user_setting(self, user_id: str) -> NotifySetting:\n        \\\"\\\"\\\"Return user setting for the user_id.\n\n        If the user_id is not found, create a new user setting for the user_id.\n        \\\"\\\"\\\"\n        if user_id not in self._user_settings:\n            self._user_settings[user_id] = NotifySetting()\n        return self._user_settings[user_id]\n\n    @callback\n    def async_update_user_setting(self, user_id: str, **kwargs: Any) -> None:\n        \\\"\\\"\\\"Update user setting for the user_id.\n\n        If the user_id is not found, create a new user setting for the user_id.\n        \\\"\\\"\\\"\n        user_setting = self.async_get_user_setting(user_id)\n        for key, value in kwargs.items():\n            setattr(user_setting, key, value)\n\n    @callback\n    def async_get_user_setting_value(self, user_id: str, key: str) -> Any:\n        \\\"\\\"\\\"Return user setting value for the user_id.\n\n        If the user_id is not found, create a new user setting for the user_id.\n        \\\"\\\"\\\"\n        user_setting = self.async_get_user_setting(user_id)\n        return getattr(user_setting, key)\n\n    @callback\n    def async_update_user_setting_value(self, user_id: str", "CodeBleu_score": 40.04486677698622}, {"code": "async def _async_load(self) -> None\n\t    await self._init_lock.acquire()\n    try:\n        if self._user_settings is not None:\n            return\n\n        user_data = await self._user_store.async_load()\n        if not user_data:\n            self._user_settings = {}\n        else:\n            self._user_settings = {}\n            for user_id, user_data in user_data[STORAGE_USERS].items():\n                self._user_settings[user_id] = NotifySetting(\n                    notify_service=user_data.get(NotifyAuthModule.STORAGE_NOTIFY_SERVICE),\n                    target=user_data.get(NotifyAuthModule.STORAGE_TARGET),\n                )\n    finally:\n        self._init_lock.release()\n\n\n", "CodeBleu_score": 37.426893379390236}, {"code": "async def _async_load(self) -> None\n\t    if self._user_settings is None:\n        async with self._init_lock:\n            if self._user_settings is None:\n                await self._user_store.async_load()\n                if not self._user_store.data:\n                    self._user_settings = {}\n                else:\n                    self._user_settings = {\n                        user_id:\n                        NotifySetting(\n                            secret=user_data[STORAGE_USERS][STORAGE_USER_ID][\\\"secret\\\"],\n                            counter=user_data[STORAGE_USERS][STORAGE_USER_ID][\\\"counter\\\"],\n                            notify_service=user_data[STORAGE_USERS][STORAGE_USER_ID][\\\"notify_service\\\"],\n                            target=user_data[STORAGE_USERS][STORAGE_USER_ID][\\\"target\\\"],\n                        )\n                        for user_id, user_data in self._user_store.data.items()\n                    }\n\n", "CodeBleu_score": 39.95072718980191}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    if (user_settings := self._user_settings.get(user_id)) is None:\n        return False\n\n    if (\n        user_settings.notify_service is None\n        or user_settings.target is None\n        or user_settings.secret is None\n    ):\n        return False\n\n    try:\n        otp = user_input[INPUT_FIELD_CODE]\n        if not _verify_otp(user_settings.secret, otp, user_settings.counter):\n            return False\n    except Exception:  # pylint: disable=broad-except\n        return False\n\n    user_settings.counter += 1\n    await self._async_save()\n\n    return True\n\n", "CodeBleu_score": 64.71105470633098}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    secret = notify_setting.secret\n    otp = user_input.get(INPUT_FIELD_CODE)\n    if otp is None:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        _verify_otp, secret, otp, notify_setting.counter\n    )\n\n", "CodeBleu_score": 71.11276002529439}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        _verify_otp, notify_setting.secret, user_input[INPUT_FIELD_CODE], notify_setting.counter\n    )\n\n", "CodeBleu_score": 72.53610852202868}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity_entry = perm_lookup.entity_lookup.get(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = entity_entry.device_entry\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.34700899108062}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity = perm_lookup.entity_lookup.get(entity_id)\n    if not entity:\n        return None\n    device = entity.device\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 41.25761119306348}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity_entry = perm_lookup.entity_lookup.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_lookup.get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 72.1418041745153}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    merged_policy = {}  # type: ignore\n    seen_categories = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [cast(CategoryType, policy[category])]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 45.98382833791366}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 62.4926122931405}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    policy: dict[CategoryType, dict[str, str]] = {}\n    seen_categories: set[CategoryType] = set()\n    for p in policies:\n        for category in p:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                policy[category] = merge_categories(\n                    [cast(dict[str, str], p[category])]\n                )\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 47.72932995729982}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  if provider in hass.data[DATA_REQS]:\n        return __import__(f\"homeassistant.components.auth_provider_{provider}\")\n\n    try:\n        module = await async_import_module(hass, f\"homeassistant.components.auth_provider_{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading auth provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Error loading auth provider {provider}: {err}\"\n        ) from err\n\n    if provider not in hass.data[DATA_REQS]:\n        hass.data[DATA_REQS].add(provider)\n        reqs = module.REQUIREMENTS\n        if reqs:\n            await requirements.async_process_requirements(hass, provider, reqs)\n\n    return module\n\n", "CodeBleu_score": 53.624872008183864}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  if provider in hass.data.get(DATA_REQS, {}):\n        return __import__(f\"homeassistant.auth.providers.{provider}\")\n\n    try:\n        module = __import__(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\", provider, err,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n    reqs = hass.data.get(DATA_REQS, {})\n    reqs[provider] = set()\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    for req in module.REQUIREMENTS:\n        if req in reqs[provider]:\n            continue\n\n        reqs[provider].add(req)\n        try:\n            await requirements.async_process_requirements(hass, req)\n        except requirements.RequirementNotFound as err:\n            _LOGGER.error(\n                \"Unable to install requirements for auth provider %s: %s\",\n                provider,\n                err,\n            )\n            raise HomeAssistantError(\n                f\"Unable to install requirements for auth provider {provider}: {err}\"\n            ) from err\n\n    hass.data[DATA_REQS] = reqs\n\n    return module\n\n", "CodeBleu_score": 50.98075156525377}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  if provider in hass.data.get(DATA_REQS, set()):\n        return await async_import_module(f\"homeassistant.components.auth_providers.{provider}\")\n    try:\n        module = await async_import_module(f\"homeassistant.components.auth_providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIRES_AUTH_PROVIDER\"):\n        return module\n    requirements_ = getattr(module, \"REQUIRES_AUTH_PROVIDER\")\n    if not requirements_:\n        return module\n    hass.data[DATA_REQS] = hass.data.get(DATA_REQS, set()).union(requirements_)\n    await requirements.async_process_requirements(hass, requirements_)\n    return module\n\n", "CodeBleu_score": 54.93396047541895}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t   try:\n        self._data = await self._store.async_load()\n    except FileNotFoundError:\n        self._data = {}\n\n    # Legacy mode will allow usernames to start/end with whitespace\n    # and will compare usernames case-insensitive.\n    # Deprecated in June 2019 and will be removed in 2026.7\n    self.is_legacy = False\n\n    if self._data and not self.is_legacy:\n        for username in self._data:\n            if username!= self.normalize_username(username):\n                self.is_legacy = True\n                break\n\n    # Legacy mode will allow usernames to start/end with whitespace\n    # and will compare usernames case-insensitive.\n    # Deprecated in June 2019 and will be removed in 2026.7\n    if self.is_legacy:\n        _LOGGER.warning(\n            \\\"Legacy mode detected. Home Assistant will no longer allow usernames to start/end with whitespace and will compare usernames case-insensitively. This mode will be removed in 2026.7. Please update your usernames and passwords to comply with the new rules.\\\"  # noqa: E501\n        )\n\n", "CodeBleu_score": 23.37086492479737}, {"code": "async def async_load(self) -> None\n\t   try:\n        self._data = await self._store.async_load()\n    except FileNotFoundError:\n        self._data = {}\n    except (OSError, json.JSONDecodeError):\n        # We failed to read the data, wipe it\n        self._data = None\n        await self._store.async_remove()\n\n    if not self._data:\n        self._data = {}\n\n    # Check for non-normalized usernames\n    for username, data in self._data.items():\n        if username!= self.normalize_username(username):\n            self._data[self.normalize_username(username)] = data\n            del self._data[username]\n\n    if self._data:\n        # We have data, check if we have legacy users\n        if any(u[\"username\"].strip()!= u[\"username\"] for u in self._data.values()):\n            self.is_legacy = True\n            # Legacy mode, log a warning\n            _LOGGER.warning(\n                \\\"Legacy mode for Home Assistant authentication is deprecated and will be removed in 2026.7\\\"\n            )\n            # We have legacy users, migrate to the new format\n            for username, data in self._data.items():\n                self._data[self.normalize_username(username, force_normalize=True)] = data\n            await self._store.async_save(self._data)\n\n\n", "CodeBleu_score": 28.29579699238376}, {"code": "async def async_load(self) -> None\n\t   try:\n        self._data = await self._store.async_load()\n    except (OSError, ValueError):\n        self._data = None\n\n    if self._data is None:\n        self._data = {}\n\n    # Check for non-normalized usernames\n    for username, user in self._data.items():\n        if username!= self.normalize_username(username):\n            self._data[self.normalize_username(username)] = user\n            del self._data[username]\n\n\n", "CodeBleu_score": 29.105035519472082}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t  username = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\\\"dummy\\\", bcrypt.gensalt())\n    for user in self.data.users:\n        if user[\\\"username\\\"] == username:\n            if user[\\\"password\\\"] == \\\"*\\\":\n                raise InvalidAuth(f\\\"Password not set for {username}\\\")\n            try:\n                if bcrypt.checkpw(\n                    password.encode(), base64.b64decode(user[\\\"password\\\"].encode())\n                ):\n                    return\n            except ValueError:\n                pass\n            raise InvalidAuth\n    bcrypt.checkpw(b\\\"dummy\\\", dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 33.29116012762279}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t  username = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\\\"dummy\\\", bcrypt.gensalt())\n    for user in self.data.users:\n        if user[\\\"username\\\"] == username:\n            if bcrypt.checkpw(password.encode(\\\"utf-8\\\"), base64.b64decode(user[\\\"password_hash\\\"])):\n                return\n            raise InvalidAuth\n\n    bcrypt.checkpw(b\\\"dummy\\\", dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 34.0724111117882}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t  username = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\\\"\\\", bcrypt.gensalt())\n    for user in self.data.users:\n        if user[\\\"username\\\"] == username:\n            password_hash = base64.b64decode(user[\\\"password\\\"])\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            raise InvalidAuth\n    bcrypt.checkpw(b\\\"\\\", dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 39.6386703088752}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n\n    for index, user in enumerate(self.users):\n        if self.normalize_username(user[\"username\"]) == username:\n            del self.users[index]\n            return\n\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 44.03682237372226}, {"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            self.users.remove(user)\n            return\n\n    raise InvalidUser(f\"User {username} not found\")\n\n", "CodeBleu_score": 38.00724995386413}, {"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(username, \"user_not_found\")\n\n", "CodeBleu_score": 38.40257668721417}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n    except InvalidUser:\n        pass\n    await self.data.async_save()\n\n", "CodeBleu_score": 89.78249354043015}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n\n        thread_timeout = timeout / len(threads)\n        if thread.join(thread_timeout):\n            joined.add(thread)\n        else:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 61.27661909214325}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        thread_timeout = timeout / len(threads)\n        thread.join(thread_timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 56.23083154844978}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is not None:\n                thread.join(timeout)\n                if thread.is_alive():\n                    if log:\n                        _log_thread_running_at_shutdown(thread.name, thread.ident)\n                    async_raise(thread.ident, SystemExit)\n                else:\n                    joined.add(thread)\n            else:\n                joined.add(thread)\n        else:\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 47.989132352398364}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        t\n        for t in threading.enumerate()\n        if t is not threading.current_thread() and not t.daemon\n    ]\n    if not threads:\n        return\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                \\\"\\\"\\\"Thread %s did not exit in %s seconds. It will be terminated.\\\"\\\"\\\",\n                thread.name,\n                timeout,\n            )\n            ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                ctypes.c_long(thread.ident), ctypes.py_object(SystemExit)\n            )\n\n", "CodeBleu_score": 31.486586296029078}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    remaining_threads = []\n    for thread in threading.enumerate():\n        if thread.ident == threading.get_ident() or thread.daemon:\n            continue\n        remaining_threads.append(thread)\n    if not remaining_threads:\n        return\n    _LOGGER.warning(\n        \\\"Shutting down %s non-daemon threads. This may take up to %s seconds.\\\",\n        len(remaining_threads),\n        THREADING_SHUTDOWN_TIMEOUT,\n    )\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(remaining_threads)\n    for thread in remaining_threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                \\\"Thread %s did not terminate within %s seconds. It will be terminated.\\\",\n                thread,\n                timeout,\n            )\n            try:\n                ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                    ctypes.c_long(thread.ident), ctypes.py_object(SystemExit)\n                )\n            except (ValueError, SystemError) as exc:\n                _LOGGER.warning(\n                    \\\"Failed to terminate thread %s. Exception: %s\\\", thread, exc\n                )\n\n", "CodeBleu_score": 34.877305721413734}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    def _shutdown_thread(thread: threading.Thread, timeout: float) -> None:\n        \"\"\"The function \"_shutdown_thread\" attempts to join the specified thread within the specified timeout. If joining the thread fails, it logs a warning and sets the thread's daemon attribute to True.", "CodeBleu_score": 12.824391455540136}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(\n            EVENT_SETUP_PENDING,\n            {\n                ATTR_SETUP_PENDING:\n                    True\n                    if remaining_with_setup_started\n                    else False,\n                ATTR_SETUP_PENDING_COUNT:\n                    len(remaining_with_setup_started)\n                    if remaining_with_setup_started\n                    else 0,\n            },\n        )\n        self._previous_was_empty = False\n    else:\n        self._previous_was_empty = True\n\n    def _async_start_watch(self) -> None:\n        \"\"\"Start watching for setups that are pending.\"\"\"\n        if self._handle is not None:\n            return\n\n        self._handle = self._loop.call_later(\n            SLOW_STARTUP_CHECK_INTERVAL,\n            self._async_watch,\n        )\n\n    def _async_stop_watch(self) -> None:\n        \"\"\"Stop watching for setups that are pending.\"\"\"\n        if self._handle is None:\n            return\n\n        self._handle.cancel()\n        self._handle = None\n\n    def _async_add_setup_pending(self, integration_group: tuple[str, str | None]) -> None:\n        \"\"\"Add a setup that is pending.\"\"\"\n        self._setup_started[integration_group] = monotonic()\n        self._async_start_watch()\n\n    def _async_remove_setup_pending(self, integration_group: tuple[str, str | None]) -> None:\n        \"\"\"Remove a setup that is pending.\"\"\"\n        self._setup_started.pop(integration_group, None)\n        if not self._setup_started:\n            self._async_stop_watch()\n\n    def _async_reset_setup_pending(self) -> None:\n        \"\"\"Reset the setups that are pending.\"\"\"\n        self._setup_started.clear()\n        self._async_stop_watch()\n\n", "CodeBleu_score": 58.539385221143355}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(\n            EVENT_HOMEASSISTANT_STARTUP,\n            {\n                ATTR_SETUP_PENDING:\n                    {domain: round(duration, 2) for domain, duration in remaining_with_setup_started.items()},\n            },\n        )\n        self._previous_was_empty = False\n\n    def _async_start_watching(self) -> None:\n        \"\"\"Start watching for setups that are pending.\"\"\"\n        if self._handle is not None:\n            return\n\n        self._handle = self._loop.call_later(\n            SLOW_STARTUP_CHECK_INTERVAL,\n            self._async_watch,\n        )\n\n    def _async_stop_watching(self) -> None:\n        \"\"\"Stop watching for setups that are pending.\"\"\"\n        if self._handle is None:\n            return\n\n        self._handle.cancel()\n        self._handle = None\n\n", "CodeBleu_score": 58.09403406625907}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.bus.async_fire(\n            EVENT_SETUP_PENDING,\n            {\"remaining\": remaining_with_setup_started},\n        )\n        self._previous_was_empty = False\n\n\n def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatch\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 64.1209603010595}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t    generated = generate_and_validate(integrations)\n    if config.skip_integrations:\n        current = config.cache.get(\"bluetooth.py\")\n        if current!= generated:\n            config.cache[\"bluetooth.py\"] = generated\n            config.error(\n                \"bluetooth.py is not up to date\",\n                fixable=True,\n                fix_suggestion=\"Run `script/gen_bluetooth`\",\n                obj=integrations,\n            )\n    else:\n        config.cache[\"bluetooth.py\"] = generated\n\n", "CodeBleu_score": 41.15074397237861}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t    # Generate and validate bluetooth data\n    generated = generate_and_validate(integrations)\n\n    # Get current content of bluetooth.py\n    current = config.cache.get(\"bluetooth.py\")\n\n    # If current content is not None, compare it with generated content\n    if current is not None:\n        if current!= generated:\n            config.cache[\"bluetooth.py\"] = generated\n            config.error(\n                \"bluetooth.py is not up to date\",\n                fixable=True,\n                fix_suggestion=\"\"\"", "CodeBleu_score": 35.922647094182146}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Validate the generated content\n    generated_content = generate_and_validate(integrations)\n\n    # Check if specific integrations are being validated\n    if config.integrations:\n        # Read the current content of bluetooth.py\n        with open(config.path(\"bluetooth.py\"), \"r\", encoding=\"utf-8\") as f:\n            current_content = f.read()\n\n        # Compare the generated content with the current content\n        if generated_content!= current_content:\n            # Add an error to the configuration indicating that bluetooth.py is not up to date\n            config.error(\n                \\\"bluetooth.py is not up to date\\\",\n                fixable=True,\n                suggestion=f\\\"Run `python3 -m script.hassfest generate {config.path()}` to update bluetooth.py.\\\",\n            )\n    else:\n        # Store the generated content in the configuration cache\n        config.cache[\"bluetooth.py\"] = generated_content\n\n\n\n\n", "CodeBleu_score": 43.71448949526472}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 89.11988518562453}, {"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t\t\"redirect_uri\":  \"https://cloudoauth.files.casaos.app\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 82.74252026858402}, {"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 89.11988518562453}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t e base.TokenError\n\tvar res *resty.Response\n\tvar err error\n\tvar body []byte\n\tif callback!= nil {\n\t\tres, err = base.RestyClient.R().SetResult(resp).SetError(&e).SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken).SetQueryParams(map[string]string{\\\"supportsAllDrives\\\": \\\"true\\\", \\\"includeItemsFromAllDrives\\\": \\\"true\\\"}).SetBody(callback()).Execute(method, url)\n\t} else {\n\t\tres, err = base.RestyClient.R().SetResult(resp).SetError(&e).SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken).SetQueryParams(map[string]string{\\\"supportsAllDrives\\\": \\\"true\\\", \\\"includeItemsFromAllDrives\\\": \\\"true\\\"}).Execute(method, url)\n\t}\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif e.Error!= \\\"\\\" {\n\t\tif e.Error == \\\"invalid_grant\\\" {\n\t\t\tif err := d.refreshToken(); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(e.Error)\n\t}\n\tbody, err = res.Body()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}", "CodeBleu_score": 47.414620060417775}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\td.AccessToken == \"\" {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treq := base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq = base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\t\tif callback!= nil {\n\t\t\tcallback(req)\n\t\t}\n\t\tres, err = req.Execute(method, url)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif resp!= nil {\n\t\tif err := res.Error(resp); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 59.16089136102695}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t e TokenError\n\tvar res *resty.Response\n\tvar err error\n\tfor i := 0; i < 3; i++ {\n\t\tif d.AccessToken == \\\"\\\" {\n\t\t\tif err = d.refreshToken(); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tres, err = base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken).\n\t\t\tSetQueryParam(\\\"supportsAllDrives\\\", \\\"true\\\").SetQueryParam(\\\"includeItemsFromAllDrives\\\", \\\"true\\\").\n\t\t\tSetError(&e).SetResult(resp).Execute(method, url)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif e.Error!= \\\"\\\" {\n\t\t\tif e.Error == \\\"invalid_grant\\\" {\n\t\t\t\tif err = d.refreshToken(); err!= nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(e.Error)\n\t\t}\n\t\tif callback!= nil {\n\t\t\tif err = callback(res); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\tif res == nil {\n\t\treturn nil, fmt.Errorf(\\\"request failed\\\")\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 44.60420631595872}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\team.Size()\n\tchunkSize := 5 * 1024 * 1024\n\tif size < chunkSize {\n\t\tchunkSize = size\n\t}\n\tvar offset int64 = 0\n\tvar err error\n\tfor offset < size {\n\t\tend := offset + chunkSize\n\t\tif end > size {\n\t\t\tend = size\n\t\t}\n\t\tvar resp UploadResp\n\t\tvar e Error\n\t\t_, err = d.request(url, http.MethodPut, func(req *resty.Request) {\n\t\t\treq.SetHeader(\\\"Content-Length\\\", strconv.FormatInt(end-offset, 10))\n\t\t\treq.SetHeader(\\\"Content-Range\\\", fmt.Sprintf(\\\"bytes %d-%d/%d\\\", offset, end-1, size))\n\t\t\treq.SetBody(stream)\n\t\t}, &resp)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif e.Error.Code!= 0 {\n\t\t\treturn fmt.Errorf(\\\"%s: %v\\\", e.Error.Message, e.Error.Errors)\n\t\t}\n\t\toffset = end\n\t\tif err = ctx.Err(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.25924310476087}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t size\n\tfileSize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// get chunk size\n\tchunkSize := 256 * 1024 * 1024\n\tif fileSize < chunkSize {\n\t\tchunkSize = int(fileSize)\n\t}\n\t// upload in chunks\n\tfor offset := int64(0); offset < fileSize; offset += int64(chunkSize) {\n\t\t// check context\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\t// get chunk size\n\t\tchunkSize := chunkSize\n\t\tif offset+int64(chunkSize) > fileSize {\n\t\t\tchunkSize = int(fileSize - offset)\n\t\t}\n\t\t// upload chunk\n\t\t_, err = d.request(url, http.MethodPut, func(req *resty.Request) {\n\t\t\treq.SetHeader(\\\"Content-Range\\\", fmt.Sprintf(\\\"bytes %d-%d/%d\\\", offset, offset+int64(chunkSize)-1, fileSize))\n\t\t\treq.SetHeader(\\\"Content-Length\\\", strconv.Itoa(chunkSize))\n\t\t\treq.SetHeader(\\\"Content-Type\\\", \\\"application/octet-stream\\\")\n\t\t\treq.SetBody(io.LimitReader(stream, int64(chunkSize)))\n\t\t}, nil)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.968317136525854}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t size\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// get file name\n\tname, err := stream.Name()\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// get file mime type\n\tmimeType, err := stream.MimeType()\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// get file content\n\tcontent, err := stream.Content()\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// calculate chunk size\n\tchunkSize := 256 * 1024 * 1024\n\tif size < chunkSize {\n\t\tchunkSize = size\n\t}\n\t// create a new upload session\n\tvar uploadSession UploadSession\n\t_, err = d.request(url, http.MethodPost, nil, &uploadSession)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// upload chunks\n\tvar offset int64\n\tfor offset < size {\n\t\t// check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\t// calculate chunk size\n\t\tchunkSize := size - offset\n\t\tif chunkSize > 256*1024*1024 {\n\t\t\tchunkSize = 256 * 1024 * 1024\n\t\t}\n\t\t// upload chunk\n\t\tchunk := content[offset : offset+chunkSize]\n\t\tvar resp UploadChunkResp\n\t\t_, err = d.request(uploadSession.UploadURL, http.MethodPut, func(req *resty.Request) {\n\t\t\treq.SetHeader(\"Content-Length\", strconv.FormatInt(chunkSize, 10))\n\t\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+chunkSize-1, size))\n\t\t\treq.SetBody(chunk)\n\t\t}, &resp)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// update offset\n\t\toffset += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.84983730249245}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR)})\n\t}\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DeleteConfig(req.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 65.74027354407161}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t req httper.MountPoint\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount point is empty\"})\n\t}\n\n\tif err := service.MyService.Storage().Umount(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfig(req.Fs); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 68.70463590466812}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.MountPointReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t}\n\tif err := service.MyService.Storage().Umount(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\tif err := service.MyService.Storage().DeleteConfig(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 71.0431019628437}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u8bfb\u53d6\u6587\u4ef6\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tdefer file.Close()\n\t// \u8bbe\u7f6e\u5934\u4fe1\u606f\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\\\"\"+filepath.Base(filePath)+\"\\\"\")\n\tctx.Response().Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Response().Header().Set(\"Content-Length\", strconv.FormatInt(file.Size(), 10))\n\t// \u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\n\t_, err = io.Copy(ctx.Response(), file)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.34439262138187}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\tif err := service.Notify(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tCode: 200,\n\t\tMsg:  \"success\",\n\t})\n}", "CodeBleu_score": 58.64381103067655}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.Err(common_err.InvalidParams, err.Error()))\n\t}\n\tif err := service.NotifyService.SendMessage(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.Err(common_err.ServerErr, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, model.CommonResponse{\n\t\tCode:    0,\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 58.650799337081835}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err))\n\t}\n\tif err := service.Notify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tCode:    0,\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 62.232883294184106}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tservice.AddConn(conn)\n\tdefer service.RemoveConn(conn)\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(\"messageType:\", messageType)\n\t\tfmt.Println(\"message:\", string(message))\n\t\tfmt.Println(\"err:\", err)\n\t}\n}", "CodeBleu_score": 38.199626189272124}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\ttoken := ctx.Param(\"token\")\n\tif token == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"token is empty\")\n\t}\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\tdefer conn.Close()\n\tservice.NotifyAdd(conn)\n\tfor {\n\t\tmsgType, msg, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"notify msgType:\", msgType, \"msg:\", string(msg), \"err:\", err)\n\t}\n\tservice.NotifyRemove(conn)\n\treturn nil\n}", "CodeBleu_score": 39.020572123799866}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection.\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, types.Error{Message: err.Error()})\n\t}\n\t// Add the new WebSocket connection to a list of connections.\n\tservice.AddConnection(conn)\n\t// Ensure that the message sending service is running.\n\tgo service.NotifyService()\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read the message type, message, and any errors.\n\t\tmsgType, msg, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Printf(\"Message type: %d\n\", msgType)\n\t\tfmt.Printf(\"Message: %s\n\", msg)\n\t\tfmt.Println(err)\n\t}\n}", "CodeBleu_score": 35.368123011749866}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system architecture\n\tarch := runtime.GOARCH\n\t// Get the drive model\n\tdrive := gjson.Get(utils.GetSystemInfo(), \"model\").String()\n\t// Get the CPU information\n\tcpuInfo := service.MyService.System().GetCPUInfo()\n\tif cpuInfo!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\"arch\": arch, \"drive\": drive, \"cpu\": cpuInfo}})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\"arch\": arch, \"drive\": drive}})\n}", "CodeBleu_score": 36.78245875985168}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get drive model and architecture\n\tdriveModel := service.MyService.System().GetDriveModel()\n\tdriveArchitecture := service.MyService.System().GetDriveArchitecture()\n\n\t// Get CPU information\n\tcpuInfo := service.MyService.System().GetCPUInfo()\n\n\t// If CPU information is available, return it with a success message\n\tif cpuInfo!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\"drive_model\": driveModel, \"drive_architecture\": driveArchitecture, \"cpu_info\": cpuInfo}})\n\t}\n\n\t// If CPU information is not available, return \"nil\"\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\"drive_model\": driveModel, \"drive_architecture\": driveArchitecture, \"cpu_info\": nil}})\n}", "CodeBleu_score": 35.10242625550589}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system information\n\tsys := service.MyService.System().GetSysInfo()\n\n\t// Get the CPU information\n\tcpu, err := cpu.Info()\n\tif err!= nil {\n\t\t// If the CPU information is not available, return nil\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n\t}\n\n\t// Create a map to hold the hardware information\n\thardwareInfo := make(map[string]interface{})\n\n\t// Add the drive model to the hardware information map\n\thardwareInfo[\\\"model\\\"] = sys.Model\n\n\t// Add the architecture to the hardware information map\n\thardwareInfo[\\\"architecture\\\"] = sys.Architecture\n\n\t// Add the CPU information to the hardware information map\n\thardwareInfo[\\\"cpu\\\"] = cpu\n\n\t// Return the hardware information map as a JSON response\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: hardwareInfo})\n}", "CodeBleu_score": 38.27561239108084}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 73.14584607547667}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tvar running []string\n\tvar notRunning []string\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.60621010244697}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif systemctl.IsServiceRunning(service) {\n\t\t\trunning = append(running, service)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 65.67707460047025}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonStr, err := json2.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t}\n\terr = common.EventBus.Publish(name, string(jsonStr))\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t}\n}", "CodeBleu_score": 26.012653019938618}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tfor k, v := range message {\n\t\tmessage[k], _ = json2.Marshal(v)\n\t}\n\n\terr := common.Notify.Publish(name, message)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t}\n}", "CodeBleu_score": 24.246394448018975}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings\n\tmessageBytes, err := json2.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Sugar.Errorf(\\\"failed to serialize message values to JSON: %v\\\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to a message bus\n\terr = common.EventBus.Publish(name, messageBytes)\n\tif err!= nil {\n\t\tlogger.Sugar.Errorf(\\\"failed to publish event to message bus: %v\\\", err)\n\t}\n\n\t// Log any errors that occur during publishing\n\tif err!= nil {\n\t\tlogger.Sugar.Errorf(\\\"failed to publish event to message bus: %v\\\", err)\n\t}\n\n\t// If the response status code is not OK, log the failure along with the response details\n\tif resp.StatusCode!= http.StatusOK {\n\t\tlogger.Sugar.Errorf(\\\"failed to send notification: %v\\\", resp.Status)\n\t}\n}", "CodeBleu_score": 40.65427920610158}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tclient := message_bus.NewClientWithResponses()\n\taddress, err := config.GetMessageBusAddress(c.gateway)\n\tif err!= nil {\n\t\tclient.SetServer(\"Error: \" + err.Error())\n\t} else {\n\t\tclient.SetServer(address)\n\t}\n\treturn client\n}", "CodeBleu_score": 28.02486917227265}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tclient := message_bus.NewClientWithResponses()\n\n\taddress := config.GetMessageBusAddress(c.gateway)\n\tif address!= \"\" {\n\t\tclient.Server = address\n\t} else {\n\t\tclient.Server = \"MessageBus is not found\"\n\t}\n\n\treturn client\n}", "CodeBleu_score": 29.76896408327979}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tclient := message_bus.NewClientWithResponses()\n\taddress := config.GetMessageBusAddress(c.gateway)\n\tif len(address) > 0 {\n\t\tclient.Server = address\n\t} else {\n\t\tclient.Server = \"message bus not found\"\n\t}\n\treturn client\n}", "CodeBleu_score": 28.930690520801495}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) > 0 {\n\t\tip = strings.Split(ip, \",\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 70.84680771795384}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) > 0 {\n\t\treturn strings.Split(ip, \",\")[0]\n\t}\n\tip = request.RemoteAddr\n\tif len(ip) > 0 {\n\t\treturn strings.Split(ip, \":\")[0]\n\t}\n\treturn \"\"\n}", "CodeBleu_score": 34.45827892250754}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) > 0 {\n\t\treturn strings.Split(ip, \",\")[0]\n\t}\n\tip = request.RemoteAddr\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 46.88661917589138}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\todulePath := config.AppInfo.ModulePath\n\tentryFilePath := modulePath + \\\"/entry.json\\\"\n\tif!file.IsExist(entryFilePath) {\n\t\terr := file.WriteFile(entryFilePath, \\\"[]\\\")\n\t\tif err!= nil {\n\t\t\tlogger.Sugar.Error(err)\n\t\t}\n\t}\n\tvar entry []byte\n\tentry = append(entry, \\\"[\\\"...)\n\tdir, err := os.Open(modulePath)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n\tdefer dir.Close()\n\tfiles, err := dir.Readdir(0)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n\tfor _, f := range files {\n\t\tif f.IsDir() {\n\t\t\tentryFile := modulePath + \\\"/\\\" + f.Name() + \\\"/entry.json\\\"\n\t\t\tif file.IsExist(entryFile) {\n\t\t\t\tcontent, err := file.ReadFullFile(entryFile)\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlogger.Sugar.Error(err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tentry = append(entry, content...)\n\t\t\t\tentry = append(entry, \\\",\\\"...)\n\t\t\t}\n\t\t}\n\t}\n\tentry = append(entry, \\\"]\\\"...)\n\terr = file.WriteFile(entryFilePath, entry)\n\tif err!= nil {\n\t\tlogger.Sugar.Error(err)\n\t}\n}", "CodeBleu_score": 43.90958683819608}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\todulesDir := filepath.Join(config.AppInfo.ModulesPath, \\\"modules\\\")\n\tentryFile := filepath.Join(modulesDir, \\\"entry.json\\\")\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(modulesDir, 0755); err!= nil {\n\t\t\tlogger.Sugar.Errorf(\\\"failed to create modules directory: %v\\\", err)\n\t\t\treturn\n\t\t}\n\t\tif err := os.WriteFile(entryFile, []byte(\\\"[]\\\"), 0644); err!= nil {\n\t\t\tlogger.Sugar.Errorf(\\\"failed to create entry file: %v\\\", err)\n\t\t\treturn\n\t\t}\n\t}\n\tentries := []byte(\\\"[]\\\")\n\tif err := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err!= nil {\n\t\t\tlogger.Sugar.Errorf(\\\"failed to walk modules directory: %v\\\", err)\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Base(path)!= \\\"entry.json\\\" {\n\t\t\treturn nil\n\t\t}\n\t\tentry, err := os.ReadFile(path)\n\t\tif err!= nil {\n\t\t\tlogger.Sugar.Errorf(\\\"failed to read entry file: %v\\\", err)\n\t\t\treturn err\n\t\t}\n\t\tentries = append(entries, entry...)\n\t\treturn nil\n\t}); err!= nil {\n\t\tlogger.Sugar.Errorf(\\\"failed to walk modules directory: %v\\\", err)\n\t\treturn\n\t}\n\tif err := os.WriteFile(entryFile, entries, 0644); err!= nil {\n\t\tlogger.Sugar.Errorf(\\\"failed to write entry file: %v\\\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 34.992929387768456}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\todulesPath := filepath.Join(config.AppInfo.RootPath, \\\"modules\\\")\n\tentryPath := filepath.Join(modulesPath, \\\"entry.json\\\")\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(modulesPath, 0755); err!= nil {\n\t\t\tlogger.Sugar.Errorw(\\\"create modules dir failed\\\", \\\"err\\\", err)\n\t\t\treturn\n\t\t}\n\t\tif err := file.WriteFullFile(entryPath, []byte(\\\"[]\\\")); err!= nil {\n\t\t\tlogger.Sugar.Errorw(\\\"create entry file failed\\\", \\\"err\\\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tdirs, err := os.ReadDir(modulesPath)\n\tif err!= nil {\n\t\tlogger.Sugar.Errorw(\\\"read modules dir failed\\\", \\\"err\\\", err)\n\t\treturn\n\t}\n\n\tvar entry []byte\n\tfor _, dir := range dirs {\n\t\tif!dir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tentryFile := filepath.Join(modulesPath, dir.Name(), \\\"entry.json\\\")\n\t\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t\tcontinue\n\t\t}\n\t\tcontent, err := file.ReadFullFile(entryFile)\n\t\tif err!= nil {\n\t\t\tlogger.Sugar.Errorw(\\\"read entry file failed\\\", \\\"err\\\", err)\n\t\t\tcontinue\n\t\t}\n\t\tentry = append(entry, content...)\n\t}\n\n\tif err := file.WriteFullFile(entryPath, entry); err!= nil {\n\t\tlogger.Sugar.Errorw(\\\"write entry file failed\\\", \\\"err\\\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.3654440227264}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\tnets := MyService.System().GetNet(true)\n\tfor _, i := range ifaces {\n\t\tfor _, n := range nets {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \\\"\\\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 63.60485214635193}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tnets, err := MyService.System().GetNet(true)\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range nets {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 64.5136796729126}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\tnetNames, err := MyService.System().GetNet(false)\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\tfor _, netName := range netNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \\\"\\\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 54.77736456924539}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t res = TSDB_CODE_SUCCESS;\n\tint32_t refId = -1;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tres = TSDB_CODE_INVALID_PARAMETER;\n\t\treturn res;\n\t}\n\n\trefId = addRef(pRequest, clientReqRefPool);\n\tif (refId < 0) {\n\t\tres = TSDB_CODE_NO_REF;\n\t\treturn res;\n\t}\n\n\tpRequest->refId = refId;\n\n\tpRequest->tsc = pTscObj;\n\tpTscObj->reqCount++;\n\n\tif (pTscObj->appInfo.appName[0]!= 0) {\n\t\tpTscObj->appInfo.reqCount++;\n\t\tpTscObj->appInfo.curReqCount++;\n\t}\n\n\tif (tscDbg.req) {\n\t\tLOG(G_LOG_INFO, \"registerRequest: %s, reqId=%d, refId=%d, tsc=%p, reqCount=%d, curReqCount=%d\", pTscObj->appInfo.appName, pRequest->reqId, refId, pTscObj, pTscObj->reqCount, pTscObj->appInfo.curReqCount);\n\t}\n\n\treturn res;\n}", "CodeBleu_score": 41.76725722668221}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\ttrefAdd(pRequest);\n\tpTscObj->requestCount++;\n\tif (pTscObj->pAppInfo) {\n\t\tpTscObj->pAppInfo->requestCount++;\n\t\tpTscObj->pAppInfo->currentRequestCount++;\n\t}\n\tif (tscDbg.request) {\n\t\tlog_info(\"Register request %p\", pRequest);\n\t}\n\treturn rc;\n}", "CodeBleu_score": 21.542423708592008}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->dbList!= NULL) {\n\t\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\t\tchar* dot = strchr(db, '.');\n\t\t\tif (dot!= NULL) {\n\t\t\t\tdb = dot + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 68.91343540538669}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->dbList!= NULL) {\n\t\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\t\tchar* dot = strchr(db, '.');\n\t\t\tif (dot!= NULL) {\n\t\t\t\tdb = dot + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 68.91343540538669}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->dbList!= NULL) {\n\t\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\t\tchar* dot = strchr(db, '.');\n\t\t\tif (dot!= NULL) {\n\t\t\t\tdb = dot + 1;\n\t\t\t}\n\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 73.26333010473331}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_REDIRECT && msgType!= TSC_MSG_QUERY_REQ && msgType!= TSC_MSG_QUERY_ASYNC_REQ && msgType!= TSC_MSG_QUERY_ASYNC_RESP && msgType!= TSC_MSG_QUERY_ASYNC_RESP_ACK) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 33.536108182898346}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_REDIRECT) {\n\t\tswitch (msgType) {\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_BATCH:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BATCH:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_BATCH_AND_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BATCH_AND_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_BATCH_AND_TIMEOUT_AND_PRIORITY:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BATCH_AND_TIMEOUT_AND_PRIORITY:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_TIMEOUT_AND_PRIORITY:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_TIMEOUT_AND_PRIORITY:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_BATCH_AND_TIMEOUT_AND_PRIORITY_AND_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BATCH_AND_TIMEOUT_AND_PRIORITY_AND_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_TIMEOUT_AND_PRIORITY_AND_TIMEOUT:\n\t\t\tcase TSDB_MSG_TYPE_QUERY_SQL_WITH_BINDINGS_AND_TIMEOUT_AND_PRIORITY_AND_TIMEOUT:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.37269543096304}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\tqueryStop(pRequest->pQuery);\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 77.60681820616921}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\tstopQuery(pRequest->pQuery);\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 77.77533421090274}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\tstopQuery(pRequest->pQuery);\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 77.77533421090274}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0)) {\n\t\ttscInfo(\"crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop == 0) {\n\t\ttaosMsleep(100);\n\t}\n}", "CodeBleu_score": 66.59941299959317}, {"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0)!= 0) {\n\t\ttscError(\"crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (clientStop!= 0) {\n\t\ttaosMsleep(10);\n\t}\n}", "CodeBleu_score": 64.12124293055396}, {"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0)) {\n\t\ttscInfo(\"crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop!= 0) {\n\t\ttaosMsleep(100);\n\t}\n}", "CodeBleu_score": 66.5675501905075}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\treturn -1;\n\t}\n\n\tint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n\tfor (int32_t i = 0; i < numOfMeta; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pMetaRsp);\n\thbRsp.pMetaRsp = NULL;\n\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 76.2781409178207}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\treturn -1;\n\t}\n\n\tint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n\tfor (int32_t i = 0; i < numOfMeta; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tif (rsp->pSchemas[0].colId!= PRIMARYKEY_TIMESTAMP_COL_ID) {\n\t\t\t\ttscError(\"invalid colId[%\\\" PRIi16 \\\"] for the first column in table meta rsp msg\", rsp->pSchemas[0].colId);\n\t\t\t\ttFreeSViewHbRsp(&hbRsp);\n\t\t\t\treturn TSDB_CODE_TSC_INVALID_VALUE;\n\t\t\t}\n\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pMetaRsp);\n\thbRsp.pMetaRsp = NULL;\n\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 76.0661295832719}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\treturn -1;\n\t}\n\n\tint32_t numOfMeta = taosArrayGetSize(hbRsp.pViewRsp);\n\tfor (int32_t i = 0; i < numOfMeta; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pViewRsp, i);\n\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pViewRsp);\n\thbRsp.pViewRsp = NULL;\n\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 77.78398426979074}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t//  (void)callbackData;\n  TS3GetData *data = (TS3GetData *)callbackData;\n  data->content_length = properties->contentLength;\n  return S3StatusOK;\n}", "CodeBleu_score": 50.741090079152386}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3GetData *data = (TS3GetData *)callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->content_length = properties->contentLength;\n\t} else {\n\t\tdata->content_length = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 77.19963081371093}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3GetData *data = (TS3GetData *)callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->content_length = properties->contentLength;\n\t} else {\n\t\tdata->content_length = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 77.19963081371093}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tdef WINDOWS\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#else\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#endif\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s%s\", tsCheckpointBackupDir, \"rsyncd.conf\");\n\n  if (generateConfigFile(confDir)!= 0) {\n    uError(\"[rsync] generate config file error, dir:%s\", confDir);\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --port=%d --config=%s\", tsRsyncPort, confDir);\n#else\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --port=%d --config=%s\", tsRsyncPort, confDir);\n#endif\n\n  int32_t code = execCommand(command);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server error, command:%s,\" ERRNO_ERR_FORMAT, command, ERRNO_ERR_DATA);\n    return;\n  } else {\n    uDebug(\"[rsync] start rsync server successful, command:%s\", command);\n  }\n}", "CodeBleu_score": 61.670462383120295}, {"code": "void startRsync(){\n\tt32_t code = taosMkdir(tsCheckpointBackupDir);\n\tif (code!= 0) {\n\t\tuError(\"[rsync] create checkpoint backup directory failed,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n\t\treturn;\n\t}\n\n\tremoveEmptyDir();\n\n\tchar confDir[PATH_MAX] = {0};\n\tsnprintf(confDir, PATH_MAX, \"%s/rsyncd.conf\", tsCheckpointBackupDir);\n\tif (generateConfigFile(confDir)!= 0) {\n\t\treturn;\n\t}\n\n\tchar command[PATH_MAX] = {0};\n\tsnprintf(command, PATH_MAX, \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n\tcode = execCommand(command);\n\tif (code == 0) {\n\t\tuDebug(\"[rsync] start rsync server successful\");\n\t} else {\n\t\tuError(\"[rsync] start rsync server failed,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n\t}\n}", "CodeBleu_score": 60.74975020637139}, {"code": "void startRsync(){\n\tdef WINDOWS\n  if (tsCheckpointBackupDir[1]!= ':') {\n    uError(\"[rsync] checkpoint backup dir is not valid, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n#endif\n\n  if (taosMkdir(tsCheckpointBackupDir, 0755)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir)!= 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char command[PATH_MAX] = {0};\n  snprintf(command, PATH_MAX, \"rsync --daemon --port=%d --config=%s\", tsCheckpointRsyncPort, confDir);\n  uDebug(\"[rsync] command:%s\", command);\n  int32_t code = execCommand(command);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 70.37567046701724}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher dispatcher = dispatchers.remove(dispatcherId);\nif (dispatcher == null) {\nthrow new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n}\ndispatcher.shutdown();\n}", "CodeBleu_score": 68.6747408100418}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher dispatcher = dispatchers.remove(dispatcherId);\nif (dispatcher == null) {\nthrow new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n}\ndispatcher.shutdown();\n}", "CodeBleu_score": 68.6747408100418}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher dispatcher = dispatchers.remove(dispatcherId);\nif (dispatcher!= null) {\ndispatcher.shutdownNow();\n} else {\nthrow new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n}\n}", "CodeBleu_score": 72.22989471020381}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.get(parent);\n if (children == null) {\n log.warn(\\\"No children for parent [{}]!\\\", parent);\n return;\n }\n List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox == null) {\n log.warn(\\\"Child [{}] is not registered!\\\", child);\n continue;\n }\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n }\n }", "CodeBleu_score": 43.511174203436454}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.get(parent);\n if (children!= null) {\n List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox == null) {\n log.warn(\"Child actor with id [{}] is not registered!\", child);\n } else {\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n }\n }\n }\n }", "CodeBleu_score": 45.150504750760774}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.get(parent);\n if (children!= null) {\n List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n TbActorMailbox childMailbox = actors.get(child);\n if (childMailbox!= null) {\n if (highPriority) {\n childMailbox.tellWithHighPriority(msg);\n } else {\n childMailbox.tell(msg);\n }\n } else {\n log.warn(\"Child actor with id [{}] is not registered!\", child);\n }\n }\n }\n }", "CodeBleu_score": 44.694142824980084}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (!destroyInProgress.get()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n} else if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\nif (ready.get()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n} else {\nif (stopReason == TbActorStopReason.INIT_FAILED) {\nlog.info(\"[{}] Actor is stopped due to init failure, going to reinitialize.\", selfId);\nstopReason = null;\nready.set(NOT_READY);\ntryInit(1);\n} else {\nlog.info(\"[{}] Actor is stopped, going to notify message.\", selfId);\nmsg.notify(this);\n}\n}\n} else {\nlog.info(\"[{}] Actor is stopped, going to notify message.\", selfId);\nmsg.notify(this);\n}\n}", "CodeBleu_score": 61.93829686776214}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (destroyInProgress.get()) {\nif (highPriority && msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\nif (!ready.get()) {\nlog.debug(\"[{}] Received RULE_NODE_UPDATED_MSG while destroying actor, going to reinit actor\", selfId);\ntryInit(1);\n} else {\nlog.debug(\"[{}] Received RULE_NODE_UPDATED_MSG while destroying actor, actor is already destroyed\", selfId);\n}\n} else {\nlog.debug(\"[{}] Received message while destroying actor, going to notify message\", selfId);\nmsg.notify(new TbActorException(new TbActorError(selfId, \"Actor is stopped\", true)));\n}\n} else {\nlog.debug(\"[{}] Enqueueing message {}\", selfId, msg);\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n}\n}", "CodeBleu_score": 52.44680016799826}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (!destroyInProgress.get()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n} else if (msg.getType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\nif (ready.get()) {\nlog.debug(\"[{}] Re-initializing actor after destruction\", selfId);\nready.set(NOT_READY);\ninitActor();\n} else {\nlog.debug(\"[{}] Actor is not ready, skipping re-initialization\", selfId);\n}\n} else {\nlog.debug(\"[{}] Actor is being destroyed, skipping message\", selfId);\nmsg.notifyFailure(new TbActorException(TbActorError.ACTOR_STOPPED, selfId, stopReason));\n}\n}", "CodeBleu_score": 55.563541722879584}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\tt throughput = settings.getMaxActorThroughput();\n\twhile (throughput > 0) {\n\t\tTbActorMsg msg = highPriorityMsgs.poll();\n\t\tif (msg == null) {\n\t\t\tmsg = normalPriorityMsgs.poll();\n\t\t\tif (msg == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tactor.process(msg);\n\t\t\tthroughput--;\n\t\t} catch (Throwable t) {\n\t\t\tif (isUnrecoverable(t)) {\n\t\t\t\tstopReason = TbActorStopReason.PROCESS_FAILED;\n\t\t\t\tdestroy(t.getCause());\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tlog.debug(\"[{}] Failed to process message: {}\", selfId, msg, t);\n\t\t\t\tProcessFailureStrategy strategy = actor.onProcessFailure(msg, t);\n\t\t\t\tif (strategy.isStop()) {\n\t\t\t\t\tlog.info(\"[{}] Failed to process message: {}, going to stop attempts.\", selfId, msg, t);\n\t\t\t\t\tstopReason = TbActorStopReason.PROCESS_FAILED;\n\t\t\t\t\tdestroy(t.getCause());\n\t\t\t\t\treturn;\n\t\t\t\t} else if (strategy.getRetryDelay() > 0) {\n\t\t\t\t\tlog.info(\"[{}] Failed to process message: {}, going to retry in attempts in {}ms\", selfId, msg, strategy.getRetryDelay(), t);\n\t\t\t\t\tsystem.getScheduler().schedule(() -> enqueue(msg, strategy.isHighPriority()), strategy.getRetryDelay(), TimeUnit.MILLISECONDS);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tlog.info(\"[{}] Failed to process message: {}, going to retry immediately\", selfId, msg, t);\n\t\t\t\t\tenqueue(msg, strategy.isHighPriority());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbusy.set(FREE);\n\tsystem.getScheduler().schedule(this::tryProcessQueue, 1, TimeUnit.MILLISECONDS);\n}", "CodeBleu_score": 48.76648611882109}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.DESTROYED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\tready.set(NOT_READY);\n\t\ttry {\n\t\t\tactor.destroy(stopReason, cause);\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"Failed to destroy actor: \" + selfId, t);\n\t\t}\n\t\twhile (true) {\n\t\t\tTbActorMsg msg = highPriorityMsgs.poll();\n\t\t\tif (msg == null) {\n\t\t\t\tmsg = normalPriorityMsgs.poll();\n\t\t\t}\n\t\t\tif (msg!= null) {\n\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n}", "CodeBleu_score": 60.219393410242915}, {"code": "public void destroy(Throwable cause){\n\t\tif (!destroyInProgress.get()) {\n\t\tdestroyInProgress.set(true);\n\t\tstopReason = stopReason!= null? stopReason : TbActorStopReason.UNKNOWN;\n\t\tdispatcher.getExecutor().execute(() -> {\n\t\t\ttry {\n\t\t\t\tready.set(NOT_READY);\n\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t\tnotifyStop();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\"Failed to destroy actor: {}\", selfId, t);\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 51.34520777770165}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.DESTROYED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nTbActorMsg msg;\nwhile ((msg = highPriorityMsgs.poll())!= null) {\nmsg.onTbActorStopped(stopReason);\n}\nwhile ((msg = normalPriorityMsgs.poll())!= null) {\nmsg.onTbActorStopped(stopReason);\n}\n} catch (Throwable t) {\nlog.warn(\\\"[{}] Failed to destroy actor\\\", selfId, t);\n}\n});\n}", "CodeBleu_score": 61.90070613361305}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t(tenantId.isNullUid()) {\nreturn true;\n}\nTenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId, ignoreTenantNotFound);\nif (tenantProfile == null) {\nreturn true;\n}\nRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\nif (rateLimitConfiguration == null) {\nreturn true;\n}\nRateLimitKey key = new RateLimitKey(api, tenantId, level);\nTbRateLimits rateLimits = this.rateLimits.get(key, k -> {\nRateLimitConfiguration.RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\nif (rateLimit == null) {\nreturn null;\n}\nreturn new TbRateLimits(rateLimit.getRate(), rateLimit.getTimeWindow());\n});\nif (rateLimits == null) {\nreturn true;\n}\nif (rateLimits.check()) {\nreturn true;\n}\nnotificationRuleProcessor.processRateLimitNotification(tenantId, api, rateLimits.getRate(), rateLimits.getTimeWindow(), level);\nreturn false;\n}", "CodeBleu_score": 46.1158379331806}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t(tenantId.isNullUid()) {\nreturn true;\n}\nTenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\nif (tenantProfile == null && ignoreTenantNotFound) {\nreturn true;\n}\nif (tenantProfile == null) {\nthrow new TenantProfileNotFoundException(tenantId);\n}\nRateLimitKey rateLimitKey = new RateLimitKey(api, tenantId, level);\nTbRateLimits rateLimits = this.rateLimits.get(rateLimitKey, (key) -> {\nRateLimitConfiguration configuration = tenantProfile.getRateLimitConfiguration();\nif (configuration == null) {\nreturn TbRateLimits.unlimited();\n}\nRateLimitConfiguration.LimitConfiguration limitConfiguration = configuration.getLimitConfiguration(api);\nif (limitConfiguration == null) {\nreturn TbRateLimits.unlimited();\n}\nreturn TbRateLimits.from(limitConfiguration);\n});\nboolean result = rateLimits.check();\nif (!result) {\nnotificationRuleProcessor.processRateLimitNotification(tenantId, api, level);\n}\nreturn result;\n}", "CodeBleu_score": 51.056658066603156}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t(tenantId.isNullUid()) {\nreturn true;\n}\nTenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId, ignoreTenantNotFound);\nif (tenantProfile == null) {\nreturn true;\n}\nRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\nif (rateLimitConfiguration == null) {\nreturn true;\n}\nRateLimitKey rateLimitKey = new RateLimitKey(api, tenantId, level);\nTbRateLimits rateLimits = this.rateLimits.get(rateLimitKey, key -> {\nRateLimitConfiguration.RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\nif (rateLimit!= null) {\nreturn new TbRateLimits(rateLimit.getRate(), rateLimit.getBurst());\n} else {\nreturn new TbRateLimits(0, 0);\n}\n});\nboolean result = rateLimits.check();\nif (!result) {\nnotificationRuleProcessor.processRateLimitNotification(tenantId, api, level);\n}\nreturn result;\n}", "CodeBleu_score": 47.629447430164504}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\nif (entry.getValue().getLastActivityTime() < expirationTime) {\nlog.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}] due to inactivity timeout\", entry.getKey(), entry.getValue().getLastActivityTime());\ndtlsSessionsMap.remove(entry.getKey());\n}\n}\n}", "CodeBleu_score": 54.904990383740696}, {"code": "public void evictTimeoutSessions(){\n\t\tlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n\tfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\n\t\t\tdtlsSessionsMap.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 55.34934229817448}, {"code": "public void evictTimeoutSessions(){\n\t\tlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n\tfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\n\t\t\tdtlsSessionsMap.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 55.34934229817448}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (!CollectionUtils.isEmpty(timeseries)) {\n\t\treturn timeseries.entrySet().stream().map(entry -> {\n\t\t\tList<KvEntry> values = entry.getValue().stream().map(value -> parseValue(entry.getKey(), value)).collect(Collectors.toList());\n\t\t\treturn new BasicTsKvEntry(entry.getKey(), values);\n\t\t}).collect(Collectors.toList());\n\t} else {\n\t\treturn Collections.emptyList();\n\t}\n}", "CodeBleu_score": 48.554661662432274}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!timeseries.isEmpty()) {\nList<TsKvEntry> tsKvEntries = new ArrayList<>();\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nList<KvEntry> kvEntries = new ArrayList<>();\nfor (JsonNode value : entry.getValue()) {\nkvEntries.add(parseValue(entry.getKey(), value));\n}\ntsKvEntries.add(new BasicTsKvEntry(entry.getKey(), kvEntries));\n}\nreturn tsKvEntries;\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 37.38063908527344}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (!CollectionUtils.isEmpty(timeseries)) {\n\t\treturn timeseries.entrySet().stream().map(entry -> {\n\t\t\tList<KvEntry> values = entry.getValue().stream().map(value -> {\n\t\t\t\tKvEntry kvEntry = parseValue(entry.getKey(), value);\n\t\t\t\tkvEntry.setTs(value.get(TS).asLong());\n\t\t\t\treturn kvEntry;\n\t\t\t}).collect(Collectors.toList());\n\t\t\treturn new BasicTsKvEntry(entry.getKey(), values);\n\t\t}).collect(Collectors.toList());\n\t} else {\n\t\treturn Collections.emptyList();\n\t}\n}", "CodeBleu_score": 51.543325653766736}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<>();\n\trequest.put(\"refreshToken\", refreshToken);\n\tResponseEntity<TokenResponse> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/token\\\", request, TokenResponse.class);\n\tupdateTokenInfo(System.currentTimeMillis(), response.getBody());\n}", "CodeBleu_score": 38.47288406899764}, {"code": "public void refreshToken(){\n\t\tMap<String, Object> request = new HashMap<>();\n\trequest.put(\"refreshToken\", refreshToken);\n\n\tString token = restTemplate.postForObject(baseURL + \\\"/api/auth/token\\\", request, String.class);\n\tupdateToken(token);\n}", "CodeBleu_score": 29.281843458171743}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", refreshToken);\n\tResponseEntity<String> response = loginRestTemplate.postForEntity(baseURL + \"/api/auth/token\", requestMap, String.class);\n\tupdateTokenInfo(System.currentTimeMillis(), response.getBody());\n}", "CodeBleu_score": 54.981444775789015}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t long ts = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 93.2272822614458}, {"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\tResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n\tsetTokenInfo(ts, tokenInfo.getBody());\n}", "CodeBleu_score": 92.5692922035692}, {"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\tResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n\tsetTokenInfo(ts, tokenInfo.getBody());\n}", "CodeBleu_score": 92.5692922035692}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\treturn Optional.ofNullable(device.getBody());\n\t} catch (HttpClientErrorException exception) {\n\t\tif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow exception;\n\t\t}\n\t}\n}", "CodeBleu_score": 88.51825307114592}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\treturn Optional.ofNullable(device.getBody());\n\t} catch (HttpClientErrorException exception) {\n\t\tif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow exception;\n\t\t}\n\t}\n}", "CodeBleu_score": 88.51825307114592}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\treturn Optional.ofNullable(device.getBody());\n\t} catch (HttpClientErrorException exception) {\n\t\tif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow exception;\n\t\t}\n\t}\n}", "CodeBleu_score": 88.51825307114592}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\t\tResponseEntity<Device> savedDevice = restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", deviceWithCredentials, Device.class);\n\t\treturn Optional.ofNullable(savedDevice.getBody());\n\t} catch (HttpClientErrorException exception) {\n\t\tif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow exception;\n\t\t}\n\t}\n}", "CodeBleu_score": 81.08038146326744}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tRequestEntity<DeviceWithCredentials> request = RequestEntity.post(URI.create(baseURL + \"/api/device-with-credentials\"))\n\t\t\t\t.contentType(MediaType.APPLICATION_JSON)\n\t\t\t\t.body(new DeviceWithCredentials(device, credentials));\n\t\tResponseEntity<Device> response = restTemplate.exchange(request, Device.class);\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException exception) {\n\t\tif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow exception;\n\t\t}\n\t}\n}", "CodeBleu_score": 70.83021754138865}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", deviceWithCredentials, Device.class);\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 73.722553183709}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tlet args;\n\tif (arguments.length < 2) {\n\t\targs = Array.from(arguments);\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness.apply(this, (args.unshift(device), args));\n\t\t});\n\t\treturn this;\n\t}\n\tval = Number(val);\n\tif (val < 0) {\n\t\tval = 0;\n\t}\n\tif (val > 100) {\n\t\tval = 100;\n\t}\n\tval = Math.round(val * 15 / 100);\n\tthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, val);\n\treturn this;\n}", "CodeBleu_score": 48.867257482601126}, {"code": "brightness(addr, val){\n\t\tlet args;\n\n\tif (arguments.length === 1) {\n\t\targs = Array.from(arguments);\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness.apply(this, (args.unshift(device), args));\n\t\t});\n\t\treturn this;\n\t}\n\n\tif (typeof addr!== \"number\") {\n\t\tthrow new Error(\"Invalid device address\");\n\t}\n\n\tif (typeof val!== \"number\") {\n\t\tthrow new Error(\"Invalid brightness value\");\n\t}\n\n\tval = Math.min(Math.max(val, 0), 15);\n\n\tthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, val);\n\treturn this;\n}", "CodeBleu_score": 51.0340277112831}, {"code": "brightness(addr, val){\n\t\tlet args;\n\tlet offset;\n\tlet index;\n\tlet character;\n\tlet value;\n\tlet hasDecimal = false;\n\n\tif (arguments.length === 1) {\n\t\targs = Array.from(arguments);\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness.apply(this, (args.unshift(device), args));\n\t\t});\n\t\treturn this;\n\t}\n\n\toffset = addr * this.digits;\n\n\tcharacter = String(chr);\n\tposition = Number(position);\n\n\t// If controller's indexes are ordered right to left, flip\n\t// the index around.\n\tindex = position;\n\tif (this.digitOrder === -1) {\n\t\tindex = this.digits - index - 1;\n\t}\n\n\tif (character.length === 2 && character[1] === \".\") {\n\t\thasDecimal = true;\n\t\tcharacter = character[0];\n\t}\n\n\tvalue = LedControl.DIGIT_CHARS[character];\n\n\tif (!value) {\n\t\tvalue = Math.abs(Number(character));\n\t}\n\n\tif (hasDecimal) {\n\t\tvalue = value | LedControl.DIGIT_CHARS[\".\"];\n\t}\n\n\tthis.memory[offset + index] = value;\n\tthis.sendDigit(addr, index, value);\n\treturn this;\n}", "CodeBleu_score": 46.669233141419866}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tlet bound = {};\nfor (let key in this) {\nif (typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n}\nreturn bound;\n}", "CodeBleu_score": 37.59007593151076}, {"code": "device(addr){\n\t\nconst device = {};\n\nfor (const key in this) {\nif (typeof this[key] === \"function\") {\ndevice[key] = this[key].bind(this, addr);\n} else {\ndevice[key] = this[key];\n}\n}\n\nreturn device;\n}", "CodeBleu_score": 38.86663189573501}, {"code": "device(addr){\n\t\tconst device = Object.create(Object.getPrototypeOf(this));\n\tObject.keys(this).forEach(function(key) {\n\t\tif (typeof this[key] === \"function\") {\n\t\t\tdevice[key] = this[key].bind(device, addr);\n\t\t}\n\t}, this);\n\treturn device;\n}", "CodeBleu_score": 34.58145590695521}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tduration = duration || 1000;\n\t\t\tcallback = callback || noop;\n\n\t\t\tconst promises = [];\n\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tthis[i][method](duration, resolve);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 35.448475225637985}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tonst promises = [];\n\tconst reconciled = methods.reduce((accum, method) => {\n\t\taccum[method] = function(...args) {\n\t\t\tconst length = this.length;\n\t\t\tconst duration = args.length > 1 && typeof args[args.length - 2] === \"number\"? args.pop() : 1000;\n\t\t\tconst callback = args.length > 1 && typeof args[args.length - 1] === \"function\"? args.pop() : noop;\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpromises.push(this[i][method](...args));\n\t\t\t}\n\n\t\t\treturn Promise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\n\t\treturn accum;\n\t}, target);\n\n\treturn reconciled;\n}", "CodeBleu_score": 39.22095799837395}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\teturn methods.reduce((accum, method) => {\n\t\taccum[method] = function(duration, callback) {\n\t\t\tconst length = this.length;\n\t\t\tconst promises = [];\n\n\t\t\tcallback = callback || noop;\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpromises.push(this[i][method](duration));\n\t\t\t}\n\n\t\t\treturn Promise.all(promises).then(callback);\n\t\t};\n\n\t\treturn accum;\n\t}, target);\n}", "CodeBleu_score": 43.120061230865275}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\nconst state = priv.get(this);\n\n// Initialize an empty input string\nlet input = \\\"\\\";\n\n// Start a read loop on the specified serial port\nthis.io.serialRead(state.portId, (data) => {\n\n// Append the data to the input string\ninput += String.fromCharCode(data);\n\n// Split the input string into sentences based on the \"\\r\n\" delimiter\nconst sentences = input.split(\\\"\\\\r\\\n\\\");\n\n// Process all complete sentences\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\n\n// Retain any incomplete sentence for the next read\ninput = sentences[sentences.length - 1];\n});\n}", "CodeBleu_score": 62.480520067417245}, {"code": "listen(){\n\tconst state = priv.get(this);\n\n// Initialize the input string and the incomplete sentence\nlet input = \"\";\nlet incompleteSentence = \"\";\n\n// Read data from the serial port\nthis.io.serialRead(state.portId, (data) => {\n// Append the data to the input string\ninput += data;\n\n// Split the input string into sentences based on the \"\\r\n\" delimiter\nconst sentences = input.split(\"\\r\n\");\n\n// Process all complete sentences\nfor (let i = 0; i < sentences.length - 1; i++) {\n// Process the complete sentence\nthis.parseNmeaSentence(sentences[i]);\n}\n\n// Retain the incomplete sentence for the next read\nincompleteSentence = sentences[sentences.length - 1];\n});\n}", "CodeBleu_score": 59.872961827158974}, {"code": "listen(){\n\t\nconst state = priv.get(this);\nconst input = [];\n\nthis.io.serialRead(state.portId, (data) => {\n  // Append the new data to the input string\n  input.push(data);\n  const inputString = input.join(\"\");\n\n  // Split the input string into sentences based on the \"\\r\n\" delimiter\n  const sentences = inputString.split(\"\\r\n\");\n\n  // Process all complete sentences\n  for (let i = 0; i < sentences.length - 1; i++) {\n    this.parseNmeaSentence(sentences[i]);\n  }\n\n  // Retain any incomplete sentence for the next read\n  input.length = 0;\n  input.push(sentences[sentences.length - 1]);\n});\n}", "CodeBleu_score": 58.57439612095089}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t active_channels = 0;\n\tuint32_t buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < AD559X_PIN_MAX; i++) {\n\t\tif (data->adc_conf & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * sequence->options->extra_samplings;\n\n\tif (sequence->options->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size: %d, required: %d\", sequence->options->buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.79289978632339}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0U;\n\tuint8_t i;\n\n\tfor (i = 0U; i < AD559X_PIN_MAX; i++) {\n\t\tif (data->adc_conf & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tif (sequence->options) {\n\t\tchannels = sequence->options->extra_samplings + 1U;\n\t}\n\n\tif (sequence->buffer_size < (channels * sequence->resolution)) {\n\t\tLOG_ERR(\"buffer too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\n\treturn 0;\n}", "CodeBleu_score": 35.34686564445594}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0;\n\tuint8_t i;\n\tuint16_t size;\n\n\tfor (i = 0; i < AD559X_PIN_MAX; i++) {\n\t\tif (data->adc_conf & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tsize = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tif (sequence->options->extra_samplings) {\n\t\t\tsize *= (sequence->options->extra_samplings + 1);\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < size) {\n\t\tLOG_ERR(\\\"buffer size %d is insufficient for %d channels\\\",\n\t\t\tsequence->buffer_size, channels);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\n\treturn 0;\n}", "CodeBleu_score": 44.909627547004035}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels == 0 || channels > AD559X_PIN_MAX) {\n\t\tLOG_ERR(\"invalid channels 0x%08x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"invalid buffer size %zu\", sequence->buffer_size);\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = channels;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 77.32181751834989}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tuint8_t i;\n\tint ret;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tfor (i = 0; i < channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tif (i >= AD559X_PIN_MAX) {\n\t\t\t\tLOG_ERR(\"invalid channel %d\", i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = channels;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\treturn 0;\n}", "CodeBleu_score": 71.60372315338621}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\tuint8_t channels;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels == 0 || channels > AD559X_PIN_MAX) {\n\t\tLOG_ERR(\"invalid channel count %d\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"invalid buffer size %zu\", sequence->buffer_size);\n\t\treturn ret;\n\t}\n\n\tdata->buffer = (uint16_t *)sequence->buffer;\n\tdata->channels = channels;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 75.50046019662614}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tdata->channels = ctx->sequence.channels;\n\tdata->repeat_buffer = ctx->sequence.buffer;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 75.25226129071164}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tuint32_t channels = ctx->sequence.channels;\n\tuint8_t channel;\n\tuint8_t channels_count = 0;\n\n\t/* Set the channels to be sampled */\n\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\tif (channels & BIT(channel)) {\n\t\t\tchannels_count++;\n\t\t}\n\t}\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tdata->repeat_buffer = data->buffer;\n\tdata->channels = channels_count;\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 59.721848112649035}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tuint8_t channels = 0U;\n\tint i;\n\n\t/*\n\t * The \"adc_context_on_sampling\" function is called to set the ADC context to the sampling state.\n\t */\n\tadc_context_on_sampling(ctx);\n\n\t/*\n\t * The \"for\" loop iterates over all channels in the ADC context and sets the \"channels\" variable to the number of channels.\n\t */\n\tfor (i = 0; i < 16; i++) {\n\t\tif (ctx->sequence.channels & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\t/*\n\t * The \"data->channels\" variable is set to the number of channels.\n\t */\n\tdata->channels = channels;\n\n\t/*\n\t * The \"data->repeat_buffer\" variable is set to the data buffer of the ADC context.\n\t */\n\tdata->repeat_buffer = ctx->sequence.buffer;\n\n\t/*\n\t * The \"k_sem_give\" function is called to release a semaphore to signal the start of sampling.\n\t */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 59.72017155954066}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 83.69996608713699}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 83.69996608713699}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 83.69996608713699}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (data->channels & BIT(channel)) {\n\t\t\t\tif (adc_ad559x_read_channel(data->dev, channel, data->buffer) < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel);\n\t\t\t\t\tadc_context_on_sampling_done(&data->ctx, -EIO);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer++;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 42.82694441821274}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint ret;\n\tuint16_t value;\n\tuint8_t channel;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (data->channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &value);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tadc_context_on_sampling_done(&data->ctx, ret);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t*data->buffer++ = value;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 54.53895477137819}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (!data->channels & BIT(channel)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (adc_ad559x_read_channel(data->dev, channel, data->buffer) < 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d read failed\", channel);\n\t\t\t\tadc_context_on_sampling_done(&data->ctx, -EIO);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buffer++;\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 42.608642308707296}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(data->ready_time);\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t\tk_busy_wait(100);\n\t} while (!(reg_val & ADS1112_CONFIG_MASK_READY));\n\n\treturn 0;\n}", "CodeBleu_score": 42.44542632562019}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(data->ready_time);\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val & ADS1112_CONFIG_MASK_READY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t} while (true);\n\n\treturn 0;\n}", "CodeBleu_score": 49.92079307811335}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t reg;\n\tint rc;\n\n\tk_sleep(data->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg & ADS1112_CONFIG_MASK_READY)) {\n\t\tk_sleep(K_MSEC(1));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.6978523274825}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_size = sequence->options->extra_samplings * sizeof(uint16_t);\n\n\tif (sequence->options->buffer_size < required_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient for extra samplings\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.45914028252232}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size = 0;\n\n\tif (sequence->options) {\n\t\trequired_buffer_size += sizeof(struct adc_sequence_extra_data);\n\t}\n\n\trequired_buffer_size += sequence->resolution * sequence->channels * sequence->oversampling;\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size: %d < %d\", sequence->buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.3055513517729}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t required_size = sequence->options->extra_samplings * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < required_size) {\n\t\tLOG_ERR(\"Buffer size too small for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.91175429878593}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\tif (sequence->calibrate) {\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tif (wait) {\n\t\trc = k_sem_take(&data->acq_sem, K_FOREVER);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.33998782619273}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tif (wait) {\n\t\trc = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 85.242624658659}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tif (wait) {\n\t\tret = k_sem_take(&data->acq_sem, K_FOREVER);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 71.40166023763219}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_property(dev);\n}", "CodeBleu_score": 94.87526410834471}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_property(dev);\n}", "CodeBleu_score": 94.87526410834471}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_property(dev);\n}", "CodeBleu_score": 94.87526410834471}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"invalid state %d\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_CMD_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"i2s_trigger failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"invalid state %d\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_CMD_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"i2s_trigger failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"invalid cmd %d\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.56448697636628}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == STATE_IDLE) {\n\t\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = STATE_CONFIGURED;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"start failed (%d)\", ret);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == STATE_CONFIGURED) {\n\t\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = STATE_IDLE;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"stop failed (%d)\", ret);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\tret = -ENOTSUP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.49286500348256}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tif (data->state == MPXXDTYY_STATE_IDLE) {\n\t\tLOG_ERR(\"Device not configured\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_CMD_START);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_CMD_STOP);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported command (%d)\", cmd);\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.47411967188144}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 80.97755497278544}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t} else {\n\t\tdata->display_enabled = false;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 78.44377392163886}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_CURSOR;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t} else {\n\t\tdata->display_enabled = false;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 78.44377392163886}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint busy = -1;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tbusy = gpio_pin_get_dt(&config->busy_gpio);\n\n\treturn busy;\n}", "CodeBleu_score": 75.90324495392647}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 45.10524809727554}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint rc = 0;\n\n\tif (!config->busy_gpio.port) {\n\t\tLOG_ERR(\"No busy GPIO defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = gpio_pin_get_dt(&config->busy_gpio);\n\n\treturn rc;\n}", "CodeBleu_score": 78.25012078110983}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\tint ret;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, bbram_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.57842280916375}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *ctx = dev->data;\n\n\tif (size == 0 || offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &ctx->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.71405293093408}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read size out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Read from invalid memory\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"Read from standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"Read from power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, bbram_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.38064716650247}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 3) {\n\t\tshell_error(sh, \"missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[2]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[2]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 76.95858461271946}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint err;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 73.29608902579719}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 83.56401299804381}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\tsize_t n = h4->rx.hdr_len - h4->rx.remaining;\n\n\tif (uart_fifo_read(cfg->uart, h4->rx.hdr + n, h4->rx.remaining)!= h4->rx.remaining) {\n\t\tLOG_ERR(\"Unable to read H:4 header\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining = 0;\n}", "CodeBleu_score": 67.81664722520185}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tsize_t len = h4->rx.hdr_len - h4->rx.remaining;\n\n\t/* Read header */\n\tif (uart_fifo_read(cfg->uart, h4->rx.hdr + len, h4->rx.remaining)!= h4->rx.remaining) {\n\t\tLOG_ERR(\\\"Unable to read H:4 packet header\\\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining = 0;\n}", "CodeBleu_score": 65.71607009385004}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\t/* Calculate how many bytes we have already read */\n\tsize_t offset = h4->rx.hdr_len - h4->rx.remaining;\n\n\t/* Read the rest of the header */\n\tif (uart_fifo_read(cfg->uart, h4->rx.hdr + offset, h4->rx.remaining)!= h4->rx.remaining) {\n\t\tLOG_ERR(\"Unable to read H:4 header\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\t/* Update remaining byte count */\n\th4->rx.remaining = 0;\n}", "CodeBleu_score": 68.11028848390553}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read = 0;\n\tint ret;\n\n\twhile (read < len) {\n\t\tsize_t to_read = MIN(len - read, sizeof(buf));\n\n\t\tret = uart_fifo_read(uart, buf, to_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tread += ret;\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 49.657430723962705}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tint ret;\n\n\twhile (len > 0) {\n\t\tsize_t chunk = MIN(len, sizeof(buf));\n\n\t\tret = uart_fifo_read(uart, buf, chunk);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= ret;\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 52.40851763950361}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t tmp[33];\n\tsize_t read = 0;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tsize_t chunk = MIN(len, sizeof(tmp));\n\n\t\tret = uart_fifo_read(uart, tmp, chunk);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tread += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 47.5347469530156}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint16_t highest_observer_priority = INT16_MAX;\n\n\tk_mutex_lock(&chan->data->lock, K_FOREVER);\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n\t\tstruct zbus_channel_observation *observation;\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (obs->data->enabled) {\n\t\t\thighest_observer_priority = MIN(highest_observer_priority, obs->data->priority);\n\t\t}\n\t}\n\n\tchan->data->highest_observer_priority = highest_observer_priority;\n\n\tk_mutex_unlock(&chan->data->lock);\n}", "CodeBleu_score": 49.88601010634351}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint16_t highest_priority = INT16_MAX;\n\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->data->priority < highest_priority) {\n\t\t\thighest_priority = obs->data->priority;\n\t\t}\n\t}\n\n#if defined(CONFIG_ZBUS_RUNTIME_OBSERVERS)\n\tstruct zbus_observer_node *obs_nd;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&chan->data->observers, obs_nd, node) {\n\t\tconst struct zbus_observer *obs = obs_nd->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->data->priority < highest_priority) {\n\t\t\thighest_priority = obs->data->priority;\n\t\t}\n\t}\n#endif /* CONFIG_ZBUS_RUNTIME_OBSERVERS */\n\n\tchan->data->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 72.99688478151846}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint16_t highest_observer_priority = INT16_MAX;\n\n\tk_mutex_lock(&chan->data->lock, K_FOREVER);\n\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;\n\t     i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t_ZBUS_ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->priority < highest_observer_priority) {\n\t\t\thighest_observer_priority = obs->priority;\n\t\t}\n\t}\n\n#if defined(CONFIG_ZBUS_RUNTIME_OBSERVERS)\n\tstruct zbus_observer_node *obs_nd, *tmp;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {\n\t\tconst struct zbus_observer *obs = obs_nd->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->priority < highest_observer_priority) {\n\t\t\thighest_observer_priority = obs->priority;\n\t\t}\n\t}\n#endif /* CONFIG_ZBUS_RUNTIME_OBSERVERS */\n\n\tchan->data->highest_observer_priority = highest_observer_priority;\n\n\tk_mutex_unlock(&chan->data->lock);\n}", "CodeBleu_score": 67.88513534492637}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\tconst struct zbus_channel *chan;\n\n\tfor (int16_t i = 0; i < ZBUS_CHAN_COUNT; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\tchan = observation->chan;\n\n\t\tif (observation->obs == obs) {\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.479458594876235}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = 0; i < ZBUS_CHAN_COUNT; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\tif (obs == observation->obs) {\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.976820906686427}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int i = 0; i < ZBUS_CHANNELS_COUNT; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\tif (observation->obs == obs) {\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.572599614224217}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 75.07046871426598}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 86.61781504652494}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 86.61781504652494}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n}", "CodeBleu_score": 4.451885662912518}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\n\tif (enable) {\n\t\tif (Int & 0x0000FFFF) {\n\t\t\tETH->INT_EN_b.NIS = TRUE;\n\t\t} else {\n\t\t\tETH->INT_EN_b.AIS = TRUE;\n\t\t}\n\t} else {\n\t\tif (Int & 0x0000FFFF) {\n\t\t\tETH->INT_EN_b.NIS = FALSE;\n\t\t} else {\n\t\t\tETH->INT_EN_b.AIS = FALSE;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.456650103065456}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc;\n\tuint32_t addr;\n\n\taddr = ETH->TDESAR;\n\tdesc = (ETH_TX_DESC *)GLB_ConvertToMappingFromAddr(addr);\n\n\twhile (desc) {\n\t\tif (ETH_DESC_OWN_BY_SELF == desc->desc.TX_0.TX0_b.OWN) {\n\t\t\treturn desc;\n\t\t}\n\n\t\tdesc = (ETH_TX_DESC *)GLB_ConvertToMappingFromAddr(desc->desc.nextDescAddr);\n\n\t\tif (addr == desc->desc.nextDescAddr) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.325923250161445}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESAR;\n\tETH_TX_DESC *start = desc;\n\n\tdo {\n\t\tif (ETH_DESC_OWN_BY_SELF == desc->TX_0.TX0_b.OWN) {\n\t\t\treturn desc;\n\t\t}\n\n\t\tdesc = (ETH_TX_DESC *)desc->nextDescAddr;\n\t} while (desc!= start);\n\n\treturn 0;\n}", "CodeBleu_score": 53.29489962031805}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *buf = (ETH_TX_DESC *)ETH->TDESLA;\n\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tif (ETH_DESC_OWN_BY_SELF == buf->TX_0.TX0_b.OWN) {\n\t\t\treturn buf;\n\t\t}\n\t\tbuf = (ETH_TX_DESC *)buf->nextDescAddr;\n\t} while (buf!= (ETH_TX_DESC *)ETH->TDESLA);\n\n\treturn 0;\n}", "CodeBleu_score": 50.78675343296667}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tuint32_t cyp_channel;\n\tcy_rslt_t result;\n\tRT_ASSERT(device!= RT_NULL);\n\tcyhal_dac_t *dac_device;\n\tdac_device = device->parent.user_data;\n\tcyp_channel = cyp_dac_get_channel(channel);\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 74.50925535493509}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tuint32_t cyp_channel;\n\tcy_rslt_t result;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\tcyp_channel = cyp_dac_get_channel(channel);\n\n\t/*DAC output enable*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 74.50925535493509}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trslt_t result;\n\trt_uint32_t cyp_channel;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\tcyp_channel = cyp_dac_get_channel(channel);\n\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 74.92667591246935}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page = 0;\n\trt_uint32_t read_addr = 0;\n\trt_uint32_t read_size = 0;\n\trt_uint32_t read_offset = 0;\n\trt_uint32_t read_remain = 0;\n\trt_uint32_t read_count = 0;\n\trt_uint32_t read_len = 0;\n\n\t/* check if the read operation would exceed the flash memory's end address */\n\tif (addr + size > IFX_EFLASH_END_ADDRESS) {\n\t\tLOG_E(\"invalid address: 0x%08x\", addr);\n\t\treturn -RT_EINVAL;\n\t}\n\n\tpage = get_page_32k(addr);\n\tread_addr = addr;\n\tread_size = size;\n\n\twhile (read_size > 0) {\n\t\t/* calculate the offset and remaining bytes in the current page */\n\t\tread_offset = read_addr - page;\n\t\tread_remain = IFX_EFLASH_PAGE_SIZE - read_offset;\n\n\t\t/* read the remaining bytes in the current page */\n\t\tread_count = read_size > read_remain? read_remain : read_size;\n\t\tread_len = cyhal_flash_read(&flash_obj, read_addr, buf, read_count);\n\t\tif (read_len!= read_count) {\n\t\t\tLOG_E(\"read failed: 0x%08x\", read_addr);\n\t\t\treturn -RT_EIO;\n\t\t}\n\n\t\t/* update the read address and size */\n\t\tread_addr += read_count;\n\t\tread_size -= read_count;\n\t\tbuf += read_count;\n\n\t\t/* move to the next page */\n\t\tpage += IFX_EFLASH_PAGE_SIZE;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 37.94408740825415}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page_addr;\n\trt_uint32_t page_offset;\n\trt_uint32_t page_size;\n\trt_uint32_t read_size = 0;\n\trt_uint32_t read_addr;\n\trt_uint32_t read_count;\n\trt_uint32_t read_data;\n\trt_uint32_t i;\n\n\tif (addr + size > block_info.end_addr) {\n\t\tLOG_E(\"read addr out of flash memory\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tpage_addr = get_page_32k(addr);\n\tpage_offset = addr - page_addr;\n\tpage_size = block_info.end_addr - page_addr + 1;\n\n\tread_addr = addr;\n\tread_count = size;\n\twhile (read_count > 0) {\n\t\tread_size = (page_size - page_offset > read_count)? read_count : (page_size - page_offset);\n\t\tfor (i = 0; i < read_size; i++) {\n\t\t\tread_data = cyhal_flash_read(&flash_obj, read_addr);\n\t\t\t*buf = (rt_uint8_t)read_data;\n\t\t\tbuf++;\n\t\t\tread_addr++;\n\t\t}\n\t\tread_count -= read_size;\n\t\tpage_addr = get_page_32k(read_addr);\n\t\tpage_offset = read_addr - page_addr;\n\t\tpage_size = block_info.end_addr - page_addr + 1;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 43.8102560363553}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t RT_NULL);\n\n\tcyhal_timer_t *tim = RT_NULL;\n\n\ttim = (cyhal_timer_t *)timer->parent.user_data;\n\n\treturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 34.428876001891965}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t RT_NULL);\n\n\tcyhal_timer_t *tim = RT_NULL;\n\n\ttim = (cyhal_timer_t *)timer->parent.user_data;\n\n\treturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 34.428876001891965}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_NULL);\ncyhal_timer_t *tim = RT_NULL;\ntim = (cyhal_timer_t *) timer->parent.user_data;\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 32.254983167889094}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\tifdef DFS_USING_POSIX\n    if (dfs_thread_self()!= RT_NULL) {\n        rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n    }\n#else\n    rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n#endif\n}", "CodeBleu_score": 27.410975674894356}, {"code": "void dfs_lock(void){\n\tifdef RT_USING_DFS_LOCK\n    rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n#endif\n}", "CodeBleu_score": 10.152178979410564}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tt fd;\n\tint index;\n\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\tfd = fd_slot_expand(fdt, index);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 35.4727937085513}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tt index;\n\tint fd;\n\tstruct dfs_file **fds = fdt->fds;\n\n\t/* search from startfd */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* expand fd table */\n\tfd = fd_slot_expand(fdt, index);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 35.69667963084711}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tt index;\n\n\t/* search for an empty slot */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* expand the fd table */\n\tif (fd_slot_expand(fdt, startfd) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* allocate the slot */\n\treturn startfd;\n}", "CodeBleu_score": 42.09281117244858}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_int32_t i;\n\terror = RT_ABS(error);\n\tfor (i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n\t\tif (rt_errno_strs[i].error == error) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 60.21929562838033}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_int32_t index;\n\tconst char *err_str;\n\trt_int32_t err_num;\n\n\terr_num = error;\n\tif (err_num < 0) {\n\t\terr_num = -err_num;\n\t}\n\n\tfor (index = 0; index < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); index++) {\n\t\tif (rt_errno_strs[index].error == err_num) {\n\t\t\terr_str = rt_errno_strs[index].str;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index == sizeof(rt_errno_strs) / sizeof(struct _errno_str_t)) {\n\t\terr_str = \"EUNKNOW\";\n\t}\n\n\treturn err_str;\n}", "CodeBleu_score": 44.304495322220596}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n\t\tif (rt_errno_strs[i].error == error) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 63.08225395644291}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\nrt_err_t result = -RT_EFULL;\n\n/* lock the spinlock */\nrt_spin_lock(&_hook_spinlock);\n\n/* find an empty slot */\nfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\nif (idle_hook_list[i] == RT_NULL) {\nidle_hook_list[i] = hook;\nresult = RT_EOK;\nbreak;\n}\n}\n\n/* unlock the spinlock */\nrt_spin_unlock(&_hook_spinlock);\n\nreturn result;\n}", "CodeBleu_score": 69.49633872467501}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_hw_interrupt_disable();\n\trt_spin_lock(&_hook_spinlock);\n\n\t/* find a empty slot */\n\tfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idle_hook_list[RT_IDLE_HOOK_LIST_SIZE - 1] == RT_NULL) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\trt_spin_unlock(&_hook_spinlock);\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 59.7164827151055}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n\n/* lock the spinlock */\nrt_spin_lock(&_hook_spinlock);\n\n/* find an empty slot */\nfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\nif (idle_hook_list[i] == RT_NULL) {\nidle_hook_list[i] = hook;\nrt_spin_unlock(&_hook_spinlock);\nreturn RT_EOK;\n}\n}\n\n/* no empty slot */\nrt_spin_unlock(&_hook_spinlock);\nreturn -RT_EFULL;\n}", "CodeBleu_score": 58.61447964642611}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_err_t ret = -RT_ENOSYS;\n\trt_base_t level;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 91.9440969940395}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_err_t ret = -RT_ENOSYS;\n\trt_base_t level;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 91.9440969940395}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_err_t ret = -RT_ENOSYS;\n\trt_base_t level;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 91.9440969940395}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.6761643694592}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn thread;\n}", "CodeBleu_score": 31.170225741451997}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.07326881772602}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t new_console_device;\n\n\t/* save the current console device */\n\tnew_console_device = _console_device;\n\n\t/* find the new console device by its name */\n\tif (name!= RT_NULL) {\n\t\tnew_console_device = rt_device_find(name);\n\t}\n\n\t/* if the new console device is different and valid, set it as the new console device */\n\tif (new_console_device!= _console_device && new_console_device!= RT_NULL) {\n\t\t/* close the current console device if it exists */\n\t\tif (_console_device!= RT_NULL) {\n\t\t\trt_device_close(_console_device);\n\t\t}\n\n\t\t/* open the new console device with read/write and stream flags */\n\t\tif (rt_device_open(new_console_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t/* set the new console device */\n\t\t\t_console_device = new_console_device;\n\t\t} else {\n\t\t\t/* if the new console device cannot be opened, set it to the old console device */\n\t\t\tnew_console_device = _console_device;\n\t\t}\n\t}\n\n\treturn new_console_device;\n}", "CodeBleu_score": 60.187175953948866}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t new_console;\n\n\t/* save the current console device */\n\tnew_console = _console_device;\n\n\t/* find the new console device */\n\tif (name!= RT_NULL) {\n\t\tnew_console = rt_device_find(name);\n\t}\n\n\t/* check if the new console device is different from the current one */\n\tif (new_console!= _console_device) {\n\t\t/* check if the new console device is valid */\n\t\tif (new_console!= RT_NULL) {\n\t\t\t/* close the current console device if it exists */\n\t\t\tif (_console_device!= RT_NULL) {\n\t\t\t\trt_device_close(_console_device);\n\t\t\t}\n\n\t\t\t/* open the new console device with read/write and stream flags */\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set the new console device */\n\t\t\t\t_console_device = new_console;\n\t\t\t} else {\n\t\t\t\t/* open failed, set the new console device to RT_NULL */\n\t\t\t\tnew_console = RT_NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* return the old console device */\n\treturn new_console;\n}", "CodeBleu_score": 58.05096664387759}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t new_console_device;\n\n\t/* save current console device */\n\tnew_console_device = _console_device;\n\n\t/* find new console device */\n\tif (name!= RT_NULL) {\n\t\tnew_console_device = rt_device_find(name);\n\t}\n\n\t/* if new console device is different from current one */\n\tif (new_console_device!= _console_device) {\n\t\t/* if current console device is valid */\n\t\tif (_console_device!= RT_NULL) {\n\t\t\t/* close current console device */\n\t\t\trt_device_close(_console_device);\n\t\t}\n\n\t\t/* if new console device is valid */\n\t\tif (new_console_device!= RT_NULL) {\n\t\t\t/* open new console device */\n\t\t\tif (rt_device_open(new_console_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set new console device */\n\t\t\t\t_console_device = new_console_device;\n\t\t\t} else {\n\t\t\t\t/* open failed, restore current console device */\n\t\t\t\tnew_console_device = _console_device;\n\t\t\t}\n\t\t} else {\n\t\t\t/* set new console device */\n\t\t\t_console_device = new_console_device;\n\t\t}\n\t}\n\n\t/* return current console device */\n\treturn new_console_device;\n}", "CodeBleu_score": 58.651900070529116}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\tstruct rt_object_information *information;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\tfor (index = 0; index < RT_Object_Info_Unknown; index++)\n\t\tif (_object_container[index].type == type) {\n\t\t\tinformation = &_object_container[index];\n\t\t\tbreak;\n\t\t}\n\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\trt_spin_lock(&information->spinlock);\n\n\tint length = 0;\n\tstruct rt_list_node *node;\n\trt_list_for_each(node, &information->object_list) {\n\t\tlength++;\n\t}\n\n\trt_spin_unlock(&information->spinlock);\n\n\treturn length;\n}", "CodeBleu_score": 39.15063214487813}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tint length = 0;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\trt_spin_lock(&information->spinlock);\n\tlength = rt_list_len(&information->object_list);\n\trt_spin_unlock(&information->spinlock);\n\n\treturn length;\n}", "CodeBleu_score": 38.87419540912763}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint length;\n\tstruct rt_object_information *info;\n\trt_base_t level;\n\n\t/* get object information */\n\tinfo = rt_object_get_information(type);\n\tif (info == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* lock object list */\n\tlevel = rt_hw_spin_lock_irqsave(&info->object_list_lock);\n\n\t/* count object length */\n\tlength = 0;\n\trt_list_for_each(info->object_list.next, &info->object_list) {\n\t\tlength ++;\n\t}\n\n\t/* unlock object list */\n\trt_hw_spin_unlock_irqrestore(&info->object_list_lock, level);\n\n\treturn length;\n}", "CodeBleu_score": 45.2401864772416}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object) {\n\t\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\t\tstruct rt_object_information *information = rt_object_get_information(object->type);\n\t\tif (information) {\n\t\t\trt_base_t level = rt_spin_lock_irqsave(&information->spinlock);\n\t\t\trt_list_remove(&object->list);\n\t\t\trt_spin_unlock_irqrestore(&information->spinlock, level);\n\t\t\tobject->type = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.59981390038539}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n\tstruct rt_object_information *information;\n\n\t/* check object type */\n\tif (object == RT_NULL) return;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* invoke hook */\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* remove object from object list */\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\trt_list_remove(&(object->list));\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 73.63811810510197}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n\tstruct rt_object_information *information;\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\tinformation = rt_object_get_information(object->type & ~RT_Object_Class_Static);\n\tif (information == RT_NULL) {\n\t\treturn;\n\t}\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\trt_list_remove(&(object->list));\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\tobject->type = 0;\n}", "CodeBleu_score": 71.34035383692942}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\tstruct rt_custom_object *cobj = RT_NULL;\n\tif (obj!= RT_NULL) {\n\t\tif ((obj->type & RT_Object_Class_Static) == RT_Object_Class_Static) {\n\t\t\tresult = -RT_EPERM;\n\t\t} else {\n\t\t\tcobj = (struct rt_custom_object *)obj;\n\t\t\tif (cobj->destroy!= RT_NULL) {\n\t\t\t\tresult = cobj->destroy(cobj->data);\n\t\t\t}\n\t\t\trt_object_delete(obj);\n\t\t}\n\t} else {\n\t\tresult = -RT_EINVAL;\n\t}\n\treturn result;\n}", "CodeBleu_score": 62.4616184520248}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = -RT_EINVAL;\n\tif (obj!= RT_NULL) {\n\t\tstruct rt_custom_object *cobj = (struct rt_custom_object *) obj;\n\t\tif (cobj->destroy!= RT_NULL) {\n\t\t\tresult = cobj->destroy(cobj->data);\n\t\t}\n\t\trt_object_delete(obj);\n\t}\n\treturn result;\n}", "CodeBleu_score": 58.89809806686295}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\tstruct rt_custom_object *cobj = (struct rt_custom_object *)obj;\n\tif (obj == RT_NULL) {\n\t\treturn -RT_EINVAL;\n\t}\n\tif (cobj->destroy!= RT_NULL) {\n\t\tresult = cobj->destroy(cobj->data);\n\t}\n\trt_object_delete(obj);\n\treturn result;\n}", "CodeBleu_score": 60.4192653252515}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tregister rt_thread_t thread;\n\tregister rt_list_t *list;\n\tregister rt_ubase_t tmp;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* disable interrupt */\n\trt_hw_interrupt_disable();\n\n\t/* set error number */\n\tthread->error = RT_EOK;\n\n\t/* if thread is not in defunct list, add it to defunct list */\n\tif ((thread->stat & RT_THREAD_STAT_FLAG_DEFUNCT) == 0) {\n\t\t/* change thread stat */\n\t\tthread->stat = RT_THREAD_STAT_FLAG_DEFUNCT;\n\n\t\t/* insert thread to defunct list */\n\t\tlist = &(rt_thread_defunct);\n\t\ttmp = (rt_ubase_t)rt_list_entry(list->prev, struct rt_object, list);\n\t\ttmp = (tmp & 0xfffffff8) | (rt_ubase_t)thread;\n\t\tlist->prev = (rt_list_t *)tmp;\n\n\t\ttmp = (rt_ubase_t)rt_list_entry(list->next, struct rt_object, list);\n\t\ttmp = (tmp & 0xfffffff8) | (rt_ubase_t)thread;\n\t\tlist->next = (rt_list_t *)tmp;\n\n\t\t/* set current thread to idle */\n\t\trt_scheduler_set_current_thread(RT_NULL);\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable();\n\n\t/* do schedule */\n\trt_schedule();\n}", "CodeBleu_score": 52.603207837149355}, {"code": "static void _thread_exit(void){\n\tregister rt_base_t temp;\n\tstruct rt_thread *thread;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* change thread stat */\n\tthread->stat = RT_THREAD_CLOSE;\n\n\t/* remove thread from thread ready list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* add thread to thread defunct list */\n\trt_list_insert_before(&(rt_thread_defunct), &(thread->tlist));\n\n\t/* switch to next thread */\n\trt_schedule();\n\n\t/* never reach here */\n\tfor (;;);\n}", "CodeBleu_score": 54.570463575709894}, {"code": "static void _thread_exit(void){\n\tregister rt_base_t temp;\n\tstruct rt_thread *thread;\n\trt_ubase_t level;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* close thread */\n\trt_object_detach(&(thread->parent.parent));\n\n\t/* add thread to defunct list */\n\trt_list_insert_before(&(rt_thread_defunct), &(thread->tlist));\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* invoke scheduler */\n\trt_schedule();\n}", "CodeBleu_score": 63.21009846740393}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\t/* get thread control block from timer */\n\tthread = (struct rt_thread *)parameter;\n\n\tlevel = rt_hw_interrupt_disable();\n\t/* verify thread status */\n\tif (thread->stat == RT_THREAD_CLOSE) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert thread to ready list */\n\trt_schedule_insert_thread(thread);\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 48.03973434943176}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\n\t/* get thread control block from timer */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_CLOSE);\n\n\trt_enter_critical();\n\n\t/* is thread suspended? */\n\tif (thread->stat == RT_THREAD_CLOSE) {\n\t\t/* set error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t}\n\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 48.47081950579779}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread = (struct rt_thread *)parameter;\n\trt_base_t level;\n\n\t/* parameter check */\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* verify thread is suspended */\n\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\t/* set thread error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert thread into ready list */\n\t\trt_schedule_insert_thread(thread);\n\n\t\t/* re-schedule */\n\t\trt_hw_interrupt_enable(level);\n\t\trt_schedule();\n\t} else {\n\t\t/* unlock scheduler */\n\t\trt_hw_interrupt_enable(level);\n\t}\n}", "CodeBleu_score": 45.08726162033161}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tt_base_t level;\n\trt_mutex_t mutex;\n\n\t/* lock the thread's spinlock */\n\tlevel = rt_hw_spin_lock_irq(&thread->spinlock);\n\n\t/* check if the thread is waiting on a mutex */\n\tif (thread->pending_mutex!= RT_NULL) {\n\t\t/* remove the thread from the mutex's waiting list */\n\t\tmutex = thread->pending_mutex;\n\t\trt_list_remove(&thread->tlist);\n\n\t\t/* clear the pending object */\n\t\tthread->pending_mutex = RT_NULL;\n\n\t\t/* release the spinlock */\n\t\trt_hw_spin_unlock_irq(&thread->spinlock, level);\n\n\t\t/* release all mutexes the thread has taken */\n\t\trt_mutex_release_all(mutex);\n\t} else {\n\t\t/* release the spinlock */\n\t\trt_hw_spin_unlock_irq(&thread->spinlock, level);\n\t}\n}", "CodeBleu_score": 32.47366608306983}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tt_uint8_t level;\n\n\t/* lock the thread's spinlock */\n\trt_spin_lock_irqsave(&thread->spinlock, level);\n\n\t/* check if the thread is waiting on a mutex */\n\tif (thread->pending_mutex!= RT_NULL) {\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(&thread->tlist);\n\t\t/* clear the pending object */\n\t\tthread->pending_mutex = RT_NULL;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\trt_mutex_release_all(thread);\n\n\t/* unlock the thread's spinlock */\n\trt_spin_unlock_irqrestore(&thread->spinlock, level);\n}", "CodeBleu_score": 28.132605394415265}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tt_base_t temp;\n\n\t/* lock the thread's spinlock */\n\trt_spin_lock(&thread->spinlock);\n\n\t/* check if the thread is waiting on a mutex */\n\tif (thread->pending_object) {\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(&thread->tlist);\n\t\t/* clear the pending object */\n\t\tthread->pending_object = RT_NULL;\n\t}\n\n\t/* unlock the thread's spinlock */\n\trt_spin_unlock(&thread->spinlock);\n\n\t/* lock the scheduler */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* release all mutexes the thread has taken */\n\trt_mutex_release_all(thread);\n\n\t/* restore the interrupt state */\n\trt_hw_interrupt_enable(temp);\n}", "CodeBleu_score": 22.430106685606493}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n\t/* log thread */\n\trt_kprintf(\"thread %s, priority is %d, stack size is %d, entry address is 0x%x\n\", thread->parent.parent.name, thread->current_priority, thread->stack_size, thread->entry);\n\n\t/* calculate thread priority */\n\trt_thread_calculate_priority(thread);\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* start thread */\n\tif (rt_thread_self() == RT_NULL) {\n\t\t/* switch to thread */\n\t\trt_hw_context_switch_to((rt_uint32_t)thread->sp);\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 52.449978532543575}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n\t/* log thread info */\n\trt_kprintf(\"thread '%s' [prio-%d] has been started\n\", thread->parent.name, thread->current_priority);\n\n\t/* calculate priority */\n\trt_thread_calculate_priority(thread);\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 52.80300899444011}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n\trt_kprintf(\"thread %s, priority is %d\n\", thread->parent.name, thread->current_priority);\n\n\t/* calculate priority */\n\trt_thread_calculate_priority(thread);\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume from suspend state */\n\trt_thread_resume(thread);\n\n\t/* start thread */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 54.89273195754316}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\tif (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n\t\trt_timer_t timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\t\t*timeout_tick = timer->timeout_tick;\n\t\treturn RT_EOK;\n\t} else {\n\t\treturn -RT_ERROR;\n\t}\n}", "CodeBleu_score": 61.995351180238515}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\tif (!rt_list_isempty(&timer_list[0])) {\n\t\tstruct rt_timer *timer = rt_list_entry(timer_list[0].next, struct rt_timer, row[0]);\n\t\t*timeout_tick = timer->timeout_tick;\n\t\treturn RT_EOK;\n\t}\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 38.107824249076984}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\tif (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n\t\trt_timer_t timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\t\t*timeout_tick = timer->timeout_tick;\n\t\treturn RT_EOK;\n\t}\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 63.3671979683843}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* parameter check */\n\tRT_ASSERT(name!= RT_NULL);\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL) {\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 66.25690003780693}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* parameter check */\n\tRT_ASSERT(name!= RT_NULL);\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL) {\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 66.25690003780693}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* parameter check */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL) {\n\t\t/* timer object initialization */\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 65.34329294480821}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tcreate a new response recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// call each handler in the chain\n\tfor _, handler := range a.handlers {\n\t\t// call the handler with the request and the recorder as arguments\n\t\thandler(recorder, req)\n\n\t\t// if the handler returned a 401 Unauthorized status, send an error response and stop processing\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\n\t\t// copy the recorder's headers to the original response\n\t\tfor header, values := range recorder.HeaderMap {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(header, value)\n\t\t\t}\n\t\t}\n\t}\n\n\t// if all handlers passed without unauthorized status, forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 51.44154353080219}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\torder := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(`{\"error\":\"Not Authorized\"}`))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 50.481773645378084}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor k, v := range recorder.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 57.912143644194856}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\th := req.URL.Path[1:]\n\tasset, err := robeaux.Asset(path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\text := strings.Split(path, \".\")[1]\n\tswitch ext {\n\tcase \\\"js\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"application/javascript\\\")\n\tcase \\\"css\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/css\\\")\n\tcase \\\"html\\\":\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/html\\\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 57.19975965814547}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tet := req.URL.Path[1:]\n\tif asset == \\\"\\\" {\n\t\tasset = \\\"index.html\\\"\n\t}\n\tcontent, err := robeaux.Asset(asset)\n\tif err!= nil {\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\tif strings.HasSuffix(asset, \\\".js\\\") {\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"application/javascript\\\")\n\t} else if strings.HasSuffix(asset, \\\".css\\\") {\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/css\\\")\n\t} else if strings.HasSuffix(asset, \\\".html\\\") {\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/html\\\")\n\t}\n\tfmt.Fprint(res, string(content))\n}", "CodeBleu_score": 34.00171113042718}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t", "CodeBleu_score": 2.29984901754818}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tbasicAuth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(basicAuth))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 59.220352021348965}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif len(auth) == 0 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif len(auth) < 6 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif auth[:5]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tparts := string(decoded[:])\n\t\tif len(parts) < 2 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif parts[0]!= username {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(parts[1]), []byte(password))!= 1 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.35179623475926}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.86350020740118}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMax - slope*fromMax\n\treturn func(input float64) (value int)  {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.77983910546365}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 62.99124600560078}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, errors.New(\\\"analogSensorRead: connection is nil\\\")\n\t}\n\n\tif _, ok := a.connection.(AnalogReader);!ok {\n\t\treturn -1, -1, errors.New(\\\"analogSensorRead: connection does not support analog reading\\\")\n\t}\n\n\trawValue, err := a.connection.(AnalogReader).AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\n\treturn rawValue, a.lastValue, nil\n}", "CodeBleu_score": 56.14961002473883}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0.0, errors.New(\\\"connection is not valid\\\")\n\t}\n\n\tif _, ok := a.connection.(AnalogReader);!ok {\n\t\treturn 0, 0.0, errors.New(\\\"connection does not support analog reading\\\")\n\t}\n\n\trawValue, err := a.connection.(AnalogReader).AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaledValue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 52.3593148422552}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, errors.New(\\\"connection is nil\\\")\n\t}\n\n\tif!a.connection.AnalogReader() {\n\t\treturn -1, -1, errors.New(\\\"connection does not support analog reading\\\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 46.8813925376993}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMax - m*float64(fromMax)\n\treturn func(input int) float64 { return m*float64(input) + n }\n}", "CodeBleu_score": 56.08353806471993}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 55.99974178334912}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 55.99974178334912}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\td.Handle(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 68.92717514936734}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(Vibration)\n\n\t// Add event handler for data events\n\td.Handle(Data, func(data interface{}) {\n\t\tif d.Connection().(*gobot.Connection).Name() == \"firmata\" {\n\t\t\t// Firmata returns a byte array\n\t\t\tdata = binary.BigEndian.Uint16(data.([]byte))\n\t\t}\n\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t})\n\n\treturn &d\n}", "CodeBleu_score": 64.31078193497308}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(Vibration)\n\td.Handle(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(Vibration, true)\n\t\t}\n\t})\n\tif err := d.Start(); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn &d\n}", "CodeBleu_score": 68.47309631260742}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn fmt.Errorf(\\\"tone frequency must be greater than 0\\\")\n\t}\n\tif duration <= 0 {\n\t\treturn fmt.Errorf(\\\"tone duration must be greater than 0\\\")\n\t}\n\n\ttonePeriod := 1 / hz\n\ttempo := 60 / d.bpm\n\n\tnumCycles := duration / tempo\n\tfor i := 0; i < int(numCycles); i++ {\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.21560432255677}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1000000.0 / hz\n\ttempo := 60.0 / d.bpm\n\tticks := duration / tempo\n\tfor i := 0.0; i < ticks; i++ {\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.62243088946853}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\\\"Tone: frequency must be greater than 0\\\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\\\"Tone: duration must be greater than 0\\\")\n\t}\n\n\t// calculate the tone period based on the given frequency\n\ttonePeriod := 1 / hz\n\n\t// calculate the tempo based on the buzzer's beats per minute (bpm)\n\ttempo := 60 / d.bpm\n\n\t// calculate the number of times to repeat the tone based on the duration\n\trepeat := int(duration / tempo)\n\n\tfor i := 0; i < repeat; i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Second)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.40398154221216}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 94.72520543716337}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 94.72520543716337}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 94.72520543716337}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tf a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"pins not initialized\\\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 60.10805065244229}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tf a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"adaptor not connected\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 61.23829135099334}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tf a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"pins map is not initialized\\\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 59.75477922621402}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\t// Apply additional options to existing options\n\topts = append(a.pinOptions, opts...)\n\n\t// Get existing pin or create new one\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\t// Translate ID to chip and line\n\t\tchip, line, err := a.translateID(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Create new pin\n\t\tpin, err = system.NewDigitalPin(chip, line, opts...)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Initialize pin\n\t\tif err = pin.Export(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Store pin\n\t\ta.pins[id] = pin\n\t}\n\n\t// Apply options to pin\n\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 55.85036871157}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"Adaptor not connected to any pins\")\n\t}\n\n\tif a.pinOptions == nil {\n\t\ta.pinOptions = make(map[string][]func(gobot.DigitalPinOptioner) bool)\n\t}\n\n\ta.pinOptions[id] = append(a.pinOptions[id], opts...)\n\n\tif pin, ok := a.pins[id]; ok {\n\t\tif err := pin.ApplyOptions(a.pinOptions[id]...); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tpin, err := system.NewDigitalPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif err := pin.ApplyOptions(a.pinOptions[id]...); err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 51.243272670140094}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"digital pins are not connected\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = system.NewDigitalPin(chip, line, a.pinOptions...)\n\t\tif err := pin.Initialize(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 62.373530939251594}]}
