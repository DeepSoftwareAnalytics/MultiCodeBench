{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * \\asf_license_stop\n *\n */", "CodeBleu_score": 9.616854472351543}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * \\asf_license_stop\n *\n */", "CodeBleu_score": 9.616854472351543}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * \\asf_license_stop\n *\n */", "CodeBleu_score": 9.616854472351543}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tsetting value\nstatic uint8_t udc_iface_setting = 0;\n\n//! Device Configuration number selected by the USB host\nCOMPILER_WORD_ALIGNED\nstatic uint8_t udc_num_configuration = 0;\n\n//! Pointer on the selected speed device configuration\nstatic udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;\n\n//! Pointer on interface descriptor used by SETUP request.\nstatic usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;\n\n//! @}", "CodeBleu_score": 7.4053766929479705}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tsetting value\nstatic uint8_t udc_iface_setting = 0;\n\n//! Device Configuration number selected by the USB host\nCOMPILER_WORD_ALIGNED\nstatic uint8_t udc_num_configuration = 0;\n\n//! Pointer on the selected speed device configuration\nstatic udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;\n\n//! Pointer on interface descriptor used by SETUP request.\nstatic usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;\n\n//! @}", "CodeBleu_score": 7.4053766929479705}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tsetting value\nstatic uint8_t udc_iface_setting = 0;\n\n//! Device Configuration number selected by the USB host\nCOMPILER_WORD_ALIGNED\nstatic uint8_t udc_num_configuration = 0;\n\n//! Pointer on the selected speed device configuration\nstatic udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;\n\n//! Pointer on interface descriptor used by SETUP request.\nstatic usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;\n\n//! @}", "CodeBleu_score": 7.4053766929479705}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\t}", "CodeBleu_score": 3.4510968920043625}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\t}", "CodeBleu_score": 3.4510968920043625}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\t}", "CodeBleu_score": 3.4510968920043625}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tfor (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;\n\t\t\tiface_num++) {\n\t\tif (!udc_iface_enable(iface_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.301196771709442}, {"code": "static bool udc_req_iface(void){\n\tfor (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;\n\t\t\tiface_num++) {\n\t\tif (!udc_iface_enable(iface_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.301196771709442}, {"code": "static bool udc_req_iface(void){\n\tfor (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;\n\t\t\tiface_num++) {\n\t\tif (!udc_iface_enable(iface_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.301196771709442}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\tendpoint OUT reception\n *\n * Called by:\n * - enable interface\n * - at the end of previous command after sending the CSW\n */\nstatic void udi_msc_cbw_wait(void);\n\n/**\n * \\brief Callback called after CBW reception\n * Called by UDD when a transfer is finished or aborted\n *\n * \\param status       UDD_EP_TRANSFER_OK, if transfer is finished\n * \\param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted\n * \\param nb_received  number of data transferred\n */\nstatic void udi_msc_cbw_received(udd_ep_status_t status,\n    iram_size_t nb_received, udd_ep_id_t ep);\n\n/**\n * \\brief Function to check the CBW length and direction\n * Call it after SCSI command decode to check integrity of command\n *\n * \\param alloc_len  number of bytes that device want transfer\n * \\param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)\n *\n * \\retval true if the command can be processed\n */\nstatic bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);\n//@}", "CodeBleu_score": 15.994918653689721}, {"code": "bool udi_msc_enable(void){\n\tendpoint OUT reception\n *\n * Called by:\n * - enable interface\n * - at the end of previous command after sending the CSW\n */\nstatic void udi_msc_cbw_wait(void);\n\n/**\n * \\brief Callback called after CBW reception\n * Called by UDD when a transfer is finished or aborted\n *\n * \\param status       UDD_EP_TRANSFER_OK, if transfer is finished\n * \\param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted\n * \\param nb_received  number of data transferred\n */\nstatic void udi_msc_cbw_received(udd_ep_status_t status,\n    iram_size_t nb_received, udd_ep_id_t ep);\n\n/**\n * \\brief Function to check the CBW length and direction\n * Call it after SCSI command decode to check integrity of command\n *\n * \\param alloc_len  number of bytes that device want transfer\n * \\param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)\n *\n * \\retval true if the command can be processed\n */\nstatic bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);\n//@}", "CodeBleu_score": 15.994918653689721}, {"code": "bool udi_msc_enable(void){\n\tendpoint OUT reception\n *\n * Called by:\n * - enable interface\n * - at the end of previous command after sending the CSW\n */\nstatic void udi_msc_cbw_wait(void);\n\n/**\n * \\brief Callback called after CBW reception\n * Called by UDD when a transfer is finished or aborted\n *\n * \\param status       UDD_EP_TRANSFER_OK, if transfer is finished\n * \\param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted\n * \\param nb_received  number of data transferred\n */\nstatic void udi_msc_cbw_received(udd_ep_status_t status,\n    iram_size_t nb_received, udd_ep_id_t ep);\n\n/**\n * \\brief Function to check the CBW length and direction\n * Call it after SCSI command decode to check integrity of command\n *\n * \\param alloc_len  number of bytes that device want transfer\n * \\param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)\n *\n * \\retval true if the command can be processed\n */\nstatic bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);\n//@}", "CodeBleu_score": 15.994918653689721}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\terror reset by setup\n  udd_ep_set_halt(UDI_MSC_EP_OUT);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);\n}", "CodeBleu_score": 21.499994971794123}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\terror reset by setup\n  udd_ep_set_halt(UDI_MSC_EP_OUT);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);\n}", "CodeBleu_score": 21.499994971794123}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\terror reset by setup\n  udd_ep_set_halt(UDI_MSC_EP_OUT);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);\n}", "CodeBleu_score": 21.499994971794123}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t_IN);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);\n}", "CodeBleu_score": 3.4742125347274597}, {"code": "static void udi_msc_csw_process(void){\n\t_IN);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);\n}", "CodeBleu_score": 3.4742125347274597}, {"code": "static void udi_msc_csw_process(void){\n\t_IN);\n  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it\n  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);\n}", "CodeBleu_score": 3.4742125347274597}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tUNUSED(port);\n  if (!b_enable) {\n    // DTR is disabled, check if the DTR rate is 1200\n    if (dwDTERate == 1200) {\n      // DTR rate is 1200, schedule a delayed system reset\n      initiateReset();\n    }\n  } else {\n    // DTR is enabled, cancel any scheduled reset\n    cancelReset();\n  }\n}", "CodeBleu_score": 37.42971199483798}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tUNUSED(port);\n\t// Store last DTR status\n\tmain_b_dtr_active = b_enable;\n\n\t// If DTR is disabled and the DTR rate is 1200, schedule a delayed system reset\n\tif (!b_enable && dwDTERate == 1200) {\n\t\t// Write to the reset controller\n\t\tREG_WDT_CR = WDT_CR_WDRSTT | WDT_CR_KEY(0xA5);\n\t\t// Call initiateReset to schedule a system reset\n\t\tinitiateReset();\n\t}\n\t// If DTR is enabled, cancel any scheduled reset\n\telse if (b_enable) {\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 52.857189383277515}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tUNUSED(port);\n  // Store last DTR state\n  main_b_dtr_active = b_enable;\n\n  // If DTR is disabled and the DTR rate is 1200, schedule a delayed system reset\n  if (!b_enable && dwDTERate == 1200) {\n    initiateReset();\n  }\n}", "CodeBleu_score": 39.664238791310964}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t01;\n\n      // Schedule delayed reset\n      initiateReset(250);\n    }", "CodeBleu_score": 0.9005771560166175}, {"code": "bool usb_task_other_requests(void){\n\t01;\n\n      // Schedule delayed reset\n      initiateReset(250);\n    }", "CodeBleu_score": 0.9005771560166175}, {"code": "bool usb_task_other_requests(void){\n\t01;\n\n      // Schedule delayed reset\n      initiateReset(250);\n    }", "CodeBleu_score": 0.9005771560166175}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tn        break;\n      default:\n        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU\n        spiTransferTx = (pfnSpiTransfer)spiTransferX;\n        spiTransferRx = (pfnSpiTransfer)spiTransferX;\n        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;\n        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;\n        break;\n    }", "CodeBleu_score": 9.845620920108681}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tn        break;\n      default:\n        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU\n        spiTransferTx = (pfnSpiTransfer)spiTransferX;\n        spiTransferRx = (pfnSpiTransfer)spiTransferX;\n        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;\n        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;\n        break;\n    }", "CodeBleu_score": 9.845620920108681}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tn        break;\n      default:\n        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU\n        spiTransferTx = (pfnSpiTransfer)spiTransferX;\n        spiTransferRx = (pfnSpiTransfer)spiTransferX;\n        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;\n        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;\n        break;\n    }", "CodeBleu_score": 9.845620920108681}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler* isr_table = get_relocated_table_addr();\n  pfnISR_Handler oldHandler = isr_table[irq + 16];\n  isr_table[irq + 16] = newHandler;\n  return oldHandler;\n}", "CodeBleu_score": 68.27083024855484}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = nullptr;\n\n  pfnISR_Handler* isrtab = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  oldHandler = isrtab[irq + 16];\n\n  // Replace it with the new handler\n  isrtab[irq + 16] = newHandler;\n\n  // Re-enable global interrupts\n  CRITICAL_SECTION_END();\n\n  return oldHandler;\n}", "CodeBleu_score": 87.0767103784086}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = nullptr;\n  pfnISR_Handler* isr_table = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  oldHandler = isr_table[irq + 16];\n\n  // Replace it with the new handler\n  isr_table[irq + 16] = newHandler;\n\n  // Re-enable global interrupts\n  CRITICAL_SECTION_END();\n\n  return oldHandler;\n}", "CodeBleu_score": 78.62404981826168}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active()) return -1;\n  if (pending_char != -1) return pending_char;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  return pending_char = process_char(udi_cdc_getc());\n}", "CodeBleu_score": 46.04974600109352}, {"code": "int MarlinSerialUSB::peek(){\n\tif (!usb_task_cdc_isenabled()) return -1;\n  if (!usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  if (pending_char != -1) return pending_char;\n  return pending_char = udi_cdc_getc();\n}", "CodeBleu_score": 51.75799406818208}, {"code": "int MarlinSerialUSB::peek(){\n\tif (!usb_task_cdc_isenabled()) return -1;\n  if (!usb_task_cdc_dtr_active()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  if (pending_char != -1) return pending_char;\n  return pending_char = udi_cdc_getc();\n}", "CodeBleu_score": 51.75799406818208}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (pending_char >= 0) {\n    int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return pending_char;\n}", "CodeBleu_score": 76.75791601729223}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_char >= 0) {\n    const int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  const int c = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n  return c;\n}", "CodeBleu_score": 79.08201853815622}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_char >= 0) {\n    const int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  const int c = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n  return c;\n}", "CodeBleu_score": 79.08201853815622}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (pending_char >= 0) return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return 0;\n\n  return 1;\n}", "CodeBleu_score": 32.0897936836184}, {"code": "int MarlinSerialUSB::available(){\n\t// If there are pending characters, return the count\n  if (pending_char >= 0) return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return 0;\n\n  return 1;\n}", "CodeBleu_score": 32.3165160648935}, {"code": "int MarlinSerialUSB::available(){\n\tif (pending_char >= 0) return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled()) return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready()) return 0;\n\n  return 1;\n}", "CodeBleu_score": 32.0897936836184}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// Adjust this block header to include the next one\n            buffer[i + 2] += buffer[inext + 2] + 1;\n\n            // Store data at the right place\n            buffer[i + 3 + blen] = data;\n\n            // Remove the next block header and append its data\n            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);\n\n            // Finally, as we have saved 2 bytes at the end, make sure to clean them\n            buffer[iend - 2] = 0xFF;\n            buffer[iend - 1] = 0xFF;\n\n          }", "CodeBleu_score": 26.41845469129334}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// Adjust this block header to include the next one\n            buffer[i + 2] += buffer[inext + 2] + 1;\n\n            // Store data at the right place\n            buffer[i + 3 + blen] = data;\n\n            // Remove the next block header and append its data\n            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);\n\n            // Finally, as we have saved 2 bytes at the end, make sure to clean them\n            buffer[iend - 2] = 0xFF;\n            buffer[iend - 1] = 0xFF;\n\n          }", "CodeBleu_score": 26.41845469129334}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t// Adjust this block header to include the next one\n            buffer[i + 2] += buffer[inext + 2] + 1;\n\n            // Store data at the right place\n            buffer[i + 3 + blen] = data;\n\n            // Remove the next block header and append its data\n            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);\n\n            // Finally, as we have saved 2 bytes at the end, make sure to clean them\n            buffer[iend - 2] = 0xFF;\n            buffer[iend - 1] = 0xFF;\n\n          }", "CodeBleu_score": 26.41845469129334}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tn    // Change attenuation 100mV below the calibrated threshold\n    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);\n  }", "CodeBleu_score": 8.335003605447802}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tn    // Change attenuation 100mV below the calibrated threshold\n    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);\n  }", "CodeBleu_score": 8.335003605447802}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tn    // Change attenuation 100mV below the calibrated threshold\n    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);\n  }", "CodeBleu_score": 8.335003605447802}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_AFTER_MOVE_ARRAY_SIZE >= MAX_SERVOS, \"SERVO_DELAY_AFTER_MOVE_ARRAY_SIZE must be >= MAX_SERVOS\");\n  if (attach()) {\n    write(value);\n    delay(servo_delay_after_move[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 39.63383222938893}, {"code": "void Servo::move(const int value){\n\tstatic_assert(\n    NUM_SERVOS <= MAX_SERVOS,\n    \"MAX_SERVOS is too small for the number of servos.\"\n  );\n  if (channel < 0) return;\n  #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n    const bool detach = true;\n  #else\n    constexpr bool detach = false;\n  #endif\n  write(value);\n  if (detach) detach();\n  delay(servo_delay[channel]);\n}", "CodeBleu_score": 46.58045163735726}, {"code": "void Servo::move(const int value){\n\tstatic_assert(\n    NUM_SERVOS <= sizeof(servo_delay) / sizeof(servo_delay[0]),\n    \"SERVO_DELAY_MS array is too small\"\n  );\n\n  if (attach()) {\n    write(value);\n    delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 55.1558798854903}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t.desc[0];\n\n  // stop i2s\n  i2s_stop(I2S_NUM_0);\n\n  // configure I2S data port interface.\n  i2s_reset_fifo(I2S_NUM_0);\n\n  //reset i2s\n  I2S0.conf.tx_reset = 1;\n  I2S0.conf.tx_reset = 0;\n  I2S0.conf.rx_reset = 1;\n  I2S0.conf.rx_reset = 0;\n\n  //reset dma\n  I2S0.lc_conf.in_rst = 1;\n  I2S0.lc_conf.in_rst = 0;\n  I2S0.lc_conf.out_rst = 1;\n  I2S0.lc_conf.out_rst = 0;\n\n  //Enable and configure DMA\n  I2S0.lc_conf.check_owner = 0;\n  I2S0.lc_conf.out_loop_test = 0;\n  I2S0.lc_conf.out_auto_wrback = 0;\n  I2S0.lc_conf.out_data_burst_en = 0;\n  I2S0.lc_conf.outdscr_burst_en = 0;\n  I2S0.lc_conf.out_no_restart_clr = 0;\n  I2S0.lc_conf.indscr_burst_en = 0;\n  I2S0.lc_conf.out_eof_mode = 1;\n\n  I2S0.conf2.lcd_en = 0;\n  I2S0.conf2.camera_en = 0;\n  I2S0.pdm_conf.pcm2pdm_conv_en = 0;\n  I2S0.pdm_conf.pdm2pcm_conv_en = 0;\n\n  I2S0.fifo_conf.dscr_en = 0;\n\n  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);\n  I2S0.fifo_conf.tx_fifo_mod = 0;\n  I2S0.conf.tx_mono = 0;\n\n  I2S0.conf_chan.rx_chan_mod = 0;\n  I2S0.fifo_conf.rx_fifo_mod = 0;\n  I2S0.conf.rx_mono = 0;\n\n  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo\n\n  I2S0.conf.tx_start = 0;\n  I2S0.conf.rx_start = 0;\n\n  I2S0.conf.tx_msb_right = 1;\n  I2S0.conf.tx_right_first = 1;\n\n  I2S0.conf.tx_slave_mod = 0; // Master\n  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;\n\n  I2S0.pdm_conf.rx_pdm_en = 0;\n  I2S0.pdm_conf.tx_pdm_en = 0;\n\n  I2S0.conf.tx_short_sync = 0;\n  I2S0.conf.rx_short_sync = 0;\n  I2S0.conf.tx_msb_shift = 0;\n  I2S0.conf.rx_msb_shift = 0;\n\n  // set clock\n  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference\n  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256\n  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)\n  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset\n\n  // fbck = fi2s / tx_bck_div_num\n  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6\n\n  // Enable TX interrupts\n  I2S0.int_ena.out_eof = 1;\n  I2S0.int_ena.out_dscr_err = 0;\n  I2S0.int_ena.out_total_eof = 0;\n  I2S0.int_ena.out_done = 0;\n\n  // Allocate and Enable the I2S interrupt\n  intr_handle_t i2s_isr_handle;\n  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);\n  esp_intr_enable(i2s_isr_handle);\n\n  // Create the task that will feed the buffer\n  xTaskCreatePinnedToCore(stepperTask, \\\"StepperTask\\\", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin\n\n  // Route the i2s pins to the appropriate GPIO\n  // If a pin is not defined, no need to configure\n  #if defined(I2S_DATA) && I2S_DATA >= 0\n    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);\n  #endif\n  #if defined(I2S_BCK) && I2S_BCK >= 0\n    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);\n  #endif\n  #if defined(I2S_WS) && I2S_WS >= 0\n    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);\n  #endif\n\n  // Start the I2S peripheral\n  return i2s_start(I2S_NUM_0);\n}", "CodeBleu_score": 21.074838668585727}, {"code": "void i2s_push_sample(){\n\t.desc[0];\n\n  // stop i2s\n  i2s_stop(I2S_NUM_0);\n\n  // configure I2S data port interface.\n  i2s_reset_fifo(I2S_NUM_0);\n\n  //reset i2s\n  I2S0.conf.tx_reset = 1;\n  I2S0.conf.tx_reset = 0;\n  I2S0.conf.rx_reset = 1;\n  I2S0.conf.rx_reset = 0;\n\n  //reset dma\n  I2S0.lc_conf.in_rst = 1;\n  I2S0.lc_conf.in_rst = 0;\n  I2S0.lc_conf.out_rst = 1;\n  I2S0.lc_conf.out_rst = 0;\n\n  //Enable and configure DMA\n  I2S0.lc_conf.check_owner = 0;\n  I2S0.lc_conf.out_loop_test = 0;\n  I2S0.lc_conf.out_auto_wrback = 0;\n  I2S0.lc_conf.out_data_burst_en = 0;\n  I2S0.lc_conf.outdscr_burst_en = 0;\n  I2S0.lc_conf.out_no_restart_clr = 0;\n  I2S0.lc_conf.indscr_burst_en = 0;\n  I2S0.lc_conf.out_eof_mode = 1;\n\n  I2S0.conf2.lcd_en = 0;\n  I2S0.conf2.camera_en = 0;\n  I2S0.pdm_conf.pcm2pdm_conv_en = 0;\n  I2S0.pdm_conf.pdm2pcm_conv_en = 0;\n\n  I2S0.fifo_conf.dscr_en = 0;\n\n  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);\n  I2S0.fifo_conf.tx_fifo_mod = 0;\n  I2S0.conf.tx_mono = 0;\n\n  I2S0.conf_chan.rx_chan_mod = 0;\n  I2S0.fifo_conf.rx_fifo_mod = 0;\n  I2S0.conf.rx_mono = 0;\n\n  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo\n\n  I2S0.conf.tx_start = 0;\n  I2S0.conf.rx_start = 0;\n\n  I2S0.conf.tx_msb_right = 1;\n  I2S0.conf.tx_right_first = 1;\n\n  I2S0.conf.tx_slave_mod = 0; // Master\n  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;\n\n  I2S0.pdm_conf.rx_pdm_en = 0;\n  I2S0.pdm_conf.tx_pdm_en = 0;\n\n  I2S0.conf.tx_short_sync = 0;\n  I2S0.conf.rx_short_sync = 0;\n  I2S0.conf.tx_msb_shift = 0;\n  I2S0.conf.rx_msb_shift = 0;\n\n  // set clock\n  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference\n  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256\n  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)\n  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset\n\n  // fbck = fi2s / tx_bck_div_num\n  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6\n\n  // Enable TX interrupts\n  I2S0.int_ena.out_eof = 1;\n  I2S0.int_ena.out_dscr_err = 0;\n  I2S0.int_ena.out_total_eof = 0;\n  I2S0.int_ena.out_done = 0;\n\n  // Allocate and Enable the I2S interrupt\n  intr_handle_t i2s_isr_handle;\n  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);\n  esp_intr_enable(i2s_isr_handle);\n\n  // Create the task that will feed the buffer\n  xTaskCreatePinnedToCore(stepperTask, \\\"StepperTask\\\", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin\n\n  // Route the i2s pins to the appropriate GPIO\n  // If a pin is not defined, no need to configure\n  #if defined(I2S_DATA) && I2S_DATA >= 0\n    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);\n  #endif\n  #if defined(I2S_BCK) && I2S_BCK >= 0\n    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);\n  #endif\n  #if defined(I2S_WS) && I2S_WS >= 0\n    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);\n  #endif\n\n  // Start the I2S peripheral\n  return i2s_start(I2S_NUM_0);\n}", "CodeBleu_score": 21.074838668585727}, {"code": "void i2s_push_sample(){\n\t.desc[0];\n\n  // stop i2s\n  i2s_stop(I2S_NUM_0);\n\n  // configure I2S data port interface.\n  i2s_reset_fifo(I2S_NUM_0);\n\n  //reset i2s\n  I2S0.conf.tx_reset = 1;\n  I2S0.conf.tx_reset = 0;\n  I2S0.conf.rx_reset = 1;\n  I2S0.conf.rx_reset = 0;\n\n  //reset dma\n  I2S0.lc_conf.in_rst = 1;\n  I2S0.lc_conf.in_rst = 0;\n  I2S0.lc_conf.out_rst = 1;\n  I2S0.lc_conf.out_rst = 0;\n\n  //Enable and configure DMA\n  I2S0.lc_conf.check_owner = 0;\n  I2S0.lc_conf.out_loop_test = 0;\n  I2S0.lc_conf.out_auto_wrback = 0;\n  I2S0.lc_conf.out_data_burst_en = 0;\n  I2S0.lc_conf.outdscr_burst_en = 0;\n  I2S0.lc_conf.out_no_restart_clr = 0;\n  I2S0.lc_conf.indscr_burst_en = 0;\n  I2S0.lc_conf.out_eof_mode = 1;\n\n  I2S0.conf2.lcd_en = 0;\n  I2S0.conf2.camera_en = 0;\n  I2S0.pdm_conf.pcm2pdm_conv_en = 0;\n  I2S0.pdm_conf.pdm2pcm_conv_en = 0;\n\n  I2S0.fifo_conf.dscr_en = 0;\n\n  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);\n  I2S0.fifo_conf.tx_fifo_mod = 0;\n  I2S0.conf.tx_mono = 0;\n\n  I2S0.conf_chan.rx_chan_mod = 0;\n  I2S0.fifo_conf.rx_fifo_mod = 0;\n  I2S0.conf.rx_mono = 0;\n\n  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo\n\n  I2S0.conf.tx_start = 0;\n  I2S0.conf.rx_start = 0;\n\n  I2S0.conf.tx_msb_right = 1;\n  I2S0.conf.tx_right_first = 1;\n\n  I2S0.conf.tx_slave_mod = 0; // Master\n  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;\n\n  I2S0.pdm_conf.rx_pdm_en = 0;\n  I2S0.pdm_conf.tx_pdm_en = 0;\n\n  I2S0.conf.tx_short_sync = 0;\n  I2S0.conf.rx_short_sync = 0;\n  I2S0.conf.tx_msb_shift = 0;\n  I2S0.conf.rx_msb_shift = 0;\n\n  // set clock\n  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference\n  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256\n  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)\n  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset\n\n  // fbck = fi2s / tx_bck_div_num\n  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6\n\n  // Enable TX interrupts\n  I2S0.int_ena.out_eof = 1;\n  I2S0.int_ena.out_dscr_err = 0;\n  I2S0.int_ena.out_total_eof = 0;\n  I2S0.int_ena.out_done = 0;\n\n  // Allocate and Enable the I2S interrupt\n  intr_handle_t i2s_isr_handle;\n  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);\n  esp_intr_enable(i2s_isr_handle);\n\n  // Create the task that will feed the buffer\n  xTaskCreatePinnedToCore(stepperTask, \\\"StepperTask\\\", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin\n\n  // Route the i2s pins to the appropriate GPIO\n  // If a pin is not defined, no need to configure\n  #if defined(I2S_DATA) && I2S_DATA >= 0\n    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);\n  #endif\n  #if defined(I2S_BCK) && I2S_BCK >= 0\n    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);\n  #endif\n  #if defined(I2S_WS) && I2S_WS >= 0\n    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);\n  #endif\n\n  // Start the I2S peripheral\n  return i2s_start(I2S_NUM_0);\n}", "CodeBleu_score": 21.074838668585727}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n  uint64_t count;\n  timer_get_counter_value(timer.group, timer.idx, &count);\n  return count;\n}", "CodeBleu_score": 82.90299767074694}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t count;\n  timer_get_counter_value(timer.group, timer.idx, &count);\n\n  return count;\n}", "CodeBleu_score": 82.90299767074694}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t count_value;\n  timer_get_counter_value(timer.group, timer.idx, &count_value);\n\n  return count_value;\n}", "CodeBleu_score": 85.72695487801299}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    uint8_t e = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = e;\n    crc16(crc, &e, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 86.47184623482694}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    const uint8_t e = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = e;\n    crc16(crc, &e, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.92773458588036}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t * const base = (uint8_t *)HAL_eeprom_data;\n  for (size_t i = 0; i < size; i++) {\n    const uint8_t e = base[pos + i];\n    if (writing) value[i] = e;\n    crc16(crc, &e, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 81.0305157782064}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 91.72417404280728}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 91.72417404280728}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tCORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.01487595230046}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TEMP_TIMER:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      break;\n    case STEP_TIMER:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      break;\n    default:\n      HAL_assert(false);\n  }\n}", "CodeBleu_score": 21.12292646295565}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TEMP_TIMER_NUM:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      break;\n    case STEP_TIMER_NUM:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      break;\n    default:\n      HAL_assert(false);\n  }\n}", "CodeBleu_score": 21.581754070631128}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TEMP_TIMER:\n      temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n      NVIC_SetPriority(TIMER02A_IRQn, TEMP_TIMER_PRIO);\n      break;\n    case STEP_TIMER:\n      step_timer.start(frequency, STEP_TIMER_PRESCALE);\n      NVIC_SetPriority(TIMER02B_IRQn, STEP_TIMER_PRIO);\n      break;\n    default:\n      HAL_ASSERT(false);\n  }\n}", "CodeBleu_score": 28.626907409431478}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tFILE *eeprom_file = fopen(filename, \"rb\");\n  if (!eeprom_file) return false;\n  size_t size = fread(buffer, 1, capacity(), eeprom_file);\n  if (size < capacity())\n    memset(buffer + size, eeprom_default_erase_value, capacity() - size);\n  fclose(eeprom_file);\n  return true;\n}", "CodeBleu_score": 38.7438821793854}, {"code": "bool PersistentStore::access_start(){\n\tconst int eeprom_fd = HAL::eeprom_open(filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n  if (eeprom_fd < 0) return false;\n\n  const size_t file_size = lseek(eeprom_fd, 0, SEEK_END);\n  if (file_size < capacity()) {\n    // The file is smaller than the expected EEPROM size.\n    // Fill the remainder of the buffer with a default erase value.\n    const uint8_t default_erase_value = 0xFF;\n    lseek(eeprom_fd, file_size, SEEK_SET);\n    for (size_t i = file_size; i < capacity(); i++)\n      write(eeprom_fd, &default_erase_value, 1);\n  }\n  else if (file_size > capacity()) {\n    // The file is larger than the expected EEPROM size.\n    // Truncate the file to the expected size.\n    lseek(eeprom_fd, capacity(), SEEK_SET);\n    ftruncate(eeprom_fd, capacity());\n  }\n\n  lseek(eeprom_fd, 0, SEEK_SET);\n  read(eeprom_fd, buffer, capacity());\n\n  HAL::eeprom_close(eeprom_fd);\n  return true;\n}", "CodeBleu_score": 46.21138222417434}, {"code": "bool PersistentStore::access_start(){\n\tFILE *eeprom_file = fopen(filename, \"rb\");\n  if (!eeprom_file) return false;\n  size_t size = fread(buffer, 1, capacity(), eeprom_file);\n  if (size < capacity()) memset(buffer + size, 0xFF, capacity() - size);\n  fclose(eeprom_file);\n  return true;\n}", "CodeBleu_score": 37.20605432693616}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n  uint8_t bit = 0;\n  for (bit = 0; bit < 8; bit++) {\n    WRITE(SD_SCK_PIN, LOW);\n    WRITE(SD_MOSI_PIN, (b & 0x80) != 0);\n    WRITE(SD_SCK_PIN, HIGH);\n    r = (r << 1) | READ(SD_MISO_PIN);\n    b <<= 1;\n  }\n  delaySPIFunc();\n  return r;\n}", "CodeBleu_score": 57.14660462153854}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n  uint8_t i;\n  for (i = 0; i < 8; i++) {\n    OUT_WRITE(SD_SCK_PIN, LOW);\n    if (b & 0x80)\n      OUT_WRITE(SD_MOSI_PIN, HIGH);\n    else\n      OUT_WRITE(SD_MOSI_PIN, LOW);\n    DELAY_NS(125);\n    OUT_WRITE(SD_SCK_PIN, HIGH);\n    DELAY_NS(125);\n    r = (r << 1) | (IN_READ(SD_MISO_PIN) ? 1 : 0);\n    b <<= 1;\n  }\n  DELAY_NS(125);\n  return r;\n}", "CodeBleu_score": 50.7851131580717}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n  for (uint8_t i = 0; i < 8; i++) {\n    WRITE(SD_SCK_PIN, LOW);\n    WRITE(SD_MOSI_PIN, TEST(b, 7));\n    delaySPIFunc();\n    WRITE(SD_SCK_PIN, HIGH);\n    r <<= 1;\n    if (READ(SD_MISO_PIN))\n      r |= 1;\n    b <<= 1;\n  }\n  return r;\n}", "CodeBleu_score": 57.24237190229531}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\n    assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE)\n        RCC->AHBENR |= RCC_AHBPeriph;\n    else\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 94.16707002156322}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t// Check the parameters\n    assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE)\n        RCC->AHBENR |= RCC_AHBPeriph;\n    else\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 94.16707002156322}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = obj->rx_buff.head;\n  if (obj->rx_buff.data[c] == SERIAL_PARITY_ERR) {\n    SERIAL_ERROR_START();\n    SERIAL_ERRORLNPGM(STR_ERR_RX_PARITY);\n    SERIAL_ERROR_END();\n  }\n  else {\n    #if ENABLED(EMERGENCY_PARSER)\n      emergency_parser.update(obj->rx_buff.data[c]);\n    #endif\n    if (obj->rx_buff.head < (SERIAL_RX_BUFFER_SIZE - 1)) {\n      obj->rx_buff.head++;\n      obj->rx_buff.data[c + 1] = 0;\n    }\n    else {\n      SERIAL_ERROR_START();\n      SERIAL_ERRORLNPGM(STR_ERR_RX_OVERRUNS);\n      SERIAL_ERROR_END();\n      obj->rx_buff.head = 0;\n      obj->rx_buff.data[0] = 0;\n    }\n  }\n}", "CodeBleu_score": 39.62824233009526}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = serial_getc(obj);\n  if (c == 0x18) {\n    #if ENABLED(EMERGENCY_PARSER)\n      emergency_parser.update(c);\n    #endif\n    return;\n  }\n\n  if (c == '\\r') return;\n\n  if (c == '\n') c = '\\r';\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    // ERROR: NO SPACE\n    return;\n  }\n\n  rx_buffer[rx_buffer_head] = c;\n  rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n}", "CodeBleu_score": 35.25629696144223}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t// Read the received byte\n  const uint8_t c = (uint8_t)USART_RDR(obj->serial);\n\n  // Check for errors\n  if (USART_ISR(obj->serial) & (USART_ISR_PE | USART_ISR_FE)) {\n    // If a parity error occurs, read the byte and discard it\n    USART_RDR(obj->serial);\n    SERIAL_ERROR_START();\n    SERIAL_ERRORLNPGM(STR_ERR_RX_PARITY);\n    SERIAL_ERROR_END();\n  }\n  else {\n    // If no error occurs, read the byte and store it in the buffer\n    obj->rx_buffer[obj->rx_buffer_head] = c;\n\n    // Update the head pointer\n    obj->rx_buffer_head = (obj->rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\n    // If the head just wrapped around, the buffer is full\n    if (obj->rx_buffer_head == obj->rx_buffer_tail)\n      obj->rx_buffer_overflow = true;\n\n    // Update the emergency parser\n    TERN_(EMERGENCY_PARSER, _serial.update(c));\n  }\n\n  // Clear the interrupt flag\n  USART_ICR(obj->serial) = USART_ICR_PECF | USART_ICR_FECF;\n}", "CodeBleu_score": 41.11878476875488}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tSERIAL_TIMER_IRQ_PRIO\n    #define SWSERIAL_TIMER_IRQ_PRIO SWSERIAL_TIMER_IRQ_PRIO_DEFAULT\n  #endif", "CodeBleu_score": 3.346291866472951}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tSERIAL_TIMER_IRQ_PRIO\n    #define SWSERIAL_TIMER_IRQ_PRIO SWSERIAL_TIMER_IRQ_PRIO_DEFAULT\n  #endif", "CodeBleu_score": 3.346291866472951}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tSERIAL_TIMER_IRQ_PRIO\n    #define SWSERIAL_TIMER_IRQ_PRIO SWSERIAL_TIMER_IRQ_PRIO_DEFAULT\n  #endif", "CodeBleu_score": 3.346291866472951}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tIf the substring is not found, this returns -1.", "CodeBleu_score": 2.2148463648035204}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tIf the substring is not found, this returns -1.", "CodeBleu_score": 2.2148463648035204}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tIf the substring is not found, this returns -1.", "CodeBleu_score": 2.2148463648035204}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Set the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crINT | i2c.crSTA | i2c.crEN)\n\n\t// Wait for the start condition to be transmitted by checking the interrupt flag.\n\tfor !i2c.srReg.HasBits(i2c.srINT) {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and sends it.\n\ti2c.drReg.Set(uint8(address<<1) | uint8(b2i(write)))\n\n\t// Wait for the address to be transmitted by checking the interrupt flag.\n\tfor !i2c.srReg.HasBits(i2c.srINT) {\n\t}\n}", "CodeBleu_score": 46.49828190629946}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag.\n\ti2c.crReg.Set(i2c.crINT)\n\t// Set the start condition.\n\ti2c.crReg.Set(i2c.crSTA)\n\t// Wait for the start condition to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srINT) {\n\t}\n\t// Clear the interrupt flag.\n\ti2c.crReg.Set(i2c.crINT)\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed.\n\ti2c.drReg.Set(uint8(address << 1) | b2i(write))\n\t// Wait for the address to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srINT) {\n\t}\n}", "CodeBleu_score": 37.39917996770139}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag.\n\ti2c.crReg.ClearBits(i2c.crINT)\n\n\t// Send a start condition.\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Wait for the start condition to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\n\t// Write the address of the peripheral.\n\ti2c.drReg.Set(address << 1)\n\tif !write {\n\t\ti2c.drReg.SetBits(1)\n\t}\n\n\t// Wait for the address to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srPS0) {\n\t}\n\n\t// Enable the I2C module.\n\ti2c.crReg.SetBits(i2c.crEN)\n}", "CodeBleu_score": 37.30632688643647}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.04571309596861}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.04571309596861}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.04571309596861}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Default I2C pins if not set.\n\tif config.SDA == 0 && config.SCL == 0 {\n\t\tconfig.SDA = SDA_PIN\n\t\tconfig.SCL = SCL_PIN\n\t}\n\n\t// do config\n\tsclPort, sclPin := config.SCL.getPortPin()\n\tsclPort.PIN_CNF[sclPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\tsdaPort, sdaPin := config.SDA.getPortPin()\n\tsdaPort.PIN_CNF[sdaPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\ti2c.setPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 19.35009660654716}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Default I2C pins if not set.\n\tif config.SDA == 0 && config.SCL == 0 {\n\t\tconfig.SDA = SDA_PIN\n\t\tconfig.SCL = SCL_PIN\n\t}\n\n\t// do config\n\tsclPort, sclPin := config.SCL.getPortPin()\n\tsclPort.PIN_CNF[sclPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\tsdaPort, sdaPin := config.SDA.getPortPin()\n\tsdaPort.PIN_CNF[sdaPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\ti2c.setPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 19.35009660654716}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Default I2C pins if not set.\n\tif config.SDA == 0 && config.SCL == 0 {\n\t\tconfig.SDA = SDA_PIN\n\t\tconfig.SCL = SCL_PIN\n\t}\n\n\t// do config\n\tsclPort, sclPin := config.SCL.getPortPin()\n\tsclPort.PIN_CNF[sclPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\tsdaPort, sdaPin := config.SDA.getPortPin()\n\tsdaPort.PIN_CNF[sdaPin].Set((nrf.GPIO_PIN_CNF_DIR_Input << nrf.GPIO_PIN_CNF_DIR_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_INPUT_Connect << nrf.GPIO_PIN_CNF_INPUT_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_PULL_Pullup << nrf.GPIO_PIN_CNF_PULL_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_DRIVE_S0D1 << nrf.GPIO_PIN_CNF_DRIVE_Pos) |\n\t\t(nrf.GPIO_PIN_CNF_SENSE_Disabled << nrf.GPIO_PIN_CNF_SENSE_Pos))\n\n\ti2c.setPins(config.SCL, config.SDA)\n\n\ti2c.mode = config.Mode\n\tif i2c.mode == I2CModeController {\n\t\ti2c.SetBaudRate(config.Frequency)\n\n\t\ti2c.enableAsController()\n\t} else {\n\t\ti2c.enableAsTarget()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 19.35009660654716}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor to avoid race conditions.\n\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\t// Try to open the directory.\n\tdir, err := syscall.Fdopendir(dup)\n\tif err == nil {\n\t\treturn uintptr(dir), \"\", nil\n\t}\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(dup)\n\t// Check for errors other than \"syscall.EINTR\".\n\tif err != syscall.EINTR {\n\t\treturn 0, \"opendir\", err\n\t}\n\t// Try again.\n\treturn darwinOpenDir(fd)\n}", "CodeBleu_score": 60.76627643768412}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor.\n\tnewfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\t// Attempt to open the directory.\n\tdir := uintptr(0)\n\tfor {\n\t\t// Call syscall.Fdopendir.\n\t\tdir, err = syscall.Fdopendir(newfd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Check for \"syscall.EINTR\".\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(newfd)\n\t\t\treturn 0, \"fdopendir\", err\n\t\t}\n\t}\n\n\t// Return the directory pointer.\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 73.19793985743034}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor to avoid race conditions with the caller.\n\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\n\t// Try to open the directory.\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dup)\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(dup)\n\n\t// Return the directory pointer or error.\n\tif err != nil {\n\t\treturn 0, \"Fdopendir\", err\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 82.88808520472519}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tinclude \\\"Esp.h\\\"", "CodeBleu_score": 2.128391891798727}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tinclude \\\"Esp.h\\\"", "CodeBleu_score": 2.128391891798727}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tinclude \\\"Esp.h\\\"", "CodeBleu_score": 2.128391891798727}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tense\\\");", "CodeBleu_score": 2.838583742703172}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tense\\\");", "CodeBleu_score": 2.838583742703172}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tense\\\");", "CodeBleu_score": 2.838583742703172}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\\\"APP size: %u (%u sectors)\\\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\\\"APP partition not found. Reading disabled\\\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\\\"OTA size: %u (%u sectors)\\\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\\\"OTA partition not found. Writing disabled\\\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\\\"USING FAT16\\\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\\\"USING FAT12\\\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\\\"FAT sector size: %u\\\", DISK_SECTOR_SIZE);\n  log_d(\\\"FAT data sectors: %u\\\", data_sectors);\n  log_d(\\\"FAT table sectors: %u\\\", msc_table_sectors);\n  log_d(\\\"FAT total sectors: %u (%uKB)\\\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}", "CodeBleu_score": 27.765865256435994}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\\\"APP size: %u (%u sectors)\\\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\\\"APP partition not found. Reading disabled\\\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\\\"OTA size: %u (%u sectors)\\\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\\\"OTA partition not found. Writing disabled\\\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\\\"USING FAT16\\\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\\\"USING FAT12\\\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\\\"FAT sector size: %u\\\", DISK_SECTOR_SIZE);\n  log_d(\\\"FAT data sectors: %u\\\", data_sectors);\n  log_d(\\\"FAT table sectors: %u\\\", msc_table_sectors);\n  log_d(\\\"FAT total sectors: %u (%uKB)\\\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}", "CodeBleu_score": 27.765865256435994}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\\\"APP size: %u (%u sectors)\\\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\\\"APP partition not found. Reading disabled\\\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\\\"OTA size: %u (%u sectors)\\\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\\\"OTA partition not found. Writing disabled\\\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\\\"USING FAT16\\\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\\\"USING FAT12\\\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\\\"FAT sector size: %u\\\", DISK_SECTOR_SIZE);\n  log_d(\\\"FAT data sectors: %u\\\", data_sectors);\n  log_d(\\\"FAT table sectors: %u\\\", msc_table_sectors);\n  log_d(\\\"FAT total sectors: %u (%uKB)\\\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}", "CodeBleu_score": 27.765865256435994}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n  size_t len = strlen(in);\n  while (i < len && j < maxlen) {\n    unsigned char c = in[i++];\n    unsigned char byte = hex_char_to_byte(c);\n    if (byte > 0x0f) {\n      continue;\n    }\n    if (i == len) {\n      break;\n    }\n    c = in[i++];\n    byte = byte << 4 | hex_char_to_byte(c);\n    if (byte > 0xff) {\n      continue;\n    }\n    out[j++] = byte;\n  }\n  return j;\n}", "CodeBleu_score": 45.723888256844496}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  while (*in && len < maxlen) {\n    unsigned char c = (unsigned char)*in;\n    unsigned char v = hex_char_to_byte(c);\n    if (v > 0x0f) {\n      in++;\n      continue;\n    }\n    if (len % 2 == 0) {\n      *out = v << 4;\n    } else {\n      *out++ |= v;\n    }\n    len++;\n    in++;\n  }\n  return len;\n}", "CodeBleu_score": 49.242797639410426}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n  while (in[i] && j < maxlen) {\n    uint8_t c = hex_char_to_byte(in[i++]);\n    if (c < 0x10) {\n      if (in[i] == 0) {\n        // if we have an odd number of hex digits, and the last digit\n        // is a valid hex digit, then we'll end up here with c < 0x10.\n        // in this case we'll just ignore the last digit.\n        break;\n      }\n      uint8_t c2 = hex_char_to_byte(in[i++]);\n      if (c2 >= 0x10) {\n        // invalid hex digit\n        continue;\n      }\n      out[j++] = (c << 4) | c2;\n    }\n  }\n  return j;\n}", "CodeBleu_score": 48.350981570771054}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tn  //  SOF_TIMEOUT = 5;\n}", "CodeBleu_score": 3.2805215944581354}, {"code": "int HWCDC::availableForWrite(void){\n\tn  //  SOF_TIMEOUT = 5;\n}", "CodeBleu_score": 3.2805215944581354}, {"code": "int HWCDC::availableForWrite(void){\n\tn  //  SOF_TIMEOUT = 5;\n}", "CodeBleu_score": 3.2805215944581354}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  if (_uart != NULL) {\n    // set FIFO full threshold to the number of bytes in the buffer\n    _rxFIFOFull = _rxBufferSize;\n    // set timeout behavior based on onlyOnTimeout\n    _onReceiveTimeout = onlyOnTimeout;\n    // set timeout to _rxTimeout\n    _uart->rx_param.timeout_thresh = _rxTimeout;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_TOUT_EN;\n    // set timeout type to receive timeout\n    _uart->rx_param.timeout_en = UART_RX_", "CodeBleu_score": 50.14870479298423}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  if (onlyOnTimeout) {\n    _rxFIFOFull = 0;\n    _onReceiveTimeout = true;\n  } else {\n    _rxFIFOFull = 255;\n    _onReceiveTimeout = false;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 55.457162696115205}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tHSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  // configure timeout behavior\n  if (onlyOnTimeout) {\n    _rxTimeout = 0;\n  } else {\n    _rxTimeout = 2;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 46.398772090157756}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\ttarget), NULL, 0);\n}", "CodeBleu_score": 4.38763997183281}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\ttarget), NULL, 0);\n}", "CodeBleu_score": 4.38763997183281}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\ttarget), NULL, 0);\n}", "CodeBleu_score": 4.38763997183281}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone was called\");\n  if (_pin == -1) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else {\n    log_e(\"Tone is already running on pin %d. Call noTone() first.\", _pin);\n  }\n}", "CodeBleu_score": 62.956364504562025}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone was called\");\n  if (tone_init()) {\n    tone_msg_t tone_msg = {\n      .tone_cmd = TONE_START,\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration,\n    };\n    xQueueReset(_tone_queue);  // clear queue\n    xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n  }\n}", "CodeBleu_score": 51.82285626894251}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_d(\"tone was called\");\n  if (_pin == -1) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else {\n    log_e(\"Tone is already running on pin %d. Use noTone to stop it first.\", _pin);\n  }\n}", "CodeBleu_score": 62.8905588396761}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tPUSB::ESPUSB(size_t task_stack_size, uint8_t event_task_priority)\n  : vid(USB_VID), pid(USB_PID), product_name(USB_PRODUCT), manufacturer_name(USB_MANUFACTURER), serial_number(USB_SERIAL), fw_version(0x0100),\n    usb_version(0x0200)  // at least 2.1 or 3.x for BOS & webUSB\n    ,\n    usb_class(TUSB_CLASS_MISC), usb_subclass(MISC_SUBCLASS_COMMON), usb_protocol(MISC_PROTOCOL_IAD), usb_attributes(TUSB_DESC_CONFIG_ATT_SELF_POWERED),\n    usb_power_ma(500), webusb_enabled(USB_WEBUSB_ENABLED), webusb_url(USB_WEBUSB_URL), _started(false), _task_stack_size(task_stack_size),\n    _event_task_priority(event_task_priority) {\n  if (!arduino_usb_event_loop_handle) {\n    esp_event_loop_args_t event_task_args = {\n      .queue_size = 5,\n      .task_name = \\\"arduino_usb_events\\\",\n      .task_priority = _event_task_priority,\n      .task_stack_size = _task_stack_size,\n      .task_core_id = tskNO_AFFINITY\n    };\n    if (esp_event_loop_create(&event_task_args, &arduino_usb_event_loop_handle) != ESP_OK) {\n      log_e(\\\"esp_event_loop_create failed\\\");\n    }\n  }\n}\n", "CodeBleu_score": 37.441755404564354}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tPUSB::ESPUSB(size_t task_stack_size, uint8_t event_task_priority)\n  : vid(USB_VID), pid(USB_PID), product_name(USB_PRODUCT), manufacturer_name(USB_MANUFACTURER), serial_number(USB_SERIAL), fw_version(0x0100),\n    usb_version(0x0200)  // at least 2.1 or 3.x for BOS & webUSB\n    ,\n    usb_class(TUSB_CLASS_MISC), usb_subclass(MISC_SUBCLASS_COMMON), usb_protocol(MISC_PROTOCOL_IAD), usb_attributes(TUSB_DESC_CONFIG_ATT_SELF_POWERED),\n    usb_power_ma(500), webusb_enabled(USB_WEBUSB_ENABLED), webusb_url(USB_WEBUSB_URL), _started(false), _task_stack_size(task_stack_size),\n    _event_task_priority(event_task_priority) {\n  if (!arduino_usb_event_loop_handle) {\n    esp_event_loop_args_t event_task_args = {\n      .queue_size = 5,\n      .task_name = \\\"arduino_usb_events\\\",\n      .task_priority = _event_task_priority,\n      .task_stack_size = _task_stack_size,\n      .task_core_id = tskNO_AFFINITY\n    };\n    if (esp_event_loop_create(&event_task_args, &arduino_usb_event_loop_handle) != ESP_OK) {\n      log_e(\\\"esp_event_loop_create failed\\\");\n    }\n  }\n}\n", "CodeBleu_score": 37.441755404564354}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tPUSB::ESPUSB(size_t task_stack_size, uint8_t event_task_priority)\n  : vid(USB_VID), pid(USB_PID), product_name(USB_PRODUCT), manufacturer_name(USB_MANUFACTURER), serial_number(USB_SERIAL), fw_version(0x0100),\n    usb_version(0x0200)  // at least 2.1 or 3.x for BOS & webUSB\n    ,\n    usb_class(TUSB_CLASS_MISC), usb_subclass(MISC_SUBCLASS_COMMON), usb_protocol(MISC_PROTOCOL_IAD), usb_attributes(TUSB_DESC_CONFIG_ATT_SELF_POWERED),\n    usb_power_ma(500), webusb_enabled(USB_WEBUSB_ENABLED), webusb_url(USB_WEBUSB_URL), _started(false), _task_stack_size(task_stack_size),\n    _event_task_priority(event_task_priority) {\n  if (!arduino_usb_event_loop_handle) {\n    esp_event_loop_args_t event_task_args = {\n      .queue_size = 5,\n      .task_name = \\\"arduino_usb_events\\\",\n      .task_priority = _event_task_priority,\n      .task_stack_size = _task_stack_size,\n      .task_core_id = tskNO_AFFINITY\n    };\n    if (esp_event_loop_create(&event_task_args, &arduino_usb_event_loop_handle) != ESP_OK) {\n      log_e(\\\"esp_event_loop_create failed\\\");\n    }\n  }\n}\n", "CodeBleu_score": 37.441755404564354}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t0; i < copySize; i++) {\n            uint8_t ch = 0;\n            xQueueReceive(rx_queue, &ch, 0);\n            if (!xQueueSend(new_rx_queue, &ch, 0)) {\n              arduino_usb_cdc_event_data_t p;\n              p.rx_overflow.dropped_bytes = copySize - i;\n              arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n              log_e(\\\"CDC RX Overflow.\\\");\n              break;\n            }\n          }\n        }", "CodeBleu_score": 35.86730795853498}, {"code": "void USBCDC::_onRX(){\n\t0; i < copySize; i++) {\n            uint8_t ch = 0;\n            xQueueReceive(rx_queue, &ch, 0);\n            if (!xQueueSend(new_rx_queue, &ch, 0)) {\n              arduino_usb_cdc_event_data_t p;\n              p.rx_overflow.dropped_bytes = copySize - i;\n              arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n              log_e(\\\"CDC RX Overflow.\\\");\n              break;\n            }\n          }\n        }", "CodeBleu_score": 35.86730795853498}, {"code": "void USBCDC::_onRX(){\n\t0; i < copySize; i++) {\n            uint8_t ch = 0;\n            xQueueReceive(rx_queue, &ch, 0);\n            if (!xQueueSend(new_rx_queue, &ch, 0)) {\n              arduino_usb_cdc_event_data_t p;\n              p.rx_overflow.dropped_bytes = copySize - i;\n              arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n              log_e(\\\"CDC RX Overflow.\\\");\n              break;\n            }\n          }\n        }", "CodeBleu_score": 35.86730795853498}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tn}", "CodeBleu_score": 6.732822916177208}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tn}", "CodeBleu_score": 6.732822916177208}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tn}", "CodeBleu_score": 6.732822916177208}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t/:a\\\", a.robeaux)\n}", "CodeBleu_score": 3.6292410274637144}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t/:a\\\", a.robeaux)\n}", "CodeBleu_score": 3.6292410274637144}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t/:a\\\", a.robeaux)\n}", "CodeBleu_score": 3.6292410274637144}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\\\": gobot.NewJSONMaster(a.master).Commands}", "CodeBleu_score": 5.554519118485905}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\\\": gobot.NewJSONMaster(a.master).Commands}", "CodeBleu_score": 5.554519118485905}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\\\": gobot.NewJSONMaster(a.master).Commands}", "CodeBleu_score": 5.554519118485905}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\t// Check for valid credentials\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Proceed to next handler\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.65698639064149}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler, which can be another middleware in the chain, or the final handler.\n\t\tnext := r.Context().Value(http.ServerContextKey).(http.Handler)\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 49.34290987179022}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tc, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\ts := string(c)\n\t\ti := strings.IndexByte(s, ':')\n\t\tif i < 0 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(s[:i])) != 1 ||\n\t\t\tsubtle.ConstantTimeCompare([]byte(password), []byte(s[i+1:])) != 1 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authorized\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.93018909842376}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\n//\t\\\"WithName\\\"", "CodeBleu_score": 2.8089516377280894}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\n//\t\\\"WithName\\\"", "CodeBleu_score": 2.8089516377280894}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\n//\t\\\"WithName\\\"", "CodeBleu_score": 2.8089516377280894}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 78.94567460585272}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 67.89758457915693}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 78.94567460585272}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\tif err := d.writeByteData(regCommand, commandSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandSoftReset == commandSoftReset {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 77.94352795567451}, {"code": "func (d *MFRC522Common) softReset() error{\n\tif err := d.writeByteData(regCommand, commandRegSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegSoftReset == commandRegSoftReset {\n\t\treturn errors.New(\"soft reset took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 79.80122323483985}, {"code": "func (d *MFRC522Common) softReset() error{\n\tif err := d.writeByteData(regCommand, commandRegSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&commandRegPowerDownBit == commandRegPowerDownBit {\n\t\treturn errors.New(\"soft reset took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 81.33643485431557}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tBit | comIEnRegLoAlertIEnBit\n\t\tirqEn = irqEn | comIEnRegIdleIEnBit | comIEnRegRxIEnBit | comIEnRegTxIEnBit\n\t\twaitIRq = uint8(comIrqRegIdleIRqBit | comIrqRegRxIRqBit)\n\t}", "CodeBleu_score": 9.327571310988032}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tBit | comIEnRegLoAlertIEnBit\n\t\tirqEn = irqEn | comIEnRegIdleIEnBit | comIEnRegRxIEnBit | comIEnRegTxIEnBit\n\t\twaitIRq = uint8(comIrqRegIdleIRqBit | comIrqRegRxIRqBit)\n\t}", "CodeBleu_score": 9.327571310988032}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tBit | comIEnRegLoAlertIEnBit\n\t\tirqEn = irqEn | comIEnRegIdleIEnBit | comIEnRegRxIEnBit | comIEnRegTxIEnBit\n\t\twaitIRq = uint8(comIrqRegIdleIRqBit | comIrqRegRxIRqBit)\n\t}", "CodeBleu_score": 9.327571310988032}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t.\n\tpiccCommandMFRegAUTHRegKEYRegA = 0x60 // Perform authentication with Key A\n\tpiccCommandMFRegAUTHRegKEYRegB = 0x61 // Perform authentication with Key B\n\t// Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\n\tpiccCommandMFRegREAD = 0x30\n\t// Writes one 16 byte block to the authenticated sector of the PICC. Called \\\"COMPATIBILITY WRITE\\\" for MIFARE Ultralight.\n\tpiccCommandMFRegWRITE     = 0xA0\n\tpiccWriteAck              = 0x0A // MIFARE Classic: 4 bit ACK, we use any other value as NAK (data sheet: 0h to 9h, Bh to Fh)\n\tpiccCommandMFRegDECREMENT = 0xC0 // Decrements the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegINCREMENT = 0xC1 // Increments the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegRESTORE   = 0xC2 // Reads the contents of a block into the internal data register.\n\tpiccCommandMFRegTRANSFER  = 0xB0 // Writes the contents of the internal data register to a block.\n\t// The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/dataRegsheet/MF0ICU1.pdf, Section 8.6)\n\t// The piccCommandMFRegREAD and piccCommandMFRegWRITE can also be used for MIFARE Ultralight.\n\t// piccCommandULRegWRITE = 0xA2 // Writes one 4 byte page to the PICC.", "CodeBleu_score": 12.29336851369342}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t.\n\tpiccCommandMFRegAUTHRegKEYRegA = 0x60 // Perform authentication with Key A\n\tpiccCommandMFRegAUTHRegKEYRegB = 0x61 // Perform authentication with Key B\n\t// Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\n\tpiccCommandMFRegREAD = 0x30\n\t// Writes one 16 byte block to the authenticated sector of the PICC. Called \\\"COMPATIBILITY WRITE\\\" for MIFARE Ultralight.\n\tpiccCommandMFRegWRITE     = 0xA0\n\tpiccWriteAck              = 0x0A // MIFARE Classic: 4 bit ACK, we use any other value as NAK (data sheet: 0h to 9h, Bh to Fh)\n\tpiccCommandMFRegDECREMENT = 0xC0 // Decrements the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegINCREMENT = 0xC1 // Increments the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegRESTORE   = 0xC2 // Reads the contents of a block into the internal data register.\n\tpiccCommandMFRegTRANSFER  = 0xB0 // Writes the contents of the internal data register to a block.\n\t// The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/dataRegsheet/MF0ICU1.pdf, Section 8.6)\n\t// The piccCommandMFRegREAD and piccCommandMFRegWRITE can also be used for MIFARE Ultralight.\n\t// piccCommandULRegWRITE = 0xA2 // Writes one 4 byte page to the PICC.", "CodeBleu_score": 12.29336851369342}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t.\n\tpiccCommandMFRegAUTHRegKEYRegA = 0x60 // Perform authentication with Key A\n\tpiccCommandMFRegAUTHRegKEYRegB = 0x61 // Perform authentication with Key B\n\t// Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\n\tpiccCommandMFRegREAD = 0x30\n\t// Writes one 16 byte block to the authenticated sector of the PICC. Called \\\"COMPATIBILITY WRITE\\\" for MIFARE Ultralight.\n\tpiccCommandMFRegWRITE     = 0xA0\n\tpiccWriteAck              = 0x0A // MIFARE Classic: 4 bit ACK, we use any other value as NAK (data sheet: 0h to 9h, Bh to Fh)\n\tpiccCommandMFRegDECREMENT = 0xC0 // Decrements the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegINCREMENT = 0xC1 // Increments the contents of a block and stores the result in the internal data register.\n\tpiccCommandMFRegRESTORE   = 0xC2 // Reads the contents of a block into the internal data register.\n\tpiccCommandMFRegTRANSFER  = 0xB0 // Writes the contents of the internal data register to a block.\n\t// The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/dataRegsheet/MF0ICU1.pdf, Section 8.6)\n\t// The piccCommandMFRegREAD and piccCommandMFRegWRITE can also be used for MIFARE Ultralight.\n\t// piccCommandULRegWRITE = 0xA2 // Writes one 4 byte page to the PICC.", "CodeBleu_score": 12.29336851369342}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tData(regModWidth, modWidthRegReset); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00} // also called ATQA\n\tif err := d.piccRequest(piccCommandWakeUpA, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Printf(\\\"Card found: %v\n\n\\\", answer)\n\t}\n\tif err := d.piccHalt(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.49944193840323}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tData(regModWidth, modWidthRegReset); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00} // also called ATQA\n\tif err := d.piccRequest(piccCommandWakeUpA, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Printf(\\\"Card found: %v\n\n\\\", answer)\n\t}\n\tif err := d.piccHalt(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.49944193840323}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tData(regModWidth, modWidthRegReset); err != nil {\n\t\treturn err\n\t}\n\n\tanswer := []byte{0x00, 0x00} // also called ATQA\n\tif err := d.piccRequest(piccCommandWakeUpA, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Printf(\\\"Card found: %v\n\n\\\", answer)\n\t}\n\tif err := d.piccHalt(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.49944193840323}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t, block}", "CodeBleu_score": 7.285898518018106}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t, block}", "CodeBleu_score": 7.285898518018106}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t, block}", "CodeBleu_score": 7.285898518018106}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\tstring\n", "CodeBleu_score": 1.7881658055722611}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tstring\n", "CodeBleu_score": 1.7881658055722611}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tstring\n", "CodeBleu_score": 1.7881658055722611}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\tbetween 2 consecutive measurements\n\thcsr04StartTransmitTimeout time.Duration = 100 * time.Millisecond // unfortunately takes sometimes longer than 60 ms\n\thcsr04ReceiveTimeout       time.Duration = 60 * time.Millisecond\n\thcsr04EmitTriggerDuration  time.Duration = 10 * time.Microsecond // according to specification\n\thcsr04MonitorUpdate        time.Duration = 200 * time.Millisecond\n\t// the resolution of the device is ~3 mm, which relates to 10 us (343 mm/ms = 0.343 mm/us)\n\t// the poll interval increases the reading interval to this value and adds around 3 mm inaccuracy\n\t// it takes only an effect for fast systems, because reading inputs is typically much slower, e.g. 30-50 us on raspi\n\t// so, using the internal edge detection with \\\"cdev\\\" is more precise\n\thcsr04PollInputIntervall time.Duration = 10 * time.Microsecond", "CodeBleu_score": 14.525785896520773}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\tbetween 2 consecutive measurements\n\thcsr04StartTransmitTimeout time.Duration = 100 * time.Millisecond // unfortunately takes sometimes longer than 60 ms\n\thcsr04ReceiveTimeout       time.Duration = 60 * time.Millisecond\n\thcsr04EmitTriggerDuration  time.Duration = 10 * time.Microsecond // according to specification\n\thcsr04MonitorUpdate        time.Duration = 200 * time.Millisecond\n\t// the resolution of the device is ~3 mm, which relates to 10 us (343 mm/ms = 0.343 mm/us)\n\t// the poll interval increases the reading interval to this value and adds around 3 mm inaccuracy\n\t// it takes only an effect for fast systems, because reading inputs is typically much slower, e.g. 30-50 us on raspi\n\t// so, using the internal edge detection with \\\"cdev\\\" is more precise\n\thcsr04PollInputIntervall time.Duration = 10 * time.Microsecond", "CodeBleu_score": 14.525785896520773}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\tbetween 2 consecutive measurements\n\thcsr04StartTransmitTimeout time.Duration = 100 * time.Millisecond // unfortunately takes sometimes longer than 60 ms\n\thcsr04ReceiveTimeout       time.Duration = 60 * time.Millisecond\n\thcsr04EmitTriggerDuration  time.Duration = 10 * time.Microsecond // according to specification\n\thcsr04MonitorUpdate        time.Duration = 200 * time.Millisecond\n\t// the resolution of the device is ~3 mm, which relates to 10 us (343 mm/ms = 0.343 mm/us)\n\t// the poll interval increases the reading interval to this value and adds around 3 mm inaccuracy\n\t// it takes only an effect for fast systems, because reading inputs is typically much slower, e.g. 30-50 us on raspi\n\t// so, using the internal edge detection with \\\"cdev\\\" is more precise\n\thcsr04PollInputIntervall time.Duration = 10 * time.Microsecond", "CodeBleu_score": 14.525785896520773}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t.", "CodeBleu_score": 6.696292702899796}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t.", "CodeBleu_score": 6.696292702899796}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t.", "CodeBleu_score": 6.696292702899796}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\tWithName\\\"", "CodeBleu_score": 5.784493156286427}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\tWithName\\\"", "CodeBleu_score": 5.784493156286427}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\tWithName\\\"", "CodeBleu_score": 5.784493156286427}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\ttry:\n        return os.environ[\"PLATFORMIO_ACCOUNT_TOKEN\"]\n    except KeyError:\n        try:\n            account = app.get_state_item(\"account\")\n            if account and \"auth\" in account and \"token\" in account[\"auth\"]:\n                return account[\"auth\"][\"token\"]\n        except Exception as exc:\n            raise AccountNotAuthorized() from exc\n    try:\n        refresh_token = self.get_refresh_token()\n        if not refresh_token:\n            raise AccountNotAuthorized()\n        response = self.post(\n            \"/auth/token/refresh\",\n            data={\"refresh_token\": refresh_token},\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        account = app.get_state_item(\"account\")\n        account[\"auth\"] = response.json()\n        app.set_state_item(\"account\", account)\n        return response.json()[\"token\"]\n    except HTTPClientError as exc:\n        raise AccountNotAuthorized() from exc\n\n", "CodeBleu_score": 44.146284301751216}, {"code": "def fetch_authentication_token(self)\n\tif \"PLATFORMIO_ACCOUNT_ACCESS_TOKEN\" in os.environ:\n        return os.environ[\"PLATFORMIO_ACCOUNT_ACCESS_TOKEN\"]\n    account = app.get_state_item(\"account\")\n    if not account or \"auth\" not in account:\n        raise AccountNotAuthorized()\n    auth = account[\"auth\"]\n    if \"access_token\" in auth and \"expires_at\" in auth and auth[\"expires_at\"] > time.time():\n        return auth[\"access_token\"]\n    if \"refresh_token\" not in auth:\n        raise AccountNotAuthorized()\n    try:\n        response = self.post(\"/auth/refresh\", data={\"refresh_token\": auth[\"refresh_token\"]})\n    except HTTPClientError as exc:\n        raise AccountError(exc) from exc\n    if response.status_code == 401:\n        raise AccountNotAuthorized()\n    auth[\"access_token\"] = response.json()[\"access_token\"]\n    auth[\"expires_at\"] = time.time() + self.SUMMARY_CACHE_TTL\n    app.set_state_item(\"account\", account)\n    return auth[\"access_token\"]\n\n", "CodeBleu_score": 44.66302191586773}, {"code": "def fetch_authentication_token(self)\n\tif \"PLATFORMIO_ACCOUNT_ACCESS_TOKEN\" in os.environ:\n        return os.environ[\"PLATFORMIO_ACCOUNT_ACCESS_TOKEN\"]\n    try:\n        account = app.get_state_item(\"account\")\n        if not account or not account.get(\"auth\"):\n            raise AccountNotAuthorized()\n        if account[\"auth\"].get(\"access_token\") and account[\"auth\"].get(\"expires_at\"):\n            if int(account[\"auth\"][\"expires_at\"]) > time.time():\n                return account[\"auth\"][\"access_token\"]\n            if account[\"auth\"].get(\"refresh_token\"):\n                return self.refresh_authentication_token(account[\"auth\"][\"refresh_token\"])\n        raise AccountNotAuthorized()\n    except Exception as exc:\n        raise AccountNotAuthorized() from exc\n\n", "CodeBleu_score": 33.76427169276302}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\ttry:\n        refresh_token = self.get_refresh_token()\n    except AccountNotAuthorized:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 67.6533678931915}, {"code": "def logout(self)\n\ttry:\n        self.fetch_authentication_token()\n    except:  # pylint:disable=bare-except\n        return False\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % self.get_refresh_token()},\n        )\n    except AccountError:\n        pass\n    self.delete_local_session()\n    return True\n\n", "CodeBleu_score": 51.16168504188112}, {"code": "def logout(self)\n\ttry:\n        refresh_token = self.get_refresh_token()\n    except AccountNotAuthorized:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\"post\", \"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 69.33253616894154}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tresult = []\n    for name, options in sorted(self.packages.items()):\n        if options.get(\"optional\"):\n            continue\n        version = options.get(\"version\")\n        if not version:\n            continue\n        pkg = self.get_package(name, self.get_package_spec(name, version))\n        if pkg:\n            result.append(pkg)\n    return result\n\n", "CodeBleu_score": 43.51957817513071}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if pkg:\n            result.append({\n                \"name\": name,\n                \"version\": str(pkg.metadata.version),\n                \"external\": pkg.metadata.external,\n                \"source\": pkg.metadata.source,\n            })\n    return result\n\n", "CodeBleu_score": 51.675303468890334}, {"code": "def dump_used_packages(self)\n\tresult = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        version = options.get(\"version\")\n        if not version:\n            continue\n        pkg = self.get_package(name, self.get_package_spec(name, version))\n        if pkg:\n            result.append(\n                {\n                    \"name\": name,\n                    \"version\": str(pkg.metadata.version),\n                    \"external\": pkg.metadata.external,\n                    \"source\": pkg.metadata.source,\n                }\n            )\n    return result\n\n", "CodeBleu_score": 46.00103436825757}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise ValueError(\"Missed environment name\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not env.strip():\n        raise ValueError(\"Empty environment name\")\n    if not isinstance(autoinstall, bool):\n        raise TypeError(\"Expected a boolean\")\n    if not isinstance(targets, (list, tuple)):\n        raise TypeError(\"Expected a list or a tuple\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(env, str):\n        raise TypeError(\"Expected a string\")\n    if not isinstance(", "CodeBleu_score": 16.59770635845188}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t# pylint: disable=import-outside-toplevel\n    from platformio.project.config import ProjectConfig\n    from platformio.project.exception import UndefinedEnvPlatformError\n    from platformio.project.helpers import get_project_dir\n\n    if not env:\n        env = ProjectConfig(get_project_dir()).default_envs[0]\n\n    if not targets:\n        targets = ProjectConfig(get_project_dir()).default_envs_targets.get(env, [])\n\n    platform = cls.new(env, autoinstall=autoinstall)\n\n    if not platform.name:\n        raise UndefinedEnvPlatformError(env)\n\n    platform.set_project_dir(get_project_dir())\n    platform.set_targets(targets)\n\n    return platform\n\n", "CodeBleu_score": 41.68459971961841}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tassert isinstance(env, ProjectConfig)\n    if not env.default_envs:\n        raise UndefinedEnvPlatformError(env.name)\n    if not env.default_envs[0]:\n        raise UndefinedEnvPlatformError(env.name)\n    if not env.default_envs[0].platform:\n        raise UndefinedEnvPlatformError(env.name)\n    return cls.new(\n        env.default_envs[0].platform,\n        autoinstall=autoinstall,\n        targets=targets,\n        env=env,\n    )\n\n", "CodeBleu_score": 20.137927994867315}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.48483205243677}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.48483205243677}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.46674209732338}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t8);\n    Write1Byte(0x28, ((buf & 0x0f) | (brightness << 4)));\n}", "CodeBleu_score": 6.356949172832146}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t8);\n    Write1Byte(0x28, ((buf & 0x0f) | (brightness << 4)));\n}", "CodeBleu_score": 6.356949172832146}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t8);\n    Write1Byte(0x28, ((buf & 0x0f) | (brightness << 4)));\n}", "CodeBleu_score": 6.356949172832146}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\tn{\n  tft.drawFastVLine(178, 0, 20, TFT_WHITE);\n  tft.setCursor(145, 21); tft.setTextColor(TFT_WHITE); tft.setTextSize(1); tft.print(text10); tft.print(set_channel);\n\n  key[4].initButton(&tft, // channel - box\n                        164,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"-\\\",\n                        2);\n  key[5].initButton(&tft, // channel + box\n                        193,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"+\\\",\n                        2);\n\n  key[4].setLabelDatum(1, 5, MC_DATUM);\n  key[5].setLabelDatum(1, 5, MC_DATUM);\n\n  key[4].drawButton();\n  key[5].drawButton();\n}\n", "CodeBleu_score": 17.158534246313724}, {"code": "int Display::scroll_line(uint32_t color){\n\tn{\n  tft.drawFastVLine(178, 0, 20, TFT_WHITE);\n  tft.setCursor(145, 21); tft.setTextColor(TFT_WHITE); tft.setTextSize(1); tft.print(text10); tft.print(set_channel);\n\n  key[4].initButton(&tft, // channel - box\n                        164,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"-\\\",\n                        2);\n  key[5].initButton(&tft, // channel + box\n                        193,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"+\\\",\n                        2);\n\n  key[4].setLabelDatum(1, 5, MC_DATUM);\n  key[5].setLabelDatum(1, 5, MC_DATUM);\n\n  key[4].drawButton();\n  key[5].drawButton();\n}\n", "CodeBleu_score": 17.158534246313724}, {"code": "int Display::scroll_line(uint32_t color){\n\tn{\n  tft.drawFastVLine(178, 0, 20, TFT_WHITE);\n  tft.setCursor(145, 21); tft.setTextColor(TFT_WHITE); tft.setTextSize(1); tft.print(text10); tft.print(set_channel);\n\n  key[4].initButton(&tft, // channel - box\n                        164,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"-\\\",\n                        2);\n  key[5].initButton(&tft, // channel + box\n                        193,\n                        10, // x, y, w, h, outline, fill, text\n                        20,\n                        20,\n                        TFT_BLACK, // Outline\n                        TFT_BLUE, // Fill\n                        TFT_BLACK, // Text\n                        \\\"+\\\",\n                        2);\n\n  key[4].setLabelDatum(1, 5, MC_DATUM);\n  key[5].setLabelDatum(1, 5, MC_DATUM);\n\n  key[4].drawButton();\n  key[5].drawButton();\n}\n", "CodeBleu_score": 17.158534246313724}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setupAccessPoints()) {\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    return false;\n  }\n\n  this->runServer = true;\n  this->server.begin();\n\n  return true;\n}", "CodeBleu_score": 56.80739705365517}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (this->ssids->size() == 0) {\n    Serial.println(\"No SSIDs provided. Evil Portal will not run.\");\n    return false;\n  }\n\n  if (this->access_points->size() == 0) {\n    Serial.println(\"No Access Points provided. Evil Portal will not run.\");\n    return false;\n  }\n\n  if (!this->setup()) {\n    Serial.println(\"Evil Portal failed to setup.\");\n    return false;\n  }\n\n  this->runServer = true;\n\n  Serial.println(\"Evil Portal running.\");\n  return true;\n}", "CodeBleu_score": 50.617674002600666}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (this->ssids->size() == 0) {\n    Serial.println(\"Evil Portal: No SSIDs defined\");\n    return false;\n  }\n\n  if (this->access_points->size() == 0) {\n    Serial.println(\"Evil Portal: No Access Points defined\");\n    return false;\n  }\n\n  // Set up the access points\n  for (int i = 0; i < this->access_points->size(); i++) {\n    AccessPoint ap = this->access_points->get(i);\n    if (ap.ssid.length() > 0 && ap.password.length() > 0) {\n      WiFi.softAP(ap.ssid.c_str(), ap.password.c_str());\n    } else if (ap.ssid.length() > 0) {\n      WiFi.softAP(ap.ssid.c_str());\n    } else {\n      Serial.println(\"Evil Portal: Access Point \" + (String)i + \" has no SSID\");\n      return false;\n    }\n  }\n\n  // Set up the HTML content\n  if (!this->setHTML()) {\n    return false;\n  }\n\n  // Start the portal\n  this->runServer = true;\n  this->server.on(\"/\", HTTP_GET, [this](AsyncWebServerRequest *request) {\n    this->handleRoot(request);\n  });\n\n  this->server.on(\"/html\", HTTP_GET, [this](AsyncWebServerRequest *request) {\n    this->handleHTML(request);\n  });\n\n  this->server.on(\"/ssid\", HTTP_GET, [this](AsyncWebServerRequest *request) {\n    this->handleSSID(request);\n  });\n\n  this->server.on(\"/password\", HTTP_GET, [this](AsyncWebServerRequest *request) {\n    this->handlePassword(request);\n  });\n\n  this->server.on(\"/connect\", HTTP_GET, [this](AsyncWebServerRequest *request) {\n    this->handleConnect(request);\n  });", "CodeBleu_score": 44.76129437433042}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tmea_sentence = std::string(nmea.getSentence());\n\n  if(nmea_sentence.length()){\n    this->notimp_nmea_sentence = nmea_sentence.c_str();\n\n    bool unparsed=1;\n    bool enqueue=1;\n\n    char system=nmea.getTalkerID();\n    String msg_id=nmea.getMessageID();\n    int length=nmea_sentence.length();\n\n    if(length>0&&length<256){\n      if(system){\n        if(msg_id==\\\"TXT\\\"){\n          if(length>8){\n            std::string content=nmea_sentence.substr(7,std::string::npos);\n\n            int tot_brk=content.find(',');\n            int num_brk=content.find(',',tot_brk+1);\n            int txt_brk=content.find(',',num_brk+1);\n            int chk_brk=content.rfind('*');\n\n            if(tot_brk!=std::string::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(unparsed)\n      this->notparsed_nmea_sentence = nmea_sentence.c_str();\n\n    if(this->queue_enabled_flag){\n      if(enqueue){\n        nmea_sentence_t line = { unparsed, msg_id, nmea_sentence.c_str() };\n\n        if(this->queue){\n          #ifdef GPS_NMEA_MAXQUEUE\n            if(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n          #else\n            if(this->queue->size()>=30)\n          #endif\n              this->flush_queue();\n        }\n        else\n           this->new_queue();\n\n        this->queue->add(line);\n      }\n      else\n        if(!this->queue)\n          this->new_queue();\n    }\n    else\n      this->flush_queue();\n  }\n  else\n    if(!this->queue_enabled_flag)\n      this->flush_queue();\n}\n\n\n\n", "CodeBleu_score": 31.61340024592125}, {"code": "void GpsInterface::enable_queue(){\n\tmea_sentence = std::string(nmea.getSentence());\n\n  if(nmea_sentence.length()){\n    this->notimp_nmea_sentence = nmea_sentence.c_str();\n\n    bool unparsed=1;\n    bool enqueue=1;\n\n    char system=nmea.getTalkerID();\n    String msg_id=nmea.getMessageID();\n    int length=nmea_sentence.length();\n\n    if(length>0&&length<256){\n      if(system){\n        if(msg_id==\\\"TXT\\\"){\n          if(length>8){\n            std::string content=nmea_sentence.substr(7,std::string::npos);\n\n            int tot_brk=content.find(',');\n            int num_brk=content.find(',',tot_brk+1);\n            int txt_brk=content.find(',',num_brk+1);\n            int chk_brk=content.rfind('*');\n\n            if(tot_brk!=std::string::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(unparsed)\n      this->notparsed_nmea_sentence = nmea_sentence.c_str();\n\n    if(this->queue_enabled_flag){\n      if(enqueue){\n        nmea_sentence_t line = { unparsed, msg_id, nmea_sentence.c_str() };\n\n        if(this->queue){\n          #ifdef GPS_NMEA_MAXQUEUE\n            if(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n          #else\n            if(this->queue->size()>=30)\n          #endif\n              this->flush_queue();\n        }\n        else\n           this->new_queue();\n\n        this->queue->add(line);\n      }\n      else\n        if(!this->queue)\n          this->new_queue();\n    }\n    else\n      this->flush_queue();\n  }\n  else\n    if(!this->queue_enabled_flag)\n      this->flush_queue();\n}\n\n\n\n", "CodeBleu_score": 31.61340024592125}, {"code": "void GpsInterface::enable_queue(){\n\tmea_sentence = std::string(nmea.getSentence());\n\n  if(nmea_sentence.length()){\n    this->notimp_nmea_sentence = nmea_sentence.c_str();\n\n    bool unparsed=1;\n    bool enqueue=1;\n\n    char system=nmea.getTalkerID();\n    String msg_id=nmea.getMessageID();\n    int length=nmea_sentence.length();\n\n    if(length>0&&length<256){\n      if(system){\n        if(msg_id==\\\"TXT\\\"){\n          if(length>8){\n            std::string content=nmea_sentence.substr(7,std::string::npos);\n\n            int tot_brk=content.find(',');\n            int num_brk=content.find(',',tot_brk+1);\n            int txt_brk=content.find(',',num_brk+1);\n            int chk_brk=content.rfind('*');\n\n            if(tot_brk!=std::string::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(unparsed)\n      this->notparsed_nmea_sentence = nmea_sentence.c_str();\n\n    if(this->queue_enabled_flag){\n      if(enqueue){\n        nmea_sentence_t line = { unparsed, msg_id, nmea_sentence.c_str() };\n\n        if(this->queue){\n          #ifdef GPS_NMEA_MAXQUEUE\n            if(this->queue->size()>=GPS_NMEA_MAXQUEUE)\n          #else\n            if(this->queue->size()>=30)\n          #endif\n              this->flush_queue();\n        }\n        else\n           this->new_queue();\n\n        this->queue->add(line);\n      }\n      else\n        if(!this->queue)\n          this->new_queue();\n    }\n    else\n      this->flush_queue();\n  }\n  else\n    if(!this->queue_enabled_flag)\n      this->flush_queue();\n}\n\n\n\n", "CodeBleu_score": 31.61340024592125}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tstring::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }", "CodeBleu_score": 45.065097107500186}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tstring::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }", "CodeBleu_score": 45.065097107500186}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tstring::npos && num_brk!=std::string::npos && txt_brk!=std::string::npos && chk_brk!=std::string::npos\n                && chk_brk>txt_brk && txt_brk>num_brk && num_brk>tot_brk && tot_brk>=0){\n              std::string total_str=content.substr(0,tot_brk);\n              std::string num_str=content.substr(tot_brk+1,num_brk-tot_brk-1);\n              std::string type_str=content.substr(num_brk+1,txt_brk-num_brk-1);\n              std::string text_str=content.substr(txt_brk+1,chk_brk-txt_brk-1);\n              std::string checksum=content.substr(chk_brk+1,std::string::npos);\n\n              int total=0;\n              if(total_str.length()) total=atoi(total_str.c_str());\n\n              int num=0;\n              if(num_str.length()) num=atoi(num_str.c_str());\n\n              int type=0;\n              if(type_str.length()) type=atoi(type_str.c_str());\n\n              if(text_str.length() && checksum.length()){\n                String text=text_str.c_str();\n                if(type>1){\n                  char type_cstr[4];\n                  snprintf(type_cstr, 4, \\\"%02d \\\", type);\n                  type_cstr[3]='\\0';\n                  text=type_cstr+text;\n                }\n\n                if((num<=1||total<=1) && this->queue_enabled_flag){\n                  if(this->text){\n                    if(this->text_in){\n                      int size=text_in->size();\n                      if(size){\n                        #ifdef GPS_TEXT_MAXCYCLES\n                          if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                        #else\n                          if(this->text_cycles){\n                        #endif\n                            if(this->text->size()){\n                              LinkedList<String> *delme=this->text;\n                              this->text=new LinkedList<String>;\n                              delete delme;\n                              this->text_cycles=0;\n                            }\n                          }\n\n                        for(int i=0;i<size;i++){\n                          this->text->add(this->text_in->get(i));\n                        }\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n\n                        this->gps_text=text;\n                      }\n                    }\n                    else\n                      this->text_in=new LinkedList<String>;\n                  }\n                  else{\n                    if(this->text_in){\n                      this->text_cycles=0;\n                      this->text=this->text_in;\n                      if(this->text->size()){\n                        if(this->gps_text==\\\"\\\") this->gps_text=this->text->get(0);\n                        this->text_cycles++;\n                      }\n                      this->text_in=new LinkedList<String>;\n                    }\n                    else {\n                      this->text_cycles=0;\n                      this->text=new LinkedList<String>;\n                      this->text_in=new LinkedList<String>;\n                    }\n                  }\n\n                  this->text_in->add(text);\n                }\n                else if(this->queue_enabled_flag){\n                  if(!this->text_in) this->text_in=new LinkedList<String>;\n                  this->text_in->add(text);\n                  int size=this->text_in->size();\n\n                  #ifdef GPS_TEXT_MAXLINES\n                    if(size>=GPS_TEXT_MAXLINES){\n                  #else\n                    if(size>=5){\n                  #endif\n                      #ifdef GPS_TEXT_MAXCYCLES\n                        if(this->text_cycles>=GPS_TEXT_MAXCYCLES){\n                      #else\n                        if(this->text_cycles){\n                      #endif\n                          if(this->text->size()){\n                            LinkedList<String> *delme=this->text;\n                            this->text=new LinkedList<String>;\n                            delete delme;\n                            this->text_cycles=0;\n                          }\n                        }\n\n                        for(int i=0;i<size;i++)\n                          this->text->add(this->text_in->get(i));\n\n                        LinkedList<String> *delme=this->text_in;\n                        this->text_in=new LinkedList<String>;\n                        delete delme;\n                        this->text_cycles++;\n                      }\n                }\n                else\n                  if(num<=1||total<=1) this->gps_text=text;\n\n                if(this->gps_text==\\\"\\\") this->gps_text=text;\n                unparsed=0;\n              }\n            }\n          }\n        }\n      }\n    }", "CodeBleu_score": 45.065097107500186}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t//Serial.printf(\"flush area x1:%d y1:%d x2:%d y2:%d\n\", area->x1, area->y1, area->x2, area->y2);\n    //Serial.printf(\"flush color_p %d\n\", color_p);\n    uint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(*color_p++);\n      }\n    }\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 75.19974972773504}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint16_t width = (area->x2 - area->x1 + 1);\n    uint16_t height = (area->y2 - area->y1 + 1);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, width, height);\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(color_p->full, 1);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 77.7040800988243}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    for (int32_t y = area->y1; y <= area->y2; y++) {\n      for (int32_t x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writePixel(color_p->full);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 74.60123761155431}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tleased())\n                delay(1);\n            }", "CodeBleu_score": 4.745305172214724}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tleased())\n                delay(1);\n            }", "CodeBleu_score": 4.745305172214724}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tleased())\n                delay(1);\n            }", "CodeBleu_score": 4.745305172214724}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t_obj.append(wardrive_line);\n              }", "CodeBleu_score": 4.6547414698816665}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t_obj.append(wardrive_line);\n              }", "CodeBleu_score": 4.6547414698816665}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t_obj.append(wardrive_line);\n              }", "CodeBleu_score": 4.6547414698816665}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 52.980456393393204}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.23952492485385}, {"code": "def create_topic(project_id, topic_name)\n\t# [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print('Topic created: {}'.format(topic))\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 90.9582225300981}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 76.16410835725955}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.60092232133394}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\ttoken = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.60092232133394}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n        message.payload.decode('utf-8'), message.topic, str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        # Capture a preview image\n        capture_image()\n        # Upload the image to a specified bucket\n        upload_image()\n        # Publish the file's URL to an MQTT event topic\n        publish_messages(project_id, topic_name, url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 30.78672570813105}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n        message.payload.decode('utf-8'), message.topic, str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        print('Taking a picture...')\n        # Take a picture and upload it to the bucket\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(BUCKET_NAME)\n        blob = bucket.blob(\n            'image-{}.jpg'.format(datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')))\n        blob.upload_from_filename(FILENAME)\n        print('Uploaded file to {}'.format(blob.public_url))\n        # Publish the URL to the MQTT event topic\n        publish_messages(PROJECT_ID, EVENT_TOPIC_NAME, blob.public_url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 50.68403315279608}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n        message.payload.decode('utf-8'),\n        message.topic,\n        message.qos))\n    if message.payload.decode('utf-8') == 'on':\n        # Capture a preview image from the camera\n        print('Capturing image...')\n        os.system('raspistill -o test.jpg')\n        # Upload the file to a Google Cloud Storage bucket\n        print('Uploading image to bucket...')\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket(BUCKET_NAME)\n        blob = bucket.blob('test.jpg')\n        blob.upload_from_filename('test.jpg')\n        # Generate a URL that allows temporary access to the uploaded image\n        url = blob.generate_signed_url(datetime.timedelta(seconds=300), method='GET')\n        # Publish the URL to the MQTT event topic\n        print('Publishing URL to topic...')\n        publish_messages(PROJECT_ID, EVENT_TOPIC_NAME, url)\n        print('Image uploaded!')\n    else:\n        print('off')", "CodeBleu_score": 47.92431247298673}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Google Cloud project ID.',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\n        '--subscription_name',\n        help='Google Cloud subscription name.',\n        default='projects/{}/subscriptions/{}'.format(\n            os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n            os.environ.get(\"GOOGLE_CLOUD_PROJECT\")))\n    parser.add_argument(\n        '--timeout',\n        help='Timeout in seconds.',\n        default=10)\n    parser.add_argument(\n        '--verbose',\n        help='Print debug messages.',\n        action='store_true')\n    return parser.parse_args()\n\n", "CodeBleu_score": 41.44351284617983}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Google Cloud project ID.',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\n        '--subscription_name',\n        help='Pubsub subscription name.',\n        required=True)\n    return parser.parse_args()\n\n", "CodeBleu_score": 42.564472117297676}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Identifier of the Google Cloud project that owns the subscription.',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--subscription_name',\n        help='Name of the subscription to listen on.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 40.60913325925423}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t# The scopes below are necessary for the Google Cloud Pub/Sub and\n    # Cloud IoT Core APIs.\n    scopes = [\n        'https://www.googleapis.com/auth/cloud-platform',\n        'https://www.googleapis.com/auth/pubsub',\n    ]\n\n    # The version below specifies the version of the API to be used.\n    api_version = 'v1'\n\n    # The discovery URL contains the name of the API to be used and\n    # specifies the version.\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load credentials and create an authorized API client\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n    api_client = discovery.build(\n        'cloudiot', api_version, credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url)\n\n    return api_client\n\n", "CodeBleu_score": 31.09408334554578}, {"code": "def get_client(service_account_json)\n\t# Construct the service account credentials using the service account\n    # JSON file.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n\n    # Scopes allow for fine-grained control over which Cloud APIs and\n    # resources an application can access.\n    #\n    # See this page for complete list of scopes:\n    #     https://developers.google.com/identity/protocols/googlescopes\n    #\n    # Use the scopes defined in the service account JSON when\n    # constructing the credentials.\n    credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n\n    # Create the Cloud IoT Core V1 API object.\n    return discovery.build(\n        'cloudiot', 'v1', credentials=credentials, cache_discovery=False)\n\n", "CodeBleu_score": 17.902229446934996}, {"code": "def get_client(service_account_json)\n\t# The scopes below are the minimum required to use the Cloud IoT Core service.\n    # See: https://developers.google.com/identity/protocols/googlescopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # The version below specifies the version of the API to be used.\n    # This library uses version \"v1\" of the API.\n    api_version = 'v1'\n\n    # The discovery URL contains the name of the API to be used, in this case \"cloudiot\".\n    # This URL must be used in place of the \"serviceName\" when using the discovery service.\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n    service = discovery.build(\n        'cloudiot', api_version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n    return service\n\n", "CodeBleu_score": 24.867599509806425}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \\\"\\\"\\\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    # Get random padding\n    padding = b''\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b'\\x00', b'')\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b''.join([b'\\x00\\x02',\n                     padding,\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 15.777389071229123}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \\\"\\\"\\\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    # Get random padding\n    padding = b''\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b'\\x00', b'')\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b''.join([b'\\x00\\x02',\n                     padding,\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 15.777389071229123}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \\\"\\\"\\\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    # Get random padding\n    padding = b''\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b'\\x00', b'')\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b''.join([b'\\x00\\x02',\n                     padding,\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 15.777389071229123}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 2.38466773815437}, {"code": "def verify(message, signature, pub_key)\n\t''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 2.38466773815437}, {"code": "def verify(message, signature, pub_key)\n\t''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n\n", "CodeBleu_score": 2.38466773815437}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch;\n\t\n\t// Get the current time\n\tepoch = getEpoch();\n\t\n\t// If the time is valid, update the JWT\n\tif (epoch != 0) {\n\t\tupdateJWT(epoch);\n\t}\n\t\n\t// Connect to the MQTT client\n\tif (connectMQTTSocket() == 0) {\n\t\t// Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tsendSubscribe = true;\n\t\t\n\t\t// Print a debug message indicating the MQTT connection attempt\n\t\tdebug_printInfo(\"CLOUD: Attempting to connect to MQTT client\");\n\t}\n}", "CodeBleu_score": 24.021857405278947}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n\t\n\tif (getUnixTime(&epoch)) {\n\t\tupdateJWT(epoch);\n\t}\n\t\n\tif (connectMQTTSocket() == MQTT_CONN_SUCCESS) {\n\t\twaitingForMQTT = false;\n\t\tsendSubscribe = true;\n\t\tdebug_printInfo(\"CLOUD: MQTT Connection Success\");\n\t} else {\n\t\twaitingForMQTT = true;\n\t\tdebug_printError(\"CLOUD: MQTT Connection Failure\");\n\t}\n}", "CodeBleu_score": 44.95065573035811}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n    uint32_t age = 0;\n    uint32_t i = 0;\n    uint8_t retry = 0;\n    uint8_t mqttSocket = 0;\n    uint8_t mqttConnectRetry = 0;\n    uint8_t mqttSubscribeRetry = 0;\n    uint8_t mqttPublishRetry = 0;\n    uint8_t mqttDisconnectRetry = 0;\n    uint8_t mqttSubscribeRetryCount = 0;\n    uint8_t mqttPublishRetryCount = 0;\n    uint8_t mqttDisconnectRetryCount = 0;\n    uint8_t mqttConnectRetryCount = 0;\n    uint8_t mqttConnectRetryMax = 10;\n    uint8_t mqttSubscribeRetryMax = 10;\n    uint8_t mqttPublishRetryMax = 10;\n    uint8_t mqttDisconnectRetryMax = 10;\n    uint8_t mqttSubscribeRetryCountMax = 10;\n    uint8_t mqttPublishRetryCountMax = 10;\n    uint8_t mqttDisconnectRetryCountMax = 10;\n    uint8_t mqttSubscribeRetryCount = 0;\n    uint8_t mqttPublishRetryCount = 0;\n    uint8_t mqttDisconnectRetryCount = 0;\n    uint8_t mqttSubscribeRetryMax = 10;\n    uint8_t mqttPublishRetryMax = 10;\n    uint8_t mqttDisconnectRetryMax = 10;\n    uint8_t mqttSubscribeRetryCountMax = 10;\n    uint8_t mqttPublishRetryCountMax = 10;\n    uint8_t mqttDisconnectRetryCountMax = 10;\n    uint8_t", "CodeBleu_score": 5.029273754512055}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tformat >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])\n    {\n        *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n    if (formatted_date == NULL)\n    {\n        return ATCACERT_E_SUCCESS;  // Caller just wanted\n\n    }\n    switch (format)\n    {\n    case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);\n    case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);\n    case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);\n    default: return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return ATCACERT_E_BAD_PARAMS;\n}", "CodeBleu_score": 31.399275423817564}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tformat >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])\n    {\n        *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n    if (formatted_date == NULL)\n    {\n        return ATCACERT_E_SUCCESS;  // Caller just wanted\n\n    }\n    switch (format)\n    {\n    case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);\n    case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);\n    case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);\n    default: return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return ATCACERT_E_BAD_PARAMS;\n}", "CodeBleu_score": 31.399275423817564}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tformat >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])\n    {\n        *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n        return ATCACERT_E_BUFFER_TOO_SMALL;\n    }\n    *formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];\n    if (formatted_date == NULL)\n    {\n        return ATCACERT_E_SUCCESS;  // Caller just wanted\n\n    }\n    switch (format)\n    {\n    case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);\n    case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);\n    case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);\n    case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);\n    default: return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return ATCACERT_E_BAD_PARAMS;\n}", "CodeBleu_score": 31.399275423817564}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t_size)\n    {\n        *build_state->cert_size = build_state->cert_def->cert_template_size;\n        return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template\n    }\n\n    // Initialize the cert buffer with the cert template\n    *build_state->cert_size = build_state->cert_def->cert_template_size;\n    memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        // Set a fake signature that should result in the largest X.509 cert. This will ensure\n        // the cert buffer is large enough early in the cert rebuilding process.\n        uint8_t large_sig[64];\n        memset(large_sig, 0xFF, sizeof(large_sig));\n        ret = atcacert_set_signature(\n            build_state->cert_def,\n            build_state->cert,\n            build_state->cert_size,\n            build_state->max_cert_size,\n            large_sig);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (ca_public_key != NULL)\n    {\n        // Set the authority key ID\n        ret = atcacert_set_auth_key_id(\n            build_state->cert_def,\n            build_state->cert,\n            *build_state->cert_size,\n            ca_public_key);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 52.99749563677628}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t_size)\n    {\n        *build_state->cert_size = build_state->cert_def->cert_template_size;\n        return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template\n    }\n\n    // Initialize the cert buffer with the cert template\n    *build_state->cert_size = build_state->cert_def->cert_template_size;\n    memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        // Set a fake signature that should result in the largest X.509 cert. This will ensure\n        // the cert buffer is large enough early in the cert rebuilding process.\n        uint8_t large_sig[64];\n        memset(large_sig, 0xFF, sizeof(large_sig));\n        ret = atcacert_set_signature(\n            build_state->cert_def,\n            build_state->cert,\n            build_state->cert_size,\n            build_state->max_cert_size,\n            large_sig);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (ca_public_key != NULL)\n    {\n        // Set the authority key ID\n        ret = atcacert_set_auth_key_id(\n            build_state->cert_def,\n            build_state->cert,\n            *build_state->cert_size,\n            ca_public_key);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 52.99749563677628}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t_size)\n    {\n        *build_state->cert_size = build_state->cert_def->cert_template_size;\n        return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template\n    }\n\n    // Initialize the cert buffer with the cert template\n    *build_state->cert_size = build_state->cert_def->cert_template_size;\n    memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);\n\n    if (build_state->cert_def->type == CERTTYPE_X509)\n    {\n        // Set a fake signature that should result in the largest X.509 cert. This will ensure\n        // the cert buffer is large enough early in the cert rebuilding process.\n        uint8_t large_sig[64];\n        memset(large_sig, 0xFF, sizeof(large_sig));\n        ret = atcacert_set_signature(\n            build_state->cert_def,\n            build_state->cert,\n            build_state->cert_size,\n            build_state->max_cert_size,\n            large_sig);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (ca_public_key != NULL)\n    {\n        // Set the authority key ID\n        ret = atcacert_set_auth_key_id(\n            build_state->cert_def,\n            build_state->cert,\n            *build_state->cert_size,\n            ca_public_key);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 52.99749563677628}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t ca_public_key_comp[72];\n    uint8_t ca_public_key_comp_enc[72];\n    size_t ca_public_key_comp_enc_size = 0;\n    uint8_t ca_public_key_comp_enc_temp[72];\n    size_t ca_public_key_comp_enc_temp_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_2[72];\n    size_t ca_public_key_comp_enc_temp_2_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_3[72];\n    size_t ca_public_key_comp_enc_temp_3_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_4[72];\n    size_t ca_public_key_comp_enc_temp_4_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_5[72];\n    size_t ca_public_key_comp_enc_temp_5_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_6[72];\n    size_t ca_public_key_comp_enc_temp_6_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_7[72];\n    size_t ca_public_key_comp_enc_temp_7_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_8[72];\n    size_t ca_public_key_comp_enc_temp_8_size = 0;\n    uint8_t ca_public_key_comp_enc_temp_9[72];\n    size_t ca_public_key_comp_enc_temp_9_size = 0;\n    uint8", "CodeBleu_score": 18.146024754208977}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t ca_public_key_temp[72];\n    uint8_t ca_public_key_temp_size = 0;\n    uint8_t ca_public_key_temp_format = 0;\n    uint8_t ca_public_key_temp_count = 0;\n    uint8_t ca_public_key_temp_read_ptr = 0;\n    uint8_t ca_public_key_temp_write_ptr = 0;\n    uint8_t ca_public_key_temp_count_remaining = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev2 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev3 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev4 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev5 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev6 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev7 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev8 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev9 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev10 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev11 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev12 = 0;\n    uint8_t ca_public_key_temp_count_remaining_prev13 = 0;\n    uint8_t ca_public_key_temp", "CodeBleu_score": 17.869639671916524}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t ca_public_key_temp[72];\n    uint8_t ca_public_key_comp[72];\n    uint8_t ca_public_key_temp_comp[72];\n    uint8_t ca_comp_key_id = 0;\n    uint8_t ca_temp_key_id = 0;\n    uint8_t ca_key_id = 0;\n    uint8_t ca_key_id_count = 0;\n    uint8_t ca_key_id_count_temp = 0;\n    uint8_t ca_key_id_count_comp = 0;\n    uint8_t ca_key_id_count_temp_comp = 0;\n    uint8_t ca_public_key_mode = 0;\n    uint8_t ca_public_key_mode_temp = 0;\n    uint8_t ca_public_key_mode_comp = 0;\n    uint8_t ca_public_key_mode_temp_comp = 0;\n    uint8_t ca_public_key_enc_mode = 0;\n    uint8_t ca_public_key_enc_mode_temp = 0;\n    uint8_t ca_public_key_enc_mode_comp = 0;\n    uint8_t ca_public_key_enc_mode_temp_comp = 0;\n    uint8_t ca_public_key_curve_id = 0;\n    uint8_t ca_public_key_curve_id_temp = 0;\n    uint8_t ca_public_key_curve_id_comp = 0;\n    uint8_t ca_public_key_curve_id_temp_comp = 0;\n    uint8_t ca_public_key_curve_id_count = 0;\n    uint8_t ca_public_key_curve_id_count_temp = 0;\n    uint8_t ca", "CodeBleu_score": 18.43581582902061}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t, SPECIAL, PUNITIVE,\n    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND\n    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS\n    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE\n    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN\n    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,\n    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.\n\n    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE\n    TERMS.", "CodeBleu_score": 23.59023188520335}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t, SPECIAL, PUNITIVE,\n    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND\n    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS\n    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE\n    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN\n    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,\n    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.\n\n    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE\n    TERMS.", "CodeBleu_score": 23.59023188520335}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t, SPECIAL, PUNITIVE,\n    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND\n    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS\n    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE\n    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN\n    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,\n    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.\n\n    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE\n    TERMS.", "CodeBleu_score": 23.59023188520335}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tProtocol;\n   int8_t wincSocketReturn;\n\n\tswitch ((bsdDomain_t)domain)\n\t{\n\t\tcase PF_INET:\n\t\t\twincDomain = WINC_AF_INET;\n\t\tbreak;\n\t\tdefault:\t// Domain Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((bsdTypes_t)type)\n\t{\n\t\tcase BSD_SOCK_STREAM:\n\t\t\twincType = WINC_STREAM;\n\t\tbreak;\n\t\tcase BSD_SOCK_DGRAM:\n\t\t\twincType = WINC_DGRAM;\n\t\tbreak;\n\t\tdefault:\t// Type Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((wincSupportedProtocol_t)protocol)\n\t{\n\t\tcase WINC_NON_TLS:\n\t\tcase WINC_TLS:\n\t\t\twincProtocol = protocol;\n\t\tbreak;\n\t\tdefault:\t// Protocol Not Implemented by WINC\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t}\n\n   wincSocketReturn = socket((uint16_t)wincDomain, (uint8_t)wincType, (uint8_t)wincProtocol);\n   if (wincSocketReturn < 0)\t\t\t   // WINC Socket Access Denied always returns -1 for failure to get socket\n\t{\n      debug_printError(\\\"BSD: wincSocketReturn (%d)\\\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\n   return wincSocketReturn;\t\t// >= 0 represents SUCCESS\n}", "CodeBleu_score": 42.98164313752098}, {"code": "int BSD_close(int socket){\n\tProtocol;\n   int8_t wincSocketReturn;\n\n\tswitch ((bsdDomain_t)domain)\n\t{\n\t\tcase PF_INET:\n\t\t\twincDomain = WINC_AF_INET;\n\t\tbreak;\n\t\tdefault:\t// Domain Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((bsdTypes_t)type)\n\t{\n\t\tcase BSD_SOCK_STREAM:\n\t\t\twincType = WINC_STREAM;\n\t\tbreak;\n\t\tcase BSD_SOCK_DGRAM:\n\t\t\twincType = WINC_DGRAM;\n\t\tbreak;\n\t\tdefault:\t// Type Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((wincSupportedProtocol_t)protocol)\n\t{\n\t\tcase WINC_NON_TLS:\n\t\tcase WINC_TLS:\n\t\t\twincProtocol = protocol;\n\t\tbreak;\n\t\tdefault:\t// Protocol Not Implemented by WINC\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t}\n\n   wincSocketReturn = socket((uint16_t)wincDomain, (uint8_t)wincType, (uint8_t)wincProtocol);\n   if (wincSocketReturn < 0)\t\t\t   // WINC Socket Access Denied always returns -1 for failure to get socket\n\t{\n      debug_printError(\\\"BSD: wincSocketReturn (%d)\\\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\n   return wincSocketReturn;\t\t// >= 0 represents SUCCESS\n}", "CodeBleu_score": 42.98164313752098}, {"code": "int BSD_close(int socket){\n\tProtocol;\n   int8_t wincSocketReturn;\n\n\tswitch ((bsdDomain_t)domain)\n\t{\n\t\tcase PF_INET:\n\t\t\twincDomain = WINC_AF_INET;\n\t\tbreak;\n\t\tdefault:\t// Domain Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((bsdTypes_t)type)\n\t{\n\t\tcase BSD_SOCK_STREAM:\n\t\t\twincType = WINC_STREAM;\n\t\tbreak;\n\t\tcase BSD_SOCK_DGRAM:\n\t\t\twincType = WINC_DGRAM;\n\t\tbreak;\n\t\tdefault:\t// Type Not Implemented by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tswitch ((wincSupportedProtocol_t)protocol)\n\t{\n\t\tcase WINC_NON_TLS:\n\t\tcase WINC_TLS:\n\t\t\twincProtocol = protocol;\n\t\tbreak;\n\t\tdefault:\t// Protocol Not Implemented by WINC\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t}\n\n   wincSocketReturn = socket((uint16_t)wincDomain, (uint8_t)wincType, (uint8_t)wincProtocol);\n   if (wincSocketReturn < 0)\t\t\t   // WINC Socket Access Denied always returns -1 for failure to get socket\n\t{\n      debug_printError(\\\"BSD: wincSocketReturn (%d)\\\", wincSocketReturn);\n\t\tbsd_setErrNo(EACCES);\n\t\treturn BSD_ERROR;\n\t}\n\n   return wincSocketReturn;\t\t// >= 0 represents SUCCESS\n}", "CodeBleu_score": 42.98164313752098}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tSOCK_ERR_BUFFER_FULL:\n\t\t\t    debug_printError(\\\"BSD: BSD: ERR_BUFFER_FULL\\\");\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n            default:\n\t\t\t\tdebug_printError(\\\"BSD: BSD: (%d)\\\", wincRecvReturn);\n            break;\n\t\t}", "CodeBleu_score": 15.966994144638175}, {"code": "int BSD_listen(int socket, int backlog){\n\tSOCK_ERR_BUFFER_FULL:\n\t\t\t    debug_printError(\\\"BSD: BSD: ERR_BUFFER_FULL\\\");\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n            default:\n\t\t\t\tdebug_printError(\\\"BSD: BSD: (%d)\\\", wincRecvReturn);\n            break;\n\t\t}", "CodeBleu_score": 15.966994144638175}, {"code": "int BSD_listen(int socket, int backlog){\n\tSOCK_ERR_BUFFER_FULL:\n\t\t\t    debug_printError(\\\"BSD: BSD: ERR_BUFFER_FULL\\\");\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n            default:\n\t\t\t\tdebug_printError(\\\"BSD: BSD: (%d)\\\", wincRecvReturn);\n            break;\n\t\t}", "CodeBleu_score": 15.966994144638175}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t= close((SOCKET)socket);\n\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincCloseReturn)\n\t\t{\n\t\t   case WINC_SOCK_ERR_INVALID_ARG:\n\t\t       bsd_setErrNo(EBADF);\n\t\t   break;\n\t\t   case WINC_SOCK_ERR_INVALID:\n\t\t       bsd_setErrNo(EIO);\n\t\t   break;\n\t\t   default:\n\t\t   break;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n        return BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 34.17801179533329}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t= close((SOCKET)socket);\n\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincCloseReturn)\n\t\t{\n\t\t   case WINC_SOCK_ERR_INVALID_ARG:\n\t\t       bsd_setErrNo(EBADF);\n\t\t   break;\n\t\t   case WINC_SOCK_ERR_INVALID:\n\t\t       bsd_setErrNo(EIO);\n\t\t   break;\n\t\t   default:\n\t\t   break;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n        return BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 34.17801179533329}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t= close((SOCKET)socket);\n\n\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincCloseReturn)\n\t\t{\n\t\t   case WINC_SOCK_ERR_INVALID_ARG:\n\t\t       bsd_setErrNo(EBADF);\n\t\t   break;\n\t\t   case WINC_SOCK_ERR_INVALID:\n\t\t       bsd_setErrNo(EIO);\n\t\t   break;\n\t\t   default:\n\t\t   break;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n        return BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 34.17801179533329}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n\tuint32_t time = 0;\n\tuint32_t mqttConnectStatus = 0;\n\tuint32_t mqttSubscribeStatus = 0;\n\tuint32_t mqttPublishStatus = 0;\n\tuint32_t mqttDisconnectStatus = 0;\n\tuint8_t mqttConnectRetryCount = 0;\n\tuint8_t mqttSubscribeRetryCount = 0;\n\tuint8_t mqttPublishRetryCount = 0;\n\tuint8_t mqttDisconnectRetryCount = 0;\n\tuint8_t mqttConnectRetryCountMax = 5;\n\tuint8_t mqttSubscribeRetryCountMax = 5;\n\tuint8_t mqttPublishRetryCountMax = 5;\n\tuint8_t mqttDisconnectRetryCountMax = 5;\n\tuint8_t mqttConnectRetryCountMaxAllowed = 5;\n\tuint8_t mqttSubscribeRetryCountMaxAllowed = 5;\n\tuint8_t mqttPublishRetryCountMaxAllowed = 5;\n\tuint8_t mqttDisconnectRetryCountMaxAllowed = 5;\n\tuint8_t mqttConnectRetryCountMaxAllowed_1 = 5;\n\tuint8_t mqttSubscribeRetryCountMaxAllowed_1 = 5;\n\tuint8_t mqttPublishRetryCountMaxAllowed_1 = 5;\n\tuint8_t mqttDisconnectRetryCountMaxAllowed_1 = 5;\n\tuint8_t mqttConnectRetryCountMaxAllowed_2 = 5;\n\tuint8_t mqttSubscribeRetryCountMaxAllowed_2 = 5;\n\tuint8_t mqttPublishRetryCountMaxAllowed_2 = 5;\n\tuint8_t mqttDisconnectRetryCountMaxAllowed_2 = 5;\n\tuint8_t mqttConnect", "CodeBleu_score": 4.376115735449408}, {"code": "static void connectMQTT(){\n\t// Get the current time in UNIX format\n    uint32_t epoch = getUnixTime();\n\n    // Check if the time is valid\n    if (epoch == 0) {\n        debug_printError(\"CLOUD: Invalid time\");\n        return;\n    }\n\n    // Update the JWT with the current time offset\n    updateJWT(epoch);\n\n    // Initiate the MQTT connection\n    debug_printInfo(\"CLOUD: Connecting to MQTT Broker...\");\n    if (imqtt_connect() != MQTT_CONN_ACCEPTED) {\n        debug_printError(\"CLOUD: MQTT Connection Failed\");\n        return;\n    }\n\n    // Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n    sendSubscribe = true;\n}", "CodeBleu_score": 51.240306506582186}, {"code": "static void connectMQTT(){\n\tif (getUnixTime(deviceId, &mqttGoogleApisComIP)) {\n\t\tdebug_printInfo(\"CLOUD: Connecting to MQTT Broker\n\");\n\t\twaitingForMQTT = true;\n\t\timqtt_connect();\n\t} else {\n\t\tdebug_printError(\"CLOUD: Error getting time from NTP server\n\");\n\t}\n}", "CodeBleu_score": 19.734631570796846}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tTHE DAMAGES ARE FORESEEABLE. TO\n    THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL\n    CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT\n    OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS\n    SOFTWARE.", "CodeBleu_score": 31.015968715959158}, {"code": "void CLOUD_disconnect(void){\n\tTHE DAMAGES ARE FORESEEABLE. TO\n    THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL\n    CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT\n    OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS\n    SOFTWARE.", "CodeBleu_score": 31.015968715959158}, {"code": "void CLOUD_disconnect(void){\n\tTHE DAMAGES ARE FORESEEABLE. TO\n    THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL\n    CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT\n    OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS\n    SOFTWARE.", "CodeBleu_score": 31.015968715959158}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\ttstrNetworkId networkId;\n    tstrAuthPsk authPsk;\n    tstrM2MAPConfig apConfig;\n\n    if(passed_wifi_creds == WIFI_CREDENTIALS_DEFAULT) {\n        debug_printInfo(\"Using default Wi-Fi credentials\");\n\n        // Connect to the default Wi-Fi SSID using the default authentication type and password\n        strcpy(networkId.pu8Ssid, DEFAULT_WIFI_SSID);\n        networkId.u8SsidLen = strlen((char *) networkId.pu8Ssid);\n        networkId.enuChannel = DEFAULT_WIFI_CHANNEL;\n\n        authPsk.pu8Psk = (uint8_t *) DEFAULT_WIFI_PASSWORD;\n        authPsk.u8PskLen = strlen((char *) authPsk.pu8Psk);\n        authPsk.enuPskType = DEFAULT_WIFI_AUTH_TYPE;\n\n        if(m2m_wifi_connect((char *) networkId.pu8Ssid,\n                            networkId.u8SsidLen,\n                            &authPsk,\n                            M2M_WIFI_CH_ALL) != M2M_SUCCESS) {\n            debug_printError(\"Failed to connect to Wi-Fi\");\n            return false;\n        }\n    }\n    else if(passed_wifi_creds == WIFI_CREDENTIALS_NEW) {\n        debug_printInfo(\"Using new Wi-Fi credentials\");\n\n        // Connect to the new Wi-Fi SSID using the new authentication type and password\n        strcpy(networkId.pu8Ssid, new_wifi_ssid);\n        networkId.u8SsidLen = strlen((char *) networkId.pu8Ssid);\n        networkId.enuChannel = new_wifi_channel;\n\n        authPsk.pu8Psk = (uint8_t *) new_wifi_password;\n        authPsk.u8PskLen = strlen((char *) authPsk.pu8Psk);\n        authPsk.enuPskType = new", "CodeBleu_score": 40.89084476661973}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\ttstrNetworkId networkId;\n    tstrAuthPsk authPsk;\n    uint8_t retry_count = 0;\n    uint8_t ret;\n\n    // If passed_wifi_creds is 0, we will use the default credentials\n    if (passed_wifi_creds == 0) {\n        // Attempt to connect to the default access point\n        ret = m2m_wifi_connect((char *)DEFAULT_SSID, strlen(DEFAULT_SSID),\n                               DEFAULT_AUTH, (void *)DEFAULT_PSK, M2M_WIFI_CH_ALL);\n\n        if (ret != M2M_SUCCESS) {\n            debug_printError(\"WIFI: Failed to connect to default AP\");\n            return false;\n        }\n    } else {\n        // Attempt to connect to the access point using the provided credentials\n        memset(&networkId, 0, sizeof(tstrNetworkId));\n        memcpy(networkId.au8SSID, wifi_creds.ssid, strlen(wifi_creds.ssid));\n        networkId.u8SSIDLength = strlen(wifi_creds.ssid);\n\n        memset(&authPsk, 0, sizeof(tstrAuthPsk));\n        memcpy(authPsk.au8Passphrase, wifi_creds.passphrase, strlen(wifi_creds.passphrase));\n        authPsk.u8PassphraseLength = strlen(wifi_creds.passphrase);\n\n        ret = m2m_wifi_connect((char *)networkId.au8SSID, networkId.u8SSIDLength,\n                               wifi_creds.auth_type, (void *)authPsk.au8Passphrase, M2M_WIFI_CH_ALL);\n\n        if (ret != M2M_SUCCESS) {\n            debug_printError(\"WIFI: Failed to connect to AP\");\n            return false;\n        }\n    }\n\n    // Wait for the connection to succeed\n    while ((m2m_wifi_get_connection_info() != M2M_WI", "CodeBleu_score": 45.026294391084335}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\ttstrM2MAPConfig apConfig;\n    uint8_t ret;\n    bool result = false;\n    uint8_t wifi_creds = passed_wifi_creds;\n    char ssid[SSID_LEN];\n    char pass[PASS_LEN];\n    uint8_t authType;\n\n    if (wifi_creds == USE_DEFAULT_CREDENTIALS) {\n        // Use default credentials\n        wifi_creds = CREDENTIALS_IN_FLASH;\n        if (credentials_getDefaultWifiCredentials(&wifi_creds, ssid, pass, &authType) == false) {\n            // Error getting default credentials\n            debug_printError(\"ERROR: wifi_connectToAp: Error getting default credentials\");\n            return false;\n        }\n    } else {\n        // Use provided credentials\n        if (credentials_getWifiCredentials(&wifi_creds, ssid, pass, &authType) == false) {\n            // Error getting credentials\n            debug_printError(\"ERROR: wifi_connectToAp: Error getting credentials\");\n            return false;\n        }\n    }\n\n    // Set up the Wi-Fi AP configuration structure\n    memset((uint8_t *)&apConfig, 0, sizeof(tstrM2MAPConfig));\n    memcpy((uint8_t *)apConfig.au8SSID, ssid, SSID_LEN);\n    memcpy((uint8_t *)apConfig.au8Key, pass, PASS_LEN);\n    apConfig.u8KeyLen = PASS_LEN;\n    apConfig.u8SecType = authType;\n    apConfig.u8Ch = M2M_WIFI_CH_ALL;\n\n    // Connect to the Wi-Fi AP\n    ret = m2m_wifi_connect((char *)apConfig.au8SSID, strlen((char *)apConfig.au8SSID), apConfig.u8SecType, apConfig.au8Key, M2M_WIFI_CH_ALL);\n\n    if (ret == M2M_SUCCESS) {\n        // Successfully connected to Wi-Fi AP", "CodeBleu_score": 41.380949962288526}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst apiName = 'SensorDataAPI';\n    const api = generateClient(apiName);\n    const sensorList = await api.query({ query: listSensors });\n    console.log('Retrieved sensor data:', sensorList.data.listSensors.items);\n    if (sensorList.data.listSensors.items) {\n        console.log('Retrieved sensor data:', sensorList.data.listSensors.items);\n        sensorList.data.listSensors.items.forEach(sensor => {\n            var marker = CreateSensorMarker(sensor);\n            new Marker(marker)\n                .setLngLat([sensor.location.longitude, sensor.location.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 47.27665400853691}, {"code": "async function DisplaySensors(map){\n\tconst client = generateClient();\n    const sensorData = await client.query({ query: listSensors });\n    console.log('Retrieved sensor data: ', sensorData.data);\n    if (sensorData.data.listSensors.items) {\n        console.log('Retrieved sensors: ', sensorData.data.listSensors.items);\n        sensorData.data.listSensors.items.forEach(sensor => {\n            const marker = CreateSensorMarker(sensor);\n            new Marker(marker).setLngLat([sensor.geolocation.longitude, sensor.geolocation.latitude]).addTo(map);\n        });\n    }\n}", "CodeBleu_score": 54.32701259709645}, {"code": "async function DisplaySensors(map){\n\t// generate client for API\n    const apiClient = generateClient();\n\n    // send GraphQL query to retrieve list of sensors\n    const { data } = await apiClient.query({\n        query: listSensors\n    });\n\n    // if there is data, log the retrieval of sensors\n    if (data) {\n        console.log('retrieved sensors: ', data.listSensors.items);\n\n        // iterate through each sensor to create a marker\n        data.listSensors.items.forEach(sensor => {\n            // create a marker for each sensor\n            const marker = new Marker({\n                element: CreateSensorMarker(sensor),\n                anchor: 'bottom',\n                color: '#000',\n                draggable: false\n            });\n\n            // set the marker's geographical coordinates\n            marker.setLngLat([sensor.location.longitude, sensor.location.latitude]);\n\n            // add the marker to the map\n            marker.addTo(map);\n        });\n    }\n}", "CodeBleu_score": 50.16896531810894}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.background = '#000';\n    marker.style.border = '2px solid #000';\n    return marker;\n}", "CodeBleu_score": 44.154756596129815}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.background = 'blue';\n    marker.style.border = '2px solid #fff';\n    return marker;\n}", "CodeBleu_score": 44.20927947309}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.background = '#11b4da';\n    marker.style.border = '2px solid #f4f3f0';\n    return marker;\n}", "CodeBleu_score": 43.730828990044465}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmfa_module = await async_import_module(\n        f\"homeassistant.auth.mfa_modules.{module_name}\"\n    )\n    if mfa_module is None:\n        _LOGGER.error(\n            \"Multi-factor auth module %s not found. Please check your configuration.\",\n            module_name,\n        )\n        raise ImportError(f\"Unable to import mfa module {module_name}\")\n\n    if DATA_REQS not in hass.data:\n        hass.data[DATA_REQS] = set()\n\n    if module_name not in hass.data[DATA_REQS]:\n        if not await requirements.async_process_requirements(\n            hass, mfa_module.REQUIREMENTS, \"mfa_module\", module_name\n        ):\n            raise HomeAssistantError(\n                f\"Unable to set up mfa module {module_name} because its requirements are not met\"\n            )\n\n        hass.data[DATA_REQS].add(module_name)\n\n    return mfa_module\n\n", "CodeBleu_score": 38.749812134863724}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tif module_name in MULTI_FACTOR_AUTH_MODULES:\n        return MULTI_FACTOR_AUTH_MODULES[module_name]\n\n    module = await async_import_module(\n        f\"homeassistant.auth.mfa_modules.{module_name}\", __name__\n    )\n\n    if module is None:\n        _LOGGER.error(\"Unable to import multi-factor module %s\", module_name)\n        raise HomeAssistantError(f\"Unable to import multi-factor module {module_name}\")\n\n    if not hasattr(module, \"MULTI_FACTOR_AUTH_MODULE\"):\n        _LOGGER.error(\n            \"Unable to import multi-factor module %s: no MULTI_FACTOR_AUTH_MODULE\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import multi-factor module {module_name}: no MULTI_FACTOR_AUTH_MODULE\"\n        )\n\n    if module_name not in DATA_REQS:\n        DATA_REQS[module_name] = set()\n\n        if not await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, DATA_REQS[module_name]\n        ):\n            _LOGGER.error(\n                \"Unable to import multi-factor module %s: requirements not met\",\n                module_name,\n            )\n            raise HomeAssistantError(\n                f\"Unable to import multi-factor module {module_name}: requirements not met\"\n            )\n\n    MULTI_FACTOR_AUTH_MODULES[module_name] = module.MULTI_FACTOR_AUTH_MODULE\n    return module.MULTI_FACTOR_AUTH_MODULE\n\n", "CodeBleu_score": 35.296288457716045}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tif module_name in MULTI_FACTOR_AUTH_MODULES:\n        return MULTI_FACTOR_AUTH_MODULES[module_name]\n\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading multi-factor module %s: %s\",\n            module_name,\n            err,\n        )\n        raise\n\n    if module_name not in MULTI_FACTOR_AUTH_MODULES:\n        _LOGGER.error(\n            \"Multi-factor module %s does not contain class 'MultiFactorAuthModule'\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"Multi-factor module {module_name} does not contain class 'MultiFactorAuthModule'\"\n        )\n\n    if module_path not in hass.data.get(DATA_REQS, set()):\n        if not await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS\n        ):\n            raise HomeAssistantError(\n                f\"Multi-factor module {module_name} is not installed\"\n            )\n\n        hass.data[DATA_REQS].add(module_path)\n\n    return module\n\n", "CodeBleu_score": 49.152292170324465}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tfor entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = setup_data[\"pin\"]\n            return True\n\n    self._data.append({\"user_id\": user_id, \"pin\": setup_data[\"pin\"]})\n    return True\n\n", "CodeBleu_score": 49.131150182198546}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif setup_data[\"pin\"] == \"\":\n        raise ValueError(\"PIN is required\")\n\n    for entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = setup_data[\"pin\"]\n            return True\n\n    self._data.append({\"user_id\": user_id, \"pin\": setup_data[\"pin\"]})\n    return True\n\n", "CodeBleu_score": 45.23173005431935}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif not (pin := setup_data.get(\"pin\")):\n        raise ValueError(\"Missing PIN\")\n    for entry in self._data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 60.21353856587118}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._user_settings is not None:\n            return\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {STORAGE_USERS: {}}\n        self._user_settings = OrderedDict()\n        for user_id, user_data in data[STORAGE_USERS].items():\n            user_setting = NotifySetting(\n                secret=user_data[STORAGE_USER_ID],\n                counter=user_data[STORAGE_USER_ID],\n                notify_service=user_data.get(STORAGE_USER_ID),\n                target=user_data.get(STORAGE_USER_ID),\n            )\n            self._user_settings[user_id] = user_setting\n\n", "CodeBleu_score": 45.23986044608792}, {"code": "async def _async_load(self) -> None\n\tif self._user_settings is not None:\n        return\n\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._user_store.async_load() or {}\n        self._user_settings = OrderedDict()\n        for user_id, user_data in data.get(STORAGE_USERS, {}).items():\n            self._user_settings[user_id] = NotifySetting(\n                user_data[STORAGE_USER_ID],\n                user_data.get(NotifySetting.secret.name),\n                user_data.get(NotifySetting.counter.name),\n                user_data.get(NotifySetting.notify_service.name),\n                user_data.get(NotifySetting.target.name),\n            )\n\n", "CodeBleu_score": 46.420680698326095}, {"code": "async def _async_load(self) -> None\n\tasync with self._init_lock:\n        if self._user_settings is None:\n            data = await self._user_store.async_load()\n            self._user_settings = OrderedDict()\n            if data is not None:\n                for user_id, user_data in data.items():\n                    self._user_settings[user_id] = NotifySetting(\n                        user_data[STORAGE_USER_ID],\n                        user_data.get(STORAGE_USERS, {}),\n                    )\n            else:\n                data = {}\n            for user in await self.hass.auth.async_get_users():\n                if user.id not in self._user_settings:\n                    self._user_settings[user.id] = NotifySetting(user.id)\n                    data[user.id] = {STORAGE_USER_ID: user.id}\n            await self._user_store.async_save(data)\n\n", "CodeBleu_score": 35.5649329004437}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tCHEMA = MULTI_FACTOR_AUTH_MODULE_SCHEMA.extend(\n    {\n        vol.Optional(CONF_INCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_EXCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_MESSAGE, default=\\\"{} is your Home Assistant login code\\\"): str,\n    },\n    extra=vol.PREVENT_EXTRA,", "CodeBleu_score": 37.53850067062267}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tCHEMA = MULTI_FACTOR_AUTH_MODULE_SCHEMA.extend(\n    {\n        vol.Optional(CONF_INCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_EXCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_MESSAGE, default=\\\"{} is your Home Assistant login code\\\"): str,\n    },\n    extra=vol.PREVENT_EXTRA,", "CodeBleu_score": 37.53850067062267}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tCHEMA = MULTI_FACTOR_AUTH_MODULE_SCHEMA.extend(\n    {\n        vol.Optional(CONF_INCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_EXCLUDE): vol.All(cv.ensure_list, [cv.string]),\n        vol.Optional(CONF_MESSAGE, default=\\\"{} is your Home Assistant login code\\\"): str,\n    },\n    extra=vol.PREVENT_EXTRA,", "CodeBleu_score": 37.53850067062267}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.3044905491215}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 62.894125800463605}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.entities.get(entity_id)\n    if not entity:\n        return None\n\n    device = perm_lookup.devices.get(entity.device_id)\n    if not device:\n        return None\n\n    area_id = device.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.24489783064349}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tmerged_policy: dict[str, CategoryType] = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, category_data in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = category_data\n            else:\n                merged_policy[category] = merge_categories(\n                    merged_policy[category], category_data\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 44.74144150156919}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tnew_policy: dict[CategoryType, list[str]] = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category, rules in policy.items():\n            if category not in seen_categories:\n                new_policy[category] = rules\n                seen_categories.add(category)\n            else:\n                new_policy[category] = list(set(new_policy[category] + rules))\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 44.38135472533279}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tmerged_policy: dict[str, CategoryType] = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, category_dict in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {\n                    \"description\": category_dict[\"description\"],\n                    \"subcategories\": {\n                        subcategory: subcategory_dict\n                        for policy in policies\n                        for subcategory, subcategory_dict in policy[category][\"subcategories\"].items()\n                    },\n                }\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 40.93111529009157}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(\n            f\"homeassistant.auth.providers.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\n            \"Error loading auth provider %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError() from err\n    if not getattr(module, \"REQUIREMENTS\", None):\n        return module\n    processed = hass.data.get(DATA_REQS)\n    if not processed:\n        processed = hass.data[DATA_REQS] = set()\n    if provider in processed:\n        return module\n    processed.add(provider)\n    await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 59.54955581758169}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tmodule = await async_import_module(\n        f\"homeassistant.auth.providers.{provider}\"\n    )\n    if not module:\n        raise HomeAssistantError(f\"Unable to import provider {provider}\")\n    if not getattr(module, \"REQUIREMENTS\", None):\n        return module\n    if DATA_REQS not in hass.data:\n        hass.data[DATA_REQS] = set()\n    if provider in hass.data[DATA_REQS]:\n        return module\n    try:\n        await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    except requirements.RequirementsNotFound as err:\n        _LOGGER.error(\n            \"Error processing requirements for provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError from err\n    hass.data[DATA_REQS].add(provider)\n    return module\n\n", "CodeBleu_score": 43.94413230114981}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tmodule = await async_import_module(\n        f\"homeassistant.auth.providers.{provider}\", __name__\n    )\n    if not module:\n        raise HomeAssistantError(f\"Unable to import auth provider {provider}\")\n    if not getattr(module, \"REQUIREMENTS\", None):\n        return module\n    if not hass.data.get(DATA_REQS):\n        hass.data[DATA_REQS] = set()\n    if provider in hass.data[DATA_REQS]:\n        return module\n    hass.data[DATA_REQS].add(provider)\n    await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 36.97183815353832}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tself._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n\n    # Check for legacy usernames\n    legacy_usernames = [\n        username\n        for usernames in self._data.values()\n        for username in usernames\n        if username.strip() != username\n    ]\n    if legacy_usernames:\n        _LOGGER.warning(\n            \"The following usernames are not normalized and will be normalized in the future: %s\",\n            legacy_usernames,\n        )\n        self.is_legacy = True\n\n", "CodeBleu_score": 26.626319329205405}, {"code": "async def async_load(self) -> None\n\tself._data = await self._store.async_load() or {}\n\n    # Legacy mode will allow usernames to start/end with whitespace\n    # and will compare usernames case-insensitive.\n    # Deprecated in June 2019 and will be removed in 2026.7\n    self.is_legacy = await self.hass.async_add_executor_job(\n        lambda: self._data.get(\"legacy_mode\", False)\n    )\n\n    # Remove legacy mode from the data\n    if self.is_legacy:\n        del self._data[\"legacy_mode\"]\n\n    # Normalize all usernames in the data\n    for user_data in self._data.values():\n        for user in user_data:\n            user[\"username\"] = self.normalize_username(user[\"username\"])\n\n", "CodeBleu_score": 24.792514801464524}, {"code": "async def async_load(self) -> None\n\tself._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n    # Check for non-normalized usernames\n    for username in self._data:\n        if username != self.normalize_username(username):\n            self.is_legacy = True\n            break\n\n", "CodeBleu_score": 25.963134728817078}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.data.normalize_username(username)\n\n    for user in self.data.users:\n        if user[\"username\"] == username:\n            break\n    else:\n        # No user found, do a dummy hash check\n        bcrypt.checkpw(password.encode(), b\"\")\n        raise InvalidAuth\n\n    stored_password_hash = base64.b64decode(user[\"password\"])\n    if not bcrypt.checkpw(password.encode(), stored_password_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 42.58093004047236}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.data.normalize_username(username)\n\n    for user in self.data.users:\n        if user[\"username\"] == username:\n            stored_password = user[\"password\"].encode(\"utf-8\")\n            break\n    else:\n        bcrypt.checkpw(b\"\", b\"\")\n        raise InvalidAuth\n\n    password_hash = base64.b64decode(stored_password)\n    if not bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 41.32908187668788}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt(10))\n    for user in self.data.users:\n        if user[\"username\"] == username:\n            break\n    else:\n        bcrypt.checkpw(password.encode(), dummy_hash)\n        raise InvalidAuth\n    stored_hash = base64.b64decode(user[\"password\"])\n    if not bcrypt.checkpw(password.encode(), stored_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 43.869727120695565}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tAGE_VERSION = 1", "CodeBleu_score": 5.181409862762599}, {"code": "def async_remove_auth(self, username: str) -> None\n\tAGE_VERSION = 1", "CodeBleu_score": 5.181409862762599}, {"code": "def async_remove_auth(self, username: str) -> None\n\tAGE_VERSION = 1", "CodeBleu_score": 5.181409862762599}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t.hash_password(password, True).decode(),\n            }\n        )\n\n    @callback\n    def async_remove_auth(self, username: str) -> None:\n        \\\"\\\"\\\"Remove authentication.\\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        index = None\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                index = i\n                break\n\n        if index is None:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n        self.users.pop(index)\n\n    def change_password(self, username: str, new_password: str) -> None:\n        \\\"\\\"\\\"Update the password.\n\n        Raises InvalidUser if user cannot be found.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"password\\\"] = self.hash_password(new_password, True).decode()\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    @callback\n    def _validate_new_username(self, new_username: str) -> None:\n        \\\"\\\"\\\"Validate that username is normalized and unique.\n\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        normalized_username = self.normalize_username(\n            new_username, force_normalize=True\n        )\n        if normalized_username != new_username:\n            raise InvalidUsername(\n                translation_key=\\\"username_not_normalized\\\",\n                translation_placeholders={\\\"new_username\\\": new_username},\n            )\n\n        if any(\n            self.normalize_username(user[\\\"username\\\"]) == normalized_username\n            for user in self.users\n        ):\n            raise InvalidUsername(\n                translation_key=\\\"username_already_exists\\\",\n                translation_placeholders={\\\"username\\\": new_username},\n            )\n\n    @callback\n    def change_username(self, username: str, new_username: str) -> None:\n        \\\"\\\"\\\"Update the username.\n\n        Raises InvalidUser if user cannot be found.\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n        self._validate_new_username(new_username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"username\\\"] = new_username\n                assert self._data is not None\n                self._async_check_for_not_normalized_usernames(self._data)\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\\\"\\\"\\\"\n        if self._data is not None:\n            await self._store.async_save(self._data)\n\n", "CodeBleu_score": 34.43998125714642}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t.hash_password(password, True).decode(),\n            }\n        )\n\n    @callback\n    def async_remove_auth(self, username: str) -> None:\n        \\\"\\\"\\\"Remove authentication.\\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        index = None\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                index = i\n                break\n\n        if index is None:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n        self.users.pop(index)\n\n    def change_password(self, username: str, new_password: str) -> None:\n        \\\"\\\"\\\"Update the password.\n\n        Raises InvalidUser if user cannot be found.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"password\\\"] = self.hash_password(new_password, True).decode()\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    @callback\n    def _validate_new_username(self, new_username: str) -> None:\n        \\\"\\\"\\\"Validate that username is normalized and unique.\n\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        normalized_username = self.normalize_username(\n            new_username, force_normalize=True\n        )\n        if normalized_username != new_username:\n            raise InvalidUsername(\n                translation_key=\\\"username_not_normalized\\\",\n                translation_placeholders={\\\"new_username\\\": new_username},\n            )\n\n        if any(\n            self.normalize_username(user[\\\"username\\\"]) == normalized_username\n            for user in self.users\n        ):\n            raise InvalidUsername(\n                translation_key=\\\"username_already_exists\\\",\n                translation_placeholders={\\\"username\\\": new_username},\n            )\n\n    @callback\n    def change_username(self, username: str, new_username: str) -> None:\n        \\\"\\\"\\\"Update the username.\n\n        Raises InvalidUser if user cannot be found.\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n        self._validate_new_username(new_username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"username\\\"] = new_username\n                assert self._data is not None\n                self._async_check_for_not_normalized_usernames(self._data)\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\\\"\\\"\\\"\n        if self._data is not None:\n            await self._store.async_save(self._data)\n\n", "CodeBleu_score": 34.43998125714642}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t.hash_password(password, True).decode(),\n            }\n        )\n\n    @callback\n    def async_remove_auth(self, username: str) -> None:\n        \\\"\\\"\\\"Remove authentication.\\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        index = None\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                index = i\n                break\n\n        if index is None:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n        self.users.pop(index)\n\n    def change_password(self, username: str, new_password: str) -> None:\n        \\\"\\\"\\\"Update the password.\n\n        Raises InvalidUser if user cannot be found.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"password\\\"] = self.hash_password(new_password, True).decode()\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    @callback\n    def _validate_new_username(self, new_username: str) -> None:\n        \\\"\\\"\\\"Validate that username is normalized and unique.\n\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        normalized_username = self.normalize_username(\n            new_username, force_normalize=True\n        )\n        if normalized_username != new_username:\n            raise InvalidUsername(\n                translation_key=\\\"username_not_normalized\\\",\n                translation_placeholders={\\\"new_username\\\": new_username},\n            )\n\n        if any(\n            self.normalize_username(user[\\\"username\\\"]) == normalized_username\n            for user in self.users\n        ):\n            raise InvalidUsername(\n                translation_key=\\\"username_already_exists\\\",\n                translation_placeholders={\\\"username\\\": new_username},\n            )\n\n    @callback\n    def change_username(self, username: str, new_username: str) -> None:\n        \\\"\\\"\\\"Update the username.\n\n        Raises InvalidUser if user cannot be found.\n        Raises InvalidUsername if the new username is invalid.\n        \\\"\\\"\\\"\n        username = self.normalize_username(username)\n        self._validate_new_username(new_username)\n\n        for user in self.users:\n            if self.normalize_username(user[\\\"username\\\"]) == username:\n                user[\\\"username\\\"] = new_username\n                assert self._data is not None\n                self._async_check_for_not_normalized_usernames(self._data)\n                break\n        else:\n            raise InvalidUser(translation_key=\\\"user_not_found\\\")\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\\\"\\\"\\\"\n        if self._data is not None:\n            await self._store.async_save(self._data)\n\n", "CodeBleu_score": 34.43998125714642}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not hasattr(thread, \"ident\"):\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        try:\n            thread.join(timeout)\n            joined.add(thread)\n        except Exception:  # pylint: disable=broad-except\n            pass\n    for thread in threads - joined:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 52.81855597204639}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        try:\n            thread.join(timeout)\n        except Exception:  # pylint: disable=broad-except\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            async_raise(thread.ident, SystemExit)\n        except Exception:  # pylint: disable=broad-except\n            pass\n    return joined\n\n", "CodeBleu_score": 50.71564125033062}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tif log:\n        _LOGGER.info(\\\"Joining %s threads\\\", len(threads))\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        ident = thread.ident\n        if ident is None:\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout=timeout)\n        except Exception:  # pylint: disable=broad-except\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, ident)\n        async_raise(ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 55.2306541150676}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t# Calculate timeout for each thread.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlocks.\n    #\n    # We need to do this before joining any threads to avoid deadlock", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\tdef get_threads() -> list[threading.Thread]:\n        threads = []\n        for thread in threading.enumerate():\n            if thread.is_alive() and not thread.daemon and not inspect.isframe(thread):\n                threads.append(thread)\n        return threads\n\n    def join_thread(thread: threading.Thread, timeout: int) -> None:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            _LOGGER.warning(\n                \"Failed to join thread %s within %s seconds\", thread.name, timeout\n            )\n\n    threads = get_threads()\n    if not threads:\n        return\n\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        join_thread(thread, timeout)\n\n", "CodeBleu_score": 41.35013425187329}, {"code": "def deadlock_safe_shutdown() -> None\n\t# Get all non-main, non-daemon, alive threads\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread.is_alive() and not thread.daemon and not thread.name == \"MainThread\"\n    ]\n    # Calculate timeout for each thread\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    # Join each thread within timeout\n    for thread in threads:\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError as exception:\n            _LOGGER.warning(\n                \"Failed to join thread %s: %s\",\n                thread.name,\n                exception,\n            )\n    # Log a warning if any threads are still alive\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread.is_alive() and not thread.daemon and not thread.name == \"MainThread\"\n    ]\n    if threads:\n        _LOGGER.warning(\n            \"Failed to join %s threads: %s\",\n            len(threads),\n            \", \".join(thread.name for thread in threads),\n        )\n\n", "CodeBleu_score": 43.049542663826465}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # Suppress overly verbose logs from libraries that aren't helpful\n    logging.getLogger(\\\"requests\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"urllib3\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"aiohttp.access\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"httpx\\\").setLevel(logging.WARNING)\n\n    sys.excepthook = lambda *args: logging.getLogger(None).exception(\n        \\\"Uncaught exception\\\", exc_info=args\n    )\n    threading.excepthook = lambda args: logging.getLogger(None).exception(\n        \\\"Uncaught thread exception\\\",\n        exc_info=(  # type: ignore[arg-type]\n            args.exc_type,\n            args.exc_value,\n            args.exc_traceback,\n        ),\n    )\n\n    # Log errors to a file if we have write access to file or config dir\n    if log_file is None:\n        err_log_path = hass.config.path(ERROR_LOG_FILENAME)\n    else:\n        err_log_path = os.path.abspath(log_file)\n\n    err_path_exists = os.path.isfile(err_log_path)\n    err_dir = os.path.dirname(err_log_path)\n\n    # Check if we can write to the error log if it exists or that\n    # we can create files in the containing directory if not.\n    if (err_path_exists and os.access(err_log_path, os.W_OK)) or (\n        not err_path_exists and os.access(err_dir, os.W_OK)\n    ):\n        err_handler = await hass.async_add_executor_job(\n            _create_log_file, err_log_path, log_rotate_days\n        )\n\n        err_handler.setLevel(logging.INFO if verbose else logging.WARNING)\n        err_handler.setFormatter(logging.Formatter(fmt, datefmt=FORMAT_DATETIME))\n\n        logger = logging.getLogger(\\\"\\\")\n        logger.addHandler(err_handler)\n        logger.setLevel(logging.INFO if verbose else logging.WARNING)\n\n        # Save the log file location for access by other components.\n        hass.data[DATA_LOGGING] = err_log_path\n    else:\n        _LOGGER.error(\\\"Unable to set up error log %s (access denied)\\\", err_log_path)\n\n    async_activate_log_queue_handler(hass)\n\n", "CodeBleu_score": 41.01324891771487}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # Suppress overly verbose logs from libraries that aren't helpful\n    logging.getLogger(\\\"requests\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"urllib3\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"aiohttp.access\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"httpx\\\").setLevel(logging.WARNING)\n\n    sys.excepthook = lambda *args: logging.getLogger(None).exception(\n        \\\"Uncaught exception\\\", exc_info=args\n    )\n    threading.excepthook = lambda args: logging.getLogger(None).exception(\n        \\\"Uncaught thread exception\\\",\n        exc_info=(  # type: ignore[arg-type]\n            args.exc_type,\n            args.exc_value,\n            args.exc_traceback,\n        ),\n    )\n\n    # Log errors to a file if we have write access to file or config dir\n    if log_file is None:\n        err_log_path = hass.config.path(ERROR_LOG_FILENAME)\n    else:\n        err_log_path = os.path.abspath(log_file)\n\n    err_path_exists = os.path.isfile(err_log_path)\n    err_dir = os.path.dirname(err_log_path)\n\n    # Check if we can write to the error log if it exists or that\n    # we can create files in the containing directory if not.\n    if (err_path_exists and os.access(err_log_path, os.W_OK)) or (\n        not err_path_exists and os.access(err_dir, os.W_OK)\n    ):\n        err_handler = await hass.async_add_executor_job(\n            _create_log_file, err_log_path, log_rotate_days\n        )\n\n        err_handler.setLevel(logging.INFO if verbose else logging.WARNING)\n        err_handler.setFormatter(logging.Formatter(fmt, datefmt=FORMAT_DATETIME))\n\n        logger = logging.getLogger(\\\"\\\")\n        logger.addHandler(err_handler)\n        logger.setLevel(logging.INFO if verbose else logging.WARNING)\n\n        # Save the log file location for access by other components.\n        hass.data[DATA_LOGGING] = err_log_path\n    else:\n        _LOGGER.error(\\\"Unable to set up error log %s (access denied)\\\", err_log_path)\n\n    async_activate_log_queue_handler(hass)\n\n", "CodeBleu_score": 41.01324891771487}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # Suppress overly verbose logs from libraries that aren't helpful\n    logging.getLogger(\\\"requests\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"urllib3\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"aiohttp.access\\\").setLevel(logging.WARNING)\n    logging.getLogger(\\\"httpx\\\").setLevel(logging.WARNING)\n\n    sys.excepthook = lambda *args: logging.getLogger(None).exception(\n        \\\"Uncaught exception\\\", exc_info=args\n    )\n    threading.excepthook = lambda args: logging.getLogger(None).exception(\n        \\\"Uncaught thread exception\\\",\n        exc_info=(  # type: ignore[arg-type]\n            args.exc_type,\n            args.exc_value,\n            args.exc_traceback,\n        ),\n    )\n\n    # Log errors to a file if we have write access to file or config dir\n    if log_file is None:\n        err_log_path = hass.config.path(ERROR_LOG_FILENAME)\n    else:\n        err_log_path = os.path.abspath(log_file)\n\n    err_path_exists = os.path.isfile(err_log_path)\n    err_dir = os.path.dirname(err_log_path)\n\n    # Check if we can write to the error log if it exists or that\n    # we can create files in the containing directory if not.\n    if (err_path_exists and os.access(err_log_path, os.W_OK)) or (\n        not err_path_exists and os.access(err_dir, os.W_OK)\n    ):\n        err_handler = await hass.async_add_executor_job(\n            _create_log_file, err_log_path, log_rotate_days\n        )\n\n        err_handler.setLevel(logging.INFO if verbose else logging.WARNING)\n        err_handler.setFormatter(logging.Formatter(fmt, datefmt=FORMAT_DATETIME))\n\n        logger = logging.getLogger(\\\"\\\")\n        logger.addHandler(err_handler)\n        logger.setLevel(logging.INFO if verbose else logging.WARNING)\n\n        # Save the log file location for access by other components.\n        hass.data[DATA_LOGGING] = err_log_path\n    else:\n        _LOGGER.error(\\\"Unable to set up error log %s (access denied)\\\", err_log_path)\n\n    async_activate_log_queue_handler(hass)\n\n", "CodeBleu_score": 41.01324891771487}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_path = config.get_bluetooth_path()\n    if not bluetooth_path.exists():\n        return\n\n    try:\n        bluetooth_content = bluetooth_path.read_text()\n    except OSError as err:\n        config.validation_errors.append(\n            \"Error while reading bluetooth.py file: {}\".format(err)\n        )\n        return\n\n    try:\n        generated_content = generate_and_validate(integrations)\n    except Exception as err:\n        config.validation_errors.append(\n            \"Error while generating bluetooth.py file: {}\".format(err)\n        )\n        return\n\n    if bluetooth_content == generated_content:\n        return\n\n    config.validation_errors.append(\n        \"bluetooth.py file is not up to date. Run `python -m homeassistant bluetooth` to update it.\"\n    )\n\n    config.validation_suggestions.append(\n        {\n            \"fix\": {\n                \"function\": \"generate_and_validate\",\n                \"path\": bluetooth_path,\n                \"content\": generated_content,\n            },\n            \"description\": \"Update bluetooth.py file\",\n        }\n    )\n\n", "CodeBleu_score": 44.07947959765778}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif not config.validate:\n        return\n\n    import pathlib\n\n    import black\n    import isort\n    import pylint.lint\n    import voluptuous\n    import voluptuous.humanize\n\n    from .model import Integration\n\n    from . import generate_and_validate\n\n    bluetooth_path = pathlib.Path(config.core_path, \"homeassistant\", \"components\", \"bluetooth\", \"bluetooth.py\")\n\n    generated_content = generate_and_validate(integrations)\n\n    if bluetooth_path.exists():\n        with open(bluetooth_path, \"r\") as bluetooth_file:\n            current_content = bluetooth_file.read()\n\n        if current_content == generated_content:\n            return\n\n        errors = pylint.lint.Run([str(bluetooth_path)], do_exit=False)\n\n        if errors.total_errors:\n            errors = voluptuous.humanize.humanize_error(errors)\n            errors = \"\".join(errors)\n            config.errors.append(f\"{bluetooth_path}: {errors}\")\n            return\n\n        config.errors.append(\n            f\"{bluetooth_path} needs to be updated:", "CodeBleu_score": 41.228830300206134}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\timport logging\n    from pathlib import Path\n    from typing import Final\n\n    from .model import Config, Integration\n    from .serializer import format_python_namespace\n\n    _LOGGER = logging.getLogger(__name__)\n\n\n\n\n    def generate_and_validate(integrations: dict[str, Integration]) -> str:\n    \\\"\\\"\\\"Validate and generate bluetooth data.\\\"\\\"\\\"\n    match_list = []\n\n    for domain in sorted(integrations):\n        match_types = integrations[domain].manifest.get(\\\"bluetooth\\\", [])\n\n        if not match_types:\n            continue\n\n        match_list.extend({\\\"domain\\\": domain, **entry} for entry in match_types)\n\n    return format_python_namespace(\n        {\\\"BLUETOOTH\\\": match_list},\n        annotations={\n            \\\"BLUETOOTH\\\": \\\"Final[list[dict[str, bool | str | int | list[int]]]]\\\"\n        },\n    )\n\n\n\n\n", "CodeBleu_score": 30.25324731174772}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.72900406179113}, {"code": "func (d *Dropbox) refreshToken() error{\n\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.72900406179113}, {"code": "func (d *Dropbox) refreshToken() error{\n\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 95.72900406179113}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.AccessToken == \"\" {\n\t\treturn nil, fmt.Errorf(\"access token is empty\")\n\t}\n\tvar err error\n\tvar res *resty.Response\n\tvar retry bool\n\tfor {\n\t\tif retry {\n\t\t\terr = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tretry = false\n\t\tif callback != nil {\n\t\t\tcallback(d.AccessToken)\n\t\t}\n\t\tres, err = base.RestyClient.R().SetResult(resp).SetAuthToken(d.AccessToken).Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif res.StatusCode() == 401 {\n\t\t\tretry = true\n\t\t\tcontinue\n\t\t}\n\t\tif res.StatusCode() != 200 {\n\t\t\treturn nil, fmt.Errorf(\"request failed: %s\", res.String())\n\t\t}\n\t\tbreak\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 52.570659583891455}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.AccessToken == \"\" {\n\t\tif d.RefreshToken == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"refresh token is empty\")\n\t\t}\n\t\terr := d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tvar (\n\t\treq    *http.Request\n\t\terr    error\n\t\tclient = &http.Client{}\n\t\tres    *http.Response\n\t\tbody   []byte\n\t)\n\tfor i := 0; i < 2; i++ {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif callback != nil {\n\t\t\tcallback(req)\n\t\t}\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t\treq.Header.Set(\"X-Goog-Upload-Protocol\", \"raw\")\n\t\treq.Header.Set(\"X-Goog-Upload-Command\", \"start\")\n\t\treq.Header.Set(\"X-Goog-Upload-Header-Content-Length\", \"0\")\n\t\treq.Header.Set(\"X-Goog-Upload-Header-Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"X-Goog-Upload-Offset\", \"0\")\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"Content-Length\", \"0\")\n\t\tres, err = client.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif res.StatusCode == 401 {\n\t\t\tif i == 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to refresh token\")\n\t\t\t}\n\t\t\terr = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif res.StatusCode != 200 {\n\t\t\treturn nil, fmt", "CodeBleu_score": 48.989615288384755}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.AccessToken == \"\" {\n\t\treturn nil, fmt.Errorf(\"no access token\")\n\t}\n\t// Set the authorization header.\n\theaders := map[string]string{\"Authorization\": \"Bearer \" + d.AccessToken}\n\t// Set the drive and team drive parameters.\n\tparams := map[string]string{\"supportsAllDrives\": \"true\", \"includeItemsFromAllDrives\": \"true\"}\n\t// Send the request.\n\treturn base.Request(url, method, callback, resp, headers, params)\n}", "CodeBleu_score": 21.85942750196545}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = 100 * 1024 * 1024\n\t}\n\tchunkSize := d.ChunkSize\n\tvar offset int64\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\tchunk, err := stream.Read(chunkSize)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif len(chunk) == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// If the context is canceled, the request will be interrupted.\n\t\t// If the context is not canceled, the request will continue.\n\t\t// The request will continue until the entire file is uploaded.\n\t\t// If the request is interrupted, it will be resumed and the file will be uploaded.\n\t\t// If the request is completed, it will be completed and the file will be uploaded.\n\t\t// If the request is interrupted, the request will be resumed and the file will be uploaded.\n\t\t// If the request is completed, the request will be completed and the file will be uploaded.\n\t\t// If the request is interrupted, the request will be resumed and the file will be uploaded.\n\t\t// If the request is completed, the request will be completed and the file will be uploaded.\n\t\t// If the request is interrupted, the request will be resumed and the file will be uploaded.\n\t\t// If the request is completed, the request will be completed and the file will be uploaded.\n\t\t// If the request is interrupted, the request will be resumed and the file will be uploaded.\n\t\t// If the request is completed, the request will be completed and the file will be uploaded.\n\t\t// If the request is interrupted, the request will be resumed and the file will be uploaded.\n\t\t// If the request is completed, the request will be completed and the file will be uploaded.\n\t\t// If the request is interrupted, the request will be resumed and the file will be uploaded.\n\t\t// If the request is completed, the request will be completed and the file", "CodeBleu_score": 24.35904551391408}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := 20 * 1024 * 1024 // 20MB\n\tvar offset int64\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\tchunk, err := stream.NextChunk(chunkSize, offset)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(chunk) == 0 {\n\t\t\tbreak\n\t\t}\n\t\theaders := map[string]string{\n\t\t\t\"Content-Type\": \"application/octet-stream\",\n\t\t\t\"Content-Range\": fmt.Sprintf(\"bytes %d-%d/%d\",\n\t\t\t\toffset, offset+int64(len(chunk))-1, stream.Size()),\n\t\t}\n\t\t_, err = d.request(url, http.MethodPut, func(req *resty.Request) {\n\t\t\treq.SetBody(chunk)\n\t\t\treq.SetHeaders(headers)\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toffset += int64(len(chunk))\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.160967528732876}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tif d.ChunkSize == 0 {\n\t\td.ChunkSize = 5 * 1024 * 1024 // 5 MB\n\t}\n\tchunkSize := d.ChunkSize\n\tfileSize := stream.Size()\n\tchunkCount := int(fileSize / chunkSize)\n\tif fileSize%chunkSize != 0 {\n\t\tchunkCount++\n\t}\n\tlogger.Info(\"upload file\", zap.String(\"file_name\", stream.Name()), zap.Int64(\"file_size\", fileSize), zap.Int(\"chunk_count\", chunkCount))\n\tfor i := 0; i < chunkCount; i++ {\n\t\tif i != 0 {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tstart := i * chunkSize\n\t\tend := (i + 1) * chunkSize\n\t\tif end > fileSize {\n\t\t\tend = fileSize\n\t\t}\n\t\tbuf := make([]byte, end-start)\n\t\t_, err := stream.Read(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar resp base.TokenResp\n\t\tvar e Error\n\t\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\t\tSetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, end-1, fileSize)).\n\t\t\tSetHeader(\"Content-Type\", \"application/octet-stream\").\n\t\t\tSetBody(buf).\n\t\t\tPost(url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlogger.Info(\"upload file\", zap.String(\"res\", res.String()))\n\t\tif e.Error.Code != 0 {\n\t\t\tif e.Error.Code == 401 {\n\t\t\t\terr = d.refreshToken()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn", "CodeBleu_score": 42.56399512963576}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req model.MountPoint\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DelStorage(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 68.86894343976164}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req model.MountPointReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DeleteConfigByName(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 69.15827320242866}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar req model.MountPointReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DeleteConfig(req.MountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 68.11429543852668}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\n\t// The function \"ReadFile\" reads the content of a file.\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\n\t// The function \"Send\" sends a response to the client.\n\treturn ctx.Send(http.StatusOK, info)\n}", "CodeBleu_score": 74.62469930854321}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// The function \"ReadFile\" reads the content of a file.\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.96622600230232}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// The function \"ioutil.ReadFile\" reads the file and returns the content as a byte slice.\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\t// The function \"ctx.File\" sends the file to the client.\n\treturn ctx.File(filePath, string(info))\n}", "CodeBleu_score": 74.23820412089742}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrBadRequest.Error())\n\t}\n\tname := ctx.Param(\"name\")\n\tif err := service.Notify.Send(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrBadRequest.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tCode:    0,\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 58.16742006344002}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ErrBadRequest.Error())\n\t}\n\n\terr := service.NotifyMessage(name, message)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ErrInternalError.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: true, Message: \"success\"})\n}", "CodeBleu_score": 57.16335281290711}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.FormValue(\"name\")\n\tmessage := ctx.FormValue(\"message\")\n\tservice.MyService.Notify().Send(name, message)\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: true, Message: \"success\"})\n}", "CodeBleu_score": 27.131937862000115}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t// upgrade http request to websocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// add the new connection to the list of connections\n\tservice.NotifyWS.AddWS(ws)\n\t// start the message sending service\n\tservice.NotifyWS.Start()\n\t// enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t_, p, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\n\", string(p))\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.14269630745846}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tservice.AddConn(conn)\n\tservice.InitNotify()\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tservice.RemoveConn(conn)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(message))\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.11253195422119}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn nil\n\t}\n\tservice.Notify.Add(conn)\n\tservice.Notify.Run()\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\n\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.95364706898823}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tpkg/utils\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/service\\\"\n\tmodel2 \\\"github.com/IceWhaleTech/CasaOS/service/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/types\\\"\n\t\\\"github.com/labstack/echo/v4\\\"\n\t\\\"github.com/tidwall/gjson\\\"", "CodeBleu_score": 11.53096653667843}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tpkg/utils\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/service\\\"\n\tmodel2 \\\"github.com/IceWhaleTech/CasaOS/service/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/types\\\"\n\t\\\"github.com/labstack/echo/v4\\\"\n\t\\\"github.com/tidwall/gjson\\\"", "CodeBleu_score": 11.53096653667843}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tpkg/utils\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/service\\\"\n\tmodel2 \\\"github.com/IceWhaleTech/CasaOS/service/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/types\\\"\n\t\\\"github.com/labstack/echo/v4\\\"\n\t\\\"github.com/tidwall/gjson\\\"", "CodeBleu_score": 11.53096653667843}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 72.10348925249164}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.14098320577163}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 73.15858310780028}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tlogger.Log.Info(\"SendNotify\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\tvar msg []byte\n\tvar err error\n\tif msg, err = json2.Marshal(message); err != nil {\n\t\tlogger.Log.Error(\"SendNotify\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t}\n\tif err = common.MQ.Publish(name, msg); err != nil {\n\t\tlogger.Log.Error(\"SendNotify\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t}\n}", "CodeBleu_score": 38.435996575973775}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tvar (\n\t\tjsonMessage []byte\n\t\terr         error\n\t)\n\tif jsonMessage, err = json2.Marshal(message); err != nil {\n\t\tlogger.Error(\"Failed to marshal message for notification\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\tlogger.Debug(\"Sending notification\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)))\n\tif err = common.Notify.Publish(name, jsonMessage); err != nil {\n\t\tlogger.Error(\"Failed to publish notification\", zap.String(\"name\", name), zap.Error(err))\n\t}\n}", "CodeBleu_score": 37.44626974940248}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tvar err error\n\tvar response *http.Response\n\tvar data []byte\n\tif data, err = json.Marshal(message); err != nil {\n\t\tlogger.Error(\"Error marshalling message: %s\", err)\n\t\treturn\n\t}\n\tif response, err = http.Post(fmt.Sprintf(\"http://%s/notify/%s\", common.CONFIG.Notify.Address, name), \"application/json\", bytes.NewBuffer(data)); err != nil {\n\t\tlogger.Error(\"Error sending message: %s\", err)\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Error sending message: %s\", response.Status)\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.61206773054484}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(config.MessageBusAddress(), message_bus.WithHTTPClient(c.gateway.HTTPClient()))\n}", "CodeBleu_score": 13.958683633667086}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tvar (\n\t\taddress string\n\t\terr     error\n\t)\n\n\tif len(config.SystemConfigInfo.RuntimePath) > 0 {\n\t\taddress, err = c.system.GetMessageBusAddress()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\taddress = \"http://localhost:8080\"\n\t}\n\n\treturn message_bus.NewClientWithResponses(address)\n}", "CodeBleu_score": 34.033601149215244}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tvar client = message_bus.NewClientWithResponses(config.MessageBusAddress)\n\n\tif config.MessageBusAddress != \"error\" {\n\t\tclient.Server = config.MessageBusAddress\n\t}\n\n\treturn client\n}", "CodeBleu_score": 29.964119593982417}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 57.38585365366337}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.TrimSpace(strings.Split(ip, \",\")[0])\n\tip = strings.TrimSpace(strings.Split(ip, \":\")[0])\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 68.63435452946504}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != \"\" {\n\t\treturn strings.Split(ip, \", \")[0]\n\t}\n\tip = request.RemoteAddr\n\tif ip != \"\" {\n\t\treturn strings.Split(ip, \":\")[0]\n\t}\n\treturn \"\"\n}", "CodeBleu_score": 35.553328201470165}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t// \u5b9a\u4e49\u6a21\u5757\u76ee\u5f55\u8def\u5f84\u548c\u5165\u53e3\u6587\u4ef6\u8def\u5f84\uff0c\u786e\u4fdd\u5165\u53e3\u6587\u4ef6\u5b58\u5728\n\tmodulePath := filepath.Join(common.GetWorkDir(), \"modules\")\n\tentryFilePath := filepath.Join(common.GetWorkDir(), \"entry.json\")\n\n\t// \u8bfb\u53d6\u6bcf\u4e2a\u6a21\u5757\u76ee\u5f55\u4e0b\u7684entry.json\u6587\u4ef6\uff0c\u5c06\u6587\u4ef6\u5185\u5bb9\u62fc\u63a5\u6210\u4e00\u4e2aJSON\u6570\u7ec4\uff0c\u5199\u5165\u5230\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\tfiles, err := file.GetAllFiles(modulePath, \"entry.json\")\n\tif err != nil {\n\t\tlogger.Error(\"read entry.json error\", zap.Error(err))\n\t\treturn\n\t}\n\tvar entrys []string\n\tfor _, file := range files {\n\t\tentry, err := file.ReadFullFile(file)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"read entry.json error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tentrys = append(entrys, string(entry))\n\t}\n\tif len(entrys) == 0 {\n\t\tlogger.Info(\"no entry.json file\")\n\t\treturn\n\t}\n\tentry := \"[\" + strings.Join(entrys, \",\") + \"]\"\n\terr = file.WriteFullFile(entryFilePath, []byte(entry))\n\tif err != nil {\n\t\tlogger.Error(\"write entry.json error\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 54.58301298310072}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tlogger.Log.Info(\"[systemService] GenreateSystemEntry\")\n\tmodulesDir := common.APP_PATH + \"/modules\"\n\tentryFilePath := common.APP_PATH + \"/entry.json\"\n\tif !file.PathExists(modulesDir) {\n\t\tlogger.Log.Error(\"[systemService] GenreateSystemEntry modulesDir not exist\")\n\t\treturn\n\t}\n\tif !file.PathExists(entryFilePath) {\n\t\tfile.CreateFile(entryFilePath)\n\t}\n\tfile.CreateFile(entryFilePath)\n\tdirs, err := file.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlogger.Log.Error(\"[systemService] GenreateSystemEntry ReadDir error:\", err)\n\t\treturn\n\t}\n\tvar entryFileContent []byte\n\tfor _, dir := range dirs {\n\t\tentryFilePath := modulesDir + \"/\" + dir + \"/entry.json\"\n\t\tif !file.PathExists(entryFilePath) {\n\t\t\tcontinue\n\t\t}\n\t\tentryFileContent = file.ReadFullFile(entryFilePath)\n\t\tif entryFileContent == nil {\n\t\t\tcontinue\n\t\t}\n\t\tentryFileContent = append(entryFileContent, []byte(\"\n\")...)\n\t}\n\tfile.WriteFile(entryFilePath, entryFileContent)\n}", "CodeBleu_score": 37.378210790028845}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// \u5b9a\u4e49\u6a21\u5757\u76ee\u5f55\n\tmodulePath := config.AppInfo.AppPath + \"/modules\"\n\t// \u5b9a\u4e49\u5165\u53e3\u6587\u4ef6\u8def\u5f84\n\tentryPath := config.AppInfo.AppPath + \"/entry.json\"\n\t// \u5b9a\u4e49\u5165\u53e3\u6587\u4ef6\n\tentryFile, err := os.OpenFile(entryPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)\n\tif err != nil {\n\t\tlogger.Error(\"Create entry.json file error:\", err)\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\t// \u8bfb\u53d6\u6a21\u5757\u76ee\u5f55\n\tdir, err := os.ReadDir(modulePath)\n\tif err != nil {\n\t\tlogger.Error(\"Read module directory error:\", err)\n\t\treturn\n\t}\n\t// \u904d\u5386\u6a21\u5757\u76ee\u5f55\n\tfor _, d := range dir {\n\t\t// \u5224\u65ad\u662f\u5426\u662f\u6587\u4ef6\u5939\n\t\tif d.IsDir() {\n\t\t\t// \u8bfb\u53d6\u6a21\u5757\u76ee\u5f55\u4e0b\u7684entry.json\u6587\u4ef6\n\t\t\tentryFile, err := os.OpenFile(modulePath+\"/\"+d.Name()+\"/entry.json\", os.O_RDONLY, 0755)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"Read entry.json file error:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer entryFile.Close()\n\t\t\t// \u8bfb\u53d6entry.json\u6587\u4ef6\u5185\u5bb9\n\t\t\tentry, err := io.ReadAll(entryFile)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"Read entry.json file error:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// \u5c06\u8bfb\u53d6\u7684entry.json\u6587\u4ef6\u5185\u5bb9\u5199\u5165\u5230entry.json\u6587\u4ef6\u4e2d\n\t\t\tentryFile.Write(entry)\n\t\t}\n\t}\n}", "CodeBleu_score": 39.9578553961219}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tn\t\\\"os\\\"\n\t\\\"path/filepath\\\"\n\t\\\"runtime\\\"\n\t\\\"strconv\\\"\n\t\\\"strings\\\"\n\t\\\"time\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/command\\\"\n\texec2 \\\"github.com/IceWhaleTech/CasaOS-Common/utils/exec\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/file\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/common\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/config\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\\\"\n\t\\\"github.com/tidwall/gjson\\\"\n\t\\\"go.uber.org/zap\\\"\n\n\t\\\"github.com/shirou/gopsutil/v3/cpu\\\"\n\t\\\"github.com/shirou/gopsutil/v3/disk\\\"\n\t\\\"github.com/shirou/gopsutil/v3/host\\\"\n\t\\\"github.com/shirou/gopsutil/v3/mem\\\"\n\t\\\"github.com/shirou/gopsutil/v3/net\\\"", "CodeBleu_score": 31.26312490736105}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tn\t\\\"os\\\"\n\t\\\"path/filepath\\\"\n\t\\\"runtime\\\"\n\t\\\"strconv\\\"\n\t\\\"strings\\\"\n\t\\\"time\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/command\\\"\n\texec2 \\\"github.com/IceWhaleTech/CasaOS-Common/utils/exec\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/file\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/common\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/config\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\\\"\n\t\\\"github.com/tidwall/gjson\\\"\n\t\\\"go.uber.org/zap\\\"\n\n\t\\\"github.com/shirou/gopsutil/v3/cpu\\\"\n\t\\\"github.com/shirou/gopsutil/v3/disk\\\"\n\t\\\"github.com/shirou/gopsutil/v3/host\\\"\n\t\\\"github.com/shirou/gopsutil/v3/mem\\\"\n\t\\\"github.com/shirou/gopsutil/v3/net\\\"", "CodeBleu_score": 31.26312490736105}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tn\t\\\"os\\\"\n\t\\\"path/filepath\\\"\n\t\\\"runtime\\\"\n\t\\\"strconv\\\"\n\t\\\"strings\\\"\n\t\\\"time\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/command\\\"\n\texec2 \\\"github.com/IceWhaleTech/CasaOS-Common/utils/exec\\\"\n\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/file\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/common\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/model\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/config\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\\\"\n\t\\\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\\\"\n\t\\\"github.com/tidwall/gjson\\\"\n\t\\\"go.uber.org/zap\\\"\n\n\t\\\"github.com/shirou/gopsutil/v3/cpu\\\"\n\t\\\"github.com/shirou/gopsutil/v3/disk\\\"\n\t\\\"github.com/shirou/gopsutil/v3/host\\\"\n\t\\\"github.com/shirou/gopsutil/v3/mem\\\"\n\t\\\"github.com/shirou/gopsutil/v3/net\\\"", "CodeBleu_score": 31.26312490736105}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\n    // add reference to request object\n    rc = addRef(pRequest->ref);\n    if (rc != 0) {\n        return rc;\n    }\n\n    // update request count for TSC object\n    pTscObj->requestCount++;\n\n    // update application request count\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestCount++;\n        pTscObj->pAppInfo->currentRequestCount++;\n    }\n\n    // log debug information\n    if (tscDbg.level > 0) {\n        char szTscId[64];\n        char szAppId[64];\n        char szReqId[64];\n        char szReqType[64];\n        char szReqTime[64];\n\n        sprintf(szTscId, \"%\"PRId64, pTscObj->id);\n        sprintf(szAppId, \"%\"PRId64, pTscObj->pAppInfo != NULL ? pTscObj->pAppInfo->id : 0);\n        sprintf(szReqId, \"%\"PRId64, pRequest->id);\n        sprintf(szReqType, \"%s\", pRequest->isQuery ? \"query\" : \"command\");\n        sprintf(szReqTime, \"%\"PRId64, pRequest->reqTime);\n\n        logDebug(\"registerRequest: tscId=%s, appId=%s, reqId=%s, type=%s, time=%s\",\n                 szTscId, szAppId, szReqId, szReqType, szReqTime);\n    }\n\n    return 0;\n}", "CodeBleu_score": 40.26805602267702}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\n    if (pTscObj == NULL) {\n        rc = TSC_ERR_NOT_FOUND;\n        TSC_LOG_ERROR(\"pTscObj is NULL\");\n    } else {\n        pRequest->tscObj = pTscObj;\n        pRequest->tscObj->requestCount++;\n        if (pTscObj->appInfo.appId != 0) {\n            pTscObj->appInfo.requestCount++;\n            pTscObj->appInfo.currentRequestCount++;\n        }\n        TSC_LOG_DEBUG(\"Register request %s\", pRequest->requestId);\n    }\n\n    return rc;\n}", "CodeBleu_score": 33.87664473921599}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n    int64_t now = 0;\n    int64_t requestTime = 0;\n    int64_t requestDuration = 0;\n    int64_t requestTimeDelta = 0;\n    int64_t requestDurationDelta = 0;\n    int64_t requestDurationMax = 0;\n    int64_t requestDurationMin = 0;\n    int64_t requestDurationSum = 0;\n    int64_t requestDurationSumSquared = 0;\n    int64_t requestDurationCount = 0;\n    int64_t requestDurationCountMax = 0;\n    int64_t requestDurationCountMin = 0;\n    int64_t requestDurationCountSum = 0;\n    int64_t requestDurationCountSumSquared = 0;\n    int64_t requestDurationCountVariance = 0;\n    int64_t requestDurationCountVarianceMax = 0;\n    int64_t requestDurationCountVarianceMin = 0;\n    int64_t requestDurationCountVarianceSum = 0;\n    int64_t requestDurationCountVarianceSumSquared = 0;\n    int64_t requestDurationCountVarianceSumSquaredMax = 0;\n    int64_t requestDurationCountVarianceSumSquaredMin = 0;\n    int64_t requestDurationCountVarianceSumSquaredSum = 0;\n    int64_t requestDurationCountVarianceSumSquaredSumSquared = 0;\n    int64_t requestDurationCountVarianceSumSquaredSumSquaredMax = 0;\n    int64_t requestDurationCountVarianceSumSquaredSumSquaredMin = 0;\n    int64_t requestDurationCountVarianceSumSquaredSumSquaredSum = 0;\n    int64_t requestDurationCountVarianceSumSquaredSumSquaredSumSquared = 0;\n    int64_t requestDurationCountVarianceSumSquaredSumSquaredSum", "CodeBleu_score": 6.878334170938887}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tStop = -1;\n", "CodeBleu_score": 3.968972783639452}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tStop = -1;\n", "CodeBleu_score": 3.968972783639452}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tStop = -1;\n", "CodeBleu_score": 3.968972783639452}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t   cJSON_AddItemToObject(json, \\\"db\\\", cJSON_CreateString(pRequest->pDb));\n  }", "CodeBleu_score": 8.0237808840773}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t   cJSON_AddItemToObject(json, \\\"db\\\", cJSON_CreateString(pRequest->pDb));\n  }", "CodeBleu_score": 8.0237808840773}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t   cJSON_AddItemToObject(json, \\\"db\\\", cJSON_CreateString(pRequest->pDb));\n  }", "CodeBleu_score": 8.0237808840773}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t->metric.parseCostUs, pRequest->metric.ctgCostUs, pRequest->metric.analyseCostUs,\n               pRequest->metric.planCostUs, pRequest->metric.execCostUs);\n      atomic_add_fetch_64((int64_t *)&pActivity->insertElapsedTime, duration);\n      reqType = SLOW_LOG_TYPE_INSERT;\n    }", "CodeBleu_score": 19.21629705877469}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t->metric.parseCostUs, pRequest->metric.ctgCostUs, pRequest->metric.analyseCostUs,\n               pRequest->metric.planCostUs, pRequest->metric.execCostUs);\n      atomic_add_fetch_64((int64_t *)&pActivity->insertElapsedTime, duration);\n      reqType = SLOW_LOG_TYPE_INSERT;\n    }", "CodeBleu_score": 19.21629705877469}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t->metric.parseCostUs, pRequest->metric.ctgCostUs, pRequest->metric.analyseCostUs,\n               pRequest->metric.planCostUs, pRequest->metric.execCostUs);\n      atomic_add_fetch_64((int64_t *)&pActivity->insertElapsedTime, duration);\n      reqType = SLOW_LOG_TYPE_INSERT;\n    }", "CodeBleu_score": 19.21629705877469}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t taosArrayDestroy(pRequest->tableList);\n  taosArrayDestroy(pRequest->targetTableList);\n\n  destroyQueryExecRes(&pRequest->body.resInfo.execRes);\n\n  if (pRequest->self) {\n    deregisterRequest(pRequest);\n  }\n\n  taosMemoryFreeClear(pRequest->pDb);\n  taosArrayDestroy(pRequest->dbList);\n  if (pRequest->body.interParam) {\n    tsem_destroy(&((SSyncQueryParam *)pRequest->body.interParam)->sem);\n  }\n  taosMemoryFree(pRequest->body.interParam);\n\n  if (TSDB_CODE_SUCCESS == nodesSimAcquireAllocator(pRequest->allocatorRefId)) {\n    qDestroyQuery(pRequest->pQuery);\n    nodesSimReleaseAllocator(pRequest->allocatorRefId);\n  }\n  nodesDestroyAllocator(pRequest->allocatorRefId);\n\n  taosMemoryFreeClear(pRequest->effectiveUser);\n  taosMemoryFreeClear(pRequest->sqlstr);\n  taosMemoryFree(pRequest);\n  tscTrace(\\\"end to destroy request %\\\" PRIx64 \\\" p:%p\\\", reqId, pRequest);\n  destroyNextReq(nextReqRefId);\n}", "CodeBleu_score": 29.674262443224826}, {"code": "void tscStopCrashReport(){\n\t taosArrayDestroy(pRequest->tableList);\n  taosArrayDestroy(pRequest->targetTableList);\n\n  destroyQueryExecRes(&pRequest->body.resInfo.execRes);\n\n  if (pRequest->self) {\n    deregisterRequest(pRequest);\n  }\n\n  taosMemoryFreeClear(pRequest->pDb);\n  taosArrayDestroy(pRequest->dbList);\n  if (pRequest->body.interParam) {\n    tsem_destroy(&((SSyncQueryParam *)pRequest->body.interParam)->sem);\n  }\n  taosMemoryFree(pRequest->body.interParam);\n\n  if (TSDB_CODE_SUCCESS == nodesSimAcquireAllocator(pRequest->allocatorRefId)) {\n    qDestroyQuery(pRequest->pQuery);\n    nodesSimReleaseAllocator(pRequest->allocatorRefId);\n  }\n  nodesDestroyAllocator(pRequest->allocatorRefId);\n\n  taosMemoryFreeClear(pRequest->effectiveUser);\n  taosMemoryFreeClear(pRequest->sqlstr);\n  taosMemoryFree(pRequest);\n  tscTrace(\\\"end to destroy request %\\\" PRIx64 \\\" p:%p\\\", reqId, pRequest);\n  destroyNextReq(nextReqRefId);\n}", "CodeBleu_score": 29.674262443224826}, {"code": "void tscStopCrashReport(){\n\t taosArrayDestroy(pRequest->tableList);\n  taosArrayDestroy(pRequest->targetTableList);\n\n  destroyQueryExecRes(&pRequest->body.resInfo.execRes);\n\n  if (pRequest->self) {\n    deregisterRequest(pRequest);\n  }\n\n  taosMemoryFreeClear(pRequest->pDb);\n  taosArrayDestroy(pRequest->dbList);\n  if (pRequest->body.interParam) {\n    tsem_destroy(&((SSyncQueryParam *)pRequest->body.interParam)->sem);\n  }\n  taosMemoryFree(pRequest->body.interParam);\n\n  if (TSDB_CODE_SUCCESS == nodesSimAcquireAllocator(pRequest->allocatorRefId)) {\n    qDestroyQuery(pRequest->pQuery);\n    nodesSimReleaseAllocator(pRequest->allocatorRefId);\n  }\n  nodesDestroyAllocator(pRequest->allocatorRefId);\n\n  taosMemoryFreeClear(pRequest->effectiveUser);\n  taosMemoryFreeClear(pRequest->sqlstr);\n  taosMemoryFree(pRequest);\n  tscTrace(\\\"end to destroy request %\\\" PRIx64 \\\" p:%p\\\", reqId, pRequest);\n  destroyNextReq(nextReqRefId);\n}", "CodeBleu_score": 29.674262443224826}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tHashCleanup(vgInfo->vgHash);\n    taosMemoryFreeClear(vgInfo);\n  }", "CodeBleu_score": 11.23597202147885}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tHashCleanup(vgInfo->vgHash);\n    taosMemoryFreeClear(vgInfo);\n  }", "CodeBleu_score": 11.23597202147885}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tHashCleanup(vgInfo->vgHash);\n    taosMemoryFreeClear(vgInfo);\n  }", "CodeBleu_score": 11.23597202147885}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t: %s\n\\\", S3_get_status_name(status));\n    return -1;\n  }", "CodeBleu_score": 9.066531096038927}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t: %s\n\\\", S3_get_status_name(status));\n    return -1;\n  }", "CodeBleu_score": 9.066531096038927}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t: %s\n\\\", S3_get_status_name(status));\n    return -1;\n  }", "CodeBleu_score": 9.066531096038927}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tchar confDir[PATH_MAX] = {0};\n    snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n    if (taosCreateDir(tsCheckpointBackupDir) != 0) {\n        uError(\"[rsync] create checkpoint backup dir error, dir:%s, \" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n        return;\n    }\n\n    removeEmptyDir();\n    if (generateConfigFile(confDir) != 0) {\n        uError(\"[rsync] generate conf file error, dir:%s, \" ERRNO_ERR_FORMAT, confDir, ERRNO_ERR_DATA);\n        return;\n    }\n\n    char command[PATH_MAX] = {0};\n#ifdef WINDOWS\n    snprintf(command, PATH_MAX, \"rsync --daemon --port=%d --config=%s\", tsCheckpointRsyncPort, confDir);\n#else\n    snprintf(command, PATH_MAX, \"rsync --daemon --port=%d --config=%s --no-detach\", tsCheckpointRsyncPort, confDir);\n#endif\n    int32_t code = execCommand(command);\n    if (code != 0) {\n        uError(\"[rsync] start rsync server error, \" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    } else {\n        uDebug(\"[rsync] start rsync server successful\");\n    }\n}", "CodeBleu_score": 72.45202705274463}, {"code": "void startRsync(){\n\tif (taosMkdir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s, \" ERRNO_ERR_FORMAT,\n           tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    return;\n  }\n\n  char command[PATH_MAX * 4] = {0};\n  snprintf(command, PATH_MAX * 4,\n#ifdef WINDOWS\n           \"rsync.exe --daemon --port %d --config %srsync.conf\",\n#else\n           \"rsync --daemon --port %d --config %srsync.conf\",\n#endif\n           tsRsyncPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] start rsync server, command:%s\", command);\n  int32_t code = execCommand(command);\n  if (code != 0) {\n    uError(\"[rsync] start rsync server failed, \" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 59.73517117426434}, {"code": "void startRsync(){\n\tif (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s, \" ERRNO_ERR_FORMAT,\n           tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s, \" ERRNO_ERR_FORMAT,\n           tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char command[PATH_MAX * 4] = {0};\n  snprintf(command, PATH_MAX * 4,\n#ifdef WINDOWS\n           \"\\\"%s\\\\rsync.exe\\\" --daemon --config=\\\"%srsync.conf\\\" --port=%d\",\n#else\n           \"\\\"%s/rsync\\\" --daemon --config=\\\"%srsync.conf\\\" --port=%d\",\n#endif\n           tsRsyncDir, tsCheckpointBackupDir, tsRsyncPort);\n  uDebug(\"[rsync] start rsync server, cmd:%s\", command);\n  if (execCommand(command) != 0) {\n    uError(\"[rsync] start rsync server failed, \" ERRNO_ERR_FORMAT,\n           ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 55.94653690114245}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.remove(dispatcherId);\n    if (current != null) {\n        current.shutdown();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 72.93184183577263}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher current = dispatchers.remove(dispatcherId);\n    if (current != null) {\n        current.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 81.23474600198797}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 77.32147434704152}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tn * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "CodeBleu_score": 18.97676150267901}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tn * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "CodeBleu_score": 18.97676150267901}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tn * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "CodeBleu_score": 18.97676150267901}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            tryInit(1);\n        } else {\n            msg.onActorStopped(selfId);\n        }\n    }\n}", "CodeBleu_score": 45.196543104823675}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyInProgress.get()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            tryInit(1);\n        } else {\n            msg.getSender().tell(new TbActorStopReasonActorMsg(stopReason));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(highPriority);\n    }\n}", "CodeBleu_score": 49.44115565026197}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyInProgress.get()) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && stopReason == TbActorStopReason.INIT_FAILED) {\n            tryInit(1);\n        } else {\n            msg.getSender().tell(new TbActorStopSignal(selfId, stopReason));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(highPriority);\n    }\n}", "CodeBleu_score": 52.113722013886274}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ttry {\n        if (log.isTraceEnabled()) {\n            log.trace(\"[{}] Processing mailbox, highPriorityMsgs: {}, normalPriorityMsgs: {}\", selfId, highPriorityMsgs.size(), normalPriorityMsgs.size());\n        }\n        int throughput = settings.getMailboxProcessingThroughput();\n        int highPriorityMsgsSize = highPriorityMsgs.size();\n        int normalPriorityMsgsSize = normalPriorityMsgs.size();\n        int totalSize = highPriorityMsgsSize + normalPriorityMsgsSize;\n        int processed = 0;\n        while (processed < throughput) {\n            TbActorMsg msg = null;\n            if (highPriorityMsgsSize > 0) {\n                msg = highPriorityMsgs.poll();\n                if (msg != null) {\n                    highPriorityMsgsSize--;\n                }\n            }\n            if (msg == null && normalPriorityMsgsSize > 0) {\n                msg = normalPriorityMsgs.poll();\n                if (msg != null) {\n                    normalPriorityMsgsSize--;\n                }\n            }\n            if (msg != null) {\n                try {\n                    actor.process(msg);\n                } catch (Throwable t) {\n                    if (isUnrecoverable(t)) {\n                        log.info(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                        stopReason = TbActorStopReason.PROCESS_FAILED;\n                        destroy(t.getCause());\n                    } else {\n                        log.debug(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                        ProcessFailureStrategy strategy = actor.onProcessFailure(msg, t);\n                        if (strategy.isStop()) {\n                            stopReason = TbActorStopReason.PROCESS_FAILED;\n                            destroy(t.getCause());\n                        } else if (strategy.getRetryDelay() > 0) {", "CodeBleu_score": 46.322837350048665}, {"code": "private void processMailbox(){\n\ttry {\n        if (ready.get() == READY) {\n            int throughput = settings.getMailboxProcessingThroughput();\n            int processed = 0;\n            while (processed < throughput && !highPriorityMsgs.isEmpty()) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg != null) {\n                    processMessage(msg);\n                    processed++;\n                } else {\n                    break;\n                }\n            }\n            while (processed < throughput && !normalPriorityMsgs.isEmpty()) {\n                TbActorMsg msg = normalPriorityMsgs.poll();\n                if (msg != null) {\n                    processMessage(msg);\n                    processed++;\n                } else {\n                    break;\n                }\n            }\n            if (processed == 0) {\n                busy.set(FREE);\n                tryProcessQueue(false);\n            } else {\n                processMailbox();\n            }\n        } else {\n            log.trace(\"[{}] MessageBox is not ready\", selfId);\n        }\n    } catch (Throwable t) {\n        log.error(\"[{}] Failed to process mailbox\", selfId, t);\n        destroy(t);\n    }\n}", "CodeBleu_score": 41.10680405641658}, {"code": "private void processMailbox(){\n\tboolean highPriority = true;\n    boolean hasMoreMessages = true;\n    int throughput = 0;\n    while (hasMoreMessages && throughput < settings.getMailboxProcessingThroughput()) {\n        TbActorMsg msg = highPriority ? highPriorityMsgs.poll() : normalPriorityMsgs.poll();\n        if (msg == null) {\n            hasMoreMessages = false;\n        } else {\n            try {\n                if (highPriority) {\n                    actor.process(msg);\n                } else {\n                    actor.process(msg);\n                }\n            } catch (Throwable t) {\n                if (isUnrecoverable(t)) {\n                    log.info(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                    stopReason = TbActorStopReason.PROCESS_FAILED;\n                    destroy(t.getCause());\n                } else {\n                    log.debug(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                    ProcessFailureStrategy strategy = actor.onProcessFailure(msg, t);\n                    if (strategy.isStop()) {\n                        log.info(\"[{}] Failed to process message: {}, going to stop actor\", selfId, msg, t);\n                        stopReason = TbActorStopReason.PROCESS_FAILED;\n                        destroy(t.getCause());\n                    } else if (strategy.getRetryDelay() > 0) {\n                        log.info(\"[{}] Failed to process message: {}, going to retry in {}ms\", selfId, msg, strategy.getRetryDelay());\n                        log.debug(\"[{}] Error\", selfId, t);\n                        system.getScheduler().schedule(() -> dispatcher.getExecutor().execute(() -> enqueue(msg, highPriority)), strategy.getRetryDelay(), TimeUnit.MILLISECONDS);\n                    } else {\n                        log.info(\"[{}] Failed to process message: {}, going to retry immediately\", selfId, msg);\n                        log.debug(\"[{}] Error\", selfId, t);", "CodeBleu_score": 47.165297691999065}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tdispatcher.getExecutor().execute(() -> tryInit(1));\n    }", "CodeBleu_score": 3.157486095458322}, {"code": "public void destroy(Throwable cause){\n\tdispatcher.getExecutor().execute(() -> tryInit(1));\n    }", "CodeBleu_score": 3.157486095458322}, {"code": "public void destroy(Throwable cause){\n\tdispatcher.getExecutor().execute(() -> tryInit(1));\n    }", "CodeBleu_score": 3.157486095458322}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimits().get(api);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    TbRateLimits tbRateLimits = getOrCreateRateLimits(tenantId, rateLimitsTrigger);\n    if (tbRateLimits.getRateLimit(level) > 0) {\n        if (tbRateLimits.getRateLimit(level) <= tbRateLimits.getRateLimitUsage(level)) {\n            tbRateLimits.incrementRateLimitUsage(level);\n            return true;\n        } else {\n            if (rateLimitsTrigger.isEnabled()) {\n                notificationRuleProcessor.process(tenantId, rateLimitsTrigger.getNotificationId(),\n                        new RateLimitNotification(api, tbRateLimits.getRateLimit(level), tbRateLimits.getRateLimitUsage(level), level));\n            }\n            return false;\n        }\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 54.81561082088151}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileProvider.getProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimits().get(api);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    RateLimitKey rateLimitKey = new RateLimitKey(api, tenantId, level);\n    TbRateLimits rateLimits = rateLimits.getIfPresent(rateLimitKey);\n    if (rateLimits == null) {\n        rateLimits = new TbRateLimits(rateLimitsTrigger.getLimit(), rateLimitsTrigger.getTimeUnit().toMillis(1));\n        rateLimits.update();\n        rateLimits.setRateLimitKey(rateLimitKey);\n        rateLimits.setTenantProfile(tenantProfile);\n        rateLimits.setApi(api);\n        rateLimits.setTenantId(tenantId);\n        rateLimits.setLevel(level);\n        rateLimits.setIgnoreTenantNotFound(ignoreTenantNotFound);\n        rateLimits = rateLimits.updateAndGet();\n        rateLimits.setRateLimitKey(rateLimitKey);\n        rateLimits = rateLimits.updateAndGet();\n        rateLimits.setRateLimitKey(rateLimitKey);\n        rateLimits = rateLimits.updateAndGet();\n        rateLimits.setRateLimitKey(rateLimitKey);\n        rateLimits = rateLimits.updateAndGet();\n        rateLimits.setRateLimitKey(rateLimitKey);\n        rateLimits = rateLimits.updateAndGet();\n        rateLimits.setRateLimitKey(rateLimitKey);\n        rateLimits = rate", "CodeBleu_score": 53.72415149031826}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitsTrigger rateLimitsTrigger = tenantProfile.getRateLimits(api);\n    if (rateLimitsTrigger == null) {\n        return true;\n    }\n    RateLimitKey rateLimitKey = new RateLimitKey(tenantId, api, level);\n    TbRateLimits rateLimits = rateLimits.getIfPresent(rateLimitKey);\n    if (rateLimits == null) {\n        rateLimits = new TbRateLimits(rateLimitsTrigger);\n        rateLimits.update();\n        rateLimits.getRateLimit(level);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_UUID);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_UUID);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_UUID);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_UUID);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_UUID);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_UUID);\n        rateLimits.getRateLimit(EntityId.NULL_UUID);\n        rateLimits.getRateLimit(StringUtils.NULL_U", "CodeBleu_score": 52.41954957007155}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    for (InetSocketAddress remotePeer : dtlsSessionsMap.keySet()) {\n        TbCoapDtlsSessionInfo dtlsSessionInfo = dtlsSessionsMap.get(remotePeer);\n        if (dtlsSessionInfo.getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", remotePeer, dtlsSessionInfo.getLastActivityTime());\n            dtlsSessionsMap.remove(remotePeer);\n        }\n    }\n}", "CodeBleu_score": 51.118522542462586}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\n    long expirationTime = currentTime - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().stream().filter(entry -> entry.getValue().getLastActivityTime() < expirationTime).forEach(entry -> {\n        log.trace(\"DTLS session removed from in-memory store: [{}]\", entry.getKey());\n        dtlsSessionsMap.remove(entry.getKey());\n    });\n}", "CodeBleu_score": 54.8669742777955}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    for (InetSocketAddress remotePeer : dtlsSessionsMap.keySet()) {\n        TbCoapDtlsSessionInfo dtlsSessionInfo = dtlsSessionsMap.get(remotePeer);\n        if (dtlsSessionInfo.getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", remotePeer, dtlsSessionInfo.getLastActivityTime());\n            dtlsSessionsMap.remove(remotePeer);\n        }\n    }\n}", "CodeBleu_score": 51.118522542462586}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> tsEntries = new ArrayList<>();\n        timeseries.forEach((key, values) -> {\n            if (!CollectionUtils.isEmpty(values)) {\n                values.forEach(value -> {\n                    tsEntries.add(new BasicTsKvEntry(value.get(TS).asLong(), parseValue(key, value.get(VALUE))));\n                });\n            }\n        });\n        return tsEntries;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 57.23429877726986}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().flatMap(entry -> {\n            List<TsKvEntry> result = new ArrayList<>();\n            if (!CollectionUtils.isEmpty(entry.getValue())) {\n                for (JsonNode node : entry.getValue()) {\n                    KvEntry entryValue = parseValue(entry.getKey(), node.get(VALUE));\n                    if (entryValue != null) {\n                        result.add(new BasicTsKvEntry(node.get(TS).asLong(), entryValue));\n                    }\n                }\n            }\n            return result.stream();\n        }).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 56.136248716694624}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().map(entry -> {\n            String key = entry.getKey();\n            List<TsKvEntry> result = new ArrayList<>();\n            entry.getValue().forEach(value -> {\n                KvEntry kvEntry = parseValue(key, value);\n                result.add(new BasicTsKvEntry(value.get(TS).asLong(), kvEntry));\n            });\n            return result;\n        }).flatMap(List::stream).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 59.31500257888425}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tthingsboard.server.common.data.id.UserId;", "CodeBleu_score": 1.574344451957297}, {"code": "public void refreshToken(){\n\tthingsboard.server.common.data.id.UserId;", "CodeBleu_score": 1.574344451957297}, {"code": "public void refreshToken(){\n\tthingsboard.server.common.data.id.UserId;", "CodeBleu_score": 1.574344451957297}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tboard.server.common.data.oauth2.OAuth2Info;", "CodeBleu_score": 1.4246777943117195}, {"code": " private void doLogin(){\n\tboard.server.common.data.oauth2.OAuth2Info;", "CodeBleu_score": 1.4246777943117195}, {"code": " private void doLogin(){\n\tboard.server.common.data.oauth2.OAuth2Info;", "CodeBleu_score": 1.4246777943117195}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t{\n            ResponseEntity<Dashboard> dashboard = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/dashboard/{dashboardId}\\\", null, Dashboard.class, customerId.getId(), dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }", "CodeBleu_score": 37.18034002556108}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t{\n            ResponseEntity<Dashboard> dashboard = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/dashboard/{dashboardId}\\\", null, Dashboard.class, customerId.getId(), dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }", "CodeBleu_score": 37.18034002556108}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t{\n            ResponseEntity<Dashboard> dashboard = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/dashboard/{dashboardId}\\\", null, Dashboard.class, customerId.getId(), dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }", "CodeBleu_score": 37.18034002556108}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tn\n    public Optional<Dashboard> unassignDashboardFromPublicCustomer(DashboardId dashboardId) {\n        try {\n            ResponseEntity<Dashboard> dashboard = restTemplate.exchange(baseURL + \\\"/api/customer/public/dashboard/{dashboardId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Dashboard.class, dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(TenantId tenantId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"tenantId\\\", tenantId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/{tenantId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getCustomerDashboards(CustomerId customerId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"customerId\\\", customerId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/customer/{customerId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    @Deprecated\n    public Dashboard createDashboard(Dashboard dashboard) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/dashboard\\\", dashboard, Dashboard.class).getBody();\n    }\n\n    @Deprecated\n    public List<DashboardInfo> findTenantDashboards() {\n        try {\n            ResponseEntity<PageData<DashboardInfo>> dashboards =\n                    restTemplate.exchange(baseURL + \\\"/api/tenant/dashboards?pageSize=100000\\\", HttpMethod.GET, null, new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                    });\n            return dashboards.getBody().getData();\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Collections.emptyList();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}\\\", Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceInfo> getDeviceInfoById(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceInfo> device = restTemplate.getForEntity(baseURL + \\\"/api/device/info/{deviceId}\\\", DeviceInfo.class, deviceId);\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Device saveDevice(Device device) {\n        return saveDevice(device, null);\n    }\n\n    public Device saveDevice(Device device, String accessToken) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device?accessToken={accessToken}\\\", device, Device.class, accessToken).getBody();\n    }\n\n    public void deleteDevice(DeviceId deviceId) {\n        restTemplate.delete(baseURL + \\\"/api/device/{deviceId}\\\", deviceId.getId());\n    }\n\n    public Optional<Device> assignDeviceToCustomer(CustomerId customerId, DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/device/{deviceId}\\\", null, Device.class, customerId.getId(), deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> unassignDeviceFromCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.exchange(baseURL + \\\"/api/customer/device/{deviceId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> assignDeviceToPublicCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/public/device/{deviceId}\\\", null, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceCredentials> getDeviceCredentialsByDeviceId(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceCredentials> deviceCredentials = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}/credentials\\\", DeviceCredentials.class, deviceId.getId());\n            return Optional.ofNullable(deviceCredentials.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public DeviceCredentials saveDeviceCredentials(DeviceCredentials deviceCredentials) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device/credentials\\\", deviceCredentials, DeviceCredentials.class).getBody();\n    }\n\n\n\n", "CodeBleu_score": 24.646993327285713}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tn\n    public Optional<Dashboard> unassignDashboardFromPublicCustomer(DashboardId dashboardId) {\n        try {\n            ResponseEntity<Dashboard> dashboard = restTemplate.exchange(baseURL + \\\"/api/customer/public/dashboard/{dashboardId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Dashboard.class, dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(TenantId tenantId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"tenantId\\\", tenantId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/{tenantId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getCustomerDashboards(CustomerId customerId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"customerId\\\", customerId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/customer/{customerId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    @Deprecated\n    public Dashboard createDashboard(Dashboard dashboard) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/dashboard\\\", dashboard, Dashboard.class).getBody();\n    }\n\n    @Deprecated\n    public List<DashboardInfo> findTenantDashboards() {\n        try {\n            ResponseEntity<PageData<DashboardInfo>> dashboards =\n                    restTemplate.exchange(baseURL + \\\"/api/tenant/dashboards?pageSize=100000\\\", HttpMethod.GET, null, new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                    });\n            return dashboards.getBody().getData();\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Collections.emptyList();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}\\\", Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceInfo> getDeviceInfoById(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceInfo> device = restTemplate.getForEntity(baseURL + \\\"/api/device/info/{deviceId}\\\", DeviceInfo.class, deviceId);\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Device saveDevice(Device device) {\n        return saveDevice(device, null);\n    }\n\n    public Device saveDevice(Device device, String accessToken) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device?accessToken={accessToken}\\\", device, Device.class, accessToken).getBody();\n    }\n\n    public void deleteDevice(DeviceId deviceId) {\n        restTemplate.delete(baseURL + \\\"/api/device/{deviceId}\\\", deviceId.getId());\n    }\n\n    public Optional<Device> assignDeviceToCustomer(CustomerId customerId, DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/device/{deviceId}\\\", null, Device.class, customerId.getId(), deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> unassignDeviceFromCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.exchange(baseURL + \\\"/api/customer/device/{deviceId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> assignDeviceToPublicCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/public/device/{deviceId}\\\", null, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceCredentials> getDeviceCredentialsByDeviceId(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceCredentials> deviceCredentials = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}/credentials\\\", DeviceCredentials.class, deviceId.getId());\n            return Optional.ofNullable(deviceCredentials.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public DeviceCredentials saveDeviceCredentials(DeviceCredentials deviceCredentials) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device/credentials\\\", deviceCredentials, DeviceCredentials.class).getBody();\n    }\n\n\n\n", "CodeBleu_score": 24.646993327285713}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tn\n    public Optional<Dashboard> unassignDashboardFromPublicCustomer(DashboardId dashboardId) {\n        try {\n            ResponseEntity<Dashboard> dashboard = restTemplate.exchange(baseURL + \\\"/api/customer/public/dashboard/{dashboardId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Dashboard.class, dashboardId.getId());\n            return Optional.ofNullable(dashboard.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(TenantId tenantId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"tenantId\\\", tenantId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/{tenantId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getTenantDashboards(PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/tenant/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    public PageData<DashboardInfo> getCustomerDashboards(CustomerId customerId, PageLink pageLink) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\\\"customerId\\\", customerId.getId().toString());\n        addPageLinkToParam(params, pageLink);\n        return restTemplate.exchange(\n                baseURL + \\\"/api/customer/{customerId}/dashboards?\\\" + getUrlParams(pageLink),\n                HttpMethod.GET, HttpEntity.EMPTY,\n                new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                }, params).getBody();\n    }\n\n    @Deprecated\n    public Dashboard createDashboard(Dashboard dashboard) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/dashboard\\\", dashboard, Dashboard.class).getBody();\n    }\n\n    @Deprecated\n    public List<DashboardInfo> findTenantDashboards() {\n        try {\n            ResponseEntity<PageData<DashboardInfo>> dashboards =\n                    restTemplate.exchange(baseURL + \\\"/api/tenant/dashboards?pageSize=100000\\\", HttpMethod.GET, null, new ParameterizedTypeReference<PageData<DashboardInfo>>() {\n                    });\n            return dashboards.getBody().getData();\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Collections.emptyList();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}\\\", Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceInfo> getDeviceInfoById(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceInfo> device = restTemplate.getForEntity(baseURL + \\\"/api/device/info/{deviceId}\\\", DeviceInfo.class, deviceId);\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Device saveDevice(Device device) {\n        return saveDevice(device, null);\n    }\n\n    public Device saveDevice(Device device, String accessToken) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device?accessToken={accessToken}\\\", device, Device.class, accessToken).getBody();\n    }\n\n    public void deleteDevice(DeviceId deviceId) {\n        restTemplate.delete(baseURL + \\\"/api/device/{deviceId}\\\", deviceId.getId());\n    }\n\n    public Optional<Device> assignDeviceToCustomer(CustomerId customerId, DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/{customerId}/device/{deviceId}\\\", null, Device.class, customerId.getId(), deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> unassignDeviceFromCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.exchange(baseURL + \\\"/api/customer/device/{deviceId}\\\", HttpMethod.DELETE, HttpEntity.EMPTY, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<Device> assignDeviceToPublicCustomer(DeviceId deviceId) {\n        try {\n            ResponseEntity<Device> device = restTemplate.postForEntity(baseURL + \\\"/api/customer/public/device/{deviceId}\\\", null, Device.class, deviceId.getId());\n            return Optional.ofNullable(device.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public Optional<DeviceCredentials> getDeviceCredentialsByDeviceId(DeviceId deviceId) {\n        try {\n            ResponseEntity<DeviceCredentials> deviceCredentials = restTemplate.getForEntity(baseURL + \\\"/api/device/{deviceId}/credentials\\\", DeviceCredentials.class, deviceId.getId());\n            return Optional.ofNullable(deviceCredentials.getBody());\n        } catch (HttpClientErrorException exception) {\n            if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw exception;\n            }\n        }\n    }\n\n    public DeviceCredentials saveDeviceCredentials(DeviceCredentials deviceCredentials) {\n        return restTemplate.postForEntity(baseURL + \\\"/api/device/credentials\\\", deviceCredentials, DeviceCredentials.class).getBody();\n    }\n\n\n\n", "CodeBleu_score": 24.646993327285713}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tices || (options.addresses ? options.addresses.length : 1);\n\n    this.memory = Array(64).fill(0);\n\n    options.dims = options.dims || LedControl.MATRIX_DIMENSIONS[\\\"8x8\\\"];\n    if (typeof options.dims === \\\"string\\\") {\n      options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];\n    }\n    if (Array.isArray(options.dims)) {\n      options.dims = {\n        rows: options.dims[0],\n        columns: options.dims[1],\n      };\n    }\n    const state = {\n      devices,\n      digits: options.digits || 8,\n      isMatrix: !!options.isMatrix,\n      isBicolor: !!options.isBicolor,\n      rows: options.dims.rows,\n      columns: options.dims.columns\n    };\n\n    if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {\n      throw new Error(\\\"Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16\\\");\n    }\n\n    Object.defineProperties(this, {\n      devices: {\n        get() {\n          return state.devices;\n        }\n      },\n      digits: {\n        get() {\n          return state.digits;\n        }\n      },\n      isMatrix: {\n        get() {\n          return state.isMatrix;\n        }\n      },\n      isBicolor: {\n        get() {\n          return state.isBicolor;\n        }\n      },\n      rows: {\n        get() {\n          return state.rows;\n        }\n      },\n      columns: {\n        get() {\n          return state.columns;\n        }\n      }\n    });\n\n    priv.set(this, state);\n    this.initialize(options);\n  }", "CodeBleu_score": 36.29992121738668}, {"code": "brightness(addr, val){\n\tices || (options.addresses ? options.addresses.length : 1);\n\n    this.memory = Array(64).fill(0);\n\n    options.dims = options.dims || LedControl.MATRIX_DIMENSIONS[\\\"8x8\\\"];\n    if (typeof options.dims === \\\"string\\\") {\n      options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];\n    }\n    if (Array.isArray(options.dims)) {\n      options.dims = {\n        rows: options.dims[0],\n        columns: options.dims[1],\n      };\n    }\n    const state = {\n      devices,\n      digits: options.digits || 8,\n      isMatrix: !!options.isMatrix,\n      isBicolor: !!options.isBicolor,\n      rows: options.dims.rows,\n      columns: options.dims.columns\n    };\n\n    if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {\n      throw new Error(\\\"Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16\\\");\n    }\n\n    Object.defineProperties(this, {\n      devices: {\n        get() {\n          return state.devices;\n        }\n      },\n      digits: {\n        get() {\n          return state.digits;\n        }\n      },\n      isMatrix: {\n        get() {\n          return state.isMatrix;\n        }\n      },\n      isBicolor: {\n        get() {\n          return state.isBicolor;\n        }\n      },\n      rows: {\n        get() {\n          return state.rows;\n        }\n      },\n      columns: {\n        get() {\n          return state.columns;\n        }\n      }\n    });\n\n    priv.set(this, state);\n    this.initialize(options);\n  }", "CodeBleu_score": 36.29992121738668}, {"code": "brightness(addr, val){\n\tices || (options.addresses ? options.addresses.length : 1);\n\n    this.memory = Array(64).fill(0);\n\n    options.dims = options.dims || LedControl.MATRIX_DIMENSIONS[\\\"8x8\\\"];\n    if (typeof options.dims === \\\"string\\\") {\n      options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];\n    }\n    if (Array.isArray(options.dims)) {\n      options.dims = {\n        rows: options.dims[0],\n        columns: options.dims[1],\n      };\n    }\n    const state = {\n      devices,\n      digits: options.digits || 8,\n      isMatrix: !!options.isMatrix,\n      isBicolor: !!options.isBicolor,\n      rows: options.dims.rows,\n      columns: options.dims.columns\n    };\n\n    if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || (state.columns + state.rows === 32)) {\n      throw new Error(\\\"Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16\\\");\n    }\n\n    Object.defineProperties(this, {\n      devices: {\n        get() {\n          return state.devices;\n        }\n      },\n      digits: {\n        get() {\n          return state.digits;\n        }\n      },\n      isMatrix: {\n        get() {\n          return state.isMatrix;\n        }\n      },\n      isBicolor: {\n        get() {\n          return state.isBicolor;\n        }\n      },\n      rows: {\n        get() {\n          return state.rows;\n        }\n      },\n      columns: {\n        get() {\n          return state.columns;\n        }\n      }\n    });\n\n    priv.set(this, state);\n    this.initialize(options);\n  }", "CodeBleu_score": 36.29992121738668}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tfunction(device) {\n        this.off(device);\n      });\n    }", "CodeBleu_score": 3.2744538104954604}, {"code": "device(addr){\n\tfunction(device) {\n        this.off(device);\n      });\n    }", "CodeBleu_score": 3.2744538104954604}, {"code": "device(addr){\n\tfunction(device) {\n        this.off(device);\n      });\n    }", "CodeBleu_score": 3.2744538104954604}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[method] = function(duration, callback = noop) {\n      if (typeof duration === \\\"function\\\") {\n        callback = duration;\n        duration = 1000;\n      }\n\n      if (typeof callback !== \\\"function\\\") {\n        throw new Error(\\\"Callback must be a function\\\");\n      }\n\n      const promises = [];\n\n      this.forEach(element => {\n        const promise = new Promise(resolve => {\n          setTimeout(() => {\n            element[method](resolve);\n          }, duration);\n        });\n\n        promises.push(promise);\n      });\n\n      Promise.all(promises).then(() => callback());\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 49.1362332587961}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[method] = function(duration, callback) {\n      if (typeof duration === \"function\") {\n        callback = duration;\n        duration = 1000;\n      }\n\n      if (typeof callback !== \"function\") {\n        callback = noop;\n      }\n\n      const promises = this.map(element => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            element[method](resolve);\n          }, duration);\n        });\n      });\n\n      Promise.all(promises).then(callback);\n\n      return this;\n    };\n  });\n\n  return target;\n}", "CodeBleu_score": 59.805390961552206}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[method] = function(duration, callback) {\n      const { length } = this;\n      const promises = [];\n\n      if (typeof duration === \"function\") {\n        callback = duration;\n        duration = 1000;\n      }\n\n      if (typeof callback !== \"function\") {\n        callback = noop;\n      }\n\n      for (let i = 0; i < length; i++) {\n        promises.push(this[i][method].call(this[i], duration, callback));\n      }\n\n      return Promise.all(promises).then(callback);\n    };\n  });\n\n  return target;\n}", "CodeBleu_score": 64.2732554948375}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tquency) {\n        const state = priv.get(this);\n\n        // Enforce maximum frequency of 10hz\n        if (frequency < 10) {\n          frequency = 10;\n        }\n\n        state.frequency = frequency;\n        this.sendCommand(`$PMTK220,${String(1000 / state.frequency)}`);\n      }\n    }", "CodeBleu_score": 22.314932768602567}, {"code": "listen(){\n\tquency) {\n        const state = priv.get(this);\n\n        // Enforce maximum frequency of 10hz\n        if (frequency < 10) {\n          frequency = 10;\n        }\n\n        state.frequency = frequency;\n        this.sendCommand(`$PMTK220,${String(1000 / state.frequency)}`);\n      }\n    }", "CodeBleu_score": 22.314932768602567}, {"code": "listen(){\n\tquency) {\n        const state = priv.get(this);\n\n        // Enforce maximum frequency of 10hz\n        if (frequency < 10) {\n          frequency = 10;\n        }\n\n        state.frequency = frequency;\n        this.sendCommand(`$PMTK220,${String(1000 / state.frequency)}`);\n      }\n    }", "CodeBleu_score": 22.314932768602567}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tuint8_t active_channels;\n\tuint32_t needed_buffer_size;\n\tuint8_t i;\n\n\tactive_channels = 0U;\n\tneeded_buffer_size = 0U;\n\n\tfor (i = 0U; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id >= AD559X_PIN_MAX) {\n\t\t\tLOG_ERR(\"invalid channel id %d\", sequence->channels[i].channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].acquisition_time != ADC_ACQ_TIME_DEFAULT) {\n\t\t\tLOG_ERR(\"invalid acquisition time\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].gain != ADC_GAIN_1) {\n\t\t\tLOG_ERR(\"invalid channel gain\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].reference != ADC_REF_INTERNAL) {\n\t\t\tLOG_ERR(\"invalid channel reference\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tactive_channels++;\n\t}\n\n\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"invalid options\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"invalid calibrate\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling != ADC_OVERSAMPLING_DISABLED) {\n\t\tLOG_ERR(\"invalid oversampling\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer", "CodeBleu_score": 43.258097710429766}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0U;\n\tuint8_t ch_mask = 0U;\n\tuint8_t ch_mask_tmp = 0U;\n\tuint8_t ch_mask_tmp2 = 0U;\n\tuint8_t ch_mask_tmp3 = 0U;\n\tuint8_t ch_mask_tmp4 = 0U;\n\tuint8_t ch_mask_tmp5 = 0U;\n\tuint8_t ch_mask_tmp6 = 0U;\n\tuint8_t ch_mask_tmp7 = 0U;\n\tuint8_t ch_mask_tmp8 = 0U;\n\tuint8_t ch_mask_tmp9 = 0U;\n\tuint8_t ch_mask_tmp10 = 0U;\n\tuint8_t ch_mask_tmp11 = 0U;\n\tuint8_t ch_mask_tmp12 = 0U;\n\tuint8_t ch_mask_tmp13 = 0U;\n\tuint8_t ch_mask_tmp14 = 0U;\n\tuint8_t ch_mask_tmp15 = 0U;\n\tuint8_t ch_mask_tmp16 = 0U;\n\tuint8_t ch_mask_tmp17 = 0U;\n\tuint8_t ch_mask_tmp18 = 0U;\n\tuint8_t ch_mask_tmp19 = 0U;\n\tuint8_t ch_mask_tmp20 = 0U;\n\tuint8_t ch_mask_tmp21 = 0U;\n\tuint8_t ch_mask_tmp22 = 0U;\n\tuint8_t ch_mask_tmp23 = 0U;\n\tuint8_t ch_mask_tmp24 = 0U;\n\tuint8_t ch_mask_tmp25 = 0U;\n\tuint8_t", "CodeBleu_score": 11.18880629466988}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0U;\n\tuint32_t buffer_size = 0U;\n\tuint8_t i;\n\n\tfor (i = 0U; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id >= AD559X_PIN_MAX) {\n\t\t\tLOG_ERR(\"invalid channel id %d\", sequence->channels[i].channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].acquisition_time != ADC_ACQ_TIME_DEFAULT) {\n\t\t\tLOG_ERR(\"invalid acquisition time\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].differential) {\n\t\t\tLOG_ERR(\"invalid differential\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].gain != ADC_GAIN_1) {\n\t\t\tLOG_ERR(\"invalid gain\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].reference != ADC_REF_INTERNAL) {\n\t\t\tLOG_ERR(\"invalid reference\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannels |= BIT(sequence->channels[i].channel_id);\n\t}\n\n\tbuffer_size = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"invalid options\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"buffer size too small (%u/%u)\", buffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\n\treturn 0;\n}", "CodeBleu_score": 39.753621419043306}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint16_t adc_res;\n\tint ret;\n\n\t/* Check if resolution matches */\n\tret = mfd_ad559x_read_reg(config->mfd_dev, AD559X_REG_ADC_RES, &adc_res);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"failed to read ADC resolution\");\n\t\treturn ret;\n\t}\n\n\tif (adc_res & AD559X_ADC_RES_IND_BIT) {\n\t\tLOG_ERR(\"invalid ADC resolution\");\n\t\treturn -EIO;\n\t}\n\n\tif (((adc_res & AD559X_ADC_RES_CHAN_MASK) >> AD559X_ADC_RES_CHAN_SHIFT) != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid ADC resolution\");\n\t\treturn -EIO;\n\t}\n\n\t/* Check if channels are valid */\n\tif (sequence->channels & ~BIT_MASK(AD559X_PIN_MAX)) {\n\t\tLOG_ERR(\"invalid channel id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate buffer size */\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = POPCOUNT(sequence->channels);\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 66.68733040667112}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t adc_resolution;\n\tuint8_t adc_conf;\n\tuint8_t resolution_mask;\n\tuint8_t resolution_bit;\n\tuint8_t resolution_val;\n\tuint8_t channels;\n\tuint8_t resolution_ind_bit;\n\tuint8_t resolution_chan_mask;\n\tuint8_t resolution_val_mask;\n\tint err;\n\n\tadc_resolution = mfd_ad559x_get_resolution(config->mfd_dev);\n\tadc_conf = data->adc_conf;\n\tresolution_mask = AD559X_ADC_RES_CHAN_MASK;\n\tresolution_bit = AD559X_ADC_RES_IND_BIT;\n\tresolution_val = adc_resolution;\n\tresolution_ind_bit = AD559X_ADC_RES_IND_BIT;\n\tresolution_chan_mask = AD559X_ADC_RES_CHAN_MASK;\n\tresolution_val_mask = AD559X_ADC_RES_VAL_MASK;\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (adc_resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", adc_resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (adc_conf != sequence->channels) {\n\t\tLOG_ERR(\"invalid channels 0x%02x\", adc_conf);\n\t\treturn -EINVAL;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\tLOG_ERR(\"invalid buffer size\");\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_", "CodeBleu_score": 57.33740194045467}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t adc_resolution;\n\tint ret;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~BIT_MASK(AD559X_PIN_MAX)) {\n\t\tLOG_ERR(\"invalid channel id\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = sequence->channels;\n\n\tadc_resolution = mfd_ad559x_read_reg(config->mfd_dev, AD559X_REG_ADC_RESOLUTION);\n\tif (adc_resolution < 0) {\n\t\tLOG_ERR(\"failed to read ADC resolution\");\n\t\treturn adc_resolution;\n\t}\n\n\tif (adc_resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid ADC resolution %d\", adc_resolution);\n\t\treturn -EIO;\n\t}\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tret = k_sem_take(&data->sem, K_FOREVER);\n\treturn ret ? ret : adc_context_eof_dev(dev, sequence);\n}", "CodeBleu_score": 72.9649275271759}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\n", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t_context.h\\\"\n", "CodeBleu_score": 11.71008504244409}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t_context.h\\\"\n", "CodeBleu_score": 11.71008504244409}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t_context.h\\\"\n", "CodeBleu_score": 11.71008504244409}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t59X_ADC_RES_IND_BIT BIT(15)", "CodeBleu_score": 2.3493487807572566}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t59X_ADC_RES_IND_BIT BIT(15)", "CodeBleu_score": 2.3493487807572566}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t59X_ADC_RES_IND_BIT BIT(15)", "CodeBleu_score": 2.3493487807572566}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tyr/drivers/adc.h>", "CodeBleu_score": 5.635092468682876}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tyr/drivers/adc.h>", "CodeBleu_score": 5.635092468682876}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tyr/drivers/adc.h>", "CodeBleu_score": 5.635092468682876}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tdt(&config->bus, msg, sizeof(msg));\n}", "CodeBleu_score": 14.763063739505563}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tdt(&config->bus, msg, sizeof(msg));\n}", "CodeBleu_score": 14.763063739505563}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tdt(&config->bus, msg, sizeof(msg));\n}", "CodeBleu_score": 14.763063739505563}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t112_CONFIG_DR_RATE_240_RES_12;\n\t\tready_time_us = (1000 * 1000) / 240;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}", "CodeBleu_score": 7.577593142112677}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t112_CONFIG_DR_RATE_240_RES_12;\n\t\tready_time_us = (1000 * 1000) / 240;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}", "CodeBleu_score": 7.577593142112677}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t112_CONFIG_DR_RATE_240_RES_12;\n\t\tready_time_us = (1000 * 1000) / 240;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}", "CodeBleu_score": 7.577593142112677}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != MPXXDTYY_STATE_READY) {\n\t\t\tLOG_ERR(\"invalid state (%d)\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"rx start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_RUNNING;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != MPXXDTYY_STATE_RUNNING) {\n\t\t\tLOG_ERR(\"invalid state (%d)\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"rx stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_READY;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"invalid command (%d)\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.78395331639278}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != MPXXDTYY_STATE_READY) {\n\t\t\tLOG_ERR(\"invalid state %d\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"invalid state %d\", data->state);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_READY;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"unsupported trigger command %d\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.3748194108964}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tenum dmic_state new_state;\n\tenum i2s_dir dir;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_READY) {\n\t\t\tnew_state = DMIC_STATE_ACTIVE;\n\t\t\tdir = I2S_DIR_TXRX;\n\t\t} else {\n\t\t\tLOG_ERR(\"invalid trigger command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tnew_state = DMIC_STATE_READY;\n\t\t\tdir = I2S_DIR_TX;\n\t\t} else {\n\t\t\tLOG_ERR(\"invalid trigger command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_trigger(config->comm_master, dir, I2S_TRIGGER_START);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"i2s_trigger failed (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->state = new_state;\n\n\treturn 0;\n}", "CodeBleu_score": 74.22481893816166}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tMODE_8_BIT) {\n\t\t/* This index is reserved for internal driver usage */\n\t\tLOG_ERR(\\\"HD44780 mode must be 4 or 8-bit\\\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Configure and set GPIOs */\n\trc = gpio_pin_configure_dt(&config->rs_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of RS GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->rw_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->rw_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of RW GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = gpio_pin_configure_dt(&config->e_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of E GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\ti = 4;\n\t}\n\n\twhile (i < 8) {\n\t\tif (config->db_gpios[i].port) {\n\t\t\trc = gpio_pin_configure_dt(&config->db_gpios[i], GPIO_OUTPUT);\n\n\t\t\tif (rc < 0) {\n\t\t\t\tLOG_ERR(\\\"Configuration of DB%d GPIO failed: %d\\\", i, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT && i > 3) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing (DB4-DB7 needed for 4-bit mode)\\\", i);\n\t\t\treturn -EINVAL;\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing\\\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->backlight_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of backlight GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->backlight_gpio, 0);\n\t}\n\n\tdata->character_x = 0;\n\tdata->character_y = 0;\n\tdata->backlight_state = false;\n\tdata->cursor_enabled = false;\n\tdata->position_blink_enabled = false;\n\tdata->direction = AUXDISPLAY_DIRECTION_RIGHT;\n\n\tif (config->boot_delay != 0) {\n\t\t/* Boot delay is set, wait for a period of time for the LCD to become ready to\n\t\t * accept commands\n\t\t */\n\t\tk_sleep(K_MSEC(config->boot_delay));\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\t/* Reset display to known state in 8-bit mode */\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\n\t\t/* Put display into 4-bit mode */\n\t\tcmd = AUXDISPLAY_HD44780_CMD_SETUP;\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t}\n\n\tif (config->capabilities.rows > 1) {\n\t\tcmd |= AUXDISPLAY_HD44780_2_LINE_CONFIG;\n\t}\n\n\t/* Configure display */\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n\tauxdisplay_hd44780_set_display_mode(dev, true);\n\tauxdisplay_hd44780_set_entry_mode(dev);\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_CMD_CLEAR,\n\t\t\t\t   config->capabilities.mode);\n\n\tk_sleep(K_USEC(config->clear_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 47.68964851258848}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tMODE_8_BIT) {\n\t\t/* This index is reserved for internal driver usage */\n\t\tLOG_ERR(\\\"HD44780 mode must be 4 or 8-bit\\\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Configure and set GPIOs */\n\trc = gpio_pin_configure_dt(&config->rs_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of RS GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->rw_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->rw_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of RW GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = gpio_pin_configure_dt(&config->e_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of E GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\ti = 4;\n\t}\n\n\twhile (i < 8) {\n\t\tif (config->db_gpios[i].port) {\n\t\t\trc = gpio_pin_configure_dt(&config->db_gpios[i], GPIO_OUTPUT);\n\n\t\t\tif (rc < 0) {\n\t\t\t\tLOG_ERR(\\\"Configuration of DB%d GPIO failed: %d\\\", i, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT && i > 3) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing (DB4-DB7 needed for 4-bit mode)\\\", i);\n\t\t\treturn -EINVAL;\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing\\\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->backlight_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of backlight GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->backlight_gpio, 0);\n\t}\n\n\tdata->character_x = 0;\n\tdata->character_y = 0;\n\tdata->backlight_state = false;\n\tdata->cursor_enabled = false;\n\tdata->position_blink_enabled = false;\n\tdata->direction = AUXDISPLAY_DIRECTION_RIGHT;\n\n\tif (config->boot_delay != 0) {\n\t\t/* Boot delay is set, wait for a period of time for the LCD to become ready to\n\t\t * accept commands\n\t\t */\n\t\tk_sleep(K_MSEC(config->boot_delay));\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\t/* Reset display to known state in 8-bit mode */\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\n\t\t/* Put display into 4-bit mode */\n\t\tcmd = AUXDISPLAY_HD44780_CMD_SETUP;\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t}\n\n\tif (config->capabilities.rows > 1) {\n\t\tcmd |= AUXDISPLAY_HD44780_2_LINE_CONFIG;\n\t}\n\n\t/* Configure display */\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n\tauxdisplay_hd44780_set_display_mode(dev, true);\n\tauxdisplay_hd44780_set_entry_mode(dev);\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_CMD_CLEAR,\n\t\t\t\t   config->capabilities.mode);\n\n\tk_sleep(K_USEC(config->clear_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 47.68964851258848}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tMODE_8_BIT) {\n\t\t/* This index is reserved for internal driver usage */\n\t\tLOG_ERR(\\\"HD44780 mode must be 4 or 8-bit\\\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Configure and set GPIOs */\n\trc = gpio_pin_configure_dt(&config->rs_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of RS GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->rw_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->rw_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of RW GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = gpio_pin_configure_dt(&config->e_gpio, GPIO_OUTPUT);\n\n\tif (rc < 0) {\n\t\tLOG_ERR(\\\"Configuration of E GPIO failed: %d\\\", rc);\n\t\treturn rc;\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\ti = 4;\n\t}\n\n\twhile (i < 8) {\n\t\tif (config->db_gpios[i].port) {\n\t\t\trc = gpio_pin_configure_dt(&config->db_gpios[i], GPIO_OUTPUT);\n\n\t\t\tif (rc < 0) {\n\t\t\t\tLOG_ERR(\\\"Configuration of DB%d GPIO failed: %d\\\", i, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT && i > 3) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing (DB4-DB7 needed for 4-bit mode)\\\", i);\n\t\t\treturn -EINVAL;\n\t\t} else if (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\t\t/* Required pin missing */\n\t\t\tLOG_ERR(\\\"Required DB%d pin missing\\\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\trc = gpio_pin_configure_dt(&config->backlight_gpio, GPIO_OUTPUT);\n\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\\\"Configuration of backlight GPIO failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->backlight_gpio, 0);\n\t}\n\n\tdata->character_x = 0;\n\tdata->character_y = 0;\n\tdata->backlight_state = false;\n\tdata->cursor_enabled = false;\n\tdata->position_blink_enabled = false;\n\tdata->direction = AUXDISPLAY_DIRECTION_RIGHT;\n\n\tif (config->boot_delay != 0) {\n\t\t/* Boot delay is set, wait for a period of time for the LCD to become ready to\n\t\t * accept commands\n\t\t */\n\t\tk_sleep(K_MSEC(config->boot_delay));\n\t}\n\n\tif (config->capabilities.mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\t/* Reset display to known state in 8-bit mode */\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\n\t\t/* Put display into 4-bit mode */\n\t\tcmd = AUXDISPLAY_HD44780_CMD_SETUP;\n\t\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_4_BIT_ONCE);\n\t}\n\n\tif (config->capabilities.rows > 1) {\n\t\tcmd |= AUXDISPLAY_HD44780_2_LINE_CONFIG;\n\t}\n\n\t/* Configure display */\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n\tauxdisplay_hd44780_set_display_mode(dev, true);\n\tauxdisplay_hd44780_set_entry_mode(dev);\n\tauxdisplay_hd44780_command(dev, false, AUXDISPLAY_HD44780_CMD_CLEAR,\n\t\t\t\t   config->capabilities.mode);\n\n\tk_sleep(K_USEC(config->clear_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 47.68964851258848}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\"Configuration of busy interrupt failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}", "CodeBleu_score": 35.34045527442932}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\"Configuration of busy interrupt failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}", "CodeBleu_score": 35.34045527442932}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\"Configuration of busy interrupt failed: %d\\\", rc);\n\t\t\treturn rc;\n\t\t}", "CodeBleu_score": 35.34045527442932}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02874204137314}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02874204137314}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02874204137314}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_ = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read exceeds the BBRAM size\");\n\t\tret = -EINVAL;\n\t} else if (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Read from invalid memory\");\n\t\tret = -EIO;\n\t} else if (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"Read from standby power failed memory\");\n\t\tret = -EIO;\n\t} else if (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"Read from power failed memory\");\n\t\tret = -EIO;\n\t} else {\n\t\tmemcpy(data, data_->data + offset, size);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.26202548033374}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_p = dev->data;\n\tint ret = 0;\n\n\tif (offset >= config->size) {\n\t\tLOG_ERR(\"Invalid offset: %d\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((offset + size) > config->size) {\n\t\tLOG_ERR(\"Invalid size: %d\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is invalid\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"Standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"Power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &data_p->data[offset], size);\n\n\treturn ret;\n}", "CodeBleu_score": 49.26631549649802}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_p = dev->data;\n\tint rc;\n\n\t/* Check if the requested read size is valid */\n\tif (size == 0) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not exceed the memory bounds */\n\tif ((offset + size) > config->size) {\n\t\tLOG_ERR(\"Read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not involve invalid memory */\n\trc = bbram_emul_check_invalid(dev);\n\tif (rc != 0) {\n\t\tLOG_ERR(\"Read operation on invalid memory\");\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, data_p->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.45380179813891}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01712631282048}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01712631282048}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01712631282048}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.89524438384621}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint ret = 0;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name is required.\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 77.83480690367746}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name not specified.\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found.\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 77.20107873695522}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\tif (!h4->rx.have_hdr) {\n\t\treturn;\n\t}\n\n\tif (uart_fifo_read(cfg->uart, h4->rx.hdr + h4->rx.hdr_len - h4->rx.remaining, h4->rx.remaining) != h4->rx.remaining) {\n\t\tLOG_WRN(\"Unable to read H:4 header\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining -= h4->rx.remaining;\n}", "CodeBleu_score": 56.08683033446711}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tint read;\n\n\t/* Read header data */\n\tread = uart_fifo_read(cfg->uart, h4->rx.hdr + h4->rx.remaining,\n\t\t\t      h4->rx.hdr_len - h4->rx.remaining);\n\tif (read < 0) {\n\t\tLOG_WRN(\"Unable to read H:4 header\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining += read;\n}", "CodeBleu_score": 67.21666518104688}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tuint8_t *buf = h4->rx.hdr + h4->rx.remaining - h4->rx.hdr_len;\n\tsize_t read;\n\n\t/* Get packet type */\n\tif (uart_fifo_read(cfg->uart, buf, h4->rx.hdr_len) != h4->rx.hdr_len) {\n\t\tLOG_WRN(\"Unable to read H:4 packet type\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\tswitch (h4->rx.type) {\n\tcase BT_HCI_H4_EVT:\n\t\th4->rx.remaining = sys_le16_to_cpu(h4->rx.evt.len);\n\t\th4->rx.hdr_len = sizeof(h4->rx.evt);\n\t\tbreak;\n\tcase BT_HCI_H4_ACL:\n\t\th4->rx.remaining = sys_le16_to_cpu(h4->rx.acl.len);\n\t\th4->rx.hdr_len = sizeof(h4->rx.acl);\n\t\tbreak;\n\tcase BT_HCI_H4_ISO:\n\t\tif (IS_ENABLED(CONFIG_BT_ISO)) {\n\t\t\th4->rx.remaining = sys_le16_to_cpu(h4->rx.iso.len);\n\t\t\th4->rx.hdr_len = sizeof(h4->rx.iso);\n\t\t\tbreak;\n\t\t}\n\t\t__fallthrough;\n\tdefault:\n\t\tLOG_ERR(\"Unknown H:4 type 0x%02x\", h4->rx.type);\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t}\n\n\tread = h4->rx.hdr_len - h4->rx.remaining;", "CodeBleu_score": 52.090956070995176}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tn\t\th4->rx.remaining -= ret;\n\t}", "CodeBleu_score": 6.07277858175735}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tn\t\th4->rx.remaining -= ret;\n\t}", "CodeBleu_score": 6.07277858175735}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tn\t\th4->rx.remaining -= ret;\n\t}", "CodeBleu_score": 6.07277858175735}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tt timeout)", "CodeBleu_score": 6.099640716013399}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tt timeout)", "CodeBleu_score": 6.099640716013399}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tt timeout)", "CodeBleu_score": 6.099640716013399}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t->data->observers_end_idx;\n\t\t\t}", "CodeBleu_score": 10.595804393576385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t->data->observers_end_idx;\n\t\t\t}", "CodeBleu_score": 10.595804393576385}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t->data->observers_end_idx;\n\t\t\t}", "CodeBleu_score": 10.595804393576385}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tpoint_timeout(end_time));\n\n\t\tif (cloned_buf == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnet_buf_put(obs->message_fifo, cloned_buf);\n\n\t\tbreak;\n\t}", "CodeBleu_score": 10.758565509750278}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tpoint_timeout(end_time));\n\n\t\tif (cloned_buf == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnet_buf_put(obs->message_fifo, cloned_buf);\n\n\t\tbreak;\n\t}", "CodeBleu_score": 10.758565509750278}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tpoint_timeout(end_time));\n\n\t\tif (cloned_buf == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnet_buf_put(obs->message_fifo, cloned_buf);\n\n\t\tbreak;\n\t}", "CodeBleu_score": 10.758565509750278}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \\\"observation must be not NULL\\\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 27.293356001899845}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \\\"observation must be not NULL\\\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 27.293356001899845}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \\\"observation must be not NULL\\\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}", "CodeBleu_score": 27.293356001899845}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t) {\n  ETH->BUS_MODE_b.PRWG = 0;\n    ETH->BUS_MODE_b.DA = ETH_DMA_ARBITRATION_ROUND_ROBIN;\n\n    ETH->BUS_MODE_b.TXPR = isRxPrior ? FALSE : TRUE;\n    ETH->BUS_MODE_b.PR = priorityRate;\n}\n", "CodeBleu_score": 20.674604538177967}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t) {\n  ETH->BUS_MODE_b.PRWG = 0;\n    ETH->BUS_MODE_b.DA = ETH_DMA_ARBITRATION_ROUND_ROBIN;\n\n    ETH->BUS_MODE_b.TXPR = isRxPrior ? FALSE : TRUE;\n    ETH->BUS_MODE_b.PR = priorityRate;\n}\n", "CodeBleu_score": 20.674604538177967}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t) {\n  ETH->BUS_MODE_b.PRWG = 0;\n    ETH->BUS_MODE_b.DA = ETH_DMA_ARBITRATION_ROUND_ROBIN;\n\n    ETH->BUS_MODE_b.TXPR = isRxPrior ? FALSE : TRUE;\n    ETH->BUS_MODE_b.PR = priorityRate;\n}\n", "CodeBleu_score": 20.674604538177967}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tyReg, uint32_t data) {\n    ETH->GMII_ADDR_b.PA = phyAddr;\n    ETH->GMII_ADDR_b.GR = phyReg;\n    ETH->GMII_ADDR_b.GW = PHY_OP_WRITE;\n  ETH->GMII_DATA = data;\n\n    ETH->GMII_ADDR_b.BUSY = TRUE;\n    while (ETH->GMII_ADDR_b.BUSY) ;\n}\n", "CodeBleu_score": 35.80475941862628}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tyReg, uint32_t data) {\n    ETH->GMII_ADDR_b.PA = phyAddr;\n    ETH->GMII_ADDR_b.GR = phyReg;\n    ETH->GMII_ADDR_b.GW = PHY_OP_WRITE;\n  ETH->GMII_DATA = data;\n\n    ETH->GMII_ADDR_b.BUSY = TRUE;\n    while (ETH->GMII_ADDR_b.BUSY) ;\n}\n", "CodeBleu_score": 35.80475941862628}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tyReg, uint32_t data) {\n    ETH->GMII_ADDR_b.PA = phyAddr;\n    ETH->GMII_ADDR_b.GR = phyReg;\n    ETH->GMII_ADDR_b.GW = PHY_OP_WRITE;\n  ETH->GMII_DATA = data;\n\n    ETH->GMII_ADDR_b.BUSY = TRUE;\n    while (ETH->GMII_ADDR_b.BUSY) ;\n}\n", "CodeBleu_score": 35.80475941862628}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tcy_rslt_t result;\n\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel */\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /* DAC device init */\n    result = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    /* DAC device enable */\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 74.1084042792074}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tcy_rslt_t result;\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel */\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /* DAC device init */\n    result = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 73.35802462651797}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tcy_rslt_t result;\n\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel */\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /* DAC device init */\n    result = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    /* DAC output enable */\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n    if (result != RT_EOK) {\n        LOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 75.69379505343615}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t i = 0;\n\n    RT_ASSERT(buf != RT_NULL);\n\n    if (addr + size > block_info.start + block_info.size) {\n        LOG_E(\"read outrange flash size!\");\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 57.935998177495684}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tcy_rslt_t err = CY_RSLT_SUCCESS;\n    rt_uint32_t i;\n    rt_uint32_t page;\n    rt_uint32_t offset;\n    rt_uint32_t read_size;\n    rt_uint32_t read_count = 0;\n    rt_uint32_t read_addr;\n    rt_uint32_t read_data;\n    rt_uint32_t *p_buf;\n\n    /* Check if the read operation would exceed the flash memory's end address */\n    if (addr + size > block_info.block_size)\n    {\n        LOG_E(\"read outrange flash size! addr is (0x%p)\", (void *)(addr + size));\n        return -RT_EINVAL;\n    }\n\n    /* Read data from flash memory */\n    page = get_page_32k(addr);\n    offset = addr % IFX_EFLASH_PAGE_SIZE;\n    read_addr = addr;\n    p_buf = (rt_uint32_t *)buf;\n    while (size)\n    {\n        /* Calculate the number of bytes to be read in this page */\n        read_size = RT_MIN(IFX_EFLASH_PAGE_SIZE - offset, size);\n\n        /* Read a page of data from the flash memory */\n        err = cyhal_flash_read(&flash_obj, page, (uint32_t *)p_buf, IFX_EFLASH_PAGE_SIZE);\n        if (CY_RSLT_SUCCESS != err)\n        {\n            LOG_E(\"read flash failed! addr is (0x%p)\", (void *)read_addr);\n            return -RT_ERROR;\n        }\n\n        /* Copy the data from the buffer to the user's buffer */\n        for (i = 0; i < read_size; i++)\n        {\n            read_data = *(p_buf + (offset + i) / 4);\n            read_data = (read_data >> ((offset + i) % 4 *", "CodeBleu_score": 55.898308993983214}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t i = 0;\n    rt_uint32_t page = 0;\n    rt_uint32_t offset = 0;\n    rt_uint32_t page_size = 0;\n    rt_uint32_t end_addr = 0;\n    rt_uint32_t read_size = 0;\n    rt_uint32_t read_count = 0;\n    rt_uint32_t read_addr = 0;\n    rt_uint32_t read_data = 0;\n    rt_uint32_t *p_read_data = RT_NULL;\n    rt_uint32_t *p_buf = RT_NULL;\n\n    /* Check if the read operation would exceed the flash memory's end address */\n    end_addr = block_info.start_addr + block_info.size;\n    if (addr + size > end_addr)\n    {\n        LOG_E(\"read outrange flash size! addr is (0x%p)\", (void *)(addr + size));\n        return -RT_EINVAL;\n    }\n\n    /* Calculate the start page, page offset, page size and the number of pages to be read */\n    page = get_page_32k(addr);\n    offset = addr - page;\n    page_size = IFX_EFLASH_PAGE_SIZE - offset;\n    read_size = size < page_size ? size : page_size;\n    read_count = size / read_size;\n\n    /* Read data from flash to buffer */\n    read_addr = addr;\n    p_buf = (rt_uint32_t *)buf;\n    for (i = 0; i < read_count; i++)\n    {\n        /* Read data from flash memory */\n        cy_rslt_t err = cyhal_flash_read(&flash_obj, read_addr, &read_data);\n        if (CY_RSLT_SUCCESS != err)\n        {\n            LOG_E(\"read flash data failed! addr is (0x%p)\", (", "CodeBleu_score": 51.96473885108075}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 44.41255133467903}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 44.41255133467903}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 44.41255133467903}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    /* find empty fd slot */\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n            return fd;\n    }\n\n    /* no empty fd slot, expand the fd table */\n    fd = fd_slot_expand(fdt, fd);\n\n    return fd;\n}", "CodeBleu_score": 29.144704817972766}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    return fd_slot_expand(fdt, fd);\n}", "CodeBleu_score": 28.48848496283538}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint index;\n    struct dfs_file **fds = fdt->fds;\n\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    return fd_slot_expand(fdt, index);\n}", "CodeBleu_score": 30.99689776442609}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\n        default:\n            if (str < end)\n            {\n                *str = '%';\n            }\n            ++ str;\n\n            if (*fmt)\n            {\n                if (str < end)\n                {\n                    *str = *fmt;\n                }\n                ++ str;\n            }\n            else\n            {\n                -- fmt;\n            }\n            continue;\n        }", "CodeBleu_score": 24.282408913325693}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n        default:\n            if (str < end)\n            {\n                *str = '%';\n            }\n            ++ str;\n\n            if (*fmt)\n            {\n                if (str < end)\n                {\n                    *str = *fmt;\n                }\n                ++ str;\n            }\n            else\n            {\n                -- fmt;\n            }\n            continue;\n        }", "CodeBleu_score": 24.282408913325693}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\n        default:\n            if (str < end)\n            {\n                *str = '%';\n            }\n            ++ str;\n\n            if (*fmt)\n            {\n                if (str < end)\n                {\n                    *str = *fmt;\n                }\n                ++ str;\n            }\n            else\n            {\n                -- fmt;\n            }\n            continue;\n        }", "CodeBleu_score": 24.282408913325693}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_err_t result = RT_EOK;\n\n    level = rt_hw_interrupt_disable();\n    rt_spin_lock(&_hook_spinlock);\n\n    for (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            goto __exit;\n        }\n    }\n\n    result = -RT_EFULL;\n\n__exit:\n    rt_spin_unlock(&_hook_spinlock);\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 64.63872818620464}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t lock;\n    rt_err_t result = RT_EOK;\n    rt_uint32_t i;\n\n    lock = rt_spin_lock_irq(&_hook_spinlock);\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n\n    rt_spin_unlock_irq(&_hook_spinlock, lock);\n\n    return result;\n}", "CodeBleu_score": 80.55475233449489}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result = RT_EOK;\n    rt_base_t level;\n    rt_uint32_t i;\n\n    if (hook == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    level = rt_hw_interrupt_disable();\n    rt_spin_lock(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n\n    rt_spin_unlock(&_hook_spinlock);\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 68.76020768810972}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.40823173009815}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.40823173009815}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.40823173009815}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t0-25     Bernard      change the mb/mq receive timeout to 0 if the\n *                             re-calculated delta tick is a negative number.\n * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag\n *                             is RT_IPC_FLAG_PRIO\n * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.\n * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq\n * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete\n * 2010-11-10     Bernard      add IPC reset command implementation.\n * 2011-12-18     Bernard      add more parameter checking in message queue\n * 2013-09-14     Grissiom     add an option check in rt_event_recv\n * 2018-10-02     Bernard      add 64bit support for mailbox\n * 2019-09-16     tyx          add send wait support for message queue\n * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an\n *                             event without pending\n * 2020-10-11     Meco Man     add value overflow-check code\n * 2021-01-03     Meco Man     implement rt_mb_urgent()\n * 2021-05-30     Meco Man     implement rt_mutex_trytake()\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to ipc.c\n * 2022-01-24     THEWON       let rt_mutex_take return thread->error when using signal\n * 2022-04-08     Stanley      Correct descriptions\n * 2022-10-15     Bernard      add nested mutex feature\n * 2022-10-16     Bernard      add prioceiling feature in mutex\n * 2023-04-16     Xin-zheqi    redesigen queue recv and send function return real message size\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n */\n", "CodeBleu_score": 18.13451986974496}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t0-25     Bernard      change the mb/mq receive timeout to 0 if the\n *                             re-calculated delta tick is a negative number.\n * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag\n *                             is RT_IPC_FLAG_PRIO\n * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.\n * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq\n * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete\n * 2010-11-10     Bernard      add IPC reset command implementation.\n * 2011-12-18     Bernard      add more parameter checking in message queue\n * 2013-09-14     Grissiom     add an option check in rt_event_recv\n * 2018-10-02     Bernard      add 64bit support for mailbox\n * 2019-09-16     tyx          add send wait support for message queue\n * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an\n *                             event without pending\n * 2020-10-11     Meco Man     add value overflow-check code\n * 2021-01-03     Meco Man     implement rt_mb_urgent()\n * 2021-05-30     Meco Man     implement rt_mutex_trytake()\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to ipc.c\n * 2022-01-24     THEWON       let rt_mutex_take return thread->error when using signal\n * 2022-04-08     Stanley      Correct descriptions\n * 2022-10-15     Bernard      add nested mutex feature\n * 2022-10-16     Bernard      add prioceiling feature in mutex\n * 2023-04-16     Xin-zheqi    redesigen queue recv and send function return real message size\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n */\n", "CodeBleu_score": 18.13451986974496}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t0-25     Bernard      change the mb/mq receive timeout to 0 if the\n *                             re-calculated delta tick is a negative number.\n * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag\n *                             is RT_IPC_FLAG_PRIO\n * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.\n * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq\n * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete\n * 2010-11-10     Bernard      add IPC reset command implementation.\n * 2011-12-18     Bernard      add more parameter checking in message queue\n * 2013-09-14     Grissiom     add an option check in rt_event_recv\n * 2018-10-02     Bernard      add 64bit support for mailbox\n * 2019-09-16     tyx          add send wait support for message queue\n * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an\n *                             event without pending\n * 2020-10-11     Meco Man     add value overflow-check code\n * 2021-01-03     Meco Man     implement rt_mb_urgent()\n * 2021-05-30     Meco Man     implement rt_mutex_trytake()\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to ipc.c\n * 2022-01-24     THEWON       let rt_mutex_take return thread->error when using signal\n * 2022-04-08     Stanley      Correct descriptions\n * 2022-10-15     Bernard      add nested mutex feature\n * 2022-10-16     Bernard      add prioceiling feature in mutex\n * 2023-04-16     Xin-zheqi    redesigen queue recv and send function return real message size\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n */\n", "CodeBleu_score": 18.13451986974496}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t16bit word)\n * 2022-08-30     Yunjie       make rt_vsnprintf adapt to ti c28x (16bit int)\n * 2023-02-02     Bernard      add Smart ID for logo version show\n * 2023-10-16     Shell        Add hook point for rt_malloc services\n * 2023-10-21     Shell        support the common backtrace API which is arch-independent\n * 2023-12-10     xqyjlj       perf rt_hw_interrupt_disable/enable, fix memheap lock\n * 2024-03-10     Meco Man     move std libc related functions to rtklibc\n */\n", "CodeBleu_score": 14.181726744612325}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t16bit word)\n * 2022-08-30     Yunjie       make rt_vsnprintf adapt to ti c28x (16bit int)\n * 2023-02-02     Bernard      add Smart ID for logo version show\n * 2023-10-16     Shell        Add hook point for rt_malloc services\n * 2023-10-21     Shell        support the common backtrace API which is arch-independent\n * 2023-12-10     xqyjlj       perf rt_hw_interrupt_disable/enable, fix memheap lock\n * 2024-03-10     Meco Man     move std libc related functions to rtklibc\n */\n", "CodeBleu_score": 14.181726744612325}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t16bit word)\n * 2022-08-30     Yunjie       make rt_vsnprintf adapt to ti c28x (16bit int)\n * 2023-02-02     Bernard      add Smart ID for logo version show\n * 2023-10-16     Shell        Add hook point for rt_malloc services\n * 2023-10-21     Shell        support the common backtrace API which is arch-independent\n * 2023-12-10     xqyjlj       perf rt_hw_interrupt_disable/enable, fix memheap lock\n * 2024-03-10     Meco Man     move std libc related functions to rtklibc\n */\n", "CodeBleu_score": 14.181726744612325}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tINIT}", "CodeBleu_score": 8.059744140928478}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tINIT}", "CodeBleu_score": 8.059744140928478}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tINIT}", "CodeBleu_score": 8.059744140928478}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t*/\nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object))\n{\n    rt_object_put_hook = hook;\n}\n\n/**@}", "CodeBleu_score": 8.172267313922596}, {"code": "void rt_object_detach(rt_object_t object){\n\t*/\nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object))\n{\n    rt_object_put_hook = hook;\n}\n\n/**@}", "CodeBleu_score": 8.172267313922596}, {"code": "void rt_object_detach(rt_object_t object){\n\t*/\nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object))\n{\n    rt_object_put_hook = hook;\n}\n\n/**@}", "CodeBleu_score": 8.172267313922596}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}", "CodeBleu_score": 16.1107885441012}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}", "CodeBleu_score": 16.1107885441012}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}", "CodeBleu_score": 16.1107885441012}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tstruct rt_thread *thread;\n    register rt_base_t temp;\n    struct rt_object *object;\n\n    thread = rt_thread_self();\n    RT_ASSERT(thread != RT_NULL);\n\n    if (thread->cleanup != RT_NULL)\n        thread->cleanup(thread);\n\n    /* remove from schedule */\n    rt_schedule_remove_thread(thread);\n\n    /* change stat */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* remove from thread list */\n    rt_list_remove(&(thread->tlist));\n\n    /* remove from timer list */\n    rt_timer_detach(&(thread->thread_timer));\n\n    /* remove from initial list */\n    rt_list_remove(&(thread->tlist));\n\n    /* remove from defunct thread list */\n    rt_list_remove(&(thread->suspend_node));\n\n    /* remove from priority queue */\n    rt_priority_queue_remove(&(thread->tlist));\n\n    /* remove from object list */\n    object = (struct rt_object *)thread;\n    rt_object_detach(object);\n\n    /* do cleanup */\n    if (thread->cleanup != RT_NULL)\n        thread->cleanup(thread);\n\n    /* disable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* insert to defunct thread list */\n    rt_list_insert_before(&rt_thread_defunct, &(thread->suspend_node));\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    /* do schedule */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 59.1349850831022}, {"code": "static void _thread_exit(void){\n\trt_base_t lock;\n    rt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_current_thread;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* change thread stat */\n    thread->stat = RT_THREAD_CLOSE;\n\n    /* remove from schedule */\n    rt_schedule_remove_thread(thread);\n\n    /* remove from thread list */\n    rt_list_remove(&(thread->tlist));\n\n    /* remove from timer list */\n    rt_timer_detach(&(thread->thread_timer));\n\n    /* release thread resource */\n    if (thread->cleanup != RT_NULL)\n    {\n        /* call cleanup function */\n        thread->cleanup(thread);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    /* do the schedule */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 56.60921889510575}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n    register rt_base_t temp;\n\n    thread = rt_thread_self();\n\n    if (thread != RT_NULL)\n    {\n        RT_OBJECT_HOOK_CALL(rt_thread_inited, (thread));\n\n        /* disable interrupt */\n        temp = rt_hw_interrupt_disable();\n\n        /* change stat */\n        thread->stat = RT_THREAD_CLOSE;\n\n        /* remove from schedule */\n        rt_schedule_remove_thread(thread);\n\n        /* remove from timer */\n        rt_timer_detach(&thread->thread_timer);\n\n        /* remove from thread list */\n        rt_list_remove(&thread->tlist);\n\n        /* enable interrupt */\n        rt_hw_interrupt_enable(temp);\n\n        /* do cleanup */\n        if (thread->cleanup != RT_NULL)\n        {\n            thread->cleanup(thread);\n        }\n\n        /* switch to next task */\n        rt_schedule();\n\n        /* never reach here */\n    }\n}", "CodeBleu_score": 55.19536978870947}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n    rt_ubase_t level;\n\n    RT_ASSERT(parameter != RT_NULL);\n\n    /* get thread */\n    thread = (struct rt_thread *)parameter;\n\n    /* thread check */\n    RT_DEBUG_IN_THREAD_CTRL(thread);\n\n    level = rt_hw_interrupt_disable();\n    /* thread is suspended */\n    if (thread->stat == RT_THREAD_SUSPEND)\n    {\n        /* set error number */\n        thread->error = -RT_ETIMEOUT;\n\n        /* remove from suspend list */\n        rt_list_remove(&(thread->tlist));\n\n        /* insert to schedule ready list */\n        rt_schedule_insert_thread(thread);\n\n        /* do a schedule */\n        rt_schedule();\n    }\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 55.33356056343857}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n    rt_ubase_t temp;\n    rt_base_t critical_level;\n\n    thread = (struct rt_thread *)parameter;\n    if (thread == RT_NULL) return;\n\n    /* thread check */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    critical_level = rt_enter_critical();\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_exit_critical(critical_level);\n        return;\n    }\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* change to ready */\n    thread->stat = RT_THREAD_READY;\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* do a schedule */\n    if (thread->next != RT_NULL) {\n        rt_schedule_insert_thread(thread->next);\n    }\n\n    /* enable interrupt */\n    temp = rt_hw_interrupt_disable();\n    if (rt_thread_self() == thread) {\n        /* update thread switch timestamp */\n        rt_scheduler_update_priority(thread->priority);\n\n        /* switch to another thread */\n        rt_hw_context_switch_to((rt_ubase_t)thread->sp);\n    }\n    rt_hw_interrupt_enable(temp);\n\n    rt_exit_critical(critical_level);\n}", "CodeBleu_score": 53.82915270758626}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n    rt_ubase_t level;\n\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (struct rt_thread *)parameter;\n\n    /* thread check */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread timeout: %s\n\", thread->name));\n\n    level = rt_hw_interrupt_disable();\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_hw_interrupt_enable(level);\n        return;\n    }\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* do schedule */\n    rt_schedule();\n}", "CodeBleu_score": 53.93526259539566}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tregister rt_base_t temp;\n    register rt_mutex_t mutex;\n    register rt_list_t *l;\n\n    /* lock thread */\n    rt_enter_critical(&thread->lock, &temp);\n\n    /* check thread is waiting on a mutex */\n    if (thread->pending_object != RT_NULL) {\n        mutex = (rt_mutex_t)thread->pending_object;\n\n        /* remove from suspend list */\n        rt_list_remove(&RT_THREAD_LIST_NODE(thread));\n\n        /* clear pending object */\n        thread->pending_object = RT_NULL;\n\n        /* unlock thread */\n        rt_exit_critical(&thread->lock, temp);\n\n        /* remove from mutex's waiting list */\n        l = &(mutex->thread_list);\n        while (l->next != &(mutex->thread_list)) {\n            if (rt_list_entry(l->next, struct rt_thread, tlist)->pending_object == mutex) {\n                /* remove thread from mutex's waiting list */\n                rt_list_remove(l->next);\n\n                /*\n                 * resume thread, it will release mutex's lock in scheduler.\n                 * In fact, it will be deleted in scheduler.\n                 */\n                rt_schedule_insert_thread(rt_list_entry(l->next, struct rt_thread, tlist));\n\n                break;\n            }\n\n            l = l->next;\n        }\n\n        return;\n    }\n\n    /* unlock thread */\n    rt_exit_critical(&thread->lock, temp);\n\n    /* take mutex lock */\n    rt_mutex_take(&thread->mutex, RT_WAITING_FOREVER);\n\n    /* release all mutexes */\n    while (!rt_list_isempty(&thread->mutex_list)) {\n        mutex = rt_list_entry(thread->mutex_list.next, rt_mutex_t, list);\n\n        /* remove from", "CodeBleu_score": 48.6989550028431}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tstruct rt_mutex *mutex;\n    struct rt_list_node *node;\n    rt_base_t lock_state;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    /* disable interrupt */\n    lock_state = rt_hw_interrupt_disable();\n\n    /* check thread waiting on mutex */\n    if (thread->stat & RT_THREAD_STAT_MUTEX) {\n        /* get mutex object */\n        mutex = (struct rt_mutex *)thread->u2.object;\n        RT_ASSERT(mutex != RT_NULL);\n\n        /* remove thread from mutex's waiting list */\n        rt_list_remove(&RT_THREAD_WAIT_NODE(thread));\n        /* clear thread pending on mutex */\n        thread->u2.object = RT_NULL;\n        /* clear thread stat */\n        thread->stat &= ~RT_THREAD_STAT_MUTEX;\n\n        /* resume thread */\n        rt_schedule_insert_thread(thread);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock_state);\n\n    /* detach thread from all mutexes */\n    for (node = thread->mutex_list.next; node != &thread->mutex_list; node = node->next) {\n        mutex = rt_list_entry(node, struct rt_mutex, parent.list);\n        RT_ASSERT(mutex != RT_NULL);\n\n        /* remove thread from mutex's holding list */\n        rt_list_remove(&RT_THREAD_CALL_NODE(thread));\n        /* decrease the holding thread's number */\n        mutex->hold = mutex->hold - 1;\n    }\n}", "CodeBleu_score": 50.646091805567906}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tstruct rt_mutex *mutex;\n    rt_base_t lock_state;\n\n    /* disable interrupt */\n    lock_state = rt_hw_interrupt_disable();\n\n    /* check thread is waiting on a mutex */\n    if (rt_list_isempty(&thread->tlist) == RT_FALSE) {\n        /* disable interrupt */\n        rt_hw_interrupt_disable();\n\n        /* get mutex */\n        mutex = (struct rt_mutex *)thread->tlist.next;\n\n        /* remove thread from mutex's waiting list */\n        rt_list_remove(&(thread->tlist));\n        thread->tlist.next = RT_NULL;\n\n        /* clear pending object */\n        thread->pending_object = RT_NULL;\n\n        /* enable interrupt */\n        rt_hw_interrupt_enable(lock_state);\n\n        /* release mutex */\n        rt_mutex_release(mutex);\n    }\n    else {\n        /* enable interrupt */\n        rt_hw_interrupt_enable(lock_state);\n    }\n\n    /* release all mutexes thread has taken */\n    while (thread->mutex_list != RT_NULL) {\n        struct rt_mutex *mutex;\n\n        /* disable interrupt */\n        lock_state = rt_hw_interrupt_disable();\n\n        /* get mutex */\n        mutex = thread->mutex_list;\n\n        /* remove mutex from thread's mutex list */\n        thread->mutex_list = mutex->list.next;\n        mutex->list.next = RT_NULL;\n\n        /* enable interrupt */\n        rt_hw_interrupt_enable(lock_state);\n\n        /* release mutex */\n        rt_mutex_release(mutex);\n    }\n}", "CodeBleu_score": 51.35285318626308}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_GROWS_UPWARD\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (void *)((char *)thread->stack_addr),\n                                          (void *)_thread_exit);\n#else\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),\n                                          (void *)_thread_exit);\n#endif /* ARCH_CPU_STACK_GROWS_UPWARD */\n\n#ifdef RT_USING_MUTEX\n    rt_list_init(&thread->taken_object_list);\n    thread->pending_object = RT_NULL;\n#endif\n\n#ifdef RT_USING_EVENT\n    thread->event_set = 0;\n    thread->event_info = 0;\n#endif /* RT_USING_EVENT */\n\n    /* error and flags */\n    thread->error = RT_EOK;\n\n    /* lock init */\n#ifdef RT_USING_SMP\n    rt_atomic_store(&thread->cpus_lock_nest, 0);\n#endif\n\n    /* initialize cleanup function and user data */\n    thread->cleanup   = 0;\n    thread->user_data = 0;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  _thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_THREAD_TIMER);\n\n    /* initialize signal */\n#ifdef RT_USING_SIGNALS\n    thread->sig_mask    = 0x00;\n    thread->sig_pending = 0x00;\n\n#ifndef RT_USING_SMP\n    thread->sig_ret     = RT_NULL;\n#endif /* RT_USING_SMP */\n    thread->sig_vectors = RT_NULL;\n    thread->si_list     = RT_NULL;\n#endif /* RT_USING_SIGNALS */\n\n#ifdef RT_USING_SMART\n    thread->tid_ref_count = 0;\n    thread->lwp = RT_NULL;\n    thread->susp_recycler = RT_NULL;\n    thread->robust_list = RT_NULL;\n    rt_list_init(&(thread->sibling));\n\n    /* lwp thread-signal init */\n    rt_memset(&thread->signal.sigset_mask, 0, sizeof(lwp_sigset_t));\n    rt_memset(&thread->signal.sig_queue.sigset_pending, 0, sizeof(lwp_sigset_t));\n    rt_list_init(&thread->signal.sig_queue.siginfo_list);\n\n    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);\n\n    /* initialize user_time and system_time */\n    thread->user_time = 0;\n    thread->system_time = 0;\n#endif\n\n#ifdef RT_USING_CPU_USAGE\n    thread->duration_tick = 0;\n#endif /* RT_USING_CPU_USAGE */\n\n#ifdef RT_USING_PTHREADS\n    thread->pthread_data = RT_NULL;\n#endif /* RT_USING_PTHREADS */\n\n#ifdef RT_USING_MODULE\n    thread->parent.module_id = 0;\n#endif /* RT_USING_MODULE */\n\n    rt_spin_lock_init(&thread->spinlock);\n\n    RT_OBJECT_HOOKLIST_CALL(rt_thread_inited, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.85608241546392}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_GROWS_UPWARD\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (void *)((char *)thread->stack_addr),\n                                          (void *)_thread_exit);\n#else\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),\n                                          (void *)_thread_exit);\n#endif /* ARCH_CPU_STACK_GROWS_UPWARD */\n\n#ifdef RT_USING_MUTEX\n    rt_list_init(&thread->taken_object_list);\n    thread->pending_object = RT_NULL;\n#endif\n\n#ifdef RT_USING_EVENT\n    thread->event_set = 0;\n    thread->event_info = 0;\n#endif /* RT_USING_EVENT */\n\n    /* error and flags */\n    thread->error = RT_EOK;\n\n    /* lock init */\n#ifdef RT_USING_SMP\n    rt_atomic_store(&thread->cpus_lock_nest, 0);\n#endif\n\n    /* initialize cleanup function and user data */\n    thread->cleanup   = 0;\n    thread->user_data = 0;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  _thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_THREAD_TIMER);\n\n    /* initialize signal */\n#ifdef RT_USING_SIGNALS\n    thread->sig_mask    = 0x00;\n    thread->sig_pending = 0x00;\n\n#ifndef RT_USING_SMP\n    thread->sig_ret     = RT_NULL;\n#endif /* RT_USING_SMP */\n    thread->sig_vectors = RT_NULL;\n    thread->si_list     = RT_NULL;\n#endif /* RT_USING_SIGNALS */\n\n#ifdef RT_USING_SMART\n    thread->tid_ref_count = 0;\n    thread->lwp = RT_NULL;\n    thread->susp_recycler = RT_NULL;\n    thread->robust_list = RT_NULL;\n    rt_list_init(&(thread->sibling));\n\n    /* lwp thread-signal init */\n    rt_memset(&thread->signal.sigset_mask, 0, sizeof(lwp_sigset_t));\n    rt_memset(&thread->signal.sig_queue.sigset_pending, 0, sizeof(lwp_sigset_t));\n    rt_list_init(&thread->signal.sig_queue.siginfo_list);\n\n    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);\n\n    /* initialize user_time and system_time */\n    thread->user_time = 0;\n    thread->system_time = 0;\n#endif\n\n#ifdef RT_USING_CPU_USAGE\n    thread->duration_tick = 0;\n#endif /* RT_USING_CPU_USAGE */\n\n#ifdef RT_USING_PTHREADS\n    thread->pthread_data = RT_NULL;\n#endif /* RT_USING_PTHREADS */\n\n#ifdef RT_USING_MODULE\n    thread->parent.module_id = 0;\n#endif /* RT_USING_MODULE */\n\n    rt_spin_lock_init(&thread->spinlock);\n\n    RT_OBJECT_HOOKLIST_CALL(rt_thread_inited, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.85608241546392}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_GROWS_UPWARD\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (void *)((char *)thread->stack_addr),\n                                          (void *)_thread_exit);\n#else\n    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,\n                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),\n                                          (void *)_thread_exit);\n#endif /* ARCH_CPU_STACK_GROWS_UPWARD */\n\n#ifdef RT_USING_MUTEX\n    rt_list_init(&thread->taken_object_list);\n    thread->pending_object = RT_NULL;\n#endif\n\n#ifdef RT_USING_EVENT\n    thread->event_set = 0;\n    thread->event_info = 0;\n#endif /* RT_USING_EVENT */\n\n    /* error and flags */\n    thread->error = RT_EOK;\n\n    /* lock init */\n#ifdef RT_USING_SMP\n    rt_atomic_store(&thread->cpus_lock_nest, 0);\n#endif\n\n    /* initialize cleanup function and user data */\n    thread->cleanup   = 0;\n    thread->user_data = 0;\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  _thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_THREAD_TIMER);\n\n    /* initialize signal */\n#ifdef RT_USING_SIGNALS\n    thread->sig_mask    = 0x00;\n    thread->sig_pending = 0x00;\n\n#ifndef RT_USING_SMP\n    thread->sig_ret     = RT_NULL;\n#endif /* RT_USING_SMP */\n    thread->sig_vectors = RT_NULL;\n    thread->si_list     = RT_NULL;\n#endif /* RT_USING_SIGNALS */\n\n#ifdef RT_USING_SMART\n    thread->tid_ref_count = 0;\n    thread->lwp = RT_NULL;\n    thread->susp_recycler = RT_NULL;\n    thread->robust_list = RT_NULL;\n    rt_list_init(&(thread->sibling));\n\n    /* lwp thread-signal init */\n    rt_memset(&thread->signal.sigset_mask, 0, sizeof(lwp_sigset_t));\n    rt_memset(&thread->signal.sig_queue.sigset_pending, 0, sizeof(lwp_sigset_t));\n    rt_list_init(&thread->signal.sig_queue.siginfo_list);\n\n    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);\n\n    /* initialize user_time and system_time */\n    thread->user_time = 0;\n    thread->system_time = 0;\n#endif\n\n#ifdef RT_USING_CPU_USAGE\n    thread->duration_tick = 0;\n#endif /* RT_USING_CPU_USAGE */\n\n#ifdef RT_USING_PTHREADS\n    thread->pthread_data = RT_NULL;\n#endif /* RT_USING_PTHREADS */\n\n#ifdef RT_USING_MODULE\n    thread->parent.module_id = 0;\n#endif /* RT_USING_MODULE */\n\n    rt_spin_lock_init(&thread->spinlock);\n\n    RT_OBJECT_HOOKLIST_CALL(rt_thread_inited, (thread));\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.85608241546392}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tRT-Thread Development Team\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Change Logs:\n * Date           Author       Notes\n * 2006-03-12     Bernard      first version\n * 2006-04-29     Bernard      implement thread timer\n * 2006-06-04     Bernard      implement rt_timer_control\n * 2006-08-10     Bernard      fix the periodic timer bug\n * 2006-09-03     Bernard      implement rt_timer_detach\n * 2009-11-11     LiJin        add soft timer\n * 2010-05-12     Bernard      fix the timer check bug.\n * 2010-11-02     Charlie      re-implement tick overflow issue\n * 2012-12-15     Bernard      fix the next timeout issue in soft timer\n * 2014-07-12     Bernard      does not lock scheduler when invoking soft-timer\n *                             timeout function.\n * 2021-08-15     supperthomas add the comment\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to timer.c\n * 2022-04-19     Stanley      Correct descriptions\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n * 2024-01-25     Shell        add RT_TIMER_FLAG_THREAD_TIMER for timer to sync with sched\n * 2024-05-01     wdfk-prog    The rt_timer_check and _soft_timer_check functions are merged\n */\n", "CodeBleu_score": 34.83336834500206}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tRT-Thread Development Team\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Change Logs:\n * Date           Author       Notes\n * 2006-03-12     Bernard      first version\n * 2006-04-29     Bernard      implement thread timer\n * 2006-06-04     Bernard      implement rt_timer_control\n * 2006-08-10     Bernard      fix the periodic timer bug\n * 2006-09-03     Bernard      implement rt_timer_detach\n * 2009-11-11     LiJin        add soft timer\n * 2010-05-12     Bernard      fix the timer check bug.\n * 2010-11-02     Charlie      re-implement tick overflow issue\n * 2012-12-15     Bernard      fix the next timeout issue in soft timer\n * 2014-07-12     Bernard      does not lock scheduler when invoking soft-timer\n *                             timeout function.\n * 2021-08-15     supperthomas add the comment\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to timer.c\n * 2022-04-19     Stanley      Correct descriptions\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n * 2024-01-25     Shell        add RT_TIMER_FLAG_THREAD_TIMER for timer to sync with sched\n * 2024-05-01     wdfk-prog    The rt_timer_check and _soft_timer_check functions are merged\n */\n", "CodeBleu_score": 34.83336834500206}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tRT-Thread Development Team\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Change Logs:\n * Date           Author       Notes\n * 2006-03-12     Bernard      first version\n * 2006-04-29     Bernard      implement thread timer\n * 2006-06-04     Bernard      implement rt_timer_control\n * 2006-08-10     Bernard      fix the periodic timer bug\n * 2006-09-03     Bernard      implement rt_timer_detach\n * 2009-11-11     LiJin        add soft timer\n * 2010-05-12     Bernard      fix the timer check bug.\n * 2010-11-02     Charlie      re-implement tick overflow issue\n * 2012-12-15     Bernard      fix the next timeout issue in soft timer\n * 2014-07-12     Bernard      does not lock scheduler when invoking soft-timer\n *                             timeout function.\n * 2021-08-15     supperthomas add the comment\n * 2022-01-07     Gabriel      Moving __on_rt_xxxxx_hook to timer.c\n * 2022-04-19     Stanley      Correct descriptions\n * 2023-09-15     xqyjlj       perf rt_hw_interrupt_disable/enable\n * 2024-01-25     Shell        add RT_TIMER_FLAG_THREAD_TIMER for timer to sync with sched\n * 2024-05-01     wdfk-prog    The rt_timer_check and _soft_timer_check functions are merged\n */\n", "CodeBleu_score": 34.83336834500206}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t(&(timer->row[i]));\n    }", "CodeBleu_score": 11.502269186205163}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t(&(timer->row[i]));\n    }", "CodeBleu_score": 11.502269186205163}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t(&(timer->row[i]));\n    }", "CodeBleu_score": 11.502269186205163}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 72.6181555832468}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, h := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\th(recorder, req)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == 401 {\n\t\t\tres.WriteHeader(401)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 67.3674281474074}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tfor key, values := range recorder.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\t\tif recorder.Code == 401 {\n\t\t\tres.WriteHeader(401)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 52.66845888700813}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\n\tHost     string\n\tPort     string\n\tCert     string\n\tKey      string\n\thandlers []func(http.ResponseWriter, *http.Request)\n\tstart    func(*API)\n}", "CodeBleu_score": 5.916886751079038}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\n\tHost     string\n\tPort     string\n\tCert     string\n\tKey      string\n\thandlers []func(http.ResponseWriter, *http.Request)\n\tstart    func(*API)\n}", "CodeBleu_score": 5.916886751079038}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\n\tHost     string\n\tPort     string\n\tCert     string\n\tKey      string\n\thandlers []func(http.ResponseWriter, *http.Request)\n\tstart    func(*API)\n}", "CodeBleu_score": 5.916886751079038}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\ta.robeaux)\n}", "CodeBleu_score": 3.629241021632411}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\ta.robeaux)\n}", "CodeBleu_score": 3.629241021632411}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\ta.robeaux)\n}", "CodeBleu_score": 3.629241021632411}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(u), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(p), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Everything OK, proceed with request.\n\t}\n}", "CodeBleu_score": 54.036667377079574}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tusername, password, ok := r.BasicAuth()\n\t\tusername, password, ok := r.BasicAuth()\n\n\t\t// If we don't have the right credentials, send a 401 Unauthorized response\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(username), []byte(user)) != 1 || subtle.ConstantTimeCompare([]byte(password), []byte(pass)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(username), []byte(user)) != 1 || subtle.ConstantTimeCompare([]byte(password), []byte(pass)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If one of the credentials is wrong, send a 401 Unauthorized response\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(username), []byte(user)) != 1 || subtle.ConstantTimeCompare([]byte(password), []byte(pass)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(username), []byte(user)) != 1 || subtle.ConstantTimeCompare([]byte(password), []byte(pass)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If one of the credentials is wrong, send a 4", "CodeBleu_score": 45.44033775750476}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(\"Authorized\"))\n\t}\n}", "CodeBleu_score": 63.200415096421125}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax-toMin) / float64(fromMax-fromMin)\n\tintercept := float64(toMin) - slope*float64(fromMin)\n\n\treturn func(input float64) (value int) {\n\t\toutput := slope*input + intercept\n\t\tif output < float64(toMin) {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > float64(toMax) {\n\t\t\treturn toMax\n\t\t}\n\t\treturn int(output)\n\t}\n}", "CodeBleu_score": 59.45527532032252}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\treturn int(math.Min(math.Max(slope*input+intercept, float64(toMin)), float64(toMax)))\n\t}\n}", "CodeBleu_score": 56.82379313410285}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\treturn int(math.Min(float64(toMax), math.Max(float64(toMin), slope*input+intercept)))\n\t}\n}", "CodeBleu_score": 60.369934846296104}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\toptions:", "CodeBleu_score": 2.86251711480364}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\toptions:", "CodeBleu_score": 2.86251711480364}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\toptions:", "CodeBleu_score": 2.86251711480364}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\t\t\td.sensorCfg.readInterval = o\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"'%s' can not be applied on '%s'\\\", opt, d.driverCfg.name))\n\t\t}", "CodeBleu_score": 16.638450365971686}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\t\t\td.sensorCfg.readInterval = o\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"'%s' can not be applied on '%s'\\\", opt, d.driverCfg.name))\n\t\t}", "CodeBleu_score": 16.638450365971686}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n\t\t\td.sensorCfg.readInterval = o\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"'%s' can not be applied on '%s'\\\", opt, d.driverCfg.name))\n\t\t}", "CodeBleu_score": 16.638450365971686}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(VibrationEvent)\n\n\terr := d.On(d.Event(DataEvent), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(VibrationEvent), data)\n\t\t}\n\t})\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 79.13524135131969}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\treturn &d\n}", "CodeBleu_score": 71.65672370260306}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\t// set up event listener\n\td.AddEvent(VibrationEvent)\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(VibrationEvent), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 83.5654444980672}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t= 58.27\n\tB1   = 61.74\n\tC2   = 65.41\n\tDb2  = 69.30\n\tD2   = 73.42\n\tEb2  = 77.78\n\tE2   = 82.41\n\tF2   = 87.31\n\tGb2  = 92.50\n\tG2   = 98.00\n\tAb2  = 103.83\n\tA2   = 110.00\n\tBb2  = 116.54\n\tB2   = 123.47\n\tC3   = 130.81\n\tDb3  = 138.59\n\tD3   = 146.83\n\tEb3  = 155.56\n\tE3   = 164.81\n\tF3   = 174.61\n\tGb3  = 185.00\n\tG3   = 196.00\n\tAb3  = 207.65\n\tA3   = 220.00\n\tBb3  = 233.08\n\tB3   = 246.94\n\tC4   = 261.63\n\tDb4  = 277.18\n\tD4   = 293.66\n\tEb4  = 311.13\n\tE4   = 329.63\n\tF4   = 349.23\n\tGb4  = 369.99\n\tG4   = 392.00\n\tAb4  = 415.30\n\tA4   = 440.00\n\tBb4  = 466.16\n\tB4   = 493.88\n\tC5   = 523.25\n\tDb5  = 554.37\n\tD5   = 587.33\n\tEb5  = 622.25\n\tE5   = 659.25\n\tF5   = 698.46\n\tGb5  = 739.99\n\tG5   = 783.99\n\tAb5  = 830.61\n\tA5   = 880.00\n\tBb5  = 932.33\n\tB5   = 987.77\n\tC6   = 1046.50\n\tDb6  = 1108.73\n\tD6   = 1174.66\n\tEb6  = 1244.51\n\tE6   = 1318.51\n\tF6   = 1396.91\n\tGb6  = 1479.98\n\tG6   = 1567.98\n\tAb6  = 1661.22\n\tA6   = 1760.00\n\tBb6  = 1864.66\n\tB6   = 1975.53\n\tC7   = 2093.00\n\tDb7  = 2217.46\n\tD7   = 2349.32\n\tEb7  = 2489.02\n\tE7   = 2637.02\n\tF7   = 2793.83\n\tGb7  = 2959.96\n\tG7   = 3135.96\n\tAb7  = 3322.44\n\tA7   = 3520.00\n\tBb7  = 3729.31\n\tB7   = 3951.07\n\tC8   = 4186.01\n\tDb8  = 4434.92\n\tD8   = 4698.63\n\tEb8  = 4978.03\n\tE8   = 5274.04\n\tF8   = 5587.65\n\tGb8  = 5919.91\n\tG8   = 6271.93\n\tAb8  = 6644.88\n\tA8   = 7040.00\n\tBb8  = 7458.62\n\tB8   = 7902.13", "CodeBleu_score": 7.6115582048283645}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t= 58.27\n\tB1   = 61.74\n\tC2   = 65.41\n\tDb2  = 69.30\n\tD2   = 73.42\n\tEb2  = 77.78\n\tE2   = 82.41\n\tF2   = 87.31\n\tGb2  = 92.50\n\tG2   = 98.00\n\tAb2  = 103.83\n\tA2   = 110.00\n\tBb2  = 116.54\n\tB2   = 123.47\n\tC3   = 130.81\n\tDb3  = 138.59\n\tD3   = 146.83\n\tEb3  = 155.56\n\tE3   = 164.81\n\tF3   = 174.61\n\tGb3  = 185.00\n\tG3   = 196.00\n\tAb3  = 207.65\n\tA3   = 220.00\n\tBb3  = 233.08\n\tB3   = 246.94\n\tC4   = 261.63\n\tDb4  = 277.18\n\tD4   = 293.66\n\tEb4  = 311.13\n\tE4   = 329.63\n\tF4   = 349.23\n\tGb4  = 369.99\n\tG4   = 392.00\n\tAb4  = 415.30\n\tA4   = 440.00\n\tBb4  = 466.16\n\tB4   = 493.88\n\tC5   = 523.25\n\tDb5  = 554.37\n\tD5   = 587.33\n\tEb5  = 622.25\n\tE5   = 659.25\n\tF5   = 698.46\n\tGb5  = 739.99\n\tG5   = 783.99\n\tAb5  = 830.61\n\tA5   = 880.00\n\tBb5  = 932.33\n\tB5   = 987.77\n\tC6   = 1046.50\n\tDb6  = 1108.73\n\tD6   = 1174.66\n\tEb6  = 1244.51\n\tE6   = 1318.51\n\tF6   = 1396.91\n\tGb6  = 1479.98\n\tG6   = 1567.98\n\tAb6  = 1661.22\n\tA6   = 1760.00\n\tBb6  = 1864.66\n\tB6   = 1975.53\n\tC7   = 2093.00\n\tDb7  = 2217.46\n\tD7   = 2349.32\n\tEb7  = 2489.02\n\tE7   = 2637.02\n\tF7   = 2793.83\n\tGb7  = 2959.96\n\tG7   = 3135.96\n\tAb7  = 3322.44\n\tA7   = 3520.00\n\tBb7  = 3729.31\n\tB7   = 3951.07\n\tC8   = 4186.01\n\tDb8  = 4434.92\n\tD8   = 4698.63\n\tEb8  = 4978.03\n\tE8   = 5274.04\n\tF8   = 5587.65\n\tGb8  = 5919.91\n\tG8   = 6271.93\n\tAb8  = 6644.88\n\tA8   = 7040.00\n\tBb8  = 7458.62\n\tB8   = 7902.13", "CodeBleu_score": 7.6115582048283645}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t= 58.27\n\tB1   = 61.74\n\tC2   = 65.41\n\tDb2  = 69.30\n\tD2   = 73.42\n\tEb2  = 77.78\n\tE2   = 82.41\n\tF2   = 87.31\n\tGb2  = 92.50\n\tG2   = 98.00\n\tAb2  = 103.83\n\tA2   = 110.00\n\tBb2  = 116.54\n\tB2   = 123.47\n\tC3   = 130.81\n\tDb3  = 138.59\n\tD3   = 146.83\n\tEb3  = 155.56\n\tE3   = 164.81\n\tF3   = 174.61\n\tGb3  = 185.00\n\tG3   = 196.00\n\tAb3  = 207.65\n\tA3   = 220.00\n\tBb3  = 233.08\n\tB3   = 246.94\n\tC4   = 261.63\n\tDb4  = 277.18\n\tD4   = 293.66\n\tEb4  = 311.13\n\tE4   = 329.63\n\tF4   = 349.23\n\tGb4  = 369.99\n\tG4   = 392.00\n\tAb4  = 415.30\n\tA4   = 440.00\n\tBb4  = 466.16\n\tB4   = 493.88\n\tC5   = 523.25\n\tDb5  = 554.37\n\tD5   = 587.33\n\tEb5  = 622.25\n\tE5   = 659.25\n\tF5   = 698.46\n\tGb5  = 739.99\n\tG5   = 783.99\n\tAb5  = 830.61\n\tA5   = 880.00\n\tBb5  = 932.33\n\tB5   = 987.77\n\tC6   = 1046.50\n\tDb6  = 1108.73\n\tD6   = 1174.66\n\tEb6  = 1244.51\n\tE6   = 1318.51\n\tF6   = 1396.91\n\tGb6  = 1479.98\n\tG6   = 1567.98\n\tAb6  = 1661.22\n\tA6   = 1760.00\n\tBb6  = 1864.66\n\tB6   = 1975.53\n\tC7   = 2093.00\n\tDb7  = 2217.46\n\tD7   = 2349.32\n\tEb7  = 2489.02\n\tE7   = 2637.02\n\tF7   = 2793.83\n\tGb7  = 2959.96\n\tG7   = 3135.96\n\tAb7  = 3322.44\n\tA7   = 3520.00\n\tBb7  = 3729.31\n\tB7   = 3951.07\n\tC8   = 4186.01\n\tDb8  = 4434.92\n\tD8   = 4698.63\n\tEb8  = 4978.03\n\tE8   = 5274.04\n\tF8   = 5587.65\n\tGb8  = 5919.91\n\tG8   = 6271.93\n\tAb8  = 6644.88\n\tA8   = 7040.00\n\tBb8  = 7458.62\n\tB8   = 7902.13", "CodeBleu_score": 7.6115582048283645}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tTODO: Support selecting phase input instead of hard-wiring MS1 and MS2 to board truth table", "CodeBleu_score": 2.929630610059118}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tTODO: Support selecting phase input instead of hard-wiring MS1 and MS2 to board truth table", "CodeBleu_score": 2.929630610059118}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tTODO: Support selecting phase input instead of hard-wiring MS1 and MS2 to board truth table", "CodeBleu_score": 2.929630610059118}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := sysfs.NewAnalogPin(a.sys, path, r, w, bufLen)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 60.182770070340084}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := a.sys.NewAnalogPin(path, r, w, bufLen)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 63.31300448810274}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 63.829789049078165}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\todAccess can be used to change the default sysfs implementation to the character device Kernel ABI.", "CodeBleu_score": 17.024231217232394}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\todAccess can be used to change the default sysfs implementation to the character device Kernel ABI.", "CodeBleu_score": 17.024231217232394}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\todAccess can be used to change the default sysfs implementation to the character device Kernel ABI.", "CodeBleu_score": 17.024231217232394}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tmisoPin)\n\t}", "CodeBleu_score": 3.8226443298989103}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tmisoPin)\n\t}", "CodeBleu_score": 3.8226443298989103}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tmisoPin)\n\t}", "CodeBleu_score": 3.8226443298989103}]}
