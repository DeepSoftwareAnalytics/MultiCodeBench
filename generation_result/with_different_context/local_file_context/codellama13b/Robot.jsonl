{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation;\n  do {\n    navigation = _walker_navigation;\n    if (navigation == nullptr) {\n      navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n      if (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n        navigation.reset();\n      }\n    }\n  } while (navigation == nullptr);\n  return navigation;\n}", "CodeBleu_score": 53.39641981629555}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (_walker_navigation == nullptr) {\n    auto navigation = std::make_shared<WalkerNavigation>(_client, GetState()->GetEpisodeId());\n    if (navigation->SetPedestriansCrossFactor(0.0f)) {\n      _walker_navigation = navigation;\n    } else {\n      log_error(\"failed to set pedestrians cross factor\");\n    }\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 43.16369695507531}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (_walker_navigation == nullptr) {\n    _walker_navigation = std::make_shared<WalkerNavigation>(_client, _state, _simulator);\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 29.997976443203495}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start_time = std::chrono::system_clock::now();\n  while (episode.GetCurrentFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::system_clock::now() > start_time + timeout) {\n      return false;\n    }\n  }\n  episode.Lock()->GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 40.791958367716234}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n  auto start = system_clock::now();\n  while (true) {\n    if (episode.GetCurrentFrame() >= frame) {\n      return true;\n    }\n    if (system_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n}", "CodeBleu_score": 34.57540311986246}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n  auto start_time = high_resolution_clock::now();\n  while (true) {\n    if (episode.GetCurrentFrame() >= frame) {\n      return true;\n    }\n    if (duration_cast<time_duration>(high_resolution_clock::now() - start_time) > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n}", "CodeBleu_score": 35.72395433325523}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tlog_debug(std::string(\"Loading episode: \") + map_name);\n  auto start_time = std::chrono::system_clock::now();\n  auto timeout = 20s;\n  auto max_time = start_time + timeout;\n  rpc::EpisodeSettings episode_settings{};\n  episode_settings.synchronous_mode = true;\n  episode_settings.no_rendering_mode = false;\n  episode_settings.fixed_delta_seconds = 1.0 / 60.0;\n  episode_settings.substepping = false;\n  episode_settings.max_substep_delta_time = 0.01;\n  episode_settings.max_substeps = 10;\n  episode_settings.max_culling_distance = 0.0;\n  episode_settings.max_actors = 1000000;\n  episode_settings.recommended_culling_distance = 0.0;\n  episode_settings.max_speed = 0.0;\n  episode_settings.collision_detection_mode = rpc::CollisionDetectionMode::Discrete;\n  episode_settings.file_write_mode = rpc::FileWriteMode::None;\n  episode_settings.enable_pedestrians = false;\n  episode_settings.seed = 0u;\n  episode_settings.pause = false;\n  episode_settings.subscribed_games = 0u;\n  episode_settings.max_cameras = 100u;\n  episode_settings.max_lights = 100u;\n  episode_settings.max_walkers = 0u;\n  episode_settings.max_animals = 0u;\n  episode_settings.max_vehicles = 0u;\n  episode_settings.max_traffic_lights = 0u;\n  episode_settings.max_speed_limits = 0u;\n  episode_settings.max_dynamic_objects = 0u;\n  episode_settings.max_spectator_cameras = 100u;\n  episode_settings.max_other_", "CodeBleu_score": 23.874274415136703}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tusing namespace std::chrono;\n  using namespace std::chrono_literals;\n  using namespace std::string_literals;\n\n  log_info(\"Loading new episode...\");\n\n  const auto start = system_clock::now();\n  const auto timeout = 120s;\n  const auto step = 500ms;\n  const auto max_attempts = (timeout / step) + 1u;\n\n  auto attempt = 0u;\n  uint64_t episode_id = 0u;\n  while ((episode_id == 0u) && (++attempt < max_attempts)) {\n    episode_id = _client.LoadNewEpisode(map_name, reset_settings, map_layers);\n    std::this_thread::sleep_for(step);\n  }\n\n  if (episode_id == 0u) {\n    log_error(\"Timeout while trying to connect to the new episode.\");\n    throw_exception(std::runtime_error(\"Timeout while trying to connect to the new episode.\"));\n  }\n\n  ValidateVersions(_client);\n\n  log_info(\"New episode connected after \", (system_clock::now() - start).count(), \"ms.\");\n\n  return EpisodeProxy(shared_from_this(), episode_id);\n}", "CodeBleu_score": 46.56893554547129}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// Load the new episode\n  rpc::EpisodeSettings episode_settings;\n  episode_settings.synchronous_mode = true;\n  episode_settings.no_rendering_mode = false;\n  episode_settings.fixed_delta_seconds = 0.016666666666666666;\n  episode_settings.substepping = false;\n  episode_settings.max_substep_delta_time = 0.01;\n  episode_settings.max_substeps = 10;\n  episode_settings.max_culling_distance = 0.0;\n  episode_settings.max_actors = 100000;\n  episode_settings.max_spectators = 100;\n  episode_settings.quality_level = rpc::EpisodeSettings::QualityLevel::EPISODE_QUALITY_FAST;\n  episode_settings.recommended_culling_distance = 0.0;\n  episode_settings.max_agents = 100000;\n  episode_settings.agents_max_neighbors = 100;\n  episode_settings.agents_max_speed = 25.0;\n  episode_settings.agents_max_wander_distance = 0.0;\n  episode_settings.agents_max_neighbors_distance = 0.0;\n  episode_settings.agents_time_horizon = 20.0;\n  episode_settings.agents_time_horizon_neighbors = 2.0;\n  episode_settings.agents_collision_detection_range = 10.0;\n  episode_settings.use_culling = false;\n  episode_settings.render_channels = rpc::EpisodeSettings::RenderChannel::RENDER_CHANNEL_ALL;\n  episode_settings.color_saturation = 1.0;\n  episode_settings.color_contrast = 1.0;\n  episode_settings.color_brightness = 1.0;\n  episode_settings.gamma =", "CodeBleu_score": 11.901785898666802}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tstd::vector<ActorId> walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Remove any walkers that no longer exist.\n  _nav.RemoveDeadAgents(_walkers);\n\n  // Update the vehicles in the crowd and the crowd itself.\n  _nav.UpdateVehicles(_walkers);\n  _nav.UpdateCrowd();\n\n  // Update the transforms and velocities of the walkers.\n  std::vector<rpc::Transform> transforms;\n  std::vector<rpc::VehicleControl> controls;\n  transforms.reserve(walkers.size());\n  controls.reserve(walkers.size());\n  for (auto &walker : walkers) {\n    auto state = episode->GetActorState(walker);\n    transforms.emplace_back(state.transform);\n    controls.emplace_back(state.control.vehicle);\n  }\n  _simulator.lock()->ApplyBatchTransform(transforms);\n  _simulator.lock()->ApplyBatchVehicleControl(controls);\n\n  // Check if any walker has been killed.\n  for (auto &walker : walkers) {\n    auto state = episode->GetActorState(walker);\n    if (state.speed < 0.0f) {\n      _nav.RemoveAgent(walker);\n      _walkers.erase(walker);\n    }\n  }\n}", "CodeBleu_score": 45.23599458211034}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tstd::vector<ActorId> walkers = episode->GetActorsByType(carla::rpc::ActorType::Walker);\n  if (walkers.empty()) {\n    return;\n  }\n\n  std::vector<ActorId> dead_walkers;\n\n  // Get the current state of the episode and remove any walkers that no longer exist.\n  std::vector<std::pair<ActorId, rpc::Actor>> state = episode->GetState()->GetActors();\n  for (auto it = state.begin(); it != state.end();) {\n    if (it->second.type != rpc::ActorType::Walker) {\n      it = state.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the vehicles in the crowd and the crowd itself in the navigation module.\n  _nav.UpdateVehicles(state);\n  _nav.UpdateCrowd();\n\n  // Apply the states of the walkers to the simulator.\n  std::vector<rpc::Command> commands;\n  commands.reserve(walkers.size());\n  for (auto walker : walkers) {\n    auto it = std::find_if(state.begin(), state.end(), [&walker](const std::pair<ActorId, rpc::Actor> &item) {\n      return item.first == walker;\n    });\n\n    if (it == state.end()) {\n      continue;\n    }\n\n    const auto &actor = it->second;\n\n    rpc::WalkerControl control;\n    control.cross_walk = actor.walker.cross_walk;\n    control.speed = actor.walker.speed;\n    control.jump = actor.walker.jump;\n    control.direction = actor.walker.direction;\n\n    rpc::Command command;\n    command.actor_id = walker;\n    command.type = rpc::Command::UPDATE_WALKER_CONTROL;\n    command.walker_control = control;\n    commands.emplace_back(command);\n  }\n\n  episode->App", "CodeBleu_score": 43.999973060168706}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tif (episode == nullptr) {\n    return;\n  }\n  auto walkers = episode->GetActorsByType(rpc::ActorType::Walker);\n  if (walkers.size() == 0) {\n    return;\n  }\n  std::unordered_map<ActorId, std::shared_ptr<WalkerControl>> walkers_control;\n  for (auto walker : walkers) {\n    auto control = std::make_shared<WalkerControl>();\n    control->actor = walker.second;\n    control->transform = walker.second->GetTransform();\n    control->speed = walker.second->GetVelocity().Length();\n    walkers_control.insert(std::make_pair(walker.first, control));\n  }\n  auto state = episode->GetState();\n  for (auto it = _walkers_control.begin(); it != _walkers_control.end();) {\n    if (state.destroyed_actors.count(it->first) > 0) {\n      it = _walkers_control.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  _nav.UpdateVehicles(walkers_control);\n  _nav.UpdateCrowd();\n  std::vector<std::shared_ptr<WalkerControl>> walkers_control_vector;\n  for (auto it = _walkers_control.begin(); it != _walkers_control.end(); ++it) {\n    walkers_control_vector.push_back(it->second);\n  }\n  _simulator.lock()->ApplyBatch(rpc::Command::UpdateWalkers, walkers_control_vector);\n  for (auto it = _walkers_control.begin(); it != _walkers_control.end();) {\n    if (it->second->is_dead) {\n      _nav.DestroyCrowdAgent(it->first);\n      it = _walkers_control.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}", "CodeBleu_score": 47.86843819767203}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 79.45585491945495}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 79.45585491945495}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeActorAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 79.45585491945495}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n  for (auto &pair : _blueprints) {\n    const auto &blueprint = pair.second;\n    if (blueprint.HasAttribute(name)) {\n      const auto &attribute = blueprint.GetAttribute(name);\n      if (attribute.value == value ||\n          std::find(attribute.recommended_values.begin(),\n                    attribute.recommended_values.end(),\n                    value) != attribute.recommended_values.end()) {\n        result.emplace(pair);\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 54.01031331135029}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n  for (auto &pair : _blueprints) {\n    if (pair.second.HasAttribute(name) &&\n        pair.second.MatchAttribute(name, value)) {\n      result.emplace(pair);\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 36.346623852699956}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n  for (auto &pair : _blueprints) {\n    const auto &blueprint = pair.second;\n    if (blueprint.HasAttribute(name)) {\n      const auto &attribute = blueprint.GetAttribute(name);\n      if (attribute.HasValue()) {\n        if (attribute.GetValue() == value) {\n          result.emplace(pair);\n        }\n      } else {\n        for (auto &recommended_value : attribute.GetRecommendedValues()) {\n          if (recommended_value == value) {\n            result.emplace(pair);\n          }\n        }\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 65.46063549952534}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Construct the full file path using a base folder and version information\n    std::string fullpath = _filesBaseFolder;\n    fullpath += \"/\";\n    fullpath += ::carla::version();\n    fullpath += \"/\";\n    fullpath += path;\n\n    // Validate the file path\n    if (!ValidateFilePath(fullpath)) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(fullpath, std::ios::binary);\n\n    // If the file is successfully opened, write the content and close the file\n    if (file.is_open()) {\n        file.write((char*)content.data(), content.size());\n        file.close();\n        return true;\n    }\n\n    // If the file cannot be opened, return false\n    return false;\n}", "CodeBleu_score": 54.11617940223501}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Construct the full file path using the base folder and version information\n    std::string fullpath = _filesBaseFolder;\n    fullpath += \"/\";\n    fullpath += ::carla::version();\n    fullpath += \"/\";\n    fullpath += path;\n\n    // Validate the file path\n    if (!FileTransfer::ValidateFilePath(fullpath)) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\n    // If the file is successfully opened, write the content and close the file\n    if (file.is_open()) {\n        file.write(reinterpret_cast<char *>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 57.837174456098296}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Construct the full file path using a base folder and version information\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Validate the file path\n  if (!FileTransfer::ValidateFilePath(fullpath)) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // Write the content\n  file.write(reinterpret_cast<char*>(content.data()), content.size());\n\n  // Close the file\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 60.122425087121556}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tauto result = std::make_shared<const Bounds>();\n  result->frame = frame;\n  for (auto i = 0u; i < 4u; ++i) {\n    result->corners[i] = Rotate(transform.rotation.yaw, _parent_bounding_box.GetCorner(i));\n    result->corners[i] += transform.location;\n  }\n  return result;\n}", "CodeBleu_score": 29.666044139876448}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = transform.location + _parent_bounding_box.location;\n    const auto yaw = geom::Math::RadiansToDegrees(transform.rotation.yaw);\n    const auto extents = _parent_bounding_box.extent;\n    const auto corners = std::array<geom::Location, 4u>{\n        Rotate(yaw, {extents.x, extents.y, 0.0f}) + location,\n        Rotate(yaw, {extents.x, -extents.y, 0.0f}) + location,\n        Rotate(yaw, {-extents.x, -extents.y, 0.0f}) + location,\n        Rotate(yaw, {-extents.x, extents.y, 0.0f}) + location};\n    return std::make_shared<const Bounds>(Bounds{frame, corners});\n  }", "CodeBleu_score": 53.416915401151066}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\treturn std::make_shared<const Bounds>(Bounds{frame, {\n    Rotate(transform.rotation.yaw, _parent_bounding_box.GetLocation()),\n    Rotate(transform.rotation.yaw, _parent_bounding_box.GetLocation() + geom::Location{_parent_bounding_box.GetExtent().x, 0.0f, 0.0f}),\n    Rotate(transform.rotation.yaw, _parent_bounding_box.GetLocation() + geom::Location{0.0f, _parent_bounding_box.GetExtent().y, 0.0f}),\n    Rotate(transform.rotation.yaw, _parent_bounding_box.GetLocation() + _parent_bounding_box.GetExtent())}});\n}", "CodeBleu_score": 37.5245417630831}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n  if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n    log_warning(\n        \"attempting to send a message to sensor that doesn't support it:\",\n        GetDisplayId());\n    return;\n  }\n  GetEpisode().Lock()->SendMessage(message, GetContext());\n}", "CodeBleu_score": 64.38087437910089}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n  if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"attempting to send message to sensor but sensor ID does not match \\\"sensor.other.v2x_custom\\\"\", GetDisplayId());\n    return;\n  }\n  GetEpisode().Lock()->SendMessage(message, GetContext());\n}", "CodeBleu_score": 65.57685004777929}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n  if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"attempting to send message but sensor ID is not \\\"sensor.other.v2x_custom\\\":\", GetDisplayId());\n    return;\n  }\n  GetEpisode().Lock()->SendMessage(GetContext(), std::move(message));\n}", "CodeBleu_score": 65.85419821738178}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    if (tm_port == 0) {\n      throw_exception(std::invalid_argument(\"tm_port cannot be zero\"));\n    }\n    _tm_port = tm_port;\n    _tm_actor = GetWorld().GetTrafficManager(tm_port);\n    if (_tm_actor == nullptr) {\n      throw_exception(std::runtime_error(\"could not get traffic manager\"));\n    }\n    _tm_actor->RegisterVehicle(GetActor(), _is_control_sticky);\n  } else {\n    if (_tm_actor != nullptr) {\n      _tm_actor->DeregisterVehicle(GetActor());\n      _tm_actor = nullptr;\n    }\n  }\n}", "CodeBleu_score": 42.64777727221882}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tauto function = [this, enabled, tm_port](auto &client) {\n    client.call(\"set_autopilot\", GetActorId(), enabled, tm_port);\n  };\n  GetEpisode().Lock()->RegisterOnTickEvent(function);\n}", "CodeBleu_score": 41.93816843086638}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tGetActor()->SetAutopilot(enabled, tm_port);\n}", "CodeBleu_score": 29.521469191844073}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t_episode.Lock()->RegisterAIController(shared_from_this());\n  auto walker = GetWalker();\n  _navigation = _episode.Lock()->GetNavigationSystem()->RegisterWalker(\n      walker,\n      walker->GetLocation(),\n      _navigation_params);\n  _navigation->SetWalker(walker);\n  _navigation->SetWalkerController(this);\n  _navigation->Enable();\n  walker->SetSimulatePhysics(false);\n  walker->SetCollisionEnabled(false);\n}", "CodeBleu_score": 46.44861021140857}, {"code": "void WalkerAIController::Start(){\n\tauto walker = GetWalkerActor();\n  auto nav = GetNavigationSystem();\n  if (walker != nullptr && nav != nullptr) {\n    auto transform = walker->GetTransform();\n    nav->RegisterWalker(walker, transform.location);\n    walker->DisableSimulation();\n    walker->DisableCollision();\n  }\n}", "CodeBleu_score": 45.857921455504695}, {"code": "void WalkerAIController::Start(){\n\tauto walker = GetWalker();\n  auto episode = GetEpisode();\n  auto navigation = episode->GetNavigationSystem();\n  auto transform = walker->GetTransform();\n  navigation->RegisterWalker(walker, transform.location);\n  walker->SetSimulatePhysics(false);\n  walker->SetCollisionEnabled(CollisionType::None);\n}", "CodeBleu_score": 38.34583815327201}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set speed of walker \", walker->GetId());\n      }\n    } else {\n      log_warning(\"NAV: Failed to set speed of walker (parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 85.2725523000635}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set maximum speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set maximum speed to \", max_speed, \"(parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 80.26314521357021}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerSpeed(walker->GetId(), max_speed)) {\n        log_warning(\n            \"NAV: Failed to set maximum speed for walker \",\n            walker->GetId());\n      }\n    } else {\n      log_warning(\n          \"NAV: Failed to set maximum speed for walker (parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 81.91304435461349}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.64635326140892}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.64635326140892}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.64635326140892}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tDEBUG_ASSERT(_episode.Lock()->GetState() == EpisodeState::Running);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().synchronous_mode == settings.synchronous_mode);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().no_rendering_mode == settings.no_rendering_mode);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().replayer_enabled == settings.replayer_enabled);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().synchronous_mode == settings.synchronous_mode);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().substepping == settings.substepping);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().max_substep_delta_time == settings.max_substep_delta_time);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().max_substeps == settings.max_substeps);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().max_culling_distance == settings.max_culling_distance);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().max_actors == settings.max_actors);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().max_blueprints == settings.max_blueprints);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().quality_level == settings.quality_level);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().frame_number == settings.frame_number);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().seed == settings.seed);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().deterministic == settings.deterministic);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().replay_sensor_data == settings.replay_sensor_data);\n  DEBUG_ASSERT(_episode.Lock()->GetEpisodeSettings().enable_gpu_determin", "CodeBleu_score": 21.659768471061607}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tusing namespace std::chrono;\n  using namespace std::chrono_literals;\n  const auto start_time = steady_clock::now();\n  const auto end_time = start_time + (timeout > 0ms ? timeout : _episode.Lock()->GetNetworkingTimeout());\n  uint64_t result = 0u;\n  for (auto attempt = 0u; attempt < 5u; ++attempt) {\n    result = _episode.Lock()->ApplySettings(settings);\n    if (result != 0u) {\n      break;\n    }\n    std::this_thread::sleep_for(100ms);\n  }\n  if (result == 0u) {\n    log_warning(\n        \"Settings could not be applied, either the timeout is too short or the server is not responding\");\n  }\n  if (settings.has_fixed_delta_seconds()) {\n    const auto start_time = steady_clock::now();\n    const auto end_time = start_time + 3s;\n    auto last_delta_seconds = 0.0;\n    for (auto attempt = 0u; attempt < 100u; ++attempt) {\n      const auto current_settings = GetSettings();\n      if (current_settings.has_fixed_delta_seconds()) {\n        const auto delta_seconds = current_settings.fixed_delta_seconds();\n        if (std::abs(delta_seconds - settings.fixed_delta_seconds()) < 0.001) {\n          log_info(\"Fixed delta seconds correctly applied\");\n          break;\n        }\n        if (last_delta_seconds != 0.0 && std::abs(delta_seconds - last_delta_seconds) > 0.001) {\n          log_warning(\n              \"The server is applying a fixed delta seconds different than the one requested\");\n          break;\n        }\n        last_delta_seconds = delta_seconds;\n      }\n      if (steady_clock::now() > end_time) {\n        log_warning(\"Timeout waiting for the server to apply the fixed delta seconds\");\n        break;\n      }\n      std::this_thread::sleep", "CodeBleu_score": 47.22659231962491}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tauto episode = _episode.Lock();\n  auto settings_id = episode->ApplySettings(settings, timeout);\n  if (settings.synchronous_mode) {\n    episode->SetSynchronousMode(true);\n  }\n  return settings_id;\n}", "CodeBleu_score": 19.92035198744544}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n  const Vector2D segment = segment_end - segment_start;\n  const float squared_length = segment.SquaredLength();\n  if (squared_length < 0.00000001f) {\n    const float distance_to_start = (point - segment_start).Length();\n    return std::make_pair(distance_to_start, distance_to_start);\n  }\n  const float length = std::sqrt(squared_length);\n  const float t = std::max(0.0f, std::min(1.0f, Dot(segment, point - segment_start) / squared_length));\n  const Vector2D projection = segment_start + t * segment;\n  const float distance_to_projection = (point - projection).Length();\n  return std::make_pair(distance_to_projection, t * length);\n}\n", "CodeBleu_score": 43.672497051351215}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n    const Vector2D segment_vector = segment_end - segment_start;\n    const float segment_squared_length = segment_vector.SquaredLength();\n    if (segment_squared_length < 1e-4) {\n      return std::make_pair(0.0f, (point - segment_start).Length());\n    }\n    const float projection = Dot(point - segment_start, segment_vector) / segment_squared_length;\n    const float clamped_projection = std::max(0.0f, std::min(1.0f, projection));\n    const float distance_along_segment = segment_vector.Length() * clamped_projection;\n    return std::make_pair(distance_along_segment, (point - (segment_start + segment_vector * clamped_projection)).Length());\n  }\n}", "CodeBleu_score": 37.9252330156117}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*\n   * This function, Math::DistanceSegmentToPoint, calculates the shortest distance from a point to a line segment in 2D space.\nIt first computes the squared length of the segment and its length.\nIf the segment length is zero, it returns zero and the distance from the point to one endpoint.\nOtherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.\n   * @param segment_start The start of the segment.\n   * @param segment_end The end of the segment.\n   * @param point The point to which the distance is calculated.\n   * @return A pair containing the distance along the segment and the distance from the projection to the point.\n   */\n  std::pair<float, float> Math::DistanceSegmentToPoint(const Vector2D &segment_start, const Vector2D &segment_end, const Vector2D &point) {\n    float squared_length = (segment_end - segment_start).SquaredLength();\n    float length = std::sqrt(squared_length);\n    if (length < 1e-6) {\n      return {0.0f, (point - segment_start).Length()};\n    }\n    float t = Dot(point - segment_start, segment_end - segment_start) / squared_length;\n    t = std::max(0.0f, std::min(1.0f, t));\n    Vector2D projection = segment_start + (segment_end - segment_start) * t;\n    return {t * length, (point - projection).Length()};\n  }\n}", "CodeBleu_score": 43.922378195432245}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\n  size_t i = GetVerticesNum() + 1;\n  AddVertices(vertices);\n  while (i < GetVerticesNum()) {\n    AddIndex(0);\n    AddIndex(i);\n    AddIndex(i + 1);\n    ++i;\n  }\n}", "CodeBleu_score": 69.02551260522453}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n    return;\n  }\n  DEBUG_ASSERT(vertices.size() >= 3);\n  size_t initial_index = GetVerticesNum();\n  AddVertices(vertices);\n  for (size_t i = initial_index + 1; i < GetVerticesNum(); ++i) {\n    AddIndex(initial_index);\n    AddIndex(i - 1);\n    AddIndex(i);\n  }\n}", "CodeBleu_score": 64.01002950770331}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n    return;\n  }\n  DEBUG_ASSERT(vertices.size() >= 3);\n  size_t i = GetVerticesNum();\n  AddVertices(vertices);\n  AddIndex(i);\n  for (size_t j = 1; j < vertices.size() - 1; ++j) {\n    AddIndex(i);\n    AddIndex(i + j);\n    AddIndex(i + j + 1);\n  }\n}", "CodeBleu_score": 56.7634644022718}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n\n  if (message->size() > carla::streaming::detail::tcp::Message::MAX_SIZE) {\n    log_error(\n        \"Primary::Write\",\n        \"message size is too big: \",\n        message->size(),\n        \" (max: \",\n        carla::streaming::detail::tcp::Message::MAX_SIZE,\n        \").\");\n    return;\n  }\n\n  _strand.post([this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n\n    _deadline.expires_from_now(_timeout);\n\n    auto self = shared_from_this();\n\n    auto handle_sent = [this, self](const boost::system::error_code &ec, size_t size) {\n      if (ec) {\n        log_error(\"Primary::Write\", \"error: \", ec.message());\n        Close();\n      }\n    };\n\n    boost::asio::async_write(\n        _socket,\n        boost::asio::buffer(message->data(), message->size()),\n        boost::asio::bind_executor(_strand, handle_sent));\n  });\n}", "CodeBleu_score": 48.3984193358629}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n\n  if (message->GetSize() > carla::streaming::detail::tcp::Message::MAX_SIZE) {\n    log_error(\n        \"Primary::Write\",\n        \"message size is too big: \",\n        message->GetSize(),\n        \" > \",\n        carla::streaming::detail::tcp::Message::MAX_SIZE);\n    return;\n  }\n\n  _strand.post([\n      this,\n      message = std::move(message)\n  ]() {\n    if (_socket.is_open()) {\n      _deadline.expires_after(_timeout);\n\n      boost::asio::async_write(\n          _socket,\n          boost::asio::buffer(message->GetData(), message->GetSize()),\n          boost::asio::bind_executor(\n              _strand,\n              [\n                  this,\n                  message\n              ](const boost::system::error_code &ec, std::size_t) {\n                HandleSent(ec, message);\n              }));\n    } else {\n      log_error(\"Primary::Write\", \"socket is not open\");\n    }\n  });\n}", "CodeBleu_score": 40.613269432468776}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->GetSize() > 0u);\n\n  auto self = shared_from_this();\n\n  _strand.post([self, message]() {\n    if (self->_socket.is_open()) {\n      boost::asio::post(\n          self->_strand,\n          [self, message]() {\n            self->_deadline.expires_from_now(self->_timeout);\n            boost::asio::async_write(\n                self->_socket,\n                boost::asio::buffer(message->GetData(), message->GetSize()),\n                boost::asio::bind_executor(\n                    self->_strand,\n                    [self, message](const boost::system::error_code &ec, std::size_t) {\n                      self->HandleSent(ec, message);\n                    }));\n          });\n    } else {\n      log_warning(\n          \"Primary\",\n          \"Attempted to send message to closed socket. Message dropped.\");\n    }\n  });\n}", "CodeBleu_score": 45.46738683607648}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 15);\n  log_info(\"sending is alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"got a response: \", response.buffer.data());\n}", "CodeBleu_score": 67.65172714213499}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((unsigned char *) \"Are you alive?\", 15);\n  log_info(\"sending is alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"got a response: \", response.buffer.size(), \" bytes\");\n}", "CodeBleu_score": 67.85637821757425}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", 15);\n  log_info(\"sending alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"got response: \", response.buffer.data());\n}", "CodeBleu_score": 64.47966613520622}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_error(\"No secondary server found for sensor \", sensor_id);\n  } else {\n    log_info(\"Enable for ROS command sent to server \", response.buffer.data());\n  }\n}", "CodeBleu_score": 56.54336721704192}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking if sensor is active\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::IS_ACTIVE, std::move(buf));\n  auto response = fut.get();\n  if (response.buffer.data()[0] == 1) {\n    log_info(\"sending enable for ros command\");\n    buf = carla::Buffer((carla::Buffer::value_type *) &sensor_id,\n                        (size_t) sizeof(stream_id));\n    fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n    response = fut.get();\n    log_info(\"response from enable for ros command: \", response.buffer.data());\n  } else {\n    log_error(\"sensor not active on any secondary server\");\n  }\n}", "CodeBleu_score": 60.45559546762416}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_error(\"Sensor \", sensor_id, \" not found on any secondary server.\");\n  } else {\n    log_info(\"Sensor \", sensor_id, \" found on secondary server \", response.buffer.data());\n  }\n}", "CodeBleu_score": 66.17267010799743}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // log_info(\"sensor \", sensor_id, \" already activated on server \", it->second);\n    return _tokens[sensor_id];\n  } else {\n    // log_info(\"sensor \", sensor_id, \" not activated on any server\");\n    // enable the sensor on a secondary server\n    auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_SENSOR, sensor_id);\n    auto response = fut.get();\n    // get the new token\n    token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n    // update the maps\n    _tokens[sensor_id] = new_token;\n    _servers[sensor_id] = response.server_id;\n    // log the action\n    log_info(\"sensor \", sensor_id, \" activated on server \", response.server_id);\n    return new_token;\n  }\n}", "CodeBleu_score": 58.197135389956934}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // if the sensor has been activated, return the existing token\n    log_info(\"sensor\", sensor_id, \"already activated on server\", it->second);\n    return _tokens[sensor_id];\n  } else {\n    // if the sensor has not been activated, enable the sensor on a secondary server, get a new token, update the maps, log the action, and return the new token\n    log_info(\"sensor\", sensor_id, \"not activated, activating...\");\n    token_type new_token = SendGetToken(sensor_id);\n    _tokens[sensor_id] = new_token;\n    _servers[sensor_id] = _router->GetNextServer();\n    log_info(\"sensor\", sensor_id, \"activated on server\", _servers[sensor_id]);\n    return new_token;\n  }\n}", "CodeBleu_score": 58.62727964031601}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"sensor\", sensor_id, \"already activated on server\", it->second);\n    return _tokens[sensor_id];\n  }\n\n  // enable the sensor on a secondary server\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_SENSOR, std::move(buf));\n\n  auto response = fut.get();\n  uint16_t server_id = *reinterpret_cast<uint16_t *>(response.buffer.data());\n  log_info(\"sensor\", sensor_id, \"enabled on server\", server_id);\n\n  // retrieve a new token\n  token_type new_token(server_id, _router->GetNextPort());\n  log_info(\"got a token:\", new_token.get_stream_id(), \",\", new_token.get_port());\n\n  // update the maps\n  _servers[sensor_id] = server_id;\n  _tokens[sensor_id] = new_token;\n\n  return new_token;\n}", "CodeBleu_score": 53.744522512410796}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<char> data((std::istreambuf_iterator<char>(file)),\n                         std::istreambuf_iterator<char>());\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 57.08801618819959}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    std::vector<char> data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    file.close();\n    return Load(data);\n}", "CodeBleu_score": 57.57382092747416}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream file(filename, std::ios::binary);\n  if (!file) {\n    return false;\n  }\n  file.seekg(0, std::ios::end);\n  std::streampos length = file.tellg();\n  file.seekg(0, std::ios::beg);\n  std::vector<unsigned char> data(length);\n  file.read((char *)data.data(), length);\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 50.006877358791144}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    _matched = info.total_count;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched = info.total_count;\n  } else {\n    std::cerr << \"Invalid count change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 78.60347399860964}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        _matched++;\n        _first_connected = true;\n    } else if (info.current_count_change == -1) {\n        _matched--;\n    } else {\n        std::cerr << \"ERROR: Unexpected number of matches. Got \" << info.current_count_change << \" instead of 1 or -1.\" << std::endl;\n    }\n}", "CodeBleu_score": 62.81897849390483}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    _matched++;\n    if (_matched == 1) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched--;\n  } else {\n    std::cerr << \"Invalid matched count change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 61.458672419746364}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tswitch (info.current_count_change) {\n    case 1:\n      _matched++;\n      _first_connected = true;\n      break;\n    case -1:\n      _matched--;\n      if (_matched == 0) {\n        delete _owner;\n      }\n      break;\n    default:\n      std::cout << \"Subscription matched with unknown count change (\" << info.current_count_change << \")\" << std::endl;\n      break;\n  }\n}", "CodeBleu_score": 46.54484616727351}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tswitch (info.current_count_change) {\n    case efd::SubscriptionMatchedStatus::MATCHED_MATCHING:\n      _matched++;\n      break;\n    case efd::SubscriptionMatchedStatus::MATCHED_UNMATCHING:\n      _matched--;\n      break;\n    case efd::SubscriptionMatchedStatus::NOT_MATCHED_DISPOSED:\n      _matched--;\n      break;\n    default:\n      std::cout << \"ERROR: Invalid subscription status change count (\" << info.current_count_change << \")\" << std::endl;\n      break;\n  }\n  if (_matched == 1) {\n    _first_connected = true;\n  }\n  if (_matched == 0) {\n    if (_owner != nullptr) {\n      delete _owner;\n      _owner = nullptr;\n    }\n  }\n}", "CodeBleu_score": 45.24297146126701}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    _matched++;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched--;\n    if (_matched == 0) {\n      delete this;\n    }\n  } else {\n    std::cerr << \"ERROR: CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 62.02991760216056}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 86.55950643428316}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serializeKey(ser);\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    uint32_t length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\n    // Set the length\n    *handle = length;\n\n    // If the computed key length is not enough to contain the MD5, then use directly the serialized key\n    if (length < 16) {\n        memcpy(handle, m_keyBuffer, length);\n    }\n    // Otherwise, compute the MD5\n    else {\n        // Compute MD5 hash\n        eprosima::fastcdr::md5(m_keyBuffer, length, &handle->value[0]);\n    }\n\n    return true;\n}", "CodeBleu_score": 55.44064786440428}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 86.55950643428316}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 98.77571843442053}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser); // Serialize the object.\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.76417672517327}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    try {\n        p_type->serialize(ser);\n        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n        return true;\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n}", "CodeBleu_score": 90.97648995991071}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// iterate over the available GCS channels and check for available payload space\n    for (uint8_t i = 0; i < GCS_CHANNEL_COUNT; i++) {\n        if (gcs_channels[i].available()) {\n            // send a request to start the data stream on the corresponding channel with the specified update rate\n            gcs_channels[i].send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g.sysid_this_mav), &(tracker.g.compid_this_mav), &(tracker.g", "CodeBleu_score": 40.996604698579056}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// iterate over all available channels\n    for (int i=0; i<GCS_CHANNELS; i++) {\n        // check if channel is available\n        if (gcs_channels[i].status == GCS_CHANNEL_AVAILABLE) {\n            // check if channel has enough space for the requested data stream\n            if (gcs_channels[i].payload_size >= 12) {\n                // send request to start data stream\n                gcs_channels[i].send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, &sysid, &compid, &MAV_DATA_STREAM_POSITION, &10);\n                // set status to requested\n                gcs_channels[i].status = GCS_CHANNEL_REQUESTED;\n                // set channel to requested\n                gcs_channels[i].sysid = sysid;\n                gcs_channels[i].compid = compid;\n                return;\n            }\n        }\n    }\n}", "CodeBleu_score": 46.84694838875325}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tuint8_t i;\n    /* iterate over all available GCS channels and check if there is space available to send a request */\n    for (i=0; i<GCS_CHANNELS; i++) {\n        if (gcs_channels[i].available_space() >= MAVLINK_MSG_ID_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            mavlink_message_t msg;\n            mavlink_msg_data_stream_pack(GCS_SYSTEM_ID, GCS_COMPONENT_ID, &msg, MAVLINK_DATA_STREAM_POSITION, sysid, compid, 100);\n            gcs_send_message(&msg);\n            return;\n        }\n    }\n}", "CodeBleu_score": 46.7623942844924}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    float pitch_cos = ahrs.cos_pitch();\n    if (pitch_cos != 0) {\n        ef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * ahrs.sin_pitch() * yaw;\n        ef_yaw = ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 76.5262150930838}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t// body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = ahrs.sin_roll() * pitch - ahrs.cos_roll() * ahrs.sin_pitch() * yaw;\n\tef_yaw = ahrs.cos_roll() * ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * yaw;\n\treturn true;\n}", "CodeBleu_score": 74.84052412430852}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    if (ahrs.cos_pitch() != 0) {\n        ef_pitch = ahrs.cos_pitch() * pitch - ahrs.sin_pitch() * yaw;\n        ef_yaw = ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * yaw;\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 71.72370131827655}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// Calculate the yaw and pitch in centidegrees\n    int16_t yaw_error = 0;\n    int16_t pitch_error = 0;\n    if (nav_status.target_valid) {\n        // Calculate yaw error\n        yaw_error = (int16_t)((nav_status.target_bearing - nav_status.bearing) * 100);\n        // Calculate pitch error\n        pitch_error = (int16_t)((nav_status.target_altitude - nav_status.altitude) * 100);\n    }\n    // Check if the direction is reversed\n    if (nav_status.direction_reversed) {\n        // Reverse the yaw error\n        yaw_error = -yaw_error;\n        // Reverse the pitch error\n        pitch_error = -pitch_error;\n    }\n    // Calculate the angle error\n    int16_t angle_error = (int16_t)(((float)yaw_error * config.yaw_p) + ((float)pitch_error * config.pitch_p));\n\n    // Convert the errors from earth frame to body frame\n    yaw_error = (int16_t)((float)yaw_error * config.yaw_i) + (int16_t)((float)angle_error * config.yaw_d);\n    pitch_error = (int16_t)((float)pitch_error * config.pitch_i) + (int16_t)((float)angle_error * config.pitch_d);\n\n    // Check if the target distance is valid or no minimum distance is set\n    if (nav_status.target_valid || config.min_distance == 0) {\n        // Update the pitch and yaw servos\n        Tracker::update_servos(yaw_error, pitch_error);\n    }\n\n}", "CodeBleu_score": 38.5787744852554}, {"code": "void Mode::update_auto(void){\n\t// Calculate target yaw and pitch in centidegrees\n    int16_t target_yaw = 0;\n    int16_t target_pitch = 0;\n    int16_t angle_error_yaw = 0;\n    int16_t angle_error_pitch = 0;\n    int16_t angle_error_yaw_body = 0;\n    int16_t angle_error_pitch_body = 0;\n\n    // Calculate the yaw error\n    if (nav_status.target_bearing != INVALID_ANGLE) {\n        // Calculate the yaw error\n        target_yaw = (nav_status.target_bearing + 180) % 360 - nav_status.yaw;\n        if (target_yaw > 180) {\n            target_yaw -= 360;\n        }\n        if (target_yaw < -180) {\n            target_yaw += 360;\n        }\n        angle_error_yaw = target_yaw;\n    }\n\n    // Calculate the pitch error\n    if (nav_status.target_distance != INVALID_DISTANCE) {\n        // Calculate the pitch error\n        target_pitch = (nav_status.target_distance - nav_status.distance) * 100;\n        angle_error_pitch = target_pitch;\n    }\n\n    // Check if the direction is reversed\n    if (nav_status.direction == REVERSE) {\n        angle_error_yaw *= -1;\n        angle_error_pitch *= -1;\n    }\n\n    // Convert the errors from earth frame to body frame\n    angle_error_yaw_body = angle_error_yaw * cos(nav_status.pitch / 100.0) - angle_error_pitch * sin(nav_status.pitch / 100.0);\n    angle_error_pitch_body = angle_error_yaw * sin(nav_status.pitch / 100.0) +", "CodeBleu_score": 37.77439615565038}, {"code": "void Mode::update_auto(void){\n\t// Calculate the target yaw and pitch in centidegrees\n  int16_t target_yaw = nav_pitch_to_yaw(nav_status.target_pitch);\n  int16_t target_pitch = nav_status.target_pitch;\n\n  // Check if the direction is reversed\n  if (nav_status.direction_reversed) {\n    target_yaw = -target_yaw;\n    target_pitch = -target_pitch;\n  }\n\n  // Calculate the angle error\n  int16_t yaw_error = target_yaw - nav_status.yaw;\n  int16_t pitch_error = target_pitch - nav_status.pitch;\n\n  // Convert the errors from earth frame to body frame\n  yaw_error = nav_convert_earth_to_body(yaw_error);\n  pitch_error = nav_convert_earth_to_body(pitch_error);\n\n  // Check if the target distance is valid or no minimum distance is set\n  if (nav_status.target_distance_valid || nav_params.min_distance == 0) {\n    // Update the pitch and yaw servos\n    tracker.set_pitch_servo(nav_status.pitch + pitch_error);\n    tracker.set_yaw_servo(nav_status.yaw + yaw_error);\n  }\n}", "CodeBleu_score": 37.78152362023564}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tgps.read();\n    if (gps.last_message_time() != last_gps_time) {\n        last_gps_time = gps.last_message_time();\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            // we have a valid position\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n            if (ground_start_countdown == 1) {\n                // set home location\n                set_home_location();\n            }\n        } else if (gps.status() >= AP_GPS::GPS_OK_FIX_2D) {\n            // we have a valid position\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n            if (ground_start_countdown == 1) {\n                // set home location\n                set_home_location();\n            }\n        } else {\n            // no valid position\n            ground_start_countdown = GROUND_START_COUNTDOWN;\n        }\n    }\n}", "CodeBleu_score": 53.49501212553501}, {"code": "void Tracker::update_GPS(void){\n\tif (AP::GPS().available()) {\n        gps.read();\n        if (gps.time_last_message_received() != gps.time_last_message_received_last()) {\n            if (gps.status() >= AP_GPS::GPS_3D_FIX) {\n                if (ground_start_countdown > 0) {\n                    ground_start_countdown--;\n                }\n                if (ground_start_countdown == 1) {\n                    if (gps.location().is_valid()) {\n                        set_home_location(gps.location());\n                        set_home_altitude(gps.altitude());\n                        set_home_heading(ahrs.yaw());\n                        set_home_distance(0);\n                        set_home_direction(ahrs.yaw());\n                        set_home_next_wp_distance(0);\n                        set_home_next_wp_bearing(ahrs.yaw());\n                        set_home_next_wp_altitude(gps.altitude());\n                        set_home_next_wp_location(gps.location());\n                        set_home_next_wp_heading(ahrs.yaw());\n                        set_home_next_wp_distance_save(0);\n                        set_home_next_wp_bearing_save(ahrs.yaw());\n                        set_home_next_wp_altitude_save(gps.altitude());\n                        set_home_next_wp_location_save(gps.location());\n                        set_home_next_wp_heading_save(ahrs.yaw());\n                        set_home_next_wp_distance_save(0);\n                        set_home_next_wp_bearing_save(ahrs.yaw());\n                        set_home_next_wp_altitude_save(gps.altitude());\n                        set_home_next_wp_location_save(gps.location());\n                        set_home_next_wp_heading_save(ahrs.yaw());\n                        set_", "CodeBleu_score": 41.613724018088874}, {"code": "void Tracker::update_GPS(void){\n\t// update GPS\n    gps.read();\n\n    // check if last message time has changed\n    if (gps.last_message_time() != last_gps_time) {\n        // check if GPS status is at least 3D fix\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            // check if we are still in ground start\n            if (ground_start_countdown > 0) {\n                // check if current location is valid\n                if (gps.location().is_valid()) {\n                    // set home location\n                    set_home_location();\n                    // set ground start countdown to zero\n                    ground_start_countdown = 0;\n                }\n            }\n        }\n    }\n\n    // update last message time\n    last_gps_time = gps.last_message_time();\n\n    // check if we are still in ground start\n    if (ground_start_countdown > 0) {\n        // decrement ground start countdown\n        ground_start_countdown--;\n    }\n}", "CodeBleu_score": 46.72456944805714}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// set servo to 1000 if pitch > 0, else set to 2000\n    if (pitch > 0) {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 1000);\n    } else {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 2000);\n    }\n}", "CodeBleu_score": 21.440376270631482}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= g.pitch_min) {\n        new_servo_out = g.pitch_min;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= g.pitch_max) {\n        new_servo_out = g.pitch_max;\n        g.pidPitch2Srv.reset_I();\n    }\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 38.810339993857355}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// set the pitch servo to the on/off position based on the pitch angle\n    if (pitch > 0) {\n        SRV_Channels::set_pwm(SRV_Channel::k_tracker_pitch, 1000);\n    } else {\n        SRV_Channels::set_pwm(SRV_Channel::k_tracker_pitch, 2000);\n    }\n}", "CodeBleu_score": 20.293337833737326}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n    // check baro altitude against inertial nav altitude\n    float baro_alt = inertial_nav.get_altitude();\n    if (baro_alt < 0) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Baro altitude invalid\");\n        return false;\n    }\n    float baro_alt_diff = fabsf(baro_alt - barometer.get_altitude());\n    if (baro_alt_diff > 10) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Baro altitude differs from inertial nav altitude by %f m\", (double)baro_alt_diff);\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 51.95091098192085}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// check if barometer checks are enabled\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    // call the base class barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer reference\n    if (!barometer.healthy()) {\n        check_failed(display_failure, \"Barometer not healthy\");\n        return false;\n    }\n\n    // check barometer altitude\n    if (barometer.get_altitude() > inertial_nav.get_altitude() + 2.0f) {\n        check_failed(display_failure, \"Barometer altitude above inertial altitude\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 38.64032744276409}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    // check baro reference\n    if (!baro_ref_ok()) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Baro reference not set\");\n        return false;\n    }\n\n    // check baro altitude\n    if (abs(inertial_nav.get_altitude() - barometer.get_altitude()) > 100) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Baro altitude too different from inertial nav altitude\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 43.69783770058008}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// set loop time for rate controllers\n    rate_controller.set_loop_time(scheduler.micros_since_last_loop());\n\n    // run attitude controllers\n    attitude_control.rate_controller_run();\n\n    // run position controller\n    position_control.rate_controller_run();\n\n    // run motor control\n    motor_control.rate_controller_run();\n\n    // run the motor test code\n    motor_test.run();\n\n    // run the motor test code\n    rc_override.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_test.run();\n\n    // run the rc_aux_channel_test code\n    rc_aux_channel_", "CodeBleu_score": 32.66980192399853}, {"code": "void Copter::run_rate_controller(){\n\t// get the time of this loop in microseconds\n    uint32_t now = micros();\n    // calculate the loop time in milliseconds\n    uint32_t dt = now - last_loop_time;\n    // save this value for next time\n    last_loop_time = now;\n    // calculate the loop time in seconds\n    float dt_s = (float)dt/1000.0f;\n    // exit immediately if this is our first time through\n    if (dt_s == 0) {\n        return;\n    }\n\n    // run the attitude controllers\n    attitude_control.rate_controller_run(dt_s);\n\n    // run the position controller\n    // position_control.rate_controller_run(dt_s);\n\n    // run the motor controllers\n    // motor_control.rate_controller_run(dt_s);\n}", "CodeBleu_score": 48.62135606962909}, {"code": "void Copter::run_rate_controller(){\n\t// get time in us since last call\n    uint32_t now = micros();\n    uint32_t dt = now - last_run_time;\n    last_run_time = now;\n\n    // exit immediately if this is our first run\n    if (dt == 0) {\n        return;\n    }\n\n    // calculate the loop time in seconds\n    float inv_dt = 1.0f / (float)dt;\n\n    // update the attitude controller\n    attitude_control.rate_controller_run(inv_dt);\n\n    // update the motor_out object with the latest values from the attitude controller\n    // this allows the mixer to access the latest actuator outputs\n    for (uint8_t i=0; i<AP_MOTORS_MAX_NUM_MOTORS; i++) {\n        motor_out[i] = attitude_control.throttle_out + attitude_control.roll_out + attitude_control.pitch_out + attitude_control.yaw_out;\n    }\n\n    // update the motor test object\n    // this allows the mixer to access the latest actuator outputs\n    for (uint8_t i=0; i<AP_MOTORS_MAX_NUM_MOTORS; i++) {\n        motors.test_motor_out[i] = motor_out[i];\n    }\n\n    // update the motor_test object\n    motors.update();\n}", "CodeBleu_score": 45.313217564995824}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}, {"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}, {"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tVector3f velocity = copter.inertial_nav.get_velocity();\n    float speed_sq = velocity.lengthSq();\n    if (copter.inertial_nav.position_is_valid() && speed_sq > LOOK_AHEAD_SPEED_SQ) {\n        look_ahead_yaw_angle = atan2(velocity.y, velocity.x) * 180 / M_PI;\n    }\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 50.110262058043865}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// get velocity\n    const Vector3f& vel = copter.inertial_nav.get_velocity();\n    // check if position is valid\n    if (! copter.inertial_nav.position_is_valid()) {\n        // if not, return last look-ahead yaw angle\n        return look_ahead_yaw_angle;\n    }\n    // calculate speed squared\n    float speed2 = vel.x*vel.x + vel.y*vel.y;\n    // if speed is above minimum threshold\n    if (speed2 > LOOK_AHEAD_SPEED2_THRESHOLD) {\n        // calculate look-ahead yaw angle\n        look_ahead_yaw_angle = atan2f(vel.y, vel.x);\n    }\n    // return look-ahead yaw angle\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 54.45161763168493}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// get velocity\n    const Vector3f &vel = copter.inertial_nav.get_velocity();\n    // get speed squared\n    float speed_sq = vel.lengthSq();\n    // check if we have a valid position and speed\n    if (copter.inertial_nav.position_is_valid() && speed_sq > 0.01f) {\n        // compute look-ahead yaw angle\n        look_ahead_yaw_angle = atan2f(vel.x, vel.y);\n    }\n    // return look-ahead yaw angle\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 52.35112357675883}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (is_armed()) {\n        return true;\n    }\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            sub.console->printf_P(PSTR(\"No disarm function configured\n\"));\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.27800998107739}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_shift :\n                break;\n            case JSButton::k_arm_toggle :\n                return true;\n            case JSButton::k_disarm :\n                return true;\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    if (sub.get_button(16)->function(true) == JSButton::k_shift) {\n        for (uint8_t i = 0; i < 16; i++) {\n            switch (sub.get_button(i)->function(true)) {\n                case JSButton::k_arm_toggle :\n                case JSButton::k_disarm :\n                    return true;\n            }\n        }\n    }\n\n    // if we get here, we don't have a disarm button configured\n    if (display_failure) {\n        hal.console->printf_P(PSTR(\"WARNING: Disarm button not configured\n\"));\n    }\n    return false;\n}", "CodeBleu_score": 42.70286124725203}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_shift:\n                break;\n            case JSButton::k_arm_toggle:\n                return true;\n            case JSButton::k_disarm:\n                return true;\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    if (sub.get_button(0)->function(true) == JSButton::k_shift) {\n        for (uint8_t i = 0; i < 16; i++) {\n            switch (sub.get_button(i)->function(true)) {\n                case JSButton::k_arm_toggle:\n                case JSButton::k_disarm:\n                    return true;\n            }\n        }\n    }\n\n    if (display_failure) {\n        sub.log_printf_P(MAV_SEVERITY_WARNING, PSTR(\"Disarm button not configured\"));\n    }\n    return false;\n}", "CodeBleu_score": 42.692913412381714}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// Calculate the rotation matrix\n    const float c = cosf(ahrs.yaw_sensor * 0.01f);\n    const float s = sinf(ahrs.yaw_sensor * 0.01f);\n\n    // Apply the rotation matrix\n    const float ne_x = x * c - y * s;\n    const float ne_y = x * s + y * c;\n\n    // Update x and y with the new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 54.19125285977906}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// calculate the rotation matrix\n    const float cos_yaw = cos(ahrs.yaw);\n    const float sin_yaw = sin(ahrs.yaw);\n    const float rot_mat[2][2] = { {cos_yaw, sin_yaw},\n                                  {-sin_yaw, cos_yaw} };\n\n    // apply the rotation matrix to the coordinates\n    float ne_x = rot_mat[0][0]*x + rot_mat[0][1]*y;\n    float ne_y = rot_mat[1][0]*x + rot_mat[1][1]*y;\n\n    // update the coordinates\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 51.12804755444691}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// get yaw angle\n    float yaw = ahrs.yaw_sensor;\n    // calculate rotation matrix\n    float c = cos(yaw * 0.01745329252);\n    float s = sin(yaw * 0.01745329252);\n    float m[2][2] = {{c, -s}, {s, c}};\n    // apply rotation matrix to x and y\n    float ne_x = x * m[0][0] + y * m[0][1];\n    float ne_y = x * m[1][0] + y * m[1][1];\n    // update x and y with new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 53.43415897571601}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t// check if home is already set\n    if (home_is_set()) {\n        return;\n    }\n\n    // check if motors are armed\n    if (motors_are_armed()) {\n        // set home to current location\n        set_home_to_current_location();\n    } else {\n        // attempt to set home to current EKF location\n        set_home_to_EKF_location();\n    }\n}", "CodeBleu_score": 33.14896757148213}, {"code": "void Sub::update_home_from_EKF(){\n\t// check if the home position has already been set\n    if (home_is_set()) {\n        return;\n    }\n\n    // check if the motors are armed\n    if (motors_armed()) {\n        // set home to current position\n        set_home_to_current_location();\n        return;\n    }\n\n    // attempt to set home to current EKF location\n    set_home_to_current_EKF_location();\n}", "CodeBleu_score": 30.568125285199375}, {"code": "void Sub::update_home_from_EKF(){\n\t// check if home is already set\n    if (home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set the home position to the current position\n    if (armed()) {\n        // set home position\n        set_home_to_current_location();\n        return;\n    }\n\n    // motors are not armed, set home position to current EKF location\n    // if we can't set home, don't worry about it\n    set_home_to_current_EKF_location();\n}", "CodeBleu_score": 29.837704464003217}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t// if motors are not armed, exit\n    if (!sub.armed()) {\n        sub.set_neutral_controls();\n        return;\n    }\n\n    // set spool state to unlimited\n    sub.set_spool_state(SPOOL_STATE::UNLIMITED);\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate = sub.get_pilot_desired_roll_rate();\n    float pitch_rate = sub.get_pilot_desired_pitch_rate();\n    float yaw_rate = sub.get_pilot_desired_yaw_rate();\n\n    // run attitude controller\n    attitude_control.angle_ef_roll_pitch_rate_ef_yaw_rate(roll_rate, pitch_rate, yaw_rate);\n\n    // set pilot's throttle input to throttle output without angle boost\n    sub.set_pilot_desired_throttle(sub.get_throttle_out());\n\n    // set motor inputs based on pilot controls\n    sub.set_motor_controls(\n        sub.get_pilot_desired_roll(),\n        sub.get_pilot_desired_pitch(),\n        sub.get_pilot_desired_yaw(),\n        sub.get_pilot_desired_throttle()\n    );\n}", "CodeBleu_score": 39.7349527138919}, {"code": "void ModeAcro::run(){\n\t// if not armed, set throttle to zero, relax attitude controllers, and exit\n    if (!sub.armed()) {\n        sub.set_neutral_controls();\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    sub.set_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate = pilot_roll_rate_in;\n    float pitch_rate = pilot_pitch_rate_in;\n    float yaw_rate = pilot_yaw_rate_in;\n\n    // run attitude controller with rates\n    attitude_control.angle_ef_roll_pitch_rate_ef_yaw_rate(roll_rate, pitch_rate, yaw_rate);\n\n    // set pilot's throttle input without angle boost as forward motor input\n    sub.set_forward_motor(pilot_throttle_in);\n\n    // set lateral motor inputs\n    sub.set_lateral_motor(pilot_roll_in, pilot_pitch_in);\n}", "CodeBleu_score": 33.85805471561783}, {"code": "void ModeAcro::run(){\n\t// set target altitude to zero for reporting\n    position_control->set_pos_target_z_cm(0);\n\n    // attitude hold inputs become thrust inputs in acro mode\n    // set to neutral to prevent chaotic behavior (esp. roll/pitch)\n    sub.set_neutral_controls();\n\n    // if not armed, return\n    if (!sub.armed()) {\n        sub.set_throttle(0);\n        sub.set_spool_state(SpoolState::Disabled);\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    sub.set_spool_state(SpoolState::Unlimited);\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate = sub.get_pilot_desired_roll_rate();\n    float pitch_rate = sub.get_pilot_desired_pitch_rate();\n    float yaw_rate = sub.get_pilot_desired_yaw_rate();\n\n    // run attitude controller\n    attitude_control->run(roll_rate, pitch_rate, yaw_rate);\n\n    // output pilot's throttle input without angle boost and set motor inputs\n    sub.set_throttle(sub.get_pilot_desired_throttle() * 0.75f);\n    sub.set_motor_inputs();\n}", "CodeBleu_score": 39.368082470857466}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// start in position control mode\n    set_mode(MODE_POSITION_CONTROL);\n    // initialize the waypoint controller\n    guided_WP_init();\n}", "CodeBleu_score": 5.1514841440422385}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// start in position control mode\n    sub.set_mode(AUTO);\n    sub.set_guided(true);\n\n    // set the waypoint controller to the current position and velocity\n    // this will ensure that the vehicle immediately moves to the current position\n    // and the waypoint controller will be able to move it to the next position\n    // without any delay\n    // note that the waypoint controller will ignore the current position and velocity\n    // if it is given a new waypoint\n    // this is done to ensure that the vehicle moves to the current position\n    // as quickly as possible\n    waypoints.set_current_waypoint_to_current_position();\n\n    // initialize the yaw using the default auto yaw mode\n    // this will ensure that the vehicle immediately moves to the current yaw\n    // and the waypoint controller will be able to move it to the next yaw\n    // without any delay\n    // note that the waypoint controller will ignore the current yaw\n    // if it is given a new yaw\n    // this is done to ensure that the vehicle moves to the current yaw\n    // as quickly as possible\n    waypoints.set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 34.70789081646342}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// start in position control mode\n    set_mode(MODE_POSITION);\n    // initialize waypoint controller\n    wp_nav.init();\n    // retrieve stopping point\n    Vector3f pos = wp_nav.get_wp_nav_position();\n    // set it as the waypoint destination\n    wp_nav.set_wp_destination(pos);\n    // initialize yaw using the default auto yaw mode\n    wp_nav.set_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 41.91052291216999}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_WP;\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // initialise wpnav to stopping point at current altitude\n    // To-Do: set to current location if disarmed?\n    // To-Do: set to stopping point altitude?\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n\n    // no need to check return status because terrain data is not used\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 36.00000535999387}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // initialise wpnav to stopping point at current altitude\n    // To-Do: set to current location if disarmed?\n    // To-Do: set to stopping point altitude?\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n\n    // no need to check return status because terrain data is not used\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 36.18060186668836}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Velocity;\n\n    // initialise vertical maximum speeds and acceleration\n    sub.guided_max_speed_z = g.guided_max_speed_z;\n    sub.guided_accel_z = g.guided_accel_z;\n\n    // initialise velocity controllers\n    sub.guided_velocity_init();\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 39.806902126982656}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}, {"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}, {"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n\n    // Check if motor test requests are received at least every 2 Hz.\n    if (tnow < last_do_motor_test_ms + 500) {\n        return true;\n    }\n\n    // Motor test requests are not received at least every 2 Hz.\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test request timeout\");\n    ap.motor_test_pass = false;\n    ap.motor_test = false;\n    motors.armed(false);\n    last_do_motor_test_fail_ms = tnow;\n    return false;\n}", "CodeBleu_score": 58.89876079869839}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n    // check if motor test has timed out\n    if (tnow - last_do_motor_test_ms > MOTOR_TEST_TIMEOUT_MS) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        ap.motor_test_pass = false;\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    // check if motor test has passed\n    if (ap.motor_test_pass) {\n        return true;\n    }\n    // check if motor test has failed\n    if (tnow - last_do_motor_test_ms > MOTOR_TEST_FAIL_MS) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test failed\");\n        ap.motor_test_pass = false;\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return false;\n}", "CodeBleu_score": 53.86029324887658}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n    if (tnow - last_do_motor_test_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        motor_test_pass = false;\n        ap.motor_test = false;\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 49.504270564254085}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target = wp_nav.get_roll_cd();\n    float pitch_target = wp_nav.get_pitch_cd();\n    float roll_range = get_param_float(PARAM_WPNAV_RP_RANGE);\n    float pitch_range = get_param_float(PARAM_WPNAV_RP_RANGE);\n    float roll_target_normalized = constrain_float(roll_target, -roll_range, roll_range) / roll_range;\n    float pitch_target_normalized = constrain_float(pitch_target, -pitch_range, pitch_range) / pitch_range;\n    lateral_out = roll_target_normalized;\n    forward_out = pitch_target_normalized;\n}", "CodeBleu_score": 35.49992928413097}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get roll and pitch targets from wp_nav in centidegrees\n    float roll_target = wp_nav.get_roll_cd();\n    float pitch_target = wp_nav.get_pitch_cd();\n\n    // Constrain roll and pitch targets within a specified maximum angle range\n    // These are the default values for the F450\n    float roll_max_cd = 600;\n    float pitch_max_cd = 600;\n\n    // Normalize roll and pitch targets\n    float roll_norm = constrain_float(roll_target, -roll_max_cd, roll_max_cd) / roll_max_cd;\n    float pitch_norm = constrain_float(pitch_target, -pitch_max_cd, pitch_max_cd) / pitch_max_cd;\n\n    // Assign normalized roll and pitch targets to lateral and forward\n    lateral_out = roll_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 40.099784022115045}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target_cd = wp_nav.get_roll_cd();\n    float pitch_target_cd = wp_nav.get_pitch_cd();\n    float roll_max_cd = wp_nav.get_roll_max_cd();\n    float pitch_max_cd = wp_nav.get_pitch_max_cd();\n    float roll_normalized = constrain_float(roll_target_cd, -roll_max_cd, roll_max_cd);\n    float pitch_normalized = constrain_float(pitch_target_cd, -pitch_max_cd, pitch_max_cd);\n    float roll_norm_abs = fabsf(roll_normalized);\n    float pitch_norm_abs = fabsf(pitch_normalized);\n    float lateral_norm = 0.0f;\n    float forward_norm = 0.0f;\n    if (roll_norm_abs > pitch_norm_abs) {\n        lateral_norm = (roll_normalized > 0.0f) ? 1.0f : -1.0f;\n        forward_norm = pitch_normalized / roll_norm_abs;\n    } else {\n        lateral_norm = (pitch_normalized > 0.0f) ? 1.0f : -1.0f;\n        forward_norm = roll_normalized / pitch_norm_abs;\n    }\n    lateral_out = lateral_norm;\n    forward_out = forward_norm;\n}", "CodeBleu_score": 34.7032270246428}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t// update the barometer\n  barometer.update();\n  // if the altitude is above zero, update the barometer calibration\n  if (barometer.get_altitude() > 0.0) {\n    barometer.calibrate();\n  }\n  // if a depth sensor is present, update the sensor health status based on the barometer's health\n  if (depth_sensor_present) {\n    if (barometer.get_health() == 0) {\n      depth_sensor_health = 0;\n    }\n  }\n}", "CodeBleu_score": 62.215404194097346}, {"code": "void Sub::read_barometer(){\n\t// read barometer\n  barometer.read();\n  altitude = barometer.getAltitude();\n  // update barometer calibration\n  if (altitude > 0) {\n    barometer_calibration = altitude;\n  }\n  // update depth sensor health status\n  if (altitude > 0 && depth_sensor_health == 1) {\n    depth_sensor_health = 2;\n  }\n  // update depth sensor health status\n  if (altitude == 0 && depth_sensor_health == 2) {\n    depth_sensor_health = 1;\n  }\n}", "CodeBleu_score": 41.82172253591294}, {"code": "void Sub::read_barometer(){\n\t// update barometer data\n  barometer.update();\n\n  // update barometer calibration if altitude is above zero\n  if (barometer.get_altitude() > 0) {\n    barometer.calibrate();\n  }\n\n  // update sensor health based on barometer health\n  if (barometer.get_health() != 0) {\n    depth.set_health(barometer.get_health());\n  }\n\n  // update depth sensor health based on barometer health\n  if (barometer.get_health() != 0) {\n    depth.set_health(barometer.get_health());\n  }\n}", "CodeBleu_score": 57.852411776347836}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}, {"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}, {"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// return true if control mode does not require position or velocity\n    if (!(rover.control_mode == Rover::CONTROL_MODE_POSITION || rover.control_mode == Rover::CONTROL_MODE_VELOCITY)) {\n        return true;\n    }\n\n    // return false if parent class's gps checks fail\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // return false if AHRS system is not ready\n    if (!ahrs.healthy()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS system not ready\");\n        return false;\n    }\n\n    // return false if EKF failsafe is active\n    if (ahrs.ekf_failsafe()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // return false if position estimate is not valid\n    if (!ahrs.get_position_valid()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"position estimate not valid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 59.02976760459634}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we are not in a position controlled mode, we can skip the GPS checks\n    if (!_vehicle_control_mode.flag_control_position_enabled && !_vehicle_control_mode.flag_control_velocity_enabled) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.healthy()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not healthy\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ahrs.get_ekf().failsafe_ekf_on()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.get_ekf().position_ok()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"position estimate not valid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 59.42668631895175}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// check if control mode requires position or velocity\n    if (rover.control_mode == Rover::CONTROL_MODE_PASSTHROUGH ||\n        rover.control_mode == Rover::CONTROL_MODE_PASSTHROUGH_PID) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.healthy()) {\n        check_failed(ARMING_CHECK_AHRS, display_failure, \"AHRS not ready\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ahrs.ekf_failsafe()) {\n        check_failed(ARMING_CHECK_EKF, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.is_valid()) {\n        check_failed(ARMING_CHECK_EKF, display_failure, \"EKF position estimate invalid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 57.81012104142555}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks && !arm_checks(method)) {\n        return false;\n    }\n\n    // if we are already armed, return immediately\n    if (armed) {\n        return true;\n    }\n\n    // record the arming method\n    arming_method = method;\n\n    // record the arming time\n    arming_time = hal.scheduler->millis();\n\n    // record the current location as the SmartRTL home location\n    rover.smart_rtl.set_home_location();\n\n    // initialise the simple mode heading\n    rover.simple_mode.init_heading();\n\n    // record the home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.set_home_heading(rover.ahrs.yaw_sensor);\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    rover.send_text_fmt(MAV_SEVERITY_INFO, \"Armed\");\n\n    // we have armed\n    armed = true;\n\n    return true;\n}", "CodeBleu_score": 56.62290639421447}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks) {\n        if (!arm_checks(method)) {\n            return false;\n        }\n    }\n\n    // set the arming method\n    arming_method = method;\n\n    // set the arming time\n    arming_time = hal.scheduler->millis();\n\n    // set the vehicle armed flag\n    armed = true;\n\n    // set the soft armed flag\n    update_soft_armed();\n\n    // send status text\n    if (method == AP_Arming::ARM_DISARM_VOL) {\n        rover.status->set_arming_status(AP_Status::ARMING_VOL);\n    } else if (method == AP_Arming::ARM_DISARM_VVI) {\n        rover.status->set_arming_status(AP_Status::ARMING_VVI);\n    } else if (method == AP_Arming::ARM_DISARM_GPS) {\n        rover.status->set_arming_status(AP_Status::ARMING_GPS);\n    } else if (method == AP_Arming::ARM_DISARM_MAG) {\n        rover.status->set_arming_status(AP_Status::ARMING_MAG);\n    } else if (method == AP_Arming::ARM_DISARM_BARO) {\n        rover.status->set_arming_status(AP_Status::ARMING_BARO);\n    } else if (method == AP_Arming::ARM_DISARM_PITOT) {\n        rover.status->set_arming_status(AP_Status::ARMING_PITOT);\n    } else if (method == AP_Arming::ARM_DISARM_FENCE) {\n        rover.status->set_arming_status(AP_Status::ARMING_FENCE);\n    } else if (method == AP_Arming::ARM_DISARM_SAFE) {\n        rover.status->set_arming_status(AP_Status::ARMING_SAFE", "CodeBleu_score": 35.1022263402632}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks) {\n        if (!arm_checks(method)) {\n            return false;\n        }\n    }\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n    // set SmartRTL home location\n    if (rover.smart_rtl.enabled()) {\n        rover.smart_rtl.set_home();\n    }\n    // set simple mode heading\n    if (rover.control_mode->get_simple_mode()) {\n        rover.simple_mode.set_heading();\n    }\n    // record home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.set_home_heading();\n    }\n    // update soft armed status\n    update_soft_armed();\n    // send arm/disarm status text\n    send_status_text();\n    return true;\n}", "CodeBleu_score": 61.587880262498715}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}, {"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}, {"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}, {"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}, {"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n    soundSerial.clear();\n\n    // initialize the sound module\n    myMP3.begin(soundSerial);\n    myMP3.volume(20);\n\n    // retrieve the number of sound files available on the SD card\n    this->anzSoundfiles = myMP3.readFileCounts();\n\n    return (this->anzSoundfiles > 0);\n}", "CodeBleu_score": 52.336166458034114}, {"code": "bool MP3Sound::begin(){\n\t// initialize the serial communication\n    soundSerial.begin(115200);\n    // clear the buffer\n    soundSerial.clear();\n    // initialize the sound module\n    myMP3.begin(soundSerial);\n    // retrieve the number of sound files available on the SD card\n    this->anzSoundfiles = myMP3.readFileCounts();\n    // return true if there are one or more sound files available\n    return (this->anzSoundfiles > 0);\n}", "CodeBleu_score": 51.2171528241379}, {"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n    soundSerial.clear();\n    myMP3.begin(soundSerial);\n    this->anzSoundfiles = myMP3.readFileCounts();\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n        return true;\n    }\n    else {\n        this->sound_available = false;\n        return false;\n    }\n}", "CodeBleu_score": 56.650589807349874}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif(active_sounds.size() == 0) return 0;\n    if(playing) return active_sounds.size();\n    playing = true;\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    return active_sounds.size();\n}", "CodeBleu_score": 54.60412913562186}, {"code": "int MP3Sound::processSounds(){\n\tif((active_sounds.size() == 0) || (playing == true)) return active_sounds.size();\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    return active_sounds.size();\n}", "CodeBleu_score": 48.67769223063195}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0) return 0;\n  if (myMP3.available()) return active_sounds.size();\n  myMP3.play(active_sounds.back());\n  active_sounds.pop_back();\n  return active_sounds.size();\n}", "CodeBleu_score": 46.1083307616224}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      // clean up any existing memory-mapped file\n      if (c->memory_mapped_file) {\n#ifdef _WIN32\n        UnmapViewOfFile(c->memory_mapped_file);\n        CloseHandle(c->memory_mapped_file_handle);\n#else\n        munmap(c->memory_mapped_file, c->memory_mapped_file_size);\n        close(c->memory_mapped_file_descriptor);\n#endif\n      }\n\n      // setup a new memory-mapped file\n      c->memory_mapped_file_size = request_read_uint32(r);\n      c->memory_mapped_file_offset = request_read_uint32(r);\n      c->memory_mapped_file_descriptor = request_read_int32(r);\n      c->memory_mapped_file_size_set = true;\n#ifdef _WIN32\n      c->memory_mapped_file_handle = (HANDLE)_get_osfhandle(c->memory_mapped_file_descriptor);\n      c->memory_mapped_file = MapViewOfFile(c->memory_mapped_file_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0);\n#else\n      c->memory_mapped_file = mmap(NULL, c->memory_mapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, c->memory_mapped_file_descriptor, 0);\n#endif\n      if (c->memory_mapped_file == MAP_FAILED) {\n        perror(\"mmap\");\n        return false;\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 49.41789395716986}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  if (c == NULL)\n    return false;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {", "CodeBleu_score": 34.21944895500067}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {", "CodeBleu_score": 37.47251275620721}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.40953841609917}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.40953841609917}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.40953841609917}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock();\n  Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    sampling_period = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 72.15178095221421}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock();\n  Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    sampling_period = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 72.15178095221421}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock();\n  Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    sampling_period = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 72.15178095221421}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  free(dms);\n  return result;\n}", "CodeBleu_score": 42.83744263926962}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString(dms);\n  free(dms);\n  return dmsString;\n}", "CodeBleu_score": 40.269331640472075}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.11883455436265}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g && g->type == dBoxClass);\n  dAASSERT (plane);\n\n  const dReal *const s = ((dxBox*) g)->side;\n\n  dVector3 n;\n  dReal d;\n\n  // check x axis\n  if (dFabs (x) < s[0]) {\n    n[0] = 1.0;\n    n[1] = 0.0;\n    n[2] = 0.0;\n    d = x;\n  }\n  // check y axis\n  else if (dFabs (y) < s[1]) {\n    n[0] = 0.0;\n    n[1] = 1.0;\n    n[2] = 0.0;\n    d = y;\n  }\n  // check z axis\n  else if (dFabs (z) < s[2]) {\n    n[0] = 0.0;\n    n[1] = 0.0;\n    n[2] = 1.0;\n    d = z;\n  }\n  // check xy plane\n  else if (dFabs (x) < s[0] && dFabs (y) < s[1]) {\n    n[0] = 1.0;\n    n[1] = 1.0;\n    n[2] = 0.0;\n    d = dSqrt (x * x + y * y);\n  }\n  // check yz plane\n  else if (dFabs (y) < s[1] && dFabs (z) < s[2]) {\n    n[0] = 0.0;\n    n[1] = 1.0;\n    n[2] = 1.0;\n    d = dSqrt (y * y + z * z);\n  }\n  // check xz plane\n  else if (dFabs (x) < s[0] && dFabs (z) < s[2]) {\n    n[0] = 1.0;\n    n[1] = 0.0;\n    n[2] =", "CodeBleu_score": 34.65039774472516}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g && g->type == dBoxClass);\n  dAASSERT (plane);\n\n  const dReal *const s = ((dxBox*) g)->side;\n  const dReal *const c = g->posr.pos;\n  const dReal px = x - c[0];\n  const dReal py = y - c[1];\n  const dReal pz = z - c[2];\n\n  dReal nx = 0, ny = 0, nz = 0, dist = 0;\n\n  if (dFabs (px) < s[0]) {\n    nx = 1;\n    dist = px;\n  }\n  else if (dFabs (px + s[0]) < s[0]) {\n    nx = -1;\n    dist = px + s[0];\n  }\n  else if (dFabs (py) < s[1]) {\n    ny = 1;\n    dist = py;\n  }\n  else if (dFabs (py + s[1]) < s[1]) {\n    ny = -1;\n    dist = py + s[1];\n  }\n  else if (dFabs (pz) < s[2]) {\n    nz = 1;\n    dist = pz;\n  }\n  else if (dFabs (pz + s[2]) < s[2]) {\n    nz = -1;\n    dist = pz + s[2];\n  }\n\n  plane[0] = nx;\n  plane[1] = ny;\n  plane[2] = nz;\n  plane[3] = dist;\n}", "CodeBleu_score": 45.69317424245361}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  dUASSERT (plane, \"argument not a plane\");\n\n  const dReal *const s = ((dxBox*) g)->side;\n  dVector3 c = {0, 0, 0};\n  dGeomBoxGetCenter (g, c);\n  dVector3 p = {x - c[0], y - c[1], z - c[2]};\n\n  dReal d = dInfinity;\n  dVector3 n = {0, 0, 0};\n  if (dFabs (p[0]) < s[0]) {\n    d = dFabs (p[0]);\n    n[0] = p[0] > 0 ? 1 : -1;\n  }\n  if (dFabs (p[1]) < s[1]) {\n    dReal d1 = dFabs (p[1]);\n    if (d1 < d) {\n      d = d1;\n      n[0] = 0;\n      n[1] = p[1] > 0 ? 1 : -1;\n    }\n  }\n  if (dFabs (p[2]) < s[2]) {\n    dReal d1 = dFabs (p[2]);\n    if (d1 < d) {\n      d = d1;\n      n[0] = 0;\n      n[1] = 0;\n      n[2] = p[2] > 0 ? 1 : -1;\n    }\n  }\n\n  dVector3Copy (n, plane);\n  plane[3] = -dDOT (n, p);\n}", "CodeBleu_score": 44.05683961687146}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\tauto input_duration = getInput<int>(\"milliseconds\");\n  if (!input_duration) {\n    throw RuntimeError(\"missing required input [milliseconds]\");\n  }\n  auto duration = *input_duration;\n  if (duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_.start(std::chrono::milliseconds(duration),\n               [this]() {\n                 timer_waiting_ = false;\n                 this->halt();\n               });\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 57.03229417434569}, {"code": "NodeStatus SleepNode::onStart(){\n\tauto input_duration = getInput<unsigned int>(\"duration\");\n  if (!input_duration) {\n    return NodeStatus::SUCCESS;\n  }\n  if (*input_duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  timer_waiting_ = true;\n  timer_ = std::make_shared<Timer>(*input_duration);\n  timer_->start();\n  timer_->setCallback([this]() {\n    timer_waiting_ = false;\n    this->halt();\n  });\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 49.21482216558487}, {"code": "NodeStatus SleepNode::onStart(){\n\tif (!getInput<int>(\"duration\", duration_)) {\n        throw BT::RuntimeError(\"missing required input [duration]\");\n    }\n\n    if (duration_ <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n\n    timer_ = std::make_shared<rclcpp::GenericTimer<>>();\n    timer_->set_callback([this]() {\n        timer_waiting_ = false;\n        this->halt();\n    });\n\n    timer_->reset();\n\n    timer_waiting_ = true;\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 49.6096899448204}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\tif (entry_key_.empty()) {\n    throw LogicError(\"Missing port 'entry' in \", name());\n  }\n\n  auto entry = blackboard_->getEntry(entry_key_);\n  if (!entry) {\n    return NodeStatus::FAILURE;\n  }\n\n  std::lock_guard<std::mutex> lock(entry->mutex);\n  if (entry->sequence_id != sequence_id_) {\n    sequence_id_ = entry->sequence_id;\n    return NodeStatus::SUCCESS;\n  }\n\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 48.320336574575265}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tauto& entry = getInput<Blackboard::Ptr>(\"entry\");\n  if(entry)\n  {\n    std::lock_guard<std::mutex> lock(entry->mutex_);\n    if(entry->sequence_id_ != sequence_id_)\n    {\n      sequence_id_ = entry->sequence_id_;\n      return NodeStatus::SUCCESS;\n    }\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 34.94227951476289}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tauto& blackboard = getBlackboard();\n  auto it = blackboard.getEntry(entry_key_);\n  if (!it) {\n    return NodeStatus::FAILURE;\n  }\n  auto& entry = *it;\n  std::lock_guard<std::mutex> lock(entry.mutex_);\n  if (entry.sequence_id_ != last_sequence_id_) {\n    last_sequence_id_ = entry.sequence_id_;\n    return NodeStatus::SUCCESS;\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 51.43405454984047}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif(success_threshold_ < 0)\n  {\n    return static_cast<size_t>(children_nodes_.size() + success_threshold_);\n  }\n  else\n  {\n    return static_cast<size_t>(success_threshold_);\n  }\n}", "CodeBleu_score": 65.6854557851193}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n        return children_nodes_.size() + success_threshold_;\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 52.585632009418106}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif(success_threshold_ < 0) {\n    return children_nodes_.size() + success_threshold_;\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 54.94376471476319}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t// If the node status is IDLE, it sets the status to RUNNING, resets halt_requested_, and starts a new asynchronous thread to run the tick function.\n  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    std::thread thread(&ThreadedAction::tickImpl, this);\n    thread.detach();\n  }\n  // If the tick function completes without a halt request, it updates the node status.\n  if (status() == NodeStatus::RUNNING && !halt_requested_.load()) {\n    setStatus(NodeStatus::SUCCESS);\n  }\n  // If an exception occurs, it catches the exception, logs an error, and sets the node status to IDLE.\n  if (status() == NodeStatus::RUNNING && halt_requested_.load()) {\n    setStatus(NodeStatus::IDLE);\n  }\n  // Finally, it returns the current status of the node.\n  return status();\n}", "CodeBleu_score": 35.49793345246846}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t// If the node status is IDLE, it sets the status to RUNNING, resets halt_requested_, and starts a new asynchronous thread to run the tick function.\n  if(status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    tick_thread_ = std::thread([this]() {\n      try {\n        tick();\n        if(!halt_requested_.load()) {\n          setStatus(NodeStatus::SUCCESS);\n        }\n      } catch(const BT::RuntimeError& ex) {\n        BT::setErrorMsg(ex.what());\n        setStatus(NodeStatus::ERROR);\n      } catch(const std::exception& ex) {\n        BT::setErrorMsg(ex.what());\n        setStatus(NodeStatus::ERROR);\n      } catch(...) {\n        BT::setErrorMsg(\"Unknown exception\");\n        setStatus(NodeStatus::ERROR);\n      }\n    });\n  }\n  // If the tick function completes without a halt request, it updates the node status.\n  if(tick_thread_.joinable() && tick_thread_.get_id() == std::this_thread::get_id()) {\n    setStatus(NodeStatus::SUCCESS);\n  }\n  // If an exception occurs, it catches the exception, logs an error, and sets the node status to IDLE.\n  if(status() == NodeStatus::ERROR) {\n    std::string error_msg = BT::getErrorMsg();\n    BT::setErrorMsg(\"\");\n    throw RuntimeError(error_msg);\n  }\n  // The function also checks for any stored exceptions and rethrows them if present.\n  if(status() == NodeStatus::ERROR) {\n    std::string error_msg = BT::getErrorMsg();\n    BT::setErrorMsg(\"\");\n    throw RuntimeError(error_msg);\n  }\n  // Finally, it returns the current status of the node.\n  return status();\n}", "CodeBleu_score": 49.3540857172829}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t// If the node status is IDLE, it sets the status to RUNNING, resets halt_requested_, and starts a new asynchronous thread to run the tick function.\n    if(getStatus() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        thread_ = std::thread([this](){\n            try {\n                setStatus(tick());\n            } catch (const std::exception& e) {\n                setStatus(NodeStatus::IDLE);\n                halt_requested_.store(true);\n                // Log the error and set the node status to IDLE.\n                getLogger().log(LogLevel::ERROR, \"Exception caught: %s\", e.what());\n            }\n        });\n    }\n    // If the tick function completes without a halt request, it updates the node status.\n    if(getStatus() == NodeStatus::SUCCESS || getStatus() == NodeStatus::FAILURE) {\n        if(!halt_requested_.load()) {\n            // If an exception occurs, it catches the exception, logs an error, and sets the node status to IDLE.\n            if(exception_ptr_ != nullptr) {\n                try {\n                    std::rethrow_exception(exception_ptr_);\n                } catch (const std::exception& e) {\n                    getLogger().log(LogLevel::ERROR, \"Exception caught: %s\", e.what());\n                    exception_ptr_ = nullptr;\n                }\n            }\n            // Finally, it returns the current status of the node.\n            return getStatus();\n        }\n    }\n    // If the node status is RUNNING, it checks for any stored exceptions and rethrows them if present.\n    if(getStatus() == NodeStatus::RUNNING) {\n        if(exception_ptr_ != nullptr) {\n            try {\n                std::rethrow_exception(exception_ptr_);\n            } catch (const std::exception& e) {\n                getLogger().log(LogLevel::ERROR, \"Exception caught: %s\", e.what());\n                exception_ptr_ = nullptr;\n            }\n        }\n    }\n    // Finally", "CodeBleu_score": 48.597944877913285}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tstream << std::endl;\n\n  auto print_node = [&](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; i++) {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n  };\n\n  applyRecursiveVisitor(root_node, print_node);\n\n  stream << std::endl;\n}", "CodeBleu_score": 29.96222222316766}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// This lambda function indents the output based on the node's depth, prints the node's name,\n    // and recursively prints the children for ControlNode or the child for DecoratorNode.\n    auto print_node = [&](const TreeNode* node, int depth) {\n        for (int i = 0; i < depth; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n    };\n\n    // Begin with a separator line.\n    stream << \"----------------------------------------\" << std::endl;\n\n    // Recursively print the tree.\n    applyRecursiveVisitor(root_node, print_node);\n\n    // End with a separator line.\n    stream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 34.83943854108291}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif(!root_node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  std::function<void(const TreeNode*, int)> print_node = [&print_node](const TreeNode* node, int depth) {\n    for(int i = 0; i < depth; ++i)\n    {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n\n    if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n    {\n      for(const auto& child : control->children())\n      {\n        print_node(static_cast<const TreeNode*>(child), depth + 1);\n      }\n    }\n    else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n    {\n      print_node(decorator->child(), depth + 1);\n    }\n  };\n\n  stream << \"--------------------------------------------------------------------------------\" << std::endl;\n  print_node(root_node, 0);\n  stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 64.06833490075535}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (node == nullptr) {\n        throw LogicError(\"The node must not be null\");\n    }\n\n    visitor(node);\n\n    if (node->getNodeType() == NodeType::CONTROL_NODE) {\n        const auto* control_node = static_cast<const ControlNode*>(node);\n        for (const auto& child : control_node->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->getNodeType() == NodeType::DECORATOR_NODE) {\n        const auto* decorator_node = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child(), visitor);\n    }\n}", "CodeBleu_score": 59.51065820986414}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"The given node is nullptr\");\n  }\n  visitor(node);\n  if (node->type == BT::ACTION_NODE) {\n    return;\n  }\n  if (node->type == BT::CONTROL_NODE) {\n    const auto control_node = static_cast<const ControlNode*>(node);\n    for (const auto& child : control_node->children) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n    return;\n  }\n  if (node->type == BT::DECORATOR_NODE) {\n    const auto decorator_node = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decorator_node->child.get(), visitor);\n    return;\n  }\n  throw LogicError(\"The given node is of an unknown type\");\n}", "CodeBleu_score": 58.38251911535024}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: cannot apply a visitor to a nullptr\");\n    }\n    visitor(node);\n    if (node->type() == NodeType::CONTROL_NODE) {\n        auto control_node = dynamic_cast<const ControlNode*>(node);\n        for (auto& child : control_node->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->type() == NodeType::DECORATOR_NODE) {\n        auto decorator_node = dynamic_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child(), visitor);\n    }\n}", "CodeBleu_score": 60.10420580842183}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builtinNodes().count(manifest.registration_ID)) {\n    throw BehaviorTreeException(\n        \"You can not register a new registration ID [\" + manifest.registration_ID +\n        \"] because it is already registered as a builtin node.\");\n  }\n  auto it = _p->builders.find(manifest.registration_ID);\n  if (it != _p->builders.end()) {\n    throw BehaviorTreeException(\n        \"You can not register a new registration ID [\" + manifest.registration_ID +\n        \"] because it is already registered.\");\n  }\n  _p->builders.insert(std::make_pair(manifest.registration_ID, builder));\n  _p->manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 54.61052821927635}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builtinNodes().count(manifest.registration_ID)) {\n    throw LogicError(\"You can not override the builtin registration ID [\",\n                     manifest.registration_ID, \"]\");\n  }\n\n  auto it = _p->builders.find(manifest.registration_ID);\n  if (it != _p->builders.end()) {\n    throw BehaviorTreeException(\"The registration ID [\",\n                                manifest.registration_ID,\n                                \"] is already registered.\");\n  }\n  _p->builders.insert(std::make_pair(manifest.registration_ID, builder));\n  _p->manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 62.68792365911793}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builtinNodes().count(manifest.ID())) {\n    throw LogicError(\"You can not register a new node with the same ID of a \"\n                     \"builtin node: \",\n                     manifest.ID());\n  }\n  if (_p->builders.count(manifest.ID())) {\n    throw BehaviorTreeException(\"A node with the same ID is already registered: \" +\n                                manifest.ID());\n  }\n  _p->builders.insert({manifest.ID(), builder});\n  _p->manifests.insert({manifest.ID(), manifest});\n}", "CodeBleu_score": 41.81949894670714}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 88.44682696911835}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto result = ParseScript(script);\n  if(result.has_value()) {\n    return result.value()(env);\n  }\n  else {\n    return nonstd::make_unexpected(result.error().what());\n  }\n}", "CodeBleu_score": 66.22257114741437}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value()) {\n    try {\n      return executor.value()(env);\n    } catch(RuntimeError& err) {\n      throw RuntimeError(StrCat(\"Error in script [\\\", script, \\\"]\n\", err.what()));\n    }\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 79.82525935933322}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> guard(_mutex);\n  if (_handle) {\n    throw RuntimeError(\"A library is already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    throw RuntimeError(std::string(\"Could not load library: \") + dlerror());\n  }\n  _path = path;\n}", "CodeBleu_score": 55.992406330295694}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> guard(_mutex);\n    if (_handle != nullptr) {\n        throw RuntimeError(\"SharedLibrary: library already loaded\");\n    }\n    _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (_handle == nullptr) {\n        throw RuntimeError(\"SharedLibrary: \" + std::string(dlerror()));\n    }\n    _path = path;\n}", "CodeBleu_score": 54.27041495397401}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  if (_handle != nullptr) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (_handle == nullptr) {\n    throw RuntimeError(std::string(\"Could not load library: \") + dlerror());\n  }\n  _path = path;\n}", "CodeBleu_score": 56.430234565789824}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//initialize the line cost\n  double line_cost = 0.0;\n\n  //create a line iterator\n  LineIterator line_iterator(x0, y0, x1, y1, costmap_);\n\n  //iterate through each point on the line\n  while(line_iterator.getCost() >= 0) {\n    //get the cost of the current point\n    double point_cost = pointCost(line_iterator.getX(), line_iterator.getY());\n\n    //if the cost is negative, return the cost immediately\n    if(point_cost < 0.0)\n      return point_cost;\n\n    //otherwise, update the line cost if the point cost is higher\n    line_cost = std::max(point_cost, line_cost);\n\n    //go to the next point on the line\n    ++line_iterator;\n  }\n\n  //return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 62.093453225465}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//initialize the line cost to 0\n  double line_cost = 0.0;\n\n  //create a line iterator\n  LineIterator line(x0, y0, x1, y1, costmap_);\n\n  //iterate through each point on the line\n  while(line.getCost() >= 0) {\n    //calculate the cost of the current point\n    double point_cost = pointCost(line.getX(), line.getY());\n\n    //if the cost is negative, we return immediately\n    if(point_cost < 0.0) {\n      return point_cost;\n    }\n\n    //otherwise, we update the line cost\n    line_cost = std::max(line_cost, point_cost);\n\n    //and increment the line iterator\n    ++line;\n  }\n\n  //if we got here, we didn't find any obstacles on the line, so we return the line cost\n  return line_cost;\n}", "CodeBleu_score": 61.89545827494225}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//initialize the line cost\n  double line_cost = 0.0;\n\n  //create a line iterator\n  LineIterator line_iterator(costmap_, x0, y0, x1, y1);\n\n  //iterate through each point on the line\n  while(line_iterator.getCost() >= 0){\n    //calculate the cost of the current point\n    double point_cost = pointCost(line_iterator.getX(), line_iterator.getY());\n\n    //if the cost is negative, return the cost immediately\n    if(point_cost < 0.0)\n      return point_cost;\n\n    //otherwise, update the line cost if the point cost is higher\n    line_cost = std::max(point_cost, line_cost);\n\n    //advance the line iterator\n    ++line_iterator;\n  }\n\n  //if all point costs are legal, then we can return that the line is legal\n  return line_cost;\n}", "CodeBleu_score": 62.349881327034915}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n  nav_msgs::Path plan;\n  plan.header.frame_id = path[0].header.frame_id;\n  plan.header.stamp = path[0].header.stamp;\n  for (const auto& pose : path) {\n    plan.poses.push_back(pose);\n  }\n  pub.publish(plan);\n}", "CodeBleu_score": 50.25524309610348}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path plan_msg;\n  plan_msg.header.stamp = path[0].header.stamp;\n  plan_msg.header.frame_id = path[0].header.frame_id;\n\n  plan_msg.poses.resize(path.size());\n  std::copy(path.begin(), path.end(), plan_msg.poses.begin());\n\n  pub.publish(plan_msg);\n}", "CodeBleu_score": 54.5855764028981}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path plan_msg;\n  plan_msg.header.frame_id = path[0].header.frame_id;\n  plan_msg.header.stamp = path[0].header.stamp;\n  plan_msg.poses.resize(path.size());\n  std::copy(path.begin(), path.end(), plan_msg.poses.begin());\n\n  pub.publish(plan_msg);\n}", "CodeBleu_score": 54.5855764028981}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (!initialized_) {\n    // initialize the limits\n    min_vel_x_ = config.min_vel_x;\n    max_vel_x_ = config.max_vel_x;\n    min_vel_y_ = config.min_vel_y;\n    max_vel_y_ = config.max_vel_y;\n    min_vel_theta_ = config.min_vel_theta;\n    max_vel_theta_ = config.max_vel_theta;\n    acc_lim_x_ = config.acc_lim_x;\n    acc_lim_y_ = config.acc_lim_y;\n    acc_lim_theta_ = config.acc_lim_theta;\n    min_in_place_vel_x_ = config.min_in_place_vel_x;\n    max_in_place_vel_x_ = config.max_in_place_vel_x;\n    min_in_place_vel_y_ = config.min_in_place_vel_y;\n    max_in_place_vel_y_ = config.max_in_place_vel_y;\n    min_in_place_vel_theta_ = config.min_in_place_vel_theta;\n    max_in_place_vel_theta_ = config.max_in_place_vel_theta;\n    acc_lim_in_place_x_ = config.acc_lim_in_place_x;\n    acc_lim_in_place_y_ = config.acc_lim_in_place_y;\n    acc_lim_in_place_theta_ = config.acc_lim_in_place_theta;\n    yaw_goal_tolerance_ = config.yaw_goal_tolerance;\n    costmap_converter_tolerance_ = config.costmap_converter_tolerance;\n    min_turning_radius_ = config.min_turning_radius;\n    max_turning_radius_ = config.max_turning_radius;\n    // set the flag\n    initialized_ = true;\n  }\n  else if (restore_defaults) {\n    // reset the limits", "CodeBleu_score": 29.63947187129597}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_ && restore_defaults) {\n    ROS_INFO(\"Restoring default local planner limits\");\n    config_ = LocalPlannerLimits();\n  }\n  if (!setup_) {\n    ROS_INFO(\"Setting up local planner limits\");\n    config_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock lock(config_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 64.20778748194927}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif(setup_ && restore_defaults) {\n    config.xy_goal_tolerance = default_xy_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.yaw_goal_tolerance = default_yaw_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.xy_goal_tolerance = default_xy_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.yaw_goal_tolerance = default_yaw_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.xy_goal_tolerance = default_xy_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.yaw_goal_tolerance = default_yaw_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.xy_goal_tolerance = default_xy_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.yaw_goal_tolerance = default_yaw_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.xy_goal_tolerance = default_xy_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy_goal_tolerance_layered_;\n    config.yaw_goal_tolerance = default_yaw_goal_tolerance_;\n    config.xy_goal_tolerance_layered = default_xy", "CodeBleu_score": 37.425081768549894}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned int mx, my;\n  costmap.worldToMap(check_cell->x, check_cell->y, mx, my);\n  unsigned char cost = costmap.getCost(mx, my);\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = std::numeric_limits<double>::max();\n    return false;\n  }\n  double new_target_dist = current_cell->target_dist + sqrt(pow(check_cell->x - current_cell->x, 2) + pow(check_cell->y - current_cell->y, 2));\n  if(new_target_dist < check_cell->target_dist)\n    check_cell->target_dist = new_target_dist;\n  return true;\n}", "CodeBleu_score": 66.46719894002085}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\n  //if the cost is unknown or an obstacle, set the target distance to the maximum obstacle cost\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = std::numeric_limits<double>::infinity();\n    return false;\n  }\n\n  //if the cost is free, calculate a new target distance and update the cell's target distance if the new distance is shorter\n  double new_distance = std::sqrt(std::pow(current_cell->cx - check_cell->cx, 2) + std::pow(current_cell->cy - check_cell->cy, 2));\n  if(new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n\n  //otherwise, the cell's target distance is already shorter than the new distance\n  return false;\n}", "CodeBleu_score": 65.79324117863315}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned int mx, my;\n  costmap.worldToMap(check_cell->x, check_cell->y, mx, my);\n  unsigned int index = getIndex(mx, my);\n  unsigned char cost = costmap.getCost(mx, my);\n  //if the cell is unknown or an obstacle, set the target distance to the max\n  if (cost == costmap_2d::NO_INFORMATION || cost == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_distance = std::numeric_limits<float>::max();\n    return false;\n  }\n  //calculate the new target distance\n  float new_target_distance = current_cell->target_distance + sqrt(pow(check_cell->x - current_cell->x, 2) + pow(check_cell->y - current_cell->y, 2));\n  //if the new target distance is shorter, update the cell's target distance\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n    check_cell->parent = current_cell;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 58.360017880367664}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scaling_factor = 1.0;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Footprint specification is empty\");\n    return -9.0;\n  }\n\n  cost = traj.cost;\n  scaling_factor = traj.scaling_factor;\n\n  for (unsigned int i = 0; i < traj.points.size(); ++i) {\n    double footprint_cost = footprintCost(traj.points[i], traj.velocities[i]);\n\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost * scaling_factor;\n}", "CodeBleu_score": 50.459805351915655}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scaling_factor = 1.0;\n  double max_cost = 0.0;\n\n  // initialize the cost based on the trajectory and speed parameters\n  cost = traj.cost * traj.speed;\n  scaling_factor = traj.speed / max_trans_vel_;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory() The footprint is empty\");\n    return -9.0;\n  }\n\n  // for each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 0; i < traj.trajectory.size(); i++) {\n    double footprint_cost = footprintCost(traj.trajectory.at(i), scaling_factor);\n\n    // if the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    // otherwise, either sum the scores or take the maximum score\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      max_cost = std::max(max_cost, footprint_cost);\n    }\n  }\n\n  // return the total cost\n  return sum_scores_ ? cost : max_cost;\n}", "CodeBleu_score": 54.67880330203655}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scaling_factor = 1.0;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified for the cost function\");\n    return -9.0;\n  }\n\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  cost = traj.getCost();\n  scaling_factor = traj.getScalingFactor();\n\n  // for each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = scoreFootprint(traj.getPoints().at(i));\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  // return the total cost\n  return cost;\n}", "CodeBleu_score": 52.84199034942121}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// make sure we have a world model\n  if (world_model == NULL) {\n    ROS_ERROR(\"World model is NULL\");\n    return -6.0;\n  }\n\n  // make sure we have a costmap\n  if (costmap == NULL) {\n    ROS_ERROR(\"Costmap is NULL\");\n    return -6.0;\n  }\n\n  // make sure the footprint is valid\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"Footprint is empty\");\n    return -6.0;\n  }\n\n  // make sure the footprint is convex\n  if (!isFootprintConvex(footprint_spec)) {\n    ROS_ERROR(\"Footprint is not convex\");\n    return -6.0;\n  }\n\n  // make sure the footprint is oriented correctly\n  if (!isFootprintOriented(footprint_spec)) {\n    ROS_ERROR(\"Footprint is not oriented correctly\");\n    return -6.0;\n  }\n\n  // make sure the robot is on the costmap\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    ROS_DEBUG(\"Robot is off the costmap\");\n    return -7.0;\n  }\n\n  // calculate the footprint polygon\n  std::vector<geometry_msgs::Point> footprint;\n  footprint = scaleFootprint(footprint_spec, scale);\n\n  // calculate the footprint cost\n  double cost = world_model->footprintCost(mx, my, th, footprint);\n\n  // if the cost is negative, return -6.0\n  if (cost < 0.0) {\n    return -6.0;\n  }\n\n  // otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  unsigned int cell_x, cell_y;\n  costmap->worldToMap(x, y, cell_x, cell_y);\n  double cell_cost = costmap->getCost(cell_x, cell_y);\n  return std::max(cost, cell_cost);", "CodeBleu_score": 54.402666319503076}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\tif (world_model == NULL) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost() world model is NULL!\");\n    return -6.0;\n  }\n  if (costmap == NULL) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost() costmap is NULL!\");\n    return -6.0;\n  }\n\n  // get the footprint points in the world\n  std::vector<geometry_msgs::Point> scaled_footprint = scaleFootprint(footprint_spec, scale);\n\n  // transform the footprint into the world\n  tf::Transform transform;\n  transform.setOrigin(tf::Vector3(x, y, 0.0));\n  transform.setRotation(tf::createQuaternionFromYaw(th));\n\n  std::vector<geometry_msgs::Point> transformed_footprint;\n  transformed_footprint.resize(scaled_footprint.size());\n  for (unsigned int i = 0; i < scaled_footprint.size(); ++i) {\n    tf::Point pt(scaled_footprint[i].x, scaled_footprint[i].y, scaled_footprint[i].z);\n    tf::Point transformed_pt = transform * pt;\n    transformed_footprint[i].x = transformed_pt.x();\n    transformed_footprint[i].y = transformed_pt.y();\n    transformed_footprint[i].z = transformed_pt.z();\n  }\n\n  // check to make sure the footprint is on the map\n  if (!costmap->worldToMap(transformed_footprint[0].x, transformed_footprint[0].y,\n                           transformed_footprint[0].z,\n                           transformed_footprint[0].x,\n                           transformed_footprint[0].y)) {\n    ROS_DEBUG(\"ObstacleCostFunction::footprintCost() robot footprint is off the map!\");\n    return -7.0;\n  }\n\n  // get the cost of the footprint\n  double footprint_cost = world_model->footprintCost(transformed_footprint);\n\n  // get the cost of the", "CodeBleu_score": 50.235681181357336}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// transform the footprint polygon into the robot's footprint frame\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = scale * footprint_spec[i].x;\n    scaled_point.y = scale * footprint_spec[i].y;\n    scaled_footprint_spec.push_back(scaled_point);\n  }\n\n  // transform the footprint into the global frame\n  tf::Quaternion quat;\n  quat.setEuler(0, 0, th);\n  tf::Transform footprint_transform(quat, tf::Vector3(x, y, 0));\n  std::vector<geometry_msgs::Point> global_footprint_spec;\n  for (unsigned int i = 0; i < scaled_footprint_spec.size(); ++i) {\n    tf::Point tf_point(scaled_footprint_spec[i].x, scaled_footprint_spec[i].y, 0);\n    tf::Point global_point = footprint_transform * tf_point;\n    geometry_msgs::Point global_point_msg;\n    global_point_msg.x = global_point.x();\n    global_point_msg.y = global_point.y();\n    global_footprint_spec.push_back(global_point_msg);\n  }\n\n  // check if the robot is on the map\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n\n  // check if the robot is in a lethal obstacle\n  if (world_model->isLethal(mx, my)) {\n    return -6.0;\n  }\n\n  // compute the cost of the robot's footprint\n  double footprint_cost = world_model->footprintCost(global_footprint_spec, mx, my);\n\n  // check", "CodeBleu_score": 64.79551020906626}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic == odom_topic_)\n    return;\n\n  odom_topic_ = odom_topic;\n\n  if (!odom_topic_.empty()) {\n    odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n  }\n  else {\n    odom_sub_.shutdown();\n  }\n}", "CodeBleu_score": 45.982589599859374}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      ROS_INFO_STREAM(\"Subscribing to odometry topic: \" << odom_topic_);\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_INFO_STREAM(\"Unsubscribing from odometry topic.\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 49.139350770221235}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      ROS_INFO_STREAM(\"Subscribing to odometry topic: \" << odom_topic_);\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    else {\n      ROS_INFO(\"Unsubscribing from odometry topic\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 47.24931197624874}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  float dist_sq = diff.dot(diff);\n  float angle_diff = std::fabs(std::atan2(diff.y(), diff.x()) - std::atan2(prev.y(), prev.x()));\n  if (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_ || angle_diff > oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 51.01820811670949}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  double dist = diff.norm();\n  double angle = std::fabs(std::atan2(diff[1], diff[0]));\n\n  if (dist > oscillation_reset_dist_ || angle > oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 39.468172004999744}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  double dist_sq = diff.squaredNorm();\n  double angle = std::atan2(diff[1], diff[0]);\n  double angle_diff = std::fabs(angle - prev_angle_);\n\n  if (dist_sq >= oscillation_reset_dist_ * oscillation_reset_dist_ ||\n      angle_diff >= oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 45.46241788883471}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, doing nothing\");\n    return;\n  }\n  if(!global_costmap_) {\n    ROS_ERROR(\"The global costmap is NULL, doing nothing\");\n    return;\n  }\n  if(!local_costmap_) {\n    ROS_ERROR(\"The local costmap is NULL, doing nothing\");\n    return;\n  }\n\n  if(invert_area_to_clear_)\n    ROS_WARN(\"Clearing inside the area specified by the costmap\");\n  else\n    ROS_WARN(\"Clearing outside the area specified by the costmap\");\n\n  if(affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n    ROS_INFO(\"Clearing local costmap\");\n    boost::shared_ptr<costmap_2d::Costmap2D> local_costmap = boost::static_pointer_cast<costmap_2d::Costmap2D>(local_costmap_->getCostmap());\n    if(force_updating_)\n      local_costmap->updateMap(true);\n    local_costmap->setCostmap2D(local_costmap->getCostmap(), reset_distance_);\n    local_costmap->updateMap();\n    ROS_INFO(\"Local costmap cleared in %f seconds\", local_costmap->getTimeTaken());\n  }\n  if(affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n    ROS_INFO(\"Clearing global costmap\");\n    boost::shared_ptr<costmap_2d::Costmap2D> global_costmap = boost::static_pointer_cast<costmap_2d::Costmap2D>(global_costmap_->getCostmap());\n    if(force_updating_)\n      global_costmap->updateMap(true);\n    global_costmap->setCostmap2D(global_costmap->getCostmap(), reset_distance_);\n    global_costmap->updateMap();\n    ROS_INFO(\"Global costmap cleared in %f seconds\", global_costmap->getTimeTaken());\n  }\n}", "CodeBleu_score": 49.501196291882515}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"The behavior has not been initialized, doing nothing\");\n    return;\n  }\n  if(!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers are not set, doing nothing\");\n    return;\n  }\n  if(invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the specified area\");\n  }\n  else {\n    ROS_WARN(\"Clearing inside of the specified area\");\n  }\n  ros::Time start = ros::Time::now();\n  if(affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n    global_costmap_->getCostmap()->setDefaultValue(NO_INFORMATION);\n    if(force_updating_) {\n      global_costmap_->updateMap();\n    }\n  }\n  if(affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n    local_costmap_->getCostmap()->setDefaultValue(NO_INFORMATION);\n    if(force_updating_) {\n      local_costmap_->updateMap();\n    }\n  }\n  ros::Time end = ros::Time::now();\n  ROS_INFO(\"Clearing the costmaps took %.3f seconds\", (end - start).toSec());\n}", "CodeBleu_score": 49.497875261938304}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"The plugin %s has not been initialized yet, behavior cannot be run\", name_.c_str());\n    return;\n  }\n  if(!global_costmap_ || !local_costmap_){\n    ROS_ERROR(\"The costmap pointers inside the plugin %s are not set, behavior cannot be run\", name_.c_str());\n    return;\n  }\n  if(invert_area_to_clear_){\n    ROS_WARN(\"Clearing inside the area specified by the footprint\");\n  }\n  else{\n    ROS_WARN(\"Clearing outside the area specified by the footprint\");\n  }\n  ros::WallTime start = ros::WallTime::now();\n  if(affected_maps_ == \"global\" || affected_maps_ == \"both\"){\n    global_costmap_->getCostmap()->setCost(global_costmap_->getGlobalFrameID(),\n                                           global_costmap_->getCostmap()->getUpdateRange(),\n                                           global_costmap_->getCostmap()->getUpdateRange(),\n                                           reset_distance_,\n                                           NO_INFORMATION,\n                                           clearable_layers_);\n    if(force_updating_){\n      global_costmap_->updateMap();\n    }\n  }\n  if(affected_maps_ == \"local\" || affected_maps_ == \"both\"){\n    local_costmap_->getCostmap()->setCost(local_costmap_->getGlobalFrameID(),\n                                          local_costmap_->getCostmap()->getUpdateRange(),\n                                          local_costmap_->getCostmap()->getUpdateRange(),\n                                          reset_distance_,\n                                          NO_INFORMATION,\n                                          clearable_layers_);\n    if(force_updating_){\n      local_costmap_->updateMap();\n    }\n  }\n  ros::WallTime end = ros::WallTime::now();\n  ROS_INFO(\"Clearing the costmap took %.3f seconds\", (end - start).toSec());\n}", "CodeBleu_score": 47.510735037508034}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (pub.getNumSubscribers() > 0) {\n    ROS_DEBUG(\"New subscriber for costmap topic\");\n    active_ = true;\n    prepareGrid();\n    publishCostmap();\n  } else {\n    ROS_DEBUG(\"No more subscribers for costmap topic\");\n    active_ = false;\n  }\n}", "CodeBleu_score": 46.94507143943571}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (!active_) {\n    active_ = true;\n    // we have a new subscriber, so we need to start publishing\n    // prepare the grid\n    prepareGrid();\n    // publish the grid\n    publishGrid();\n  }\n}", "CodeBleu_score": 51.57723163425876}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (!active_) {\n    active_ = true;\n    // prepare the grid data\n    prepareGrid();\n    // publish the prepared grid\n    publishGrid();\n  }\n}", "CodeBleu_score": 51.57723163425876}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\tif (!active_) {\n    return;\n  }\n\n  unsigned int mx, my;\n  costmap_->getSizeInCells(mx, my);\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = costmap_->getResolution();\n  grid_.info.width = mx;\n  grid_.info.height = my;\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(mx * my);\n\n  xn_ = x0_;\n  yn_ = y0_;\n\n  if (always_send_full_costmap_) {\n    x0_ = 0;\n    y0_ = 0;\n  } else {\n    x0_ = costmap_->getSizeInCellsX();\n    y0_ = costmap_->getSizeInCellsY();\n  }\n\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    unsigned int mx, my;\n    costmap_->indexToCells(i, mx, my);\n\n    if (mx < x0_ || mx >= xn_ || my < y0_ || my >= yn_) {\n      grid_.data[i] = -1;\n    } else {\n      grid_.data[i] = cost_translation_table_[costmap_->getCost(mx, my)];\n    }\n  }\n}", "CodeBleu_score": 60.937265923893456}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tif (active_) {\n    return;\n  }\n  costmap_->lock();\n  double res = costmap_->getResolution();\n  grid_.header.frame_id = global_frame_;\n  grid_.info.resolution = res;\n  grid_.info.width = x0_;\n  grid_.info.height = y0_;\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.data.resize(x0_ * y0_);\n  active_ = true;\n  costmap_->unlock();\n}", "CodeBleu_score": 39.30771930082646}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tif (!active_) {\n    return;\n  }\n\n  // lock the costmap mutex\n  boost::mutex::scoped_lock lock(costmap_->getMutex());\n\n  // get the resolution\n  double res = costmap_->getResolution();\n\n  // set the grid's header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n\n  // set the grid's resolution, width, and height\n  grid_.info.resolution = res;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // convert map coordinates to world coordinates for the origin\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n\n  // set the origin's position and orientation\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin coordinates\n  xn_ = grid_.info.origin.position.x;\n  yn_ = grid_.info.origin.position.y;\n\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data from the costmap's character map\n  unsigned int index = 0;\n  for (unsigned int j = 0; j < costmap_->getSizeInCellsY(); j++) {\n    for (unsigned int i = 0; i < costmap_->getSizeInCellsX(); i++) {\n      grid_.data[index] = cost_translation_table_[costmap_->getCost(i, j)];\n      index++;\n    }\n  }\n}", "CodeBleu_score": 70.41010141562279}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}, {"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}, {"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index > end_index) {\n    return;\n  }\n\n  // get the yaw angle at the start and end indices\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // determine the shortest angular distance between the two angles\n  double diff = angles::shortest_angular_distance(start_angle, end_angle);\n\n  // if the angle is too small, just return\n  if (fabs(diff) < 0.35) {\n    return;\n  }\n\n  // determine the incremental change in angle for each pose\n  double step_size = diff / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = angles::normalize_angle(start_angle + (i - start_index) * step_size);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 64.95429581960465}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tconst double start = tf2::getYaw(path[start_index].pose.orientation);\n  const double end = tf2::getYaw(path[end_index].pose.orientation);\n  const double diff = angles::shortest_angular_distance(start, end);\n  const double increment = diff / (end_index - start_index);\n  for (int i = start_index + 1; i <= end_index; ++i) {\n    double angle = start + (i - start_index) * increment;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 68.97088522002703}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tint n = end_index - start_index + 1;\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n  double diff = fabs(angles::shortest_angular_distance(start_angle, end_angle));\n  double increment = diff / (n - 1);\n  for(int i=start_index+1;i<=end_index;i++) {\n    double angle = tf2::getYaw(path[i].pose.orientation);\n    double new_angle = angles::normalize_angle(angle + increment);\n    set_angle(&path[i], new_angle);\n  }\n}", "CodeBleu_score": 57.49364113047515}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t//set the frame id of the start and goal to map\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    //make a plan\n    bool success = makePlan(cmap_->getCostmap(), req.start, req.goal, resp.plan);\n    //set the success status\n    resp.success = success;\n    return true;\n}", "CodeBleu_score": 61.34110094945668}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_INFO(\"Received a request to make a plan\");\n    PoseStamped start, goal;\n    start.header.frame_id = goal.header.frame_id = \"map\";\n    start.pose = req.start;\n    goal.pose = req.goal;\n    vector<PoseStamped> plan;\n    bool success = makePlan(start, goal, plan);\n    resp.plan = plan;\n    resp.success = success;\n    return true;\n}", "CodeBleu_score": 55.674877609454}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_INFO(\"PlannerWithCostmap::makePlanService\");\n    // Set the start and goal frame_id to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    // Create the start and goal poses\n    PoseStamped start, goal;\n    tf2::fromMsg(req.start, start);\n    tf2::fromMsg(req.goal, goal);\n    // Create a path\n    vector<PoseStamped> path;\n    // Make the plan\n    bool success = makePlan(start, goal, path);\n    // Update the response\n    resp.success = success;\n    if (success) {\n        resp.plan.poses = path;\n    }\n    return true;\n}", "CodeBleu_score": 74.08041167468166}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    ros::NodeHandle n(\"~/\" + name);\n    make_plan_service_ = n.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = n.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 71.35050464749216}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 79.34674356464235}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~/\" + name);\n    cmap_ = cmap;\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 82.68426615141193}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tPoseStamped start;\n  start.header.frame_id = \"map\";\n  start.header.stamp = ros::Time::now();\n  start.pose = getRobotPose();\n  vector<PoseStamped> path;\n  bool success = makePlan(start, *goal, path);\n  if (success) {\n    resp.path = path;\n  }\n}", "CodeBleu_score": 53.27890733779306}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\trm::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.header.stamp = ros::Time::now();\n  start.pose = getRobotPose();\n  vector<PoseStamped> path;\n  bool success = makePlan(start, *goal, path);\n  if (success) {\n    resp.path = path;\n  }\n}", "CodeBleu_score": 54.269151427821306}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tPoseStamped global_pose;\n  tf2::Transform global_tf;\n  cmap_->getRobotPose(global_pose);\n  tf2::fromMsg(global_pose.pose, global_tf);\n\n  vector<PoseStamped> path;\n  bool success = makePlan(global_pose, *goal, path);\n  if (success) {\n    resp.path = path;\n  }\n}", "CodeBleu_score": 62.56355059157722}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_req;\n    param_set_req.request.param_id = param_set.param_id;\n    param_set_req.request.param_value = param_set.param_value;\n    param_set_req.request.param_type = param_set.param_type;\n    param_set_req.request.target_system = 1;\n    param_set_req.request.target_component = 1;\n    param_set_req.request.param_index = param_set.param_index;\n    param_set_req.request.param_count = param_set.param_count;\n    param_set_req.request.param_text = param_set.param_text;\n\n    this->param_set_client_.call(param_set_req);\n}", "CodeBleu_score": 51.941567783614715}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_service;\n    param_set_service.request.param_id = param_set.param_id;\n    param_set_service.request.value.real = param_set.value;\n    this->param_set_client_.call(param_set_service);\n}", "CodeBleu_score": 67.57641884818095}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_msg;\n    param_set_msg.request.param_id = param_set.param_id;\n    param_set_msg.request.value.integer = param_set.value;\n    this->param_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 67.75950505345811}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// \u7b49\u5f85\u8fde\u63a5\n    if (listen(server_fd_, 10) < 0) {\n        perror(\"listen error\");\n        exit(1);\n    }\n    // \u8fde\u63a5\u6210\u529f\n    while (1) {\n        // \u7b49\u5f85\u8fde\u63a5\n        if ((client_fd_ = accept(server_fd_, (struct sockaddr *)&client_addr_, &client_addr_len_)) < 0) {\n            perror(\"accept error\");\n            exit(1);\n        }\n        // \u8fde\u63a5\u6210\u529f\n        while (1) {\n            // \u63a5\u6536\u6570\u636e\n            if ((recv_len_ = recv(client_fd_, recv_buf_, BUF_LEN, 0)) <= 0) {\n                perror(\"recv error\");\n                close(client_fd_);\n                break;\n            }\n            // \u89e3\u7801\n            if (decode(recv_buf_, recv_len_, &recv_msg_) != 0) {\n                // \u89e3\u7801\u5931\u8d25\n                ROS_ERROR(\"decode error\");\n                close(client_fd_);\n                break;\n            }\n            // \u53d1\u5e03\n            if (publish(recv_msg_) != 0) {\n                // \u53d1\u5e03\u5931\u8d25\n                ROS_ERROR(\"publish error\");\n                close(client_fd_);\n                break;\n            }\n            // \u5173\u95ed\u8fde\u63a5\n            close(client_fd_);\n        }\n    }\n}", "CodeBleu_score": 48.870060232115314}, {"code": "void CommunicationBridge::serverFun(){\n\t// \u7b49\u5f85\u8fde\u63a5\n    while (1) {\n        // \u7b49\u5f85\u8fde\u63a5\n        if (this->tcp_server_socket_.accept(this->tcp_client_socket_) == -1) {\n            ROS_ERROR(\"tcp_server_socket_.accept() failed!\");\n            return;\n        }\n        // \u63a5\u6536\u6570\u636e\n        while (1) {\n            // \u63a5\u6536\u6570\u636e\n            if (this->tcp_client_socket_.receive(this->tcp_msg_) == -1) {\n                ROS_ERROR(\"tcp_client_socket_.receive() failed!\");\n                return;\n            }\n            // \u89e3\u7801\u6570\u636e\n            if (this->tcp_msg_.decode() == -1) {\n                ROS_ERROR(\"tcp_msg_.decode() failed!\");\n                return;\n            }\n            // \u5904\u7406\u6570\u636e\n            if (this->tcp_msg_.getLength() <= 0) {\n                ROS_ERROR(\"tcp_msg_.getLength() <= 0!\");\n                return;\n            }\n            // \u5904\u7406\u6570\u636e\n            switch (this->tcp_msg_.getType()) {\n                case 0: {\n                    // \u5904\u7406\u6570\u636e\n                    if (this->tcp_msg_.getLength() != sizeof(int)) {\n                        ROS_ERROR(\"tcp_msg_.getLength() != sizeof(int)!\");\n                        return;\n                    }\n                    // \u5904\u7406\u6570\u636e\n                    if (this->tcp_msg_.getData() == NULL) {\n                        ROS_ERROR(\"tcp_msg_.getData() == NULL!\");\n                        return;\n                    }\n                    // \u5904\u7406\u6570\u636e\n                    int *data = (int *)this->tcp_msg_.getData();\n                    // \u5904\u7406\u6570\u636e\n                    if (data[0] == 0) {\n                        // \u5904\u7406\u6570\u636e\n                        if (this->uav_basic_ != NULL) {\n                            // \u5904\u7406\u6570\u636e\n                            this->uav_basic_->close();\n                            // \u5904\u7406\u6570\u636e\n                            delete this->uav_basic_;", "CodeBleu_score": 23.43390885104309}, {"code": "void CommunicationBridge::serverFun(){\n\t// \u7b49\u5f85\u8fde\u63a5\n    int socket_fd = -1;\n    struct sockaddr_in serv_addr;\n    int addrlen = sizeof(serv_addr);\n    char recv_buf[BUFFER_SIZE];\n    int n = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int ret = 0;\n    int ret_recv = 0;\n    int ret_send = 0;\n    int ret_send_heartbeat = 0;\n    int ret_send_heartbeat_check = 0;\n    int ret_send_swarm_control_time = 0;\n    int ret_send_swarm_control_timeout_count = 0;\n    int ret_send_swarm_control_timeout_count_all = 0;\n    int ret_send_swarm_control_timeout_count_all_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check_check_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check_check_check_check_check_check = 0;\n    int ret_send_swarm_control_timeout_count_all_check_check_check_check_check_", "CodeBleu_score": 9.518761479317172}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubT", "CodeBleu_score": 1.2533532734519865}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tprometheus_msgs::MultiBsplines multi_bsplines_msg = *msg;\n    std::vector<prometheus_msgs::Bspline> bsplines = multi_bsplines_msg.bsplines;\n    for (int i = 0; i < bsplines.size(); i++) {\n        prometheus_msgs::Bspline bspline = bsplines[i];\n        int drone_id = bspline.drone_id;\n        if (drone_id == drone_id_) {\n            // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb: drone_id = \" << drone_id << std::endl;\n            Bspline bspline_data;\n            bspline_data.drone_id = drone_id;\n            bspline_data.knots = bspline.knots;\n            bspline_data.ctrl_pts = bspline.ctrl_pts;\n            bspline_data.yaw_pts = bspline.yaw_pts;\n            bspline_data.duration = bspline.duration;\n            bspline_data.start_time = bspline.start_time;\n            bspline_data.end_time = bspline.end_time;\n            bspline_data.dim = bspline.dim;\n            bspline_data.order = bspline.order;\n            bspline_data.dim_full = bspline.dim_full;\n            bspline_data.order_full = bspline.order_full;\n            bspline_data.dim_reduced = bspline.dim_reduced;\n            bspline_data.order_reduced = bspline.order_reduced;\n            bspline_data.dim_reduced_full = bspline.dim_reduced_full;\n            bspline_data.order_reduced_full = bspline.order_reduced_full;\n            bspline_data.dim_reduced_full_full = bspline.dim_reduced_", "CodeBleu_score": 36.56168261538929}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    // std::cout << \"EGOPlannerSwarm::multitrajSubT", "CodeBleu_score": 1.2533532734519865}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}, {"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}, {"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tdouble x = (u - cx_) * depth / fx_;\n  double y = (v - cy_) * depth / fy_;\n  double z = depth;\n  return Eigen::Vector4d(x, y, z, 1.0);\n}", "CodeBleu_score": 51.51124683444102}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.07034331015703}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos_in_cam;\n    pos_in_cam(0) = (u - cx_) * depth / fx_;\n    pos_in_cam(1) = (v - cy_) * depth / fy_;\n    pos_in_cam(2) = depth;\n    pos_in_cam(3) = 1.0;\n    return pos_in_cam;\n}", "CodeBleu_score": 82.65741730877512}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        path.push_back(current->cameFrom);\n        current = current->cameFrom;\n    }\n    return path;\n}", "CodeBleu_score": 82.99039872984793}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n\n    return path;\n}", "CodeBleu_score": 98.26143553100475}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n  path.push_back(current);\n  while (current->cameFrom != NULL) {\n    current = current->cameFrom;\n    path.push_back(current);\n  }\n  return path;\n}", "CodeBleu_score": 95.97280666949473}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tstart_idx = grid_map_->getIndex(start_pt);\n    end_idx = grid_map_->getIndex(end_pt);\n\n    // Check if the start or end point is inside an obstacle.\n    bool start_inside_obstacle = grid_map_->isInsideObstacle(start_idx);\n    bool end_inside_obstacle = grid_map_->isInsideObstacle(end_idx);\n\n    // If both points are inside obstacles, then we can't find a path.\n    if (start_inside_obstacle && end_inside_obstacle) {\n        return false;\n    }\n\n    // If both points are outside obstacles, then we can return true.\n    if (!start_inside_obstacle && !end_inside_obstacle) {\n        return true;\n    }\n\n    // If only one point is inside an obstacle, then we need to adjust the other point.\n    // We need to find the point that is closest to the other point.\n    Vector3d start_pt_adjusted = start_pt;\n    Vector3d end_pt_adjusted = end_pt;\n    double distance_to_start = (start_pt - end_pt).norm();\n    double distance_to_end = (end_pt - start_pt).norm();\n\n    if (start_inside_obstacle) {\n        // Move the end point away from the start point until it is no longer in an obstacle.\n        while (grid_map_->isInsideObstacle(end_idx)) {\n            // Move the end point away from the start point.\n            end_pt_adjusted = end_pt + distance_to_start * (end_pt - start_pt) / distance_to_end;\n            end_idx = grid_map_->getIndex(end_pt_adjusted);\n        }\n    }\n    else {\n        // Move the start point away from the end point until it is no longer in an obstacle.\n        while (grid_map_->isInsideObstacle(start_idx)) {\n            // Move the start point away from the end point.", "CodeBleu_score": 44.378168934696234}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start and end points to grid indices\n  start_idx = grid_map_->GetGridIndex(start_pt);\n  end_idx = grid_map_->GetGridIndex(end_pt);\n\n  // Adjust start and end points if they are inside obstacles\n  if (grid_map_->IsInsideObstacle(start_idx)) {\n    // Adjust start point\n    Vector3d new_start_pt = start_pt;\n    Vector3i new_start_idx = start_idx;\n    while (grid_map_->IsInsideObstacle(new_start_idx)) {\n      // Move start point away from end point\n      new_start_pt = new_start_pt + (new_start_pt - end_pt).normalized();\n      new_start_idx = grid_map_->GetGridIndex(new_start_pt);\n    }\n    start_pt = new_start_pt;\n    start_idx = new_start_idx;\n  }\n  if (grid_map_->IsInsideObstacle(end_idx)) {\n    // Adjust end point\n    Vector3d new_end_pt = end_pt;\n    Vector3i new_end_idx = end_idx;\n    while (grid_map_->IsInsideObstacle(new_end_idx)) {\n      // Move end point away from start point\n      new_end_pt = new_end_pt + (new_end_pt - start_pt).normalized();\n      new_end_idx = grid_map_->GetGridIndex(new_end_pt);\n    }\n    end_pt = new_end_pt;\n    end_idx = new_end_idx;\n  }\n\n  // Check if conversion and adjustment was successful\n  if (grid_map_->IsInsideObstacle(start_idx) || grid_map_->IsInsideObstacle(end_idx)) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 43.35592285955422}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert the start and end points to grid indices\n    grid_map_->getIndex(start_pt, start_idx);\n    grid_map_->getIndex(end_pt, end_idx);\n\n    // Adjust the start and end points if they are inside obstacles\n    if (grid_map_->isValid(start_idx(0), start_idx(1), start_idx(2)) && grid_map_->isObstacle(start_idx(0), start_idx(1), start_idx(2))) {\n        Vector3d adjusted_start_pt = start_pt;\n        Vector3i adjusted_start_idx = start_idx;\n        if (!AdjustPoint(adjusted_start_pt, adjusted_start_idx, end_idx))\n            return false;\n        start_pt = adjusted_start_pt;\n        start_idx = adjusted_start_idx;\n    }\n    if (grid_map_->isValid(end_idx(0), end_idx(1), end_idx(2)) && grid_map_->isObstacle(end_idx(0), end_idx(1), end_idx(2))) {\n        Vector3d adjusted_end_pt = end_pt;\n        Vector3i adjusted_end_idx = end_idx;\n        if (!AdjustPoint(end_pt, adjusted_end_idx, start_idx))\n            return false;\n        end_pt = adjusted_end_pt;\n        end_idx = adjusted_end_idx;\n    }\n\n    // Check if the start and end points are valid grid indices\n    if (!grid_map_->isValid(start_idx(0), start_idx(1), start_idx(2))) {\n        return false;\n    }\n    if (!grid_map_->isValid(end_idx(0), end_idx(1), end_idx(2))) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 39.687480727745495}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t// \u66f4\u65b0\u692d\u5706\u68c0\u6d4b\u7ed3\u679c\n    for (int i = 0; i < msg->infos.size(); i++) {\n        if (msg->infos[i].name == \"T\") {\n            ellipse_det = msg->infos[i];\n            num_regain++;\n            num_lost = 0;\n            if (is_detected == false) {\n                is_detected = true;\n            }\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n    // \u5224\u65ad\u662f\u5426\u4e22\u5931\u76ee\u6807\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    // \u5224\u65ad\u662f\u5426\u68c0\u6d4b\u5230\u76ee\u6807\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    // \u4ea4\u6362\u89c6\u89c9\u68c0\u6d4b\u7ed3\u679c\u4e2d\u7684\u89c6\u89d2\u89d2\u5ea6\n    float temp_angle = ellipse_det.sight_angle[0];\n    ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n    ellipse_det.sight_angle[1] = temp_angle;\n}", "CodeBleu_score": 70.56775685222563}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t// \u66f4\u65b0\u692d\u5706\u68c0\u6d4b\u4fe1\u606f\n    for (int i = 0; i < msg->info.size(); i++) {\n        if (msg->info[i].name == \"T\") {\n            ellipse_det = msg->info[i];\n            num_regain++;\n            num_lost = 0;\n            if (num_regain > VISION_THRES) {\n                is_detected = true;\n            }\n        } else {\n            num_regain = 0;\n            num_lost++;\n            if (num_lost > VISION_THRES) {\n                is_detected = false;\n            }\n        }\n    }\n}", "CodeBleu_score": 57.55881756089342}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n        if (msg->detection_info[i].name == \"T\") {\n            ellipse_det = msg->detection_info[i];\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    if (is_detected) {\n        ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n        ellipse_det.sight_angle[1] = ellipse_det.sight_angle[2];\n        ellipse_det.sight_angle[2] = ellipse_det.sight_angle[0];\n    }\n}", "CodeBleu_score": 73.79406852844521}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tif(in_gazebo_)\n    {\n        return;\n    }\n\n    // Calculate target foot positions for the next timestep\n    base_.setDesiredPose(req_pose_);\n    base_.update();\n\n    // Compute velocity commands for the legs\n    leg_controller_.update(base_);\n\n    // Compute joint positions\n    kinematics_.update(base_);\n\n    // Publish foot contact information\n    if(publish_foot_contacts_)\n    {\n        publishFootContacts();\n    }\n\n    // Publish joint positions\n    if(publish_joint_states_)\n    {\n        publishJointStates();\n    }\n\n    // Publish joint position commands\n    if(publish_joint_control_)\n    {\n        publishJointCommands();\n    }\n}", "CodeBleu_score": 27.56041876749516}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tros::Time now = ros::Time::now();\n    double dt = (now - last_time_).toSec();\n\n    // Calculate target foot positions\n    body_controller_.update(req_pose_, dt);\n\n    // Compute leg command\n    leg_controller_.update(dt);\n\n    // Compute joint command\n    kinematics_.update(leg_controller_.getLegCommands(), dt);\n\n    // Publish joint command\n    if (publish_joint_control_) {\n        publishJointCommands();\n    }\n\n    // Publish foot contact information\n    if (publish_foot_contacts_) {\n        publishFootContacts();\n    }\n\n    // Publish joint states\n    if (publish_joint_states_ && !in_gazebo_) {\n        publishJointStates();\n    }\n\n    last_time_ = now;\n}", "CodeBleu_score": 51.35300300175083}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n  champ::PhaseGenerator::Time time = rosTimeToChampTime(ros::Time::now());\n\n  // Update the body controller\n  body_controller_.update(time, req_pose_);\n\n  // Get the current foot positions\n  std::vector<champ::Point3d> current_foot_positions = base_.getFootPositions();\n\n  // Compute the foot target positions\n  std::vector<champ::Point3d> foot_target_positions = body_controller_.getFootTargetPositions();\n\n  // Compute the foot target velocities\n  std::vector<champ::Point3d> foot_target_velocities = body_controller_.getFootTargetVelocities();\n\n  // Compute the foot target accelerations\n  std::vector<champ::Point3d> foot_target_accelerations = body_controller_.getFootTargetAccelerations();\n\n  // Compute the joint target positions\n  std::vector<double> joint_target_positions = kinematics_.computeJointTargetPositions(foot_target_positions, foot_target_velocities, foot_target_accelerations);\n\n  // Compute the joint target velocities\n  std::vector<double> joint_target_velocities = kinematics_.computeJointTargetVelocities(foot_target_positions, foot_target_velocities, foot_target_accelerations);\n\n  // Compute the joint target accelerations\n  std::vector<double> joint_target_accelerations = kinematics_.computeJointTargetAccelerations(foot_target_positions, foot_target_velocities, foot_target_accelerations);\n\n  // Update the leg controller\n  leg_controller_.update(time, joint_target_positions, joint_target_velocities, joint_target_accelerations);\n\n  // Publish joint commands\n  if (publish_joint_control_) {\n    // Create the joint command message\n    trajectory_msgs::JointTrajectory joint_command;\n    joint_command.header.stamp = ros::Time::now();\n    joint_command", "CodeBleu_score": 40.55531576433234}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\tjoints_msg = Joints()\n    joints_msg.header = joints.header\n    joints_msg.joints = joints.position[0:12]\n    self.joint_minimal_pub.publish(joints_msg)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header = joints.header\n    joint_trajectory.joint_names = self.joint_names\n    joint_trajectory.points = [JointTrajectoryPoint()]\n    joint_trajectory.points[0].positions = joints.position[0:12]\n    joint_trajectory.points[0].time_from_start = rospy.Duration(1.0)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 42.84162388821976}, {"code": "def joints_cmd_callback(self, joints){\n\tJoints joints_minimal = Joints()\n\tjoints_minimal.header = joints.header\n\tjoints_minimal.name = self.joint_names\n\tjoints_minimal.position = joints.position[0:12]\n\tself.joint_minimal_pub.publish(joints_minimal)\n\n\tJointTrajectory joint_trajectory = JointTrajectory()\n\tjoint_trajectory.header = joints.header\n\tjoint_trajectory.joint_names = self.joint_names\n\tJointTrajectoryPoint joint_trajectory_point = JointTrajectoryPoint()\n\tjoint_trajectory_point.positions = joints.position[0:12]\n\tjoint_trajectory_point.time_from_start = rospy.Duration(0.5)\n\tjoint_trajectory.points.append(joint_trajectory_point)\n\tself.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 47.72502445006753}, {"code": "def joints_cmd_callback(self, joints){\n\tjoints_msg = Joints()\n    joints_msg.header = joints.header\n    joints_msg.position = joints.position[0:12]\n    self.joint_minimal_pub.publish(joints_msg)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header = joints.header\n    joint_trajectory.joint_names = self.joint_names\n\n    joint_trajectory_point = JointTrajectoryPoint()\n    joint_trajectory_point.positions = joints.position[0:12]\n    joint_trajectory_point.time_from_start = rospy.Duration(0.05)\n    joint_trajectory.points.append(joint_trajectory_point)\n\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 47.76309801607349}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\tstd::vector<std::string> collisions;\n\t\tboost::split(collisions, _msg->contact(i).collision2(), boost::is_any_of(\"::\"));\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (collisions[collisions.size()-1] == foot_links_[i]) {\n\t\t\t\tfoot_contacts_[i] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 56.65302667092834}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfoot_contacts_[0] = false;\n\tfoot_contacts_[1] = false;\n\tfoot_contacts_[2] = false;\n\tfoot_contacts_[3] = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision_string;\n\t\tboost::split(collision_string, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\t\tif (collision_string[collision_string.size() - 1] == foot_links_[0]) {\n\t\t\tfoot_contacts_[0] = true;\n\t\t} else if (collision_string[collision_string.size() - 1] == foot_links_[1]) {\n\t\t\tfoot_contacts_[1] = true;\n\t\t} else if (collision_string[collision_string.size() - 1] == foot_links_[2]) {\n\t\t\tfoot_contacts_[2] = true;\n\t\t} else if (collision_string[collision_string.size() - 1] == foot_links_[3]) {\n\t\t\tfoot_contacts_[3] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.30288299497481}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision_split;\n\t\tboost::split(collision_split, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\t\tif (std::find(foot_links_.begin(), foot_links_.end(), collision_split[collision_split.size() - 1]) != foot_links_.end()) {\n\t\t\tfoot_contacts_[std::distance(foot_links_.begin(), std::find(foot_links_.begin(), foot_links_.end(), collision_split[collision_split.size() - 1]))] = true;\n\t\t}\n\t}\n\n\tchamp_msgs::ContactsStamped contacts_msg;\n\tcontacts_msg.header.stamp = ros::Time::now();\n\tfor (int i = 0; i < 4; i++) {\n\t\tcontacts_msg.contacts[i] = foot_contacts_[i];\n\t}\n\tcontacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 57.58311231172728}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_ || !controller_active_) {\n    // If the controller is not active, set all rotor velocities to zero.\n    *rotor_velocities = Eigen::VectorXd::Zero(\n        vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration =\n      desired_rotor_thrusts_ * normalized_attitude_gain_;\n  Eigen::Vector3d desired_angular_acceleration =\n      desired_rotor_thrusts_ * normalized_angular_rate_gain_;\n\n  // Project thrust onto the body z-axis and combine with angular acceleration.\n  Eigen::Vector3d desired_acceleration_projected_on_body_z =\n      desired_acceleration.normalized() * desired_acceleration.norm();\n  Eigen::Vector3d desired_acceleration_projected_on_body_xy =\n      desired_acceleration - desired_acceleration_projected_on_body_z;\n  Eigen::Vector4d desired_acceleration_projected_on_body =\n      Eigen::Vector4d(desired_acceleration_projected_on_body_xy(0),\n                      desired_acceleration_projected_on_body_xy(1),\n                      desired_acceleration_projected_on_body_z(2), 0);\n  Eigen::Vector4d desired_acceleration_and_angular_acceleration =\n      desired_acceleration_projected_on_body +\n      Eigen::Vector4d(desired_angular_acceleration(0),\n                      desired_angular_acceleration(1),\n                      desired_angular_acceleration(2), 0);\n\n  // Compute rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ *\n                      desired_acceleration_and_angular", "CodeBleu_score": 42.882459138599785}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\n    ROS_ERROR(\"LeePositionController: CalculateRotorVelocities: Parameters not initialized.\");\n    return;\n  }\n\n  if (!controller_active_) {\n    // If the controller is not active, set all rotor velocities to zero.\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  Eigen::Vector3d desired_acceleration = Eigen::Vector3d::Zero();\n  Eigen::Vector3d desired_angular_acceleration = Eigen::Vector3d::Zero();\n  CalculateDesiredAcceleration(&desired_acceleration);\n  CalculateDesiredAngularAcceleration(&desired_angular_acceleration);\n\n  Eigen::Vector3d thrust_projected_on_body_z_axis = desired_acceleration.z() * vehicle_parameters_.rotor_configuration_.body_z_axis;\n  Eigen::Vector3d desired_angular_acceleration_projected_on_body_z_axis = desired_angular_acceleration.z() * vehicle_parameters_.rotor_configuration_.body_z_axis;\n  Eigen::Vector3d desired_acceleration_and_angular_acceleration_projected_on_body_z_axis = thrust_projected_on_body_z_axis + desired_angular_acceleration_projected_on_body_z_axis;\n\n  Eigen::VectorXd desired_rotor_accelerations = angular_acc_to_rotor_velocities_ * desired_acceleration_and_angular_acceleration_projected_on_body_z_axis;\n  *rotor_velocities = desired_rotor_accelerations.array().max(0.0).matrix().array().sqrt().matrix();\n}", "CodeBleu_score": 46.226589693195294}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_ || !controller_active_) {\n    // If the controller is not active, set all rotor velocities to zero.\n    *rotor_velocities = Eigen::VectorXd::Zero(\n        vehicle_parameters_.rotor_configuration_.rotors.size());\n  } else {\n    // Calculate desired acceleration and angular acceleration.\n    Eigen::Vector3d desired_acceleration =\n        desired_state_.thrust -\n        vehicle_parameters_.rotor_configuration_.center_of_mass.cross(\n            desired_state_.angular_momentum);\n    Eigen::Vector3d desired_angular_acceleration =\n        desired_state_.moment -\n        vehicle_parameters_.rotor_configuration_.center_of_mass.cross(\n            desired_state_.angular_acceleration);\n    // Project thrust onto the body z-axis.\n    Eigen::Vector3d thrust_body =\n        desired_state_.thrust -\n        vehicle_parameters_.rotor_configuration_.center_of_mass.cross(\n            desired_state_.angular_momentum);\n    // Combine angular acceleration and thrust into a single vector.\n    Eigen::Vector4d desired_acceleration_and_thrust;\n    desired_acceleration_and_thrust << desired_acceleration, thrust_body.z();\n    // Calculate rotor velocities.\n    *rotor_velocities = angular_acc_to_rotor_velocities_ *\n                        (normalized_attitude_gain_ * desired_acceleration +\n                         normalized_angular_rate_gain_ *\n                             desired_angular_acceleration +\n                         normalized_angular_rate_gain_ *\n                             vehicle_parameters_.rotor_configuration_.rotors.size() *\n                             controller_parameters_.angular_rate_gain_.transpose() *\n                             desired_acceleration_and_thrust);\n    // Ensure non-negative values.\n    for (int i = 0; i < rotor_velocities->size(); ++i) {\n      (*rotor_veloc", "CodeBleu_score": 39.986878468473066}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_rate;\n  Eigen::Vector3d desired_angular_acceleration;\n\n  // Calculate the position error, and the desired acceleration.", "CodeBleu_score": 16.456221536002545}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n\n  Eigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position_W;\n  Eigen::Vector3d velocity_error = odometry_.linear_velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d desired_linear_acceleration =\n      controller_parameters_.position_gain_ * position_error +\n      controller_parameters_.velocity_gain_ * velocity_error;\n\n  // Add gravity to the desired linear acceleration.\nThis is done by incorporating the mass of the vehicle and gravity.\nThe acceleration due to gravity is: g = 9.81 m/s^2\n\n  desired_linear_acceleration +=\n      vehicle_parameters_.mass_ * controller_parameters_.gravity_ -\n      vehicle_parameters_.mass_ * odometry_.linear_acceleration_W;\n\n  // Add the commanded acceleration to the desired linear acceleration.\nThis is done by incorporating the mass of the vehicle.\n\n  desired_linear_acceleration +=\n      vehicle_parameters_.mass_ * command_trajectory_.acceleration_W;\n\n  // Transform the desired linear acceleration from the body frame to the world frame.\n\n  *acceleration = odometry_.orientation.toRotationMatrix() * desired_linear_acceleration;\n}", "CodeBleu_score": 50.25951248599334}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n\n  // Get the position error in the world frame.\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\n  // Get the velocity error in the world frame.\n  Eigen::Vector3d velocity_error = odometry_.orientation.toRotationMatrix()\n      * odometry_.velocity - command_trajectory_.velocity;\n\n  // Compute the desired acceleration by incorporating position and velocity gains,\n  // adjusting for vehicle mass, gravity, and the commanded acceleration.\n  *acceleration = position_error * controller_parameters_.position_gain_\n      + velocity_error * controller_parameters_.velocity_gain_\n      + command_trajectory_.acceleration\n      + Eigen::Vector3d(0, 0, -vehicle_parameters_.mass_ * controller_parameters_.gravity_);\n}", "CodeBleu_score": 48.87307464427671}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(initialized_params_);\n  assert(rotor_velocities->size() == amount_rotors_);\n\n  // Calculate desired angular acceleration\n  Eigen::Vector3d desired_angular_acceleration =\n      gain_attitude_ * (desired_attitude_ - current_attitude_);\n\n  // Calculate desired angular velocity\n  Eigen::Vector3d desired_angular_velocity =\n      desired_angular_acceleration / inertia_matrix_;\n\n  // Calculate desired thrust\n  Eigen::Vector4d desired_thrust;\n  desired_thrust << desired_angular_velocity(0), desired_angular_velocity(1),\n      desired_angular_velocity(2), thrust_reference_;\n\n  // Combine desired thrust and angular acceleration\n  Eigen::Vector4d desired_acceleration =\n      gain_angular_rate_ * desired_angular_velocity\n      + angular_acc_to_rotor_velocities_ * desired_thrust;\n\n  // Ensure desired acceleration is at least one\n  desired_acceleration = desired_acceleration.cwiseMax(Eigen::Vector4d::Ones());\n\n  // Compute rotor velocities\n  *rotor_velocities = allocation_matrix_ * desired_acceleration.array().sqrt();\n}", "CodeBleu_score": 47.47330165642485}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t// Ensure that the parameters are initialized.\n  if (!initialized_params_) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: parameters \"\n              << \"not initialized yet.\n\";\n    return;\n  }\n  // Ensure that the input is valid.\n  if (rotor_velocities == NULL) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: invalid \"\n              << \"input.\n\";\n    return;\n  }\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(amount_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      gain_attitude_ * desired_angular_acceleration_ +\n      gain_angular_rate_ * desired_angular_rate_;\n\n  // Calculate the thrust reference.\n  Eigen::Vector4d thrust_reference =\n      Eigen::Vector4d(desired_angular_acceleration(0),\n                      desired_angular_acceleration(1),\n                      desired_angular_acceleration(2), 0);\n\n  // Combine the thrust reference with the desired angular acceleration.\n  Eigen::VectorXd desired_acceleration =\n      thrust_reference + angular_acc_to_rotor_velocities_ * thrust_reference;\n\n  // Calculate the rotor velocities.\n  *rotor_velocities = allocation_matrix_ * desired_acceleration;\n  for (int i = 0; i < amount_rotors_; ++i) {\n    if (rotor_velocities->coeff(i) < 0.0) {\n      rotor_velocities->coeffRef(i) = 0.0;\n    }\n  }\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 47.50378357055491}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(initialized_params_);\n  assert(rotor_velocities->size() == 0);\n  assert(rotor_velocities->size() == amount_rotors_);\n\n  // Desired angular acceleration\n  Eigen::Vector3d desired_angular_acceleration =\n      gain_attitude_ * (desired_attitude_ - current_attitude_);\n  desired_angular_acceleration.z() += gravity_;\n\n  // Desired angular rate\n  Eigen::Vector3d desired_angular_rate =\n      gain_angular_rate_ * (desired_angular_rate_ - current_angular_rate_);\n\n  // Desired thrust\n  Eigen::Vector3d desired_thrust =\n      desired_thrust_ - mass_ * gravity_ * Eigen::Vector3d::UnitZ();\n\n  // Desired acceleration\n  Eigen::Vector4d desired_acceleration;\n  desired_acceleration << desired_angular_acceleration, desired_thrust;\n\n  // Desired acceleration in body frame\n  Eigen::Vector4d desired_acceleration_in_body_frame =\n      desired_acceleration +\n      Eigen::Vector4d(0, 0, current_angular_rate_.z(), 0) *\n          Eigen::Vector4d(0, 0, 0, 1);\n\n  // Desired acceleration in body frame\n  Eigen::Vector4d desired_acceleration_in_body_frame =\n      desired_acceleration +\n      Eigen::Vector4d(0, 0, current_angular_rate_.z(), 0) *\n          Eigen::Vector4d(0, 0, 0, 1);\n\n  // Desired acceleration in body frame\n  Eigen::Vector4d desired_acceleration_in_body_frame =\n      desired_acceleration +\n      Eigen::Vector4d(0, 0, current_angular_rate_.z(), 0) *\n          Eigen::Vector4d(0, 0, 0,", "CodeBleu_score": 36.71947200919039}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t# find the indices for the start and end times\n    start_index = numpy.argmin(abs(self.time - start_time))\n    end_index = numpy.argmin(abs(self.time - end_time))\n\n    # make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # update each attribute of the copied object to contain only the sliced data\n    for attribute in sliced_object.__dict__.keys():\n        sliced_object.__dict__[attribute] = self.__dict__[attribute][start_index:end_index + 1]\n\n    return sliced_object\n\n", "CodeBleu_score": 34.84208297859697}, {"code": "def slice(self, start_time, end_time)\n\t# Find the indices for the start and end times\n    start_index = numpy.where(self.time >= start_time)[0][0]\n    end_index = numpy.where(self.time <= end_time)[0][-1]\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    for attribute in sliced_object.__dict__.keys():\n        sliced_object.__dict__[attribute] = sliced_object.__dict__[attribute][start_index:end_index + 1]\n\n    return sliced_object\n\n", "CodeBleu_score": 34.50567454068961}, {"code": "def slice(self, start_time, end_time)\n\t# Find the indices for the start and end times\n    start_index = numpy.where(self.time >= start_time)[0][0]\n    end_index = numpy.where(self.time <= end_time)[0][-1]\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n    # Slice the attributes of the copied object\n    sliced_object.time = self.time[start_index:end_index + 1]\n    sliced_object.bag_time = self.bag_time[start_index:end_index + 1]\n    return sliced_object\n\n", "CodeBleu_score": 24.433200271235172}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    quat = [rotation.x, rotation.y, rotation.z, rotation.w]\n    euler = tf.transformations.euler_from_quaternion(quat)\n    yaw = euler[2]\n\n    # Create Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the waypoint is different from the last one\n    if self.empty:\n        self.empty = False\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n        self.append_yaw(yaw)\n    elif (self.x[-1] != point.x or self.y[-1] != point.y or self.z[-1] != point.z or self.yaw[-1] != yaw):\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n        self.append_yaw(yaw)\n\n", "CodeBleu_score": 34.81375383579017}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Get the position from the waypoint message\n    position = waypoint_msg.pose.position\n    # Get the rotation from the waypoint message\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the waypoint is different from the last one\n    if self.empty:\n        self.empty = False\n    else:\n        # If the position and yaw are the same, don't append the waypoint\n        if (self.last_point == point) and (self.last_yaw == euler[2]):\n            return\n    # Append the point, yaw, and corresponding times to their respective arrays\n    self.append_point(point, msg_time, bag_time)\n    self.yaw = numpy.append(self.yaw, euler[2])\n    self.last_point = point\n    self.last_yaw = euler[2]\n\n", "CodeBleu_score": 27.1052531634954}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Extract the position and rotation from the waypoint message.\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation from a Quaternion to Euler angles.\n    quat_to_euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object from the position.\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one.\n    if self.empty:\n        # If the waypoint list is empty, it is always different.\n        self.empty = False\n        self.append_point(point)\n        self.append_yaw(quat_to_euler[2])\n        self.append_times(msg_time, bag_time)\n    else:\n        # Compare the position and yaw values.\n        if (numpy.array_equal(self.x[-1], point.x) and numpy.array_equal(self.y[-1], point.y) and numpy.array_equal(self.z[-1], point.z) and numpy.array_equal(self.yaw[-1], quat_to_euler[2])):\n            # If the waypoint is the same, do nothing.\n            pass\n        else:\n            # If the waypoint is different, append it.\n            self.append_point(point)\n            self.append_yaw(quat_to_euler[2])\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 33.17099212717209}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 24.627178874169726}, {"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 24.627178874169726}, {"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 24.627178874169726}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 19.71800647003772}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 19.71800647003772}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 19.71800647003772}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n  Eigen::VectorXf rms_noise_values =\n      Eigen::VectorXf::Ones(width * height) * this->rms_noise;\n  Eigen::VectorXf noise_values =\n      Eigen::VectorXf::Ones(width * height) * this->noise;\n  // Apply noise to depth data\n  for (int i = 0; i < width * height; i++) {\n    if (this->InRange(depth_data(i))) {\n      depth_data(i) += noise_values(i) * rms_noise_values(i);\n    } else {\n      depth_data(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 48.37085356155027}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n  // Calculate the multiplier based on the camera parameters\n  const float multiplier = 1.0f / (this->max_depth - this->min_depth);\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n  // Compute the RMS noise\n  const float rms_noise =\n      sqrt(2 * this->noise_std_dev * this->noise_std_dev);\n  // Compute the noise values\n  const float noise_low = this->min_depth - rms_noise;\n  const float noise_high = this->max_depth + rms_noise;\n  // For each pixel, add noise if the pixel value is in range, otherwise set the\n  // pixel to a bad point value\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vec(i))) {\n      data_vec(i) += multiplier * this->noise_mean;\n    } else {\n      data_vec(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 45.36653120974393}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n\n  // Calculate multiplier\n  const float multiplier =\n      this->GetMultiplier(width, height, this->focal_length, this->fov,\n                          this->horizontal_fov, this->vertical_fov);\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute RMS noise\n  const float rms_noise = this->rms_noise_ * multiplier;\n\n  // Compute noise values\n  const float noise_min = this->min_depth + rms_noise;\n  const float noise_max = this->max_depth - rms_noise;\n\n  // Add noise to each pixel\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data_vec[i])) {\n      data_vec[i] += rms_noise * (2.0 * this->gazebo::math::Rand::GetDblUniform() - 1.0);\n    } else {\n      data_vec[i] = this->bad_point_value;\n    }\n\n    // Clamp data to noise min and max\n    data_vec[i] = std::max(data_vec[i], noise_min);\n    data_vec[i] = std::min(data_vec[i], noise_max);\n  }\n}", "CodeBleu_score": 56.23700439456465}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}, {"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}, {"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (this->loop) {\n    this->timePos = fmod(_time, this->length);\n  }\n  else {\n    this->timePos = std::min(std::max(_time, 0.0), this->length);\n  }\n}", "CodeBleu_score": 42.061245451394704}, {"code": "void Animation::SetTime(double _time){\n\tif (this->loop) {\n    this->timePos = fmod(_time, this->length);\n  }\n  else {\n    this->timePos = std::min(_time, this->length);\n    this->timePos = std::max(this->timePos, 0.0);\n  }\n}", "CodeBleu_score": 44.925604050078526}, {"code": "void Animation::SetTime(double _time){\n\tif (this->loop) {\n    this->timePos = fmod(_time, this->length);\n  } else {\n    this->timePos = std::min(this->length, std::max(0.0, _time));\n  }\n\n  if (this->build) {\n    this->UpdateKeyFrames();\n  }\n}", "CodeBleu_score": 45.31402219861228}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}, {"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}, {"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}, {"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}, {"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}, {"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}, {"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}, {"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}, {"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}, {"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}, {"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 58.5840225418091}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 58.5840225418091}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 58.5840225418091}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}, {"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}, {"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}, {"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}, {"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t# Create an empty matrix for the distance between UAVs.\n    self.adj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    # Loop through the original formation.\n    for i in range(0, self.uav_num - 1):\n        # Loop through the changed formation.\n        for j in range(0, self.uav_num - 1):\n            # Calculate the Euclidean distance between UAVs.\n            distance = numpy.linalg.norm(\n                numpy.array(orig_formation[i]) - numpy.array(change_formation[j])\n            )\n            # Adjust the distance and convert it to an integer.\n            self.adj_matrix[i, j] = int(50 - distance)\n    return self.adj_matrix\n\n", "CodeBleu_score": 30.10911885367235}, {"code": "def build_graph(self, orig_formation, change_formation)\n\tadj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            if i != j:\n                # Calculate the distance between the UAVs in the original formation.\n\n                x_dist = orig_formation[i][0] - orig_formation[j][0]\n                y_dist = orig_formation[i][1] - orig_formation[j][1]\n                z_dist = orig_formation[i][2] - orig_formation[j][2]\n                dist_orig = numpy.sqrt(x_dist ** 2 + y_dist ** 2 + z_dist ** 2)\n                # Calculate the distance between the UAVs in the changed formation.\n\n                x_dist = change_formation[i][0] - change_formation[j][0]\n                y_dist = change_formation[i][1] - change_formation[j][1]\n                z_dist = change_formation[i][2] - change_formation[j][2]\n                dist_change = numpy.sqrt(x_dist ** 2 + y_dist ** 2 + z_dist ** 2)\n                # Subtract the distances from 50 and convert them to integers.\n\n                adj_matrix[i][j] = int(50 - dist_orig) - int(50 - dist_change)\n    return adj_matrix\n\n", "CodeBleu_score": 34.55823031904083}, {"code": "def build_graph(self, orig_formation, change_formation)\n\tadj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            if i == j:\n                adj_matrix[i, j] = 0\n            else:\n                x_diff = orig_formation[i][0] - change_formation[j][0]\n                y_diff = orig_formation[i][1] - change_formation[j][1]\n                z_diff = orig_formation[i][2] - change_formation[j][2]\n                adj_matrix[i, j] = int(50 - numpy.sqrt(x_diff ** 2 + y_diff ** 2 + z_diff ** 2))\n    return adj_matrix\n\n", "CodeBleu_score": 36.88456161568966}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 1:\n            continue\n        gap = self.label_left[i] - self.label_right[j]\n        if gap == 0:\n            self.visit_right[j] = 1\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                self.match_left[i] = j\n                return True\n        if self.slack_right[j] > gap:\n            self.slack_right[j] = gap\n    return False\n\n", "CodeBleu_score": 50.312200326292825}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] - self.label_right[j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or find_path(self, self.match_right[j]):\n                    self.match_right[j] = i\n                    self.match_left[i] = j\n                    return True\n            elif gap < self.slack_right[j]:\n                self.slack_right[j] = gap\n    return False\n\n", "CodeBleu_score": 43.56594025696962}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] - self.label_right[j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or find_path(self, self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 47.60648463632037}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\tfor i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        self.match_right = numpy.array([-1] * (self.uav_num - 1))\n        while True:\n            if self.find_path(i):\n                break\n            else:\n                self.label_left[self.slack_right.argmin()] += 1\n                self.label_right[self.slack_right.argmin()] -= 1\n                self.visit_left = numpy.array([0] * (self.uav_num - 1))\n                self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    return self.match_right\n\n", "CodeBleu_score": 47.87939802059377}, {"code": "def KM(self)\n\tself.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))  # init match for the right set\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))  # init visit for the left set\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))  # init visit for the right set\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))  # init slack for the right set\n    for i in range(self.uav_num - 1):\n        self.visit_left[i] = True\n        self.visit_right[i] = True\n        self.slack_right[i] = 0\n    while True:\n        for i in range(self.uav_num - 1):\n            if not self.visit_left[i]:\n                continue\n            for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n                if not self.visit_right[j]:\n                    continue\n                gap = self.label_left[i] + self.label_right[j] - match_weight\n                if gap == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        self.visit_left[i] = False\n                        self.visit_right[j] = False\n                        break\n                else:\n                    self.slack_right[j] = min(gap, self.slack_right[j])\n        if not numpy.any(self.visit_left):", "CodeBleu_score": 39.870633234016466}, {"code": "def KM(self)\n\twhile True:\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        self.match_right = numpy.array([-1] * (self.uav_num - 1))\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        for i in range(self.uav_num - 1):\n            self.visit_right[i] = False\n        for i in range(self.uav_num - 1):\n            if self.visit_left[i]:\n                continue\n            self.visit_left[i] = True\n            for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n                if self.visit_right[j]:\n                    continue\n                gap = self.label_left[i] + self.label_right[j] - match_weight\n                if gap == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                else:\n                    self.slack_right[j] = min(gap, self.slack_right[j])\n        if all(self.visit_right):\n            break\n        else:\n            min_slack_right = numpy.argmin(self.slack_right)\n            self.label_right += self.slack_right\n            self.label_left += self.slack_right[min_slack_right]\n            self.slack_right = numpy.array([100] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))", "CodeBleu_score": 46.50352266138649}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.299115066160905}, {"code": "def yellow_dectection(image)\n\t# Convert to HSV color space and extract the V channel\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.14795030481221}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}]}
