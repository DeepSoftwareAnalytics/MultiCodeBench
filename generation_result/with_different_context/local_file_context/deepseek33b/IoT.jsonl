{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc && (desc->bDescriptorType != desc_id)) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tle16_to_cpu(desc->bLength));\n\t}\n\treturn desc;\n}", "CodeBleu_score": 30.50553010712217}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc != udc_get_eof_conf()) {\n\t\tuint8_t *next_desc = (uint8_t *) desc + le16_to_cpu(desc->bLength);\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) next_desc;\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 38.65566688174881}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile ((desc != udc_get_eof_conf()) && (desc->bDescriptorType != desc_id)) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *) desc + le16_to_cpu(desc->bLength));\n\t}\n\treturn (desc != udc_get_eof_conf()) ? desc : NULL;\n}", "CodeBleu_score": 32.68662610495103}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    usb_conf_desc_t UDC_DESC_STORAGE *desc;\n    usb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\n    // Check if there is a valid configuration\n    if (NULL == udc_ptr_conf) {\n        return false;\n    }\n\n    // Check if the interface number is within bounds\n    if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n        return false;\n    }\n\n    // Iterate through the descriptors, starting from the beginning of the configuration descriptor\n    desc = (UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_conf->desc;\n    while (true) {\n        // Check if the current descriptor is an interface descriptor\n        if (USB_DT_INTERFACE == desc->bDescriptorType) {\n            // Cast the descriptor to an interface descriptor\n            iface_desc = (UDC_DESC_STORAGE usb_iface_desc_t *) desc;\n\n            // Check if the interface number and setting number match the desired values\n            if (iface_num == iface_desc->bInterfaceNumber && setting_num == iface_desc->bAlternateSetting) {\n                // If the interface number and setting number match, update the udc_ptr_iface pointer\n                udc_ptr_iface = iface_desc;\n                return true;\n            }\n        }\n\n        // Move to the next descriptor\n        desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc + desc->bLength);\n\n        // Check if the end of the configuration descriptor has been reached\n        if (udc_get_eof_conf() == desc) {\n            break;\n        }\n    }\n\n    // If the desired interface descriptor was not found, return false\n    return false;\n}", "CodeBleu_score": 63.15136712373261}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    usb_conf_desc_t UDC_DESC_STORAGE *ptr_desc;\n    usb_iface_desc_t UDC_DESC_STORAGE *ptr_iface;\n\n    // Check if there is a valid configuration\n    if (NULL == udc_ptr_conf) {\n        return false;\n    }\n\n    // Check if the interface number is within bounds\n    if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n        return false;\n    }\n\n    // Iterate through the descriptors in the configuration descriptor\n    ptr_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_conf->desc;\n    while (true) {\n        // Check if the current descriptor is an interface descriptor\n        if (USB_DT_INTERFACE == ptr_desc->bDescriptorType) {\n            // Cast the descriptor to an interface descriptor\n            ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ptr_desc;\n\n            // Check if the interface number and setting number match the specified values\n            if ((iface_num == ptr_iface->bInterfaceNumber) && (setting_num == ptr_iface->bAlternateSetting)) {\n                // Update the internal pointer to the interface descriptor\n                udc_ptr_iface = ptr_iface;\n                return true;\n            }\n        }\n\n        // Move to the next descriptor\n        ptr_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) ptr_desc + ptr_desc->bLength);\n\n        // Check if we have reached the end of the configuration descriptor\n        if (udc_get_eof_conf() == ptr_desc) {\n            break;\n        }\n    }\n\n    // If we have reached here, the interface descriptor was not found\n    return false;\n}", "CodeBleu_score": 65.79861487632893}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udd_g_ctrlreq.req.wLength != sizeof(udc_endpoint_status)) {\n        return false;\n    }\n\n    udc_endpoint_status = udd_ep_is_halted(udd_g_ctrlreq.req.wIndex & 0x7F) ? 1 : 0;\n\n    udd_set_setup_payload( (uint8_t *) & udc_endpoint_status, sizeof(udc_endpoint_status));\n    return true;\n}", "CodeBleu_score": 70.42869646886699}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udd_g_ctrlreq.req.wLength != sizeof(udc_endpoint_status)) {\n        return false;\n    }\n\n    udc_endpoint_status = (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex & 0x0F)) ?\n                           CPU_TO_LE16(USB_EP_STATUS_HALTED) :\n                           CPU_TO_LE16(0);\n\n    udd_set_setup_payload((uint8_t *) &udc_endpoint_status,\n                           sizeof(udc_endpoint_status));\n    return true;\n}", "CodeBleu_score": 59.46496240564139}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    // Check if the request length matches the size of the endpoint status variable\n    if (udd_g_ctrlreq.req.wLength != sizeof(udd_ep_status_t)) {\n        return false;\n    }\n\n    // Determine the status of the specified endpoint\n    udd_ep_status_t status = 0;\n    if (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n        status = UDD_EP_STATUS_HALTED;\n    }\n\n    // Set up the response payload with the endpoint status\n    udd_set_setup_payload((uint8_t *)&status, sizeof(udd_ep_status_t));\n    return true;\n}", "CodeBleu_score": 58.421740293344214}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\n\tif (udc_num_configuration == 0) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Select first alternate setting of the interface to update udc_ptr_iface\n\t// before call iface->setup()\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Forward request to UDI\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\treturn udi_api->setup(&udd_g_ctrlreq);\n}", "CodeBleu_score": 58.24814098271895}, {"code": "static bool udc_req_iface(void){\n\t    uint8_t iface_num;\n    udi_api_t UDC_DESC_STORAGE *udi_api;\n\n    if (!udc_num_configuration) {\n        return false; // The device is not is configured state yet\n    }\n\n    // Check the interface number included in the request\n    iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n    if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n        return false;\n    }\n\n    // Select first alternate setting of the interface to update udc_ptr_iface\n    // before call iface->setup()\n    if (!udc_update_iface_desc(iface_num, 0)) {\n        return false;\n    }\n\n    // Forward the SETUP request to the corresponding UDI handler\n    udi_api = udc_ptr_conf->udi_apis[iface_num];\n    return udi_api->setup(udd_g_ctrlreq.req.bRequest, udd_g_ctrlreq.req.wValue, udd_g_ctrlreq.req.wIndex, udd_g_ctrlreq.req.wLength);\n}", "CodeBleu_score": 63.11246887170191}, {"code": "static bool udc_req_iface(void){\n\t    uint8_t iface_num;\n    udi_api_t UDC_DESC_STORAGE *udi_api;\n\n    if (!udc_num_configuration) {\n        return false; // The device is not is configured state yet\n    }\n\n    // Check the interface number included in the request\n    iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n    if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n        return false;\n    }\n\n    // Select first alternate setting of the interface to update udc_ptr_iface\n    // before call iface->setup()\n    if (!udc_update_iface_desc(iface_num, 0)) {\n        return false;\n    }\n\n    // Update alternate setting of the interface\n    if (!udc_update_iface_desc(iface_num, udc_iface_setting)) {\n        return false;\n    }\n\n    // Forward the SETUP request to the corresponding UDI handler\n    udi_api = udc_ptr_conf->udi_apis[iface_num];\n    return udi_api->setup(udd_g_ctrlreq.req.bRequest, udd_g_ctrlreq.req.wValue,\n                          udd_g_ctrlreq.req.wIndex, udd_g_ctrlreq.req.wLength,\n                          udd_g_ctrlreq.req.bmRequestType);\n}", "CodeBleu_score": 72.36412661410583}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t  /* Initialize MSC interface */\n  udi_msc_init();\n\n  /* Check if there is a medium on each LUN */\n  if (!udi_msc_cbw_wait()) {\n    return false;\n  }\n\n  /* Enable MSC interface */\n  if (!udi_msc_enable_interface()) {\n    return false;\n  }\n\n  /* Wait for CBW reception */\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 15.045188217398794}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t    if (!udi_msc_external_enable()) {\n        return false;\n    }\n    udi_msc_cbw_received(UDD_EP_TRANSFER_ABORT, 0, UDI_MSC_EP_OUT);\n    return true;\n}", "CodeBleu_score": 11.056912763942499}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  UNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 94.65050514592977}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  UNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 94.65050514592977}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  UNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 94.65050514592977}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, then stall the next request from the USB host\n  if (udi_msc_csw.dCSWDataResidue) {\n    if (udi_msc_csw.bmCSWFlags & USB_CSW_DIRECTION_IN) {\n      udd_ep_wait_stall_set(UDI_MSC_EP_OUT, udi_msc_csw_process);\n    } else {\n      udd_ep_wait_stall_set(UDI_MSC_EP_IN, udi_msc_csw_process);\n    }\n  }\n  // Prepare CSW\n  udi_msc_csw.dCSWSignature = CPU_TO_BE32(USB_CSW_SIGNATURE);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw.bmCSWFlags = udi_msc_csw.bmCSWFlags & USB_CSW_DIRECTION_IN;\n  // Send CSW\n  if (!udd_ep_run(UDI_MSC_EP_OUT, true, (uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw), udi_msc_csw_sent)) {\n    // If endpoint not available, then exit process command\n    udi_msc_sense_fail_hardware();\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 55.90562688283691}, {"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, then stall next request from host\n  if (udi_msc_csw.dCSWDataResidue) {\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n      // Stall IN endpoint\n      udd_ep_stall(UDI_MSC_EP_IN);\n    } else {\n      // Stall OUT endpoint\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  // Send CSW\n  if (!udd_ep_run(UDI_MSC_EP_OUT, true, (uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw), udi_msc_csw_sent)) {\n    // If endpoint not available, then exit process command\n    udi_msc_sense_fail_hardware();\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 66.68296870982357}, {"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, then stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n  if (udi_msc_csw.dCSWDataResidue) {\n    // If CBW is for IN, then stall OUT endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      // Else, stall IN endpoint\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n\n  // Prepare CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.bmCSWStatus = CPU_TO_LE16(udi_msc_csw.bmCSWStatus);\n  udi_msc_csw.dCSWDataResidue = le32_to_cpu(udi_msc_csw.dCSWDataResidue);\n\n  // Send CSW\n  if (!udd_ep_run(UDI_MSC_EP_IN, false, (uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw), udi_msc_csw_sent)) {\n    // If endpoint not available, then exit process command\n    return;\n  }\n}", "CodeBleu_score": 61.67023611833194}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  UNUSED(port);\n  main_b_dtr_active = b_enable;\n  if (dwDTERate == 1200 && !b_enable) {\n    // Schedule a delayed system reset\n    REG_WDT_MR = WDT_MR_WDRSTEN | WDT_MR_WDRSTT(1000);\n  } else {\n    // Cancel any scheduled reset\n    REG_WDT_MR = WDT_MR_WDRSTEN | WDT_MR_WDRSTT(0);\n  }\n}", "CodeBleu_score": 48.204916435230224}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  UNUSED(port);\n  main_b_dtr_active = b_enable;\n\n  if (dwDTERate == 1200 && !b_enable) {\n    // Schedule a delayed system reset\n    REG_WDT_MR = WDT_MR_WDRSTEN | WDT_MR_WDV(2000);\n    REG_WDT_CR = WDT_CR_WDRSTT | WDT_CR_KEY(0xA5);\n  } else {\n    // Cancel any scheduled reset\n    REG_WDT_MR = 0;\n    REG_WDT_CR = WDT_CR_KEY(0xA5);\n  }\n}", "CodeBleu_score": 46.82189937651653}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  UNUSED(port);\n  // Update DTR status\n  main_b_dtr_active = b_enable;\n  // Check if rate is 1200\n  if (dwDTERate == 1200) {\n    // If DTR signal is disabled, schedule a delayed system reset\n    if (!b_enable) {\n      // Write to reset controller to initiate reset\n      REG_RSTC_RSTC_MR = RSTC_RSTC_MR_KEY(0xA5) | RSTC_RSTC_MR_SRC_SYS | RSTC_RSTC_MR_URSTEN;\n      // Call \"initiateReset\" to initiate the reset\n      initiateReset();\n    }\n    // If DTR signal is enabled, cancel any scheduled reset\n    else {\n      // Call \"cancelReset\" to cancel the scheduled reset\n      cancelReset();\n    }\n  }\n}", "CodeBleu_score": 63.44790690065831}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n\n  for (uint16_t cnt = 0; cnt < nbyte; cnt++) {\n    // wait for transmission register empty\n    WHILE_TX(0);\n    // write dummy byte with address and end transmission flag\n    SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n    // wait for received register full\n    WHILE_RX(0);\n    // get received byte\n    buf[cnt] = SPI0->SPI_RDR;\n  }\n\n  // wait for transmission register empty\n  WHILE_TX(0);\n  // read last byte\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 61.471090140766414}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n\n  for (uint16_t cnt = 0; cnt < nbyte; cnt++) {\n    // write dummy byte with address and end transmission flag\n    SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n    while ((SPI0->SPI_SR & SPI_SR_TDRE) == 0);\n    while ((SPI0->SPI_SR & SPI_SR_RDRF) == 0);\n\n    //DELAY_US(1U);\n    buf[cnt] = SPI0->SPI_RDR;\n  }\n\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 57.823444556187134}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) return;\n\n  for (uint16_t cnt = 0; cnt < nbyte; cnt++) {\n    // write dummy byte with address and end transmission flag\n    SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n    WHILE_TX(0);\n    WHILE_RX(0);\n\n    buf[cnt] = SPI0->SPI_RDR;\n  }\n\n  buf[nbyte] = spiRec();\n}", "CodeBleu_score": 69.06694601460556}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  // Get the address of the relocated interrupt vector table\n  pfnISR_Handler* relocated_table = get_relocated_table_addr();\n\n  // Disable global interrupts to ensure atomic operation\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  pfnISR_Handler oldHandler = relocated_table[irq + 16];\n\n  // Replace the current handler with the new handler\n  relocated_table[irq + 16] = newHandler;\n\n  // Re-enable interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 85.14532954200112}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  // Get the address of the relocated interrupt vector table\n  pfnISR_Handler* const ramtab = get_relocated_table_addr();\n\n  // Disable global interrupts\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  pfnISR_Handler oldHandler = ramtab[irq + 16];\n\n  // Replace it with the new handler\n  ramtab[irq + 16] = newHandler;\n\n  // Re-enable interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 82.4992007446654}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  // Get the address of the relocated interrupt vector table\n  pfnISR_Handler* isrtab = get_relocated_table_addr();\n\n  // Disable global interrupts to ensure atomic operation\n  CRITICAL_SECTION_START();\n\n  // Get the current handler for the specified IRQ\n  pfnISR_Handler oldHandler = isrtab[irq + 16];\n\n  // Replace it with the new handler\n  isrtab[irq + 16] = newHandler;\n\n  // Re-enable interrupts\n  CRITICAL_SECTION_END();\n\n  // Return the original ISR handler\n  return oldHandler;\n}", "CodeBleu_score": 96.0473683554555}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n    int c = udi_cdc_getc();\n    if (c != -1) {\n      if (pending_char == -1) {\n        if (ECHO_MARLINDBG) {\n          if (c != '\\r' && c != '\n') {\n            SERIAL_ECHO_START();\n            SERIAL_ECHOLNPAIR(\\\"ECHO: \\\", (char)c);\n          }\n        }\n        if (parser.seen('M')) {\n          if (parser.seen('112')) {\n            SERIAL_ECHO_START();\n            SERIAL_ECHOPGM(\\\"ECHO: !!!EMERGENCY_PARSER!!!\\\");\n            SERIAL_ECHO_END();\n            SERIAL_ECHOLNPGM(\\\" (to disable, M110 S0)\\\");\n          }\n          if (parser.seen('110')) {\n            parser.boolval('S') ? emergency_parser.enable() : emergency_parser.disable();\n          }\n        }\n      }\n      pending_char = c;\n    }\n  }\n  return pending_char;\n}", "CodeBleu_score": 41.21553596165958}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n    int c = udi_cdc_getc();\n    if (c == -1) return -1;\n    if (c == '\\\n') {\n      c = '\\\\r';\n      pending_char = '\\\n';\n    }\n    if (c == '\\\\r' && pending_char == '\\\n') {\n      pending_char = -1;\n      return '\\\n';\n    }\n    pending_char = -1;\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 49.95335561261642}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready()) {\n    pending_char = udi_cdc_getc();\n    if (pending_char != -1) {\n      // Process the character\n      if (emergency_parser.enabled) emergency_parser.update(pending_char);\n    }\n  }\n  return pending_char;\n}", "CodeBleu_score": 45.742370803739405}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t", "CodeBleu_score": 1.6377800256158708}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    const int ch = pending_char;\n    pending_char = -1;\n    return ch;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return pending_char;\n}", "CodeBleu_score": 72.61735167836143}, {"code": "int MarlinSerialUSB::read(){\n\t  if (pending_char >= 0) {\n    const int c = pending_char;\n    pending_char = -1;\n    return c;\n  }\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return pending_char;\n}", "CodeBleu_score": 74.14551056664311}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  pending_char = udi_cdc_getc();\n\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n  return 1;\n}", "CodeBleu_score": 49.92287376406407}, {"code": "int MarlinSerialUSB::available(){\n\t  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  return 1;\n}", "CodeBleu_score": 30.671562552852894}, {"code": "int MarlinSerialUSB::available(){\n\t  if (pending_char >= 0)\n    return 1;\n\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n\n  return 1;\n\n}", "CodeBleu_score": 30.95725895241267}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(uint32_t(REAL_EEPROM_ADDR(pos)));\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 88.64207247763936}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(uint32_t(REAL_EEPROM_ADDR(pos)));\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 88.64207247763936}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(uint32_t(REAL_EEPROM_ADDR(pos)));\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 88.64207247763936}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  #if ENABLED(I2S_STEPPER_STREAM)\n    if (pin > 127) {\n      pwm_pin_data[pin & 0x7F].pwm_duty_ticks = value;\n      return;\n    }\n  #endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) ledcWrite(cid, value);\n}", "CodeBleu_score": 29.699858862668354}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin > 127) return;\n  #if ENABLED(I2S_STEPPER_STREAM)\n    if (pin > 127) {\n      pwm_pin_t &pindata = pwm_pin_data[pin & 0x7F];\n      if (pindata.pwm_duty_ticks == 0) {\n        SBI32(i2s_port_data, pin & 0x7F);\n        return;\n      }\n      const uint32_t duty = map(value, 0, _BV(res)-1, 0, pindata.pwm_cycle_ticks);\n      if (duty == 0 || duty == pindata.pwm_cycle_ticks) {\n        pindata.pwm_duty_ticks = 0;\n        SBI32(i2s_port_data, pin & 0x7F);\n      }\n      else\n        pindata.pwm_duty_ticks = duty;\n      return;\n    }\n  #endif\n\n  const int8_t cid = set_pwm_frequency(pin, freq);\n  if (cid >= 0) ledcWrite(cid, map(value, 0, _BV(res)-1, 0, _BV(PWM_RESOLUTION)-1));\n}", "CodeBleu_score": 39.447234495137096}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  #if ENABLED(I2S_STEPPER_STREAM)\n    if (pin > 127) {\n      const uint8_t pinlo = pin & 0x7F;\n      pwm_pin_t &pindata = pwm_pin_data[pinlo];\n      const uint32_t duty = map(value, 0, _BV(res)-1, 0, pindata.pwm_cycle_ticks);\n      if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n\n        pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n        duty ? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n      }\n      else\n        pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n      return;\n    }\n  #endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0)\n    ledcWrite(cid, value);\n}", "CodeBleu_score": 47.534366820572586}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(COUNT(servo_delay) == NUM_SERVOS, \\\n                \\\"SERVO_DELAY has wrong size. Expected \" STRINGIFY(NUM_SERVOS) \" entries.\\\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n\n      detach();\n\n    #endif\n\n  }\n\n}", "CodeBleu_score": 52.75167390774749}, {"code": "void Servo::move(const int value){\n\t  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n\n      detach();\n\n    #endif\n\n  }\n\n}", "CodeBleu_score": 40.689774758976164}, {"code": "void Servo::move(const int value){\n\t  static_assert(COUNT(servo_delay) == NUM_SERVOS, \\\n                \"SERVO_DELAY must be a table in the format of 150 for each servo.\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 63.54900026663608}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  static uint32_t dma_buf_pos = 0;\n  static uint32_t pwm_tick = 0;\n\n  #if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n    for (uint8_t pin = 0; pin < 16; pin++) {\n      uint32_t duty = I2S0.conf_single_data & (1 << pin);\n      if (duty) {\n        if (pwm_tick == 0) {\n  // toggle pin state\n  i2s_write(pin, !i2s_state(pin));\n  // set tick count for next transition\n  pwm_tick = duty;\n} else {\n  pwm_tick--;\n}\n      }\n    }\n  #endif\n\n  // store updated port data into DMA buffer\n  dma.buf[dma_buf_pos] = i2s_port_data;\n  dma_buf_pos++;\n\n  // if DMA buffer is full, send it to the I2S peripheral\n  if (dma_buf_pos == DMA_BUF_LEN) {\n    xQueueSend(dma.queue, &dma.buf, portMAX_DELAY);\n    dma_buf_pos = 0;\n  }\n}", "CodeBleu_score": 33.846821784805044}, {"code": "void i2s_push_sample(){\n\t  #if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n    uint32_t *ptr = dma.desc[dma.index];\n    uint32_t *end = ptr + DMA_BUF_SIZE;\n    while (ptr < end) {\n      uint32_t *next = ptr + DMA_BUF_SIZE / 2;\n      *ptr++ = i2s_port_data;\n      *ptr++ = I2S0.conf_single_data;\n      i2s_port_data = 0;\n      I2S0.conf_single_data = 0;\n      ptr = next;\n    }\n\n  #else\n    uint32_t *ptr = dma.desc[dma.index];\n    uint32_t *end = ptr + DMA_BUF_SIZE;\n    while (ptr < end) *ptr++ = i2s_port_data;\n    i2s_port_data = 0;\n  #endif\n\n  // Update the DMA descriptor\n  dma.desc[dma.index]->length = sizeof(uint32_t) * DMA_BUF_SIZE;\n  dma.desc[dma.index]->buf = dma.buffer[dma.index];\n  dma.desc[dma.index]->eof = 1;\n  dma.desc[dma.index]->sosf = 0;\n  dma.desc[dma.index]->owner = 1;\n  dma.desc[dma.index]->offset = 0;\n  dma.desc[dma.index]->empty = 0;\n  dma.desc[dma.index]->qe.stqe_next = NULL;\n\n  // Send the buffer to the DMA\n  if (xQueueSendFromISR(dma.queue, &dma.desc[dma.index], NULL) == pdTRUE) {\n    dma.index = (dma.index + 1) % DMA_BUF_COUNT;\n  }\n}", "CodeBleu_score": 33.33917291942122}, {"code": "void i2s_push_sample(){\n\t  for (uint8_t i = 0; i < 16; i++) {\n    if (pwm_duty[i]) {\n      if (--pwm_tick[i] == 0) {\n        i2s_write(i, !i2s_state(i));\n        pwm_tick[i] = pwm_duty[i];\n      }\n    }\n  }\n  dma.buffer[dma.index++] = i2s_port_data;\n  if (dma.index >= DMA_BUF_SIZE) {\n    dma.index = 0;\n    xQueueSend(dma.queue, &dma.buffer, 0);\n  }\n}", "CodeBleu_score": 28.782867868453334}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  const tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t counter_value;\n  timer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n  return counter_value;\n}", "CodeBleu_score": 99.67475659310028}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  const tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t timer_counter_value = 0;\n  timer_get_counter_value(timer.group, timer.idx, &timer_counter_value);\n\n  return timer_counter_value;\n}", "CodeBleu_score": 79.02689814125374}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  const tTimerConfig timer = timer_config[timer_num];\n\n  uint64_t timer_counter_value;\n  timer_get_counter_value(timer.group, timer.idx, &timer_counter_value);\n\n  return timer_counter_value;\n}", "CodeBleu_score": 84.63876488349202}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.58904212470298}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.58904212470298}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 92.58904212470298}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.13698866452353}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.13698866452353}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 85.13698866452353}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TEMP_TIMER) {\n    temp_timer.start(frequency, TIMER02A_PRESCALE);\n    NVIC_SetPriority(TIMER02A_IRQn, TEMP_TIMER_PRIO);\n  }\n  else if (timer_num == STEP_TIMER) {\n    step_timer.start(frequency, TIMER02B_PRESCALE);\n    NVIC_SetPriority(TIMER02B_IRQn, STEP_TIMER_PRIO);\n  }\n  else {\n    ASSERT(0);\n  }\n}", "CodeBleu_score": 37.30912023586451}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TIMER_TEMP_CH) {\n    temp_timer.init(frequency, TIMER_TEMP_PRESCALE);\n    temp_timer.setCallbackPriority(TEMP_TIMER_PRIO);\n  }\n  else if (timer_num == TIMER_STEP_CH) {\n    step_timer.init(frequency, TIMER_STEP_PRESCALE);\n    step_timer.setCallbackPriority(STEP_TIMER_PRIO);\n  }\n  else {\n    ASSERT(0);\n  }\n}", "CodeBleu_score": 45.29212641313812}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n\\t\\tcase TIMER_TEMP: temp_timer.start(frequency, TIMER02A_PRESCALE); temp_timer.set_callback_priority(TIMER_CALLBACK_PRIORITY); break;\n\\t\\tcase TIMER_STEP: step_timer.start(frequency, TIMER02B_PRESCALE); step_timer.set_callback_priority(TIMER_CALLBACK_PRIORITY); break;\n\\t\\tdefault: ASSERT(0);\n\\t}\n}", "CodeBleu_score": 33.066826569466315}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  bool return_value = true;\n\n  if (!(eeprom_file = fopen(filename, \\\"rb\\\"))) {\n    if (!(eeprom_file = fopen(filename, \\\"wb\\\"))) {\n      return_value = false;\n    } else {\n      for (int i = 0; i < MARLIN_EEPROM_SIZE; i++) buffer[i] = 0xFF;\n    }\n  } else {\n    fseek(eeprom_file, 0, SEEK_END);\n    size_t const file_size = ftell(eeprom_file);\n    if (file_size < MARLIN_EEPROM_SIZE) {\n      for (int i = file_size; i < MARLIN_EEPROM_SIZE; i++) buffer[i] = 0xFF;\n    } else {\n      fseek(eeprom_file, 0, SEEK_SET);\n      fread(buffer, sizeof(uint8_t), MARLIN_EEPROM_SIZE, eeprom_file);\n    }\n  }\n\n  return return_value;\n}", "CodeBleu_score": 49.49366438377345}, {"code": "bool PersistentStore::access_start(){\n\t  size_t read_size = capacity();\n\n  #if DISABLED(FLASH_EEPROM_EMULATION)\n    if (FILE *const eeprom_file = fopen(filename, \\\"rb\\\"))\n    {\n      fseek(eeprom_file, 0, SEEK_END);\n      const size_t actual_size = ftell(eeprom_file);\n      fseek(eeprom_file, 0, SEEK_SET);\n      if (actual_size < read_size)\n      {\n        memset(buffer, 0xFF, read_size);\n        read_size = actual_size;\n      }\n      else\n        fread(buffer, sizeof(uint8_t), read_size, eeprom_file);\n      fclose(eeprom_file);\n      return true;\n    }\n    return false;\n  #else\n    return true;\n  #endif\n}", "CodeBleu_score": 48.079205582711616}, {"code": "bool PersistentStore::access_start(){\n\t  size_t read_size = 0;\n\n  if (!(file = fopen(filename, \\\"rb\\\"))) return false;\n\n  fseek(file, 0, SEEK_END);\n  read_size = ftell(file);\n  fseek(file, 0, SEEK_SET);\n\n  if (read_size < MARLIN_EEPROM_SIZE) {\n    // fill remainder of buffer with default erase value\n    memset(&buffer[read_size], 0xFF, MARLIN_EEPROM_SIZE - read_size);\n  }\n\n  if (read_size != fread(buffer, 1, MARLIN_EEPROM_SIZE, file)) {\n    fclose(file);\n    return false;\n  }\n\n  fclose(file);\n  return true;\n}", "CodeBleu_score": 47.65484515821782}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t rec = 0;\n    for (int i = 7; i >= 0; --i) {\n        WRITE(SD_SCK_PIN, LOW);\n        WRITE(SD_MOSI_PIN, !!(b & (1 << i)));\n        WRITE(SD_SCK_PIN, HIGH);\n        rec |= (READ(SD_MISO_PIN) ? 1 : 0) << i;\n    }\n    delaySPIFunc();\n    return rec;\n}", "CodeBleu_score": 53.61726830020598}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  for (uint8_t i = 0x80; i; i >>= 1) {\n    WRITE(SD_SCK_PIN, LOW);\n    WRITE(SD_MOSI_PIN, !!(b & i));\n    WRITE(SD_SCK_PIN, HIGH);\n    r <<= 1;\n    if (READ(SD_MISO_PIN)) r |= 0x01;\n  }\n  delaySPIFunc();\n  return r;\n}", "CodeBleu_score": 52.08924033287985}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t rec = 0;\n  for (int i = 7; i >= 0; i--) {\n    // Set clock pin low\n    OUT_WRITE(SD_SCK_PIN, LOW);\n    // Write most significant bit of the byte to the MOSI pin\n    OUT_WRITE(SD_MOSI_PIN, b & (1 << i));\n    // Toggle clock pin high\n    OUT_WRITE(SD_SCK_PIN, HIGH);\n    // Read bit from the MISO pin\n    rec <<= 1;\n    rec |= digitalRead(SD_MISO_PIN);\n    // Wait for the specified delay\n    delaySPIFunc();\n  }\n  // Return the received byte\n  return rec;\n}", "CodeBleu_score": 50.11390635491802}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  // Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  // Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  // Check the parameters\n  assert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 95.98536460782101}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\n  // If the buffer is full, we have a problem\n  if (rx_buffer_head == RX_BUFFER_SIZE) {\n    // If there is an error, read it and discard the byte\n    if (obj->is_error()) obj->read();\n    return;\n  }\n\n  // Get and store byte\n  uint8_t data = obj->read();\n  rx_buffer[rx_buffer_head] = data;\n\n  // If there is an error, read it and discard the byte\n  if (obj->is_error()) {\n    obj->read();\n    return;\n  }\n\n  // Calculate next buffer index\n  uint8_t next_buffer_index = rx_buffer_head + 1;\n  if (next_buffer_index == RX_BUFFER_SIZE) next_buffer_index = 0;\n\n  // If the next index loops back to the head, we are so far ahead that the buffer is full.\n  // Flush the buffer to make room for new data.\n  if (next_buffer_index == rx_buffer_tail) {\n    rx_buffer_overflow = true;\n    _flush_buffer();\n  }\n\n  // Store new index\n  rx_buffer_head = next_buffer_index;\n\n  // Update the emergency parser\n  TERN_(EMERGENCY_PARSER, _serial.rx_callback(data));\n}", "CodeBleu_score": 36.66036931968601}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->rx_buffer_head == obj->rx_buffer_tail) { // Buffer overflow\n    obj->rx_buffer_head = obj->rx_buffer_tail = obj->rx_buffer_size;\n  }\n\n  uint8_t data = obj->uart->DR;\n\n  if (obj->rx_buffer_head < obj->rx_buffer_size) {\n    obj->rx_buffer[obj->rx_buffer_head] = data;\n    obj->rx_buffer_head = (obj->rx_buffer_head + 1) % obj->rx_buffer_size;\n  }\n\n  #if ENABLED(EMERGENCY_PARSER)\n    TERN_(EMERGENCY_PARSER, _serial.rx_callback(data));\n  #endif\n}", "CodeBleu_score": 43.50641986789257}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->rx_buffer_head == obj->rx_buffer_tail) { // Allocate the buffer for the first byte\n    char_buffer_head = char_buffer;\n    char_buffer_tail = char_buffer;\n  }\n\n  // If the buffer is full, we can't read another byte; return an error\n  if (((obj->rx_buffer_head + 1) == obj->rx_buffer_tail) || ((obj->rx_buffer_head + 1) == &obj->rx_buffer[SERIAL_RX_BUFFER_SIZE])) {\n    obj->rx_buffer_overflow = true;\n    return;\n  }\n\n  // Read the byte and store it in the buffer\n  *obj->rx_buffer_head = (char)obj->uart->DR;\n\n  // Update the buffer head pointer\n  obj->rx_buffer_head++;\n  if (obj->rx_buffer_head == &obj->rx_buffer[SERIAL_RX_BUFFER_SIZE]) {\n    obj->rx_buffer_head = obj->rx_buffer;\n  }\n\n  // Update the emergency parser\n  TERN_(EMERGENCY_PARSER, _serial.rx_callback(obj->rx_buffer_head[-1]));\n}", "CodeBleu_score": 34.700863908653304}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (HAL_timer_initialized(timer_num)) {\n    if (timer_instance[timer_num]->getInterruptState()) return;\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n  }\n}", "CodeBleu_score": 85.93176752397606}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (HAL_timer_initialized(timer_num)) {\n    if (!HAL_timer_interrupt_enabled(timer_num)) {\n      switch (timer_num) {\n        case MF_TIMER_STEP:\n          timer_instance[timer_num]->attachInterrupt(Step_Handler);\n          break;\n        case MF_TIMER_TEMP:\n          timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 82.26519647115877}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (HAL_timer_initialized(timer_num)) {\n    if (!timer_instance[timer_num]->hasInterrupt()) {\n      switch (timer_num) {\n        case MF_TIMER_STEP:\n          timer_instance[timer_num]->attachInterrupt(Step_Handler);\n          break;\n        case MF_TIMER_TEMP:\n          timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 88.16753037969694}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := len(s) - 1; i >= len(sep)-1; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && string(s[len(s)-n:]) == string(sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && string(s[i+1:i+n+1]) == string(sep) {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 67.13625777867095}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := n - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && Equal(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && Equal(s[i+1:i+n+1], sep) {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 62.69649882856265}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := len(s) - 1; i >= len(sep)-1; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[len(s)-n:]) == string(sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\ti--\n\t\tif h == hashss && string(s[i+1:i+1+n]) == string(sep) {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 68.16450593329806}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tmask := interrupt.Disable()\n\tif usbcdc.waitTxc {\n\t\tSendUSBInPacket(usbLineInfo[0], usbLineInfo[2:7])\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore(mask)\n}", "CodeBleu_score": 46.42492495831693}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tmask := interrupt.Disable()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.txBuffer.Flush()\n\t} else {\n\t\tusbcdc.waitTxc = true\n\t}\n\tinterrupt.Restore(mask)\n}", "CodeBleu_score": 50.69820257552895}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tmask := interrupt.Disable()\n\n\tif usbcdc.waitTxc {\n\t\tfor _, buf := range usbcdc.txBuffer.Buffers() {\n\t\t\tusb.SendUSBInPacket(usb.ENDPOINT_CDC_TX, buf)\n\t\t}\n\t\tusbcdc.waitTxc = false\n\t}\n\n\tinterrupt.Restore(mask)\n}", "CodeBleu_score": 63.87776699097457}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag, put a start condition on the bus, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crINT | i2c.crEN | i2c.crSTA)\n\n\t// Wait for the start condition to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srINT) {\n\t}\n\n\n\t// Write the shifted peripheral address to the bus.\n\ti2c.writeByte((address << 1) | uint8(write))\n}", "CodeBleu_score": 40.915230488314016}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag, set a start condition, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crEN | i2c.crINT | i2c.crSTA)\n\n\t// Wait for the start condition to be transmitted.\n\tfor !i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\n\t// Write the shifted peripheral address to the bus.\n\ti2c.drReg.Set(uint8(address << 1))\n\tif !write {\n\t\ti2c.drReg.SetBits(i2c.crRD)\n\t}\n\n\n\t// Send the address.\n\ti2c.crReg.Set(i2c.crEN | i2c.crINT | i2c.crSTA)\n\n\t// Wait for the address to be transmitted.\n\tfor !i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n}", "CodeBleu_score": 41.9983407791336}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag, put a start condition on the bus, and enable the I2C module.\n\ti2c.crReg.Set(i2c.crEN | i2c.crINT | i2c.crSTA)\n\n\t// Wait for the start condition to be transmitted.\n\tfor !i2c.srReg.HasBits(i2c.srINT) {\n\t}\n\n\n\t// Write the address of the peripheral.\n\ti2c.writeByte((address << 1) | uint8(write))\n}", "CodeBleu_score": 40.915230488314016}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := FlashDataStart() + uintptr(start*f.EraseBlockSize())\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.SetCONFIG_ERASE(nrf.NVMC_CONFIG_ERASE_ErasePage)\n\t\tnrf.NVMC.SetCONFIG_PSIZE(nrf.NVMC_CONFIG_PSIZE_PSize1)\n\t\tnrf.NVMC.SetCONFIG_PAGE(uint32(startAddress / 4096))\n\t\tnrf.NVMC.TASKS_ERASEPAGE.Set(1)\n\n\t\twaitWhileFlashBusy()\n\n\t\tstartAddress += uintptr(f.EraseBlockSize())\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 71.45985056458301}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := FlashDataStart() + uintptr(start)*uintptr(f.EraseBlockSize())\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := 0; i < int(len); i++ {\n\t\tnrf.NVMC.SetCONFIG_MODE(nrf.NVMC_CONFIG_MODE_Erase)\n\t\tnrf.NVMC.SetCONFIG_TASKS_ERASEPAGE(uint32(startAddress))\n\t\twaitWhileFlashBusy()\n\t\tstartAddress += uintptr(f.EraseBlockSize())\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 66.1069714675102}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := FlashDataStart() + uintptr(start*f.EraseBlockSize())\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.SetCONFIG_MODE(nrf.NVMC_CONFIG_MODE_Erase)\n\t\tnrf.NVMC.SetCONFIG_TASKS_ERASEPAGE(uint32(startAddress + uintptr(i*f.EraseBlockSize())))\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.67555553486187}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tstart := FlashDataStart() + uintptr(off)\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(start)), len(p))\n\tcopy(data, p)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 31.603080023281134}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(FlashDataStart()+uintptr(off))), len(p))\n\tcopy(data, p)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 27.627574701030326}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\taddr := FlashDataStart() + uintptr(off)\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(addr)), len(p))\n\tcopy(data, p)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 31.673968131651048}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// fdopendir(3) is not implemented on macOS, so we use the fdopendir(2) syscall.\n\t// This is not a perfect emulation, but it is sufficient for our purposes.\n\td, err := syscall.FcntlFlock(fd, syscall.F_DUPFD_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn 0, \"fcntl\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(d)\n\t\tif err != syscall.EINTR {\n\t\t\tif err != nil {\n\t\t\t\tsyscall.Close(d)\n\t\t\t\treturn 0, \"fdopendir\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 61.9138420933805}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\td, err := syscall.FcntlFlock(fd, syscall.F_DUPFD_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn 0, \"fcntl\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(d)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(d)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"fdopendir\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 60.893433930115194}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\td, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"dup\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(d)\n\t\tif err == nil {\n\t\t\tsyscall.Close(d)\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(d)\n\t\t\treturn 0, \"fdopendir\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 62.87647068819355}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *partition = esp_ota_get_running_partition();\n  if (partition == NULL) {\n    return 0;\n  }\n  const esp_partition_pos_t partition_pos = {\n      .offset = partition->address,\n      .pos = partition->position,\n  };\n  esp_image_header_t header;\n  if (esp_image_verify(ESP_IMAGE_VERIFY, &header, &partition_pos) != ESP_OK) {\n    return 0;\n  }\n  if (response == SKETCH_SIZE) {\n    return header.image_len;\n  }\n  return partition->size - header.image_len;\n}", "CodeBleu_score": 62.108822869229364}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t* partition = esp_ota_get_running_partition();\n  esp_image_header_t header;\n  if (!esp_image_verify(ESP_PARTITION_TYPE_APP, &header)) {\n    return 0;\n  }\n  if (response == TOTAL_AVAILABLE_SKETCH_SPACE) {\n    return header.image_len;\n  }\n  return partition->size - header.data_len;\n}", "CodeBleu_score": 39.926890846182886}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *partition = esp_ota_get_running_partition();\n  if (!partition) {\n    return 0;\n  }\n\n  esp_image_header_t header;\n  if (esp_image_header_get_metadata(partition, ESP_IMAGE_OTA, &header) != ESP_OK) {\n    return 0;\n  }\n\n  if (response == TOTAL_SKETCH_SIZE) {\n    return header.image_len;\n  }\n\n  return partition->size - header.data_len;\n}", "CodeBleu_score": 47.28895964457575}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  msc_total_sectors = msc_update_get_required_disk_sectors();\n  msc_ram_disk = (uint8_t *)heap_caps_malloc(msc_total_sectors * DISK_SECTOR_SIZE, MALLOC_CAP_DMA);\n  if (!msc_ram_disk) {\n    log_e(\\\"Not enough memory for FW MSC\\\");\n    return false;\n  }\n  msc_boot = (fat_boot_sector_t *)msc_ram_disk;\n  msc_table = msc_ram_disk + msc_total_sectors - msc_table_sectors * DISK_SECTOR_SIZE;\n  fat_init(msc_boot, msc_table, msc_total_sectors, mcs_is_fat16);\n  fat_set_volume_label(msc_boot, volume_label);\n  fat_set_serial_number(msc_boot, serial_number);\n  if (msc_run_partition) {\n    fw_entry = fat_file_add_entry(msc_boot, msc_table, \\\"firmware.bin\\\", 0, FAT_ATTR_READ_ONLY);\n    if (fw_entry) {\n      fw_start_sector = fw_entry->first_sector;\n      fw_end_sector = fw_entry->first_sector + FAT_SIZE_TO_SECTORS(fw_size);\n    }\n  }\n  return true;\n}", "CodeBleu_score": 49.714036541632176}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  msc_total_sectors = msc_update_get_required_disk_sectors();\n  msc_ram_disk = (uint8_t *) heap_caps_malloc(msc_total_sectors * DISK_SECTOR_SIZE, MALLOC_CAP_8BIT);\n  if (msc_ram_disk == NULL) {\n    log_e(\\\"msc_update_setup_disk: Failed to allocate %u bytes for RAM disk\\\", msc_total_sectors * DISK_SECTOR_SIZE);\n    return false;\n  }\n  msc_boot = (fat_boot_sector_t *) msc_ram_disk;\n  msc_table = msc_ram_disk + msc_table_sectors * DISK_SECTOR_SIZE;\n  fat_init_boot_sector(msc_boot, msc_total_sectors, msc_table_sectors, msc_table, msc_total_sectors - msc_table_sectors - 2);\n  fat_set_volume_label(msc_boot, volume_label);\n  fat_set_serial_number(msc_boot, serial_number);\n  fat_init_fs(msc_table, msc_table_sectors, msc_total_sectors - msc_table_sectors - 2);\n  if (msc_run_partition) {\n    fw_entry = fat_add_dir_entry(msc_table, msc_table_sectors, msc_total_sectors - msc_table_sectors - 2, \\\"FW.BIN\\\", 0, FAT_FILE_TYPE_REGULAR);\n    fw_start_sector = fw_entry->first_sector;\n    fw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size) - 1;\n    fat_set_dir_entry_size(msc_table, fw_entry, fw_size);\n  }\n  return true;\n}", "CodeBleu_score": 51.881607756511485}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t  if (offset % SPI_FLASH_SEC_SIZE) {\n    log_e(\\\"Offset is not aligned with flash sector size\\\");\n    return ESP_FAIL;\n  }\n  esp_err_t result = esp_partition_erase_range(partition, offset, size);\n  if (result != ESP_OK) {\n    log_e(\\\"Failed to erase flash: %s\\\", esp_err_to_name(result));\n    return result;\n  }\n  return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 50.61629552235534}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t", "CodeBleu_score": 5.717441331318144}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t  uint32_t sector_size = spi_flash_get_sector_size();\n  if (offset % sector_size) {\n    log_e(\\\"Offset not aligned with sector size\\\");\n    return ESP_ERR_INVALID_ARG;\n  }\n  esp_err_t err = ESP_OK;\n  if (offset < partition->size) {\n    err = spi_flash_erase_sector(partition->address + offset);\n    if (err) {\n      log_e(\\\"Failed to erase sector: %s\\\", esp_err_to_name(err));\n      return err;\n    }\n  }\n  return spi_flash_write(partition->address + offset, data, size);\n}", "CodeBleu_score": 46.61669917870079}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  uint8_t high_nibble = 0x10;\n  while (*in && i < maxlen) {\n    uint8_t byte = hex_char_to_byte(*in);\n    if (byte < 0x10) {\n      if (high_nibble == 0x10) {\n        high_nibble = byte;\n      } else {\n        out[i] = (high_nibble << 4) | byte;\n        high_nibble = 0x10;\n        i++;\n      }\n    }\n    in++;\n  }\n  return i;\n}", "CodeBleu_score": 48.17617183840188}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = 0;\n  while (*in && len < maxlen) {\n    if (in[1] && hex_char_to_byte(in[1]) < 16) {\n      out[len++] = (hex_char_to_byte(in[0]) << 4) | hex_char_to_byte(in[1]);\n      in += 2;\n    } else {\n      in++;\n    }\n  }\n  return len;\n}", "CodeBleu_score": 37.86845070032988}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = strlen(in);\n  size_t i, j;\n  for (i = 0, j = 0; i < len && j < maxlen; i += 2, j++) {\n    uint8_t c1 = hex_char_to_byte(in[i]);\n    if (c1 == 16) {\n      break;\n    }\n    uint8_t c2 = hex_char_to_byte(in[i + 1]);\n    if (c2 == 16) {\n      break;\n    }\n    out[j] = (c1 << 4) | c2;\n  }\n  return j;\n}", "CodeBleu_score": 41.87235699250179}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t  if (!tx_ring_buf || !tx_lock) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) == pdTRUE) {\n    size_t free_size = xRingbufferGetCurFreeSize(tx_ring_buf);\n    xSemaphoreGive(tx_lock);\n    return free_size;\n  }\n  return 0;\n}", "CodeBleu_score": 72.98035924788539}, {"code": "int HWCDC::availableForWrite(void){\n\t  if (tx_ring_buf == NULL || tx_lock == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) == pdTRUE) {\n    size_t free = xRingbufferGetCurFreeSize(tx_ring_buf);\n    xSemaphoreGive(tx_lock);\n    return free;\n  }\n  return 0;\n}", "CodeBleu_score": 86.74941233529492}, {"code": "int HWCDC::availableForWrite(void){\n\t  if (!tx_ring_buf || !tx_lock) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) != pdTRUE) {\n    return 0;\n  }\n  int ret = uxRingbufferGetFreeSize(tx_ring_buf);\n  xSemaphoreGive(tx_lock);\n  return ret;\n}", "CodeBleu_score": 73.40421218991587}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  _onReceiveTimeout = onlyOnTimeout;\n  // set FIFO full threshold\n  if (function != NULL) {\n    _rxFIFOFull = 0;\n    if (_rxBufferSize > UART_FIFO_LEN) {\n      _rxFIFOFull = _rxBufferSize - UART_FIFO_LEN;\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 61.85872911093687}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  _onReceiveTimeout = onlyOnTimeout;\n  // Set the FIFO full threshold to the size of the receive buffer\n  if (_rxFIFOFull == 0) {\n    _rxFIFOFull = _rxBufferSize;\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 47.61164343657519}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function != NULL && _uart != NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n  // set FIFO full threshold\n  _rxFIFOFull = _rxBufferSize / 2;\n  // set receive timeout behavior\n  _onReceiveTimeout = onlyOnTimeout;\n  HSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 40.13099940945164}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 99.80465478981657}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) break;\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 86.32172015423131}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) break;\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 86.32172015423131}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\\\"tone was called\\\");\n  if (_pin == -1 || _pin == pin) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else {\n    log_e(\\\"Tone is already running on given pin %d\\\", pin);\n  }\n}", "CodeBleu_score": 66.17870899329502}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\\\"tone was called\\\");\n  if (_pin == pin) {\n    log_e(\\\"Tone is already running on pin %d\\\", pin);\n  } else {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  }\n}", "CodeBleu_score": 61.73719171568713}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\\\"tone was called\\\");\n  log_d(\\\"pin=%d, frequency=%u Hz, duration=%lu ms\\\", pin, frequency, duration);\n\n  if (_pin == -1) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueReset(_tone_queue);  // clear queue\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n    }\n  } else if (_pin == pin) {\n    log_e(\\\"Tone is already running on given pin %d\\\", pin);\n    log_e(\\\"Stop the tone first with noTone(%d)\n\", pin);\n  } else {\n    log_e(\\\"Tone is already running on pin %d\n\", _pin);\n    log_e(\\\"Stop the tone first with noTone(%d)\n\", _pin);\n  }\n}", "CodeBleu_score": 64.49064279937298}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = max(usb_version, 0x0210);\n    }\n  }\n  return !_started;\n}", "CodeBleu_score": 72.01425934435565}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = max(usb_version, 0x0210);\n    }\n  }\n  return !_started;\n}", "CodeBleu_score": 72.01425934435565}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = std::max(usb_version, (uint16_t)0x0210);\n    }\n  }\n  return !_started;\n}", "CodeBleu_score": 70.72408926624807}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  if (rx_queue) {\n    size_t copySize = rx_queue_len;\n    if (rx_queue_len) {\n      size_t available = uxQueueMessagesWaiting(rx_queue);\n      if (available < rx_queue_len) {\n        copySize = available;\n      }\n      if (copySize > 0) {\n        uint8_t ch = 0;\n        xQueueReceive(rx_queue, &ch, 0);\n        if (!xQueueSend(new_rx_queue, &ch, 0)) {\n          arduino_usb_cdc_event_data_t p;\n          p.rx_overflow.dropped_bytes = copySize - i;\n          arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n          log_e(\"CDC RX Overflow.\");\n          break;\n        }\n      }\n    }\n    vQueueDelete(rx_queue);\n  }\n  rx_queue = new_rx_queue;\n  return rx_queue_len;\n}", "CodeBleu_score": 49.860298313276274}, {"code": "void USBCDC::_onRX(){\n\t", "CodeBleu_score": 1.253830987611717}, {"code": "void USBCDC::_onRX(){\n\t  if (rx_queue) {\n    uint8_t ch = 0;\n    size_t len = tud_cdc_n_read(itf, &ch, 1);\n    if (len) {\n      if (!xQueueSend(rx_queue, &ch, 0)) {\n        arduino_usb_cdc_event_data_t p;\n        p.rx_overflow.dropped_bytes = 1;\n        arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n        log_e(\\\"CDC RX Overflow.\\\");\n      }\n    }\n  }\n}", "CodeBleu_score": 31.60852672412598}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.738073028315426}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.738073028315426}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.738073028315426}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.91081293671324}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err != nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"connections\": robot.Connections}, res)\n\t}\n}", "CodeBleu_score": 32.00138428711164}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.91081293671324}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).Device(req.URL.Query().Get(\":device\")), res, req)\n}", "CodeBleu_score": 26.38811825977969}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).Device(req.URL.Query().Get(\":device\")).Driver(),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 32.54654025498055}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).Device(req.URL.Query().Get(\":device\")), res, req)\n}", "CodeBleu_score": 26.38811825977969}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tactual := r.Header.Get(\"Authorization\")\n\t\tif actual != expected {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 61.3646905825559}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauthBytes, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauthPair := bytes.SplitN(authBytes, []byte(\":\"), 2)\n\t\tif len(authPair) != 2 {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tusernameBytes := []byte(username)\n\t\tpasswordBytes := []byte(password)\n\t\tif subtle.ConstantTimeCompare(authPair[0], usernameBytes) == 1 && subtle.ConstantTimeCompare(authPair[1], passwordBytes) == 1 {\n\t\t\t// Authentication succeeded\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// Authentication failed\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 48.40971876352612}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+r.URL.Path+`\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.12687592697451}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogReadSupported() {\n\t\treturn -1, -1, fmt.Errorf(\"analog read is not supported by this connection\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tscaledValue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 51.310862134118395}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogReadSupported() {\n\t\treturn -1, -1, fmt.Errorf(\"analog reading not supported by '%s'\", a.Name())\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 51.62592877922108}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogReadSupported() {\n\t\treturn -1, -1, fmt.Errorf(\"'%s' does not support analogRead\", a.Name())\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 50.86525844099301}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn d\n}", "CodeBleu_score": 82.63605056101007}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn d\n}", "CodeBleu_score": 82.63605056101007}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn d\n}", "CodeBleu_score": 82.63605056101007}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, cmdSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&cmdSoftReset != 0 {\n\t\treturn fmt.Errorf(\"MFRC522Common.softReset: initialization took too long\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 79.02309005281913}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, cmdSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&cmdSoftReset != 0 {\n\t\treturn fmt.Errorf(\"MFRC522Common: soft reset failed, command register is 0x%02X\", val)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 83.48337614971177}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, cmdSoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&cmdSoftReset != 0 {\n\t\treturn fmt.Errorf(\"MFRC522Common: power-down bit is still set after initialization\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 79.14197613309139}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// number of bytes in the FIFO\n\tn, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"the FIFO has %d bytes, but the buffer has %d bytes\", n, len(backData))\n\t}\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\trxLastBits, err := d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits & controlRegRxLastBitsBit, nil\n}", "CodeBleu_score": 60.24271626209846}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"bad length in readFifo\")\n\t}\n\tif n == 0 {\n\t\tn = 32\n\t}\n\tif err := d.readByteDataTo(regFIFOData, backData[:n]); err != nil {\n\t\treturn 0, err\n\t}\n\trxLastBits, err := d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits & controlRegRxLastBits, nil\n}", "CodeBleu_score": 53.85094251318273}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.readByteData(regFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO level error\")\n\t}\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\trxLastBits, err := d.readByteData(regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits & controlRegRxLastBits, nil\n}", "CodeBleu_score": 57.030159463229545}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"halt\\\")\n\t}\n\n\thaltCommand := []byte{piccCommandHalt}\n\n\thaltCommand = append(haltCommand, d.calcCRC(haltCommand)...)\n\n\n\t_, err := d.piccComms(haltCommand)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\treturn nil\n\n}", "CodeBleu_score": 32.49060462347045}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"halt\\\")\n\t}\n\thaltCommand := []byte{piccCommandHaltA, 0x00}\n\td.calculateCRC(haltCommand, 1)\n\tif err := d.piccCommand(haltCommand); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.81013626519786}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"halt\\\")\n\t}\n\thaltCommand := []byte{piccCommandHalt}\n\n\thaltCommand = append(haltCommand, d.calcCRC(haltCommand)...)\n\n\tif err := d.piccCommand(haltCommand); err != nil {\n\n\t\treturn err\n\n\t}\n\n\treturn nil\n\n}", "CodeBleu_score": 32.658929171900716}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, true); err != nil {\n\t\treturn nil, err\n\t}\n\tif len(backData) != 16 {\n\t\treturn nil, fmt.Errorf(\"the read data should be exactly 16 bytes long, but has %d bytes\", len(backData))\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 80.09481569385032}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err != nil {\n\t\treturn nil, err\n\t}\n\tif piccDebug {\n\t\tfmt.Println(\"backData\", backData)\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 78.53091267006013}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err != nil {\n\t\treturn nil, err\n\t}\n\tif piccDebug {\n\t\tfmt.Println(\"backData\", backData)\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 78.53091267006013}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer needs at least 2 bytes\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\n\tif reqMode == piccRequestReqAll {\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset|bitFramingRegRxAlign); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar txLastBits uint8\n\tif reqMode == piccRequestReqAll {\n\t\ttxLastBits = 0x07\n\t} else {\n\t\ttxLastBits = 0x00\n\t}\n\n\tsendData := []byte{reqMode}\n\tif err := d.communicateWithPICC(commandRegTransceive, sendData, answer, txLastBits, false); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 71.52928398254389}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\tswitch reqMode {\n\tcase piccCommandReqAll:\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase piccCommandReqIDLE:\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.writeByteData(regBitFraming, bitFramingReg8Bit); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase piccCommandReqSAK:\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.writeByteData(regBitFraming, bitFramingReg8Bit); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown request mode %d\", reqMode)\n\t}\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tif err := d.communicateWithPICC(commandRegTransceive, []byte{reqMode}, answer, txLastBits, false); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.23925580942813}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n\t\treturn err\n\t}\n\n\tswitch reqMode {\n\tcase piccRequestIDLE:\n\t\tbreak\n\tcase piccRequestAll:\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegKeyAll); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase piccRequestKeyA:\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegKeyA); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase piccRequestKeyB:\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.writeByteData(regBitFraming, bitFramingRegKeyB); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown request mode: %d\", reqMode)\n\t}\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tif reqMode == piccRequestIDLE {\n\t\ttxLastBits = 0x07\n\t}\n\n\tsendCommand := []byte{piccCommandRequest, reqMode}\n\tif err := d.communicateWithPICC(commandRegTransceive, sendCommand, answer, txLastBits, false); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.322370745046385}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(1 * time.Millisecond)\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 81.2832076737592}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// trigger one step\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// wait for 1ms\n\ttime.Sleep(1 * time.Millisecond)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 81.2832076737592}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger one step by setting the step pin low:\n\tif err := d.digitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for 1ms:\n\ttime.Sleep(1 * time.Millisecond)\n\n\t// Set the step pin high again:\n\tif err := d.digitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number based on the direction:\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 81.2832076737592}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitor is already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\tfmt.Printf(\\\"error measuring distance: %v\\\", err)\n\t\t\t}\n\n\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.061788145369654}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tcase <-time.After(hcsr04MonitorUpdate):\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\\\"error on measure distance: %v\n\\\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}", "CodeBleu_score": 55.94594038346139}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\\\"error on measure distance: %v\\\", err)\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}\n\n\td.distanceMonitorStopWaitGroup.Wait()\n\td.distanceMonitorStopChan = nil\n\td.distanceMonitorStopWaitGroup = nil\n}", "CodeBleu_score": 62.57593687489991}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp int64\n\n\treturn func(evt int, timestamp time.Duration, pinID string, seqno uint32, lineSeqno uint32) {\n\t\tif evt == gobot.DigitalPinFallingEdge {\n\t\t\tif startTimestamp != 0 {\n\t\t\t\td.delayMicroSecChan <- time.Since(time.Unix(0, startTimestamp)).Microseconds()\n\t\t\t\tstartTimestamp = 0\n\t\t\t}\n\t\t}\n\t\tif evt == gobot.DigitalPinRisingEdge {\n\t\t\tstartTimestamp = timestamp.Nanoseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 51.228542863808514}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTime time.Time\n\n\treturn func(pin int, timestamp time.Duration, _ string, _ uint32, _ uint32) {\n\t\tif d.hcsr04Cfg.useEdgePolling {\n\t\t\treturn\n\t\t}\n\n\t\tswitch pin {\n\t\tcase 0:\n\t\t\tstartTime = time.Now()\n\t\tcase 1:\n\t\t\td.delayMicroSecChan <- int64(time.Since(startTime) / time.Microsecond)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"unexpected pin '%d' for '%s'\\\", pin, d.driverCfg.name))\n\t\t}\n\t}\n}", "CodeBleu_score": 45.867622339107605}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, timestamp time.Duration, event string, seqno uint32, lineSeqno uint32) {\n\t\tswitch event {\n\t\tcase \\\"rising\\\":\n\t\t\tstartTimestamp = time.Now()\n\t\tcase \\\"falling\\\":\n\t\t\td.delayMicroSecChan <- int64(time.Since(startTimestamp) / time.Microsecond)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\\\"unknown event '%s' for '%s'\\\", event, d.driverCfg.name))\n\t\t}\n\t}\n}", "CodeBleu_score": 40.74136820750183}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger measurement\n\tif err := d.triggerPin.Write(1); err != nil {\n\t\treturn fmt.Errorf(\"error on write to trigger pin: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulseWidth)\n\tif err := d.triggerPin.Write(0); err != nil {\n\t\treturn fmt.Errorf(\"error on write to trigger pin: %v\", err)\n\t}\n\n\t// wait for measurement\n\tselect {\n\tcase d.lastMeasureMicroSec = <-d.delayMicroSecChan:\n\tcase <-time.After(hcsr04MeasureTimeout):\n\t\treturn fmt.Errorf(\\\"timeout while measuring distance for '%s'\\\", d.driverCfg.name)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.600681226171325}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// lock the mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\tif err := d.triggerPin.Write(1); err != nil {\n\t\treturn fmt.Errorf(\"error on write to trigger pin: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulseWidth)\n\tif err := d.triggerPin.Write(0); err != nil {\n\t\treturn fmt.Errorf(\"error on write to trigger pin: %v\", err)\n\t}\n\n\t// wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase d.lastMeasureMicroSec = <-d.delayMicroSecChan:\n\tcase <-time.After(hcsr04MeasureTimeout):\n\t\treturn fmt.Errorf(\"measurement timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.91000698206788}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerPin.DigitalWrite(1); err != nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulseWidth)\n\tif err := d.triggerPin.DigitalWrite(0); err != nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\tselect {\n\tcase d.lastMeasureMicroSec = <-d.delayMicroSecChan:\n\tcase <-time.After(hcsr04MeasureTimeout):\n\t\treturn fmt.Errorf(\\\"timeout while waiting for echo pin\\\")\n\t}\n\n\n\treturn nil\n}", "CodeBleu_score": 60.83386941732615}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if os.environ.get(\\\"PLATFORMIO_AUTH_TOKEN\\\"):\n        return os.environ.get(\\\"PLATFORMIO_AUTH_TOKEN\\\")\n    if not self.is_authenticated():\n        raise AccountNotAuthorized()\n    if self.is_access_token_valid():\n        return self.get_access_token()\n    if self.is_refresh_token_valid():\n        self.fetch_authentication_data()\n        return self.get_access_token()\n    raise AccountNotAuthorized()\n\n\n", "CodeBleu_score": 16.904925282021203}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.environ.get(\\\"PLATFORMIO_AUTH_TOKEN\\\"):\n        return os.environ.get(\\\"PLATFORMIO_AUTH_TOKEN\\\")\n    if not app.get_state_item(\\\"account\\\"):\n        raise AccountNotAuthorized()\n    auth = app.get_state_item(\\\"account\\\").get(\\\"auth\\\")\n    if not auth:\n        raise AccountNotAuthorized()\n    if auth.get(\\\"access_token\\\") and auth.get(\\\"expires_at\\\") > time.time():\n        return auth.get(\\\"access_token\\\")\n    if not auth.get(\\\"refresh_token\\\"):\n        raise AccountNotAuthorized()\n    try:\n        data = self.fetch_json_data(\\\"auth/token\\\", method=\\\"POST\\\",\n                                     data={\\\"refresh_token\\\": auth.get(\\\"refresh_token\\\")})\n        app.set_state_item(\\\"account\\\", {\\\"auth\\\": data})\n        return data.get(\\\"access_token\\\")\n    except HTTPClientError as exc:\n        raise AccountNotAuthorized() from exc\n\n\n", "CodeBleu_score": 41.929215832184255}, {"code": "def fetch_authentication_token(self)\n\t\n    if os.getenv(\\\"PLATFORMIO_AUTH_TOKEN\\\"):\n        return os.getenv(\\\"PLATFORMIO_AUTH_TOKEN\\\")\n    account = app.get_state_item(\\\"account\\\")\n    if not account:\n        raise AccountNotAuthorized()\n    auth = account.get(\\\"auth\\\")\n    if not auth:\n        raise AccountNotAuthorized()\n    if auth.get(\\\"access_token\\\") and auth.get(\\\"expires_at\\\") > time.time():\n        return auth[\\\"access_token\\\"]\n    if not auth.get(\\\"refresh_token\\\"):\n        raise AccountNotAuthorized()\n    try:\n        auth = self.fetch_json_data(\\\"auth/token\\\",\n                                     method=\\\"POST\\\",\n                                     data={\\\"refresh_token\\\": auth[\\\"refresh_token\\\"]})\n        account[\\\"auth\\\"] = auth\n        app.set_state_item(\\\"account\\\", account)\n        return auth[\\\"access_token\\\"]\n    except HTTPClientError as exc:\n        raise AccountNotAuthorized() from exc\n\n\n", "CodeBleu_score": 38.15583242912812}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.425290718503334}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.425290718503334}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 64.31288061280071}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.get_installed_packages():\n        data = {\"name\": pkg.metadata.name, \"version\": str(pkg.metadata.version)}\n        if pkg.metadata.external:\n            data[\"source\"] = pkg.metadata.source\n        result.append(data)\n    return result", "CodeBleu_score": 35.87041232725618}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.get_installed_packages():\n        data = {\n            \"name\": pkg.metadata.name,\n            \"version\": str(pkg.metadata.version),\n        }\n        if pkg.metadata.is_external():\n            data[\"source\"] = pkg.metadata.source_url\n        result.append(data)\n    return result", "CodeBleu_score": 34.884819741408556}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for pkg in self.get_installed_packages():\n        metadata = pkg.metadata\n        if metadata.external:\n            result.append({\"name\": metadata.name, \"version\": metadata.version, \"source\": metadata.source})\n        else:\n            result.append({\"name\": metadata.name, \"version\": metadata.version})\n    return result\n\n", "CodeBleu_score": 24.4224387962436}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not isinstance(env, ProjectConfig.Section):\n        env = ProjectConfig.get_env(env)\n    if not env.get(ProjectConfig.SECTION_ENV_PLATFORM):\n        raise UndefinedEnvPlatformError(env.name)\n    p = cls.new(env.get(ProjectConfig.SECTION_ENV_PLATFORM), autoinstall=autoinstall)\n    p.configure_project(env)\n    p.configure_packages(env, targets)\n    return p", "CodeBleu_score": 43.77998370069779}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not isinstance(env, ProjectConfig.EnvConfig):\n        env = ProjectConfig.get_env(env)\n    if not env.get_platform():\n        raise UndefinedEnvPlatformError(env.name)\n    _instance = cls.new(env.get_platform(), autoinstall=autoinstall)\n    _instance.configure_project(env)\n    _instance.configure_packages(env, targets)\n    return _instance", "CodeBleu_score": 43.081445823579344}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    spec = ProjectConfig.get_env(env)\n    if not spec:\n        raise UndefinedEnvPlatformError(env)\n    _instance = cls.new(spec[\"platform\"], autoinstall=autoinstall)\n    _instance.configure_project_env(env)\n    _instance.configure_project_packages(env, targets)\n    return _instance", "CodeBleu_score": 50.06215620396526}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.96762498070593}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.96762498070593}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire1.read();\n    }\n}", "CodeBleu_score": 80.96762498070593}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us) {\n        SetTimerWakeup(time_in_us);\n    } else {\n        SetDSpinWakeup(0);\n    }\n    Write1Byte(0x32, Read8bit(0x32) | (1UL << 6));  // Turn on timer wakeup\n    ESP.deepSleep(time_in_us);\n}", "CodeBleu_score": 50.86137439101597}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        SetTimerWakeup(time_in_us);\n    } else {\n        Wire1.beginTransmission(0x34);\n        Wire1.write(0x39);\n        Wire1.write(0x00);\n        Wire1.endTransmission();\n    }\n    ESP.deepSleep(time_in_us);\n}", "CodeBleu_score": 56.4879256703811}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        SetTimerWakeup(time_in_us);\n    } else {\n        Wire1.beginTransmission(0x34);\n        Wire1.write(0x39);\n        Wire1.write(0x00);\n        Wire1.endTransmission();\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 51.83159073175049}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  //Serial.println(F(\"scroll_line()\"));\n  int y = yStart;\n\n  if (yDraw >= yArea) {\n    yDraw = yStart;\n\n    if (!tteBar) {\n      yStart = TOP_FIXED_AREA;\n      yArea = YMAX - TOP_FIXED_AREA - BOT_FIXED_AREA;\n    } else {\n      yStart = TOP_FIXED_AREA_2;\n      yArea = YMAX - TOP_FIXED_AREA_2 - BOT_FIXED_AREA;\n    }\n\n    tft.fillRect(0, yStart, TFT_WIDTH, yArea, TFT_BLACK);\n    tft.setScrollAddress(0, yStart);\n\n    for (uint8_t i = 0; i < 18; i++) {\n      if (blank[i] > 0) {\n        tft.fillRect(blank[i], yStart + (i * TEXT_HEIGHT), TFT_WIDTH - blank[i], TEXT_HEIGHT, TFT_BLACK);\n        blank[i] = 0;\n      }\n    }\n  }\n\n  tft.fillRect(0, yDraw, TFT_WIDTH, TEXT_HEIGHT, color);\n  yDraw += TEXT_HEIGHT;\n  return y;\n}", "CodeBleu_score": 44.73455090820691}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int yPrev = yDraw;\n\n  if (yDraw < YMAX - BOT_FIXED_AREA - TEXT_HEIGHT) {\n    yDraw += TEXT_HEIGHT;\n  } else {\n    yDraw = YMAX - BOT_FIXED_AREA - TEXT_HEIGHT;\n  }\n\n  if (!tteBar) {\n    tft.fillRect(0, yStart, SCREEN_WIDTH, TEXT_HEIGHT, color);\n  } else {\n    tft.fillRect(0, yStart, SCREEN_WIDTH, TEXT_HEIGHT, color);\n  }\n\n  return yPrev;\n}", "CodeBleu_score": 32.09570363332911}, {"code": "int Display::scroll_line(uint32_t color){\n\t  //Serial.println(F(\"scroll_line()\"));\n  int yPrev = yStart;\n  yStart = (yStart + TEXT_HEIGHT) % yArea;\n  if (yStart < TOP_FIXED_AREA) {\n    yStart = TOP_FIXED_AREA;\n  }\n  else if (yStart < TOP_FIXED_AREA_2) {\n    yStart = TOP_FIXED_AREA_2;\n  }\n  tft.fillRect(0, yPrev, SCREEN_WIDTH, TEXT_HEIGHT, color);\n  tft.setScrollAddress(0, yStart);\n  return yPrev;\n}", "CodeBleu_score": 30.39550919474602}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  bool success = true;\n\n  if (access_points != NULL) {\n    if (access_points->size() > 0) {\n      Serial.println(\\\"Evil Portal Found \\\" + (String)access_points->size() + \\\" Access Points\\\");\n\n      for (int i = 0; i < access_points->size(); i++) {\n        AccessPoint ap = access_points->get(i);\n\n        if (ap.ssid.length() > 0 && ap.password.length() > 0) {\n          if (!this->addAP(ap.ssid, ap.password)) {\n            success = false;\n          }\n        }\n      }\n    }\n  }\n\n  if (ssids != NULL) {\n    if (ssids->size() > 0) {\n      Serial.println(\\\"Evil Portal Found \\\" + (String)ssids->size() + \\\" SSIDs\\\");\n\n      for (int i = 0; i < ssids->size(); i++) {\n        ssid s = ssids->get(i);\n\n        if (s.ssid.length() > 0 && s.password.length() > 0) {\n          if (!this->addSSID(s.ssid, s.password)) {\n            success = false;\n          }\n        }\n      }\n    }\n  }\n\n  if (this->has_ap || this->has_html) {\n    this->runServer = true;\n  }\n\n  if (this->runServer) {\n    this->start();\n  }\n\n  return success;\n}", "CodeBleu_score": 42.17505417307683}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setup_access_points())\n    return false;\n\n  if (!this->setup_html_content())\n    return false;\n\n  this->start();\n\n  return true;\n}", "CodeBleu_score": 60.65513199740493}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setup_ap()) {\n    return false;\n  }\n\n  if (!this->setup_html()) {\n    return false;\n  }\n\n  this->runServer = true;\n  this->start_server();\n\n  return true;\n}", "CodeBleu_score": 57.636123332641}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t  if(!this->queue_enabled_flag) {\n    this->flush_queue();\n    this->queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 17.142725487217604}, {"code": "void GpsInterface::enable_queue(){\n\t  if(!this->queue_enabled_flag){\n    this->flush_queue();\n    this->queue_enabled_flag=true;\n  }\n  else if(!this->queue) this->new_queue();\n  else if(!this->text) this->text=new LinkedList<String>;\n  else if(!this->text_in) this->text_in=new LinkedList<String>;\n}", "CodeBleu_score": 47.09128883275578}, {"code": "void GpsInterface::enable_queue(){\n\t  if(!this->queue_enabled_flag) {\n    this->flush_queue();\n    this->queue_enabled_flag=true;\n  }\n  else {\n    if(!this->queue)\n      this->new_queue();\n    if(!this->text)\n      this->new_text();\n    if(!this->text_in)\n      this->new_text_in();\n  }\n}", "CodeBleu_score": 35.93834766294747}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    if (this->queue->size()) {\n      LinkedList<nmea_sentence_t> *delme = this->queue;\n      this->queue = new LinkedList<nmea_sentence_t>;\n      delete delme;\n    }\n  } else\n    this->queue = new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 66.07664604843404}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    if (this->queue->size()) {\n      LinkedList<nmea_sentence_t> *delme = this->queue;\n      this->queue = new LinkedList<nmea_sentence_t>;\n      delete delme;\n    }\n  } else\n    this->new_queue();\n}", "CodeBleu_score": 76.98311416620582}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (this->queue) {\n    if (this->queue->size()) {\n      LinkedList<nmea_sentence_t> *delme = this->queue;\n      this->queue = new LinkedList<nmea_sentence_t>;\n      delete delme;\n    }\n  } else\n    this->queue = new LinkedList<nmea_sentence_t>;\n}", "CodeBleu_score": 66.07664604843404}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n    uint32_t x = area->x1;\n    uint32_t y = area->y1;\n    uint8_t *p_color = (uint8_t *)color_p;\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(x, y, w, h);\n    display_obj.tft.pushColors(&p_color[0], w * h, true);\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 54.293861893520436}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n    uint32_t pixels_cnt = w * h;\n    uint32_t byte_cnt = pixels_cnt * 2;\n    uint16_t *color_p_copy = (uint16_t *) color_p;\n    uint16_t color_p_copy_temp[pixels_cnt];\n    for (uint32_t i = 0; i < pixels_cnt; i++) {\n      color_p_copy_temp[i] = __builtin_bswap16(color_p_copy[i]);\n    }\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.pushColors((uint16_t *) &color_p_copy_temp, pixels_cnt, true);\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 50.957250162648116}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tln(\\\"C(Hold) - Exit\\\");\n            pressed = false;\n          }", "CodeBleu_score": 4.254616802858982}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tln(\\\"C(Hold) - Exit\\\");\n            pressed = false;\n          }", "CodeBleu_score": 4.254616802858982}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tln(\\\"C(Hold) - Exit\\\");\n            pressed = false;\n          }", "CodeBleu_score": 4.254616802858982}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  for (int i = 0; i < count; i++) {\n    String essid = \"\";\n    for (int j = 0; j < 6; j++) {\n      essid += (char)random(32, 127);\n    }\n    addSSID(essid);\n  }\n\n  return ssids->size();\n}", "CodeBleu_score": 31.01947987914701}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  for (int i = 0; i < count; i++) {\n    String essid = \"\";\n    for (int j = 0; j < 6; j++) {\n      essid += (char)random(65, 91);\n    }\n    addSSID(essid);\n  }\n  return count;\n}", "CodeBleu_score": 27.96971664672285}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int num_added = 0;\n  for (int i = 0; i < count; i++) {\n    String essid = \"\";\n    for (int j = 0; j < 6; j++) {\n      essid += (char)random(65, 91); // Generate a random uppercase letter\n    }\n    if (addSSID(essid))\n      num_added++;\n  }\n  return num_added;\n}", "CodeBleu_score": 34.17516581023249}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.58447548238634}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 75.24423914554694}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Capturing preview image...')\n        os.system('fswebcam -r 1280x720 --no-banner /home/pi/preview.jpg')\n        print('Uploading preview image...')\n        upload_blob('preview.jpg', 'preview.jpg', 'preview-images')\n        print('Publishing preview image URL...')\n        publish_messages('iot-project-370111', 'events', 'https://storage.googleapis.com/preview-images/preview.jpg')\n    else:\n        print('off')\n", "CodeBleu_score": 32.241910115445485}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        print(\"capturing image\")\n        os.system(\"raspistill -w 1024 -h 768 -q 100 -o /home/pi/Desktop/image.jpg\")\n        print(\"image captured\")\n        print(\"uploading image\")\n        upload_blob(\"pi-iot-2023\", \"/home/pi/Desktop/image.jpg\", \"image.jpg\")\n        print(\"image uploaded\")\n        print(\"publishing message\")\n        publish_messages(\"pi-iot-2023\", \"events\", \"https://storage.googleapis.com/pi-iot-2023/image.jpg\")\n        print(\"message published\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 38.27515712761399}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('on')\n        url = capture_preview()\n        upload_file(url)\n        publish_messages(project_id, topic_name, url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 36.29923214521833}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Example Google Cloud IoT MQTT device connection code.'\n    )\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Cloud IoT Core subscription name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 60.90272284420855}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument('--project_id', default=os.environ.get(\\\"GOOGLE_CLOUD_PROJECT\\\"), help='GCP cloud project name')\n    parser.add_argument('--subscription_name', required=True, help='Cloud IoT Core subscription name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 53.43411205214783}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Example Google Cloud IoT MQTT device connection code.'\n    )\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Cloud IoT Core MQTT topic name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 61.17259432206045}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = '{}?version={}'.format(\n        discovery_api, api_version)\n\n    return discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)\n\n", "CodeBleu_score": 70.99417316749474}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_api = \"https://cloudiot.googleapis.com/$discovery/rest?version={}\".format(\n        api_version\n    )\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n    discovery_url = discovery_api\n    return discovery.build(\"cloudiotcore\", api_version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials)\n\n", "CodeBleu_score": 46.99064741991572}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_account_info = json.load(open(service_account_json))\n    credentials = service_account.Credentials.from_service_account_info(service_account_info, scopes=api_scopes)\n    service = discovery.build('cloudiotcore', api_version, discoveryServiceUrl=discovery_api_url, credentials=credentials)\n    return service\n\n", "CodeBleu_score": 26.89241596103715}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = _asn1_hash_algorithms[hash_method]\n    if not asn1_code:\n        raise NotImplementedError('unsupported hash method: %s' % hash_method)\n\n    padded = _pad_for_signing(asn1_code + hash_value, common.byte_size(priv_key.n))\n    padded_hash = transform.bytes2int(padded)\n    encrypted = priv_key.sign(padded_hash, None, None)\n    block = transform.int2bytes(encrypted, common.byte_size(priv_key.n))\n\n    return block\n\n", "CodeBleu_score": 48.03384947149439}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    asn1_code = _get_hash_algo(hash_method).asn1_code\n    if asn1_code is None:\n        raise TypeError(\"Unsupported hash type\")\n\n    padded = _pad_for_signing(asn1_code + hash_value, common.byte_size(priv_key.n))\n    payload = transform.bytes2int(padded)\n    encrypted = core.encrypt_int(payload, priv_key.d, priv_key.n)\n    block = transform.int2bytes(encrypted, common.byte_size(priv_key.n))\n\n    return block\n\n", "CodeBleu_score": 47.35028849326734}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    # Verify that the hash method is supported\n    if hash_method not in HASH_ASN1:\n        raise TypeError('Unsupported hash type')\n\n    # Convert the hash value to a byte block\n    hash_bytes = hash_value.to_bytes(hash_value.bit_length() // 8 + 1, byteorder='big')\n\n    # Construct the ASN1 code for the hash method\n    asn1_code = HASH_ASN1[hash_method]\n\n    # Concatenate the ASN1 code and hash value\n    data = asn1_code + hash_bytes\n\n    # Pad the data for signing\n    padded_data = _pad_for_signing(data, common.byte_size(priv_key.n))\n\n    # Encrypt the padded data using the private key\n    encrypted_data = encrypt(padded_data, priv_key)\n\n    # Return the encrypted signature as a byte block\n    return encrypted_data\n\n", "CodeBleu_score": 48.604133772298674}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    blocksize = common.byte_size(pub_key.n)\n    encrypted = transform.bytes2int(signature)\n    decrypted = pub_key.encrypt(encrypted, None)\n    clearsig = transform.int2bytes(decrypted, blocksize)\n\n    # Find the start of the ASN.1 sequence in the clearsig\n    try:\n        start = clearsig.index(b'\\x00\\x01\\xff') + 3\n    except ValueError:\n        raise VerificationError('Verification failed')\n\n    # Verify that the clearsig starts with the correct ASN.1 sequence\n    if clearsig[0:start] != b'\\x00\\x01\\xff':\n        raise VerificationError('Verification failed')\n\n    # Find the length of the ASN.1 sequence\n    seq_len = clearsig[start]\n    if seq_len != len(clearsig) - start - 1:\n        raise VerificationError('Verification failed')\n\n    # Extract the hash method and the hash\n    hash_method = clearsig[start + 1]\n    if hash_method not in HASH_ASN1:\n        raise VerificationError('Verification failed')\n\n    start += 2\n    hash_len = clearsig[start]\n    start += 1\n    hash_value = clearsig[start:start + hash_len]\n\n    # Compute the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the padded hash\n    pad = b'\\x00' * (blocksize - len(msg_hash) - 3)\n    padded_hash = b'\\x00\\x01' + pad + b'\\x00' + msg_hash\n\n    # Verify that the padded hash matches the clearsig\n    if padded_hash != clearsig[start + hash_len:]:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 42.898929740979696}, {"code": "def verify(message, signature, pub_key)\n\t\n    blocksize = common.byte_size(pub_key.n)\n\n    encrypted = transform.bytes2int(signature)\n    decrypted = pub_key.blinded_decrypt(encrypted)\n    clearsig = transform.int2bytes(decrypted, blocksize)\n\n    # Find the start of the hash method marker\n    try:\n        idx = clearsig.index(b'\\x00', 2)\n    except ValueError:\n        raise VerificationError('Verification failed')\n\n    # Separate the hash method from the rest of the signature\n    hash_method = clearsig[:idx]\n    hash_value = clearsig[idx + 1:]\n\n    # Get the ASN1 code for this hash method\n    if hash_method not in HASH_ASN1:\n        raise VerificationError('Unsupported hash type')\n    asn1code = HASH_ASN1[hash_method]\n\n    # Verify the signature\n    msg_hash = compute_hash(message, hash_method)\n    padded = asn1code + msg_hash\n\n    if clearsig != padded:\n        raise VerificationError('Verification failed')\n\n    return hash_method.decode()\n\n", "CodeBleu_score": 44.468509550193225}, {"code": "def verify(message, signature, pub_key)\n\t\n    blocksize = common.byte_size(pub_key.n)\n    encrypted = transform.bytes2int(signature)\n    decrypted = pub_key.blinded_decrypt(encrypted)\n    clearsig = transform.int2bytes(decrypted, blocksize)\n\n    # Find the start of the hash method marker\n    try:\n        idx = clearsig.index(b'\\x00', 2)\n    except ValueError:\n        raise VerificationError('Verification failed')\n\n    # Separate the hash method from the rest of the signature\n    hash_method = clearsig[:idx]\n    hash_len = _hash_info(hash_method).hash_size\n    clearsig = clearsig[idx + 1:]\n\n    # Check the length of the signature\n    if len(clearsig) != hash_len:\n        raise VerificationError('Verification failed')\n\n    # Get the hash type\n    hash_method = _hash_info(hash_method)\n\n    # Verify the hash\n    hasher = hash_method.new()\n    hasher.update(message)\n    digest = hasher.digest()\n\n    if clearsig != digest:\n        raise VerificationError('Verification failed')\n\n    return hash_method.name\n\n", "CodeBleu_score": 42.662254767586624}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    uint32_t currentTime = getCurrentTime();\n    if (currentTime != 0) {\n        updateJWT(currentTime);\n    }\n    mqtt_connect();\n    sendSubscribe = true;\n    debug_printError(\"CLOUD: Connecting to MQTT\");\n}", "CodeBleu_score": 36.11992928834533}, {"code": "static void connectMQTT(){\n\t    uint32_t currentTime;\n    uint32_t epoch;\n\n    currentTime = CLOCK_getCurrentTime();\n\n    if (currentTime != 0) {\n        epoch = currentTime + UNIX_OFFSET;\n        updateJWT(epoch);\n    }\n\n    if (connectMQTTSocket() == MQTT_SUCCESS) {\n        sendSubscribe = true;\n    }\n\n    debug_printError(\"CLOUD: Connecting to MQTT\");\n}", "CodeBleu_score": 56.23088045559817}, {"code": "static void connectMQTT(){\n\t    // Get the current time\n    uint32_t epoch = getEpochTime();\n    // Update the JWT with the current time\n    updateJWT(epoch);\n    // Connect to the MQTT client\n    connectMQTTSocket();\n    // Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n    sendSubscribe = true;\n    // Print a debug message indicating the MQTT connection attempt\n    debug_printError(\"CLOUD: Attempting to connect to MQTT\");\n}", "CodeBleu_score": 24.614172192450752}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    int i;\n\n    // Check each character to ensure it is a digit\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        value = value * 10 + (str[i] - '0');\n    }\n\n    // Check if the number is too large to handle\n    if (value > UINT32_MAX) {\n        return str;\n    }\n\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 29.92520540021914}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t result = 0;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        if (*str < '0' || *str > '9') {\n            return str;\n        }\n        result = result * 10 + (*str - '0');\n        str++;\n    }\n\n    *num = result;\n    return str;\n}", "CodeBleu_score": 29.72370929811945}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t tmp = 0;\n    int i;\n\n    // Check each character to ensure it is a digit\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;  // Error: non-digit character\n        }\n\n        // Calculate the numeric value of the digit\n        tmp = tmp * 10 + (str[i] - '0');\n    }\n\n    // Check if the number is within the range of uint32_t\n    if (tmp > UINT32_MAX) {\n        return str;  // Error: number too large\n    }\n\n    *num = tmp;\n    return str + width;\n}", "CodeBleu_score": 31.15957000554454}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return atcacert_verify_signature(tbs_digest, signature, ca_public_key);\n}", "CodeBleu_score": 72.7797096556414}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    int     ret;\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcac_verify_extern(tbs_digest, signature, ca_public_key, NISTP256);\n    if (ret == 0) {\n        return ATCACERT_E_VERIFY_FAILED;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 80.27993492428125}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t tbs_size;\n    uint8_t tbs_offset;\n\n    if (cert_def == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    tbs_size = cert_def->tbs_cert_size;\n    tbs_offset = cert_def->tbs_cert_offset;\n\n    if (tbs_offset + tbs_size > cert_size) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    if (cert_def->signature_size == 0) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    if (cert_def->signature_offset + cert_def->signature_size > cert_size) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    memcpy(signature, cert + cert_def->signature_offset, cert_def->signature_size);\n\n    ret = atcacert_verify_signature(tbs_digest, signature, ca_public_key);\n\n    return ret;\n}", "CodeBleu_score": 66.24484325454127}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *prev = NULL;\n    timerStruct_t *next = *list;\n    while(next != NULL)\n    {\n        if(next == timer)\n        {\n            if(prev == NULL)\n            {\n                *list = next->next;\n            }\n            else\n            {\n                prev->next = next->next;\n            }\n            return true;\n        }\n        prev = next;\n        next = next->next;\n    }\n    return false;\n}", "CodeBleu_score": 37.25172295384597}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *next = &((*prev)->next);\n    while(*next != NULL)\n    {\n        if(*next == timer)\n        {\n            *prev = (*next)->next;\n            return true;\n        }\n        prev = next;\n        next = &((*prev)->next);\n    }\n    return false;\n}", "CodeBleu_score": 26.456210234010065}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *listPtr = list;\n    while (*listPtr != NULL)\n    {\n        if (*listPtr == timer)\n        {\n            *listPtr = timer->next;\n            return true;\n        }\n        listPtr = &((*listPtr)->next);\n    }\n    return false;\n}", "CodeBleu_score": 22.019029199698796}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t    packetReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n    if (!bsdSocket) {\n        debug_printError(\"BSD: close error unknown socket number\");\n        bsd_setErrNo(ENOTSOCK);\n        return BSD_ERROR;\n    } else {\n        bsdSocket->socketState = NOT_A_SOCKET;\n        if (close(socket) != WINC_SOCK_ERR_NO_ERROR) {\n            debug_printError(\"BSD: close error\");\n            bsd_setErrNo(EIO);\n            return BSD_ERROR;\n        } else {\n            debug_printGOOD(\"BSD: close success\");\n            return BSD_SUCCESS;\n        }\n    }\n}", "CodeBleu_score": 45.58490636142365}, {"code": "int BSD_close(int socket){\n\t    packetReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n    if(!bsdSocket)\n    {\n        debug_printError(\"BSD: close error unknown socket number\");\n        bsd_setErrNo(ENOTSOCK);\n        return BSD_ERROR;\n    }\n    else\n    {\n        bsdSocket->socketState = NOT_A_SOCKET;\n        wincSocketResponses_t wincCloseReturn = close(socket);\n        if(wincCloseReturn != WINC_SOCK_ERR_NO_ERROR)\n        {\n            switch(wincCloseReturn)\n            {\n                case WINC_SOCK_ERR_INVALID_ARG:\n                    debug_printError(\"BSD: close error invalid argument\");\n                    bsd_setErrNo(EINVAL);\n                    break;\n                case WINC_SOCK_ERR_INVALID:\n                    debug_printError(\"BSD: close error invalid\");\n                    bsd_setErrNo(EIO);\n                    break;\n                case WINC_SOCK_ERR_INVALID_SOCKET:\n                    debug_printError(\"BSD: close error invalid socket\");\n                    bsd_setErrNo(ENOTSOCK);\n                    break;\n                default:\n                    debug_printError(\"BSD: close error (%d)\", wincCloseReturn);\n                    bsd_setErrNo(EIO);\n                    break;\n            }\n            return BSD_ERROR;\n        }\n        else\n        {\n            debug_printGOOD(\"BSD: socket (%d) closed\", socket);\n            return BSD_SUCCESS;\n        }\n    }\n}", "CodeBleu_score": 57.42136146164104}, {"code": "int BSD_close(int socket){\n\t    packetReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n    if(!bsdSocket) {\n        debug_printError(\"BSD: close error unknown socket number\");\n        bsd_setErrNo(ENOTSOCK);\n        return BSD_ERROR;\n    }\n    bsdSocket->socketState = NOT_A_SOCKET;\n    wincSocketResponses_t wincCloseReturn = close(socket);\n    if(wincCloseReturn != WINC_SOCK_ERR_NO_ERROR) {\n        switch(wincCloseReturn) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if(socket < 0) {\n                    debug_printError(\"BSD: ENOTSOCK\");\n                    bsd_setErrNo(ENOTSOCK);\n                } else {\n                    debug_printError(\"BSD: EINVAL\");\n                    bsd_setErrNo(EINVAL);\n                }\n            break;\n            case WINC_SOCK_ERR_INVALID:\n                debug_printError(\"BSD: EIO\");\n                bsd_setErrNo(EIO);\n            break;\n            default:\n                debug_printError(\"BSD: BSD: (%d)\", wincCloseReturn);\n            break;\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 58.92367138529148}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t    wincSocketResponses_t wincListenReturn;\n\n    debug_printGOOD(\"BSD: BSD_listen (%d, %d)\", socket, backlog);\n\n    wincListenReturn = listen((SOCKET) socket, (uint8_t) backlog);\n\n    if (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n        switch (wincListenReturn) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if (socket < 0) {\n                    bsd_setErrNo(ENOTSOCK);\n                } else if (backlog < 0) {\n                    bsd_setErrNo(EINVAL);\n                } else {\n                    bsd_setErrNo(EFAULT);\n                }\n                break;\n            case WINC_SOCK_ERR_INVALID:\n                bsd_setErrNo(EIO);\n                break;\n            default:\n                break;\n        }\n        return BSD_ERROR;\n    } else {\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 72.277364885807}, {"code": "int BSD_listen(int socket, int backlog){\n\t    wincSocketResponses_t wincListenReturn;\n\n    wincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n    if (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n        switch (wincListenReturn) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if (socket < 0) {\n                    bsd_setErrNo(ENOTSOCK);\n                } else if (backlog < 0) {\n                    bsd_setErrNo(EINVAL);\n                }\n                break;\n            case WINC_SOCK_ERR_INVALID:\n                bsd_setErrNo(EIO);\n                break;\n            default:\n                break;\n        }\n        return BSD_ERROR;\n    } else {\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 75.65104372303414}, {"code": "int BSD_listen(int socket, int backlog){\n\t    wincSocketResponses_t wincListenReturn;\n\n    debug_printGOOD(\"BSD: BSD_listen (%d) \", socket);\n\n    wincListenReturn = listen((SOCKET) socket, (uint8_t) backlog);\n\n    if (wincListenReturn != WINC_SOCK_ERR_NO_ERROR) {\n        switch (wincListenReturn) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if (socket < 0) {\n                    debug_printError(\"BSD: ENOTSOCK\");\n                    bsd_setErrNo(ENOTSOCK);\n                } else if (backlog < 0) {\n                    debug_printError(\"BSD: EINVAL\");\n                    bsd_setErrNo(EINVAL);\n                }\n                break;\n            case WINC_SOCK_ERR_INVALID:\n                debug_printError(\"BSD: EIO\");\n                bsd_setErrNo(EIO);\n                break;\n            default:\n                debug_printError(\"BSD: (%d)\", wincListenReturn);\n                break;\n        }\n        return BSD_ERROR;\n    } else {\n        debug_printGOOD(\"BSD: Listen Success\");\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 61.71371263099867}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    wincSocketResponses_t wincAcceptResponse;\n    static wincSupported_sockaddr winc_sockaddr;\n\n    winc_sockaddr.sa_family = addr->sa_family;\n    memcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n    switch(winc_sockaddr.sa_family) {\n        case PF_INET:\n            winc_sockaddr.sa_family = AF_INET;\n            wincAcceptResponse = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t)addrlen);\n        break;\n        default:\t\t//Address family not supported by WINC\n            bsd_setErrNo(EAFNOSUPPORT);\n            return BSD_ERROR;\n    }\n\n    if (wincAcceptResponse != WINC_SOCK_ERR_NO_ERROR) {\n        switch(wincAcceptResponse) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if(socket < 0) {\n                    bsd_setErrNo(ENOTSOCK);\n                }\n                else if(addr != NULL) {\n                    bsd_setErrNo(EFAULT);\n                }\n                else if(addrlen == 0) {\n                    bsd_setErrNo(EINVAL);\n                }\n            break;\n            case WINC_SOCK_ERR_INVALID:\n                bsd_setErrNo(EIO);\n            break;\n            default:\n            break;\n        }\n        return BSD_ERROR;\n    }\n    else {\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 74.41324467858131}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    wincSocketResponses_t wincAcceptResponse;\n    wincSupported_sockaddr winc_sockaddr;\n\n    winc_sockaddr.sa_family = addr->sa_family;\n    memcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n    switch(winc_sockaddr.sa_family) {\n        case PF_INET:\n            winc_sockaddr.sa_family = AF_INET;\n            wincAcceptResponse = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n        break;\n        default:\t\t//Address family not supported by WINC\n            bsd_setErrNo(EAFNOSUPPORT);\n            return BSD_ERROR;\n    }\n\n    if (wincAcceptResponse != WINC_SOCK_ERR_NO_ERROR) {\n        switch(wincAcceptResponse) {\n            case WINC_SOCK_ERR_INVALID_ARG:\n                if(socket < 0) {\n                    bsd_setErrNo(ENOTSOCK);\n                }\n                else if(addr != NULL) {\n                    bsd_setErrNo(EFAULT);\n                }\n                else if(addrlen == 0) {\n                    bsd_setErrNo(EINVAL);\n                }\n            break;\n            case WINC_SOCK_ERR_INVALID:\n                bsd_setErrNo(EIO);\n            break;\n            default:\n            break;\n        }\n        return BSD_ERROR;\n    }\n    else {\n        return BSD_SUCCESS;\n    }\n}", "CodeBleu_score": 76.99720155814502}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\tstatic wincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family)\n\t{\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(wincAcceptReturn)\n\t\t{\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr != NULL)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == 0)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_BUFFER_FULL:\n\t\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse\n\t{\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 78.09471463385611}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t    uint32_t currentTime = (uint32_t)time(NULL) + UNIX_OFFSET;\n\n    if (currentTime != 0) {\n        updateJWT(currentTime);\n        debug_printError(\"CLOUD: MQTT Connecting...\");\n        sendSubscribe = true;\n    }\n}", "CodeBleu_score": 39.226331182983785}, {"code": "static void connectMQTT(){\n\t   uint32_t epoch = 0;\n   // Get current time in UNIX format\n   epoch = time(NULL);\n\n   if (epoch != 0) {\n      // Update JWT with current time offset\n      updateJWT(epoch);\n      // Initiate MQTT connection\n      debug_printError(\"CLOUD: Connecting to MQTT broker\");\n      waitingForMQTT = true;\n      // Set flag to send MQTT SUBSCRIBE packet once connection is established\n      sendSubscribe = true;\n   }\n}", "CodeBleu_score": 33.19076841557166}, {"code": "static void connectMQTT(){\n\t    uint32_t currentTime;\n    int8_t ret;\n\n    currentTime = getCurrentTime();\n    if (currentTime != 0) {\n        updateJWT(currentTime);\n        ret = connectMQTTSocket();\n        if (ret == MQTT_SUCCESS) {\n            debug_printError(\"CLOUD: MQTT Connection Successful\");\n            waitingForMQTT = true;\n            sendSubscribe = true;\n        } else {\n            debug_printError(\"CLOUD: MQTT Connection Failed\");\n            waitingForMQTT = false;\n        }\n    } else {\n        debug_printError(\"CLOUD: MQTT Connection Failed: Invalid time\");\n        waitingForMQTT = false;\n    }\n}", "CodeBleu_score": 49.705020685933945}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t    debug_printInfo(\"CLOUD: MQTT Disconnect\");\n\n    if (MQTT_GetConnectionState() == CONNECTED) {\n        MQTT_CLIENT_disconnect();\n    }\n}", "CodeBleu_score": 72.48291970444728}, {"code": "void CLOUD_disconnect(void){\n\t    debug_printInfo(\"CLOUD: Disconnecting from cloud service\");\n    if (MQTT_CLIENT_getConnectionState() == CONNECTED) {\n        mqttConnectionInfo_t mqttConnectionInfo;\n        MQTT_CLIENT_getConnectionInfo(&mqttConnectionInfo);\n        MQTT_CLIENT_disconnect(&mqttConnectionInfo);\n    }\n}", "CodeBleu_score": 55.390846686859916}, {"code": "void CLOUD_disconnect(void){\n\t    debug_printInfo(\"CLOUD: Disconnecting from the cloud service\");\n    if (MQTT_GetConnectionStatus() == CONNECTED) {\n        MQTT_CLIENT_disconnect();\n    }\n}", "CodeBleu_score": 62.18728524644752}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    tstrWifiConnectParam param;\n    uint8_t wifi_creds = passed_wifi_creds;\n    uint8_t ret = M2M_SUCCESS;\n\n    if (wifi_creds == WIFI_CREDENTIALS_DEFAULT) {\n        // Use default credentials\n        param.u8secType = M2M_WIFI_SEC_OPEN;\n        param.u8SSIDLen = sizeof(DEFAULT_SSID) - 1;\n        param.au8SSID = (uint8_t *)DEFAULT_SSID;\n        param.u8PSKLen = 0;\n        param.au8PSK = NULL;\n    } else {\n        // Use new credentials\n        param.u8secType = M2M_WIFI_SEC_WPA_PSK;\n        param.u8SSIDLen = sizeof(SSID) - 1;\n        param.au8SSID = (uint8_t *)SSID;\n        param.u8PSKLen = sizeof(PASSWORD) - 1;\n        param.au8PSK = (uint8_t *)PASSWORD;\n    }\n\n    // Connect to Wi-Fi\n    ret = m2m_wifi_connect(&param);\n\n    if (ret != M2M_SUCCESS) {\n        // Connection failed\n        debug_printError(\\\"Failed to connect to Wi-Fi access point.\\\");\n        // Update networking error status\n        app_manager_update_networking_error_status(NETWORKING_ERROR_WIFI_CONNECT_FAILURE);\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 48.82120232693761}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  // Generate a client for the API\n  const client = generateClient();\n\n  // Send a GraphQL query to fetch sensor data\n  const response = await client.query({\n    query: listSensors,\n  });\n\n  // Log the API response\n  console.log(response);\n\n  // Check if the response contains data\n  if (response.data) {\n    console.log('Retrieved sensors');\n\n    // Iterate through each sensor\n    response.data.listSensors.items.forEach((sensor) => {\n      // Create a marker for the sensor\n      var marker = CreateSensorMarker(sensor);\n\n      // Place the marker on the map at the sensor's geographical coordinates\n      new Marker(marker)\n        .setLngLat([sensor.longitude, sensor.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 58.095210000698685}, {"code": "async function DisplaySensors(map){\n\t    const apiClient = generateClient();\n    const response = await apiClient.query({\n        query: listSensors\n    });\n    if (response.data) {\n        console.log(\"retrieved sensors: \" + response.data.listSensors.items.length)\n        response.data.listSensors.items.forEach((sensor) => {\n            var marker = CreateSensorMarker(sensor)\n            new Marker(marker).setLngLat([sensor.longitude, sensor.latitude]).addTo(map)\n        })\n    }\n}", "CodeBleu_score": 57.12931351696982}, {"code": "async function DisplaySensors(map){\n\t  const client = generateClient();\n  const response = await client.query({\n    query: listSensors,\n  });\n  console.log(response);\n  if (response.data.listSensors.items) {\n    console.log(\"retrieving sensors\");\n    response.data.listSensors.items.forEach((sensor) => {\n      var marker = CreateSensorMarker(sensor);\n      new Marker(marker).setLngLat([\n        sensor.location.longitude,\n        sensor.location.latitude,\n      ]).addTo(map);\n    });\n  }\n}", "CodeBleu_score": 60.02311009668365}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = '#000000';\n    marker.style.border = '2px solid #ffffff';\n    return marker;\n}", "CodeBleu_score": 45.18404941777827}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\n    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = 'blue';\n    marker.style.border = '2px solid black';\n    return marker;\n}", "CodeBleu_score": 44.00379214430668}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'marker';\n  marker.style.backgroundColor = 'blue';\n  marker.style.border = '2px solid black';\n  return marker;\n}", "CodeBleu_score": 42.58094397792411}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    module = await async_import_module(hass, module_path)\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed_reqs = hass.data.get(DATA_REQS)\n        if processed_reqs is None:\n            hass.data[DATA_REQS] = processed_reqs = set()\n\n        if module_path not in processed_reqs:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            processed_reqs.add(module_path)\n\n    return module\n\n", "CodeBleu_score": 45.79231215312891}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    module = await async_import_module(hass, module_path)\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed_reqs = hass.data.get(DATA_REQS, set())\n        if module_path not in processed_reqs:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            processed_reqs.add(module_path)\n            hass.data[DATA_REQS] = processed_reqs\n\n    return module\n\n", "CodeBleu_score": 42.7797986598053}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Error setting up mfa module %s: %s\", module_name, err)\n        raise HomeAssistantError() from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.config.skip_pip:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n\n    if module_path not in hass.data.setdefault(DATA_REQS, set()):\n        await requirements.async_process_requirements(hass, module_path, module.REQUIREMENTS)\n        hass.data[DATA_REQS].add(module_path)\n\n    return module\n", "CodeBleu_score": 58.933254693997924}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = setup_data[\"pin\"]\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": setup_data[\"pin\"]})\n\n", "CodeBleu_score": 65.54924069928073}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 80.42675528111758}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 80.42675528111758}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        self._user_settings = OrderedDict()\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {STORAGE_USERS: {}}\n\n        for user_id, user_data in data[STORAGE_USERS].items():\n            self._user_settings[user_id] = NotifySetting(**user_data)\n\n", "CodeBleu_score": 51.59416875931464}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._user_store.async_load()\n        if not data:\n            self._user_settings = {}\n            return\n\n        self._user_settings = {\n            user_id: NotifySetting(**user_data)\n            for user_id, user_data in data[STORAGE_USERS].items()\n        }\n\n", "CodeBleu_score": 48.60710580511869}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        try:\n            data = await self._user_store.async_load()\n        except (ValueError, KeyError):\n            data = None\n\n        if data is None:\n            data = {}\n\n        self._user_settings = {\n            user_id: NotifySetting(**user_data)\n            for user_id, user_data in data.get(STORAGE_USERS, {}).items()\n        }\n\n", "CodeBleu_score": 56.73221196005461}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    if (notify_setting := self._user_settings.get(user_id)) is None:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        _verify_otp,\n        notify_setting.secret,\n        user_input[INPUT_FIELD_CODE],\n        notify_setting.counter,\n    )\n\n", "CodeBleu_score": 81.76007471921605}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    if (notify_setting := self._user_settings.get(user_id)) is None:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        _verify_otp,\n        notify_setting.secret,\n        user_input[INPUT_FIELD_CODE],\n        notify_setting.counter,\n    )\n\n", "CodeBleu_score": 81.76007471921605}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    if (notify_setting := self._user_settings.get(user_id)) is None:\n        return False\n\n    return await self.hass.async_add_executor_job(\n        _verify_otp,\n        notify_setting.secret,\n        user_input[INPUT_FIELD_CODE],\n        notify_setting.counter,\n    )\n\n", "CodeBleu_score": 81.76007471921605}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n\n    if entity_entry is None or entity_entry.device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n\n    if device_entry is None or device_entry.area_id is None:\n        return None\n\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 86.25457105561063}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    if entity_entry.device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n\n    if device_entry is None or device_entry.area_id is None:\n        return None\n\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 81.8503052580568}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    if (entity_entry := perm_lookup.entity_registry.async_get(entity_id)) is None:\n        return None\n\n    if (\n        entity_entry.device_id is None\n        or (device_entry := perm_lookup.device_registry.async_get(entity_entry.device_id))\n        is None\n        or device_entry.area_id is None\n    ):\n        return None\n\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 59.67467652019498}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {\n                    subcategory: set.union(\n                        *[\n                            policy[category][subcategory]\n                            for policy in policies\n                            if category in policy and subcategory in policy[category]\n                        ]\n                    )\n                    for subcategory in subcategories\n                }\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 45.64010017982299}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = cast(CategoryType, {})\n            merged_policy[category] = {**merged_policy[category], **subcategories}\n\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 48.3523245835607}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen_categories = set()\n\n    for policy in policies:\n        for category, category_data in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {\n                    \"allow\": set(),\n                    \"deny\": set(),\n                    \"ask\": set(),\n                }\n            merged_policy[category][\"allow\"] |= category_data[\"allow\"]\n            merged_policy[category][\"deny\"] |= category_data[\"deny\"]\n            merged_policy[category][\"ask\"] |= category_data[\"ask\"]\n\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 41.85661820341759}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\\\n        _LOGGER.error(\"Error while importing %s auth provider\", provider)\n        raise HomeAssistantError(err) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed_reqs = hass.data.get(DATA_REQS, set())\n    if module in processed_reqs:\n        return module\n\n    processed_reqs.add(module)\n    hass.data[DATA_REQS] = processed_reqs\n\n    if not await requirements.async_process_requirements(\n        hass, f\"auth_provider {provider}\", module.REQUIREMENTS\n    ):\n        _LOGGER.debug(\n            \"Not loading auth provider %s because requirements were not met\", provider\n        )\n        return module\n\n    await requirements.async_get_integration_with_requirements(\n        hass, f\"auth_provider {provider}\", module.REQUIREMENTS\n    )\n\n    return module\n\n", "CodeBleu_score": 48.02258365778347}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(hass, f\"hass_nabucasa.auth.providers.{provider}\")\n\n    if not hasattr(module, \"REQUIREMENTS\") or not module.REQUIREMENTS:\n        return module\n\n    processed_reqs = hass.data.get(DATA_REQS)\n    if processed_reqs is None:\n        processed_reqs = hass.data[DATA_REQS] = set()\n\n    if provider in processed_reqs:\n        return module\n\n    await requirements.async_process_requirements(\n        hass, f\"auth_provider {provider}\", module.REQUIREMENTS\n    )\n    processed_reqs.add(provider)\n\n    return module\n\n", "CodeBleu_score": 42.16151195290318}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Error loading auth provider %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed_reqs = hass.data.get(DATA_REQS, set())\n    processed_reqs.add(provider)\n    hass.data[DATA_REQS] = processed_reqs\n\n    if hass.data.get(DATA_REQS) == processed_reqs:\n        await requirements.async_process_requirements(\n            hass, f\"auth_provider_{provider}\", module.REQUIREMENTS\n        )\n\n    return module\n\n", "CodeBleu_score": 48.977230983177265}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {}\n\n    self._data = data\n\n    # Check for non-normalized usernames\n    for user_id, users in data.items():\n        for user in users:\n            if user[\"username\"] != self.normalize_username(user[\"username\"]):\n                self._data[user_id] = [\n                    {\"username\": self.normalize_username(user[\"username\"]), \"name\": user[\"name\"]}\n                    for user in users\n                ]\n                break\n\n", "CodeBleu_score": 28.168960238069385}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {}\n    self._data = data\n\n    # Check for non-normalized usernames\n    for username, users in self._data.items():\n        if username != self.normalize_username(username):\n            self.is_legacy = True\n            break\n\n\n", "CodeBleu_score": 33.108711170994304}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        self._data = {}\n        return\n\n    self._data = data\n\n    for user_list in self._data.values():\n        for user in user_list:\n            if self.normalize_username(user[\"username\"]) != user[\"username\"]:\n                # Legacy mode will allow usernames to start/end with whitespace\n                # and will compare usernames case-insensitive.\n                # Deprecated in June 2019 and will be removed in 2026.7\n                self.is_legacy = True\n                break\n\n", "CodeBleu_score": 37.7101077465754}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n\n    for user in self.data.users:\n        if user[\"username\"] == username:\n            hash_ = base64.b64decode(user[\"password\"].encode())\n            break\n    else:\n        # Prevent timing attacks by doing a dummy check.\n        bcrypt.checkpw(password.encode(), dummy_hash)\n        raise InvalidAuth\n\n    if not bcrypt.checkpw(password.encode(), hash_):\n        raise InvalidAuth\n\n", "CodeBleu_score": 43.67258336268892}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n\n    for user in self.data.users:\n        if user[\"username\"] == username:\n            hash_ = base64.b64decode(user[\"password\"].encode())\n            try:\n                if bcrypt.checkpw(password.encode(), hash_):\n                    return\n            except ValueError as err:\n                raise InvalidAuth from err\n            raise InvalidAuth\n\n    # Prevent timing attack with dummy hash check\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 42.93519935778207}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.data.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.data.users:\n        if self.data.normalize_username(user[\"username\"]) == username:\n            if not bcrypt.checkpw(password.encode(\"utf-8\"), user[\"password_hash\"].encode(\"utf-8\")):\n                raise InvalidAuth\n            return\n\n    # Check if username exists to prevent timing attacks\n    for user in self.data.users:\n        if self.data.normalize_username(user[\"username\"]) == username:\n            bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n            raise InvalidAuth\n\n    raise InvalidAuth\n\n", "CodeBleu_score": 39.53441138239938}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    found = None\n\n    for index, user in enumerate(self.users):\n        if self.normalize_username(user[\"username\"]) == username:\n            found = index\n\n    if found is None:\n        raise InvalidUser(\"user_not_found\")\n\n    self.users.pop(found)\n\n", "CodeBleu_score": 54.72203164206655}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n\n    found = None\n\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            found = user\n\n    if found is None:\n        raise InvalidUser(\"user_not_found\")\n\n    self.users.remove(found)\n\n", "CodeBleu_score": 46.907360379659806}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    found = None\n\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            found = user\n\n    if found is None:\n        raise InvalidUser(\"user_not_found\")\n\n    self.users.remove(found)\n\n", "CodeBleu_score": 46.907360379659806}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 96.05282869816531}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    timeout_per_thread = timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout_per_thread)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            # Threads that are not running or have been interrupted\n            # cannot be joined or interrupted\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        try:\n            async_raise(thread.ident, SystemExit)\n        except SystemExit:\n            pass\n    return joined\n\n", "CodeBleu_score": 66.06997858165667}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    timeout_per_thread = timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout_per_thread)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            # Thread is not running\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    threads -= joined\n    attempt = 1\n    while threads and attempt <= MAX_LOG_ATTEMPTS:\n        attempt += 1\n        _LOGGER.warning(\n            \"Waiting for threads to finish: %s\",\n            \", \".join(thread.name for thread in threads),\n        )\n        time.sleep(1)\n        threads -= joined\n        for thread in threads:\n            if not thread.is_alive():\n                joined.add(thread)\n    for thread in threads:\n        if not thread.ident:\n            # Thread is not running\n            joined.add(thread)\n            continue\n        with contextlib.suppress(SystemExit):\n            async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 66.01931798905231}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    now = time.monotonic()\n    timeout_per_thread = timeout / len(threads)\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        remaining = timeout_per_thread - (time.monotonic() - now)\n        thread.join(timeout=max(remaining, 0))\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 60.04893563589572}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread()\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        thread_name = thread.name\n        logging.getLogger(__name__).debug(\n            \"joining thread %s\", thread_name\n        )\n        thread.join(timeout)\n        if thread.is_alive():\n            logging.getLogger(__name__).warning(\n                \"failed to join thread %s\", thread_name\n            )\n\n", "CodeBleu_score": 45.06776880550796}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread()\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                \"Failed to join thread %s\",\n                thread.name,\n                exc_info=True,\n            )\n\n", "CodeBleu_score": 43.833411712995925}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread()\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                \"Failed to join thread %s\", thread.name, exc_info=thread._exc_info\n            )\n\n", "CodeBleu_score": 43.44502658964111}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._hass.async_create_task(\n            self._hass.helpers.dispatcher.async_dispatcher_send(\n                SIGNAL_SETUP_DONE, remaining_with_setup_started\n            )\n        )\n        self._previous_was_empty = False\n    elif not self._previous_was_empty:\n        self._hass.async_create_task(\n            self._hass.helpers.dispatcher.async_dispatcher_send(SIGNAL_SETUP_DONE)\n        )\n        self._previous_was_empty = True\n\n\n def start(self) -> None:\n    \"\"\"The function \"start\" starts the periodic log of setups that are pending by scheduling a timer to run the \"_async_watch\" function every SLOW_STARTUP_CHECK_INTERVAL seconds.\"\"\"\n    self._handle = self._loop.call_later(\n        SLOW_STARTUP_CHECK_INTERVAL, self._async_watch\n    )\n\n def cancel(self) -> None:\n    \"\"\"The function \"cancel\" cancels the periodic log of setups that are pending by cancelling the timer that was set up in the \"start\" function.\"\"\"\n    if self._handle is not None:\n        self._handle.cancel()\n        self._handle = None\n\n", "CodeBleu_score": 44.838930270671625}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._hass.async_create_task(\n            self._hass.helpers.dispatcher.async_dispatcher_send(\n                SLOW_STARTUP_SIGNAL, remaining_with_setup_started\n            )\n        )\n    self._previous_was_empty = not remaining_with_setup_started\n", "CodeBleu_score": 67.32710797263141}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._hass.async_create_task(\n            self._hass.helpers.dispatcher.async_dispatcher_send(\n                SIGNAL_SETUP_STARTED, remaining_with_setup_started\n            )\n        )\n        self._previous_was_empty = False\n    elif not self._previous_was_empty:\n        self._hass.async_create_task(\n            self._hass.helpers.dispatcher.async_dispatcher_send(SIGNAL_SETUP_DONE)\n        )\n        self._previous_was_empty = True\n\n", "CodeBleu_score": 47.22954960164438}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = (\n        config.root / \"homeassistant/generated/bluetooth.py\"\n    )\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if not bluetooth_path.is_file():\n        return\n\n    with bluetooth_path.open(\"r\") as fp:\n        current = fp.read().strip()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n", "CodeBleu_score": 68.06406226023933}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = (\n        config.root / \"homeassistant/generated/bluetooth.py\"\n    )\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if not bluetooth_path.is_file():\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n        return\n\n    with bluetooth_path.open(\"r\") as fp:\n        current = fp.read().strip()\n\n    if current != content:\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n\n", "CodeBleu_score": 53.844707114386345}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    bluetooth_path = (\n        config.root / \"homeassistant/generated/bluetooth.py\"\n    )\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if not bluetooth_path.is_file() or content != bluetooth_path.read_text(encoding=\"utf-8\"):\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    for domain in sorted(integrations):\n        integration = integrations[domain]\n\n        if not integration.manifest.get(\"bluetooth\"):\n            continue\n\n        has_match_key = False\n\n        for key in (\"match_manufacturer\", \"match_model\"):\n            if key in integration.manifest[\"bluetooth\"][0]:\n                has_match_key = True\n                break\n\n        if not has_match_key:\n            continue\n\n        if domain not in config.specific_integrations:\n            continue\n\n        if not (\n            integration.path / \"__init__.py\"\n        ).relative_to(config.root).as_posix().startswith(\n            \"homeassistant/components/\"\n        ):\n            continue\n\n        if not (\n            domain\n            in config.specific_integrations[domain][\"manifest\"][\"bluetooth\"]\n        ):\n            continue\n\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n", "CodeBleu_score": 48.13008205700464}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 95.7293264155016}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 95.7293264155016}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error != \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 95.7293264155016}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tif err := d.autoRetry(func() (*resty.Response, error) {\n\t\tr, err := req.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif r.StatusCode() == 401 {\n\t\t\tif err := d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn nil, base.ErrNeedRetry\n\t\t}\n\t\treturn r, nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\tif resp != nil {\n\t\treturn nil, nil\n\t}\n\treturn req.Body()\n}", "CodeBleu_score": 62.31405310562194}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tvar e Error\n\treq.SetError(&e)\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode() == 401 {\n\t\tif strings.Contains(e.Error, \"invalid_grant\") {\n\t\t\terr = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(e.Error)\n\t}\n\n\tif e.Error.Code != 0 {\n\t\treturn nil, fmt.Errorf(e.Error.Message)\n\t}\n\n\tif res.RawBody != nil {\n\t\tdefer res.RawBody.Close()\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 84.50192187738837}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tif err := d.checkToken(req, url, method); err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbody := res.Body()\n\treturn body, nil\n}", "CodeBleu_score": 60.643790443277744}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.ChunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = 10 * 1024 * 1024\n\t}\n\tchunkNum := int(math.Ceil(float64(stream.GetSize()) / float64(chunkSize)))\n\tuploadID, err := d.createUploadSession(ctx, url, int64(chunkNum))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer d.closeUploadSession(ctx, uploadID)\n\tfor i := 0; i < chunkNum; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\toffset := int64(i * chunkSize)\n\t\t\tlimit := int(chunkSize)\n\t\t\tif i == chunkNum-1 {\n\t\t\t\tlimit = int(stream.GetSize() - offset)\n\t\t\t}\n\t\t\tdata := make([]byte, limit)\n\t\t\t_, err = stream.Read(data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontentRange := fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+int64(limit)-1, stream.GetSize())\n\t\t\terr = d.uploadChunk(ctx, uploadID, contentRange, data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn d.completeUploadSession(ctx, uploadID)\n}", "CodeBleu_score": 47.2388086860196}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tsize := stream.GetSize()\n\tchunkSize := int64(utils.Min(size, d.ChunkSize))\n\tchunkNum := int(size / chunkSize)\n\tif size%chunkSize != 0 {\n\t\tchunkNum++\n\t}\n\tchunkIndex := 0\n\tfor chunkIndex < chunkNum {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tchunkStart := int64(chunkIndex) * chunkSize\n\t\t\tchunkEnd := chunkStart + chunkSize - 1\n\t\t\tif chunkEnd >= size {\n\t\t\t\tchunkEnd = size - 1\n\t\t\t}\n\t\t\tchunk, err := stream.GetSectionReader(chunkStart, chunkEnd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq := base.RestyClient.R()\n\t\t\treq.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t\t\treq.SetHeader(\"Content-Length\", strconv.FormatInt(chunkEnd-chunkStart+1, 10))\n\t\t\treq.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", chunkStart, chunkEnd, size))\n\t\t\treq.SetBody(chunk)\n\t\t\tres, err := req.Execute(http.MethodPut, url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif res.StatusCode() != http.StatusCreated {\n\t\t\t\treturn fmt.Errorf(\"chunk upload failed: %s\", res.Status())\n\t\t\t}\n\t\t\tchunkIndex++\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.26186789037476}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req httper.MountPoint\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t}\n\tmountPoint := req.MountPoint\n\tif !strings.HasPrefix(mountPoint, \"/media\") {\n\t\tmountPoint = path.Join(\"/media\", mountPoint)\n\t}\n\terr := service.MyService.Storage().UmountStorage(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DeleteConfig(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 74.21678506924738}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req httper.StorageReq\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn err\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t}\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\tservice.MyService.Storage().DeleteConfigByMountPoint(req.MountPoint)\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 75.94280479231034}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req httper.MountPoint\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n\t}\n\tmountPoint := req.MountPoint\n\tif err := service.MyService.Storage().UmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\tif err := service.MyService.Storage().DeleteConfig(mountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: \"unmount success\"})\n}", "CodeBleu_score": 74.2676541354531}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 80.16725704205643}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 71.33496006639984}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 80.16725704205643}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetErrJson(err))\n\t}\n\tservice.MyService.Notify().SendNotify(name, message)\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 76.94939209079514}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.ERR_BIND\n\t}\n\n\tservice.MyService.Notify().SendNotify(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 68.40016849297295}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.INVALID_PARAMS)\n\t}\n\n\tservice.MyService.Notify().SendNotify(name, message)\n\n\treturn ctx.JSON(http.StatusOK, model.Result{Success: common_err.SUCCESS.Code, Message: common_err.SUCCESS.Message})\n}", "CodeBleu_score": 69.78688278816335}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to a list of connections\n\tservice.MyService.NotifyServer.Broadcast <- &types.Connection{Send: make(chan []byte, 256), Ws: ws}\n\t// Ensure that the message sending service is running\n\tservice.MyService.NotifyServer.Start()\n\t// Continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%s\n\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 43.940426523659426}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tservice.MyService.NotifyServer.AddClient(ws)\n\tservice.MyService.NotifyServer.Start()\n\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tservice.MyService.NotifyServer.RemoveClient(ws)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Printf(\"recv: %s\n\", message)\n\t\tif string(message) == \"ping\" {\n\t\t\tmessage = []byte(\"pong\")\n\t\t}\n\t\terr = ws.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.97519605835784}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tservice.MyService.Notify().AddConn(ws)\n\n\tgo service.MyService.Notify().SendMsg()\n\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%s\n\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.41923922707008}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArch := service.MyService.System().GetSystemHardwareInfo()\n\tcpu := service.MyService.System().GetCPUInfo()\n\tif cpu == nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]string{\"drive_model\": driveModel, \"drive_arch\": driveArch, \"cpu\": \"nil\"}})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]string{\"drive_model\": driveModel, \"drive_arch\": driveArch, \"cpu\": cpu.String()}})\n}", "CodeBleu_score": 37.402187499647546}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture := service.MyService.System().GetDriveInfo()\n\tcpuInfo, _ := service.MyService.System().GetCPUInfo()\n\tdata := make(map[string]interface{}, 2)\n\tdata[\"driveModel\"] = driveModel\n\tdata[\"driveArchitecture\"] = driveArchitecture\n\tdata[\"cpuInfo\"] = cpuInfo\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: data})\n}", "CodeBleu_score": 42.245915188848585}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArch := disk.GetDriveModelAndArch()\n\tcpu := cpu.GetCPUInfo()\n\tif cpu == nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\n\t\t\t\"drive_model\": driveModel,\n\t\t\t\"drive_arch\":  driveArch,\n\t\t}})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: map[string]interface{}{\n\t\t\"drive_model\": driveModel,\n\t\t\"drive_arch\":  driveArch,\n\t\t\"cpu\":         cpu,\n\t}})\n}", "CodeBleu_score": 31.99677706469276}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 80.4027818389349}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 80.4027818389349}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.90254304404401}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageJSON, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"SendNotify json.Marshal error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tmessageString := string(messageJSON)\n\n\tresponse, err := common.SendMessage(name, messageString)\n\tif err != nil {\n\t\tlogger.Error(\"SendNotify SendMessage error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"SendNotify SendMessage error\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 36.67999323460487}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageString := make(map[string]string)\n\tfor k, v := range message {\n\t\tmessageString[k] = fmt.Sprintf(\"%v\", v)\n\t}\n\tmessageBytes, _ := json2.Marshal(messageString)\n\tmessageString = make(map[string]string)\n\tjson.Unmarshal(messageBytes, &messageString)\n\n\tevent := notify.Event{\n\t\tName:    name,\n\t\tMessage: messageString,\n\t}\n\n\teventBytes, _ := json.Marshal(event)\n\n\tpublishErr := common.MessageBus.Publish(common.NOTIFY_MESSAGE_TOPIC, eventBytes)\n\tif publishErr != nil {\n\t\tlogger.Error(\\\"publish notify message failed\\\", zap.Any(\\\"error\\\", publishErr))\n\t}\n}", "CodeBleu_score": 43.4178643580215}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonStr, _ := json2.Marshal(message)\n\terr := common.SendNotify(name, string(jsonStr))\n\tif err != nil {\n\t\tlogger.Error(\"send notify error\", zap.Error(err))\n\t\treturn\n\t}\n\tlogger.Info(\"send notify success\", zap.Any(\"name\", name), zap.Any(\"message\", message))\n}", "CodeBleu_score": 26.412537017978167}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"\")\n\n\taddress, err := config.GetConfigPath(config.Get().CommonInfo.RuntimePath, \"message-bus.addr\")\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 37.24354405703808}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"\")\n\taddr, err := config.MyService.RuntimePath(\"message-bus\")\n\tif err == nil {\n\t\tclient = message_bus.NewClientWithResponses(addr)\n\t} else {\n\t\tclient.Server = \"error\"\n\t}\n\treturn client\n}", "CodeBleu_score": 37.23114246499423}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"\")\n\n\taddress, err := config.GetMessageBusAddress(config.CommonInfo.RuntimePath)\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 39.98961619597811}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\\\"x-forwarded-for\\\")\n\tif ip != \\\"\\\" {\n\t\tip = strings.Split(ip, \\\",\\\")[0]\n\t}\n\tif ip == \\\"\\\" {\n\t\tip = strings.Split(request.RemoteAddr, \\\":\\\")[0]\n\t}\n\tif ip == \\\"::1\\\" {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\tif ip == \\\"::ffff:127.0.0.1\\\" {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 44.42055466065478}, {"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\\\"x-forwarded-for\\\")\n\tif len(xForwardedFor) > 0 {\n\t\tips := strings.Split(xForwardedFor, \\\",\\\")\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n\tip := request.RemoteAddr\n\tif strings.Contains(ip, \\\"::1\\\") {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\tif strings.Contains(ip, \\\"::ffff:\\\") {\n\t\tip = strings.TrimPrefix(ip, \\\"::ffff:\\\")\n\t}\n\treturn ip\n}", "CodeBleu_score": 36.735051038733054}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\\\"x-forwarded-for\\\")\n\tif ip == \\\"\\\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \\\",\\\")[0]\n\tif strings.Contains(ip, \\\":\\\") {\n\t\tip = strings.Split(ip, \\\":\\\")[0]\n\t}\n\tif ip == \\\"::1\\\" {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\tif ip == \\\"::ffff:127.0.0.1\\\" {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 49.720879119483044}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tentryFilePath := config.AppInfo.EntryPath\n\tentryFilePath = filepath.Join(entryFilePath, \"entry.json\")\n\t_, err := os.Stat(entryFilePath)\n\tif err != nil {\n\t\tos.Create(entryFilePath)\n\t}\n\n\tmoduleDirPath := config.AppInfo.ModulePath\n\tmoduleDir, err := os.ReadDir(moduleDirPath)\n\tif err != nil {\n\t\tlogger.Error(\"read module dir error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tentryFile, err := os.OpenFile(entryFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)\n\tif err != nil {\n\t\tlogger.Error(\"open entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\tentryFile.WriteString(\"[\")\n\tfor i, module := range moduleDir {\n\t\tif module.IsDir() {\n\t\t\tmoduleEntryPath := filepath.Join(moduleDirPath, module.Name(), \"entry.json\")\n\t\t\t_, err := os.Stat(moduleEntryPath)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmoduleEntryFile, err := os.Open(moduleEntryPath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"open module entry file error\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer moduleEntryFile.Close()\n\n\t\t\tmoduleEntryFileContent, err := io.ReadAll(moduleEntryFile)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"read module entry file error\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif i != 0 {\n\t\t\t\tentryFile.WriteString(\",\")\n\t\t\t}\n\t\t\tentryFile.Write(moduleEntryFileContent)\n\t\t}\n\t}\n\tentryFile.WriteString(\"]\")\n}", "CodeBleu_score": 47.480607183700094}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulePath := filepath.Join(config.AppInfo.Root, \"modules\")\n\tentryPath := filepath.Join(config.AppInfo.Root, \"entry.json\")\n\n\tif !file.IsExist(entryPath) {\n\t\tfile.WriteFile(entryPath, []byte(\"[]\"))\n\t}\n\n\tentryList := make([]string, 0)\n\n\terr := filepath.Walk(modulePath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Walk error\", zap.Error(err))\n\t\t\treturn err\n\t\t}\n\n\t\tif info.IsDir() && info.Name() != \"modules\" {\n\t\t\tentryFilePath := filepath.Join(path, \"entry.json\")\n\t\t\tif file.IsExist(entryFilePath) {\n\t\t\t\tentryList = append(entryList, entryFilePath)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlogger.Error(\"Walk error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tentryJSON := \"[\"\n\tfor i, entryFilePath := range entryList {\n\t\tcontent, err := file.ReadFile(entryFilePath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Read file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tif i > 0 {\n\t\t\tentryJSON += \",\"\n\t\t}\n\n\t\tentryJSON += string(content)\n\t}\n\tentryJSON += \"]\"\n\n\terr = file.WriteFile(entryPath, []byte(entryJSON))\n\tif err != nil {\n\t\tlogger.Error(\"Write file error\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 59.81126295549999}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnets, err := MyService.System().GetNet(true)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tfor _, n := range nets {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 74.86406859143075}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := MyService.System().GetNet(false)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tfor _, name := range netNames {\n\t\t\tif i.Name == name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"no matching interface found\")\n}", "CodeBleu_score": 67.84875980681075}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetNames := MyService.System().GetNet(true)\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range netNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 72.93116436806089}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  if (pTscObj->requestCount >= pTscObj->maxRequests) {\n    return TSDB_CODE_OVER_MAX_REQUESTS;\n  }\n\n  if (pTscObj->appInfo != NULL) {\n    pTscObj->appInfo->totalReqs++;\n    pTscObj->appInfo->curReqs++;\n  }\n\n  pTscObj->requestCount++;\n  taosRefInc(pRequest, pRequest->ref);\n\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 26.00752475010733}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  tscAddRef(pTscObj);\n  pTscObj->reqCount++;\n\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->reqCount++;\n    pTscObj->pAppInfo->curReqCount++;\n  }\n\n  tscLogDbg(2, \"tsc:%p, req:%p, reqCount:%d, curReqCount:%d\", pTscObj, pRequest, pTscObj->reqCount, pTscObj->pAppInfo->curReqCount);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 30.68115423576846}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  if (pTscObj == NULL) {\n    return TSDB_CODE_INVALID_ARGUMENT;\n  }\n\n  pRequest->ref = taosRefInc(pRequest->ref, 1);\n  pTscObj->requests++;\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->requests++;\n    pTscObj->pAppInfo->currentRequests++;\n  }\n\n  tscDbg.requests++;\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->requests++;\n    pTscObj->pAppInfo->currentRequests++;\n  }\n\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 34.81504314355415}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDb == NULL || exceptDb == NULL) {\n    return true;\n  }\n\n  if (strcmp(pRequest->pDb, exceptDb) != 0) {\n    return true;\n  }\n\n  if (pRequest->dbList == NULL) {\n    return false;\n  }\n\n  for (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n    char* db = taosArrayGet(pRequest->dbList, i);\n    char* dot = strchr(db, '.');\n    if (dot != NULL) {\n      db = dot + 1;\n    }\n    if (strcmp(db, exceptDb) == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 78.29357791352872}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDb != NULL && strcmp(pRequest->pDb, exceptDb) != 0) {\n    return true;\n  }\n\n  if (pRequest->dbList != NULL) {\n    for (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n      char* db = taosArrayGet(pRequest->dbList, i);\n      char* dot = strchr(db, '.');\n      if (dot != NULL) {\n        db = dot + 1;\n      }\n      if (strcmp(db, exceptDb) != 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 79.2515795037296}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->body.resInfo.numOfDbs == 0) {\n    return true;\n  }\n\n  if (strcmp(pRequest->body.resInfo.dbList[0], exceptDb) != 0) {\n    for (int32_t i = 0; i < pRequest->body.resInfo.numOfDbs; i++) {\n      char *db = pRequest->body.resInfo.dbList[i];\n      char *dot = strchr(db, '.');\n      if (dot != NULL) {\n        db = dot + 1;\n      }\n      if (strcmp(db, exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 68.70873443847059}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == TSDB_CODE_RPC_REDIRECT) {\n    if (msgType == TSDB_MSG_TYPE_RPC_REQUEST || msgType == TSDB_MSG_TYPE_RPC_RESPONSE || msgType == TSDB_MSG_TYPE_RPC_REDIRECT) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 40.77498762540993}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n\n    SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      if (pRequest->stmt) {\n        taos_stop_query(pRequest->stmt, 0);\n      }\n      releaseRequest(*rid);\n    }\n\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 86.07659448733035}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n\n    SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      stopQuery(pRequest);\n      releaseRequest(*rid);\n    }\n\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 96.65412294387427}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n\n    SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      if (pRequest->query) {\n        taosStopQuery(pRequest->query);\n      }\n      releaseRequest(*rid);\n    }\n\n    pIter = taosHashIterate(pRequests, pIter);\n  }\n}", "CodeBleu_score": 85.8391174714446}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (-1 != atomic_val_compare_exchange_32(&clientStop, -1, 1)) {\n    return;\n  }\n\n  while (1) {\n    if (0 == atomic_load_32(&clientStop)) break;\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 66.50116878865799}, {"code": "void tscStopCrashReport(){\n\t  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (0 != atomic_val_compare_exchange_32(&clientStop, 1, 0)) {\n    tscInfo(\"crash report thread is already stopped\");\n    return;\n  }\n\n  while (0 != clientStop) {\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 67.10478044598848}, {"code": "void tscStopCrashReport(){\n\t  if (!tsEnableCrashReport) {\n    return;\n  }\n\n  if (atomic_val_compare_exchange_32(&clientStop, -1, 1) != 0) {\n    tscInfo(\"crash report thread already stopped\");\n    return;\n  }\n\n  while (clientStop != 0) {\n    taosMsleep(10);\n  }\n}", "CodeBleu_score": 68.52644936591268}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t code = 0;\n\n  SViewHbRsp hbRsp = {0};\n  if (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\n    terrno = TSDB_CODE_INVALID_MSG;\n    return -1;\n  }\n\n  int32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n  for (int32_t i = 0; i < numOfMeta; ++i) {\n    SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n    if (rsp->numOfColumns < 0) {\n      tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n    } else {\n      tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      if (rsp->pSchemas[0].colId != PRIMARYKEY_TIMESTAMP_COL_ID) {\n        tscError(\"invalid colId[%\\\" PRIi16 \\\"] for the first column in view meta rsp msg\", rsp->pSchemas[0].colId);\n        tFreeSViewHbRsp(&hbRsp);\n        return TSDB_CODE_TSC_INVALID_VALUE;\n      }\n\n      catalogAsyncUpdateViewMeta(pCatalog, rsp);\n    }\n  }\n\n  taosArrayDestroy(hbRsp.pMetaRsp);\n  hbRsp.pMetaRsp = NULL;\n\n  tFreeSViewHbRsp(&hbRsp);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 78.97052938239861}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t code = 0;\n\n  SViewHbRsp hbRsp = {0};\n  if (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\n    terrno = TSDB_CODE_INVALID_MSG;\n    return -1;\n  }\n\n  int32_t numOfViews = taosArrayGetSize(hbRsp.pMetaRsp);\n  for (int32_t i = 0; i < numOfViews; ++i) {\n    SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n    if (rsp->numOfColumns < 0) {\n      tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n    } else {\n      tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n      if (rsp->pSchemas[0].colId != PRIMARYKEY_TIMESTAMP_COL_ID) {\n        tscError(\"invalid colId[%\\\" PRIi16 \\\"] for the first column in view meta rsp msg\", rsp->pSchemas[0].colId);\n        tFreeSViewHbRsp(&hbRsp);\n        return TSDB_CODE_TSC_INVALID_VALUE;\n      }\n\n      catalogAsyncUpdateViewMeta(pCatalog, rsp);\n    }\n  }\n\n  taosArrayDestroyWithCleanFunc(hbRsp.pMetaRsp, hbFreeSViewMetaInRsp);\n  hbRsp.pMetaRsp = NULL;\n\n  tFreeSViewHbRsp(&hbRsp);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 77.15932096496597}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t  TS3SizeCBD *cbd = (TS3SizeCBD *)callbackData;\n  if (properties->contentLength > 0) {\n    cbd->content_length = properties->contentLength;\n  }\n  return S3StatusOK;\n}", "CodeBleu_score": 74.20221781187566}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t  TS3GetData *data = (TS3GetData *)callbackData;\n\n  if (properties->contentLength > 0) {\n    data->content_length = properties->contentLength;\n  } else {\n    data->content_length = 0;\n  }\n\n  return S3StatusOK;\n}", "CodeBleu_score": 79.26125362221364}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t  TS3GetData *pGetData = (TS3GetData *)callbackData;\n\n  if (properties->contentLength > 0) {\n    pGetData->content_length = properties->contentLength;\n  } else {\n    pGetData->content_length = 0;\n  }\n\n  return S3StatusOK;\n}", "CodeBleu_score": 78.09984252258474}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  if (taosCreateDir(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 2, \"start /B rsync --daemon --no-detach --port %d --config=%s\", tsCheckpointBackupPort, confDir);\n#else\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --no-detach --port %d --config=%s\", tsCheckpointBackupPort, confDir);\n#endif\n\n  int32_t code = execCommand(command);\n  if (code != 0) {\n    uError(\"[rsync] start rsync server failed,code:%d\", code);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 63.464007742357666}, {"code": "void startRsync(){\n\t  // create checkpoint backup directory\n  if (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  // remove empty directory\n  removeEmptyDir();\n\n  // generate rsync conf file\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  // start rsync server\n  char command[PATH_MAX * 2] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n#else\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n#endif\n\n  int32_t code = execCommand(command);\n  if (code != 0) {\n    uError(\"[rsync] start rsync server error,code:%d\", code);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 64.28689240515439}, {"code": "void startRsync(){\n\t  if (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate rsync conf file error\");\n    return;\n  }\n\n  char command[PATH_MAX] = {0};\n  snprintf(command, PATH_MAX,\n#ifdef WINDOWS\n           \"start /b rsync --daemon --no-detach --port %d --config=%s\",\n#else\n           \"rsync --daemon --no-detach --port %d --config=%s\",\n#endif\n           tsCheckpointBackupPort, confDir);\n\n  int32_t code = execCommand(command);\n  if (code != 0) {\n    uError(\"[rsync] start rsync server error,code:%d\", code);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 56.86006158572244}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 91.45110903459917}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 91.45110903459917}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}", "CodeBleu_score": 91.45110903459917}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = parentChildMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                TbActorMailbox mailbox = actors.get(child);\n                if (mailbox != null) {\n                    if (highPriority) {\n                        mailbox.tellWithHighPriority(msg);\n                    } else {\n                        mailbox.tell(msg);\n                    }\n                } else {\n                    log.warn(\"Actor with id [{}] is not registered\", child);\n                }\n            });\n        }\n    }", "CodeBleu_score": 56.43708120541062}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = parentChildMap.getOrDefault(parent, Collections.emptySet());\n        List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n        for (TbActorId child : filteredChildren) {\n            try {\n                tell(child, msg, highPriority);\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"Failed to send message to child actor [{}], because it is not registered\", child, e);\n            }\n        }\n    }", "CodeBleu_score": 56.93196274322645}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Set<TbActorId> children = parentChildMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                TbActorMailbox childMailbox = actors.get(child);\n                if (childMailbox != null) {\n                    if (highPriority) {\n                        childMailbox.tellWithHighPriority(msg);\n                    } else {\n                        childMailbox.tell(msg);\n                    }\n                } else {\n                    log.warn(\"Child actor with id [{}] is not registered\", child);\n                }\n            });\n        }\n    }", "CodeBleu_score": 55.533955540775914}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n        if (stopReason == TbActorStopReason.INIT_FAILED) {\n            log.debug(\"[{}] Reinitializing actor after failed initialization\", selfId);\n            system.getScheduler().schedule(() -> dispatcher.getExecutor().execute(() -> tryInit(1)), 0, TimeUnit.MILLISECONDS);\n        }\n    } else {\n        msg.onActorStopped(selfId, stopReason);\n    }\n}", "CodeBleu_score": 55.218422580260196}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (msg.getMsgType().equals(MsgType.RULE_NODE_UPDATED_MSG) && highPriority) {\n        if (stopReason == TbActorStopReason.INIT_FAILED) {\n            log.info(\"[{}] Reinitializing actor...\", selfId);\n            system.getScheduler().schedule(() -> dispatcher.getExecutor().execute(() -> tryInit(1)), 0, TimeUnit.MILLISECONDS);\n        }\n    } else {\n        msg.onActorStopped(selfId, stopReason);\n    }\n}", "CodeBleu_score": 56.097194529039655}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    } else if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n        if (stopReason == TbActorStopReason.INIT_FAILED) {\n            log.info(\"[{}] Reinitializing actor due to RULE_NODE_UPDATED_MSG\", selfId);\n            reinit();\n        }\n    } else {\n        msg.onActorStopped(selfId, stopReason);\n    }\n}", "CodeBleu_score": 54.81941397973831}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    try {\n        log.trace(\"[{}] Processing mailbox\", selfId);\n        int throughput = settings.getMaxActorThroughput();\n        while (throughput > 0 && (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty())) {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg != null) {\n                try {\n                    actor.process(msg);\n                } catch (TbActorException e) {\n                    if (e.getCause() instanceof TbActorError && ((TbActorError) e.getCause()).isUnrecoverable()) {\n                        stopReason = TbActorStopReason.INIT_FAILED;\n                        destroy(e.getCause());\n                    } else {\n                        log.debug(\"[{}] Failed to process message: {}\", selfId, msg, e);\n                        actor.onProcessFailure(msg, e);\n                    }\n                }\n            }\n            throughput--;\n        }\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            busy.set(FREE);\n            if (throughput == 0) {\n                system.getScheduler().schedule(() -> dispatcher.getExecutor().execute(this::processMailbox), 1, TimeUnit.MILLISECONDS);\n            }\n        } else {\n            processMailbox();\n        }\n    } catch (Throwable t) {\n        log.error(\"[{}] Failed to process mailbox\", selfId, t);\n    }\n}", "CodeBleu_score": 53.54886754304344}, {"code": "private void processMailbox(){\n\t    try {\n        int processed = 0;\n        TbActorMsg msg;\n        while (processed < settings.getMaxActorInitThroughput() && (msg = highPriorityMsgs.poll()) != null) {\n            process(msg);\n            processed++;\n        }\n        while (processed < settings.getMaxActorInitThroughput() && (msg = normalPriorityMsgs.poll()) != null) {\n            process(msg);\n            processed++;\n        }\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            busy.set(FREE);\n            dispatcher.getExecutor().execute(this::tryProcessQueue);\n        } else {\n            dispatcher.getExecutor().execute(this::processMailbox);\n        }\n    } catch (TbActorException e) {\n        log.debug(\"[{}] Actor initialization failure\", selfId, e);\n        stopReason = TbActorStopReason.INIT_FAILED;\n        destroy(e.getCause());\n    } catch (Throwable t) {\n        log.debug(\"[{}] Failed to process message\", selfId, t);\n        if (actor.onProcessFailure(t).isStop()) {\n            stopReason = TbActorStopReason.PROCESS_FAILED;\n            destroy(t.getCause());\n        } else {\n            tryProcessQueue(false);\n        }\n    }\n}", "CodeBleu_score": 46.43503675312119}, {"code": "private void processMailbox(){\n\t    try {\n        int processed = 0;\n        long startTime = System.currentTimeMillis();\n        while (processed < settings.getMaxActorProcessingThroughput()) {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg != null) {\n                try {\n                    actor.process(msg);\n                } catch (TbActorException e) {\n                    if (e.getCause() instanceof TbActorError && ((TbActorError) e.getCause()).isUnrecoverable()) {\n                        stopReason = TbActorStopReason.INIT_FAILED;\n                        destroy(e.getCause());\n                        return;\n                    } else {\n                        log.debug(\"[{}] Failed to process msg: {}\", selfId, msg, e);\n                        actor.onProcessFailure(msg, e);\n                    }\n                } catch (Throwable t) {\n                    log.debug(\"[{}] Failed to process msg: {}\", selfId, msg, t);\n                    actor.onProcessFailure(msg, t);\n                }\n                processed++;\n            } else {\n                break;\n            }\n        }\n        long endTime = System.currentTimeMillis();\n        long processingTime = endTime - startTime;\n        if (processingTime < settings.getMaxActorProcessingTime()) {\n            long sleepTime = settings.getMaxActorProcessingTime() - processingTime;\n            system.getScheduler().schedule(() -> tryProcessQueue(false), sleepTime, TimeUnit.MILLISECONDS);\n        } else {\n            tryProcessQueue(false);\n        }\n    } finally {\n        busy.set(FREE);\n    }\n}", "CodeBleu_score": 52.960994196525355}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        ready.set(NOT_READY);\n        try {\n            actor.destroy(stopReason, cause);\n            notifyQueuedMessages(stopReason, cause);\n        } catch (Exception e) {\n            log.warn(\"Failed to destroy actor: [{}]\", selfId, e);\n        }\n    });\n}", "CodeBleu_score": 60.48971084842212}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        ready.set(NOT_READY);\n        try {\n            actor.destroy(stopReason, cause);\n            notifyAllQueuedMessages(stopReason, cause);\n        } catch (Exception e) {\n            log.warn(\"Failed to destroy actor {}\", selfId, e);\n        }\n    });\n}", "CodeBleu_score": 60.24746974792071}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        ready.set(NOT_READY);\n        try {\n            actor.destroy(stopReason, cause);\n            notifyAllQueuedMsgs(stopReason, cause);\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 65.85945522747424}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t        if (tenantId.isSysTenantId()) {\n            return true;\n        }\n        TenantProfile tenantProfile = tenantProfileProvider.findTenantProfileById(tenantId);\n        if (tenantProfile == null) {\n            if (ignoreTenantNotFound) {\n                return true;\n            } else {\n                throw new TenantProfileNotFoundException(tenantId);\n            }\n        }\n        RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n        if (rateLimitConfiguration == null) {\n            return true;\n        }\n        TbRateLimits rateLimits = getRateLimits(tenantId, api, level);\n        boolean success = rateLimits.tryConsume(rateLimitConfiguration.getLimit(api));\n        if (!success) {\n            notificationRuleProcessor.process(new RateLimitsTrigger(tenantId, api, level));\n        }\n        return success;\n    }", "CodeBleu_score": 67.19527364763084}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileProvider.findTenantProfileById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    TbRateLimits rateLimits = tenantProfile.getRateLimits();\n    if (rateLimits == null) {\n        return true;\n    }\n    boolean success = rateLimits.tryConsume(api.getLimitKey(level));\n    if (!success) {\n        notificationRuleProcessor.process(new RateLimitsTrigger(tenantId, api, level));\n    }\n    return success;\n}", "CodeBleu_score": 58.77973439092033}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isSysTenantId()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileProvider.findTenantProfileById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    TbRateLimits rateLimits = tenantProfile.getRateLimits(api);\n    if (rateLimits == null) {\n        return true;\n    }\n    if (rateLimits.isExceeded(level)) {\n        notificationRuleProcessor.process(new RateLimitsTrigger(tenantId, api, rateLimits, level));\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 52.067051451989045}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().removeIf(entry -> {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\n            return true;\n        } else {\n            return false;\n        }\n    });\n}", "CodeBleu_score": 78.04425150136403}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().removeIf(entry -> {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store: [{}]\", entry.getKey());\n            return true;\n        }\n        return false;\n    });\n}", "CodeBleu_score": 80.32335576925006}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().removeIf(entry -> {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.trace(\"DTLS session removed from in-memory store: [{}]\", entry.getKey());\n            return true;\n        } else {\n            return false;\n        }\n    });\n}", "CodeBleu_score": 93.05914300261998}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!timeseries.isEmpty()) {\n        List<TsKvEntry> tsEntries = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            for (JsonNode value : entry.getValue()) {\n                KvEntry entry = parseValue(entry.getKey(), value);\n                tsEntries.add(new BasicTsKvEntry(entry, value.get(TS).asLong()));\n            }\n        }\n        return tsEntries;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 50.01216121772721}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (!CollectionUtils.isEmpty(timeseries)) {\n            List<TsKvEntry> tsList = new ArrayList<>();\n            for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n                String key = entry.getKey();\n                List<JsonNode> valueList = entry.getValue();\n                for (JsonNode valueNode : valueList) {\n                    KvEntry entry = parseValue(key, valueNode);\n                    tsList.add(new BasicTsKvEntry(entry, valueNode.get(TS).asLong()));\n                }\n            }\n            return tsList;\n        } else {\n            return Collections.emptyList();\n        }\n    }", "CodeBleu_score": 52.0529478628982}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (!CollectionUtils.isEmpty(timeseries)) {\n            List<TsKvEntry> result = new ArrayList<>();\n            for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n                for (JsonNode ts : entry.getValue()) {\n                    KvEntry value = parseValue(entry.getKey(), ts.get(VALUE));\n                    result.add(new BasicTsKvEntry(value, ts.get(TS).asLong()));\n                }\n            }\n            return result;\n        } else {\n            return Collections.emptyList();\n        }\n    }", "CodeBleu_score": 58.52810757451324}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    long ts = System.currentTimeMillis();\n    Map<String, Object> request = new HashMap<>();\n    request.put(\"refreshToken\", refreshToken);\n    Map<String, Object> response = loginRestTemplate.postForObject(baseURL + \"/api/auth/token\", request, Map.class);\n    mainToken = (String) response.get(\"token\");\n    refreshToken = (String) response.get(\"refreshToken\");\n    mainTokenExpTs = ts + (long) response.get(\"tokenTtl\");\n    refreshTokenExpTs = ts + (long) response.get(\"refreshTokenTtl\");\n    clientServerTimeDiff = (long) response.get(\"serverTime\");\n}", "CodeBleu_score": 55.085505400030975}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refreshToken\", refreshToken);\n    ResponseEntity<JwtPair> response = loginRestTemplate.postForEntity(baseURL + \"/api/auth/token\", request, JwtPair.class);\n    long currentTs = System.currentTimeMillis();\n    JwtPair body = response.getBody();\n    mainToken = body.getToken();\n    refreshToken = body.getRefreshToken();\n    mainTokenExpTs = currentTs + body.getTokenTtl();\n    refreshTokenExpTs = currentTs + body.getRefreshTokenTtl();\n}", "CodeBleu_score": 61.24602127712669}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refreshToken\", refreshToken);\n    ResponseEntity<JwtPair> response = loginRestTemplate.postForEntity(baseURL + \"/api/auth/token\", request, JwtPair.class);\n    JwtPair jwtPair = response.getBody();\n    mainToken = jwtPair.getToken();\n    refreshToken = jwtPair.getRefreshToken();\n    mainTokenExpTs = System.currentTimeMillis() + jwtPair.getTokenTtl();\n    refreshTokenExpTs = System.currentTimeMillis() + jwtPair.getRefreshTokenTtl();\n}", "CodeBleu_score": 59.00354835327494}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo.getBody());\n    }", "CodeBleu_score": 98.07301814223813}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo.getBody());\n    }", "CodeBleu_score": 98.07301814223813}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo.getBody());\n    }", "CodeBleu_score": 98.07301814223813}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 94.09553786507534}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 94.09553786507534}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}", "CodeBleu_score": 94.09553786507534}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t", "CodeBleu_score": 6.094910559018862}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t", "CodeBleu_score": 6.094910559018862}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t", "CodeBleu_score": 6.094910559018862}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    let i;\n    let scale;\n    let brightness;\n\n    if (arguments.length === 1) {\n      brightness = Math.round(Number(val) * 15 / 100);\n      this.each(function(device) {\n        this.brightness(device, brightness);\n      });\n    } else {\n      scale = Math.round(Number(val) * 15 / 100);\n      this.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, scale);\n    }\n    return this;\n  }", "CodeBleu_score": 62.80527546134805}, {"code": "brightness(addr, val){\n\t    let state;\n    let devices;\n    let device;\n    let value;\n\n    if (arguments.length === 1) {\n      value = Number(addr);\n      if (value < 0) {\n        value = 0;\n      } else if (value > 100) {\n        value = 100;\n      }\n\n      value = Math.round(value / 100 * 15);\n      this.each(function(device) {\n        this.brightness(device, value);\n      });\n    } else {\n      state = priv.get(this);\n      devices = state.devices;\n      device = Number(addr);\n      value = Number(val);\n\n      if (device < 0) {\n        device = 0;\n      } else if (device >= devices) {\n        device = devices - 1;\n      }\n\n      if (value < 0) {\n        value = 0;\n      } else if (value > 15) {\n        value = 15;\n      }\n\n      this.send(device, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, value);\n    }\n    return this;\n  }", "CodeBleu_score": 57.63751629496808}, {"code": "brightness(addr, val){\n\t  if (typeof val === \"undefined\") {\n    this.each(function(device) {\n      this.brightness(device, addr);\n    });\n  } else {\n    this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, val);\n  }\n  return this;\n}", "CodeBleu_score": 60.710117737856116}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const bound = {};\n\n    for (const key in this) {\n      if (this.hasOwnProperty(key)) {\n        if (typeof this[key] === \"function\") {\n          bound[key] = this[key].bind(this, addr);\n        } else {\n          bound[key] = this[key];\n        }\n      }\n    }\n\n    return bound;\n  }", "CodeBleu_score": 52.70915611989639}, {"code": "device(addr){\n\t    const methods = Object.keys(LedControl.prototype);\n    const bound = {};\n    let i;\n    let method;\n    let func;\n\n    for (i = 0; i < methods.length; i++) {\n      method = methods[i];\n      func = this[method];\n      if (typeof func === \"function\") {\n        bound[method] = func.bind(this, addr);\n      }\n    }\n\n    return bound;\n  }", "CodeBleu_score": 36.7249178472726}, {"code": "device(addr){\n\t    const bound = {};\n    const keys = Object.keys(LedControl.prototype);\n\n    keys.forEach((key) => {\n      if (typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n\n    return bound;\n  }", "CodeBleu_score": 56.69964721449856}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = function(duration = 1000, callback = noop) {\n      const length = this.length;\n      const promises = [];\n\n      for (let i = 0; i < length; i++) {\n        promises.push(new Promise(resolve => {\n          this[i][method](resolve);\n        }));\n      }\n\n      setTimeout(() => {\n        Promise.all(promises).then(callback);\n      }, duration);\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 43.74195758024372}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = function(duration = 1000, callback = noop) {\n      const length = this.length;\n      const promises = [];\n\n      for (let i = 0; i < length; i++) {\n        promises.push(new Promise(resolve => {\n          this[i][method](resolve);\n        }));\n      }\n\n      Promise.all(promises).then(callback);\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 41.32002922817959}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = function(duration = 1000, callback = noop) {\n      const length = this.length;\n      const promises = [];\n\n      for (let i = 0; i < length; i++) {\n        promises.push(new Promise(resolve => {\n          this[i][method](resolve);\n        }));\n      }\n\n      setTimeout(() => {\n        Promise.all(promises).then(callback);\n      }, duration);\n\n      return this;\n    };\n  });\n}", "CodeBleu_score": 43.74195758024372}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t    const state = priv.get(this);\n    let input = '';\n    let incomplete;\n\n    // Start a read loop on the serial port\n    this.io.serialRead(state.portId, (data) => {\n        // Append the received data to the input string\n        input += String.fromCharCode.apply(null, data);\n\n        // Split the input string into sentences based on the \"\\r\n\" delimiter\n        const sentences = input.split('\\r\n');\n\n        // Process all complete sentences\n        for (let i = 0; i < sentences.length - 1; i++) {\n            this.parseNmeaSentence(sentences[i]);\n        }\n\n        // Retain any incomplete sentence for the next read\n        incomplete = sentences[sentences.length - 1];\n    });\n}", "CodeBleu_score": 66.93565093736773}, {"code": "listen(){\n\t    const state = priv.get(this);\n    let input = \\\"\\\";\n\n    this.io.serialRead(state.portId, data => {\n      input += String.fromCharCode.apply(null, data);\n      const sentences = input.split(\\\"\\\\r\\\n\\\");\n\n      if (sentences.length > 1) {\n        // Process all complete sentences\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n\n        // Retain the incomplete sentence for the next read\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 71.22041975674207}, {"code": "listen(){\n\t  const state = priv.get(this);\n  let input = \\\"\\\";\n\n  this.io.serialRead(state.portId, data => {\n    // Append new data to the input string\n    input += data.toString();\n\n    // Split the input string into sentences\n    const sentences = input.split(\\\"\\\\r\\\n\\\");\n\n    // Process all complete sentences\n    for (let i = 0; i < sentences.length - 1; ++i) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n\n    // Retain the incomplete sentence for the next read\n    input = sentences[sentences.length - 1];\n  });\n}", "CodeBleu_score": 62.13941557785313}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t active_channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i].channel_id < AD559X_PIN_MAX) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tif (sequence->options) {\n\t\tactive_channels++;\n\t}\n\n\tif (sequence->buffer_size < active_channels) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.23693612977966}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t num_channels = 0;\n\tuint32_t needed_size = 0;\n\n\tfor (uint32_t i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i].sampling_delay == 0) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tneeded_size = num_channels * sizeof(uint16_t);\n\n\tif (sequence->options & ADC_ASYNC_MODE) {\n\t\tneeded_size += sizeof(struct adc_async_channel_data);\n\t}\n\n\tif (sequence->buffer_size < needed_size) {\n\t\tLOG_ERR(\"buffer size %zu is not sufficient for %d channels\",\n\t\t\tsequence->buffer_size, num_channels);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.17189040112235}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tuint8_t channels = sequence->channels;\n\tuint8_t active_channels = 0;\n\n\tfor (uint8_t i = 0; i < channels; i++) {\n\t\tconst struct adc_channel_cfg *channel_cfg = &sequence->channels[i];\n\n\t\tif (channel_cfg->acquisition_time == ADC_ACQ_TIME_DEFAULT) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tif (sequence->options & ADC_ASYNC) {\n\t\tif (sequence->buffer_size < active_channels * sizeof(struct adc_sequence_entry)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tif (sequence->buffer_size < active_channels * sizeof(struct adc_sequence_entry)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.91507960549471}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~AD559X_ADC_CHANNELS) {\n\t\tLOG_ERR(\"invalid channels 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->repeat_buffer;\n\tdata->channels = sequence->channels;\n\n\tadc_context_start_read(&data->ctx, dev);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn data->ctx.result;\n}", "CodeBleu_score": 70.56018454235281}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > BIT(AD559X_PIN_MAX)) {\n\t\tLOG_ERR(\"unsupported channels 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = sequence->channels;\n\n\tadc_context_start_read(&data->ctx);\n\n\tret = k_sem_take(&data->sem, K_FOREVER);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn sequence->buffer_size;\n}", "CodeBleu_score": 73.33493239287428}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tuint8_t channels;\n\tint ret;\n\tstruct adc_ad559x_data *data = dev->data;\n\n\tif (sequence->resolution != AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > BIT(AD559X_PIN_MAX)) {\n\t\tLOG_ERR(\"invalid channels 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->repeat_buffer;\n\tchannels = POPCOUNT(sequence->channels);\n\n\tret = adc_context_start_read(&data->ctx, channels);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_context_wait_for_completion(&data->ctx);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 76.87272482075653}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n    uint8_t channels = data->channels;\n    data->buffer = ctx->buffer;\n    data->repeat_buffer = ctx->buffer;\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 70.76528123684363}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n    data->adc_conf = data->channels;\n    data->repeat_buffer = data->buffer;\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 84.33817726422583}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    const struct adc_sequence *sequence = ctx->sequence;\n    struct adc_ad559x_data *data = ctx->acquire_param;\n    uint8_t channels;\n\n    channels = POPCOUNT(sequence->channels);\n\n    /* Set channels to be sampled */\n    data->adc_conf |= sequence->channels;\n    mfd_ad559x_write_reg(data->config->mfd_dev, AD559X_REG_ADC_CONFIG, data->adc_conf);\n\n    /* Initialize repeat buffer with data buffer */\n    data->repeat_buffer = data->buffer;\n    for (int i = 0; i < channels; i++) {\n        data->repeat_buffer[i] = sequence->buffer[i];\n    }\n\n    /* Release semaphore to signal start of sampling */\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 56.579915060485696}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n    ctx->acq_buffer.buffer = data->buffer;\n    ctx->acq_buffer.size = sizeof(*data->buffer);\n\n    if (repeat_sampling) {\n        data->buffer = data->repeat_buffer;\n    }\n}", "CodeBleu_score": 78.45356982406138}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n    ctx->data = data->buffer;\n\n    if (repeat_sampling) {\n        ctx->data = data->repeat_buffer;\n    }\n}", "CodeBleu_score": 78.67065739087535}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n    ctx->acquisition_buffer = data->buffer;\n    if (repeat_sampling) {\n        ctx->acquisition_buffer = data->repeat_buffer;\n    }\n}", "CodeBleu_score": 76.41196715830434}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (true) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (uint8_t i = 0; i < AD559X_PIN_MAX; i++) {\n            if ((data->channels & BIT(i)) == 0) {\n                continue;\n            }\n\n            int ret = adc_ad559x_read_channel(data->dev, i, data->buffer++);\n            if (ret < 0) {\n                LOG_ERR(\"failed to read channel %d: %d\", i, ret);\n                adc_context_on_sampling_done(&data->ctx, i, ret);\n            }\n        }\n\n        adc_context_on_sampling_done(&data->ctx, -1, 0);\n    }\n}", "CodeBleu_score": 48.25046230788418}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    uint8_t channel;\n    uint16_t *buffer = data->buffer;\n    bool repeat_sampling;\n    int ret;\n\n    while (true) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        channel = find_lsb_set(data->channels) - 1;\n        repeat_sampling = true;\n\n        while (data->channels) {\n            if (data->channels & BIT(channel)) {\n                ret = adc_ad559x_read_channel(data->dev, channel, buffer);\n                if (ret < 0) {\n                    LOG_ERR(\"failed to read channel %d: %d\", channel, ret);\n                    adc_context_on_sampling_done(&data->ctx, NULL);\n                    break;\n                }\n\n                buffer++;\n                data->channels &= ~BIT(channel);\n            }\n\n            channel++;\n        }\n\n        adc_context_update_buffer_pointer(&data->ctx, repeat_sampling);\n        adc_context_on_sampling_done(&data->ctx, NULL);\n    }\n}", "CodeBleu_score": 55.61932660665169}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (true) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (uint8_t channel = 0; channel < AD559X_PIN_MAX; channel++) {\n            if ((data->channels & BIT(channel)) == 0) {\n                continue;\n            }\n\n            int ret = adc_ad559x_read_channel(data->dev, channel, data->buffer++);\n            if (ret < 0) {\n                LOG_ERR(\"failed to read channel %d\", channel);\n                adc_context_complete(&data->ctx, ret);\n                break;\n            }\n        }\n\n        adc_context_on_sampling_done(&data->ctx, data->channels);\n    }\n}", "CodeBleu_score": 51.94761154992034}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    uint8_t config_reg = 0;\n    int rc = 0;\n\n    k_sleep(data->ready_time);\n\n    do {\n        rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n        if (rc) {\n            LOG_ERR(\"Failed to read config register\");\n            return rc;\n        }\n    } while (!(config_reg & ADS1112_CONFIG_MASK_READY));\n\n    return 0;\n}", "CodeBleu_score": 41.16247660971088}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    uint8_t config_reg_val = 0;\n    int rc;\n\n    /* Sleep for the device's specified ready time */\n    k_sleep(data->ready_time);\n\n    /* Read the configuration register to check the status */\n    rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg_val);\n    if (rc != 0) {\n        return rc;\n    }\n\n    /* If the device is not ready, sleep for 100 microseconds and check again */\n    while ((config_reg_val & ADS1112_CONFIG_MASK_READY) == 0) {\n        k_sleep(K_USEC(100));\n        rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg_val);\n        if (rc != 0) {\n            return rc;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 83.82745022474947}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    struct ads1112_data *data = dev->data;\n    int rc;\n\n    k_sleep(data->ready_time);\n\n    do {\n        uint8_t reg;\n\n        rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n        if (rc < 0) {\n            LOG_ERR(\"Failed to read the configuration register: %d\", rc);\n            return rc;\n        }\n\n        if (reg & ADS1112_CONFIG_MASK_READY) {\n            return 0;\n        }\n\n        k_sleep(K_USEC(100));\n    } while (true);\n}", "CodeBleu_score": 48.092861150506124}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t required_size = sizeof(*sequence->buffer) * sequence->options.extra_samplings;\n\n    if (sequence->buffer_size < required_size) {\n        LOG_ERR(\"Buffer size %zu is smaller than required %zu\", sequence->buffer_size, required_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 40.76148644474539}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    int num_samplings = sequence->options->extra_samplings + 1;\n    int num_channels = sequence->channels->count;\n    int required_buffer_size = num_samplings * num_channels;\n\n    if (sequence->buffer_size < required_buffer_size) {\n        LOG_ERR(\"Buffer size (%d) is not sufficient for %d channels and %d extra samplings\",\n                sequence->buffer_size, num_channels, sequence->options->extra_samplings);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 47.32032570942505}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    int num_samplings = sequence->options ? sequence->options->extra_samplings + 1 : 1;\n    int required_buffer_size = num_samplings * sequence->channels_count;\n\n    if (sequence->buffer_size < required_buffer_size) {\n        LOG_ERR(\"Buffer size %d is smaller than required buffer size %d\",\n                sequence->buffer_size, required_buffer_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.41127153316916}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, sequence, wait);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 74.26680969672927}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tif (wait) {\n\t\tret = adc_context_start_read(&data->ctx, sequence);\n\t} else {\n\t\tadc_context_start_read(&data->ctx, sequence);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 66.05971312099372}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint res = 0;\n\n\tres = ads1112_validate_sequence(dev, sequence);\n\tif (res != 0) {\n\t\treturn res;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tres = adc_context_start_read(&data->ctx, sequence, wait);\n\n\treturn res;\n}", "CodeBleu_score": 58.126603900933624}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36641186127734}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    const struct device *dev;\n\n    dev = device_get_binding(argv[args_indx.device]);\n    if (!dev) {\n        shell_error(sh, \"Audio Codec device not found\");\n        return -ENODEV;\n    }\n\n    return audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 96.83564071016914}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36641186127734}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tret = i2s_configure(config->comm_master, I2S_DIR_RX, I2S_FORMAT_PCM_16BIT);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"configure failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_START);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"trigger failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tret = i2s_trigger(config->comm_master, I2S_DIR_RX, I2S_STOP);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"trigger failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 55.143259621732}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"DMIC not configured\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_TRIGGER_TX, 0);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC not active\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_TRIGGER_STOP, 0);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.65569877524156}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state != DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"DMIC not in configured state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_TRIGGER_START);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state != DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC not in active state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_TRIGGER_STOP);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported DMIC trigger\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.61798694999284}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_POSITION_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 90.40655435613981}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    const struct auxdisplay_hd44780_config *config = dev->config;\n    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n    if (data->cursor_enabled) {\n        cmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n    }\n\n    if (data->position_blink_enabled) {\n        cmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n    }\n\n    if (enabled) {\n        cmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n    }\n\n    auxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 90.45151831530342}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_POSITION_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 90.40655435613981}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint rc = 0;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\tLOG_ERR(\"Busy GPIO not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = gpio_pin_get_dt(&config->busy_gpio);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO status\");\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 74.7050498572576}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 45.10524809727554}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tbool is_busy = false;\n\n\tif (config->busy_gpio.port) {\n\t\tis_busy = gpio_pin_get_dt(&config->busy_gpio);\n\t} else {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn is_busy;\n}", "CodeBleu_score": 71.79370000721887}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = { SERLCD_BEGIN_SPECIAL_COMMAND, command };\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 81.80170839372602}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 64.25953484564872}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data = dev->data;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read size %zu\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid read\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"Standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"Power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &data->data[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 54.60652547094976}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\tLOG_ERR(\"Read size cannot be 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Read operation exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &data->data[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 53.95332001246672}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size ||\n\t    bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 97.77377392351411}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 82.98552962309924}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 86.70234567588466}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 86.70234567588466}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    const struct h4_config *cfg = dev->config;\n    struct h4_data *h4 = dev->data;\n\n    /* Calculate number of bytes already read */\n    h4->rx.remaining -= sizeof(h4->rx.hdr) - h4->rx.remaining;\n\n    /* Read remaining bytes */\n    if (uart_fifo_read(cfg->uart, &h4->rx.hdr, h4->rx.remaining) != h4->rx.remaining) {\n        LOG_WRN(\"Unable to read H:4 header\");\n        return;\n    }\n\n    /* Update remaining byte count */\n    h4->rx.remaining = sys_get_be16(&h4->rx.evt.len);\n}", "CodeBleu_score": 55.00041763862675}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    const struct h4_config *cfg = dev->config;\n    struct h4_data *h4 = dev->data;\n\n    /* Get header data */\n    h4->rx.hdr_len -= h4->rx.remaining;\n    if (uart_fifo_read(cfg->uart, &h4->rx.hdr[h4->rx.hdr_len], h4->rx.remaining) != h4->rx.remaining) {\n        LOG_WRN(\"Unable to read H:4 header data\");\n        h4->rx.remaining = 0;\n        return;\n    }\n\n    /* Convert header data to host byte order */\n    if (h4->rx.hdr_len == sizeof(h4->rx.evt)) {\n        h4->rx.evt.opcode = sys_be16_to_cpu(h4->rx.evt.opcode);\n        h4->rx.evt.length = sys_be16_to_cpu(h4->rx.evt.length);\n    } else if (h4->rx.hdr_len == sizeof(h4->rx.acl)) {\n        h4->rx.acl.handle = sys_be16_to_cpu(h4->rx.acl.handle);\n        h4->rx.acl.length = sys_be16_to_cpu(h4->rx.acl.length);\n    } else if (h4->rx.hdr_len == sizeof(h4->rx.iso)) {\n        h4->rx.iso.handle = sys_be16_to_cpu(h4->rx.iso.handle);\n        h4->rx.iso.length = sys_be16_to_cpu(h4->rx.iso.length);\n    }\n\n    h4->rx.remaining = 0;\n}", "CodeBleu_score": 52.95984042941315}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    const struct h4_config *cfg = dev->config;\n    struct h4_data *h4 = dev->data;\n\n    /* Calculate number of bytes already read */\n    uint16_t read = h4->rx.hdr_len - h4->rx.remaining;\n\n    /* Read remaining bytes from UART FIFO into header buffer */\n    if (uart_fifo_read(cfg->uart, &h4->rx.hdr[read], h4->rx.remaining) != h4->rx.remaining) {\n        LOG_WRN(\"Unable to read H:4 packet header\");\n        h4->rx.type = BT_HCI_H4_NONE;\n        return;\n    }\n\n    /* Update remaining byte count based on number of bytes successfully read */\n    h4->rx.remaining -= read;\n}", "CodeBleu_score": 65.39150769427793}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret;\n\n\tif (len > sizeof(buf)) {\n\t\tlen = sizeof(buf);\n\t}\n\n\tret = uart_fifo_read(uart, buf, len);\n\tif (ret) {\n\t\tLOG_ERR(\"Unable to discard %u bytes (ret %d)\", len, ret);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.33229222330854}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t ret;\n    int err;\n\n    if (len > 32) {\n        len = 32;\n    }\n\n    err = uart_fifo_read(uart, buf, len);\n    if (err) {\n        LOG_ERR(\"Unable to read from UART (ret %d)\", err);\n        return 0;\n    }\n\n    ret = len;\n    while (ret > 0) {\n        err = uart_fifo_read(uart, buf, ret);\n        if (err) {\n            LOG_ERR(\"Unable to read from UART (ret %d)\", err);\n            return len - ret;\n        }\n\n        ret -= err;\n    }\n\n    return len;\n}", "CodeBleu_score": 59.33031094967658}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t ret;\n\n    if (len > 33) {\n        len = 33;\n    }\n\n    ret = uart_fifo_read(uart, buf, len);\n    if (ret) {\n        LOG_ERR(\"Unable to discard %u bytes (ret %d)\", len, ret);\n        return 0;\n    }\n\n    return ret;\n}", "CodeBleu_score": 54.12773285019762}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    int16_t highest_priority = INT16_MAX;\n\n    for (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n        struct zbus_channel_observation *observation;\n        STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\n        const struct zbus_observer *obs = observation->obs;\n\n        if (!obs->data->enabled) {\n            continue;\n        }\n\n        if (obs->data->priority < highest_priority) {\n            highest_priority = obs->data->priority;\n        }\n    }\n\n#if defined(CONFIG_ZBUS_RUNTIME_OBSERVERS)\n    struct zbus_observer_node *obs_nd, *tmp;\n\n    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {\n        const struct zbus_observer *obs = obs_nd->obs;\n\n        if (!obs->data->enabled) {\n            continue;\n        }\n\n        if (obs->data->priority < highest_priority) {\n            highest_priority = obs->data->priority;\n        }\n    }\n#endif /* CONFIG_ZBUS_RUNTIME_OBSERVERS */\n\n    chan->data->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 57.7874528340487}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    int16_t hop = INT16_MAX;\n    struct zbus_channel_observation *observation;\n\n    for (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n        STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\n        const struct zbus_observer *obs = observation->obs;\n\n        if (!obs->data->enabled) {\n            continue;\n        }\n\n        if (obs->priority < hop) {\n            hop = obs->priority;\n        }\n    }\n\n    chan->data->highest_observer_priority = hop;\n}", "CodeBleu_score": 50.25537317616061}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint16_t hop = INT16_MAX;\n\n\tchan_lock(chan);\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; i < limit; ++i) {\n\t\tstruct zbus_channel_observation *observation;\n\t\tstruct zbus_channel_observation_mask *observation_mask;\n\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\tif (!observation->obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (observation->obs->priority < hop) {\n\t\t\thop = observation->obs->priority;\n\t\t}\n\t}\n\n#if defined(CONFIG_ZBUS_RUNTIME_OBSERVERS)\n\tstruct zbus_observer_node *obs_nd, *tmp;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {\n\t\tif (!obs_nd->obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs_nd->obs->priority < hop) {\n\t\t\thop = obs_nd->obs->priority;\n\t\t}\n\t}\n#endif /* CONFIG_ZBUS_RUNTIME_OBSERVERS */\n\n\tchan->data->highest_observer_priority = hop;\n\n\tchan_unlock(chan);\n}", "CodeBleu_score": 62.93477399561599}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *observation;\n    struct zbus_channel_observation_mask *observation_mask;\n\n    K_SPINLOCK(&_zbus_chan_slock) {\n        for (int16_t i = 0, limit = _zbus_chan_observations_count; i < limit; ++i) {\n            STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n            STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n            __ASSERT(observation != NULL, \"observation must be not NULL\");\n\n            const struct zbus_channel *chan = observation->chan;\n\n            if (!chan->data->enabled || observation_mask->enabled) {\n                continue;\n            }\n\n            if (chan->data->observers_end_idx == -1) {\n                continue;\n            }\n\n            for (int16_t j = chan->data->observers_start_idx, limit = chan->data->observers_end_idx; j < limit; ++j) {\n                STRUCT_SECTION_GET(zbus_channel_observation, j, &observation);\n                STRUCT_SECTION_GET(zbus_channel_observation_mask, j, &observation_mask);\n\n                __ASSERT(observation != NULL, \"observation must be not NULL\");\n\n                const struct zbus_observer *obs_ = observation->obs;\n\n                if (!obs_->data->enabled || observation_mask->enabled) {\n                    continue;\n                }\n\n                if (obs_ == obs) {\n                    chan_update_hop(chan);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 17.206113086001718}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *observation;\n    struct zbus_channel_observation_mask *observation_mask;\n\n    for (int16_t i = 0; i < _zbus_channel_observations_count; ++i) {\n        STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n        STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n        __ASSERT(observation != NULL, \"observation must be not NULL\");\n\n        const struct zbus_observer *obs_ = observation->obs;\n\n        if (!obs_->data->enabled || observation_mask->enabled) {\n            continue;\n        }\n\n        if (obs_ == obs) {\n            chan_update_hop(observation->chan);\n        }\n    }\n}", "CodeBleu_score": 24.03277925116141}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_observation *observation;\n    struct zbus_channel_observation_mask *observation_mask;\n\n    K_SPINLOCK(&_zbus_chan_slock) {\n        for (int16_t i = 0; i < _zbus_channel_observations_count; ++i) {\n            STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n            STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n            __ASSERT(observation != NULL, \"observation must be not NULL\");\n\n            const struct zbus_channel *chan = observation->chan;\n\n            if (!chan->data->enabled || observation_mask->enabled) {\n                continue;\n            }\n\n            if (chan->data->observer == obs) {\n                chan_update_hop(chan);\n            }\n        }\n    }\n}", "CodeBleu_score": 19.420290944675813}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority != current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.57115455252737}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    _ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n    _ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n    int current_thread_priority = k_thread_priority_get(k_current_get());\n\n    K_SPINLOCK(&obs_slock) {\n        if (obs->data->priority != current_thread_priority) {\n            obs->data->priority = current_thread_priority;\n\n            update_all_channels_hop(obs);\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 73.17326589161893}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    _ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n    _ZBUS_ASSERT(obs != NULL, \"obs is required\");\n\n    int current_thread_priority = k_thread_priority_get(k_current_get());\n\n    K_SPINLOCK(&obs_slock) {\n        if (obs->data->priority != current_thread_priority) {\n            obs->data->priority = current_thread_priority;\n\n            update_all_channels_hop(obs);\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 73.17326589161893}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int err;\n\n    _ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    k_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n    int context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n    err = chan_lock(chan, timeout, &context_priority);\n    if (err) {\n        return err;\n    }\n\n    err = _zbus_vded_exec(chan, end_time);\n\n    chan_unlock(chan, context_priority);\n\n    return err;\n}", "CodeBleu_score": 88.95742836882025}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 88.77374490325414}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan != NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 88.77374490325414}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    assert_param(IS_ETH_INTERRUPT(Int));\n\n    if (enable) {\n        if (Int & 0x80) {\n            ETH->INT_b.ABNIE = TRUE;\n        } else {\n            ETH->INT_b.NIE = TRUE;\n        }\n    } else {\n        ETH->INT_b.IE &= ~(Int & 0x7F);\n\n        if (ETH->INT_b.ABNIE && (ETH->INT_b.IE & 0x7F) == 0) {\n            ETH->INT_b.ABNIE = FALSE;\n        }\n\n        if (ETH->INT_b.NIE && (ETH->INT_b.IE & 0x7F) == 0) {\n            ETH->INT_b.NIE = FALSE;\n        }\n    }\n}", "CodeBleu_score": 54.78136149038356}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    assert_param(IS_ETH_INTERRUPT(Int));\n    assert_param(IS_ETH_FUNCTIONAL_STATE(enable));\n\n    if (enable) {\n        if (Int == ETH_INT_NORMAL) {\n            ETH->INT_EN_b.NIE = TRUE;\n        } else if (Int == ETH_INT_ABNORMAL) {\n            ETH->INT_EN_b.AIE = TRUE;\n        } else {\n            ETH->INT_EN_b.INT_EN = (1 << (Int - 1));\n        }\n    } else {\n        if (Int == ETH_INT_NORMAL) {\n            ETH->INT_EN_b.NIE = FALSE;\n        } else if (Int == ETH_INT_ABNORMAL) {\n            ETH->INT_EN_b.AIE = FALSE;\n        } else {\n            ETH->INT_EN_b.INT_EN &= ~(1 << (Int - 1));\n        }\n    }\n}", "CodeBleu_score": 61.038592758965336}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    assert_param(IS_ETH_INTERRUPT(Int));\n\n    if (enable) {\n        if (Int & 0x80) {\n            ETH->INT_b.ABNIE = TRUE;\n        } else {\n            ETH->INT_b.NIE = TRUE;\n        }\n    } else {\n        if (Int & 0x80) {\n            ETH->INT_b.ABNIE = FALSE;\n        } else {\n            ETH->INT_b.NIE = FALSE;\n        }\n    }\n\n    ETH->INT_b.IE = ETH->INT_b.NIE | ETH->INT_b.ABNIE;\n}", "CodeBleu_score": 45.19730974434325}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc = (ETH_TX_DESC *)ETH->TDESLA;\n    ETH_TX_DESC *nextDesc = txDesc;\n\n    do {\n        if (0 == nextDesc->TX_0.TX0_b.TCH) {\n            return nextDesc;\n        }\n\n        nextDesc = (ETH_TX_DESC *)nextDesc->nextDescAddr;\n    } while (nextDesc != txDesc);\n\n    return 0;\n}", "CodeBleu_score": 55.84011057140344}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESLA;\n    ETH_TX_DESC *ring = (ETH_TX_DESC *)ETH->TDESLA;\n    ETH_TX_DESC *buf = desc;\n\n    if (!desc) {\n        return 0;\n    }\n\n    do {\n        INNER_ETH_TX_DESC *innerDesc = (INNER_ETH_TX_DESC *)buf;\n        if (innerDesc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_DEV) {\n            innerDesc->TX_0.TX0_b.OWN = ETH_DESC_OWN_BY_SELF;\n            return buf;\n        }\n\n        buf = (ETH_TX_DESC *)buf->nextDescAddr;\n    } while (buf != ring);\n\n    return 0;\n}", "CodeBleu_score": 56.07288219872988}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESLA;\n    ETH_TX_DESC *start = desc;\n    uint32_t *addr = (uint32_t *)desc;\n\n    do {\n        if (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n            desc->TX_0.TX0_b.OWN = ETH_DESC_OWN_BY_HOST;\n            return desc;\n        }\n\n        addr = (uint32_t *)desc->nextDescAddr;\n        desc = (ETH_TX_DESC *)addr;\n    } while (desc != start);\n\n    return 0;\n}", "CodeBleu_score": 62.80906924421169}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    cy_rslt_t result;\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel */\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /* DAC device init */\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 80.07498587520656}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    cy_rslt_t result;\n\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel*/\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC device init*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 80.07498587520656}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    cy_rslt_t result;\n\n    rt_uint32_t cyp_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyhal_dac_t *dac_device;\n\n    dac_device = device->parent.user_data;\n\n    /* get current dac channel*/\n    cyp_channel = cyp_dac_get_channel(channel);\n\n    /*DAC device enable*/\n    result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\n    if (result != RT_EOK) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable fail = %d\n\", result);\n        return -RT_ENOSYS;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 80.07498587520656}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t end_addr = 0;\n    rt_uint32_t i = 0;\n    cy_rslt_t err = CY_RSLT_SUCCESS;\n\n    /* Check the read operation will not exceed the flash memory's end address */\n    end_addr = addr + size;\n    if (end_addr > block_info.start_address + block_info.block_size) {\n        LOG_E(\"Flash read operation will exceed the flash memory's end address\");\n        return -RT_EINVAL;\n    }\n\n    /* Read data from flash memory */\n    for (i = 0; i < size; i++) {\n        err = cyhal_flash_read(&flash_obj, addr + i, buf + i);\n        if (err != CY_RSLT_SUCCESS) {\n            LOG_E(\"Flash read operation failed\");\n            return -RT_ERROR;\n        }\n    }\n\n    return size;\n}", "CodeBleu_score": 47.54514802716918}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t end_addr = addr + size;\n\n    if (end_addr > block_info.start_address + block_info.block_size) {\n        LOG_E(\"read out of flash\");\n        return -RT_EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        *(buf + i) = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 48.28608260052807}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 45.02898307996257}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 45.02898307996257}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *tim = RT_NULL;\n\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 45.02898307996257}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 8.060973252351632}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 8.060973252351632}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 8.060973252351632}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    /* Search for an empty slot starting from the specified index */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table */\n    if (fd_slot_expand(fdt, startfd) == -1) {\n        return -1;\n    }\n\n    return startfd;\n}", "CodeBleu_score": 47.67538258924066}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    return fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 33.664274934899474}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    /* Search for an empty slot starting from the specified index */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table */\n    if (index < DFS_FD_MAX) {\n        return fd_slot_expand(fdt, index);\n    }\n\n    return -1;  /* No empty slot found and expansion failed */\n}", "CodeBleu_score": 42.38648576772436}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    int i;\n\n    /* Convert negative error code to positive */\n    if (error < 0) {\n        error = -error;\n    }\n\n    /* Search for the error code in the error string array */\n    for (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++) {\n        if (rt_errno_strs[i].error == error) {\n            return rt_errno_strs[i].str;\n        }\n    }\n\n    /* Return \"EUNKNOW\" if the error code is not found */\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 82.07427590637212}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    rt_int32_t i;\n    rt_err_t err = error;\n\n    if (error < 0) {\n        err = -error;\n    }\n\n    for (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++) {\n        if (err == rt_errno_strs[i].error) {\n            return rt_errno_strs[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 70.8570207484864}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    const char *str = \"EUNKNOW\";\n    rt_int32_t i;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++) {\n        if (rt_errno_strs[i].error == error) {\n            str = rt_errno_strs[i].str;\n            break;\n        }\n    }\n\n    return str;\n}", "CodeBleu_score": 73.80374154842097}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_uint8_t i;\n    rt_err_t result = -RT_EFULL;\n    rt_uint32_t cpu_id = rt_hw_cpu_id();\n    struct rt_thread *thread = &idle_thread[cpu_id];\n    rt_uint32_t ticks = rt_tick_get();\n\n    /* lock the spinlock */\n    level = rt_hw_interrupt_disable();\n    rt_spinlock_take(&_hook_spinlock);\n\n    /* find an empty slot */\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* unlock the spinlock */\n    rt_spinlock_release(&_hook_spinlock);\n    rt_hw_interrupt_enable(level);\n\n    /* set the idle thread hook function */\n    thread->idle_hook = hook;\n    thread->idle_ticks = ticks;\n\n    return result;\n}", "CodeBleu_score": 67.98790994648276}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_size_t i;\n    rt_err_t result = -RT_EFULL;\n    rt_uint8_t *p = (rt_uint8_t *)&result;\n    rt_uint8_t *q = (rt_uint8_t *)&i;\n    rt_uint8_t *r = (rt_uint8_t *)&level;\n    rt_uint8_t *s = (rt_uint8_t *)&_hook_spinlock;\n\n    rt_spinlock_irq_enter(&_hook_spinlock);\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_spinlock_irq_leave(&_hook_spinlock);\n\n    return result;\n}", "CodeBleu_score": 70.44622053307094}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_err_t result;\n    rt_uint8_t i;\n\n    if (hook == RT_NULL)\n        return -RT_EINVAL;\n\n    level = rt_hw_interrupt_disable();\n    rt_spinlock_take(&_hook_spinlock);\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    if (i == RT_IDLE_HOOK_LIST_SIZE)\n        result = -RT_EFULL;\n    rt_spinlock_release(&_hook_spinlock);\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 69.11095420207735}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.66622949429424}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.66622949429424}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n\n    level = rt_spin_lock_irqsave(&_hook_spinlock);\n\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == hook) {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n    return ret;\n}", "CodeBleu_score": 98.66622949429424}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_sched_lock_level_t slvl;\n    rt_thread_t thread;\n    rt_err_t error;\n\n    RT_SCHED_DEBUG_IS_UNLOCKED;\n    RT_ASSERT(susp_list != RT_NULL);\n\n    rt_sched_lock(&slvl);\n    while (!rt_list_isempty(susp_list)) {\n        thread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n        error = rt_sched_thread_ready(thread);\n\n        if (error) {\n            LOG_D(\"[error:%d] failed to resume thread:%p from suspended list\", error, thread);\n        } else {\n            /* thread error should not be a negative value */\n            if (thread_error >= 0) {\n                /* set thread error code to notified resuming thread */\n                thread->error = thread_error;\n            }\n        }\n    }\n    rt_sched_unlock(slvl);\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.28382628998076}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_sched_lock_level_t slvl;\n    rt_thread_t thread;\n    rt_err_t error;\n\n    RT_SCHED_DEBUG_IS_UNLOCKED;\n    RT_ASSERT(susp_list != RT_NULL);\n\n    rt_sched_lock(&slvl);\n    while (!rt_list_isempty(susp_list)) {\n        thread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n        error = rt_sched_thread_ready(thread);\n\n        if (error) {\n            LOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\",\n                  __func__, error, thread);\n        } else {\n            /* thread error should not be a negative value */\n            if (thread_error >= 0) {\n                /* set thread error code to notified resuming thread */\n                thread->error = thread_error;\n            }\n        }\n    }\n    rt_sched_unlock(slvl);\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.898949649334796}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_sched_lock_level_t slvl;\n    rt_thread_t thread;\n    rt_err_t error;\n\n    RT_SCHED_DEBUG_IS_UNLOCKED;\n    RT_ASSERT(susp_list != RT_NULL);\n\n    rt_sched_lock(&slvl);\n    while (!rt_list_isempty(susp_list)) {\n        thread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n        error = rt_sched_thread_ready(thread);\n\n        if (error) {\n            LOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\",\n                  __func__, error, thread);\n        } else {\n            /* thread error should not be a negative value */\n            if (thread_error >= 0) {\n                /* set thread error code to notified resuming thread */\n                thread->error = thread_error;\n            }\n        }\n    }\n    rt_sched_unlock(slvl);\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.898949649334796}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = rt_console_get_device();\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    rt_device_t new_console = rt_device_find(name);\n\n    if (new_console != RT_NULL) {\n        rt_err_t result = rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n        if (result == RT_EOK) {\n            _console_device = new_console;\n        }\n    }\n\n    return old_console;\n}", "CodeBleu_score": 50.29636022843509}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_device;\n    rt_device_t old_device;\n\n    /* get the current console device */\n    old_device = rt_console_get_device();\n\n    /* find the new console device by name */\n    new_device = rt_device_find(name);\n\n    /* check if the new device is the same as the current device */\n    if (new_device != old_device) {\n        /* close the current console device if it exists */\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n\n        /* open the new console device with read/write and stream flags */\n        if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n            /* set the new device as the console device */\n            _console_device = new_device;\n        } else {\n            /* if the new device cannot be opened, set the old device as the console device */\n            _console_device = old_device;\n            new_device = RT_NULL;\n        }\n    }\n\n    /* return the old console device */\n    return new_device;\n}", "CodeBleu_score": 67.04087698854411}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t device;\n    rt_device_t old_device;\n\n    old_device = _console_device;\n\n    if (name != RT_NULL) {\n        device = rt_device_find(name);\n        if (device != RT_NULL) {\n            if (device == old_device) {\n                return old_device;\n            }\n\n            if (device->open_flag & RT_DEVICE_FLAG_STREAM) {\n                if (old_device != RT_NULL) {\n                    old_device->close(old_device);\n                }\n\n                device->open_flag |= RT_DEVICE_FLAG_RDWR;\n                device->open(device, RT_DEVICE_OFLAG_RDWR);\n                _console_device = device;\n            } else {\n                LOG_E(\"Not a stream device, can't be set as console device.\");\n            }\n        }\n    }\n\n    return old_device;\n}", "CodeBleu_score": 61.273665095799025}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_information *information;\n    int count = 0;\n\n    /* get object information */\n    information = rt_object_get_information(type);\n    if (information == RT_NULL)\n        return 0;\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* get object count */\n    count = rt_list_length(&(information->object_list));\n\n    /* leave critical */\n    rt_exit_critical();\n\n    return count;\n}", "CodeBleu_score": 42.2864752569731}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *information;\n    rt_list_t *head;\n    rt_object_t object;\n\n    information = rt_object_get_information(type);\n    if (information != RT_NULL) {\n        rt_spinlock_t *spinlock = &information->lock;\n        rt_base_t level;\n\n        level = rt_hw_interrupt_disable();\n        rt_spinlock_take(spinlock);\n\n        head = &information->object_list;\n        for (object = rt_list_entry(head->next, struct rt_object, list);\n             &object->list != head;\n             object = rt_list_entry(object->list.next, struct rt_object, list))\n        {\n            count++;\n        }\n\n        rt_spinlock_release(spinlock);\n        rt_hw_interrupt_enable(level);\n    }\n\n    return count;\n}", "CodeBleu_score": 44.2751562092156}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_information *information;\n    int count = 0;\n\n    information = rt_object_get_information(type);\n    if (information == RT_NULL) return 0;\n\n    rt_spinlock_lock(&information->lock);\n    {\n        struct rt_object *object;\n\n        object = information->object_list.next;\n        while (object != &information->object_list) {\n            count ++;\n            object = object->list.next;\n        }\n    }\n    rt_spinlock_unlock(&information->lock);\n\n    return count;\n}", "CodeBleu_score": 54.38167402939579}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    if (object == RT_NULL) {\n        return;\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    struct rt_object_information *information = rt_object_get_information(object->type);\n    if (information == RT_NULL) {\n        return;\n    }\n\n    rt_base_t level = rt_spin_lock_irqsave(&(information->spinlock));\n    rt_list_remove(&(object->list));\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 58.7478601065329}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    struct rt_object_information *information;\n\n    /* check object */\n    if (object == RT_NULL) {\n        return;\n    }\n\n    /* call hook function */\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    /* get object information */\n    information = rt_object_get_information(object->type);\n    if (information == RT_NULL) {\n        return;\n    }\n\n    /* enter critical */\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* leave critical */\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    /* set object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 73.66809246191382}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    struct rt_object_information *information;\n\n    /* check object */\n    if (object == RT_NULL) return;\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    /* get object information */\n    information = rt_object_get_information(object->type);\n    if (information == RT_NULL) return;\n\n    /* enter critical */\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* leave critical */\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    /* set object type to unknown */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 76.2330489449316}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    struct rt_custom_object *cobj = RT_NULL;\n    rt_err_t result = RT_EOK;\n\n    if (obj == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    cobj = (struct rt_custom_object *)obj;\n    if (cobj->destroy) {\n        result = cobj->destroy(cobj->data);\n    }\n\n    rt_object_delete(obj);\n    return result;\n}", "CodeBleu_score": 63.92378876017069}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    struct rt_custom_object *cobj = (struct rt_custom_object *)obj;\n    rt_err_t result = -RT_EINVAL;\n\n    if (cobj && cobj->destroy) {\n        result = cobj->destroy(cobj->data);\n    }\n\n    rt_object_delete(obj);\n    return result;\n}", "CodeBleu_score": 53.48325374920926}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    struct rt_custom_object *cobj = RT_NULL;\n    rt_err_t result = -RT_EINVAL;\n\n    if (obj != RT_NULL) {\n        cobj = (struct rt_custom_object *)obj;\n        if (cobj->type == RT_Object_Class_Custom) {\n            if (cobj->destroy) {\n                result = cobj->destroy(cobj->data);\n            }\n            rt_object_delete(obj);\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 74.2847358674629}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close the thread */\n    _thread_close(thread);\n\n    /* add the thread to the defunct list */\n    rt_list_insert_after(&rt_thread_defunct, &thread->tlist);\n\n    /* leave critical section */\n    rt_exit_critical();\n\n    /* trigger a context switch */\n    rt_schedule();\n}", "CodeBleu_score": 38.25541419807547}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_err_t result;\n\n    /* get current thread */\n    thread = rt_thread_self();\n    RT_ASSERT(thread != RT_NULL);\n\n    /* enter critical section */\n    result = rt_hw_interrupt_disable();\n\n    /* close thread */\n    result = _thread_close(thread);\n    if (result != RT_EOK) {\n        LOG_E(\"thread exit failed, result: %d\", result);\n        rt_hw_interrupt_enable(result);\n        return;\n    }\n\n    /* leave critical section */\n    rt_hw_interrupt_enable(result);\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 58.18225235438585}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_tick_t tick;\n    rt_uint32_t level;\n    rt_thread_t idle;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    level = rt_hw_interrupt_disable();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add thread to defunct thread list */\n    rt_list_insert_after(&(rt_thread_defunct), &(thread->tlist));\n\n    /* exit critical section */\n    rt_hw_interrupt_enable(level);\n\n    /* trigger context switch */\n    tick = rt_tick_get();\n    idle = rt_thread_self();\n    rt_schedule_insert_thread(idle);\n    rt_schedule();\n\n    /* never reach here */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 58.58860012096786}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    rt_base_t critical_level;\n\n    /* get current thread */\n    thread = (struct rt_thread *)parameter;\n\n    /* parameter check */\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    critical_level = rt_enter_critical();\n\n    /* check thread suspend */\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_exit_critical_safe(critical_level);\n        return;\n    }\n\n    /* set thread error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert into ready list */\n    rt_list_insert_after(&(thread->tlist), &(rt_thread_priority_table[thread->current_priority].threads));\n\n    rt_exit_critical_safe(critical_level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 50.867288045422484}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    rt_base_t level;\n\n    thread = (struct rt_thread *)parameter;\n\n    /* check thread */\n    if ((thread == NULL) || (thread->stat != RT_THREAD_SUSPEND)) {\n        return;\n    }\n\n    level = rt_hw_interrupt_disable();\n\n    /* set thread error number */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert into ready list */\n    rt_thread_ready_insert(thread);\n\n    /* unlock scheduler */\n    rt_hw_interrupt_enable(level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 51.514627282231565}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    rt_base_t critical_level;\n\n    /* get current thread */\n    thread = (struct rt_thread *) parameter;\n\n    /* parameter check */\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    /* lock scheduler */\n    critical_level = rt_enter_critical();\n\n    /* check thread state */\n    if (thread->stat != RT_THREAD_SUSPEND) {\n        rt_exit_critical_safe(critical_level);\n        return;\n    }\n\n    /* set thread error number to timeout */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert into ready list */\n    rt_list_insert_after(&(thread->tlist), &rt_thread_ready);\n\n    /* unlock scheduler */\n    rt_exit_critical_safe(critical_level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 50.65598036759887}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t critical_level;\n    rt_mutex_t mutex;\n\n    /* Lock the thread's spinlock */\n    critical_level = rt_enter_critical();\n\n    /* Check if the thread is waiting on a mutex */\n    mutex = thread->waiting_mutex;\n    if (mutex != RT_NULL) {\n        /* Remove the thread from the mutex's waiting list */\n        rt_mutex_detach_thread(mutex, thread);\n        /* Clear the pending object */\n        thread->waiting_mutex = RT_NULL;\n    }\n\n    /* Release all mutexes the thread has taken */\n    rt_mutex_release_all(thread);\n\n    /* Restore the spinlock state */\n    rt_exit_critical_safe(critical_level);\n}", "CodeBleu_score": 27.133721821574497}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_base_t critical_level;\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->wait_object != RT_NULL) {\n        /* Get the mutex object */\n        mutex = (rt_mutex_t)thread->wait_object;\n\n        /* Lock the mutex's spinlock */\n        critical_level = rt_mutex_enter(mutex);\n\n        /* Remove the thread from the mutex's waiting list */\n        rt_list_remove(&thread->tlist);\n\n        /* Clear the pending object */\n        thread->wait_object = RT_NULL;\n\n        /* Release the mutex's spinlock */\n        rt_mutex_leave(mutex, critical_level);\n    }\n\n    /* Release all mutexes the thread has taken */\n    rt_mutex_release_all(thread);\n}", "CodeBleu_score": 24.046860181676017}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t critical_level;\n    rt_list_t *node;\n\n    /* Lock the thread's spinlock */\n    critical_level = rt_enter_critical();\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->waiting_mutex != RT_NULL) {\n        /* Remove the thread from the mutex's waiting list */\n        node = &RT_MUTEX_LIST_NODE(thread);\n        rt_list_remove(node);\n        thread->waiting_mutex = RT_NULL;\n        thread->waiting_mutex_list_node = RT_NULL;\n    }\n\n    /* Release all mutexes the thread has taken */\n    rt_mutex_release_all(thread);\n\n    /* Restore the spinlock state */\n    rt_exit_critical_safe(critical_level);\n}", "CodeBleu_score": 29.788749451024216}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n\n    /* check thread state */\n    if (thread->stat != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n\n    /* check thread type */\n    if (thread->parent.type != RT_Object_Class_Thread) {\n        return -RT_ERROR;\n    }\n\n    /* log thread information */\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread name:%s, priority:%d\n\", thread->parent.name, thread->current_priority));\n\n    /* calculate thread priority attributes */\n    thread->thread_priority = thread->current_priority;\n    thread->thread_tick = thread->init_tick;\n\n    /* reset thread state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    if (rt_scheduler_get_systick_period() != 0) {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 50.684763923192854}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n\n    /* check thread state */\n    if (thread->current_priority != -1) {\n        return -RT_ERROR;\n    }\n\n    /* check thread type */\n    RT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n    /* log thread name and priority */\n    LOG_D(\"Thread '%s' start, priority: %d\", thread->parent.name, thread->current_priority);\n\n    /* calculate thread priority attributes */\n    thread->priority_bitmap = (rt_uint32_t)1 << (RT_THREAD_PRIORITY_MAX - thread->current_priority);\n\n    /* reset thread state */\n    thread->stat = RT_THREAD_STAT_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    if (rt_thread_self() != RT_NULL) {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 55.880793282056416}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n\n    /* thread should be in initialization state */\n    RT_ASSERT(thread->current_priority == -1);\n\n    /* thread object check */\n    RT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n    /* log thread information */\n    LOG_D(\"Thread '%s' startup(priority=%d).\", thread->parent.name, thread->current_priority);\n\n    /* calculate the thread's priority attributes */\n    thread->priority_attr = thread->current_priority;\n    thread->priority_attr |= thread->number_mask << RT_THREAD_PRIORITY_BITS;\n    thread->priority_attr |= thread->priority << (RT_THREAD_PRIORITY_BITS + RT_THREAD_PRIORITY_MASK_BITS);\n\n    /* reset thread state */\n    thread->stat = RT_THREAD_INIT;\n\n    /* resume thread */\n    result = rt_thread_resume(thread);\n    if (result != RT_EOK) {\n        return result;\n    }\n\n    /* trigger scheduler */\n    rt_schedule();\n\n    return RT_EOK;\n}", "CodeBleu_score": 50.361591339703146}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    struct rt_timer *timer;\n\n    if (timer_list[0].next != &timer_list[0]) {\n        list = timer_list[0].next;\n        timer = rt_list_entry(list, struct rt_timer, row[0]);\n        *timeout_tick = timer->timeout_tick;\n        return RT_EOK;\n    } else {\n        return -RT_ERROR;\n    }\n}", "CodeBleu_score": 58.19185382136936}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    struct rt_timer *timer;\n\n    /* get the highest level list */\n    list = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n    /* if the list is not empty, get the first timer entry */\n    if (!rt_list_isempty(list)) {\n        timer = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n        *timeout_tick = timer->timeout_tick;\n        return RT_EOK;\n    }\n\n    /* if the list is empty, return an error code */\n    return -RT_ERROR;\n}", "CodeBleu_score": 72.43502563904276}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    struct rt_timer *timer;\n\n    if (!rt_list_isempty(&timer_list[0])) {\n        timer = rt_list_entry(timer_list[0].next, struct rt_timer, row[0]);\n        *timeout_tick = timer->timeout_tick;\n        return RT_EOK;\n    }\n    return -RT_ERROR;\n}", "CodeBleu_score": 53.09702987987799}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for timer object */\n    struct rt_timer *timer = (struct rt_timer *)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* timer object initialization */\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 82.00065352883126}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for the timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        /* initialize the timer object */\n        rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n        _timer_init(timer, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 73.55327538819196}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for timer */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        /* initialize timer */\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 69.22139131630752}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(`{\"error\": \"Not Authorized\"}`))\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\trec.Body.Reset()\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 65.86744461093289}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \\\"Not Authorized\\\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\trec.Body.Reset()\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 65.42266300483583}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\trobeaux.JSONError(res, http.StatusUnauthorized, \"Not Authorized\")\n\t\t\treturn\n\t\t}\n\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 69.91844964746697}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := Asset(fmt.Sprintf(\"public%s\", req.URL.Path))\n\tif err != nil {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.Contains(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.Contains(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.Contains(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 52.55098360002863}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tfile, err := Asset(fmt.Sprintf(\"public/%s\", req.URL.Path[1:]))\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch path.Ext(req.URL.Path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(file)\n}", "CodeBleu_score": 49.28230700798966}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path[1:]\n\tasset, err := Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 55.539619422220554}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.91081293671324}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.91081293671324}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 94.91081293671324}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+r.URL.Path+`\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 54.215637680730566}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(u)) != 1 || subtle.ConstantTimeCompare([]byte(password), []byte(p)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 47.69192680195384}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\tw.WriteHeader(401)\n\t\t\tw.Write([]byte(\"Not Authorized.\n\"))\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.45725218294801}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tval := int(slope*input + intercept)\n\t\tif val > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\tif val < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\treturn val\n\t}\n}", "CodeBleu_score": 69.08022443312841}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 57.68744604507211}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\toutput := slope*input + intercept\n\t\tif output < float64(toMin) {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > float64(toMax) {\n\t\t\treturn toMax\n\t\t}\n\t\treturn int(output)\n\t}\n}", "CodeBleu_score": 66.44103482520363}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tval, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = val\n\ta.lastValue = a.sensorCfg.scale(val)\n\n\treturn val, a.lastValue, nil\n}", "CodeBleu_score": 42.46316871042895}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, fmt.Errorf(\"analog sensor: connection not initialized\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\n\treturn a.lastRawValue, a.lastValue, nil\n}", "CodeBleu_score": 56.859407673089954}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, fmt.Errorf(\"analog sensor: connection not initialized\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\n\treturn rawValue, a.lastValue, nil\n}", "CodeBleu_score": 53.13919399883047}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tm := toRange / float64(fromRange)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\tscaled := m*float64(input) + n\n\t\tif scaled > toMax {\n\t\t\treturn toMax\n\t\t} else if scaled < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 65.90032346667878}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\tscaled := m*float64(input) + n\n\t\tif scaled < toMin {\n\t\t\treturn toMin\n\t\t} else if scaled > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 76.75052359494619}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tm := toRange / float64(fromRange)\n\tn := toMin - m*float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 56.658995605924325}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\tif err := d.Eventer.AddEvent(Data, d.publishVibrationEvent); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 62.68267170644649}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\tif err := d.Eventer.AddEvent(aio.Data, d.handleVibration); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 62.40188103417004}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\td.AddEvent(Vibration)\n\n\tif err := d.Eventer.AddEvent(Data, d.handleData); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &d\n}", "CodeBleu_score": 61.94576346451759}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1000000 / hz\n\ttempo := 600000 / d.bpm\n\tcount := int(duration / tempo)\n\n\tfor i := 0; i < count; i++ {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tempo) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.69620006296571}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := uint64(1000000 / hz)\n\ttempo := uint64(60000000 / d.bpm)\n\tdurations := uint64(duration * 1000)\n\n\tfor i := uint64(0); i < durations; i += tempo {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 66.49016081014786}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1000000 / hz\n\ttempo := 600000 / d.bpm\n\n\tfor i := 0.0; i < duration*1000; i += period {\n\t\tif err := d.Toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tempo) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.34468996081762}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 97.42204276111762}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 97.42204276111762}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 97.42204276111762}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"not initialized\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin != nil {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin = a.sys.NewAnalogPin(path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 76.43126377524743}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"analog pins not initialized\\\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin != nil {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin = a.sys.NewAnalogPin(path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 74.82371390415462}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"pins are not initialized\\\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 63.86612049399925}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 80.57237800109367}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 72.46441017087983}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"not connected\")\n\t}\n\topts = append(a.pinOptions, opts...)\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := system.IDToChipAndLine(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = system.NewDigitalPin(chip, line, system.WithPinLogger(a.logger))\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := pin.Export(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 60.99700356283646}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"digital pins adaptor is not initialized\")\n\t}\n\topts = append(a.pinOptions, opts...)\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := system.PinToChipLine(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = system.NewDigitalPin(chip, line, opts...)\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 55.29181025332727}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Not connected\")\n\t}\n\topts = append(a.pinOptions, opts...)\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := system.PinToChipLine(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = system.NewDigitalPin(chip, line, system.WithPinID(id), system.WithPinOptions(opts...))\n\t\tif err := pin.ApplyOptions(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 61.261015755476855}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)    switch (usb_setup.bRequest) {\n        case 0x04: {\n            // Microsoft-compatible ID\n            usb_control_payload_ptr = (uint8_t *)&usb_descriptor_ms_id;\n            usb_control_payload_size = sizeof(usb_descriptor_ms_id);\n            return true;\n        }\n        case 0x05: {\n            // Microsoft-compatible extended properties\n            usb_control_payload_ptr = (uint8_t *)&usb_descriptor_ms_extended_properties;\n            usb_control_payload_size = sizeof(usb_descriptor_ms_extended_properties);\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 16.15583324171484}, {"code": "bool usb_task_other_requests(void)    switch (usb_setup.bRequest) {\n        case 0x04:\n            usb_control_request_payload = (uint8_t *)&microsoft_id_descriptor;\n            usb_control_request_payload_size = sizeof(microsoft_id_descriptor);\n            return true;\n        case 0x05:\n            usb_control_request_payload = (uint8_t *)&microsoft_extended_properties_descriptor;\n            usb_control_request_payload_size = sizeof(microsoft_extended_properties_descriptor);\n            return true;\n        default:\n            return false;\n    }\n}", "CodeBleu_score": 17.80990671211687}, {"code": "bool usb_task_other_requests(void)    // Check if the request type is vendor-specific\n    if (usb_get_setup_request_type() == USB_SETUP_REQUEST_TYPE_VENDOR) {\n        // Check if the request index is 0x04 or 0x05\n        if (usb_get_setup_request_index() == 0x04 || usb_get_setup_request_index() == 0x05) {\n            // Set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors\n            uint8_t *p_payload = NULL;\n            uint16_t payload_size = 0;\n\n            // Process request index 0x04\n            if (usb_get_setup_request_index() == 0x04) {\n                p_payload = (uint8_t *)&usb_descriptor_ms_id;\n                payload_size = sizeof(usb_descriptor_ms_id);\n            }\n\n            // Process request index 0x05\n            if (usb_get_setup_request_index() == 0x05) {\n                p_payload = (uint8_t *)&usb_descriptor_ms_ext_prop;\n                payload_size = sizeof(usb_descriptor_ms_ext_prop);\n            }\n\n            // Update the control request payload and size\n            usb_set_control_request_payload(p_payload, payload_size);\n\n            // Return true to indicate that the request is processed\n            return true;\n        }\n    }\n\n    // Return false to indicate that the request is not recognized\n    return false;\n}\n", "CodeBleu_score": 28.192753289632467}]}
