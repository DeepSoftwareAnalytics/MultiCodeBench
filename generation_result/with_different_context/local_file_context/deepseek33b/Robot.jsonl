{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    if (download) {\n      for (auto &file : files) {\n        if (!FileTransfer::FileExists(file)) {\n          FileTransfer::DownloadFile(file);\n          std::cout << \"Downloaded: \" << file << std::endl;\n        } else {\n          std::cout << \"Found in cache: \" << file << std::endl;\n        }\n      }\n    }\n    return files;\n  }", "CodeBleu_score": 65.27842369210303}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n    std::vector<std::string> files_list = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    for (const auto &file : files_list) {\n        if (download) {\n            if (!FileTransfer::FileExists(file)) {\n                std::cout << \"Downloading file: \" << file << std::endl;\n                _pimpl->CallAndWait<void>(\"download_file\", file);\n            } else {\n                std::cout << \"File found in cache: \" << file << std::endl;\n            }\n        }\n        required_files.push_back(file);\n    }\n\n    return required_files;\n}", "CodeBleu_score": 52.02736637283599}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    if (download) {\n      for (auto &file : files) {\n        if (!FileTransfer::FileExists(file)) {\n          _pimpl->CallAndWait<void>(\"download_file\", file);\n          DEBUG_ASSERT(FileTransfer::FileExists(file));\n          log_info(\"downloaded file:\", file);\n        } else {\n          log_info(\"found file in cache:\", file);\n        }\n      }\n    }\n    return files;\n  }", "CodeBleu_score": 63.95494580882548}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n    // Check the validity of the transformation to avoid ill-formed transformations\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.x != 0.0f || transform.location.y != 0.0f) {\n        log_warning(\\\"The translation of the SpringArm/SpringArmGhost actor must be only in the 'z' axis\\\");\n      }\n    }\n\n    // Call the internal function to complete the actor spawning process\n    return _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n  }", "CodeBleu_score": 39.35317656698998}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.x != 0.0f || transform.location.y != 0.0f) {\n        log_warning(\\\"SpringArm and SpringArmGhost attachments should not have a translation in the x and y axes.\\\");\n      }\n    }\n    return _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n  }", "CodeBleu_score": 38.682408427142555}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t    // Check if the transformation is valid\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      // Check if the transformation is valid\n      if (transform.location.x != 0.0f || transform.location.y != 0.0f ||\n          transform.location.z != 0.0f || transform.rotation.pitch != 0.0f ||\n          transform.rotation.roll != 0.0f) {\n        log_warning(\\\"Invalid transformation for a SpringArm/SpringArmGhost attachment: \\\"\n\\\"  location: \\\" + std::to_string(transform.location.x) + \\\" \\\" + std::to_string(transform.location.y) + \\\" \\\" + std::to_string(transform.location.z) + \\\" \\\"\n\\\"  rotation: \\\" + std::to_string(transform.rotation.pitch) + \\\" \\\" + std::to_string(transform.rotation.roll) + \\\" \\\" + std::to_string(transform.rotation.yaw));\n      }\n    }\n\n    return _pimpl->CallAndWait<rpc::Actor>(\\\"spawn_actor_with_parent\\\", description, transform, parent, attachment_type, socket_name);\n  }", "CodeBleu_score": 42.894824951713154}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    carla::streaming::detail::token_type thisToken;\n    thisToken.set_type(carla::streaming::detail::token_type::type::GBuffer);\n    thisToken.set_stream_id(ActorId);\n    thisToken.set_data(GBufferId);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\"get_sensor_token\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }", "CodeBleu_score": 49.00094524986483}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    carla::streaming::detail::token_type token = _pimpl->CallAndWait<carla::streaming::detail::token_type>(\"get_gbuffer_token\", ActorId, GBufferId);\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->streaming_client.Subscribe(thisToken, std::move(callback));\n  }", "CodeBleu_score": 46.88905763404415}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    carla::streaming::detail::token_type thisToken(GetGBufferToken(ActorId, GBufferId));\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\"get_sensor_token\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }", "CodeBleu_score": 43.80782628484401}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.lock();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>(*this);\n        if (!_walker_navigation.compare_exchange(&navigation, navigation)) {\n            navigation = _walker_navigation.lock();\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 54.230489427998485}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (_walker_navigation == nullptr) {\n    _walker_navigation = std::make_shared<WalkerNavigation>();\n    _walker_navigation->SetEpisode(shared_from_this());\n  }\n  return _walker_navigation;\n}", "CodeBleu_score": 35.94336448330316}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.lock();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>(_client, _simulator.lock());\n        if (_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n            navigation->SetEpisode(shared_from_this());\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 50.40076110253264}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetFrame() < frame) {\n    if (std::chrono::system_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 40.823756470490956}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto deadline = std::chrono::steady_clock::now() + timeout;\n  while (episode.GetFrame() < frame) {\n    if (std::chrono::steady_clock::now() > deadline) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 36.53497064039516}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetFrame() < frame) {\n    if (std::chrono::system_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 40.823756470490956}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n    if (episode_id == 0) {\n        throw_exception(std::runtime_error(\"failed to load episode\"));\n    }\n\n    // Wait for the episode to be ready.\n    auto timeout = _client.GetClientSettings().connection_timeout;\n    auto deadline = std::chrono::system_clock::now() + timeout.to_chrono();\n    while (true) {\n        auto new_episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n        if (new_episode_id != episode_id) {\n            episode_id = new_episode_id;\n            break;\n        }\n        if (std::chrono::system_clock::now() > deadline) {\n            throw_exception(std::runtime_error(\"failed to load episode\"));\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n\n    // Wait for the episode to be ready.\n    auto start = std::chrono::system_clock::now();\n    while (!_client.GetEpisode(episode_id).IsReady()) {\n        if (std::chrono::system_clock::now() > deadline) {\n            throw_exception(std::runtime_error(\"failed to load episode\"));\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n\n    // Check if the episode has a valid map.\n    auto map_name_from_episode = _client.GetEpisode(episode_id).GetMapName();\n    if (map_name_from_episode.empty()) {\n        throw_exception(std::runtime_error(\"failed to load episode\"));\n    }\n\n    // Return the episode object.\n    return GetEpisode(episode_id);\n}", "CodeBleu_score": 45.51694126733609}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to be loaded.\n  const auto timeout = time_duration::from_seconds(10.0);\n  const auto start = std::chrono::system_clock::now();\n  while (_client.GetEpisodeId() != episode_id) {\n    std::this_thread::yield();\n    const auto end = std::chrono::system_clock::now();\n    const auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n    if (timeout.to_chrono() < diff) {\n      throw_exception(std::runtime_error(\"timeout exceeded\"));\n    }\n  }\n\n  // Set the episode ID and return the episode object.\n  _episode_id = episode_id;\n  return GetCurrentEpisode();\n}", "CodeBleu_score": 49.85198199445028}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  EpisodeProxy episode(episode_id, _client);\n  // Wait for episode to be ready.\n  auto start = std::chrono::system_clock::now();\n  while (episode.GetId() != episode_id) {\n    std::this_thread::yield();\n    auto end = std::chrono::system_clock::now();\n    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n    if(diff > std::chrono::seconds(5)) {\n      throw_exception(std::runtime_error(\"Failed to load episode\"));\n    }\n  }\n  return episode;\n}", "CodeBleu_score": 48.22620770158771}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (!walker) {\n    throw_exception(std::runtime_error(\"Walker is not available\"));\n  }\n  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterWalker(walker->GetId());\n}", "CodeBleu_score": 64.15645116287428}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = controller.GetWalker();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"Walker is not available\"));\n  }\n  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterWalker(walker->GetId());\n}", "CodeBleu_score": 68.38602070334217}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  auto walker = nav->GetWalker(controller.GetId());\n  if (!walker) {\n    throw_exception(std::runtime_error(\"Walker with id \" + std::to_string(controller.GetId()) + \" not found.\"));\n  }\n  nav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 67.81121703471031}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n  DEBUG_ASSERT(_episode != nullptr);\n\n  // spawn actor\n  const auto actor_id = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  // register actor\n  auto actor = MakeActor(actor_id);\n  _episode->RegisterActor(actor, gc);\n\n  // log creation details\n  const auto actor_type = blueprint.GetType();\n  const auto actor_name = blueprint.GetId();\n  const auto actor_display_id = actor->GetDisplayId();\n  const auto parent_display_id = (parent != nullptr ? parent->GetDisplayId() : \"\");\n  const auto attachment_type_str = (parent != nullptr ? std::to_string(static_cast<uint32_t>(attachment_type)) : \"\");\n  const auto socket_name_str = (parent != nullptr ? socket_name : \"\");\n  log_info(\n      \"spawned actor: id=\\\"\", actor_id, \"\\\", type=\\\"\", actor_type, \"\\\", name=\\\"\", actor_name, \"\\\", display_id=\\\"\", actor_display_id, \"\\\", parent=\\\"\", parent_display_id, \"\\\", attachment_type=\\\"\", attachment_type_str, \"\\\", socket_name=\\\"\", socket_name_str, \"\\\"\");\n\n  return actor;\n}", "CodeBleu_score": 44.98689646809622}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  DEBUG_ASSERT(_episode != nullptr);\n\n  // spawn the actor\n  auto actor_id = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  if (!actor_id.has_value()) {\n    throw_exception(std::runtime_error(\"failed to spawn actor\"));\n  }\n\n  // register the actor\n  auto actor = MakeActor(*actor_id);\n  _episode->RegisterActor(actor, gc);\n\n  // log the creation details\n  auto blueprint_name = blueprint.GetDisplayId();\n  auto actor_name = actor->GetDisplayId();\n  auto parent_name = parent != nullptr ? parent->GetDisplayId() : \"None\";\n  auto attachment_type_name = rpc::AttachmentTypeName(attachment_type);\n  auto socket_name_str = socket_name.empty() ? \"None\" : socket_name;\n  log_debug(\n      \"spawned actor: \" + actor_name + \"\n      blueprint: \" + blueprint_name + \"\n      parent: \" + parent_name + \"\n      attachment: \" + attachment_type_name + \"\n      socket: \" + socket_name_str);\n\n  return actor;\n}", "CodeBleu_score": 47.640997799355524}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n  // spawn actor\n  auto actor_id = _client.SpawnActor(blueprint.GetId(), transform, parent, attachment_type, socket_name);\n  auto actor = MakeActor(actor_id);\n\n  // register actor\n  _episode->RegisterActor(actor);\n\n  // apply garbage collection policy\n  actor->SetGarbageCollectionPolicy(gc);\n\n  // log details\n  actor->LogCreation();\n\n  return actor;\n}", "CodeBleu_score": 31.582171593981833}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_episode != nullptr);\n  _client.SubscribeToStream(sensor.GetDataStreamName(), [=](Buffer buffer) {\n    auto data = sensor.Deserialize(buffer);\n    data->SetFrame(_episode->GetFrame());\n    callback(data);\n  });\n}", "CodeBleu_score": 48.97765130533281}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t    DEBUG_ASSERT(_episode != nullptr);\n    _client.SubscribeToStream(\n        sensor.GetToken(),\n        [this, callback](Buffer buffer) {\n          auto data = buffer.Deserialize<sensor::SensorData>();\n          data->SetEpisode(*_episode);\n          callback(std::move(data));\n        });\n  }", "CodeBleu_score": 57.45056424358557}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t    DEBUG_ASSERT(_episode != nullptr);\n    _client.SubscribeToStream(\n        sensor.GetToken(),\n        [this, callback](Buffer buffer) {\n          auto sensor_data = sensor::SensorData::Deserialize(buffer);\n          sensor_data->SetEpisode(GetCurrentEpisode());\n          callback(sensor_data);\n        });\n  }", "CodeBleu_score": 48.397847887424426}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n  auto state = episode->GetState();\n  for (auto it = _crowd.begin(); it != _crowd.end();) {\n    if (state->ContainsActor(*it)) {\n      ++it;\n    } else {\n      _nav.RemoveWalker(*it);\n      it = _crowd.erase(it);\n    }\n  }\n  _nav.UpdateVehicles(state->GetVehicles());\n  _nav.UpdateCrowd(_crowd);\n  for (auto walker : walkers) {\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetSpeed();\n    _nav.ApplyBatch([&](const carla::nav::WalkerManager::WalkerPtr &w) {\n      w->Update(transform, speed);\n    });\n  }\n  for (auto it = _crowd.begin(); it != _crowd.end();) {\n    if ((*it)->IsAlive()) {\n      ++it;\n    } else {\n      _nav.RemoveWalker(*it);\n      episode->RemoveActor(*it);\n      it = _crowd.erase(it);\n    }\n  }\n}", "CodeBleu_score": 44.03883029832683}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  auto state = episode->GetState();\n  for (auto it = _crowd.begin(); it != _crowd.end();) {\n    if (state->ContainsActor(*it)) {\n      ++it;\n    } else {\n      _crowd.erase(it++);\n    }\n  }\n\n  _nav.UpdateVehicles(_crowd);\n  _nav.UpdateCrowd();\n\n  for (auto &walker : walkers) {\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetSpeed();\n\n    _nav.ApplyStateToVehicle(walker, transform, speed);\n  }\n\n  _simulator.lock()->ApplyBatchState(walkers);\n\n  for (auto &walker : walkers) {\n    if (walker->IsAlive()) {\n      continue;\n    }\n\n    _crowd.erase(walker);\n    _controllers.erase(walker);\n  }\n}", "CodeBleu_score": 43.41534393696684}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n  auto current_state = episode->GetState();\n  auto current_walkers = current_state->GetWalkers();\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    if (current_walkers.find(it->first) == current_walkers.end()) {\n      _nav.RemoveWalker(it->first);\n      it = _walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  _nav.UpdateVehicles(current_state->GetVehicles());\n  _nav.UpdateCrowd(current_state->GetWalkers());\n  for (auto &walker : walkers) {\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetCurrentSpeed();\n    _nav.SetWalkerSpeed(walker->GetId(), speed);\n    _nav.SetWalkerTransform(walker->GetId(), transform);\n  }\n  _nav.Tick();\n  for (auto &walker : walkers) {\n    auto transform = _nav.GetWalkerTransform(walker->GetId());\n    auto speed = _nav.GetWalkerSpeed(walker->GetId());\n    auto control = _nav.GetWalkerControl(walker->GetId());\n    auto debug_shape = _nav.GetWalkerDebugShape(walker->GetId());\n    walker->Update(transform, speed, control, debug_shape);\n    if (walker->IsDead()) {\n      _nav.RemoveWalker(walker->GetId());\n      _walkers.erase(walker->GetId());\n      walker->DestroyController();\n    }\n  }\n}", "CodeBleu_score": 45.06649302516357}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = _uid;\n    description.id = _id;\n    description.attributes.reserve(_attributes.size());\n    for (auto &item : _attributes) {\n        description.attributes.emplace_back(item.second.ToActorAttribute());\n    }\n    return description;\n}", "CodeBleu_score": 78.08842475986097}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &item : _attributes) {\n    description.attributes.emplace_back(item.second.ToRpc());\n  }\n  return description;\n}", "CodeBleu_score": 79.7995674678956}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &item : _attributes) {\n    description.attributes.emplace_back(std::move(item.second));\n  }\n  return description;\n}", "CodeBleu_score": 79.62703547914329}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    map_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.HasAttribute(name)) {\n        if (pair.second.GetAttribute(name) == value) {\n          result.emplace(pair);\n        }\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 39.62373741311943}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    map_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.ContainsAttribute(name)) {\n        if (pair.second.GetAttribute(name) == value) {\n          result.emplace(pair);\n        }\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 39.953653340454395}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    map_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.ContainsAttribute(name)) {\n        if (pair.second.GetAttributeValue(name) == value) {\n          result.emplace(pair);\n        }\n      }\n    }\n\n\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 40.206045826301086}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    // Construct the full file path\n    std::string fullpath = _filesBaseFolder;\n    fullpath += \"/\";\n    fullpath += ::carla::version();\n    fullpath += \"/\";\n    fullpath += path;\n\n    // Validate the file path\n    if (fullpath.find(\"..\") != std::string::npos) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    // Write the content to the file\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n    // Close the file\n    file.close();\n\n    return true;\n}", "CodeBleu_score": 57.66873989360962}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \\\"/\\\";\n  fullpath += ::carla::version();\n  fullpath += \\\"/\\\";\n  fullpath += path;\n\n  // Validate the file path\n  if (fullpath.find(\\\"../\\\") != std::string::npos || fullpath.find(\\\"./\\\") != std::string::npos) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n  if (file.is_open()) {\n    // Write the content to the file\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    file.close();\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 53.34534445015624}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \\\"/\\\";\n  fullpath += ::carla::version();\n  fullpath += \\\"/\\\";\n  fullpath += path;\n\n  // Validate the file path\n  if (fullpath.find(\\\"../\\\") != std::string::npos) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // Write the content to the file\n  file.write(reinterpret_cast<char*>(content.data()), content.size());\n\n  // Close the file\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 53.73193384241019}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const auto location = transform.location + _parent_bounding_box.location;\n    const auto extents = _parent_bounding_box.extent;\n    const auto yaw = transform.rotation.yaw;\n    return std::make_shared<Bounds>(Bounds{\n        frame,\n        {\n            location + Rotate(yaw, geom::Location{extents.x, extents.y, 0.0f}),\n            location + Rotate(yaw, geom::Location{-extents.x, extents.y, 0.0f}),\n            location + Rotate(yaw, geom::Location{-extents.x, -extents.y, 0.0f}),\n            location + Rotate(yaw, geom::Location{extents.x, -extents.y, 0.0f}),\n        }});\n  }", "CodeBleu_score": 62.2536515748657}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto location = _parent_bounding_box.location + transform.location;\n  const auto rotation = geom::Rotation(transform.rotation);\n  const auto yaw = rotation.yaw;\n  const auto extent = _parent_bounding_box.extent;\n  return std::make_shared<Bounds>(Bounds{\n      frame,\n      {\n          location + Rotate(yaw, geom::Location{extent.x, extent.y, extent.z}),\n          location + Rotate(yaw, geom::Location{extent.x, -extent.y, extent.z}),\n          location + Rotate(yaw, geom::Location{-extent.x, -extent.y, extent.z}),\n          location + Rotate(yaw, geom::Location{-extent.x, extent.y, extent.z}),\n      }});\n}", "CodeBleu_score": 53.47878051548533}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto location = _parent_bounding_box.location + transform.location;\n  const auto yaw = transform.rotation.yaw;\n  const auto extents = _parent_bounding_box.extent;\n  const auto corners = {\n      location + Rotate(yaw, geom::Location{extents.x, extents.y, 0.0f}),\n      location + Rotate(yaw, geom::Location{extents.x, -extents.y, 0.0f}),\n      location + Rotate(yaw, geom::Location{-extents.x, -extents.y, 0.0f}),\n      location + Rotate(yaw, geom::Location{-extents.x, extents.y, 0.0f})};\n  return std::make_shared<const Bounds>(Bounds{frame, corners});\n}", "CodeBleu_score": 58.676400389164364}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  _lights_state = _client.GetLightStates();\n  for(auto it = _lights_state.begin(); it != _lights_state.end(); ++it) {\n    LightId id = it->first;\n    LightState& state = it->second;\n    if(_lights.find(id) == _lights.end()) {\n      _lights[id] = Light(id);\n    }\n    SetLightStateNoLock(id, state);\n  }\n}", "CodeBleu_score": 34.87263086966031}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  auto lights_state = _client.GetLightsState();\n\n  for(auto it = lights_state.begin(); it != lights_state.end(); it++) {\n    LightState& state = it->second;\n    LightId id = it->first;\n\n    auto it_light = _lights.find(id);\n    if(it_light == _lights.end()) {\n      _lights[id] = Light(id, state._group, state._color, state._intensity, state._active);\n    } else {\n      Light& light = it_light->second;\n      light._group = state._group;\n      light._color = state._color;\n      light._intensity = state._intensity;\n      light._active = state._active;\n    }\n  }\n\n  _lights_state = lights_state;\n  _dirty = false;\n}", "CodeBleu_score": 42.37522968107308}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Get the current state of all lights from the server\n  std::vector<rpc::LightState> lights_state = _client.GetLightStates();\n\n  // Update the local light states\n  for (const auto& light_state : lights_state) {\n    LightId id = light_state.id;\n    LightState& state = _lights_state[id];\n    state._active = light_state.active;\n    state._color = Color(light_state.color.r, light_state.color.g, light_state.color.b);\n    state._intensity = light_state.intensity;\n    state._group = static_cast<LightGroup>(light_state.group);\n  }\n\n  // Create new light objects if they do not already exist in the _lights map\n  for (const auto& light_state : lights_state) {\n    LightId id = light_state.id;\n    if (_lights.find(id) == _lights.end()) {\n      _lights[id] = Light(id);\n    }\n  }\n}", "CodeBleu_score": 44.339917953684896}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if(_dirty) {\n    std::vector<rpc::LightState> lights_to_update;\n    for(auto& it : _lights_changes) {\n      rpc::LightState state;\n      state._id = it.first;\n      state._intensity = it.second._intensity;\n      state._color = rpc::Color(it.second._color.r, it.second._color.g, it.second._color.b);\n      state._group = static_cast<rpc::LightState::LightGroup>(it.second._group);\n      state._active = it.second._active;\n      lights_to_update.push_back(state);\n    }\n    _episode.Lock()->UpdateServerLightsState(lights_to_update, discard_client);\n    _lights_changes.clear();\n    _dirty = false;\n  }\n}", "CodeBleu_score": 66.35634427124378}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (!_dirty) {\n    return;\n  }\n  std::vector<rpc::LightState> msg;\n  for (auto& it : _lights_changes) {\n    rpc::LightState state;\n    state._id = it.first;\n    state._intensity = it.second._intensity;\n    state._color.r = it.second._color.r;\n    state._color.g = it.second._color.g;\n    state._color.b = it.second._color.b;\n    state._group = static_cast<rpc::LightState::LightGroup>(it.second._group);\n    state._active = it.second._active;\n    msg.push_back(state);\n  }\n  _episode.Lock()->SendLightStateToServer(msg, discard_client);\n  _lights_changes.clear();\n  _dirty = false;\n}", "CodeBleu_score": 52.945969575841154}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  if(!_dirty) {\n    return;\n  }\n\n  // Create message\n  rpc::LightState::List lights_snapshot;\n  for(auto it = _lights_changes.begin(); it != _lights_changes.end(); ++it) {\n    rpc::LightState light_state;\n    light_state._id = it->first;\n    light_state._intensity = it->second._intensity;\n    light_state._color = rpc::Color(it->second._color.r, it->second._color.g, it->second._color.b);\n    light_state._group = static_cast<uint8_t>(it->second._group);\n    light_state._active = it->second._active;\n    lights_snapshot.push_back(light_state);\n  }\n\n  // Send message\n  _episode.Lock()->SendLightStateToServer(lights_snapshot, discard_client);\n\n  // Clear changes\n  _lights_changes.clear();\n  _dirty = false;\n}", "CodeBleu_score": 52.51856461328565}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\\\"calling sensor Send() \\\", GetDisplayId());\n    if (GetDisplayId() != \\\"sensor.other.v2x_custom\\\") {\n        log_warning(\\\"sending message from sensor \\\", GetDisplayId(), \\\": sensor is not v2x_custom\\\");\n        return;\n    }\n    GetEpisode().Lock()->SendMessageToServer(std::move(message), GetContext());\n}", "CodeBleu_score": 38.987036036856395}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\\\"calling sensor Send() \\\", GetDisplayId());\n    if (GetId() != \\\"sensor.other.v2x_custom\\\") {\n      log_warning(\\\"sending message to sensor with wrong ID:\\\", GetDisplayId());\n      return;\n    }\n    GetEpisode().Lock()->SendMessageToServer(std::move(message), GetContext());\n  }", "CodeBleu_score": 39.18696905543487}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  log_debug(\\\"calling sensor Send() \\\", GetDisplayId());\n  if (GetId() != \\\"sensor.other.v2x_custom\\\") {\n    log_warning(\\\"sensor id is not sensor.other.v2x_custom\\\");\n    return;\n  }\n  GetEpisode().Lock()->Send(std::move(message), GetContext());\n}", "CodeBleu_score": 53.16847594515834}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    _parent.GetEpisode().Lock()->GetTrafficManager(tm_port)->RegisterVehicles({shared_from_this()});\n  } else {\n    _parent.GetEpisode().Lock()->GetTrafficManager(tm_port)->UnregisterVehicles({shared_from_this()});\n  }\n}", "CodeBleu_score": 54.91539892872005}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->GetExtension<TM>(tm_port)->RegisterVehicles({shared_from_this()}, enabled);\n}", "CodeBleu_score": 31.797737649277057}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->GetTrafficManager()->RegisterVehicles({shared_from_this()}, tm_port);\n  GetEpisode().Lock()->GetTrafficManager()->SetPercentageRunningLight(100);\n  GetEpisode().Lock()->GetTrafficManager()->SetPercentageRunningSign(100);\n  GetEpisode().Lock()->GetTrafficManager()->SetGlobalPercentageRunning(100);\n  if (enabled) {\n    GetEpisode().Lock()->GetTrafficManager()->RegisterVehicles({shared_from_this()}, tm_port);\n  } else {\n    GetEpisode().Lock()->GetTrafficManager()->UnregisterVehicles({shared_from_this()});\n  }\n}", "CodeBleu_score": 45.71080757774394}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  // Get the walker actor\n  _walker = boost::dynamic_pointer_cast<Actor>(_parent);\n  // Register the walker with the navigation system\n  _navigation = GetWorld().GetMap()->GetNavigator();\n  _navigation->AddWalker(_walker->GetId(), _walker->GetTransform());\n  // Disable physics simulation and collisions\n  _walker->SetSimulatePhysics(false);\n  _walker->SetEnableGravity(false);\n}", "CodeBleu_score": 34.68313407582223}, {"code": "void WalkerAIController::Start(){\n\t  _navigation = GetWorld().GetMap()->GetNavigator();\n  _navigation->AddWalker(GetId(), GetActor()->GetTransform());\n  GetActor()->SetSimulatePhysics(false);\n  GetActor()->SetEnableGravity(false);\n}", "CodeBleu_score": 28.473465883856253}, {"code": "void WalkerAIController::Start(){\n\t  _walker = boost::dynamic_pointer_cast<Walker>(GetParent());\n  _navigation = GetWorld().GetMap()->GetNavigator();\n  _navigation->AddWalker(this);\n  _walker->DisablePhysicsSimulation();\n  _walker->SetCollisionDetection(CollisionDetection::None);\n}", "CodeBleu_score": 30.87141281434293}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\\\"NAV: Failed to set max speed to \\\", max_speed, \\\" for walker\\\");\n      }\n    } else {\n      log_warning(\\\"NAV: Failed to set max speed to \\\", max_speed, \\\" for walker (parent does not exist)\\\");\n    }\n  }\n}", "CodeBleu_score": 78.73225519490587}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\\\"NAV: Failed to set maximum speed to \\\", max_speed);\n      }\n    } else {\n      log_warning(\\\"NAV: Failed to set maximum speed to \\\", max_speed, \\\"(parent does not exist)\\\");\n    }\n  }\n\n  void WalkerAIController::SetAcceleration(const float acceleration) {\n    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav != nullptr) {\n      auto walker = GetParent();\n      if (walker != nullptr) {\n        if (!nav->SetWalkerAcceleration(walker->GetId(), acceleration)) {\n          log_warning(\\\"NAV: Failed to set acceleration to \\\", acceleration);\n        }\n      } else {\n        log_warning(\\\"NAV: Failed to set acceleration to \\\", acceleration, \\\"(parent does not exist)\\\");\n      }\n    }\n  }\n\n}", "CodeBleu_score": 63.80609590757387}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav != nullptr) {\n        auto walker = GetParent();\n        if (walker != nullptr) {\n            if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n                log_warning(\\\"NAV: Failed to set max speed to \\\", max_speed);\n            }\n        } else {\n            log_warning(\\\"NAV: Failed to set max speed to \\\", max_speed, \\\"(parent does not exist)\\\");\n        }\n    }\n}", "CodeBleu_score": 77.3588979895862}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n        result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n}", "CodeBleu_score": 98.47744849251113}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n        result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n}", "CodeBleu_score": 98.47744849251113}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n        result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n}", "CodeBleu_score": 98.47744849251113}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t    std::vector<SharedPtr<Landmark>> result;\n\n    std::vector<SharedPtr<Waypoint>> signals =\n        GetSignalsInDistance(distance, stop_at_junction);\n\n    std::unordered_set<SharedPtr<Waypoint>> unique_signals;\n    for (auto &signal : signals) {\n      if (unique_signals.insert(signal).second) {\n        result.emplace_back(SharedPtr<Landmark>(new Landmark(signal)));\n      }\n    }\n\n    return result;\n  }", "CodeBleu_score": 40.55220646794968}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t    std::vector<SharedPtr<Landmark>> result;\n    for (auto signal : GetSignalsInDistance(distance, stop_at_junction)) {\n      auto landmark_ptr = _parent->GetMap().GetLandmark(signal->GetSignalId());\n      if (landmark_ptr == nullptr) {\n        // Landmark information not found in database.\n        continue;\n      }\n      auto landmark = SharedPtr<Landmark>(new Landmark(std::move(*landmark_ptr)));\n      auto waypoint = SharedPtr<Waypoint>(new Waypoint(_parent, signal->GetWaypoint()));\n      landmark->SetWaypoint(waypoint);\n      result.emplace_back(landmark);\n    }\n    return result;\n  }", "CodeBleu_score": 53.52244240245081}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t    std::vector<SharedPtr<Landmark>> result;\n    auto signals = GetSignalsInDistance(distance, stop_at_junction);\n    std::unordered_set<SharedPtr<Landmark>> unique_landmarks;\n    for (auto &signal : signals) {\n      auto landmark = _parent->GetMap().GetLandmark(signal);\n      if (landmark != nullptr && unique_landmarks.count(landmark) == 0) {\n        unique_landmarks.insert(landmark);\n        result.emplace_back(SharedPtr<Landmark>(new Landmark(_parent, landmark)));\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 53.44281371821482}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  auto episode = _episode.Lock();\n  auto id = episode->SetEpisodeSettings(settings);\n  if (timeout <= 0s) {\n    timeout = episode->GetNetworkingTimeout();\n  }\n\n  if (settings.fixed_delta_seconds > 0.0f) {\n    constexpr auto max_attempts = 10u;\n    const auto delta_seconds = time_duration::from_seconds(settings.fixed_delta_seconds);\n    auto attempts = 0u;\n    while (attempts < max_attempts) {\n      const auto start = std::chrono::system_clock::now();\n      std::this_thread::sleep_for(delta_seconds);\n      const auto end = std::chrono::system_clock::now();\n      const auto elapsed = std::chrono::duration_cast<time_duration>(end - start);\n      if (elapsed < delta_seconds) {\n        log_warning(\n            \"fixed delta time not applied correctly\",\n            attempts,\n            max_attempts,\n            delta_seconds,\n            elapsed);\n      } else {\n        break;\n      }\n      ++attempts;\n    }\n  }\n\n  return id;\n}", "CodeBleu_score": 50.19244598255287}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    const Vector3D segment_direction = segment.end - segment.start;\n    const float segment_squared_length = segment_direction.SquaredLength();\n    const float segment_length = std::sqrt(segment_squared_length);\n    if (segment_length == 0.0f) {\n      return {0.0f, point.Distance(segment.start)};\n    }\n    const float projection = Dot(point - segment.start, segment_direction) / segment_squared_length;\n    const float clamped_projection = std::min(std::max(projection, 0.0f), 1.0f);\n    const Vector3D point_on_segment = segment.start + segment_direction * clamped_projection;\n    return {clamped_projection * segment_length, point.Distance(point_on_segment)};\n  }", "CodeBleu_score": 40.2100755440057}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    const float segment_length_squared = (b - a).SquaredLength();\n    const float segment_length = std::sqrt(segment_length_squared);\n    if (segment_length < std::numeric_limits<float>::epsilon()) {\n      return {0.0f, a.Distance(point)};\n    }\n    const float t = std::clamp(Dot(point - a, b - a) / segment_length_squared, 0.0f, 1.0f);\n    const Vector3D projection = a + t * (b - a);\n    return {projection.Distance(point), t * segment_length};\n  }", "CodeBleu_score": 42.691397991090646}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    const float segment_length_squared = (b - a).LengthSquared();\n    const float segment_length = std::sqrt(segment_length_squared);\n    if (segment_length < EPSILON) {\n      return std::make_pair(0.0f, (point - a).Length());\n    }\n    const float projection = Dot(point - a, b - a) / segment_length_squared;\n    const float distance_along_segment = std::min(std::max(projection, 0.0f), 1.0f);\n    const Vector3D point_on_segment = a + (b - a) * distance_along_segment;\n    const float distance_to_point = (point - point_on_segment).Length();\n    return std::make_pair(distance_along_segment * segment_length, distance_to_point);\n  }", "CodeBleu_score": 41.974054698252395}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    if (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum() + 1;\n    AddVertices(vertices);\n    AddIndex(i);\n    while (i < GetVerticesNum()) {\n      AddIndex(i + 1);\n      AddIndex(i);\n      ++i;\n    }\n  }", "CodeBleu_score": 66.92664363015987}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    if (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum() + 1;\n    AddVertices(vertices);\n    while (i < GetVerticesNum()) {\n      AddIndex(i);\n      AddIndex(i + 1);\n      AddIndex(i - 1);\n      ++i;\n    }\n  }", "CodeBleu_score": 68.95758675142783}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    if (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum();\n    AddVertices(vertices);\n    AddIndex(i);\n    AddIndex(i + 1);\n    while (i < GetVerticesNum() - 1) {\n      AddIndex(i + 2);\n      ++i;\n    }\n  }", "CodeBleu_score": 59.657140783955334}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(_socket.is_open());\n  DEBUG_ASSERT(message != nullptr);\n\n  // Ensure the message is valid.\n  message->Validate();\n\n  // Post the lambda to the strand for execution.\n  boost::asio::post(\n      _strand,\n      [this, message = std::move(message)]() {\n        if (_socket.is_open()) {\n          // Set the timeout.\n          _deadline.expires_from_now(_timeout);\n\n          // Start the asynchronous write operation.\n          boost::asio::async_write(\n              _socket,\n              boost::asio::buffer(message->GetData(), message->GetSize()),\n              boost::asio::bind_executor(\n                  _strand,\n                  [this, message](const boost::system::error_code &ec, size_t) {\n                    HandleSent(ec, message);\n                  }));\n        }\n      });\n}", "CodeBleu_score": 37.610539641173915}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  DEBUG_ASSERT(_socket.is_open());\n\n  boost::asio::post(\n      _strand,\n      [=]() {\n        if (!_socket.is_open()) {\n          return;\n        }\n        _deadline.expires_from_now(_timeout);\n        boost::asio::async_write(\n            _socket,\n            boost::asio::buffer(message->data(), message->size()),\n            boost::asio::bind_executor(\n                _strand,\n                [=](boost::system::error_code ec, std::size_t /*length*/) {\n                  if (!ec) {\n                    LIBCARLA_PROFILE_INSTRUMENTATION_API_END(\n                        \"write\", \"multigpu_server_session_write\");\n                    return;\n                  }\n                  log_error(\n                      \"tcp multigpu server session\",\n                      _session_id,\n                      \": error writing to client:\",\n                      ec.message());\n                  Close();\n                }));\n      });\n}", "CodeBleu_score": 41.4787743826567}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n\n  if (!_socket.is_open()) {\n    log_error(\"trying to write on a closed socket\");\n    return;\n  }\n\n  const auto message_size = message->size();\n  if (message_size > _buffer_pool->max_buffer_size()) {\n    log_error(\"message size exceeds maximum buffer size\");\n    return;\n  }\n\n  auto buffer = _buffer_pool->get_buffer(message_size);\n  if (buffer == nullptr) {\n    log_error(\"failed to allocate buffer\");\n    return;\n  }\n\n  // write the message header\n  std::memcpy(buffer->data(), message->header_begin(), message->header_size());\n\n  // write the message data\n  std::memcpy(buffer->data() + message->header_size(), message->data(), message->data_size());\n\n  boost::asio::async_write(\n      _socket,\n      boost::asio::buffer(buffer->data(), message_size),\n      boost::asio::bind_executor(\n          _strand,\n          [weak_self = weak_from_this(), buffer, message_size](\n              const boost::system::error_code &ec,\n              std::size_t /* transferred */) {\n            auto self = weak_self.lock();\n            if (!self) {\n              return;\n            }\n            self->_buffer_pool->release_buffer(buffer);\n            if (ec) {\n              log_error(\"error writing:\", ec.message());\n              self->Close();\n              return;\n            }\n            DEBUG_ASSERT(message_size == buffer->size());\n            log_debug(\"sent\", message_size, \"bytes\");\n          }));\n}", "CodeBleu_score": 49.52759643515434}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (!ec && _socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        _socket.shutdown(boost::asio::socket_base::shutdown_both, ignored_ec);\n        _socket.close();\n    }\n    _on_closed(shared_from_this());\n    log_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 66.00671471202256}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    boost::system::error_code ec_shutdown;\n    _socket.shutdown(boost::asio::socket_base::shutdown_both, ec_shutdown);\n    _socket.close();\n  }\n  _on_closed(shared_from_this());\n  log_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 66.62474792705882}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    boost::system::error_code ignored_ec;\n    _socket.shutdown(boost::asio::socket_base::shutdown_both, ignored_ec);\n    _socket.close();\n  }\n  _on_closed(shared_from_this());\n  log_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 66.48670411943493}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::Buffer buf((unsigned char *) \"Are you alive?\", 15);\n  log_info(\"sending is alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\"got alive response: \", response.buffer.data());\n}", "CodeBleu_score": 70.42730334925274}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::Buffer buf((unsigned char *) \"Are you alive?\", 14);\n  log_info(\\\"sending is alive command\\\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\\\"got alive response\\\");\n}", "CodeBleu_score": 54.59736084563108}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  carla::Buffer buf((unsigned char *) \"Are you alive?\", (size_t) 14);\n  log_info(\\\"sending you alive command\\\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\\\"got alive response: \\\", response.buffer.data());\n}", "CodeBleu_score": 57.81235200579163}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  log_info(\\\"sending enable for ROS command\\\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  if (response.buffer.size() > 0) {\n    if (response.buffer[0] == 1) {\n      log_info(\\\"sensor found on server\\\");\n    } else {\n      log_error(\\\"sensor not found on server\\\");\n    }\n  }\n}", "CodeBleu_score": 60.61646000250525}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  auto server_id = _router->GetServerIdForSensor(sensor_id);\n  if (server_id >= 0) {\n    carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n    log_info(\\\"sending enable for ROS command\\\");\n    auto fut = _router->WriteTo(MultiGPUCommand::ENABLE_ROS, std::move(buf), server_id);\n    auto response = fut.get();\n    log_info(\\\"response from enable for ROS command: \\\", response.buffer.data());\n  } else {\n    log_error(\\\"sensor not found on any server\\\");\n  }\n}", "CodeBleu_score": 64.50814937755362}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  log_info(\\\"sending enable for ROS command\\\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_error(\\\"sensor not found on any server\\\");\n  }\n}", "CodeBleu_score": 54.29638049873196}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"sensor\", sensor_id, \" already activated in server\", it->second);\n    return it->second.second;\n  } else {\n    // if not, enable the sensor on a secondary server\n    log_info(\"enabling sensor\", sensor_id, \" on a secondary server\");\n    token_type new_token = SendEnableSensor(sensor_id);\n    // update the maps\n    _servers.insert(std::make_pair(sensor_id, std::make_pair(new_token.get_server_id(), new_token)));\n    _tokens.insert(std::make_pair(new_token.get_server_id(), std::make_pair(sensor_id, new_token)));\n    // log the action\n    log_info(\"sensor\", sensor_id, \" enabled on server\", new_token.get_server_id(), \" with token\", new_token.get_stream_id(), \":\", new_token.get_port());\n    return new_token;\n  }\n}", "CodeBleu_score": 53.532881308815085}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"sensor\", sensor_id, \"already activated on server\", it->second);\n    return _tokens.find(sensor_id)->second;\n  } else {\n    log_info(\"sensor\", sensor_id, \"not activated, sending enable command\");\n    EnableSensor(sensor_id);\n    token_type new_token = SendGetToken(sensor_id);\n    _tokens[sensor_id] = new_token;\n    _servers[sensor_id] = new_token.get_server_id();\n    return new_token;\n  }\n}", "CodeBleu_score": 59.38449458306484}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    log_info(\"sensor\", sensor_id, \"already activated on server\", it->second);\n    return _tokens[sensor_id];\n  } else {\n    log_info(\"activating sensor\", sensor_id);\n    // enable the sensor on a secondary server\n    token_type new_token = SendGetToken(sensor_id);\n    // update the maps\n    _servers[sensor_id] = new_token.get_server_id();\n    _tokens[sensor_id] = new_token;\n    log_info(\"sensor\", sensor_id, \"activated on server\", new_token.get_server_id());\n    return new_token;\n  }\n}", "CodeBleu_score": 59.769648919171495}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  file.seekg(0, std::ios::end);\n  std::streampos size = file.tellg();\n  file.seekg(0, std::ios::beg);\n  std::vector<char> data(size);\n  file.read(data.data(), size);\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 56.09924318309653}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n        return false;\n    }\n    file.seekg(0, std::ios::end);\n    std::vector<char> data(file.tellg());\n    file.seekg(0, std::ios::beg);\n    file.read(data.data(), data.size());\n    file.close();\n    return Load(data);\n}", "CodeBleu_score": 54.73826620512885}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  file.seekg(0, std::ios::end);\n  std::streamsize size = file.tellg();\n  file.seekg(0, std::ios::beg);\n  std::vector<char> buffer(size);\n  file.read(buffer.data(), size);\n  file.close();\n  return Load(buffer);\n}", "CodeBleu_score": 55.77227515703884}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // check if this actor exists\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    // get the index found\n    int index = it->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent\n      _crowd->removeAgent(index);\n      // update the walker manager\n      _walker_manager.RemoveWalker(id);\n      // remove the id\n      _mapped_walkers_id.erase(id);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  // check if this actor exists\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    // get the index found\n    int index = it->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent\n      _crowd->removeAgent(index);\n      // update the walker manager\n      _vehicle_manager.RemoveVehicle(id);\n      // remove the id\n      _mapped_vehicles_id.erase(id);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 76.97884369895526}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // check if this actor exists\n  auto it_walker = _mapped_walkers_id.find(id);\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n  if (it_walker != _mapped_walkers_id.end()) {\n    // get the index found\n    int index = it_walker->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent\n      _crowd->removeAgent(index);\n      // update the walker manager\n      _walker_manager.RemoveWalker(id);\n      // remove from the mapping\n      _mapped_walkers_id.erase(it_walker);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  } else if (it_vehicle != _mapped_vehicles_id.end()) {\n    // get the index found\n    int index = it_vehicle->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent\n      _crowd->removeAgent(index);\n      // remove from the mapping\n      _mapped_vehicles_id.erase(it_vehicle);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 68.57296161566389}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // check if this actor exists\n  auto it_walker = _mapped_walkers_id.find(id);\n  if (it_walker != _mapped_walkers_id.end()) {\n    // get the index found\n    int index = it_walker->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent from the crowd\n      _crowd->removeAgent(index);\n      // update the walker manager\n      _walker_manager.RemoveWalker(id);\n      // remove the id from the mapping\n      _mapped_walkers_id.erase(id);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n  if (it_vehicle != _mapped_vehicles_id.end()) {\n    // get the index found\n    int index = it_vehicle->second;\n    if (index != -1) {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      // remove the agent from the crowd\n      _crowd->removeAgent(index);\n      // update the vehicle manager\n      _vehicle_manager.RemoveVehicle(id);\n      // remove the id from the mapping\n      _mapped_vehicles_id.erase(id);\n      _mapped_by_index.erase(index);\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 66.48049634020806}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  // collect currently mapped vehicles\n  std::set<ActorId> mapped_vehicles;\n  for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ++it) {\n    mapped_vehicles.insert(it->first);\n  }\n\n  // add or update vehicles\n  for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n    VehicleCollisionInfo &vehicle = *it;\n    // add or update\n    if (!AddOrUpdateVehicle(vehicle)) {\n      return false;\n    }\n    // mark as updated\n    mapped_vehicles.erase(vehicle.id);\n  }\n\n  // remove vehicles that are not updated\n  for (auto it = mapped_vehicles.begin(); it != mapped_vehicles.end(); ++it) {\n    RemoveAgent(*it);\n  }\n\n  return true;\n}", "CodeBleu_score": 54.732078750867075}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  // get the list of currently mapped vehicles\n  std::set<ActorId> mapped_vehicles;\n  for (auto &pair : _mapped_vehicles_id) {\n    mapped_vehicles.insert(pair.first);\n  }\n\n  // add or update vehicles from the provided list\n  for (auto &vehicle : vehicles) {\n    // mark as updated\n    _updated_vehicles.insert(vehicle.id);\n\n    // add or update the vehicle\n    if (!AddOrUpdateVehicle(vehicle)) {\n      return false;\n    }\n  }\n\n  // remove vehicles not marked as updated\n  for (auto &id : mapped_vehicles) {\n    if (_updated_vehicles.find(id) == _updated_vehicles.end()) {\n      RemoveAgent(id);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 50.12346989903753}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  // collect the ids of currently mapped vehicles\n  std::set<ActorId> current_vehicles;\n  for (auto &pair : _mapped_vehicles_id) {\n    current_vehicles.insert(pair.first);\n  }\n\n  // add or update vehicles from the list\n  for (auto &vehicle : vehicles) {\n    bool added = AddVehicle(vehicle);\n    if (!added) {\n      logging::log(\"Vehicle not added to the crowd by some problem!\");\n    }\n    // mark as updated\n    current_vehicles.erase(vehicle.id);\n  }\n\n  // remove vehicles not updated\n  for (auto &id : current_vehicles) {\n    bool removed = RemoveAgent(id);\n    if (!removed) {\n      logging::log(\"Vehicle not removed from the crowd by some problem!\");\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 47.34318069432451}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the internal index\n  auto it_walkers = _mapped_walkers_id.find(id);\n  auto it_vehicles = _mapped_vehicles_id.find(id);\n  if (it_walkers == _mapped_walkers_id.end() && it_vehicles == _mapped_vehicles_id.end()) {\n    return false;\n  }\n\n  // get the index found\n  int index = -1;\n  if (it_walkers != _mapped_walkers_id.end()) {\n    index = it_walkers->second;\n  } else {\n    index = it_vehicles->second;\n  }\n  if (index == -1) {\n    return false;\n  }\n\n  // get the walker\n  const dtCrowdAgent *agent;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    agent = _crowd->getAgent(index);\n  }\n\n  // get the direction\n  float dir[3] = {direction.x, direction.y, direction.z};\n  // compute the squared distance\n  float squared_distance = (dir[0] * dir[0]) + (dir[1] * dir[1]) + (dir[2] * dir[2]);\n  // check if there is a vehicle nearby\n  return _crowd->needsCollision(index, dir, squared_distance * distance);\n}", "CodeBleu_score": 58.38246734407535}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the internal index\n  auto it = _mapped_walkers_id.find(id);\n  if (it == _mapped_walkers_id.end()) {\n    return false;\n  }\n\n  // get the index found\n  int index = it->second;\n  if (index == -1) {\n    return false;\n  }\n\n  // get the walker\n  const dtCrowdAgent *agent;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    agent = _crowd->getAgent(index);\n  }\n\n  if (!agent->active) {\n    return false;\n  }\n\n  // get the position\n  float pos[3] = { agent->npos[0], agent->npos[1], agent->npos[2] };\n\n  // get the squared distance\n  float squared_distance = distance * distance;\n\n  // get the direction\n  float dir[3] = { direction.x, direction.y, direction.z };\n\n  // check if there is a vehicle nearby\n  return _crowd->getNearestObstacle(pos, dir, &squared_distance) != -1;\n}", "CodeBleu_score": 64.14644544155912}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the internal index\n  auto it = _mapped_walkers_id.find(id);\n  if (it == _mapped_walkers_id.end()) {\n    return false;\n  }\n\n  // get the index found\n  int index = it->second;\n  if (index == -1) {\n    return false;\n  }\n\n  // get the walker\n  const dtCrowdAgent *agent;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    agent = _crowd->getAgent(index);\n  }\n\n  // compute the squared distance\n  float squared_distance = distance * distance;\n\n  // use the crowd system to determine if a vehicle is nearby\n  return _crowd->isAgentNearAgent(index, agent->npos, squared_distance, direction.x, direction.y, direction.z);\n}", "CodeBleu_score": 63.36282673517397}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // get the current route point\n    WalkerEvent &event = info.route[info.currentIndex].event;\n\n    // create the context\n    WalkerEventVisitorContext context(id, info, delta);\n\n    // process the event\n    return boost::variant2::visit(WalkerEventVisitor(context), event);\n}", "CodeBleu_score": 48.37947750592216}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // get the current point\n    WalkerRoutePoint &point = info.route[info.currentIndex];\n\n    // create the context\n    WalkerEventContext context(id, info, delta);\n\n    // process the event\n    return boost::variant2::visit(WalkerEventVisitor(context), point.event);\n}", "CodeBleu_score": 49.50871144168777}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // get the current route point\n    WalkerRoutePoint &point = info.route[info.currentIndex];\n\n    // create the visitor\n    WalkerEventVisitor visitor(info, delta);\n\n    // process the event\n    return boost::variant2::visit(visitor, point.event);\n}", "CodeBleu_score": 59.10441843162799}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  // Get the root node of the XML document\n  const pugi::xml_node &root = xml.child(\\\"OpenDRIVE\\\");\n\n  // Iterate through each road node\n  for (pugi::xml_node road_node : root.children(\\\"road\\\")) {\n    // Get the road ID\n    const int road_id = road_node.attribute(\\\"id\\\").as_int();\n\n    // Iterate through each lane section node\n    for (pugi::xml_node lane_section_node : road_node.children(\\\"lanes\\\").children(\\\"laneSection\\\")) {\n      // Get the left, center, and right lane nodes\n      const pugi::xml_node left_lane_node = lane_section_node.child(\\\"left\\\");\n      const pugi::xml_node center_lane_node = lane_section_node.child(\\\"center\\\");\n      const pugi::xml_node right_lane_node = lane_section_node.child(\\\"right\\\");\n\n      // Parse the left, center, and right lanes\n      ParseLanes(left_lane_node, map_builder, road_id);\n      ParseLanes(center_lane_node, map_builder, road_id);\n      ParseLanes(right_lane_node, map_builder, road_id);\n    }\n  }\n}", "CodeBleu_score": 46.68347445955412}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  pugi::xml_node open_drive_node = xml.child(\\\"OpenDRIVE\\\");\n  for (pugi::xml_node road_node : open_drive_node.children(\\\"road\\\")) {\n    const std::string id = road_node.attribute(\\\"id\\\").value();\n\n    for (pugi::xml_node lanes_node : road_node.children(\\\"lanes\\\")) {\n      const double s = lanes_node.attribute(\\\"s\\\").as_double();\n\n      // Left Lane\n      pugi::xml_node left_lane_node = lanes_node.child(\\\"left\\\");\n      if (left_lane_node) {\n        ParseLanes(left_lane_node, id, s, map_builder);\n      }\n\n      // Center Lane\n      pugi::xml_node center_lane_node = lanes_node.child(\\\"center\\\");\n      if (center_lane_node) {\n        ParseLanes(center_lane_node, id, s, map_builder);\n      }\n\n      // Right Lane\n      pugi::xml_node right_lane_node = lanes_node.child(\\\"right\\\");\n      if (right_lane_node) {\n        ParseLanes(right_lane_node, id, s, map_builder);\n      }\n    }\n  }\n}", "CodeBleu_score": 55.192694055804104}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    _matched = info.total_count;\n    _first_connected = true;\n    std::cout << \\\"Matched\\\" << std::endl;\n  } else if (info.current_count_change == -1) {\n    _matched = info.total_count;\n    std::cout << \\\"Unmatched\\\" << std::endl;\n  } else {\n    std::cerr << \\\"Error for writer\\\" << std::endl;\n  }\n}", "CodeBleu_score": 71.06319075537625}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    _matched = info.total_count;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched = info.total_count;\n  } else {\n    std::cerr << \\\"Error: invalid count change\\\" << std::endl;\n  }\n}", "CodeBleu_score": 72.17524034345115}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n      _matched = info.total_count;\n      _first_connected = true;\n    } else if (info.current_count_change == -1) {\n      _matched = info.total_count;\n    } else {\n      std::cerr << \\\"Error: invalid count change\\\" << std::endl;\n    }\n  }", "CodeBleu_score": 73.54088593686518}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  if (info.current_count_change == 1) {\n    _matched = info.total_count;\n    _first_connected = true;\n  } else if (info.current_count_change == -1) {\n    _matched = info.total_count;\n    if (_matched == 0) {\n      _owner->destroy_subscriber();\n    }\n  } else {\n    // should never happen\n    std::cerr << \\\"Error in CarlaSubscriberListenerImpl::on_subscription_matched: \\\"\n      << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 80.16825159697554}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n      _matched = info.total_count;\n      _first_connected = true;\n    } else if (info.current_count_change == -1) {\n      _matched = info.total_count;\n      if (_matched == 0) {\n        _owner->destroy();\n      }\n    } else {\n      std::cerr << \\\"Error: CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count\\\" << std::endl;\n    }\n  }", "CodeBleu_score": 76.90605510155328}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n      _matched = info.total_count;\n      _first_connected = true;\n    } else if (info.current_count_change == -1) {\n      _matched = info.total_count;\n      if (_matched == 0) {\n        _owner->destroy();\n      }\n    } else {\n      std::cerr << \\\"Error in CarlaSubscriberListenerImpl::on_subscription_matched\\\" << std::endl;\n    }\n  }", "CodeBleu_score": 76.01519158151937}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 98.51696483682669}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!m_isGetKeyDefined)\n        return false;\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)\n    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i < 16;++i)\n        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else\n    {\n        for(uint8_t i = 0;i < 16;++i)\n        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 86.59356015359099}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.01569280410635}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 97.14855897766093}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false; // If there is not enough memory to serialize the object, return false.\n    }\n\n    // Get the length of the serialized data.\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 90.71182952196808}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 94.30811008515623}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // return immediately if sysid doesn't match our target sysid\n    if ((tracker.g.sysid_target != 0) && (tracker.g.sysid_target != msg.sysid)) {\n        return;\n    }\n\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT:\n            // decode\n            mavlink_heartbeat_t packet;\n            mavlink_msg_heartbeat_decode(&msg, &packet);\n            if (tracker.g.sysid_target == 0) {\n                tracker.g.sysid_target = msg.sysid;\n                gcs().send_message(MSG_NEXT_PARAM);\n            }\n            break;\n\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n        case MAVLINK_MSG_ID_SCALED_PRESSURE:\n            // these messages always contain the target location, so if\n            // we don't have it yet, we should make a new global_position\n            // estimate\n            if (tracker.g.sysid_target == 0) {\n                tracker.g.sysid_target = msg.sysid;\n                gcs().send_message(MSG_NEXT_PARAM);\n            }\n            break;\n    }\n}", "CodeBleu_score": 50.19523137908855}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if the target has already been set\n    if (tracker.g.sysid_target != 0) {\n        return;\n    }\n\n    // decode the message\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // exit immediately if the message type is not one that should be tracked\n    if (packet.type != MAV_TYPE_GCS && packet.type != MAV_TYPE_ONBOARD_CONTROLLER && packet.type != MAV_TYPE_GIMBAL) {\n        return;\n    }\n\n    // set the target system ID and request position and air pressure data streams\n    tracker.g.sysid_target = msg.sysid;\n    tracker.gcs().request_datastream_position(tracker.g.sysid_target);\n    tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target);\n\n    // flag that the target has been set\n    tracker.g.sysid_target_set = true;\n}", "CodeBleu_score": 58.136963814966336}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (tracker.g.sysid_target != 0) {\n        return;\n    }\n\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    // exit immediately if this is not a vehicle we would track\n    if (packet.type != MAV_TYPE_GCS &&\n        packet.type != MAV_TYPE_ONBOARD_CONTROLLER &&\n        packet.type != MAV_TYPE_GIMBAL) {\n        return;\n    }\n\n    tracker.g.sysid_target = msg.sysid;\n    gcs().send_message(MSG_HEARTBEAT);\n    gcs().send_message(MSG_SYS_STATUS);\n    gcs().send_message(MSG_EXTENDED_STATUS1);\n    gcs().send_message(MSG_EXTENDED_STATUS2);\n    gcs().send_message(MSG_EXTENDED_STATUS3);\n    gcs().send_message(MSG_CURRENT_WAYPOINT);\n    gcs().send_message(MSG_GPS_RAW);\n    gcs().send_message(MSG_GPS_RTK);\n    gcs().send_message(MSG_GPS2_RAW);\n    gcs().send_message(MSG_GPS2_RTK);\n    gcs().send_message(MSG_NAV_CONTROLLER_OUTPUT);\n    gcs().send_message(MSG_POSITION_TARGET_GLOBAL_INT);\n    gcs().send_message(MSG_SERVO_OUTPUT_RAW);\n    gcs().send_message(MSG_RADIO_IN);\n    gcs().send_message(MSG_ATTITUDE);\n    gcs().send_message(MSG_VFR_HUD);\n}", "CodeBleu_score": 42.531867366679656}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.barometer.need_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 79.41971545510849}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.barometer.calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 78.83784048853948}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        tracker.baro_cal_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 69.36538868534356}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0.0f) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 81.14154580216298}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0.0f) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 81.14154580216298}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    // exit immediately if disarmed\n    if (!motors->armed()) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // if param is 1, arm the motors\n    if (packet.param1 == 1) {\n        // return failure if motors are already armed\n        if (motors->armed()) {\n            return MAV_RESULT_FAILED;\n        }\n\n        // arm the motors\n        motors->armed(true);\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    // if param is 0, disarm the motors\n    if (packet.param1 == 0) {\n        // return failure if motors are already disarmed\n        if (!motors->armed()) {\n            return MAV_RESULT_FAILED;\n        }\n\n        // disarm the motors\n        motors->armed(false);\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    // if param is not 0 or 1, return MAV_RESULT_UNSUPPORTED\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 60.69886679723299}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (chan(i).initialised) {\n            if (HAVE_PAYLOAD_SPACE(chan(i).get_chan(), DATA_STREAM)) {\n                chan(i).send_message(DATA_STREAM,\n                                      sysid,\n                                      compid,\n                                      tracker.g.sysid_this_mav,\n                                      tracker.g.compid,\n                                      MAV_DATA_STREAM_POSITION,\n                                      tracker.g.streamRates[MAV_DATA_STREAM_POSITION],\n                                      1); // start streaming\n            }\n        }\n    }\n}", "CodeBleu_score": 64.57925734513915}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (chan(i).initialised) {\n            if (HAVE_PAYLOAD_SPACE(chan(i).get_chan(), DATA_STREAM)) {\n                chan(i).send_message(DATA_STREAM,\n                                     0,    // target system\n                                     sysid,\n                                     compid,\n                                     MAV_DATA_STREAM_POSITION,\n                                     1, // start the stream\n                                     tracker.g.streamRates[sysid][compid][MAV_DATA_STREAM_POSITION]);\n            }\n        }\n    }\n}", "CodeBleu_score": 64.74201306482264}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (chan(i).initialised) {\n            if (HAVE_PAYLOAD_SPACE(chan(i).get_chan(), MAVLINK_MSG_ID_REQUEST_DATA_STREAM)) {\n                chan(i).send_request_data_stream(sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n            }\n        }\n    }\n}", "CodeBleu_score": 59.474332329034965}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float pitch_cos = ahrs.cos_pitch();\n    if (is_zero(pitch_cos)) {\n        return false;\n    }\n    ef_pitch = pitch * pitch_cos - yaw * ahrs.sin_roll();\n    ef_yaw = pitch * ahrs.sin_roll() + yaw * pitch_cos;\n    return true;\n}", "CodeBleu_score": 63.31768747199635}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    if (is_zero(ahrs.cos_pitch())) {\n        return false;\n    }\n    ef_pitch = pitch * ahrs.cos_pitch() - yaw * ahrs.sin_roll() * ahrs.sin_pitch() / ahrs.cos_pitch();\n    ef_yaw = yaw * ahrs.cos_roll() / ahrs.cos_pitch() + pitch * ahrs.sin_roll();\n    return true;\n}", "CodeBleu_score": 76.33411536314969}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    if (is_zero(ahrs.cos_pitch())) {\n        return false;\n    }\n    ef_pitch = ahrs.sin_roll() * pitch - ahrs.cos_roll() * ahrs.cos_pitch() * yaw;\n    ef_yaw = ahrs.cos_roll() * pitch + ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n    return true;\n}", "CodeBleu_score": 84.50032192202298}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    int32_t target_yaw_cd = wrap_180_cd(nav_status.bearing_cd);\n    int32_t target_pitch_cd = constrain_float(nav_status.pitch_cd, -aparm.angle_max, aparm.angle_max);\n\n    // check if direction is reversed\n    if (g.reverse_yaw) {\n        target_yaw_cd = wrap_180_cd(target_yaw_cd + 18000);\n    }\n\n    // compute angle error in centidegrees\n    int32_t angle_error_cd = wrap_180_cd(target_yaw_cd - ahrs.yaw_sensor) * 100;\n\n    // convert angle error to body frame\n    angle_error_cd = wrap_180_cd(angle_error_cd - ahrs.pitch_sensor * aparm.angle_max) * 100;\n\n    // update pitch and yaw servos\n    if (nav_status.distance_to_target >= g.wp_radius || g.wp_radius == 0) {\n        tracker.update_pitch(target_pitch_cd);\n        tracker.update_yaw(target_yaw_cd);\n    }\n}", "CodeBleu_score": 39.916718502024516}, {"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    int32_t yaw_cd, pitch_cd;\n    if (nav_status == Nav_WP) {\n        // get pilot's desired yaw and pitch\n        yaw_cd = nav_pilot.yaw_cd;\n        pitch_cd = nav_pilot.pitch_cd;\n    } else {\n        // get auto_yaw and auto_pitch from mission commands\n        yaw_cd = mission.get_angle(0) * 100;\n        pitch_cd = mission.get_angle(1) * 100;\n    }\n\n    // check if direction is reversed\n    if (g.reverse_yaw) {\n        yaw_cd = -yaw_cd;\n    }\n    if (g.reverse_pitch) {\n        pitch_cd = -pitch_cd;\n    }\n\n    // compute angle error in centidegrees\n    int32_t yaw_error_cd = wrap_180_cd(yaw_cd - ahrs.yaw_sensor);\n    int32_t pitch_error_cd = pitch_cd - ahrs.pitch_sensor;\n\n    // convert angle error to body frame\n    float yaw_error = yaw_error_cd * 0.01f;\n    float pitch_error = pitch_error_cd * 0.01f;\n\n    // check if target distance is valid or no minimum distance is set\n    if (nav_status == Nav_WP && (wp_distance <= g.wp_radius || g.wp_radius == 0)) {\n        // update pitch and yaw servos\n        tracker.update_pitch(pitch_error);\n        tracker.update_yaw(yaw_error);\n    }\n}", "CodeBleu_score": 39.71377101652857}, {"code": "void Mode::update_auto(void){\n\t    int32_t yaw_cd = 0;\n    int32_t pitch_cd = 0;\n\n    // set yaw_cd, pitch_cd and yaw_speed_cd\n    // To-Do: add your navigation code below\n    // --------------------\n\n    // --------------------\n\n    // convert to centi-degrees\n    yaw_cd = yaw_cd * 100;\n    pitch_cd = pitch_cd * 100;\n\n    // check for failsafe\n    // To-Do: check for failsafe and do something if needed\n    // --------------------\n\n    // --------------------\n\n    // convert earth-frame angle errors to body-frame angle errors\n    float yaw_error_cd = wrap_180_cd(yaw_cd - ahrs.yaw_sensor);\n    float pitch_error_cd = pitch_cd - ahrs.pitch_sensor;\n\n    // set servos\n    if (yaw_error_cd > 100 || yaw_error_cd < -100) {\n        // if yaw_error is outside of deadband\n        g2.motors.set_roll(roll_cd);\n        g2.motors.set_pitch(pitch_cd);\n        g2.motors.set_yaw(yaw_cd);\n        g2.motors.set_throttle_takeoff();\n    } else if (ap.at_target) {\n        // if we have reached the target\n        g2.motors.set_roll(roll_cd);\n        g2.motors.set_pitch(pitch_cd);\n        g2.motors.set_throttle_hover();\n    } else {\n        // if we are within the deadband\n        g2.motors.set_roll(roll_cd);\n        g2.motors.set_pitch(pitch_cd);\n        g2.motors.set_throttle_land();\n    }\n}", "CodeBleu_score": 34.47954834374604}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n\n    // check if new GPS readings have arrived.  We only call\n    // position_ok once if using GPS ground course and speed\n    // heading.  This ensures that the position is only accepted\n    // once we have a 3D fix.  It also ensures that we don't\n    // accept a 3D fix when using a GPS ground course and speed\n    // heading as it is likely to drift with the GPS\n    if (last_fix_time_ms != gps.last_fix_time_ms()) {\n        last_fix_time_ms = gps.last_fix_time_ms();\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            // if we have a 3D lock then set the home position\n            if (gps.num_sats() >= 6 && ground_start_countdown_ms == 0) {\n                if (!ahrs.home_is_set()) {\n                    // we have a 3D lock, set home\n                    if (set_home_to_current_location(false)) {\n                        // record home is set so we don't do it again\n                        AP::ahrs().set_home_persist(true);\n                    }\n                }\n            } else {\n                // we are not 3D locked, start the countdown\n                ground_start_countdown_ms = MIN(ground_start_countdown_ms, 1000);\n            }\n        }\n    }\n\n    // check if we should update the home location\n    if (ground_start_countdown_ms > 0) {\n        ground_start_countdown_ms--;\n        if (ground_start_countdown_ms == 0) {\n            // we have reached the countdown, set the home location\n            if (set_home_to_current_location(true)) {\n                // record home is set so we don't do it again\n                AP::ahrs().set_home_persist(true);\n            }\n        }\n    }\n}", "CodeBleu_score": 54.19526090329633}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n\n    if (gps.last_message_time_ms() != last_gps_msg_time_ms) {\n        last_gps_msg_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            // start countdown to set home location\n            if (ground_start_countdown_ms > 0) {\n                ground_start_countdown_ms--;\n                if (ground_start_countdown_ms == 0) {\n                    if (gps.location_ok()) {\n                        set_home_to_current_location(false);\n                    } else {\n                        ground_start_countdown_ms = TRACKER_GROUND_START_TIME_MS;\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 49.08579241261158}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n    if (last_message_time_ms != gps.last_message_time_ms()) {\n        last_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n            if (ground_start_countdown_ms > 0) {\n                ground_start_countdown_ms--;\n                if (ground_start_countdown_ms == 0) {\n                    if (gps.location_valid()) {\n                        // set home location\n                        set_home_to_current_location(false);\n                        // set system time from GPS\n                        hal.util->set_system_clock(gps.time_epoch_usec());\n                    } else {\n                        // reset countdown\n                        ground_start_countdown_ms = 1000;\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 51.68586326285056}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // set servo output based on pitch\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, pitch*100.0f);\n}", "CodeBleu_score": 8.084591757740196}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch);\n\n    // position limit pitch servo\n    if (pitch < -g.pitch_min) {\n        new_servo_out = -g.pitch_min;\n    } else if (pitch > g.pitch_max) {\n        new_servo_out = g.pitch_max;\n    } else {\n        new_servo_out = pitch;\n    }\n\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 38.06126238216739}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(pitch, G_Dt);\n\n    // position limit pitch servo\n    int32_t pitch_min_cd = g.pitch_min * 100;\n    int32_t pitch_max_cd = g.pitch_max * 100;\n    if (new_servo_out <= pitch_min_cd) {\n        new_servo_out = pitch_min_cd;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= pitch_max_cd) {\n        new_servo_out = pitch_max_cd;\n        g.pidPitch2Srv.reset_I();\n    }\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 44.858631247700345}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // Check baro & inav alt are within 1m if EKF is operating in an absolute position reference\n    if (copter.flightmode->has_manual_throttle() &&\n        copter.precland_state.last_valid_baro < (copter.g.fs_ekf_thresh_pos - 1.0f)) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Precland not complete\");\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::barometer_checks(display_failure);\n}", "CodeBleu_score": 29.14051089358045}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    // check baro reference\n    if (copter.ap.pre_arm_rc_checks == true) {\n        // check baro vs inertial nav altitude\n        if (fabsf(copter.baro_alt - copter.inertial_nav.get_altitude()) > BARO_MAX_ALT_DISPARITY_PRE_ARM_CHECK) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Altitude disparity\");\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 46.88980618653106}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // Return true immediately if already armed\n    if (copter.motors->armed()) {\n        return true;\n    }\n\n    // check baro\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro vs inav altitude\n    if (check_enabled(ARMING_CHECK_BARO)) {\n        // Check baro vs inav altitude\n        if (copter.inertial_nav.get_altitude() > 0 &&\n            fabsf(copter.baro_alt - copter.inertial_nav.get_altitude()) > BARO_MAX_ALT_DISPARITY) {\n            check_failed(ARMING_CHECK_BARO, display_failure, \"Altitude disparity\");\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 49.87631178143279}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain.enabled() && (copter.terrain.get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_RANGEFINDER)) {\n        return false;\n    }\n\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 54.09748192179185}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain_follow_enabled() &&\n        (copter.g2.rtl_altitude_type == RTL_ALT_TERRAIN)) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 46.90355489642538}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain_follow) {\n        return copter.terrain_follow.terrain_source() == TerrainSource::TERRAIN_FROM_DATABASE && copter.rtl_alt_type == RTL_ALT_TYPE_TERRAIN;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 53.18067664467817}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // set attitude controller loop time\n    motors.set_loop_rate(scheduler.get_loop_rate_hz());\n\n    // call attitude controller\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 15.54261755344225}, {"code": "void Copter::run_rate_controller(){\n\t    // set attitude controller loop time\n    attitude_control->set_dt(scheduler.get_loop_period_s());\n\n    // run low level rate controllers that require only IMU input\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 25.69233688077618}, {"code": "void Copter::run_rate_controller(){\n\t    // set attitude controller loop time\n    motors->set_dt(scheduler.get_loop_period_s());\n\n    // run low level rate controllers that only require IMU input\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 16.060305617106348}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.same_latlon_as(new_loc) &&\n        old_loc.alt_frame == new_loc.alt_frame) {\n        // no need to update location\n        return false;\n    }\n\n    // set new target location\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 50.13554085889365}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old location matches the new location\n    if (old_loc.same_latlon_as(new_loc)) {\n        // check if the altitude frames match\n        if (old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n            // set the new location as the target location\n            set_target_location(new_loc);\n            return true;\n        }\n    }\n    // return false if the conditions are not met\n    return false;\n}", "CodeBleu_score": 53.70540971837438}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.same_latlon_as(new_loc) &&\n        old_loc.frame_match_xy(new_loc) &&\n        old_loc.alt_frame == new_loc.alt_frame) {\n        // no need to update location\n        return false;\n    }\n\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 52.46365649388801}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // switch is in HIGH position so change mode\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    } else {\n        // ensure we don't leave rc_failsafe\n        if (copter.failsafe.radio) {\n            return;\n        }\n\n        // switch is in LOW position so return to flight mode switch or return to flight mode switch if already in that mode\n        if (copter.flightmode->mode_number() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 69.93674393420858}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // switch is in HIGH position so set mode\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    } else if (copter.flightmode->mode_number() == mode) {\n        // ensure we don't leave rc switch in HIGH position if mode switching has not succeeded\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 71.53418133397724}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // switch is in HIGH position so set the flight mode\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    } else {\n        // ensure flight mode is not changed\n        if (copter.flightmode->mode_number() == mode) {\n            // switch is in LOW position so reset flight mode switch\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 73.71135259335495}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // save roll and pitch trim\n    float roll_trim = ToRad((float)channel_roll->get_control_in()/100.0f);\n    float pitch_trim = ToRad((float)channel_pitch->get_control_in()/100.0f);\n    ahrs.add_trim(roll_trim, pitch_trim);\n    Log_Write_Event(DATA_SAVE_TRIM);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 89.79431911603955}, {"code": "void Copter::save_trim(){\n\t    // save roll and pitch trim\n    float roll_trim = ToRad((float)channel_roll->get_control_in()/100.0f);\n    float pitch_trim = ToRad((float)channel_pitch->get_control_in()/100.0f);\n    ahrs.add_trim(roll_trim, pitch_trim);\n    Log_Write_Event(DATA_SAVE_TRIM);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 89.79431911603955}, {"code": "void Copter::save_trim(){\n\t    if (channel_roll->get_control_in() == 0 && channel_pitch->get_control_in() == 0) {\n        ahrs.save_trim();\n        Log_Write_Event(DATA_SAVE_TRIM);\n        gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n    }\n}", "CodeBleu_score": 36.087337255596665}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n    const float speed_sq = vel.sq_length();\n    // Commanded Yaw to automatically look ahead.\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_LOOKAHEAD_SQ)) {\n        _look_ahead_yaw = degrees(atan2f(-vel.y, -vel.x));\n        _look_ahead_yaw = wrap_180_cd(_look_ahead_yaw);\n    }\n    return _look_ahead_yaw;\n}", "CodeBleu_score": 70.07389510708663}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.length_squared();\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQUARED)) {\n        // Commanded Yaw to automatically look ahead.\n        _look_ahead_yaw = degrees(atan2f(-vel.y, -vel.x))*100.0f;\n    }\n    return _look_ahead_yaw;\n}", "CodeBleu_score": 66.97804555926884}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f& vel = copter.inertial_nav.get_velocity_neu();\n    float speed_sq = vel.length_squared();\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQUARED)) {\n        look_ahead_yaw = degrees(atan2f(-vel.x, -vel.y)) * 100.0f;\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 60.650939847369614}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // Perform arming checks common to all vehicle types\n    if (!AP_Arming::arm_checks(method)) {\n        return false;\n    }\n\n    // Perform additional arming checks for Plane\n    switch (method) {\n        case AP_Arming::Method::RUDDER:\n            if (plane.g.rudder_only) {\n                const char *msg = \"Rudder Arming Enabled\";\n                check_failed(ARMING_CHECK_PARAMETERS, display_failure_f(msg));\n                return false;\n            }\n            if (!is_zero(plane.get_pilot_desired_throttle(channel_throttle->get_control_in()))) {\n                const char *msg = \"Non-zero throttle with rudder arming\";\n                check_failed(ARMING_CHECK_PARAMETERS, display_failure_f(msg));\n                return false;\n            }\n            break;\n        case AP_Arming::Method::MAVLINK:\n            // always allow arming via mavlink\n            break;\n        default:\n            // deny arming from any other method\n            return false;\n    }\n\n    // return true if we've passed all checks\n    return true;\n}", "CodeBleu_score": 54.29165529442297}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // check if arming checks are disabled\n    if (checks_to_perform == 0) {\n        return true;\n    }\n\n    // check if the watchdog was armed\n    if (watchdog_was_armed) {\n        return true;\n    }\n\n    // check if the arming method is RUDDER\n    if (method == AP_Arming::Method::RUDDER) {\n        // check if rudder arming is disabled\n        if (!plane.control_mode->allows_arming_with_rudder_arm()) {\n            check_failed(ARMING_CHECK_RUDDER, display_failure_f(\"Rudder arming disabled\"));\n            return false;\n        }\n\n        // check if the throttle is not zero\n        if (plane.get_throttle_input() == 0) {\n            check_failed(ARMING_CHECK_RUDDER, display_failure_f(\"Throttle at zero\"));\n            return false;\n        }\n    }\n\n    // call and return the result of the parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 67.43525411143332}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        // option must be enabled:\n        if (!check_enabled(ARMING_CHECK_PARAMETERS)) {\n            return true;\n        }\n\n        // rudder arming must be enabled:\n        if (!plane.rudder_arming_enabled()) {\n            check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Rudder arming disabled\");\n            return false;\n        }\n\n        // throttle must be zero:\n        if (plane.get_throttle_input() > 0) {\n            check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Throttle Failsafe not cleared\");\n            return false;\n        }\n\n        // if we got this far all must be ok\n        return true;\n    }\n\n    // call parent class checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 61.93681102602602}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // update location from EKF\n    Location temp_loc;\n    if (ahrs.get_location(temp_loc)) {\n        set_home_with_lock(temp_loc);\n    }\n\n    // update current_loc\n    current_loc = temp_loc;\n\n    // update inav's current position\n    plane.inertial_nav.set_position_xy_z(temp_loc.lat, temp_loc.lng, temp_loc.alt, true);\n\n    // change arm state\n    change_arm_state();\n\n    // set armed flag\n    plane.set_armed(true);\n\n    // log flight mode in case it was changed while vehicle was disarmed\n    plane.logger.set_vehicle_armed(true);\n\n    // save to eeprom\n    plane.quadplane.save_tuning();\n\n    // start pre-arm checks timer\n    plane.pre_arm_check_timer_ms = AP_HAL::millis();\n\n    // disable cpu failsafe because initialising everything takes a while\n    plane.failsafe.disable_with_timeout(10*1000);\n\n    // flash leds\n    AP_Notify::flags.armed = true;\n    AP_Notify::flags.failsafe_battery = false;\n    gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n    // update notify\n    AP_Notify::flags.armed = true;\n    AP_Notify::flags.failsafe_battery = false;\n\n    return true;\n}", "CodeBleu_score": 58.21484439109501}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // remember home to prevent recall\n    AP::ahrs().set_home(plane.home);\n\n    // update current location\n    AP::ahrs().lock_home();\n\n    // update notify object\n    AP_Notify::flags.armed = true;\n    AP::notify().update_notify();\n\n    // log arming to dataflash\n    plane.log_arming();\n\n    // play a tone\n    AP_Notify::events.arming_tune = true;\n\n    // return success\n    return true;\n}", "CodeBleu_score": 57.55019126446796}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed) {\n        return true;\n    }\n\n    // check if disarm button has been configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm button not configured\");\n        }\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 75.53504359802822}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // check if disarm function is assigned\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.63145009543226}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    // call superclass method\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.63145009543226}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    // Calculate the rotation matrix\n    float sin_yaw = sinf(ahrs.yaw);\n    float cos_yaw = cosf(ahrs.yaw);\n    // Apply the rotation matrix\n    float ne_x = x * cos_yaw - y * sin_yaw;\n    float ne_y = x * sin_yaw + y * cos_yaw;\n    // Update x and y with the new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 57.55663929521988}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    // Calculate the rotation matrix using the yaw angle from the AHRS\n    const float cos_yaw = cosf(ahrs.yaw);\n    const float sin_yaw = sinf(ahrs.yaw);\n    const float rotation_matrix[2][2] = {{cos_yaw, -sin_yaw}, {sin_yaw, cos_yaw}};\n\n    // Apply the rotation matrix to the coordinates\n    float ne_x = rotation_matrix[0][0] * x + rotation_matrix[0][1] * y;\n    float ne_y = rotation_matrix[1][0] * x + rotation_matrix[1][1] * y;\n\n    // Update the input variables with the new coordinates\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 50.90070278065697}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    // calculate the rotation matrix\n    float sin_yaw = sinf(ahrs.yaw);\n    float cos_yaw = cosf(ahrs.yaw);\n\n    // rotate the coordinates\n    float ne_x = x * cos_yaw - y * sin_yaw;\n    float ne_y = x * sin_yaw + y * cos_yaw;\n\n    // update the input coordinates with the new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 57.55663929521988}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Check if yaw angle and param4 are within acceptable ranges\n    if (packet.param1 > 360.0f || packet.param1 < 0.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param4 > 1.0f || packet.param4 < 0.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set yaw heading using the provided parameters\n    sub.mode_guided.set_yaw_heading(packet.param1, packet.param4);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.26823108360788}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Convert the yaw angle from degrees to radians\n    const float yaw_angle_rad = radians(packet.param1);\n    // Check if the yaw angle is within the acceptable range of -180 to 180 degrees\n    if (is_zero(packet.param1) || !is_equal(yaw_angle_rad, packet.param1)) {\n        return MAV_RESULT_DENIED;\n    }\n    // Check if the param4 value is within the acceptable range of 0 to 1\n    if (packet.param4 < 0.0f || packet.param4 > 1.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    // Set the yaw heading using the provided parameters\n    sub.set_yaw_heading(yaw_angle_rad, packet.param4);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.84825917846134}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Convert the yaw angle from degrees to radians\n    const float yaw_angle_rad = radians(packet.param1);\n\n    // Check if the yaw angle is within the acceptable range\n    if (yaw_angle_rad < -M_PI || yaw_angle_rad > M_PI) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if param4 is within the acceptable range\n    if (packet.param4 < 0 || packet.param4 > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set the yaw heading using the provided parameters\n    sub.set_yaw_heading(yaw_angle_rad, packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 41.24131670825967}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        return wrap_360_cd(sub.mode_guided.wp_bearing_cd()) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 88.59465098613943}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        return wrap_360_cd(sub.mode_guided.wp_bearing_cd()) / 200;\n    }\n    return 0;\n}", "CodeBleu_score": 91.7172745812542}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 200;\n    }\n    return 0;\n}", "CodeBleu_score": 98.80793469472702}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us: AP_HAL::micros64(),\n            id: (uint8_t)id,\n            data_value: value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 88.3159519841957}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us: AP_HAL::micros64(),\n            id: (uint8_t)id,\n            data_value: value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 88.3159519841957}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us: AP_HAL::micros64(),\n            id: (uint8_t)id,\n            data_value: value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 88.3159519841957}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    // if disarmed and home is not set, set home to current location\n    if (!motors.armed()) {\n        Location temp_loc;\n        if (ahrs.get_location(temp_loc)) {\n            set_home(temp_loc, false);\n        }\n        return;\n    }\n\n    // if armed, set home to current location\n    Location temp_loc;\n    if (ahrs.get_location(temp_loc)) {\n        set_home(temp_loc, false);\n    }\n}", "CodeBleu_score": 27.23883743284198}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    Location temp_loc;\n\n    // if EKF origin has been set, use it and exit\n    if (ahrs.get_origin(temp_loc)) {\n        set_home(temp_loc, false);\n        return;\n    }\n\n    // if we are on the ground, set home to current location\n    if (!motors.armed()) {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 31.023043300167842}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    // if we are disarmed, set home to current location\n    if (is_disarmed()) {\n        Location loc;\n        if (ahrs.get_position(loc)) {\n            set_home(loc, false);\n        }\n    }\n\n    // set EKF origin if it has not been set\n    Location ekf_origin;\n    if (ahrs.get_origin(ekf_origin)) {\n        if (ekf_origin.lat == 0 && ekf_origin.lng == 0 && ekf_origin.alt == 0) {\n            // new EKF origin\n            Log_Write_Event(DATA_EKF_ORIGIN_SET);\n        }\n    }\n}", "CodeBleu_score": 24.40116500542037}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialise waypoint controller\n    sub.wp_nav->wp_and_spline_init();\n\n    // set to position control mode\n    guided_pos_control_run();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_limit.start_time = AP_HAL::millis();\n    guided_limit.start_pos = inertial_nav.get_position();\n}", "CodeBleu_score": 26.132411459873538}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set to position control mode\n    sub.mode_guided.set_mode(SubMode::GUIDED_POS);\n\n    // initialise waypoint controller\n    sub.mode_guided.wp_nav.wp_and_spline_init();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_limit.start_time = AP_HAL::millis();\n    guided_limit.start_pos = inertial_nav.get_position();\n\n    // set guided mode's target position and velocity to current position and velocity\n    guided_limit.pos_target_cm = inertial_nav.get_position();\n    guided_limit.vel_target_cms = inertial_nav.get_velocity();\n\n    // get default yaw state\n    guided_angle_state.update_time_ms = AP_HAL::millis();\n    guided_angle_state.roll_cd = ahrs.roll_sensor;\n    guided_angle_state.pitch_cd = ahrs.pitch_sensor;\n    guided_angle_state.yaw_cd = ahrs.yaw_sensor;\n    guided_angle_state.climb_rate_cms = 0.0f;\n\n    // clear guided start time if we are going to a new destination\n    guided_limit.time_and_pos_control_start_time_ms = 0;\n\n    // set yaw state to yaw to next navigation leg\n    guided_angle_state.yaw_state = AUTO_YAW_LOOK_AT_NEXT_WP;\n\n    // reset position limiting\n    guided_limit.horiz_max_cm = 0.0f;\n\n    // reset the timeout timer\n    update_time_ms = AP_HAL::millis();\n}", "CodeBleu_score": 33.87534619565271}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set to position control mode\n    sub.guided_set_angle(AUTO_YAW_HOLD);\n\n    // initialise waypoint controller\n    guided_pos_control_run();\n}", "CodeBleu_score": 8.929894047445702}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set to velocity control mode\n    sub.guided_mode = Guided_Velocity;\n\n    // set vertical speed and acceleration limits\n    sub.wp_nav.set_speed_xy(wp_nav.get_default_speed_xy());\n    sub.wp_nav.set_accel_xy(wp_nav.get_wp_acceleration());\n    sub.wp_nav.set_speed_up(wp_nav.get_wp_speed_up());\n    sub.wp_nav.set_speed_down(wp_nav.get_wp_speed_down());\n    sub.wp_nav.set_speed_cruise(wp_nav.get_wp_speed_cruise());\n\n    // initialise the vertical position controller\n    if (!pos_control.is_active_z()) {\n        pos_control.init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    if (!pos_control.is_active_xy()) {\n        pos_control.init_xy_controller();\n    }\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 61.62340113136339}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set guided_mode to velocity controller\n    sub.guided_mode = Guided_Velocity;\n\n    // initialize vertical speeds and acceleration\n    pos_control.set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_velocity_z_max, g.pilot_accel_z);\n\n    // initialize vertical position controller\n    pos_control.set_alt_target_to_current_alt();\n\n    // initialise the vertical position controller\n    if (!pos_control.is_active_z()) {\n        pos_control.init_z_controller();\n    }\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 51.54520913157922}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set to velocity control mode\n    sub.guided_mode = Guided_Velocity;\n\n    // initialize vertical maximum speeds and acceleration\n    sub.pos_control.set_max_speed_accel_z(-sub.get_pilot_velocity_z_max_dn(), sub.g.pilot_velocity_z_max_up, sub.g.pilot_accel_z);\n\n    // initialise the vertical position controller\n    if (!sub.pos_control.is_active_z()) {\n        sub.pos_control.init_z_controller();\n    }\n\n    // initialise the horizontal position controller\n    if (!sub.pos_control.is_active_xy()) {\n        sub.pos_control.init_xy_controller();\n    }\n\n    // set vertical speed and acceleration limits\n    sub.pos_control.set_max_speed_accel_xy(sub.wp_nav.get_default_speed_xy(), sub.wp_nav.get_wp_acceleration());\n    sub.pos_control.set_correction_speed_accel_xy(sub.wp_nav.get_default_speed_xy(), sub.wp_nav.get_wp_acceleration());\n\n    // initialise the vertical position controller\n    if (!sub.pos_control.is_active_z()) {\n        sub.pos_control.init_z_controller();\n    }\n\n    // set auto yaw mode\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 40.97478164496345}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    if ((guided_limit.timeout_ms > 0) &&\n        (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {\n        return true;\n    }\n\n    // get current location\n    const Vector3f& curr_pos = inertial_nav.get_position_neu_cm();\n\n    // check if z altitude has gotten within 20cm of the destination\n    if ((guided_limit.alt_min_cm > 0) && (guided_limit.alt_max_cm > 0) &&\n        (curr_pos.z < guided_limit.alt_min_cm + 20.0f || curr_pos.z > guided_limit.alt_max_cm - 20.0f)) {\n        return true;\n    }\n\n    // check if we have gone too far\n    if (guided_limit.horiz_max_cm > 0) {\n        if (get_horizontal_distance_cm(curr_pos.xy(), guided_limit.start_pos.xy()) > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be in keep going\n    return false;\n}", "CodeBleu_score": 67.60557443551326}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    if ((guided_limit.timeout_ms > 0) && (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {\n        return true;\n    }\n\n    // get current location\n    const Vector3f& curr_pos = inertial_nav.get_position_neu_cm();\n\n    // check if altitude has gone below min\n    if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {\n        return true;\n    }\n\n    // check if altitude has gone above max\n    if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {\n        return true;\n    }\n\n    // check if horizontal distance has gone above max\n    if (guided_limit.horiz_max_cm > 0.0f) {\n        const float horiz_move = get_horizontal_distance_cm(guided_limit.start_pos.xy(), curr_pos.xy());\n        if (horiz_move > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be within limits\n    return false;\n}", "CodeBleu_score": 95.47436340708879}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    if ((guided_limit.timeout_ms > 0) &&\n        (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {\n        return true;\n    }\n\n    // get current location\n    const Vector3f& curr_pos = inertial_nav.get_position_neu_cm();\n\n    // check if altitude is below min\n    if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {\n        return true;\n    }\n\n    // check if altitude is above max\n    if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {\n        return true;\n    }\n\n    // check if horizontal distance is greater than limit\n    if (guided_limit.horiz_max_cm > 0.0f) {\n        float horiz_move = get_horizontal_distance_cm(guided_limit.start_pos.xy(), curr_pos.xy());\n        if (horiz_move > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be within limits\n    return false;\n}", "CodeBleu_score": 93.05311687601791}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    // get time since last motor test message received\n    uint32_t tnow = AP_HAL::millis();\n    uint32_t motor_test_timeout_ms = 500;\n    if (tnow - last_do_motor_test_ms > motor_test_timeout_ms) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        pass_motor_test = false;\n        ap.motor_test = false;\n        disarm_motors();\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n\n    // if we get this far, the test passes\n    return true;\n}", "CodeBleu_score": 63.02167887201485}, {"code": "bool Sub::verify_motor_test(){\n\t    // check if motor test requests are received at least every 2 Hz\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - last_do_motor_test_ms < 500) {\n        // timeout\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        ap.motor_test_pass = false;\n        ap.motor_test = false;\n        disarm_motors();\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    // pass\n    ap.motor_test_pass = true;\n    return true;\n}", "CodeBleu_score": 59.0858315004946}, {"code": "bool Sub::verify_motor_test(){\n\t    uint32_t tnow = AP_HAL::millis();\n\n    // check if motor test requests are received at least every 2 Hz\n    if (tnow - last_do_motor_test_ms < 500) {\n        return true;\n    }\n\n    // timeout message\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n\n    // set pass flag to false\n    motor_test_pass = false;\n\n    // disable motor test\n    ap.motor_test = false;\n\n    // disarm system\n    init_disarm_motors();\n\n    // record failure time\n    last_do_motor_test_fail_ms = tnow;\n\n    // return false\n    return false;\n}", "CodeBleu_score": 47.62399459569038}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = -wp_nav->get_pitch(); // output is reversed\n\n    // Constrain target forward/lateral values\n    // The targets can never require more than 100% of the maximum vertical or horizontal control throw\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize targets\n    lateral_out /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 49.2485483022293}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav.get_roll();\n    forward_out = -wp_nav.get_pitch(); // output is reversed\n\n    // constrain target forward/lateral values\n    // The outputs of wp_nav.get_roll() and get_pitch() should already be constrained to these maximum angles at this point.\n    // These are only included here for the sake of ensuring that the targets returned by this function remain constrained within their limits.\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize the roll and pitch targets\n    lateral_out  /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 49.8129792978532}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = -wp_nav->get_pitch(); // output is reversed\n\n    // constrain target forward/lateral values\n    // The outputs of wp_nav->get_roll() and wp_nav->get_pitch() should already be constrained to these maximum angles.\n    // These are only here prevent breakage of third party code which assumes the values are unconstrained.\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize them within the range [-1,1]\n    lateral_out /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 49.2485483022293}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}, {"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}, {"code": "void Sub::read_barometer(){\n\t    if (!barometer.healthy()) {\n        barometer.init();\n    }\n\n    barometer.update();\n\n    if (barometer.healthy()) {\n        baro_alt = barometer.get_altitude() * 100.0f;\n\n        if (baro_alt > baro_alt_max) {\n            baro_alt_max = baro_alt;\n        }\n\n        if (baro_alt < baro_alt_min) {\n            baro_alt_min = baro_alt;\n        }\n\n        if (baro_alt > -1.0f) {\n            baro_calibration_sum += baro_alt;\n            baro_calibration_count++;\n        }\n\n        if (depth_sensor_present) {\n            // if we have a depth sensor, then we can update the\n            // health of the barometer\n            if (depth_sensor.healthy()) {\n                barometer.set_healthy(true);\n            } else {\n                barometer.set_healthy(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 48.1993414952416}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf has no origin yet (probably EKF not enabled)\n    Location temp_loc;\n    if (!ahrs.get_origin(temp_loc)) {\n        return false;\n    }\n\n    // return true if inertial nav is not enabled\n    if (!ahrs.have_inertial_nav()) {\n        return true;\n    }\n\n    // return true if motors are disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // ensure ahrs have received GPS\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = ahrs.get_filter_status();\n\n    // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs && filt_status.flags.pred_horiz_pos_abs);\n    }\n\n    // return true if ekf's horizontal absolute position estimate is ok and home position is set\n    return (filt_status.flags.horiz_pos_abs && filt_status.flags.pred_horiz_pos_abs && filt_status.flags.horiz_pos_rel && filt_status.flags.pred_horiz_pos_rel && filt_status.flags.using_gps && !filt_status.flags.const_pos_mode);\n}", "CodeBleu_score": 55.73060370784199}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return immediately if ekf not yet initialised\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = ahrs.get_filter_status();\n\n    // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs && !filt_status.flags.pred_horiz_pos_abs);\n    }\n\n    // if armed we require a good absolute or predicted horizontal position\n    return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs) && !filt_status.flags.const_pos_mode);\n}", "CodeBleu_score": 69.02621474185192}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return immediately if ekf is not present\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // return true if not arming or we are armed and still initialising\n    if (!arming.is_armed() || arming.is_armed() && !motors.armed()) {\n        return true;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = inertial_nav.get_filter_status();\n\n    // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs && filt_status.flags.pred_horiz_pos_abs);\n    }\n\n    // once armed we require a good absolute or predicted horizontal position\n    return (filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs);\n}", "CodeBleu_score": 64.02780673776178}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure ahrs is ready\n    if (!rover.ahrs.pre_arm_checks(display_failure)) {\n        return false;\n    }\n\n    // check ekf failsafe\n    if (rover.failsafe.ekf) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"EKF failsafe\");\n        return false;\n    }\n\n    // ensure position estimate is ok\n    if (!rover.ekf_position_ok()) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"Position estimate too far from EKF origin\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 64.4696487506604}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check AHRS is ready\n    if (!rover.ahrs.healthy()) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"AHRS not healthy\");\n        return false;\n    }\n\n    // check EKF failsafe\n    if (rover.failsafe.ekf) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"EKF failsafe\");\n        return false;\n    }\n\n    // check position estimate is ok\n    if (!rover.ekf_position_ok()) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"Position estimate not ok\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 56.44965484474124}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we have no gps failsafe, then return true, as we can't check for GPS\n    if (!(checks_to_perform & ARMING_CHECK_GPS)) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // Check if AHRS initialised\n    if (rover.ahrs.initialised() == false) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not initialised\");\n        return false;\n    }\n\n    // check for ekf failsafe\n    if (rover.failsafe.ekf) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe\");\n        return false;\n    }\n\n    // ensure position estimate is ok\n    if (!rover.ekf_position_ok()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"Position estimate invalid\");\n        return false;\n    }\n\n    // if we've gotten this far then all must be ok\n    return true;\n}", "CodeBleu_score": 61.69093466509361}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // set simple mode heading if necessary\n    if (rover.control_mode->is_simple_mode()) {\n        rover.mode_simple.set_desired_heading_to_current_heading();\n    }\n\n    // set smart RTL home location\n    rover.smart_rtl.set_home(true);\n\n    // record home heading for sail vehicles\n    if (rover.control_mode->is_boat_mode()) {\n        rover.mode_boat.record_home_heading();\n    }\n\n    // update soft armed flag\n    update_soft_armed();\n\n    // log arming to dataflash\n    AP::logger().Write_Event(LogEvent::ARMING_RUDDER);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 63.77681968630131}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (!checkShouldCharge()) {\n            if (millis() - last_charge_disabled_millis > CHARGE_DISABLE_RETRY_TIME_MS) {\n                charging_enabled = false;\n                p.chargingEnable(false);\n            }\n        } else {\n            charging_enabled = true;\n            p.chargingEnable(true);\n        }\n    } else {\n        if (millis() - last_charge_disabled_millis > CHARGE_DISABLE_RETRY_TIME_MS) {\n            charging_enabled = false;\n            p.chargingEnable(false);\n        }\n    }\n}", "CodeBleu_score": 50.729739631646865}, {"code": "void updateChargingEnabled(){\n\t    // if charging is allowed, enable charging if necessary\n    if (charging_allowed) {\n        if (!charging_enabled) {\n            charging_enabled = true;\n            charging_enabled_millis = millis();\n            charging_enabled_count = 0;\n            digitalWrite(PIN_CHARGE_ENABLE, HIGH);\n        }\n    }\n    // if charging is not allowed, disable charging if necessary\n    else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_enabled_millis = millis();\n            charging_enabled_count = 0;\n            digitalWrite(PIN_CHARGE_ENABLE, LOW);\n        }\n    }\n    // if charging is not allowed and it's been more than 10 seconds since the last attempt to disable charging, try enabling charging again\n    if (!charging_allowed && !charging_enabled && millis() - charging_enabled_millis > 10000) {\n        charging_enabled_millis = millis();\n        charging_enabled_count++;\n        // if the charger is not connected, try enabling charging again after a short delay\n        if (!digitalRead(PIN_CHARGE_CONNECTED)) {\n            charging_enabled = true;\n            digitalWrite(PIN_CHARGE_ENABLE, HIGH);\n        }\n        // if the charger is connected, try enabling charging again after a longer delay\n        else if (charging_enabled_count < 10) {\n            charging_enabled = true;\n            digitalWrite(PIN_CHARGE_ENABLE, HIGH);\n        }\n        // if the charger is connected and the maximum number of attempts have been made, disable charging\n        else {\n            charging_enabled = false;\n            digitalWrite(PIN_CHARGE_ENABLE, LOW);\n        }\n    }\n}", "CodeBleu_score": 56.8982042247756}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed && !checkShouldCharge()) {\n        if (millis() - last_charging_disabled_time > CHARGING_DISABLED_RETRY_DELAY_MS) {\n            last_charging_disabled_time = millis();\n            charging_enabled = false;\n            p.chargingEnabled(false);\n        }\n    } else {\n        charging_enabled = charging_allowed;\n        p.chargingEnabled(charging_enabled);\n    }\n}", "CodeBleu_score": 39.356759050185474}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t    if (ROS_running && size >= 4) {\n        uint16_t crc = crc16(message, size - 2);\n        memcpy((char *) message + size - 2, &crc, 2);\n        packetSerial.send((uint8_t *) message, size);\n    }\n}", "CodeBleu_score": 43.61026259889682}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ROS_running && size >= 4) {\n        uint8_t *msg = (uint8_t *) message;\n        uint16_t crc = crc16_update(0, msg, size - 2);\n        msg[size - 2] = crc & 0xFF;\n        msg[size - 1] = (crc >> 8) & 0xFF;\n\n        packetSerial.send(msg, size);\n    }\n}", "CodeBleu_score": 64.21995559616298}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ROS_running && size >= 4) {\n        uint16_t crc = calculate_crc(message, size);\n        uint8_t *msg = (uint8_t *) message;\n        msg[size] = crc & 0xFF;\n        msg[size + 1] = (crc >> 8) & 0xFF;\n        packetSerial.send(msg, size + 2);\n    }\n}", "CodeBleu_score": 60.79091011586403}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t    soundSerial.begin(9600);\n    soundSerial.clear();\n    myMP3.begin(soundSerial);\n    delay(100);\n    this->anzSoundfiles = myMP3.getTotalFiles();\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n    return this->sound_available;\n}", "CodeBleu_score": 57.64236173977236}, {"code": "bool MP3Sound::begin(){\n\t\n    soundSerial.begin(9600);\n    soundSerial.clear();\n\n    myMP3.begin(soundSerial, true);\n    delay(1000);\n\n    this->anzSoundfiles = myMP3.numSDFiles();\n\n    if (this->anzSoundfiles > 0) {\n        this->sound_available = true;\n    }\n\n    return this->sound_available;\n\n}", "CodeBleu_score": 59.53894394988539}, {"code": "bool MP3Sound::begin(){\n\t\n    soundSerial.begin(9600);\n    soundSerial.clear();\n\n    myMP3.begin(soundSerial);\n    delay(1000);\n\n    this->anzSoundfiles = myMP3.getTotalFiles();\n\n    if (this->anzSoundfiles > 0)\n    {\n        this->sound_available = true;\n    }\n\n    return this->sound_available;\n\n}", "CodeBleu_score": 57.99695340996105}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\n    if(active_sounds.size() == 0) return 0;\n\n    if(myMP3.available() && !myMP3.isPlaying()) {\n\n        myMP3.play(active_sounds.back());\n        active_sounds.pop_back();\n        return active_sounds.size();\n\n    }\n\n    return active_sounds.size();\n\n}", "CodeBleu_score": 49.12287604161833}, {"code": "int MP3Sound::processSounds(){\n\t\n    if (active_sounds.size() == 0) return 0;\n\n    if (playing == false) {\n        int soundNr = active_sounds.back();\n        active_sounds.pop_back();\n        myMP3.play(soundNr);\n        playing = true;\n        return active_sounds.size();\n    }\n\n    return active_sounds.size();\n\n}", "CodeBleu_score": 52.55626999406648}, {"code": "int MP3Sound::processSounds(){\n\t\n    if (active_sounds.size() == 0) {\n        playing = false;\n        return 0;\n    }\n\n    if (playing) {\n        if (myMP3.available()) {\n            if (myMP3.readType() == DFPlayerPlayFinished) {\n                playing = false;\n            }\n        }\n    }\n\n    if (!playing) {\n        int soundNr = active_sounds.back();\n        active_sounds.pop_back();\n        myMP3.play(soundNr);\n        playing = true;\n    }\n\n    return active_sounds.size();\n}", "CodeBleu_score": 55.60216536850937}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (c->image->memory_mapped_file_name) {\n      free(c->image->memory_mapped_file_name);\n      c->image->memory_mapped_file_name = NULL;\n    }\n    c->image->memory_mapped_file_name = request_read_string(r);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 42.98781654344908}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (c->mmap_filename)\n      free(c->mmap_filename);\n    c->mmap_filename = request_read_string(r);\n    c->mmap_file_size = request_read_uint32(r);\n    c->mmap_file_descriptor = -1;\n    c->mmap_file_pointer = NULL;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 49.73839748901822}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (c->file_name) {\n#ifdef _WIN32\n      UnmapViewOfFile(c->file_map);\n      CloseHandle(c->file_handle);\n#else  // memory mapped files\n      munmap(c->file_map, c->file_size);\n      close(c->file_handle);\n#endif\n      free(c->file_name);\n      c->file_name = NULL;\n    }\n    c->file_name = request_read_string(r);\n#ifdef _WIN32\n    c->file_handle = CreateFile(c->file_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    c->file_map = MapViewOfFile(c->file_handle, FILE_MAP_READ, 0, 0, 0);\n#else  // memory mapped files\n    c->file_handle = open(c->file_name, O_RDONLY);\n    struct stat s;\n    fstat(c->file_handle, &s);\n    c->file_size = s.st_size;\n    c->file_map = mmap(0, c->file_size, PROT_READ, MAP_SHARED, c->file_handle, 0);\n#endif\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 44.36525422884656}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.7323980855264}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.7323980855264}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.7323980855264}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 60.093445795918356}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 60.093445795918356}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock();\n  Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    sampling_period = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 72.32407277559176}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = string(dmsString);\n  free(dmsString);\n  return result;\n}", "CodeBleu_score": 47.40291523664223}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  free(dms);\n  return result;\n}", "CodeBleu_score": 43.090065346945124}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n    const dReal *const s = ((dxBox *) g)->side;\n    const dReal *const p = ((dxBox *) g)->pos;\n\n    // Calculate the relative position of the point to the box center\n    dReal dx = x - p[0];\n    dReal dy = y - p[1];\n    dReal dz = z - p[2];\n\n    // Check each axis for proximity to the box's surface\n    dReal dist = s[0] - fabs(dx);\n    plane[0] = dSign(dx);\n    plane[1] = 0.0;\n    plane[2] = 0.0;\n    plane[3] = dist;\n\n    dReal distY = s[1] - fabs(dy);\n    if (distY < dist) {\n        plane[0] = 0.0;\n        plane[1] = dSign(dy);\n        plane[2] = 0.0;\n        plane[3] = distY;\n        dist = distY;\n    }\n\n    dReal distZ = s[2] - fabs(dz);\n    if (distZ < dist) {\n        plane[0] = 0.0;\n        plane[1] = 0.0;\n        plane[2] = dSign(dz);\n        plane[3] = distZ;\n    }\n}", "CodeBleu_score": 45.336145179683285}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\n    const dReal *const s = ((dxBox *) g)->side;\n    const dReal *const p = g->pos;\n    const dReal dx = x - p[0];\n    const dReal dy = y - p[1];\n    const dReal dz = z - p[2];\n\n    // Check each axis for proximity to the box's surface\n    if (fabs(dx) < s[0] / 2) {\n        plane[0] = (dx > 0) ? 1.0 : -1.0;\n        plane[1] = 0.0;\n        plane[2] = 0.0;\n        plane[3] = p[0] + s[0] / 2 * plane[0];\n    } else if (fabs(dy) < s[1] / 2) {\n        plane[0] = 0.0;\n        plane[1] = (dy > 0) ? 1.0 : -1.0;\n        plane[2] = 0.0;\n        plane[3] = p[1] + s[1] / 2 * plane[1];\n    } else if (fabs(dz) < s[2] / 2) {\n        plane[0] = 0.0;\n        plane[1] = 0.0;\n        plane[2] = (dz > 0) ? 1.0 : -1.0;\n        plane[3] = p[2] + s[2] / 2 * plane[2];\n    } else {\n        // If the point is not close to any surface, set the plane to the default values\n        plane[0] = 0.0;\n        plane[1] = 0.0;\n        plane[2] = 1.0;\n        plane[3] = p[2];\n    }\n}", "CodeBleu_score": 42.24525216003478}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT (g && g->type == dBoxClass,\"argument not a box\");\n\n    const dReal *const s = ((dxBox*) g)->side;\n    const dReal *const r = g->pos;\n\n    dReal d1 = x - r[0];\n    dReal d2 = y - r[1];\n    dReal d3 = z - r[2];\n\n    dReal d = dAbs(d1);\n    dReal dd = dAbs(d2);\n    dReal ddd = dAbs(d3);\n\n    if (ddd < d) {\n        d = ddd;\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2] = d3 < 0 ? -1 : 1;\n    }\n\n    if (dd < d) {\n        d = dd;\n        plane[0] = 0;\n        plane[1] = d2 < 0 ? -1 : 1;\n        plane[2] = 0;\n    }\n\n    if (d1 < d) {\n        plane[0] = d1 < 0 ? -1 : 1;\n        plane[1] = 0;\n        plane[2] = 0;\n    }\n\n    plane[3] = -d;\n}", "CodeBleu_score": 44.70822459725285}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dIASSERT(box);\n  dIASSERT(fluidPlane);\n  dIASSERT(immersion);\n\n  dBodyID body = dGeomGetBody(box->g1);\n  dIASSERT(body);\n  dIASSERT(flags >= 0);\n\n  sBoxImmersionData immersionData(box, fluidPlane, flags, immersion);\n  return immersionData.performImmersionChecking();\n}", "CodeBleu_score": 55.761262767633525}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  dxBox *const box = (dxBox *) o1;\n  dxCapsule *const capsule = (dxCapsule *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 98.18997189821218}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dIASSERT ((flags & NUMI_MASK) >= 1);\n    dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n    dContactGeom c[1];\n    const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n    if (collision == 0)\n        return 0;\n\n    dxBox *const box = (dxBox *) o1;\n    dxCapsule *const capsule = (dxCapsule *) o2;\n\n    immersion->g1 = o1;\n    immersion->g2 = o2;\n\n    dVector4 fluidPlane;\n    dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n    return dImmerseBox(box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.192938759883}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dIASSERT ((flags & NUMI_MASK) >= 1);\n    dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n    dContactGeom c[1];\n    const int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n    if (collision == 0)\n        return 0;\n\n    dxBox *const box = (dxBox *) o1;\n    dxCapsule *const capsule = (dxCapsule *) o2;\n\n    immersion->g1 = o1;\n    immersion->g2 = o2;\n\n    dVector4 fluidPlane;\n    dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n    return dImmerseBox(box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.192938759883}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n  return 2.0 * volume;\n}", "CodeBleu_score": 89.47583695948099}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n  return 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.71008041165729}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n  return 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.71008041165729}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n  xBuoyancyCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n  return xBuoyancyCenter * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 64.62946224868801}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n  xBuoyancyCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n  return 2.0 * m_fRadius * xBuoyancyCenter / volume;\n}", "CodeBleu_score": 65.99794252334875}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal end = asin(sinTheta1);\n  const dReal singularityStart = singularityFactor * end;\n  dReal xCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n  xCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n  return 2.0 * m_fRadiusSquare * xCenter / volume;\n}", "CodeBleu_score": 65.67265395456549}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  const dxCapsule *const capsule = (dxCapsule *) o1;\n  dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\n\n  sCapsuleImmersionData data(capsule, fluidPlane, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 81.82836014504853}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n  dContactGeom c[1];\n  const int collision = dCollideTrimeshCapsule(o2, o1, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n\n  const dxCapsule *const capsule = (dxCapsule *) o1;\n  dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  dVector4 fluidPlane;\n  dGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\n\n  return dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 86.65093816670392}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dIASSERT ((flags & NUMI_MASK) >= 1);\n    dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n    dContactGeom c[1];\n    const int collision = dCollideTrimeshCapsule(o2, o1, 1, c, sizeof(dContact));\n    if (collision == 0)\n        return 0;\n\n    const dxCapsule *const capsule = (dxCapsule *) o1;\n    dxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n    immersion->g1 = o1;\n    immersion->g2 = o2;\n\n    dVector4 fluidPlane;\n    dGeomTriMeshGetImmersionPlane(trimesh, fluidPlane);\n\n    sCapsuleImmersionData data(capsule, fluidPlane, flags, immersion);\n    return data.performImmersionChecking();\n}", "CodeBleu_score": 81.50240393398032}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  // Use the input port to access the sleep duration in milliseconds\n  int msecs = getInput<int>(\"msecs\").value();\n\n  if (msecs <= 0) {\n    // Invalid input, return SUCCESS\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start the timer\n  timer_waiting_ = true;\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_.start(msecs, [this]() {\n    // Set the timer_waiting_ flag to false\n    timer_waiting_ = false;\n\n    // Emit a wake-up signal\n    emitWakeUpSignal();\n  });\n\n  // If the timer is aborted, ensure the timer_waiting_ flag is reset\n  if (!timer_.isActive()) {\n    timer_waiting_ = false;\n  }\n\n  // Return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 53.099749048902844}, {"code": "NodeStatus SleepNode::onStart(){\n\t  Optional<int> ms = getInput<int>(\"msec\");\n  if (!ms) {\n    return NodeStatus::SUCCESS;\n  }\n  else if (ms.value() <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  timer_waiting_ = true;\n\n  setStatus(NodeStatus::RUNNING);\n  timer_.start(std::chrono::milliseconds(ms.value()));\n\n  auto callback = [this]() {\n    timer_waiting_ = false;\n    emitWakeUpSignal();\n  };\n\n  timer_.setCallback(callback);\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 53.91467670394397}, {"code": "NodeStatus SleepNode::onStart(){\n\t  int msecs;\n  if (!getInput(\"msecs\", msecs)) {\n    throw RuntimeError(\"Missing parameter [msecs] in SleepNode\");\n  }\n  if (msecs <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.start(msecs);\n  timer_.setCallback(std::bind(&SleepNode::halt, this));\n  timer_waiting_ = true;\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.876781486206845}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  auto entry = config().blackboard->get(entry_key_);\n  if(!entry) {\n    return NodeStatus::FAILURE;\n  }\n  auto& entry_ref = *entry;\n  std::unique_lock<std::mutex> lk(entry_ref.mutex);\n  if(entry_ref.seq_num != last_seq_num_) {\n    last_seq_num_ = entry_ref.seq_num;\n    return NodeStatus::SUCCESS;\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 48.43869762111299}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = tree_.blackboard()->get(entry_key_);\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n    auto& entry_ref = entry.value();\n    std::unique_lock<std::mutex> lk(entry_ref.mutex());\n    auto seq_id = entry_ref.seqNum();\n    if (last_seq_id_ != seq_id) {\n        last_seq_id_ = seq_id;\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 51.29555952553498}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = tree_.blackboard()->get(entry_key_);\n    if(!entry) {\n        return NodeStatus::FAILURE;\n    }\n    auto prev_seq = entry->seqNum();\n    entry->lock();\n    auto curr_seq = entry->seqNum();\n    entry->unlock();\n    if(prev_seq != curr_seq) {\n        entry->setSequenceNumber(curr_seq);\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 44.61477186090506}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    return success_threshold_ < 0 ? (children_nodes_.size() + success_threshold_ + 1) : success_threshold_;\n}", "CodeBleu_score": 46.235760796698}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(children_nodes_.size() + success_threshold_ + 1, size_t(0));\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 59.877916378515536}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    size_t success_threshold = success_threshold_;\n    if (success_threshold < 0) {\n        success_threshold = children_nodes_.size() + success_threshold + 1;\n    }\n    return (size_t) std::max(0, (int) success_threshold);\n}", "CodeBleu_score": 49.74773391937802}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    auto now = std::chrono::high_resolution_clock::now();\n    auto duration = now - _p->last_heartbeat_time;\n    auto duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>(duration);\n\n    if (duration_ms > std::chrono::milliseconds(500)) {\n      std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n      _p->heartbeat_active = false;\n      lk.unlock();\n      enableAllHooks(false);\n    }\n  }\n}", "CodeBleu_score": 50.12407248485915}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    auto now = std::chrono::high_resolution_clock::now();\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if (_p->heartbeat_active) {\n      if (now - _p->last_heartbeat > std::chrono::milliseconds(2000)) {\n        _p->heartbeat_active = false;\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 50.192201576512204}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n        if(_p->heartbeat_active) {\n            auto now = std::chrono::high_resolution_clock::now();\n            if(now - _p->heartbeat_time > std::chrono::milliseconds(500)) {\n                _p->heartbeat_active = false;\n                enableAllHooks(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 44.73738122603522}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  auto json_out = nlohmann::json::object();\n\n  std::vector<std::string> bb_names;\n  std::istringstream iss(bb_list);\n  std::string bb_name;\n  while (std::getline(iss, bb_name, ';')) {\n    bb_names.push_back(bb_name);\n  }\n\n  for (const auto& bb_name : bb_names) {\n    BT::TreeNode* subtree_root = nullptr;\n    {\n      std::unique_lock<std::mutex> lk(_p->tree_mutex);\n      auto it = _p->tree.find(bb_name);\n      if (it != _p->tree.end()) {\n        subtree_root = it->second;\n      }\n    }\n\n    if (subtree_root) {\n      std::unique_lock<std::mutex> lk(subtree_root->mutex());\n      if (subtree_root->isBlackboardInitialized()) {\n        auto blackboard = subtree_root->blackboard();\n        json_out[bb_name] = blackboard->toJsonString();\n      }\n    }\n  }\n\n  msgpack::sbuffer buffer;\n  msgpack::pack(buffer, json_out);\n  return std::vector<uint8_t>(buffer.data(), buffer.data() + buffer.size());\n}", "CodeBleu_score": 49.57166250060558}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  // Split the input string into a vector of blackboard names\n  std::vector<std::string> bb_names;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    bb_names.push_back(bb_name);\n  }\n\n  // Create a JSON object to store the blackboards\n  nlohmann::json json_out;\n\n  // Iterate through the blackboard names\n  for (const auto& bb_name : bb_names) {\n    // Find the corresponding subtree and lock it\n    auto subtree = _p->tree.subTree(bb_name);\n    std::unique_lock<std::mutex> lk(subtree->mutex());\n\n    // If the subtree is valid, export the blackboard to JSON and add it to the JSON object\n    if (subtree->valid()) {\n      nlohmann::json json_bb;\n      subtree->blackboard()->toJson(json_bb);\n      json_out[bb_name] = json_bb;\n    }\n  }\n\n  // Convert the JSON object to MessagePack format and return it as a vector of uint8_t\n  return nlohmann::json::to_msgpack(json_out);\n}", "CodeBleu_score": 48.96319388187232}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> result;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n\n  while (std::getline(ss, bb_name, ';')) {\n    auto subtree = _p->tree->subTree(bb_name);\n    if (subtree) {\n      std::unique_lock<std::mutex> lk(subtree->mutex());\n      if (subtree->blackboard) {\n        auto json = subtree->blackboard->toJson();\n        auto msgpack = nlohmann::json::to_msgpack(json);\n        result.insert(result.end(), msgpack.begin(), msgpack.end());\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 51.414521137481586}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  TreeNode::Ptr node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n\n  auto hook_it = _p->pre_hooks.find(node_uid);\n  if (hook_it == _p->pre_hooks.end()) {\n    return false;\n  }\n  auto hook = hook_it->second;\n  std::unique_lock<std::mutex> lk(hook->mutex);\n\n  if (hook->mode == Monitor::Hook::Mode::BREAKPOINT) {\n    hook->desired_status = result;\n    hook->remove_when_done = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n  }\n  return true;\n}", "CodeBleu_score": 76.93515941442574}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  TreeNode::Ptr node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n\n  auto hook_it = _p->pre_hooks.find(node_uid);\n  if (hook_it == _p->pre_hooks.end()) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook_it->second->mutex);\n  if (hook_it->second->mode == Monitor::Hook::Mode::BREAKPOINT) {\n    hook_it->second->desired_status = result;\n    hook_it->second->remove_when_done = remove;\n    hook_it->second->ready = true;\n    hook_it->second->wakeup.notify_all();\n  }\n  return true;\n}", "CodeBleu_score": 62.55771068251159}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    auto it = _p->nodes_by_uid.find(node_uid);\n    if (it == _p->nodes_by_uid.end()) {\n        return false;\n    }\n    TreeNode::Ptr node = it->second.lock();\n    if (!node) {\n        return false;\n    }\n\n    auto hook_it = _p->pre_hooks.find(node_uid);\n    if (hook_it == _p->pre_hooks.end()) {\n        return false;\n    }\n    std::unique_lock<std::mutex> lk(hook_it->second->mutex);\n    if (hook_it->second->mode == Monitor::Hook::Mode::BREAKPOINT) {\n        hook_it->second->desired_status = result;\n        hook_it->second->remove_when_done = remove;\n        hook_it->second->ready = true;\n        hook_it->second->wakeup.notify_all();\n    }\n    return true;\n}", "CodeBleu_score": 61.723877688190875}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    const NodeStatus prev_status = status();\n\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n\n        try {\n            std::future<NodeStatus> future = std::async(std::launch::async, [this]() {\n                try {\n                    return tick();\n                } catch (const std::exception& ex) {\n                    std::cerr << \"Exception from ThreadedAction::executeTick: \" << ex.what() << std::endl;\n                    return NodeStatus::FAILURE;\n                }\n            });\n\n            future_result_ = std::move(future);\n        } catch (const std::exception& ex) {\n            std::cerr << \"Exception from ThreadedAction::executeTick: \" << ex.what() << std::endl;\n            return NodeStatus::FAILURE;\n        }\n    }\n\n    if (future_result_.valid() &&\n        future_result_.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n        try {\n            NodeStatus status = future_result_.get();\n            if (!halt_requested_) {\n                setStatus(status);\n            }\n        } catch (const std::exception& ex) {\n            std::cerr << \"Exception from ThreadedAction::executeTick: \" << ex.what() << std::endl;\n            return NodeStatus::FAILURE;\n        }\n    }\n\n    if (halt_requested_ && status() == NodeStatus::RUNNING) {\n        halt();\n        return NodeStatus::IDLE;\n    }\n\n    return status();\n}", "CodeBleu_score": 46.74398443915472}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    const NodeStatus prev_status = status();\n\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n\n        try {\n            // Create a new thread to run the tick function\n            thread_ = std::thread(&ThreadedAction::tickThread, this);\n        } catch (const std::exception& ex) {\n            // Handle any exceptions thrown by the thread creation\n            std::cerr << \"Error creating thread: \" << ex.what() << std::endl;\n            setStatus(NodeStatus::IDLE);\n        }\n    }\n\n    // Check if the thread has completed\n    if (thread_.joinable() && thread_.get_id() != std::this_thread::get_id()) {\n        thread_.join();\n    }\n\n    // Check if an exception was stored\n    if (exception_ptr_) {\n        std::rethrow_exception(exception_ptr_);\n    }\n\n    return status();\n}", "CodeBleu_score": 43.74054008633181}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  const NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::thread(&ThreadedAction::threadFunc, this);\n  }\n\n  // check if the thread completed\n  if (thread_.joinable()) {\n    thread_.join();\n    // if halt() was invoked, we return IDLE\n    if (halt_requested_) {\n      return NodeStatus::IDLE;\n    }\n    // otherwise, we return the same status as before\n    return prev_status;\n  }\n\n  // check if an exception was stored\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n  return status();\n}", "CodeBleu_score": 35.15532472579576}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_recursively = [&stream](const TreeNode* node, int indent) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                print_recursively(child, indent + 1);\n            }\n        }\n        else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_recursively(decorator->child(), indent + 1);\n        }\n    };\n\n    stream << \"----------------\" << std::endl;\n    print_recursively(root_node, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 65.50802187478783}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_node = [](const TreeNode* node, std::ostream& stream, int indent) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n    };\n\n    auto recursivePrint = [&](const TreeNode* node, std::ostream& stream, int indent) {\n        print_node(node, stream, indent);\n\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                recursivePrint(child, stream, indent + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            if (decorator->child()) {\n                recursivePrint(decorator->child(), stream, indent + 1);\n            }\n        }\n    };\n\n    stream << \"----------------\" << std::endl;\n    recursivePrint(root_node, stream, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 65.86751053075002}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    static constexpr const char* g_whitespace = \"                         \";\n    size_t max_line_length = 100;\n\n    const auto get_indent = [](const TreeNode* node) -> std::string {\n        size_t depth = 0;\n        while (node->parent()) {\n            depth++;\n            node = node->parent();\n        }\n        size_t indent = std::min(depth, (size_t)(sizeof(g_whitespace) - 1));\n        return std::string(g_whitespace).substr(0, indent);\n    };\n\n    std::function<void(const TreeNode*)> recursive;\n    recursive = [&](const TreeNode* node) {\n        const auto& name = node->name();\n        stream << get_indent(node) << node->name() << std::endl;\n\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                recursive(child);\n            }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            recursive(decorator->child());\n        }\n    };\n\n    stream << std::endl;\n    recursive(root_node);\n    stream << std::endl;\n}", "CodeBleu_score": 51.36511104614148}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"Passing a nullptr to applyRecursiveVisitor\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 67.65560102824001}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"Passed a null node to applyRecursiveVisitor\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  }\n  else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 67.86866062730846}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"Passing a null node to applyRecursiveVisitor\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 67.66310476989513}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.count(manifest.registration_ID)) {\n        throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                    \"] already registered\");\n    }\n    _p->builders.insert({manifest.registration_ID, builder});\n    _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 65.16825662411695}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (_p->builders.count(manifest.registration_ID) != 0) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                               \"] already registered\");\n  }\n  _p->builders.insert({manifest.registration_ID, builder});\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 65.77045253541826}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  auto it = _p->builders.find(manifest.registration_ID);\n  if (it != _p->builders.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID, \"] already registered\");\n  }\n  _p->builders.insert(\n      {manifest.registration_ID, builder});  // copy is not a problem\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 85.43532447220427}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 99.74130720797476}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ID](const std::string& name, const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 96.2528774124797}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ID](const std::string& name, const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports), {}};\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 89.70228761862361}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backup;\n    backup.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        backup.push_back(subtree->blackboard->createBackup());\n    }\n    return backup;\n}", "CodeBleu_score": 60.299696364337805}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (const auto& subtree : tree.subtrees) {\n    auto bb = Blackboard::create();\n    bb->cloneInto(*(subtree->blackboard));\n    backup.emplace_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 60.528790835308286}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for(const auto& subtree : tree.subtrees) {\n    auto bb = Blackboard::create();\n    bb->cloneInto(*(subtree->blackboard));\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 61.59795827655338}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value()(env);\n}", "CodeBleu_score": 76.94056569224894}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n  return executor.value()(env);\n}", "CodeBleu_score": 75.23174261213809}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value()(env);\n}", "CodeBleu_score": 76.94056569224894}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t  std::unique_lock<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    std::string err_str = dlerror();\n    throw RuntimeError(std::string(\"Could not load library: \") + err_str);\n  }\n  _path = path;\n}", "CodeBleu_score": 64.54350096509346}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(_mutex);\n    if (_handle) {\n        throw RuntimeError(\"A library is already loaded\");\n    }\n    _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!_handle) {\n        std::string err_str = dlerror();\n        throw RuntimeError(err_str);\n    }\n    _path = path;\n}", "CodeBleu_score": 61.30278547334985}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(_mutex);\n    if (_handle) {\n        throw RuntimeError(\"Library already loaded: \" + _path);\n    }\n    _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!_handle) {\n        std::string err_str = dlerror();\n        throw RuntimeError(std::string(\"Could not load library: \") + err_str);\n    }\n    _path = path;\n}", "CodeBleu_score": 69.02640752372575}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n    str = str.stripped();\n    if (str.front() != '{' || str.back() != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = str.substr(1, str.size() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 24.39110161537776}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  const auto first_non_space = str.find_first_not_of(' ');\n  const auto last_non_space = str.find_last_not_of(' ');\n  const auto first = first_non_space == StringView::npos ? 0 : first_non_space;\n  const auto last = last_non_space == StringView::npos ? str.size() - 1 : last_non_space;\n\n  if (str[first] == '{' && str[last] == '}') {\n    if (stripped_pointer) {\n      *stripped_pointer = str.substr(first + 1, last - first - 1);\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 46.77718140364483}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if(str.size() < 3) {\n    return false;\n  }\n\n  const auto stripped = strip(str);\n  if(stripped.size() < 3) {\n    return false;\n  }\n\n  if(stripped.front() != '{' || stripped.back() != '}') {\n    return false;\n  }\n\n  if(stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 29.23556919154713}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  for(LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance())\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n    if(point_cost < 0)\n      return point_cost;\n\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 95.21480638119665}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for (LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n        point_cost = pointCost(line.getX(), line.getY()); // Assign values to variables as specified\n\n        if (point_cost < 0)\n            return point_cost;\n\n        if (line_cost < point_cost)\n            line_cost = point_cost;\n    }\n\n    return line_cost;\n}", "CodeBleu_score": 82.94574468821254}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for(LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n        point_cost = pointCost(line.getX(), line.getY()); // Assign values to variables based on the types of the elements\n        if(line_cost < point_cost) {\n            line_cost = point_cost;\n        }\n    }\n\n    return line_cost;\n}", "CodeBleu_score": 71.37249364541658}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //given an empty path so we don't do anything\n  if(path.empty())  {\n    return;\n  }\n\n  //create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for(unsigned int i=0; i < path.size(); i++){\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 95.66940002173307}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  //given an empty path we won't do anything\n  if(path.empty())\n    return;\n\n  //create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for(unsigned int i=0; i < path.size(); i++){\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 100.0}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses = path;\n  pub.publish(gui_path);\n}", "CodeBleu_score": 55.164768362233744}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n  }", "CodeBleu_score": 97.93423193356755}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n         stopped(base_odom, trans_stopped_velocity);\n}", "CodeBleu_score": 57.57429632288257}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t    return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n           fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n           fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n  }", "CodeBleu_score": 96.94779003227964}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if(setup_ && restore_defaults) {\n    config = default_limits_;\n    //if we've changed the default values at runtime, we'll need to re-set up the dsrv\n    setup_ = false;\n  }\n  if(!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  //update the local planner's limits\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 87.0162784236615}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if(setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if(!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  // update the configuration\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 89.92164574519894}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if(setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if(!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  // update dynamic_reconfigure\n  boost::mutex::scoped_lock l(configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 86.4499934603736}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t    unsigned int cell_cost = static_cast<int>(costmap.getCost(check_cell->cx, check_cell->cy));\n\n    if (cell_cost >= lethal_cost_ || cell_cost == unknown_cost_) {\n        check_cell->target_dist = obstacleCosts();\n        return false;\n    }\n\n    double new_target_dist = current_cell->target_dist + 1;\n    if (new_target_dist < check_cell->target_dist)\n        check_cell->target_dist = new_target_dist;\n    return true;\n}", "CodeBleu_score": 65.87361069608397}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = (unsigned int)costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = OBSTACLE;\n    return false;\n  }\n\n  double new_target_dist = distanceLookup(current_cell, check_cell);\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 62.062798097544324}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = (unsigned int)costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    if (display_window_) {\n      //we won't plan for this cell, so we just put it in the list as unreachable\n      grey_grid_.push_back(*check_cell);\n    }\n    return false;\n  }\n\n  //if we got here, the caller can use the cell... we need to update it\n  if (!display_window_) {\n    //update the cell and push it into the queue, if that's appropriate\n    if (!check_cell->target_mark) {\n      check_cell->target_dist = current_cell->target_dist + 1;\n      check_cell->target_mark = true;\n      bool add_to_list = true;\n      if (check_cell->seen_mark) {\n        //if we've been here before, we may have a better path\n        if (check_cell->target_dist < check_cell->seen_dist) {\n          check_cell->seen_mark = false;\n        } else {\n          add_to_list = false;\n        }\n      }\n      if (add_to_list == true) {\n        bool add_to_open = true;\n        if (open_cell_map_.find(computeIndex(check_cell->cx, check_cell->cy)) != open_cell_map_.end()) {\n          add_to_open = false;\n        }\n        if (add_to_open) {\n          open_cells_.push_back(*check_cell);\n          open_cell_map_[computeIndex(check_cell->cx, check_cell->cy)] = check_cell;\n        }\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 48.96809140359414}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double obstacle_cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (scale < 0) {\n    return -9;\n  }\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\\\"Footprint spec is empty.\\\");\n    return -9;\n  }\n\n  double px, py, pth;\n  unsigned int cell_x, cell_y;\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    traj.getPoint(i, px, py, pth);\n\n    double f_cost = footprintCost(px, py, pth);\n\n    if (f_cost < 0) {\n      return -9;\n    }\n\n    if (sum_scores_) {\n      obstacle_cost += scale*f_cost;\n    }\n    else {\n      obstacle_cost = std::max(scale*f_cost, obstacle_cost);\n    }\n  }\n  return obstacle_cost;\n}", "CodeBleu_score": 67.2452641626654}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double obstacle_cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (scale < 0) {\n    return -9;\n  }\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\\\"Footprint spec is empty.\\\");\n    return -9;\n  }\n\n  double px, py, pth;\n  unsigned int cell_x, cell_y;\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    traj.getPoint(i, px, py, pth);\n    double f_cost = footprintCost(px, py, pth);\n\n    if (f_cost < 0) {\n      return -9;\n    }\n\n    if (sum_scores_) {\n      obstacle_cost += scale*f_cost;\n    }\n    else {\n      obstacle_cost = std::max(scale*f_cost, obstacle_cost);\n    }\n  }\n  return obstacle_cost;\n}", "CodeBleu_score": 67.2452641626654}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if( odom_topic_ == \"\" ) {\n      odometry_sub_.shutdown();\n      return;\n    }\n\n    ros::NodeHandle gn;\n    odometry_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n  }\n}", "CodeBleu_score": 62.80840030333694}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if( odom_topic != odom_topic_ ) {\n        odom_topic_ = odom_topic;\n\n        if( odom_topic_ != \"\" ) {\n            ros::NodeHandle gn;\n            odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n        }\n        else {\n            if(odom_sub_) {\n                odom_sub_.shutdown();\n            }\n        }\n    }\n}", "CodeBleu_score": 68.80896218835336}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if( odom_topic_ != \"\" ) {\n      ros::NodeHandle gn;\n      odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    }\n    else {\n      if(odom_sub_) {\n        odom_sub_.shutdown();\n      }\n    }\n  }\n}", "CodeBleu_score": 71.63951872119654}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n  double sq_dist_threshold = oscillation_reset_dist_ * oscillation_reset_dist_;\n  double angle_threshold = oscillation_reset_angle_ * oscillation_reset_angle_;\n  if (sq_dist <= sq_dist_threshold) {\n    Eigen::Vector3f delta = pos - prev;\n    double sq_ang_dist = delta.head(2).squaredNorm();\n    if (sq_ang_dist <= angle_threshold) {\n      forward_pos_only_ = forward_neg_only_ = strafe_pos_only_ = strafe_neg_only_ = rot_pos_only_ = rot_neg_only_ = false;\n    }\n  }\n}", "CodeBleu_score": 38.47547228013674}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n  double sq_rot_dist = fabs(angles::shortest_angular_distance(tf2::getYaw(pos.z()), tf2::getYaw(prev.z())));\n  //if we've moved far enough\n  if(sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_){\n    resetOscillationFlags();\n    return;\n  }\n  //if we've turned far enough\n  if(sq_rot_dist > oscillation_reset_angle_){\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 44.25888930393227}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  //if the squared distance between the current position and previous position is\n  //greater than the oscillation_reset_dist_ (squared), reset oscillation flags\n  if(sq_dist > oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n    return;\n  }\n\n  //calculate the angular difference between the current and previous positions\n  double angle = atan2(pos[1] - prev[1], pos[0] - prev[0]);\n\n  //if the angular difference is greater than the oscillation_reset_angle_, reset oscillation flags\n  if(fabs(angle - prev_stationary_pos_angle_) > oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 53.548362442500874}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  //if the grid coordinates are outside the bounds of the grid... return\n  if(!gridCoords(pt, gx, gy))\n    return;\n\n  //get the associated index\n  unsigned int index = gridIndex(gx, gy);\n\n  //check to see if the point is too close to its nearest neighbor\n  if(nearest(pt, 2) < resolution_)\n    return;\n\n  //insert the point into the cell\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 78.41831235896952}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  //if the grid coordinates are outside the bounds of the grid... return\n  if(!gridCoords(pt, gx, gy))\n    return;\n\n  //get the associated index\n  unsigned int index = gridIndex(gx, gy);\n\n  //check to see if the point is too close to its neighbors\n  if(nearestNeighbor(pt, index) <= sq_cell_size_ / 2.0)\n    return;\n\n  //insert the point into the cell\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 79.21399672543615}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n  if(!gridCoords(pt, gx, gy))\n    return;\n\n  //get the index of the cell\n  unsigned int index = gridIndex(gx, gy);\n\n  //check if the point is too close to its nearest neighbor\n  if(nearestNeighbor(pt, index) < min_dist_)\n    return;\n\n  //insert the point into the grid\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 79.45149315519373}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (vel[i] < sample_target_vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 99.8359832745465}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (vel[i] < sample_target_vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 99.8359832745465}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (vel[i] < sample_target_vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 99.8359832745465}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double heading_diff = DBL_MAX;\n  double goal_x, goal_y;\n  unsigned int mx, my;\n\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    costmap_.mapToWorld(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, goal_x, goal_y);\n    if (costmap_.worldToMap(goal_x, goal_y, mx, my)) {\n      if (lineCost(cell_x, cell_y, mx, my) < 0) {\n        heading_diff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n        break;\n      }\n    }\n  }\n\n  return heading_diff;\n}", "CodeBleu_score": 70.53057889893259}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double heading_diff = DBL_MAX;\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    double gx = global_plan_[i].pose.position.x;\n    double gy = global_plan_[i].pose.position.y;\n    double gth = 0.0;\n    if (i > 0) {\n      gth = atan2(gy - global_plan_[i - 1].pose.position.y, gx - global_plan_[i - 1].pose.position.x);\n    }\n    double dx = gx - x;\n    double dy = gy - y;\n    double d = sqrt(dx * dx + dy * dy);\n    double th = atan2(dy, dx);\n    double heading_to_point = fabs(gth - th);\n    if (fabs(d) <= pdist_scale_ * costmap_.getResolution()) {\n      heading_diff = fabs(gth - heading);\n      break;\n    } else if (fabs(heading_to_point) <= heading_lookahead_) {\n      heading_diff = fabs(gth - heading);\n      break;\n    }\n  }\n  return heading_diff;\n}", "CodeBleu_score": 51.52843743593394}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n    double vx_samp_scaled = vx_samp;\n    double vy_samp_scaled = vy_samp;\n    double vtheta_samp_scaled = vtheta_samp;\n\n    vx_samp_scaled = std::max(min_vel_x_, std::min(max_vel_x_, vx_samp_scaled));\n    vy_samp_scaled = std::max(min_vel_y_, std::min(max_vel_y_, vy_samp_scaled));\n    vtheta_samp_scaled = std::max(min_vel_theta_, std::min(max_vel_theta_, vtheta_samp_scaled));\n\n    if (vx_samp == 0 && vtheta_samp == 0) {\n      // ROS_DEBUG(\"vx_samp and vtheta_samp is 0, this is not a valid trajectory.\");\n      return false;\n    }\n\n    Trajectory traj;\n    generateTrajectory(x, y, theta, vx, vy, vtheta, vx_samp_scaled, vy_samp_scaled, vtheta_samp_scaled, traj);\n\n    //if the trajectory hits an obstacle, we don't want it\n    if (traj.cost_ < 0) {\n      // ROS_DEBUG(\"The trajectory %f, %f, %f, %f, %f, %f hits an obstacle, invalid.\", vx_samp, vy_samp, vtheta_samp, vx, vy, vtheta);\n      return false;\n    }\n\n    // the point_cost function computes the cost based on the distance from the global_plan\n    if (traj.cost_ >= 0) {\n      //if the trajectory is a legal one... the check passes\n      return true;\n    }\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, traj.cost_);\n    return false;\n  }", "CodeBleu_score": 62.308931237846686}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    Trajectory traj;\n    traj.xv_ = vx;\n    traj.yv_ = vy;\n    traj.thetav_ = vtheta;\n\n    Trajectory::create_trajectory(x, y, theta, vx_samp, vy_samp, vtheta_samp, traj);\n\n    if (scored_sampling_){\n      traj.score_ = scoreTrajectory(traj, -1);\n    } else {\n      traj.score_ = scoreTrajectory(traj);\n    }\n\n    //if the trajectory is a legal one... the check passes\n    if(traj.score_ >= 0){\n      return true;\n    }\n    //otherwise... it is invalid...\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, traj.score_);\n    return false;\n  }", "CodeBleu_score": 61.71202959927593}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if(!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s to unstuck robot\", affected_maps_.c_str(), affected_maps_ == \"both\" ? \"s\" : \"\");\n  if (invert_area_to_clear_)\n    ROS_WARN(\"In inverted clearing option; clearing area until distance %f to the nearest obstacle\", reset_distance_);\n\n  if (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n    clear(global_costmap_);\n  }\n\n  if (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n    clear(local_costmap_);\n  }\n}", "CodeBleu_score": 49.407253028672}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if(!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the specified area.\");\n  } else {\n    ROS_WARN(\"Clearing outside the specified area.\");\n  }\n\n  ros::WallTime start_time = ros::WallTime::now();\n\n  if (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n    clear(global_costmap_);\n  }\n\n  if (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n    clear(local_costmap_);\n  }\n\n  ROS_DEBUG(\"[ClearCostmapRecovery] Clearing took %f seconds\", (ros::WallTime::now() - start_time).toSec());\n}", "CodeBleu_score": 53.91198822830711}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells cell_gatherer(*this, polygon, polygon_cells);\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n\t}\n\tif (!polygon.empty()) {\n\t\tunsigned int last_index = polygon.size() - 1;\n\t\t// we also need to close the polygon\n\t\traytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n\t}\n}", "CodeBleu_score": 95.5538637061164}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    PolygonOutlineCells cell_gatherer(*this, polygon, polygon_cells);\n\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon by going from the last point to the first\n        raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n}", "CodeBleu_score": 96.562593698748}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    PolygonOutlineCells cell_gatherer(*this);\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon by going from the last point to the first\n        raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n\n    polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 92.10207300456341}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    grid_.data[i] = cost_translation_table_[data[i]];\n  }\n}", "CodeBleu_score": 88.4161668348603}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t    boost::unique_lock < boost::recursive_mutex > lock(*costmap_->getMutex());\n    double resolution = costmap_->getResolution();\n\n    grid_.header.frame_id = global_frame_;\n    grid_.header.stamp = ros::Time::now();\n    grid_.info.resolution = resolution;\n\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    double wx, wy;\n    costmap_->mapToWorld(0, 0, wx, wy);\n    grid_.info.origin.position.x = wx - resolution / 2;\n    grid_.info.origin.position.y = wy - resolution / 2;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    unsigned char* data = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); i++) {\n        grid_.data[i] = cost_translation_table_[data[i]];\n    }\n}", "CodeBleu_score": 88.67708239526017}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    grid_.data[i] = cost_translation_table_[data[i]];\n  }\n}", "CodeBleu_score": 88.26039325191954}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    if (new_config.footprint == old_config.footprint)\n        return;\n\n    std::vector<geometry_msgs::Point> footprint_spec;\n    if (new_config.footprint == \"\") {\n        // no footprint parameter given, delete the old one\n        unpadded_footprint_ = padded_footprint_ = std::vector<geometry_msgs::Point>();\n        return;\n    }\n    if (makeFootprintFromString(new_config.footprint, footprint_spec)) {\n        setUnpaddedRobotFootprint(footprint_spec);\n    } else {\n        ROS_ERROR(\"The footprint parameter does not take a valid value.  Footprint will be set to circumscribed radius.\");\n    }\n}", "CodeBleu_score": 52.53102970043352}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint != old_config.footprint) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint))\n      setUnpaddedRobotFootprint(new_footprint);\n  }\n}", "CodeBleu_score": 35.83017521456922}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    if (new_config.footprint == old_config.footprint)\n        return;\n\n    std::vector<geometry_msgs::Point> footprint_spec;\n    if (new_config.footprint == \"\") {\n        footprint_spec = makeFootprintFromRadius(new_config.robot_radius);\n    } else {\n        std::string error;\n        if (makeFootprintFromString(new_config.footprint, footprint_spec, error)) {\n            setUnpaddedRobotFootprint(footprint_spec);\n        } else {\n            ROS_ERROR(\"Invalid footprint parameter: %s\", error.c_str());\n        }\n    }\n}", "CodeBleu_score": 57.83388214982237}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    // get the current pose of the robot\n    geometry_msgs::PoseStamped new_pose;\n    if (!getRobotPose(new_pose)) {\n        ROS_WARN(\"[Costmap2DROS] Could not get robot pose\");\n        return;\n    }\n\n    // check if the robot has moved\n    if (fabs((old_pose_.pose.position.x - new_pose.pose.position.x) < resolution_ * 0.05) &&\n        fabs((old_pose_.pose.position.y - new_pose.pose.position.y) < resolution_ * 0.05) &&\n        fabs((tf2::getYaw(old_pose_.pose.orientation) - tf2::getYaw(new_pose.pose.orientation)) < resolution_ * 0.05)) {\n        return;\n    }\n\n    // update the old pose\n    old_pose_ = new_pose;\n\n    // reset the map update flag\n    map_update_flag_ = true;\n}", "CodeBleu_score": 57.16357771986722}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  // get robot pose in the costmap frame\n  geometry_msgs::PoseStamped new_pose;\n  if (getRobotPose(new_pose)) {\n    // update the old_pose_ pointer to be the current pose\n    old_pose_ = new_pose;\n    // call the updateMap method to update the costmap based on the robot's movement\n    updateMap(new_pose.pose.position.x, new_pose.pose.position.y);\n  } else {\n    // if the robot pose cannot be retrieved, log a warning message and cancel reconfiguration\n    ROS_WARN(\"[Costmap2DROS] Could not get robot pose\");\n    cancelReconfigure();\n  }\n}", "CodeBleu_score": 57.87021022777936}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  tf::Stamped<tf::Pose> new_pose;\n  if (getRobotPose(new_pose)) {\n    double x = new_pose.getOrigin().x(), y = new_pose.getOrigin().y(),\n        theta = tf::getYaw(new_pose.getRotation());\n    if (fabs(old_pose_.getOrigin().x() - x) < 0.0001 &&\n        fabs(old_pose_.getOrigin().y() - y) < 0.0001 &&\n        fabs(old_pose_.getRotation().z() - theta) < 0.0001) {\n      // Nothing changed, so do nothing\n      return;\n    }\n    old_pose_ = new_pose;\n    // TODO: this should be a subscription, not a service call\n    clearRobotFootprint();\n    return;\n  } else {\n    ROS_WARN(\"[Costmap2DROS] Could not get robot pose\");\n  }\n}", "CodeBleu_score": 45.337211744744174}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  // check if we're stopped or just not initialized\n  if (stopped_) {\n    // we're stopped, so reactivate our subscribers\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end();\n        ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n\n  // block until the costmap is reinitialized.. meaning one update has run and sent the old data\n  ROS_INFO(\"Waiting for move_base to get robot pose\");\n  ros::Rate r(100);\n  ros::NodeHandle private_nh(\"~/\" + name_);\n  if (!initialized_) {\n    ros::spinOnce();\n    r.sleep();\n  }\n\n  // now we're initialized\n  initialized_ = true;\n\n  ROS_INFO(\"Starting costmap\");\n\n  // start the update thread to collect and update the costmap\n  stop_updates_ = false;\n  map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, 1.0 / update_frequency_));\n}", "CodeBleu_score": 60.05011806896003}, {"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n\n  // block until the costmap is reinitialized.. meaning one update has run and published.\n  ROS_INFO(\"Waiting for move_base/global_costmap/costmap to become ready\");\n  ros::Rate r(100);\n  ros::NodeHandle n;\n  while (n.ok() && !initialized_) {\n    r.sleep();\n  }\n\n  // now we'll wait for the map update thread to launch\n  ROS_INFO(\"Waiting for update thread to launch\");\n  while (n.ok() && !map_update_thread_) {\n    r.sleep();\n  }\n}", "CodeBleu_score": 61.432994189892256}, {"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n\n  // block until the costmap is reinitialized.. meaning one update cycle has run\n  ROS_INFO(\"Waiting for move_base to get robot pose\");\n  ros::NodeHandle n;\n  ros::Rate r(100);\n  if (global_frame_.empty()) {\n    ROS_ERROR(\"The global frame must not be empty. It can be set using the <global_frame> parameter.\");\n    return;\n  }\n  tf2_ros::Buffer tf_buffer(ros::Duration(10));\n  tf2_ros::TransformListener tf(tf_buffer);\n  while (ros::ok() && !tf_buffer.canTransform(global_frame_, \"base_link\", ros::Time(), ros::Duration(0.1))) {\n    ros::spinOnce();\n    r.sleep();\n  }\n\n  map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, 1.0 / update_frequency_));\n}", "CodeBleu_score": 55.710471193437925}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_ == ros::Duration(0.0)) {\n        // keep only the most recent observation\n        if (observation_list_.size() > 1) {\n            observation_list_.erase(++observation_list_.begin(), observation_list_.end());\n        }\n    } else {\n        ros::Time now = ros::Time::now();\n        list<Observation>::iterator obs_it = observation_list_.begin();\n        while (obs_it != observation_list_.end()) {\n            if ((now - obs_it->cloud_->header.stamp) > observation_keep_time_) {\n                // this observation is stale\n                obs_it = observation_list_.erase(obs_it);\n            } else {\n                // this observation is fresh enough\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 57.365715487083335}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_ == 0) {\n        if (observation_list_.size() > 0) {\n            observation_list_.resize(1);\n        }\n        return;\n    }\n\n    list<Observation>::iterator obs_it = observation_list_.begin();\n    while (obs_it != observation_list_.end()) {\n        if ((last_updated_ - obs_it->cloud_->header.stamp) > observation_keep_time_) {\n            obs_it = observation_list_.erase(obs_it);\n        } else {\n            break;\n        }\n    }\n}", "CodeBleu_score": 47.379777416040895}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 0) {\n      observation_list_.resize(1);\n    }\n    return;\n  }\n\n  ros::Time now = ros::Time::now();\n  list<Observation>::iterator obs_it = observation_list_.begin();\n  while (obs_it != observation_list_.end()) {\n    if ((now - obs_it->cloud_->header.stamp) > observation_keep_time_) {\n      obs_it = observation_list_.erase(obs_it);\n    } else {\n      ++obs_it;\n    }\n  }\n}", "CodeBleu_score": 52.97636694350412}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    double start_yaw, end_yaw, inc_yaw, current_yaw;\n    int i;\n\n    start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n    inc_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    for (i = start_index; i <= end_index; i++) {\n        current_yaw = start_yaw + inc_yaw * (i - start_index) / (end_index - start_index);\n        set_angle(&path[i], current_yaw);\n    }\n}", "CodeBleu_score": 58.444852482098874}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n  double increment = diff / (end_index - start_index);\n\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 75.88410405237032}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n    double diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n    double increment = diff / (end_index - start_index);\n\n    for (int i = start_index; i <= end_index; i++) {\n        double angle = start_yaw + increment * (i - start_index);\n        set_angle(&path[i], angle);\n    }\n}", "CodeBleu_score": 79.9037722396049}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    rm::PoseStamped start = req.start;\n    rm::PoseStamped goal = req.goal;\n\n    start.header.frame_id = \\\"map\\\";\n    goal.header.frame_id = \\\"map\\\";\n\n    vector<PoseStamped> path;\n    if (makePlan(start, goal, path)) {\n        resp.plan_found = true;\n        resp.path = path;\n    } else {\n        resp.plan_found = false;\n    }\n\n    return true;\n}", "CodeBleu_score": 56.141235123660806}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    rm::PoseStamped start;\n    start.header.frame_id = \\\"map\\\";\n    start.header.stamp = ros::Time::now();\n    start.pose = req.start;\n\n    rm::PoseStamped goal;\n    goal.header.frame_id = \\\"map\\\";\n    goal.header.stamp = ros::Time::now();\n    goal.pose = req.goal;\n\n    vector<PoseStamped> plan;\n    bool success = makePlan(start, goal, plan);\n    resp.plan_found = success;\n    if (success) {\n        resp.path = plan;\n    }\n    return true;\n}", "CodeBleu_score": 60.523214293998706}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    rm::PoseStamped start;\n    start.header.frame_id = \\\"map\\\";\n    start.header.stamp = ros::Time::now();\n    start.pose = req.start;\n\n    rm::PoseStamped goal;\n    goal.header.frame_id = \\\"map\\\";\n    goal.header.stamp = ros::Time::now();\n    goal.pose = req.goal;\n\n    vector<PoseStamped> plan;\n    bool success = makePlan(start, goal, plan);\n    resp.plan_found = success;\n    if (success) {\n        resp.path = plan;\n    }\n    return true;\n}", "CodeBleu_score": 60.523214293998706}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n    ros::NodeHandle private_nh(\\\"~/\\\" + name);\n    cmap_ = cmap;\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe<rm::PoseStamped>(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 63.41155203288476}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\\\"~\\\");\n    cmap_ = cmap;\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 62.7710090372423}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n    ros::NodeHandle private_nh(\\\"~/\\\" + name);\n    cmap_ = cmap;\n\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe<rm::PoseStamped>(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 63.41155203288476}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n        return false;\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n        return true;\n\n    return false;\n}", "CodeBleu_score": 59.833301875601855}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (costmap_ == NULL)\n        return false;\n\n    wx = wx - costmap_->getOriginX();\n    wy = wy - costmap_->getOriginY();\n\n    double scale = costmap_->getResolution();\n    mx = wx / scale;\n    my = wy / scale;\n\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n        return true;\n\n    return false;\n}", "CodeBleu_score": 57.233493649710745}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n        return false;\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n        return true;\n\n    return false;\n}", "CodeBleu_score": 59.833301875601855}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 89.92337079722196}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 89.92337079722196}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 99.82945959233214}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\",\"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n  }", "CodeBleu_score": 98.80792016647686}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n  }", "CodeBleu_score": 87.43909463093408}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 87.40002289273339}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() >= limited_distance_ * limited_distance_) {\n    ROS_INFO(\"Move slow and clear recovery behavior has moved the robot far enough, stopping limiting the speed of the robot.\");\n    if (remove_limit_thread_ != NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 77.26170675433197}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > limited_distance_ * limited_distance_) {\n    ROS_INFO(\"Moved far enough, stopping speed limit\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 79.44723607277079}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    if (getSqDistance() >= limited_distance_ * limited_distance_) {\n        ROS_WARN(\"Move slow and clear recovery behavior has moved the robot far enough\");\n        boost::mutex::scoped_lock l(mutex_);\n        if (remove_limit_thread_) {\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n            remove_limit_thread_ = NULL;\n        }\n        remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n        distance_check_timer_.stop();\n    }\n}", "CodeBleu_score": 71.90287224786768}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  tf2_ros::Buffer tfBuffer;\n  tf2_ros::TransformListener tfListener(tfBuffer);\n  geometry_msgs::PoseStamped robot_pose;\n  if (!tfBuffer.canTransform(\"map\", \"base_link\", ros::Time(0), ros::Duration(1.0))) {\n    ROS_WARN(\"Cannot transform from map to base_link\");\n    return;\n  }\n  try {\n    robot_pose = tfBuffer.transform(rm::PoseStamped(), \"map\", ros::Duration(1.0));\n  } catch (tf2::TransformException& ex) {\n    ROS_WARN(\"%s\", ex.what());\n    return;\n  }\n\n  vector<PoseStamped> path;\n  rm::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.pose = robot_pose.pose;\n  bool success = makePlan(start, *goal, path);\n\n  if (success) {\n    plan_pub_.publish(path);\n  }\n}", "CodeBleu_score": 51.939222346840516}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  tf2_ros::Buffer tfBuffer;\n  tf2_ros::TransformListener tfListener(tfBuffer);\n\n  // Get the current pose of the robot\n  geometry_msgs::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.header.stamp = ros::Time::now();\n  start.pose.position.x = cmap_->getRobotPose().getOrigin().x();\n  start.pose.position.y = cmap_->getRobotPose().getOrigin().y();\n  start.pose.orientation.w = 1.0;\n\n  // Set the goal pose\n  rm::PoseStamped goal_pose;\n  goal_pose.header.frame_id = \"map\";\n  goal_pose.header.stamp = ros::Time::now();\n  goal_pose.pose.position.x = goal->pose.position.x;\n  goal_pose.pose.position.y = goal->pose.position.y;\n  goal_pose.pose.orientation.w = 1.0;\n\n  // Generate a path from the current pose to the goal pose\n  vector<PoseStamped> path;\n  bool success = makePlan(start, goal_pose, path);\n\n  // Publish the path\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = \"map\";\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses = path;\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 48.14036569180743}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 9.194105522934656}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 70.01936124391204}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 70.01936124391204}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    mavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.real = param_set.value;\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 70.01936124391204}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    int sockfd, connfd;\n    struct sockaddr_in servaddr, cliaddr;\n    socklen_t clilen = sizeof(cliaddr);\n    char buf[MAXLINE];\n    int n;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        ROS_ERROR(\"socket error\");\n        return;\n    }\n\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port = htons(this->TCP_PORT);\n\n    if (bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {\n        ROS_ERROR(\"bind error\");\n        return;\n    }\n\n    if (listen(sockfd, 10) < 0) {\n        ROS_ERROR(\"listen error\");\n        return;\n    }\n\n    while (true) {\n        connfd = accept(sockfd, (struct sockaddr *)&cliaddr, &clilen);\n        if (connfd < 0) {\n            ROS_ERROR(\"accept error\");\n            return;\n        }\n\n        while (true) {\n            n = recv(connfd, buf, MAXLINE, 0);\n            if (n > 0) {\n                // ROS_INFO(\"Received message: %s\", buf);\n                this->decode(buf, n);\n            } else if (n == 0) {\n                ROS_ERROR(\"Connection closed by client\");\n                close(connfd);\n                break;\n            } else {\n                ROS_ERROR(\"recv error\");\n                close(connfd);\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}", "CodeBleu_score": 51.31322881600232}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t    int sockfd, connfd;\n    struct sockaddr_in servaddr, cliaddr;\n    socklen_t len;\n    char buffer[MAXLINE];\n    int n;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        ROS_ERROR(\"socket error\");\n        return;\n    }\n\n    bzero(&servaddr, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port = htons(TCP_PORT);\n\n    int opt = 1;\n    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void*)&opt, sizeof(opt));\n\n    if (bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0) {\n        ROS_ERROR(\"bind error\");\n        return;\n    }\n\n    if (listen(sockfd, 5) < 0) {\n        ROS_ERROR(\"listen error\");\n        return;\n    }\n\n    while (true) {\n        len = sizeof(cliaddr);\n        connfd = accept(sockfd, (struct sockaddr*)&cliaddr, &len);\n        if (connfd < 0) {\n            ROS_ERROR(\"accept error\");\n            continue;\n        }\n\n        while (true) {\n            n = recv(connfd, buffer, MAXLINE, 0);\n            if (n <= 0) {\n                ROS_ERROR(\"recv error\");\n                break;\n            }\n\n            if (this->is_simulation_) {\n                this->decodeMessage(buffer, n);\n            }\n        }\n\n        close(connfd);\n    }\n\n    close(sockfd);\n}", "CodeBleu_score": 52.50710080990682}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->is_simulation_) {\n        // \u4eff\u771f\u6a21\u5f0f\u4e0b\n        if (this->swarm_control_simulation_ != NULL) {\n            // \u627e\u5230\u5bf9\u5e94\u7684\u65e0\u4eba\u673a\n            this->swarm_control_simulation_->updateSingleUAVCommand(uav_cmd);\n            this->swarm_control_simulation_->singleUAVCommandPub(this->swarm_control_simulation_->getSingleUAVCommand(uav_cmd.drone_id));\n        }\n    } else {\n        // \u975e\u4eff\u771f\u6a21\u5f0f\u4e0b\n        if (this->uav_basic_ != NULL) {\n            this->uav_basic_->updateUAVCommand(uav_cmd);\n            this->uav_basic_->uavCommandPub(this->uav_basic_->getUAVCommand());\n        }\n    }\n}", "CodeBleu_score": 42.91300532114556}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->is_simulation_) {\n        // \u6a21\u62df\u6a21\u5f0f\n        // \u901a\u8fc7ID\u627e\u5230\u5bf9\u5e94\u7684UAV\n        this->swarm_control_simulation_->updateSingleUAVCommand(uav_cmd);\n        this->swarm_control_simulation_->singleUAVCommandPub(this->swarm_control_simulation_->getSingleUAVCommand(uav_cmd.drone_id));\n    } else {\n        // \u975e\u6a21\u62df\u6a21\u5f0f\n        // \u53d1\u5e03\u5230\u5355\u4e2aUAV\n        this->uav_basic_->updateSingleUAVCommand(uav_cmd);\n        this->uav_basic_->singleUAVCommandPub(this->uav_basic_->getSingleUAVCommand());\n    }\n}", "CodeBleu_score": 40.54575961857994}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->is_simulation_) {\n        if (this->swarm_control_simulation_ != NULL) {\n            this->swarm_control_simulation_->updateUAVCommand(uav_cmd);\n            this->swarm_control_simulation_->pubUAVCommand(uav_cmd.uav_id);\n        }\n    } else {\n        if (this->uav_basic_ != NULL) {\n            this->uav_basic_->updateUAVCommand(uav_cmd);\n            this->uav_basic_->pubUAVCommand();\n        }\n    }\n}", "CodeBleu_score": 40.86147774741906}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == ModeSelection::UseMode::REBOOTNX) {\n        system(\"sudo reboot\");\n    } else if (mode_selection.use_mode == ModeSelection::UseMode::EXITNX) {\n        system(\"sudo poweroff\");\n    } else if (mode_selection.use_mode == ModeSelection::UseMode::CREATEMODE) {\n        createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == ModeSelection::UseMode::DELETEMODE) {\n        deleteMode(mode_selection.mode_name);\n    }\n}", "CodeBleu_score": 63.23997587029033}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    // \u6a21\u5f0f\u5207\u6362\n    if (mode_selection.use_mode == ModeSelection::UseMode::REBOOTNX) {\n        std::cout << \"REBOOTNX\" << std::endl;\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == ModeSelection::UseMode::EXITNX) {\n        std::cout << \"EXITNX\" << std::endl;\n        system(\"exit\");\n    }\n\n    if (mode_selection.use_mode == ModeSelection::UseMode::CREATEMODE) {\n        createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == ModeSelection::UseMode::DELETEMODE) {\n        deleteMode(mode_selection.mode_name);\n    }\n}", "CodeBleu_score": 62.40567020182277}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == ModeSelection::REBOOTNX) {\n        // std::cout << \\\"reboot\\\" << std::endl;\n\n        system(\\\"reboot\\\");\n    } else if (mode_selection.use_mode == ModeSelection::EXITNX) {\n        system(\\\"exit\\\");\n    } else if (mode_selection.use_mode == ModeSelection::CREATEMODE) {\n        createMode(mode_selection);\n    } else if (mode_selection.use_mode == ModeSelection::DELETEMODE) {\n        deleteMode(mode_selection);\n    }\n}", "CodeBleu_score": 68.07021183350808}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    int drone_id = msg->drone_id;\n    std::vector<Bspline> trajs;\n    for (int i = 0; i < msg->traj_num; i++) {\n        Bspline bspline;\n        bspline.order = msg->trajs[i].order;\n        bspline.control_points = msg->trajs[i].control_points;\n        bspline.knots = msg->trajs[i].knots;\n        bspline.knots_num = msg->trajs[i].knots_num;\n        bspline.duration = msg->trajs[i].duration;\n        bspline.position_num = msg->trajs[i].position_num;\n        bspline.position_pts = msg->trajs[i].position_pts;\n        bspline.yaw_num = msg->trajs[i].yaw_num;\n        bspline.yaw_pts = msg->trajs[i].yaw_pts;\n        trajs.push_back(bspline);\n    }\n    std::string encoded_data = encodeMultiBsplines(drone_id, trajs);\n    communication->tcp_send(encoded_data, tcp_ip_);\n}", "CodeBleu_score": 47.33204077606717}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    int drone_id = msg->drone_id;\n    std::vector<prometheus_msgs::Bspline> traj = msg->trajectory;\n\n    // Initialize a vector to store the Bspline structs\n    std::vector<Bspline> bsplines;\n\n    // Iterate through each trajectory in the MultiBsplines message\n    for (int i = 0; i < traj.size(); i++) {\n        // Create a new Bspline struct\n        Bspline bspline;\n\n        // Set the attributes of the Bspline struct\n        bspline.order = traj[i].order;\n        bspline.duration = traj[i].duration;\n        bspline.knots = traj[i].knots;\n        bspline.position_pts = traj[i].position_pts;\n        bspline.yaw_pts = traj[i].yaw_pts;\n\n        // Add the Bspline struct to the vector\n        bsplines.push_back(bspline);\n    }\n\n    // Encode the MultiBsplines data\n    std::vector<uint8_t> encoded_data = encode_multi_bsplines(drone_id, bsplines);\n\n    // Send the encoded data via TCP using the communication module\n    communication->send_data_via_tcp(encoded_data, tcp_ip_, 10001);\n}", "CodeBleu_score": 30.989012497841028}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    int drone_id = msg->drone_id;\n    int traj_num = msg->trajectory_num;\n    int traj_order = msg->trajectory_order;\n    int traj_piece_num = msg->trajectory_piece_num;\n    int knots_num = msg->knots_num;\n    int points_num = msg->points_num;\n    int yaw_num = msg->yaw_num;\n\n    std::vector<Bspline> traj_list;\n    traj_list.resize(traj_num);\n\n    for (int i = 0; i < traj_num; i++) {\n        Bspline &traj = traj_list[i];\n\n        traj.order = traj_order;\n        traj.knots_num = knots_num;\n        traj.points_num = points_num;\n        traj.yaw_num = yaw_num;\n\n        traj.knots.resize(knots_num);\n        for (int j = 0; j < knots_num; j++) {\n            traj.knots[j] = msg->knots[i * knots_num + j];\n        }\n\n        traj.points.resize(points_num);\n        for (int j = 0; j < points_num; j++) {\n            traj.points[j] = msg->points[i * points_num + j];\n        }\n\n        traj.yaw.resize(yaw_num);\n        for (int j = 0; j < yaw_num; j++) {\n            traj.yaw[j] = msg->yaw[i * yaw_num + j];\n        }\n    }\n\n    communication->encodeMultiBsplines(drone_id, traj_list, traj_piece_num);\n}", "CodeBleu_score": 43.35652211506974}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);  // Set the resolution of the octree\n    std::stringstream compressed_data;\n    octree.encodePointCloud(cloud, compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.str().size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"compressed_data\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    compressed_msg.fields[0].count = compressed_data.str().size();\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = compressed_data.str().size();\n    compressed_msg.row_step = compressed_data.str().size();\n    compressed_msg.is_dense = true;\n    compressed_msg.data.resize(compressed_data.str().size());\n    memcpy(&compressed_msg.data[0], compressed_data.str().c_str(), compressed_data.str().size());\n\n    return compressed_msg;\n}", "CodeBleu_score": 47.09638228834439}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create an octree compression object\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ> compressor(0.01);\n\n    // Compress the point cloud\n    std::stringstream compressed_data;\n    compressor.encodePointCloud(cloud, compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.str().size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"compressed_data\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    compressed_msg.fields[0].count = compressed_msg.width;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = compressed_msg.width;\n    compressed_msg.row_step = compressed_msg.width;\n    compressed_msg.data.resize(compressed_msg.width);\n    memcpy(&compressed_msg.data[0], compressed_data.str().c_str(), compressed_msg.width);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    return compressed_msg;\n}", "CodeBleu_score": 46.241956236374854}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // \u521b\u5efa\u4e00\u4e2a\u516b\u53c9\u6811\u538b\u7f29\u5bf9\u8c61\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(1.0f);\n\n    // \u8bbe\u7f6e\u8f93\u5165\u70b9\u4e91\n    octree.setInputCloud(cloud);\n\n    // \u6267\u884c\u538b\u7f29\u64cd\u4f5c\n    octree.addPointsFromInputCloud();\n\n    // \u83b7\u53d6\u538b\u7f29\u540e\u7684\u6570\u636e\n    std::vector<unsigned char> compressed_data;\n    octree.serializeCompressedData(compressed_data);\n\n    // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684 PointCloud2 \u6d88\u606f\uff0c\u5e76\u8bbe\u7f6e\u5176\u6570\u636e\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"compressed_data\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    compressed_msg.fields[0].count = 1;\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = sizeof(unsigned char);\n    compressed_msg.row_step = compressed_msg.width * compressed_msg.point_step;\n    compressed_msg.data.resize(compressed_msg.row_step);\n    std::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.row_step);\n\n    // \u91ca\u653e\u52a8\u6001\u5206\u914d\u7684\u5185\u5b58\n    cloud.reset();\n\n    return compressed_msg;\n}", "CodeBleu_score": 49.98271124400333}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 96.75999708297736}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = this->multi_uav_state_.uav_state_all.begin(); it != this->multi_uav_state_.uav_state_all.end(); it++) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 61.77830180090449}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto &uav : multi_uav_state_.uav_state_all) {\n        if (uav.uav_id == uav_state.uav_id) {\n            uav = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 41.84391967924156}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    prometheus_msgs::MultiUGVState multi_ugv_state;\n    multi_ugv_state.ugv_num = 0;\n\n    for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n        prometheus_msgs::UGVState ugv_state;\n        ugv_state.ugv_id = (*it).ugv_id;\n        ugv_state.battery_state = (*it).battery_state;\n        ugv_state.battery_percetage = (*it).battery_percetage;\n        for (int i = 0; i < 3; i++) {\n            ugv_state.position[i] = (*it).position[i];\n            ugv_state.velocity[i] = (*it).velocity[i];\n            ugv_state.attitude[i] = (*it).attitude[i];\n            ugv_state.attitude_rate[i] = (*it).attitude_rate[i];\n        };\n        ugv_state.attitude_q.x = (*it).attitude_q.x;\n        ugv_state.attitude_q.y = (*it).attitude_q.y;\n        ugv_state.attitude_q.z = (*it).attitude_q.z;\n        ugv_state.attitude_q.w = (*it).attitude_q.w;\n\n        multi_ugv_state.ugv_num++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n\n    // \u53d1\u5e03\u8bdd\u9898\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 90.65088777104262}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    prometheus_msgs::MultiUGVState multi_ugv_state;\n    multi_ugv_state.ugv_num = 0;\n\n    for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n        prometheus_msgs::UGVState ugv_state;\n        ugv_state.ugv_id = (*it).ugv_id;\n        ugv_state.battery = (*it).battery;\n        for (int i = 0; i < 3; i++) {\n            ugv_state.position[i] = (*it).position[i];\n            ugv_state.velocity[i] = (*it).velocity[i];\n            ugv_state.attitude[i] = (*it).attitude[i];\n        }\n        ugv_state.attitude_q.x = (*it).attitude_q.x;\n        ugv_state.attitude_q.y = (*it).attitude_q.y;\n        ugv_state.attitude_q.z = (*it).attitude_q.z;\n        ugv_state.attitude_q.w = (*it).attitude_q.w;\n\n        multi_ugv_state.ugv_num++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n\n    // \u53d1\u5e03\u8bdd\u9898\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 94.44055223394284}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    prometheus_msgs::MultiUGVState multi_ugv_state;\n    multi_ugv_state.ugv_num = 0;\n\n    for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n        prometheus_msgs::UGVState ugv_state;\n        ugv_state.ugv_id = (*it).ugv_id;\n        ugv_state.battery_state = (*it).battery_state;\n        ugv_state.battery_percetage = (*it).battery_percetage;\n        for (int i = 0; i < 3; i++) {\n            ugv_state.position[i] = (*it).position[i];\n            ugv_state.velocity[i] = (*it).velocity[i];\n            ugv_state.attitude[i] = (*it).attitude[i];\n            ugv_state.attitude_rate[i] = (*it).attitude_rate[i];\n        };\n        ugv_state.attitude_q.x = (*it).attitude_q.x;\n        ugv_state.attitude_q.y = (*it).attitude_q.y;\n        ugv_state.attitude_q.z = (*it).attitude_q.z;\n        ugv_state.attitude_q.w = (*it).attitude_q.w;\n\n        multi_ugv_state.ugv_num++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n\n    // \u53d1\u5e03\u8bdd\u9898\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 90.65088777104262}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  int end_idx = q.cols() - order_;\n  const double a2 = 100.0, b2 = 10000.0;\n\n  /*** calculate positional cost and gradient ***/\n  for (int i = order_; i < end_idx; ++i) {\n    Eigen::Vector3d pos_err = q.col(i) - ref_pts_.col(i - order_);\n    Eigen::Vector3d vel_err = q.col(i + 1) + q.col(i - 1) - 2 * q.col(i);\n    cost += pos_err.squaredNorm() * a2 + vel_err.squaredNorm() * b2;\n    gradient.col(i) += 2.0 * a2 * pos_err + 2.0 * b2 * vel_err;\n  }\n}", "CodeBleu_score": 36.27342063088495}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  int end_idx = q.cols() - order_;\n  constexpr double a2 = 1000.0, b2 = 10000.0;\n\n  for (int i = order_; i < end_idx; i++) {\n    Eigen::Vector3d pos_err = q.col(i) - cps_.points.col(i);\n    Eigen::Vector3d vel_err = cps_.velocity.col(i) - (q.col(i) - q.col(i - 1)) / bspline_interval_;\n    double tmp1 = pos_err.dot(pos_err);\n    double tmp2 = vel_err.dot(vel_err);\n    double tmp = tmp1 + tmp2;\n\n    if (tmp > 0) {\n      cost += tmp;\n      gradient.col(i) += 2.0 * pos_err * a2 + vel_err * b2;\n    }\n  }\n}", "CodeBleu_score": 41.25450109595229}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  int end_idx = q.cols() - order_;\n  double t_now = ros::Time::now().toSec();\n  constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n  for (int i = order_; i < end_idx; i++) {\n    double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n    Eigen::Vector3d pos_err = q.col(i) - ref_pts_.evaluateDeBoorT(glb_time);\n    double pos_cost = pos_err.dot(pos_err);\n    Eigen::Vector3d vel_err = q.col(i) - ref_pts_.evaluateDeBoorT(glb_time, 1);\n    double vel_cost = vel_err.dot(vel_err);\n    double time_cost = pow(glb_time - ref_pts_.getTimeSum(), 2);\n    double fitness_cost = pos_cost * inv_a2 + vel_cost * inv_b2 + time_cost;\n    cost += fitness_cost;\n\n    Eigen::Vector3d pos_grad = 2.0 * pos_err * inv_a2;\n    Eigen::Vector3d vel_grad = 2.0 * vel_err * inv_b2;\n    Eigen::Vector3d time_grad = 2.0 * (glb_time - ref_pts_.getTimeSum()) * Eigen::Vector3d::Ones();\n    Eigen::Vector3d fitness_grad = pos_grad + vel_grad + time_grad;\n    gradient.col(i) += fitness_grad;\n  }\n}", "CodeBleu_score": 43.48736280762577}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t    UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n    double jerk = 0.0;\n    double time_inc = jerk_traj.getTimeSum() / (jerk_traj.control_points_.cols() - 3);\n    for (int i = 0; i < jerk_traj.control_points_.cols(); ++i) {\n        jerk += (jerk_traj.control_points_.col(i) * jerk_traj.control_points_.col(i)).sum() * time_inc;\n    }\n    return jerk;\n}", "CodeBleu_score": 45.191282566054795}, {"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  double jerk = 0.0;\n  double time_inc = jerk_traj.getTimeSum() / (jerk_traj.control_points_.cols() - 3);\n\n  Eigen::VectorXd kts = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  for (int i = 0; i < ctrl_pts.cols(); ++i) {\n    for (int j = 0; j < dimension_; ++j) {\n      jerk += (kts(i + 1) - kts(i)) * ctrl_pts(j, i) * ctrl_pts(j, i);\n    }\n  }\n\n  return jerk / time_inc;\n}", "CodeBleu_score": 82.02865376926096}, {"code": "double UniformBspline::getJerk(){\n\t    UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n    double jerk = 0.0;\n    double time_inc = jerk_traj.getTimeSum() / (jerk_traj.control_points_.cols() - 3);\n    for (int i = 0; i < jerk_traj.control_points_.cols(); ++i) {\n        jerk += (jerk_traj.control_points_.col(i)).squaredNorm() * time_inc;\n    }\n    return jerk;\n}", "CodeBleu_score": 44.60865281195876}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.35005343899863}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(2) = depth;\n    pos(0) = (u - cx_) * pos(2) / fx_;\n    pos(1) = (v - cy_) * pos(2) / fy_;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 61.08617890775774}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.35005343899863}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    int drone_id;\n    try {\n        drone_id = std::stoi(odom.child_frame_id.substr(5));\n    } catch (const std::exception& e) {\n        ROS_ERROR(\"Error extracting drone ID: %s\", e.what());\n        return;\n    }\n    rcvDroneOdomCallbackBase(odom, drone_id);\n}", "CodeBleu_score": 52.86829839898729}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        // Extract the drone ID from the child_frame_id field of the odometry message\n        int drone_id = std::stoi(odom.child_frame_id.substr(5));\n        // Call rcvDroneOdomCallbackBase with the odometry data and drone ID\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        // If extracting the drone ID fails, catch and print the exception\n        ROS_ERROR(\"Error extracting drone ID from child_frame_id: %s\", e.what());\n    }\n}", "CodeBleu_score": 57.28047621178389}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    std::string drone_id_str = odom.child_frame_id.substr(10);\n    int drone_id = std::stoi(drone_id_str);\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (const std::exception& e) {\n    std::cerr << \"Error extracting drone ID: \" << e.what() << std::endl;\n  }\n}", "CodeBleu_score": 64.36420262381212}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  Eigen::Vector3d true_pose_cam, true_pose_world;\n  if (getTruePose(drone_id, true_pixel, true_pose_cam)) {\n    true_pose_world = cam2World(true_pose_cam);\n    pose_error_[drone_id] = (true_pose_world - drone_pose_world_[drone_id]).norm();\n    updateDebugResult(drone_id, true_pose_world);\n    publishPoseError(drone_id);\n  } else {\n    updateDebugResult(drone_id, true_pose_world, false);\n  }\n}", "CodeBleu_score": 34.3163165286148}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // get true pose in cam frame\n  Eigen::Vector3d true_pose_cam = depth2Pos(true_pixel(0), true_pixel(1), depth_img_.at<float>(true_pixel(1), true_pixel(0)));\n  // check the true_pixel\n  if (getDist2(true_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n    // get the pose error\n    Eigen::Vector3d pose_error = true_pose_cam - drone_pose_cam_[drone_id];\n    // update the debug result\n    debug_result_[drone_id].detected = true;\n    debug_result_[drone_id].pose_error = pose_error;\n    // publish the pose error\n    publishPoseError(drone_id, pose_error);\n  } else {\n    // update the debug result\n    debug_result_[drone_id].detected = false;\n    debug_result_[drone_id].pose_error = Eigen::Vector3d(0, 0, 0);\n  }\n}", "CodeBleu_score": 39.01027261078988}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // get true pose in cam frame\n  Eigen::Vector3d true_pose_cam = depth2Pos(true_pixel(0), true_pixel(1), drone_pose_cam_[drone_id](2));\n  // check if the true pose is within the pose error\n  if (getDist2(true_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n    // update debug result\n    debug_result_[drone_id].found = true;\n    debug_result_[drone_id].pose_error = (true_pose_cam - drone_pose_cam_[drone_id]).norm();\n    // publish pose error\n    std_msgs::Float64 pose_error_msg;\n    pose_error_msg.data = debug_result_[drone_id].pose_error;\n    pose_error_pub_[drone_id].publish(pose_error_msg);\n  } else {\n    // update debug result\n    debug_result_[drone_id].found = false;\n  }\n}", "CodeBleu_score": 43.40117054131415}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n\n    return path;\n}", "CodeBleu_score": 98.77621185986197}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n\n    reverse(path.begin(), path.end());\n\n    return path;\n}", "CodeBleu_score": 90.82197591467109}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n\n    return path;\n}", "CodeBleu_score": 98.77621185986197}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!grid_map_->odomValid())\n        return false;\n\n    if (!grid_map_->worldToIndex(start_pt, start_idx) || !grid_map_->worldToIndex(end_pt, end_idx))\n        return false;\n\n    if (grid_map_->isOccupied(start_idx)) {\n        //ROS_WARN(\"Start point is insde obstacle !!! Replan...\");\n        do {\n            start_pt = (start_pt - end_pt).normalized() * grid_map_->getResolution() + start_pt;\n            if (!grid_map_->worldToIndex(start_pt, start_idx))\n                return false;\n        } while (grid_map_->isOccupied(start_idx));\n    }\n\n    if (grid_map_->isOccupied(end_idx)) {\n        //ROS_WARN(\"End point is insde obstacle !!! Replan...\");\n        do {\n            end_pt = (end_pt - start_pt).normalized() * grid_map_->getResolution() + end_pt;\n            if (!grid_map_->worldToIndex(end_pt, end_idx))\n                return false;\n        } while (grid_map_->isOccupied(end_idx));\n    }\n\n    return true;\n}", "CodeBleu_score": 59.14003858932201}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    // Convert start and end points to grid indices\n    start_idx = grid_map_->getGridIndex(start_pt);\n    end_idx = grid_map_->getGridIndex(end_pt);\n\n    // Check if start or end point is inside an obstacle\n    if (grid_map_->isInsideObstacle(start_idx)) {\n        // Adjust start point until it is no longer inside an obstacle\n        for (int i = 0; i < 3; i++) {\n            int delta = end_idx(i) - start_idx(i);\n            if (delta > 0) {\n                start_idx(i) += 1;\n            } else if (delta < 0) {\n                start_idx(i) -= 1;\n            }\n            if (!grid_map_->isInsideObstacle(start_idx)) {\n                break;\n            }\n        }\n    }\n\n    if (grid_map_->isInsideObstacle(end_idx)) {\n        // Adjust end point until it is no longer inside an obstacle\n        for (int i = 0; i < 3; i++) {\n            int delta = end_idx(i) - start_idx(i);\n            if (delta > 0) {\n                end_idx(i) -= 1;\n            } else if (delta < 0) {\n                end_idx(i) += 1;\n            }\n            if (!grid_map_->isInsideObstacle(end_idx)) {\n                break;\n            }\n        }\n    }\n\n    // Check if start or end point is inside an obstacle after adjustment\n    if (grid_map_->isInsideObstacle(start_idx) || grid_map_->isInsideObstacle(end_idx)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 36.06674012440938}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n\n    if (isOccupied(start_idx)) {\n        // current start point is inside an obstacle\n        ROS_WARN(\"Start point is inside obstacle !\");\n        do {\n            start_pt = (start_pt - end_pt).normalized() * resolution + start_pt;\n            // cout << \"start_pt=\" << start_pt.transpose() << endl;\n        } while (isOccupied(start_idx));\n        // cout << \"start_pt=\" << start_pt.transpose() << endl;\n        Coord2Index(start_pt, start_idx);\n    }\n\n    if (isOccupied(end_idx)) {\n        // current end point is inside an obstacle\n        ROS_WARN(\"End point is inside obstacle !\");\n        do {\n            end_pt = (end_pt - start_pt).normalized() * resolution + end_pt;\n            // cout << \"end_pt=\" << end_pt.transpose() << endl;\n        } while (isOccupied(end_idx));\n        // cout << \"end_pt=\" << end_pt.transpose() << endl;\n        Coord2Index(end_pt, end_idx);\n    }\n\n    return true;\n}", "CodeBleu_score": 69.89540983434578}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3i min_id, max_id;\n    posToIndex(min_pos, min_id);\n    posToIndex(max_pos, max_id);\n\n    boundIndex(min_id);\n    boundIndex(max_id);\n\n    /*\n     * The resetBuffer function is used to reset the occupancy buffer within a specified 3D region. It iterates over the grid coordinates from min_id to max_id and sets the corresponding elements in the occupancy_buffer_inflate_ to zero.\n     */\n    for (int x = min_id(0); x <= max_id(0); ++x)\n        for (int y = min_id(1); y <= max_id(1); ++y)\n            for (int z = min_id(2); z <= max_id(2); ++z) {\n                md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n            }\n}", "CodeBleu_score": 81.16198124642644}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3i min_id, max_id;\n    posToIndex(min_pos, min_id);\n    posToIndex(max_pos, max_id);\n\n    boundIndex(min_id);\n    boundIndex(max_id);\n\n    /*\n     * The resetBuffer function is used to reset the occupancy and distance buffers within a specified 3D region.\n     * It iterates over the grid coordinates from min_id to max_id and sets the corresponding elements in the occupancy_buffer_inflate_ to zero.\n     * The resetBuffer function is called by the resetBuffer function, which resets the occupancy and distance buffers for the entire map.\n     */\n    for (int x = min_id(0); x <= max_id(0); ++x) {\n        for (int y = min_id(1); y <= max_id(1); ++y) {\n            for (int z = min_id(2); z <= max_id(2); ++z) {\n                md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 77.00928959198284}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3i min_id, max_id;\n    posToIndex(min_pos, min_id);\n    posToIndex(max_pos, max_id);\n\n    boundIndex(min_id);\n    boundIndex(max_id);\n\n    /*\n     * The code snippet you provided is iterating over a 3D grid defined by the min_id and max_id vectors.\n     * It uses nested for loops to iterate over the x, y, and z dimensions of the grid.\n     * For each combination of x, y, and z, it calculates the corresponding index using the indexToLinear function.\n     * It then sets the corresponding element in the occupancy_buffer_inflate_ vector to zero.\n     * This function is likely used to reset the occupancy buffer within a specified region of the grid map.\n     */\n    for (int x = min_id(0); x <= max_id(0); ++x)\n        for (int y = min_id(1); y <= max_id(1); ++y)\n            for (int z = min_id(2); z <= max_id(2); ++z) {\n                int idx = indexToLinear(x, y, z);\n                md_.occupancy_buffer_inflate_[idx] = 0;\n            }\n}", "CodeBleu_score": 72.14191739538703}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_tc = mp_.map_max_boundary_ - camera_pt;\n    Eigen::Vector3d min_tc = mp_.map_min_boundary_ - camera_pt;\n\n    double min_t = 1000000;\n\n    for (int i = 0; i < 3; ++i) {\n        if (fabs(diff[i]) > 0) {\n            double t1 = max_tc[i] / diff[i];\n            if (t1 > 0 && t1 < min_t)\n                min_t = t1;\n\n            double t2 = min_tc[i] / diff[i];\n            if (t2 > 0 && t2 < min_t)\n                min_t = t2;\n        }\n    }\n\n    return camera_pt + (min_t - 1e-3) * diff;\n}", "CodeBleu_score": 97.28342257392919}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d max_tc = mp_.map_max_boundary_ - camera_pt;\n  Eigen::Vector3d min_tc = mp_.map_min_boundary_ - camera_pt;\n\n  double scale_x = min_tc(0) / diff(0);\n  double scale_y = min_tc(1) / diff(1);\n  double scale_z = min_tc(2) / diff(2);\n\n  scale_x = scale_x > 0.0 ? scale_x : 100.0;\n  scale_y = scale_y > 0.0 ? scale_y : 100.0;\n  scale_z = scale_z > 0.0 ? scale_z : 100.0;\n\n  double scale = min(min(scale_x, scale_y), scale_z);\n\n  Eigen::Vector3d pt_in_grid = camera_pt + scale * diff;\n  return pt_in_grid;\n}", "CodeBleu_score": 50.677195649808446}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d max_tc = mp_.map_max_boundary_ - camera_pt;\n  Eigen::Vector3d min_tc = mp_.map_min_boundary_ - camera_pt;\n\n  double scale_x = max_tc(0) / diff(0);\n  double scale_y = max_tc(1) / diff(1);\n  double scale_z = max_tc(2) / diff(2);\n\n  double scale = min(min(abs(scale_x), abs(scale_y)), abs(scale_z));\n\n  Eigen::Vector3d pt_out = camera_pt + scale * diff;\n  return pt_out;\n}", "CodeBleu_score": 45.391011265888736}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    int num_images = image_fns.size();\n    float total_fmeasure = 0.0f;\n\n    for (int i = 0; i < num_images; ++i) {\n        Mat3b img = imread(image_fns[i]);\n        if (img.empty()) {\n            cout << \"Error loading image: \" << image_fns[i] << endl;\n            continue;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        total_fmeasure += fmeasure;\n    }\n\n    return total_fmeasure / num_images;\n}", "CodeBleu_score": 58.09772718144688}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float total_fmeasure = 0.f;\n    int counter = 0;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i) {\n        string image_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n\n        Mat3b img = imread(image_fn);\n        if (img.empty()) {\n            cout << \"Error opening: \" << image_fn << endl;\n            continue;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        total_fmeasure += fmeasure;\n        ++counter;\n    }\n\n    return (total_fmeasure / float(counter));\n}", "CodeBleu_score": 50.74914116338617}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure_accum = 0.f;\n    unsigned n_images = image_fns.size();\n\n    for (unsigned i = 0; i < n_images; ++i) {\n        Mat3b img = imread(image_fns[i]);\n\n        vector<Ellipse> ell_gt;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\n        vector<Ellipse> ell_dt;\n        _load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n        fmeasure_accum += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n    }\n\n    return fmeasure_accum / float(n_images);\n}", "CodeBleu_score": 62.050577888826076}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a, b, c, d;\n    float angle;\n\n    /* check parameters */\n    if (foci == NULL) {\n        fprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null.\n\");\n        return 0.0;\n    }\n\n    /* compute the angles from the point to each focus */\n    a = atan2(y - foci[1], x - foci[0]);\n    b = atan2(y - foci[3], x - foci[2]);\n\n    /* compute the signed difference between these angles */\n    c = a - b;\n\n    /* adjust the angle to lie within the range [-\u03c0, \u03c0] */\n    d = fmod(c + M_PI, M_2__PI) - M_PI;\n\n    /* return the angle */\n    return d;\n}", "CodeBleu_score": 58.98482656949777}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a, b, angle;\n\n    /* check parameters */\n    if (foci == NULL) {\n        fprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null.\n\");\n        return 0.0;\n    }\n\n    a = atan2(y - foci[1], x - foci[0]);\n    b = atan2(y - foci[3], x - foci[2]);\n    angle = a - b;\n    if (angle > M_PI) angle -= M_2__PI;\n    if (angle < -M_PI) angle += M_2__PI;\n    return angle;\n}", "CodeBleu_score": 63.03510239073131}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a, b;\n\n    /* check parameters */\n    if (foci == NULL) fprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null.\");\n\n    a = atan2(y - foci[1], x - foci[0]);\n    b = atan2(y - foci[3], x - foci[2]);\n    return angle_diff_signed(a, b);\n}", "CodeBleu_score": 49.235041651352546}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\te\n        return true;\n}", "CodeBleu_score": 3.0939704032948514}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\te\n        return true;\n}", "CodeBleu_score": 3.0939704032948514}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\te\n        return true;\n}", "CodeBleu_score": 3.0939704032948514}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    if (msg->num_detections > 0) {\n        for (int i = 0; i < msg->num_detections; i++) {\n            ellipse_det = msg->detection_info[i];\n            if (ellipse_det.name == \"T\") {\n                num_regain++;\n                num_lost = 0;\n            } else {\n                num_regain = 0;\n                num_lost++;\n            }\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    if (ellipse_det.sight_angle[0] > 0) {\n        ellipse_det.sight_angle[0] = -ellipse_det.sight_angle[0];\n    }\n    if (ellipse_det.sight_angle[1] > 0) {\n        ellipse_det.sight_angle[1] = -ellipse_det.sight_angle[1];\n    }\n}", "CodeBleu_score": 73.59975495799134}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->num; i++) {\n        if (msg->detection_info[i].name == \"T\") {\n            ellipse_det = msg->detection_info[i];\n            num_regain++;\n            num_lost = 0;\n            break;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    if (ellipse_det.sight_angle[0] < 0) {\n        ellipse_det.sight_angle[0] = -ellipse_det.sight_angle[0];\n        ellipse_det.sight_angle[1] = -ellipse_det.sight_angle[1];\n    }\n}", "CodeBleu_score": 66.24690278352102}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->num_detections; i++) {\n        if (msg->detections[i].name == \"T\") {\n            ellipse_det = msg->detections[i];\n            num_regain++;\n            num_lost = 0;\n            if (num_regain > VISION_THRES) {\n                is_detected = true;\n            }\n            break;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    ellipse_det.sight_angle[0] = -ellipse_det.sight_angle[0];\n    ellipse_det.sight_angle[1] = -ellipse_det.sight_angle[1];\n    ellipse_det.sight_angle[2] = -ellipse_det.sight_angle[2];\n}", "CodeBleu_score": 67.04870447278651}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->getInflateOccupancy(cur_pos) == 1) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 27.975000301690102}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // \u68c0\u67e5\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u5728\u5360\u636e\u5730\u56fe\u5185\n    if (Occupy_map_ptr->check_in_map(cur_pos)) {\n        // \u68c0\u67e5\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u5b89\u5168\n        return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n    }\n    // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u4e0d\u5728\u5360\u636e\u5730\u56fe\u5185\uff0c\u5219\u8ba4\u4e3a\u5f53\u524d\u4f4d\u7f6e\u662f\u5b89\u5168\u7684\n    return true;\n}", "CodeBleu_score": 44.077742298473574}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // Check if the current position is within the safe distance from the start position\n    if ((cur_pos - start_pos).norm() < safe_distance) {\n        return true;\n    }\n\n    // Check if the current position is within the safe distance from the goal position\n    if ((cur_pos - goal_pos).norm() < safe_distance) {\n        return true;\n    }\n\n    // Check if the current position is within the safe distance from the obstacle\n    if (Occupy_map_ptr->getInflateOccupancy(cur_pos) == 1) {\n        return false;\n    }\n\n    // If the current position is not within the safe distance from the start or goal position,\n    // and not within the safe distance from the obstacle, it is considered safe\n    return true;\n}", "CodeBleu_score": 29.292241552321517}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t  ros::Time time_now = ros::Time::now();\n  // \u5c06\u7ec8\u6b62\u8282\u70b9\u63a8\u5165\u8def\u5f84\u70b9\u96c6\u5408\n  path_nodes_.push_back(end_node);\n\n  // \u4ece\u7ec8\u6b62\u70b9\u5f80\u56de\u5bfb\u627e\u8def\u5f84\n  NodePtr cur_node = end_node;\n  while (cur_node->parent != NULL) {\n    cur_node = cur_node->parent;\n    path_nodes_.push_back(cur_node);\n  }\n\n  // \u5c06\u8def\u5f84\u70b9\u96c6\u5408\u53cd\u5411\uff0c\u5f97\u5230\u4ece\u8d77\u59cb\u70b9\u5230\u7ec8\u6b62\u70b9\u7684\u8def\u5f84\n  reverse(path_nodes_.begin(), path_nodes_.end());\n\n  // \u8ba1\u7b97\u8def\u5f84\u957f\u5ea6\n  iter_num_ = 0;\n  for (int i = 0; i < (int)path_nodes_.size() - 1; i++) {\n    iter_num_ += (path_nodes_[i]->position - path_nodes_[i + 1]->position).norm();\n  }\n\n  // \u8ba1\u7b97\u65f6\u95f4\n  double time_search = (ros::Time::now() - time_now).toSec();\n\n  // \u6253\u5370\u4fe1\u606f\n  cout << GREEN << \"[Astar] succeed: iter_num=\" << iter_num_ << \", time=\" << time_search << \"s.\" << TAIL << endl;\n}", "CodeBleu_score": 62.92033511431146}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  ros::Time time_start = ros::Time::now();\n\n  // \u4ece\u7ec8\u70b9\u5f80\u56de\u63a8\n  NodePtr cur_node = end_node;\n  path_nodes_.push_back(cur_node);\n\n  // \u5faa\u73af\uff0c\u76f4\u5230\u8d77\u70b9\n  while (cur_node->parent != NULL) {\n    cur_node = cur_node->parent;\n    path_nodes_.push_back(cur_node);\n  }\n\n  // \u53cd\u8f6c\u8def\u5f84\uff0c\u4ece\u8d77\u70b9\u5f00\u59cb\n  reverse(path_nodes_.begin(), path_nodes_.end());\n\n  // \u5c06\u8def\u5f84\u70b9\u4f4d\u7f6e\u8d4b\u503c\u7ed9path_\n  for (auto &i : path_nodes_) {\n    path_.push_back(i->position);\n  }\n\n  // \u8ba1\u7b97\u8def\u5f84\u957f\u5ea6\n  double path_length = 0.0;\n  for (int i = 0; i < int(path_nodes_.size()) - 1; ++i) {\n    path_length += (path_nodes_[i + 1]->position - path_nodes_[i]->position).norm();\n  }\n\n  // \u8f93\u51fa\u8def\u5f84\u957f\u5ea6\n  cout << GREEN << \"[Astar] path length: \" << path_length << TAIL << endl;\n\n  // \u8ba1\u7b97\u8def\u5f84\u65f6\u95f4\n  double time_astar = (ros::Time::now() - time_start).toSec();\n  cout << GREEN << \"[Astar] astar time cost: \" << time_astar * 1000 << \" ms\" << TAIL << endl;\n}", "CodeBleu_score": 65.68648611400137}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t  ros::Time time_start = ros::Time::now();\n  path_nodes_.clear();\n\n  NodePtr cur_node = end_node;\n\n  while (cur_node->parent != NULL) {\n    path_nodes_.push_back(cur_node);\n    cur_node = cur_node->parent;\n  }\n\n  reverse(path_nodes_.begin(), path_nodes_.end());\n\n  ros::Duration t_astar = ros::Time::now() - time_start;\n}", "CodeBleu_score": 62.31341564477524}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    // \u66f4\u65b0\u90bb\u5c45\u7684\u72b6\u6001\n    state_nei[id](0) = odom->pose.pose.position.x;\n    state_nei[id](1) = odom->pose.pose.position.y;\n    state_nei[id](2) = odom->pose.pose.position.z;\n\n    // \u5728\u4eff\u771f\u6a21\u5f0f\u4e0b\uff0c\u5982\u679c\u8ddd\u79bb\u8d77\u70b9\u8d85\u8fc75\u7c73\uff0c\u5219\u8ba4\u4e3a\u90bb\u5c45\u4e22\u5931\n    if(simulation_mode)\n    {\n        if(sqrt(pow(state_nei[id](0) - start_pos(0), 2) + pow(state_nei[id](1) - start_pos(1), 2)) > 5)\n        {\n            get_nei_state[id] = false;\n        }else\n        {\n            get_nei_state[id] = true;\n        }\n    }else\n    {\n        get_nei_state[id] = true;\n    }\n\n    // \u66f4\u65b0\u90bb\u5c45\u7684\u72b6\u6001\n    // state_nei[id](0) = odom->pose.pose.position.x;\n    // state_nei[id](1) = odom->pose.pose.position.y;\n    // state_nei[id](2) = odom->pose.pose.position.z;\n    // get_nei_state[id] = true;\n}", "CodeBleu_score": 54.56138007820041}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id](0) = odom->pose.pose.position.x;\n    state_nei[id](1) = odom->pose.pose.position.y;\n    state_nei[id](2) = odom->pose.pose.position.z;\n    get_nei_state[id] = true;\n\n    if(sim_mode)\n    {\n        if((state_nei[id] - start_pos).norm() > 5)\n        {\n            get_nei_state[id] = false;\n        }\n    }\n}", "CodeBleu_score": 41.516504830247065}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    odom_nei[id].x = odom->pose.pose.position.x;\n    odom_nei[id].y = odom->pose.pose.position.y;\n    odom_nei[id].z = odom->pose.pose.position.z;\n    get_nei_state[id] = true;\n    // \u4eff\u771f\u6a21\u5f0f\u4e0b\uff0c\u8ddd\u79bb\u8fc7\u8fdc\uff0c\u5219\u8ba4\u4e3a\u4e22\u5931\n    if(simulation_mode)\n    {\n        if(sqrt(pow(odom_nei[id].x - start_pt.x,2) + pow(odom_nei[id].y - start_pt.y,2)) > 5.0)\n        {\n            get_nei_state[id] = false;\n        }\n    }\n}", "CodeBleu_score": 45.850066208076115}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if(!odom_ready)\n        return;\n\n    sensor_ready = true;\n    counter_update++;\n\n    // \u6bcf\u96945\u6b21\u66f4\u65b0\u4e00\u6b21\u5730\u56fe\n    if(counter_update > 5)\n    {\n        counter_update = 0;\n        Astar_ptr->Occupy_map_ptr->update_map_from_pcl(msg);\n    }\n}", "CodeBleu_score": 54.2456455603682}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter % 5 == 0) {\n        update_counter = 0;\n        Astar_ptr->Occupy_map_ptr->update_map(msg);\n    }\n}", "CodeBleu_score": 60.669192115985936}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n\n    sensor_ready = true;\n    update_counter++;\n\n    if (update_counter >= 5) {\n        Astar_ptr->Occupy_map_ptr->update_map(msg);\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 64.31465452891732}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) return;\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *input_point_cloud);\n    global_map_pcl = input_point_cloud;\n    inflate_map(global_map_pcl);\n}", "CodeBleu_score": 58.41676727509682}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if(!get_gpcl) {\n        get_gpcl = true;\n        // \u5c06\u4f20\u5165\u7684\u5168\u5c40\u70b9\u4e91\u8f6c\u6362\u4e3apcl\u70b9\u4e91\n        pcl::fromROSMsg(*global_point, *input_point_cloud);\n        // \u81a8\u80c0\u5168\u5c40\u70b9\u4e91\n        inflate_point_cloud(input_point_cloud, global_point_cloud_map, enum_p);\n    }\n}", "CodeBleu_score": 60.364178699463864}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if(get_gpcl)\n        return;\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_cloud_map);\n    global_pcl.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*global_cloud_map, *global_pcl);\n    inflate_point_cloud(global_pcl, inflate_index_ugv, enum_p_ugv, global_ugv_pcl);\n}", "CodeBleu_score": 56.87568283147348}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    // \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n    pcl::fromROSMsg(*local_point, *input_point_cloud);\n\n    has_global_point = true;\n\n    if (sim_mode) {\n        if (queue_size <= 0) { // without slide windows\n            // map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n            *global_point_cloud_map += *input_point_cloud;\n        } else { // with slide windows\n            // slide windows with size: $queue_size\n            point_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n            st_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n            // \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n            global_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n            map<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n            for (iter = point_cloud_pair.begin(); iter != point_cloud_pair.end(); iter++) {\n                *global_point_cloud_map += iter->second;\n            }\n        }\n\n        // downsample\n        *pcl_ptr = *global_point_cloud_map;\n        vg.setInputCloud(pcl_ptr);\n        vg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n        vg.filter(*global_point_cloud_map);\n        inflate_point_cloud();\n    } else {\n        local_map_merge_odom(odom);\n    }\n}", "CodeBleu_score": 54.7486627393325}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  if(has_global_point)\n  {\n    sensor_msgs::PointCloud2 global_pcl_ros;\n    pcl::toROSMsg(*global_point_cloud_map, global_pcl_ros);\n    global_pcl_ros.header.frame_id = \\\"world\\\";\n    global_pcl_pub.publish(global_pcl_ros);\n\n    sensor_msgs::PointCloud2 inflate_pcl_ros;\n    pcl::toROSMsg(*cloud_inflate_vis_, inflate_pcl_ros);\n    inflate_pcl_ros.header.frame_id = \\\"world\\\";\n    inflate_pcl_pub.publish(inflate_pcl_ros);\n  }\n}", "CodeBleu_score": 60.90084630018475}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  if (global_point_cloud_map->points.size() == 0) {\n    return;\n  }\n\n  // \u8f6c\u5316\u4e3aPCL\u7684\u683c\u5f0f\u8fdb\u884c\u5904\u7406\n  sensor_msgs::PointCloud2 global_point_cloud_map_ros;\n  pcl::toROSMsg(*global_point_cloud_map, global_point_cloud_map_ros);\n  global_point_cloud_map_ros.header.frame_id = \\\"world\\\";\n  global_pcl_pub.publish(global_point_cloud_map_ros);\n\n  // \u8f6c\u5316\u4e3aPCL\u7684\u683c\u5f0f\u8fdb\u884c\u5904\u7406\n  sensor_msgs::PointCloud2 cloud_inflate_vis_ros;\n  pcl::toROSMsg(*cloud_inflate_vis_, cloud_inflate_vis_ros);\n  cloud_inflate_vis_ros.header.frame_id = \\\"world\\\";\n  inflate_pcl_pub.publish(cloud_inflate_vis_ros);\n}", "CodeBleu_score": 50.81362198671457}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    // \u6839\u636e\u5c40\u90e8\u70b9\u4e91\u66f4\u65b0\u5730\u56fe\n    // \u60c5\u51b5\uff1aRGBD\u76f8\u673a\u3001\u4e09\u7ef4\u6fc0\u5149\u96f7\u8fbe\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom);\n}", "CodeBleu_score": 96.86386357622838}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  // \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u53ef\u4ee5\u5b9e\u65f6\u66f4\u65b0\n  if (Astar_ptr->Occupy_map_ptr->get_lpcl) {\n    // \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n  }\n}", "CodeBleu_score": 79.20073580351715}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    // \u6839\u636e\u5c40\u90e8\u70b9\u4e91\u66f4\u65b0\u5730\u56fe\n    // \u60c5\u51b5\uff1aRGBD\u76f8\u673a\u3001\u4e09\u7ef4\u6fc0\u5149\u96f7\u8fbe\n    Astar_ptr->Occupy_map_ptr->map_update_laser(msg, uav_odom);\n}", "CodeBleu_score": 90.58879304920642}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n    // Calculate target foot positions based on the desired pose using the body controller\n    body_controller_.updatePose(req_pose_);\n    body_controller_.getTargetFootPositions(target_foot_positions_);\n\n    // Compute velocity commands for the legs\n    leg_controller_.updateTargetFootPositions(target_foot_positions_);\n    leg_controller_.updateJointPositions(joint_positions_);\n    leg_controller_.updateJointVelocities(joint_velocities_);\n\n    // Perform inverse kinematics to determine target joint positions\n    kinematics_.updateJointPositions(joint_positions_);\n    kinematics_.updateJointVelocities(joint_velocities_);\n    kinematics_.getTargetJointPositions(target_joint_positions_);\n\n    // Publish foot contact information\n    if (publish_foot_contacts_ && !in_gazebo_) {\n        publishFootContacts_();\n    }\n\n    // Publish joint positions\n    if (publish_joint_states_ && !in_gazebo_) {\n        publishJointStates_();\n    }\n\n    // Publish joint commands\n    if (publish_joint_control_) {\n        publishJointCommands_();\n    }\n}", "CodeBleu_score": 36.90301771197716}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate the target foot positions based on the desired pose\n    body_controller_.run();\n\n    // Compute velocity commands for the legs\n    kinematics_.run();\n\n    // Perform inverse kinematics to determine target joint positions\n    leg_controller_.run();\n\n    // Publish foot contact information\n    if (publish_foot_contacts_ && !in_gazebo_) {\n        publishFootContacts_();\n    }\n\n    // Publish joint positions\n    if (publish_joint_states_ && !in_gazebo_) {\n        publishJointStates_();\n    }\n\n    // Publish joint commands\n    if (publish_joint_control_) {\n        publishJointCommands_();\n    }\n}", "CodeBleu_score": 22.824544453211885}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Calculate target foot positions based on desired pose\n    body_controller_.updateTargetPose(req_pose_, rosTimeToChampTime(ros::Time::now()));\n\n    // Compute velocity commands for the legs\n    leg_controller_.updateTargetJointPositions(rosTimeToChampTime(ros::Time::now()));\n\n    // Perform inverse kinematics to determine target joint positions\n    kinematics_.updateTargetJointPositions(leg_controller_.getTargetJointPositions());\n\n    // Publish foot contact information\n    if (publish_foot_contacts_ && !in_gazebo_) {\n        publishFootContacts_();\n    }\n\n    // Publish joint positions\n    if (publish_joint_states_ && !in_gazebo_) {\n        publishJointStates_();\n    }\n\n    // Publish joint control commands\n    if (publish_joint_control_) {\n        publishJointControl_();\n    }\n}", "CodeBleu_score": 40.53328701168108}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (publish_foot_contacts_ && !in_gazebo_) {\n    champ_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.contacts.resize(4);\n\n    for (size_t i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].contact_state = foot_contacts[i];\n      contacts_msg.contacts[i].contact_phase = leg_controller_.getLegGaitPhase(i);\n    }\n\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 72.48632456487043}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (publish_foot_contacts_ && !in_gazebo_) {\n        champ_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.contacts.resize(4);\n\n        for (size_t i = 0; i < 4; i++) {\n            contacts_msg.contacts[i].contact_state = foot_contacts[i];\n            contacts_msg.contacts[i].contact_phase = base_.getGaitPhase().getGaitPhase(i);\n        }\n\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 73.07063838804793}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (publish_foot_contacts_ && !in_gazebo_) {\n        champ_msgs::ContactsStamped contacts_msg;\n\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.contacts.resize(4);\n\n        for (size_t i = 0; i < 4; i++) {\n            contacts_msg.contacts[i].contact_state = foot_contacts[i];\n            contacts_msg.contacts[i].contact_phase = leg_controller_.getGaitPhase(i);\n        }\n\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 73.08552911388828}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    minimal_joints = Joints()\n    minimal_joints.position = joints.position[:12]\n    self.joint_minimal_pub.publish(minimal_joints)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.joint_names = self.joint_names\n    point = JointTrajectoryPoint()\n    point.positions = joints.position\n    point.time_from_start = rospy.Duration(0.5)\n    joint_trajectory.points.append(point)\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 52.09283095455219}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.joints = joints.position[:12]\n    self.joint_minimal_pub.publish(joints_msg)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.joint_names = self.joint_names\n    joint_trajectory.points.append(JointTrajectoryPoint())\n    joint_trajectory.points[0].positions = joints.position[:12]\n    joint_trajectory.points[0].time_from_start = rospy.Duration(0.1)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 41.517256933021855}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.joints = []\n    for i in range(12):\n        joints_msg.joints.append(joints.position[i])\n    self.joint_minimal_pub.publish(joints_msg)\n\n    joint_trajectory_msg = JointTrajectory()\n    joint_trajectory_msg.joint_names = self.joint_names\n    point = JointTrajectoryPoint()\n    point.positions = joints.position\n    point.time_from_start = rospy.Duration(0.5)\n    joint_trajectory_msg.points.append(point)\n    self.joint_trajectory_pub.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 70.28289944800183}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    for (int i = 0; i < 4; i++) {\n        foot_contacts_[i] = false;\n    }\n\n    for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n\n        std::vector<std::string> collision1_split;\n        std::vector<std::string> collision2_split;\n\n        boost::split(collision1_split, collision1, boost::is_any_of(\\\"::\\\"));\n        boost::split(collision2_split, collision2, boost::is_any_of(\\\"::\\\"));\n\n        std::string collision1_link = collision1_split[0];\n        std::string collision2_link = collision2_split[0];\n\n        for (unsigned int j = 0; j < foot_links_.size(); j++) {\n            if (collision1_link == foot_links_[j]) {\n                foot_contacts_[j] = true;\n            }\n            if (collision2_link == foot_links_[j]) {\n                foot_contacts_[j] = true;\n            }\n        }\n    }\n\n    champ_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.contacts.resize(4);\n    for (unsigned int i = 0; i < 4; i++) {\n        contacts_msg.contacts[i] = foot_contacts_[i];\n    }\n    contacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 59.321372453099265}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\tfor (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\t\tstd::vector<std::string> collisions;\n\n\t\tcollisions.push_back(collision1);\n\n\t\tcollisions.push_back(collision2);\n\n\t\tfor (int i = 0; i < 2; i++) {\n\n\t\t\tstd::vector<std::string> strs;\n\n\t\t\tboost::split(strs, collisions[i], boost::is_any_of(\\\":\\\"));\n\n\t\t\tstd::vector<std::string> strs2;\n\n\t\t\tboost::split(strs2, strs[0], boost::is_any_of(\\\"/\\\"));\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\n\t\t\t\tif (strs2[0] == foot_links_[j]) {\n\n\t\t\t\t\tfoot_contacts_[j] = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpublishContacts_();\n\n}", "CodeBleu_score": 63.835318222640716}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t", "CodeBleu_score": 1.3983365370963055}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 99.77937154959373}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 99.77937154959373}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 99.77937154959373}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d e_3(Eigen::Vector3d::UnitZ());\n\n  *acceleration = Eigen::Vector3d::Zero();\n  if (controller_parameters_.use_position_gain_) {\n    *acceleration += position_error.cwiseProduct(controller_parameters_.position_gain_);\n  }\n  if (controller_parameters_.use_velocity_gain_) {\n    *acceleration += velocity_error.cwiseProduct(controller_parameters_.velocity_gain_);\n  }\n\n  // Transformiert die Beschleunigung in das Weltkoordinatensystem.\n  *acceleration = R_W_I.transpose() * (*acceleration) + e_3 * vehicle_parameters_.gravity_ + command_trajectory_.acceleration_W;\n  // Beschleunigung auf die Beschleunigung des Vehikels normalisiert.\n  *acceleration /= vehicle_parameters_.mass_;\n\n  if (acceleration->norm() > vehicle_parameters_.max_acc_) {\n    *acceleration = acceleration->normalized() * vehicle_parameters_.max_acc_;\n  }\n}", "CodeBleu_score": 80.28550894544335}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d e_3(Eigen::Vector3d::UnitZ());\n\n  *acceleration = (position_error.cwiseProduct(controller_parameters_.position_gain_)\n      + velocity_error.cwiseProduct(controller_parameters_.velocity_gain_))\n      / vehicle_parameters_.mass_\n      - vehicle_parameters_.gravity_ * e_3\n      + command_trajectory_.acceleration_W;\n}", "CodeBleu_score": 98.05277279065074}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d e_3(Eigen::Vector3d::UnitZ());\n\n  *acceleration = Eigen::Vector3d::Zero();\n  *acceleration += position_error.cwiseProduct(controller_parameters_.position_gain_);\n  *acceleration += velocity_error.cwiseProduct(controller_parameters_.velocity_gain_);\n  *acceleration += command_trajectory_.acceleration_W.cwiseProduct(\n      controller_parameters_.acceleration_gain_) + e_3.cwiseProduct(\n      Eigen::Vector3d(0, 0, vehicle_parameters_.gravity_));\n}", "CodeBleu_score": 81.9337110384927}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(amount_rotors_);\n  if (!initialized_params_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust_ / mass_;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 78.72760121961868}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(amount_rotors_);\n  if (!initialized_params_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(6);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust_;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 76.80660122396196}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(amount_rotors_);\n  if (!initialized_params_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(6);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = collective_thrust_;\n  angular_acceleration_thrust(4) = collective_thrust_;\n  angular_acceleration_thrust(5) = collective_thrust_;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->array().max(1.0);\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 72.38826911003814}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = numpy.searchsorted(self.time, start_time)\n    end_index = numpy.searchsorted(self.time, end_time)\n    new_object = copy.deepcopy(self)\n    new_object.time = self.time[start_index:end_index]\n    new_object.bag_time = self.bag_time[start_index:end_index]\n    return new_object\n\n", "CodeBleu_score": 25.304073506835017}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = numpy.argmax(self.time > start_time)\n    end_index = numpy.argmax(self.time > end_time)\n    new_object = copy.deepcopy(self)\n    new_object.time = self.time[start_index:end_index]\n    new_object.bag_time = self.bag_time[start_index:end_index]\n    return new_object\n\n", "CodeBleu_score": 25.295302481479094}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = numpy.where(self.time >= start_time)[0][0]\n    end_index = numpy.where(self.time <= end_time)[0][-1]\n    sliced_object = copy.deepcopy(self)\n    for key, value in sliced_object.__dict__.items():\n        if isinstance(value, numpy.ndarray):\n            sliced_object.__dict__[key] = value[start_index:end_index + 1]\n    return sliced_object\n\n", "CodeBleu_score": 33.07689773407994}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if not self.empty:\n        if waypoint_msg.position.x == self.x[-1] and waypoint_msg.position.y == self.y[-1] and waypoint_msg.position.z == self.z[-1] and waypoint_msg.yaw == self.yaw[-1]:\n            return\n    quat = Quaternion()\n    quat.x = waypoint_msg.orientation.x\n    quat.y = waypoint_msg.orientation.y\n    quat.z = waypoint_msg.orientation.z\n    quat.w = waypoint_msg.orientation.w\n    euler = quaternion_to_euler(quat)\n    self.yaw = numpy.append(self.yaw, euler[2])\n    self.append_point(waypoint_msg.position)\n    self.append_times(msg_time, bag_time)\n    self.empty = False\n\n", "CodeBleu_score": 31.625090617271145}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    quaternion = waypoint_msg.pose.orientation\n    rotation = tf.transformations.euler_from_quaternion(\n        [quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    yaw = rotation[2]\n    point = Point(position.x, position.y, position.z)\n    if not self.empty and (point.x != self.x[-1] or point.y != self.y[-1] or yaw != self.yaw[-1]):\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n    elif self.empty:\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 37.396757496743405}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    quaternion = waypoint_msg.pose.orientation\n    yaw = math.atan2(\n        2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y),\n        1 - 2 * (quaternion.y ** 2 + quaternion.z ** 2))\n    if (self.empty or\n            (position.x != self.x[-1] or\n             position.y != self.y[-1] or\n             position.z != self.z[-1] or\n             yaw != self.yaw[-1])):\n        self.empty = False\n        self.append_point(position)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 33.454838648913615}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic != imu_topic:\n            continue\n        self.acc[index].append_acceleration(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n        self.ang_vel[index].append_angular_velocity(msg.angular_velocity)\n        self.ang_vel[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 52.18726259352984}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic != imu_topic:\n            continue\n        self.acc[index].append_point(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 45.900668431140076}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic != imu_topic:\n            continue\n        self.acc[index].append_xyz(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 45.80846177604923}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acc' if self.prefix else 'acc'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 78.51135929729323}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle('Acceleration')\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 75.33988432127605}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acc' if self.prefix else 'acc'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 78.51135929729323}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indeces are required to perform comparisons.\")\n        return\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 39.219764553637525}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Please provide at least two pose indices to compare.\")\n        return\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 32.12553796263795}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError(\"At least two pose indeces must be provided.\")\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.pos[pose_indeces[i]], self.pos[pose_indeces[j]])\n\n", "CodeBleu_score": 42.99250087515794}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        for time in wrench.time:\n            if start_time and time < start_time:\n                continue\n            if end_time and time > end_time:\n                break\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 44.6697946228401}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if collision.time >= start_time and collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.39398851604464}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time and end_time:\n            if collision.time >= start_time and collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time:\n            if collision.time >= start_time:\n                collision_times.append(collision.time)\n        elif end_time:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.26095308604406}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 75.42305683412431}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 71.55115547094847}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = settling_time + start_time\n    analyze_bag.plot_angular_velocities(start_time=start_time, end_time=end_time,\n                                        settling_time=absolute_settling_time, x_range=x_range,\n                                        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(start_time=start_time, end_time=end_time,\n                                            settling_time=absolute_settling_time, x_range=x_range,\n                                            y_range=[-1.5, 1.5], plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 51.00274184080782}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) return;\n\n  const float multiplier =\n      this->focal_length * this->focal_length /\n      (this->baseline * this->baseline * this->pixel_size * this->pixel_size);\n\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height, 1);\n\n  // Compute the RMS noise\n  const float rms_noise =\n      std::sqrt(this->k1 * multiplier + this->k2 / multiplier);\n\n  // Compute the noise values\n  std::normal_distribution<float> distribution(0.0, rms_noise);\n  std::vector<float> noise_values(width * height);\n  for (size_t i = 0; i < width * height; i++) {\n    noise_values[i] = distribution(this->random_generator);\n  }\n\n  // Add noise to the data\n  for (size_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vec(i))) {\n      data_vec(i) += noise_values[i];\n    } else {\n      data_vec(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 51.47176881004336}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) return;\n\n  const float multiplier =\n      this->focal_length * this->baseline / this->depth_unit;\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height, 1);\n\n  const float rms_noise =\n      this->depth_unit * this->depth_unit * this->k1 * multiplier * multiplier;\n  const float noise_std = std::sqrt(2.0f * rms_noise);\n  const float bad_point = std::numeric_limits<float>::quiet_NaN();\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    const float depth = data_vec(i) / this->depth_unit;\n    if (this->InRange(depth)) {\n      const float noise = noise_std * this->random_generator_.Gaussian();\n      data_vec(i) += noise;\n    } else {\n      data_vec(i) = bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.080942302776506}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  float multiplier =\n      this->intrinsics.fx * this->intrinsics.fy *\n      this->intrinsics.baseline * this->intrinsics.baseline *\n      this->intrinsics.baseline * this->intrinsics.baseline /\n      (this->intrinsics.fx * this->intrinsics.baseline);\n\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  float rms_noise =\n      multiplier * this->intrinsics.fx * this->intrinsics.fy *\n      this->intrinsics.baseline * this->intrinsics.baseline *\n      this->intrinsics.baseline * this->intrinsics.baseline /\n      (this->intrinsics.fx * this->intrinsics.baseline);\n\n  float noise_x = this->gaussian_noise_x.Generate();\n  float noise_y = this->gaussian_noise_y.Generate();\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vec(i))) {\n      data_vec(i) += rms_noise + noise_x + noise_y;\n    } else {\n      data_vec(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.471029465456105}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 99.66306672220828}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 99.66306672220828}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 99.66306672220828}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n  actuator_msg->header.stamp = ros_now;\n  for (int i = 0; i < num_motors_; ++i) {\n    actuator_msg->angular_velocities.push_back(\n        joints_[i]->GetVelocity(0) * motor_velocity_reference_ /\n        joints_[i]->GetVelocityLimit(0));\n  }\n  writeBag(namespace_ + \\\"/\\\" + motor_topic_, ros_now, actuator_msg);\n}", "CodeBleu_score": 40.34741388040892}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for actuator velocities.\n  mav_msgs::ActuatorsPtr actuator_velocities_msg(new mav_msgs::Actuators);\n\n  // Iterate through the motor joints.\n  for (int i = 0; i < num_motors_; i++) {\n    // Calculate the slowed-down rotational velocities.\n    double slowed_down_velocity = joints_[i]->GetVelocity(0) * (1 - motor_speed_slowdown_);\n\n    // Assign the slowed-down velocities to the message.\n    actuator_velocities_msg->angular_velocities.push_back(slowed_down_velocity);\n  }\n\n  // Set the message timestamp.\n  actuator_velocities_msg->header.stamp = ros_now;\n\n  // Write the data to a bag file using the specified namespace and motor topic.\n  writeBag(namespace_ + \"/\" + motor_topic_, ros_now, actuator_velocities_msg);\n}", "CodeBleu_score": 48.22172922163919}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for the actuator velocities.\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n\n  // Iterate through the motor joints.\n  for (unsigned int i = 0; i < joints_.size(); i++) {\n    // Calculate the slowed-down rotational velocities.\n    double velocity = joints_[i]->GetVelocity(0) * motor_speed_slowdown_;\n\n    // Assign the calculated velocities to the message.\n    actuator_msg->angular_velocities.push_back(velocity);\n  }\n\n  // Set the message timestamp.\n  actuator_msg->header.stamp = ros_now;\n\n  // Write the data to a bag file using the specified namespace and motor topic.\n  writeBag(namespace_ + \"/\" + motor_topic_, ros_now, actuator_msg);\n}", "CodeBleu_score": 50.49797638319377}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  delta_aileron_left_ = NormalizedInputToAngle(\n      vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->roll());\n  delta_aileron_right_ = NormalizedInputToAngle(\n      vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  delta_elevator_ = NormalizedInputToAngle(\n      vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n  delta_flap_ = NormalizedInputToAngle(\n      vehicle_params_.flap,\n      roll_pitch_yawrate_thrust_msg->thrust());\n  delta_rudder_ = NormalizedInputToAngle(\n      vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->thrust());\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 79.33458135252148}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  delta_aileron_left_ = NormalizedInputToAngle(\n      vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->roll());\n  delta_aileron_right_ = NormalizedInputToAngle(\n      vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  delta_elevator_ = NormalizedInputToAngle(\n      vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n  delta_flap_ = NormalizedInputToAngle(\n      vehicle_params_.flap,\n      roll_pitch_yawrate_thrust_msg->thrust());\n  delta_rudder_ = NormalizedInputToAngle(\n      vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->thrust());\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 79.33458135252148}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->roll());\n  delta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n  delta_flap_ = NormalizedInputToAngle(vehicle_params_.flap,\n      roll_pitch_yawrate_thrust_msg->thrust().z());\n  delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->thrust().x());\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust().y();\n}", "CodeBleu_score": 85.32036090839566}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for MAVLink messages\n  if (readSysId() > 0) {\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(fd_, &readfds);\n    timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n    int ret = select(fd_ + 1, &readfds, nullptr, nullptr, &timeout);\n    if (ret < 0) {\n      std::cout << \"Error on select(): \" << strerror(errno) << std::endl;\n    } else if (ret > 0) {\n      if (FD_ISSET(fd_, &readfds)) {\n        uint8_t cp;\n        ssize_t nread = ::read(fd_, &cp, 1);\n        if (nread < 0) {\n          std::cout << \"Error on read(): \" << strerror(errno) << std::endl;\n        } else if (nread > 0) {\n          if (mavlink_parse_char(MAVLINK_COMM_1, cp, &message_, &status_)) {\n            if (gcs_link_ && gcs_enabled_) {\n              // forward message from autopilot to GCS\n              send_mavlink_message(gcs_link_, &message_);\n            }\n            // handle message from GCS or autopilot\n            handleMessage(&message_);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 42.42996693220423}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for MAVLink messages\n  if (readSysId_ > 0) {\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(readSysId_, &readfds);\n    timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n    int ret = select(readSysId_ + 1, &readfds, NULL, NULL, &timeout);\n    if (ret < 0) {\n      std::cout << \"select error = \" << ret << \", errno = \" << errno << std::endl;\n    } else if (ret > 0) {\n      if (FD_ISSET(readSysId_, &readfds)) {\n        uint8_t cp;\n        int result = read(readSysId_, &cp, 1);\n        if (result != 1) {\n          std::cout << \"WARNING: MAVLink read timeout!\" << std::endl;\n        }\n        if (mavlink_parse_char(MAVLINK_COMM_1, cp, &last_message_,\n                               &last_status_)) {\n          if (hil_mode_) {\n            handleMessage(&last_message_);\n          } else {\n            // XXX FIXME TODO REMOVE\n            // XXX REMOVE ME\n            // forward message from PX4 to QGroundControl\n            send_mavlink_message(&last_message_);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 42.604603871132966}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for MAVLink messages\n  if (readSysId > 0) {\n    // get current time\n    struct timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n\n    // poll for data\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(readSysId, &readfds);\n    int pollret = select(readSysId + 1, &readfds, NULL, NULL, &timeout);\n\n    // check for received bytes on UDP socket\n    if (pollret > 0 && FD_ISSET(readSysId, &readfds)) {\n      // 100 bytes should be enough to hold all MAVLink messages received\n      // in one UDP packet\n      uint8_t buffer[100];\n      ssize_t recsize = recv(readSysId, buffer, sizeof(buffer), 0);\n\n      if (recsize > 0) {\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        // parse all MAVLink messages in buffer\n        for (ssize_t i = 0; i < recsize; i++) {\n          // parse single MAVLink message\n          if (mavlink_parse_char(MAVLINK_COMM_1, buffer[i], &msg, &status)) {\n            // forward message to serial connection\n            if (serial_enabled_) {\n              send_mavlink_message(&msg);\n            }\n\n            // handle message\n            handleMessage(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 59.6332624623501}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  // Stop I/O thread\n  io_service_.stop();\n  if (io_thread_.joinable()) {\n    io_thread_.join();\n  }\n\n  if (serial_dev_.is_open()) {\n    serial_dev_.close();\n  }\n}", "CodeBleu_score": 60.29936201433416}, {"code": "void GazeboMavlinkInterface::close() {\n\t  mutex.lock();\n  if (serial_enabled_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n  mutex.unlock();\n}", "CodeBleu_score": 64.89041457090619}, {"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (serial_enabled_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n    serial_enabled_ = false;\n  }\n}", "CodeBleu_score": 65.55042290710695}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d link_position,\n  std::vector<ignition::math::Vector3d> interpolation_points,\n  std::vector<ignition::math::Vector3d> interpolation_values,\n  std::vector<unsigned int> idx\n}", "CodeBleu_score": 13.35531113313904}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    const ignition::math::Vector3d& position,\n    const std::vector<ignition::math::Vector3d>& interpolation_points,\n    const std::vector<ignition::math::Vector3d>& interpolation_values,\n    const std::vector<double>& vertical_spacing_factors,\n    const std::vector<double>& bottom_z,\n    const std::vector<double>& top_z\n}", "CodeBleu_score": 22.015667695818564}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d link_position,\n  ignition::math::Vector3d point_1,\n  ignition::math::Vector3d point_2,\n  ignition::math::Vector3d value_1,\n  ignition::math::Vector3d value_2\n}", "CodeBleu_score": 17.86486307252876}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  if (this->length == 0.0) {\n    gzerr << \"Animation length is zero, unable to set time\n\";\n    return;\n  }\n\n  if (this->loop) {\n    _time = fmod(_time, this->length);\n    if (_time < 0) {\n      _time += this->length;\n    }\n  } else {\n    if (_time < 0) {\n      _time = 0;\n    } else {\n      _time = ignition::math::clamp(_time, 0.0, this->length);\n    }\n  }\n\n  if (ignition::math::equal(_time, this->timePos)) {\n    return;\n  }\n\n  this->timePos = _time;\n\n  this->build = false;\n}", "CodeBleu_score": 57.84515934714698}, {"code": "void Animation::SetTime(double _time){\n\t  if (this->timePos != _time) {\n    this->timePos = _time;\n\n    if (this->loop) {\n      this->timePos = fmod(this->timePos, this->length);\n      if (this->timePos < 0) {\n        this->timePos += this->length;\n      }\n    } else {\n      if (this->timePos < 0) {\n        this->timePos = 0;\n      } else {\n        this->timePos = std::min(this->timePos, this->length);\n      }\n    }\n  }\n}", "CodeBleu_score": 77.84486036197039}, {"code": "void Animation::SetTime(double _time){\n\t    // If the new time is negative, set the time to the beginning of the animation.\n    if (_time < 0) {\n        this->timePos = 0;\n        return;\n    }\n\n    // If looping is enabled, wrap the time around the animation length.\n    if (this->loop) {\n        this->timePos = fmod(_time, this->length);\n    }\n    // If looping is disabled, clamp the time between 0 and the animation length.\n    else {\n        this->timePos = std::max(0.0, std::min(_time, this->length));\n    }\n\n    // If the new time position is different from the current time position, update the time position.\n    if (this->timePos != _time) {\n        this->timePos = _time;\n    }\n}", "CodeBleu_score": 57.477779485135486}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.vehicle_state.orientation)\n    self.target_motion = self.construct_target(x=self.vehicle_state.position.x, y=self.vehicle_state.position.y, z=self.vehicle_state.position.z, yaw=yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\": Hovering\")\n\n", "CodeBleu_score": 62.24629919804509}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.pose.orientation)\n    self.target_motion = self.construct_target(x=self.pose.position.x,\n                                              y=self.pose.position.y,\n                                              z=self.pose.position.z,\n                                              yaw=yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \": Hovering\")\n\n", "CodeBleu_score": 57.464079976593865}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    yaw = self.q2yaw(self.vehicle_state.attitude.orientation)\n    self.target_motion = self.construct_target(x=self.vehicle_state.position.x,y=self.vehicle_state.position.y,z=self.vehicle_state.position.z,yaw=yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\": Hovering\")\n\n", "CodeBleu_score": 62.35590609546271}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        if self.flightModeService(mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED, self.mode_mapping[self.flight_mode]):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Mode changed to \" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Mode change failed\")\n            return False\n\n", "CodeBleu_score": 57.11053915903464}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" success\")\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" failed\")\n            return False\n\n", "CodeBleu_score": 77.2060087040282}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \": hovering\")\n        return True\n    elif self.flight_mode == 'OFFBOARD':\n        if self.flightModeService(custom_mode='OFFBOARD'):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": offboard mode\")\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": offboard mode failed\")\n            return False\n    else:\n        if self.flightModeService(custom_mode=self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode + \" failed\")\n            return False\n\n", "CodeBleu_score": 53.383810334145764}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        if self.flight_mode != \"HOVER\":\n            self.flightModeService(custom_mode=\"HOVER\")\n            self.hover_action()\n    else:\n        self.hover_flag = 1\n\n", "CodeBleu_score": 53.94604404260397}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        if self.flight_mode != 'OFFBOARD':\n            self.flight_mode = 'OFFBOARD'\n            self.flightModeService(custom_mode='OFFBOARD')\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"flight mode changed to OFFBOARD\\\")\n\n    def hold_state_transition(self, x, y, z, w, frame):\n        if self.hover_flag == 1:\n            if self.flight_mode != 'HOLD':\n                self.flight_mode = 'HOLD'\n                self.flightModeService(custom_mode='HOLD')\n                print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"flight mode changed to HOLD\\\")\n                self.hold_flag = 1\n                if frame == 'flu':\n                    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n                if frame == 'enu':\n                    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n\n    def q2yaw(self, q):\n        if (q.w == 0 and q.x == 0 and q.y == 0 and q.z == 0):\n            yaw = 0\n        else:\n            yaw = np.arctan2(2 * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q", "CodeBleu_score": 38.84404533425684}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        if self.flight_mode != \"OFFBOARD\":\n            self.flight_mode = \"OFFBOARD\"\n            self.flightModeService(custom_mode=self.flight_mode)\n        self.hover_action()\n\n", "CodeBleu_score": 58.456051567969126}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 48.77390960520454}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 53.16045874304341}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q.w, q.x, q.y, q.z)\n        return q.yaw_pitch_roll[0]\n\n", "CodeBleu_score": 48.77390960520454}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + ': Hovering')\n\n", "CodeBleu_score": 41.764476415120136}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + ': Hovering')\n\n", "CodeBleu_score": 41.764476415120136}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n\n", "CodeBleu_score": 46.83615075373995}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + ': flight mode switch failed')\n            return False\n\n", "CodeBleu_score": 73.32810907116234}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 75.99048692133246}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + ': ' + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + ': flight mode switch failed')\n            return False\n\n", "CodeBleu_score": 70.69730595507006}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.namespace:\n        self.local_pose = msg\n        self.global_pose[i] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose.pose.position.x = msg.pose.position.x\n            self.takeoff_target_pose.pose.position.y = msg.pose.position.y\n            self.takeoff_target_pose.pose.position.z = msg.pose.position.z\n            self.hover_target_pose.pose.position.x = msg.pose.position.x\n            self.hover_target_pose.pose.position.y = msg.pose.position.y\n            self.hover_target_pose.pose.position.z = msg.pose.position.z\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose.pose.position.x = msg.pose.position.x\n            self.hover_target_pose.pose.position.y = msg.pose.position.y\n            self.hover_target_pose.pose.position.z = msg.pose.position.z\n        self.global_pose[i].pose.position.x -= self.global_pose_bias[0]\n        self.global_pose[i].pose.position.y -= self.global_pose_bias[1]\n        self.global_pose[i].pose.position.z -= self.global_pose_bias[2]\n\n", "CodeBleu_score": 26.945796467788824}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[i] = msg\n        if self.gcs_cmd == \"TAKEOFF\":\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z\n        elif self.gcs_cmd == \"FORM_1\":\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z\n        elif self.gcs_cmd == \"FORM_2\":\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.pose.position.x = self.local_", "CodeBleu_score": 20.181736506881958}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[self.uav_id] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose = msg\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = msg\n    else:\n        self.global_pose[i] = msg\n\n    self.global_pose[self.uav_id].pose.position.x -= self.bias_x\n    self.global_pose[self.uav_id].pose.position.y -= self.bias_y\n    self.global_pose[self.uav_id].pose.position.z -= self.bias_z\n\n", "CodeBleu_score": 30.16710282714386}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.global_pose[self.uav_id].pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 72.40427091732786}, {"code": "def takeoff_detection(self)\n\t\n    if self.global_pose[self.uav_id].pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 72.40427091732786}, {"code": "def takeoff_detection(self)\n\t\n    if self.global_pose[self.uav_id].pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 72.40427091732786}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance_matrix[i][j] = int(50 - numpy.linalg.norm(orig_formation[i] - change_formation[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 43.593213194850435}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance_matrix[i][j] = int(50 - numpy.linalg.norm(orig_formation[i] - change_formation[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 43.593213194850435}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    graph = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            graph[i][j] = int(50 - numpy.linalg.norm(orig_formation[i] - change_formation[j]))\n    return graph\n\n", "CodeBleu_score": 41.37393586881777}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n        if gap == 0:\n            self.visit_right[j] = 1\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 58.25096120811422}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 54.80687063277052}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n            if gap == 0:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(self.slack_right[j], gap)\n    return False\n\n", "CodeBleu_score": 54.80687063277052}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        while True:\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            if self.find_path(i):\n                break\n            d = numpy.min(self.slack_right)\n            self.label_left[self.visit_left] -= d\n            self.label_right[self.visit_right] += d\n    return self.match_right\n\n", "CodeBleu_score": 44.508052271072316}, {"code": "def KM(self)\n\t\n    for i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        while True:\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            if self.find_path(i):\n                break\n            d = self.slack_right[0]\n            for j in range(1, self.uav_num - 1):\n                if self.slack_right[j] < d:\n                    d = self.slack_right[j]\n            for j in range(self.uav_num - 1):\n                if self.visit_left[j]:\n                    self.label_left[j] -= d\n                if self.visit_right[j]:\n                    self.label_right[j] += d\n                else:\n                    self.slack_right[j] -= d\n    return self.match_right\n\n", "CodeBleu_score": 63.551596263055956}, {"code": "def KM(self)\n\t\n    for i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        while True:\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            if self.find_path(i):\n                break\n            d = numpy.min(self.slack_right)\n            self.label_left[self.visit_left] -= d\n            self.label_right[self.visit_right] += d\n    return self.match_right\n\n", "CodeBleu_score": 44.508052271072316}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=\"uint8\")\n    upper_yellow = np.array([30, 255, 255], dtype=\"uint8\")\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    yellow = cv2.bitwise_and(image, image, mask=mask)\n    return yellow\n\n", "CodeBleu_score": 48.318705012439864}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.04105682804775}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.04105682804775}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  int id;\n  StandaloneTagDescription* descriptionContainer;\n  bool printWarning;\n  return standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end();\n}", "CodeBleu_score": 15.67309354066086}]}
