{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\treturn _pimpl->CallAndWait<std::vector<std::string>>(\n\"get_required_files\",\nfolder,\ndownload);\n}", "CodeBleu_score": 19.433053311354247}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\treturn _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_required_files\\\", folder, download);\n}", "CodeBleu_score": 11.071281885805167}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\tstd::vector<std::string> required_files = _pimpl->CallAndWait<std::vector<std::string>>(\n\"get_required_files\", folder, download);\nreturn required_files;\n}", "CodeBleu_score": 25.554004925482793}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t/*\n * This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.\nIf the attachment type is SpringArm or SpringArmGhost, it checks the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis and issues a warning if necessary.\nFinally, it calls an internal function to complete the actor spawning process and returns the spawned actor.\n */\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        if (transform.location.z!= 0.0f) {\n            log_warning(\"The translation of the actor's transform is only in the 'z' axis, which is not supported. The translation will be set to zero.\");\n            transform.location.z = 0.0f;\n        }\n    }\n    auto actor = _pimpl->CallAndWait<rpc::Actor>(\n        \"spawn_actor_with_parent\",\n        description,\n        transform,\n        parent,\n        attachment_type,\n        socket_name);\n    return actor;\n}", "CodeBleu_score": 50.07932924205236}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t/*\n * The function is implemented as follows:\n */\n    carla::streaming::detail::token_type thisToken(ActorId, GBufferId);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\n        \"get_gbuffer_token\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 44.323644893275855}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t/*\n * The Client::SubscribeToGBuffer function takes two parameters:\n * \n * ActorId: The ID of the Actor that the G-buffer belongs to.\n * GBufferId: The ID of the G-buffer that the client wants to subscribe to.\n * callback: A callback function that takes a Buffer object as a parameter and processes the data.\n */\n    carla::streaming::detail::token_type thisToken(GBufferId, ActorId);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\n        \"get_gbuffer_token\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 44.097912798162874}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n/*\n * The following code is the implementation of the function Client::SubscribeToGBuffer.\n */\n\n// Get the G-buffer token for the specified ActorId and GBufferId.\nstreaming::Token gbuffer_token = _pimpl->CallAndWait<streaming::Token>(\n    \"get_gbuffer_token\", ActorId, GBufferId);\n\n// Copy the token data and subscribe to the streaming client using the provided callback function.\ncarla::streaming::detail::token_type thisToken(gbuffer_token);\nstreaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\n    \"get_sensor_token\", thisToken.get_stream_id());\n_pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n}", "CodeBleu_score": 50.394092174542024}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t (_walker_navigation == nullptr) {\n\t\t_walker_navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 28.352727568207065}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t(_walker_navigation == nullptr) {\n_walker_navigation = std::make_shared<WalkerNavigation>(_client, _simulator, _state);\n}\nreturn _walker_navigation;\n}", "CodeBleu_score": 28.26407096653103}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t(!_walker_navigation) {\n_walker_navigation = std::make_shared<WalkerNavigation>(_client, _simulator);\n}\nreturn _walker_navigation;\n}", "CodeBleu_score": 23.104441501407347}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst auto start = std::chrono::steady_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tif (std::chrono::steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tepisode.Tick();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 32.62926260931444}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start = std::chrono::steady_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tif (std::chrono::steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 34.721601838967416}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t", "CodeBleu_score": 2.6018891845533507}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tpisodeProxy episode;\n\tauto start = std::chrono::system_clock::now();\n\tauto end = start + std::chrono::seconds(2);\n\tauto timeout = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n\twhile (true) {\n\t\ttry {\n\t\t\tepisode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\t\t\tbreak;\n\t\t} catch (const carla::rpc::Exception &e) {\n\t\t\tif (e.error_code == carla::rpc::ErrorCode::EpisodeNotFound) {\n\t\t\t\tif (timeout.count() <= 0) {\n\t\t\t\t\tthrow carla::Exception(carla::rpc::ErrorCode::EpisodeNotFound, \"Episode not found\");\n\t\t\t\t}\n\t\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t\t} else {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\treturn episode;\n}", "CodeBleu_score": 43.03468335314289}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tpisodeProxy episode = EpisodeProxy(_client.LoadEpisode(map_name, reset_settings, map_layers));\n\tif (episode.GetEpisodeId() == 0) {\n\t\tthrow std::runtime_error(\"Failed to load episode\");\n\t}\n\treturn episode;\n}", "CodeBleu_score": 24.22418427359864}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tpisodeProxy episode;\n\tauto attempts = 0;\n\twhile (true) {\n\t\tif (attempts > 10) {\n\t\t\tthrow std::runtime_error(\"Could not connect to the simulator within the allowed number of attempts.\");\n\t\t}\n\t\ttry {\n\t\t\tepisode = LoadEpisode(map_name, reset_settings, map_layers, 5000);\n\t\t\tbreak;\n\t\t} catch (const std::runtime_error &e) {\n\t\t\tattempts++;\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(500));\n\t\t}\n\t}\n\treturn episode;\n}", "CodeBleu_score": 31.3632961537752}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode!= nullptr);\n\tauto nav = _episode->CreateNavigationIfMissing();\n\tauto walker = nav->GetWalker(controller.id);\n\tif (!walker) {\n\t\tthrow_exception(std::runtime_error(\"walker not found\"));\n\t}\n\twalker->RegisterAIController(controller);\n}", "CodeBleu_score": 58.07489980593839}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode!= nullptr);\nauto nav = _episode->CreateNavigationIfMissing();\nnav->RegisterWalkerAIController(controller);\n}", "CodeBleu_score": 38.908861013205765}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode!= nullptr);\n\tauto nav = _episode->CreateNavigationIfMissing();\n\tauto walker = nav->GetWalker(controller.walker_id);\n\tif (!walker) {\n\t\tthrow_exception(std::runtime_error(\n\t\t\t\"walker with id \" + std::to_string(controller.walker_id) + \" not found\"));\n\t}\n\twalker->RegisterAIController(controller);\n}", "CodeBleu_score": 59.64841710054019}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t/*\n * This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.\n * It first ensures that the episode is valid, then subscribes to the sensor's data stream using the client's SubscribeToStream method.\n * The callback is set to deserialize the incoming data, associate it with the current episode, and then invoke the provided callback with the sensor data.\n */\n    DEBUG_ASSERT(_episode!= nullptr);\n    _client.SubscribeToStream(sensor.GetId(), [this, callback](const rpc::SensorData &data) {\n      auto sensor_data = sensor::SensorData::Deserialize(data);\n      sensor_data->SetEpisode(GetCurrentEpisode());\n      callback(sensor_data);\n    });\n  }", "CodeBleu_score": 41.44427456661684}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\nstd::vector<std::shared_ptr<Walker>> walkers;\n\nif (episode->GetWalkerCount() == 0) {\nreturn;\n}\n\nauto state = episode->GetState();\n\nif (state.IsDone()) {\nreturn;\n}\n\nauto crowd = _nav.GetCrowd();\n\nfor (auto& walker : crowd->GetWalkers()) {\nwalker->SetTransform(walker->GetTransform());\n}\n\nfor (auto& walker : crowd->GetWalkers()) {\nauto transform = walker->GetTransform();\nauto speed = walker->GetSpeed();\n\nwalker->SetTransform(transform);\nwalker->SetSpeed(speed);\n}\n\nauto dead_walkers = crowd->GetDeadWalkers();\nfor (auto& walker : dead_walkers) {\nauto controller = walker->GetController();\nif (controller) {\ncontroller->Destroy();\n}\n}\n\n}", "CodeBleu_score": 30.936832611431885}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Retrieve the list of walkers in the episode.\n\tauto walkers = episode->GetWalkerData();\n\n\t// Check if there are any walkers in the episode.\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Retrieve the current state of the episode.\n\tauto state = episode->GetState();\n\n\t// Remove any walkers that no longer exist.\n\tauto removed_walkers = std::remove_if(walkers.begin(), walkers.end(),\n\t\t[&](const std::shared_ptr<WalkerData>& walker) {\n\t\t\treturn!walker->Exists();\n\t\t});\n\twalkers.erase(removed_walkers, walkers.end());\n\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module.\n\t_nav.UpdateCrowd(walkers);\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n\tfor (auto walker : walkers) {\n\t\tauto transform = walker->GetTransform();\n\t\tauto speed = walker->GetSpeed();\n\n\t\t_simulator.lock()->ApplyWalkerBatch({\n\t\t\trpc::Command::SetTransform(transform),\n\t\t\trpc::Command::SetSpeed(speed),\n\t\t\trpc::Command::SetWalkerControl(walker->GetControl())\n\t\t});\n\t}\n\n\t// Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n\tfor (auto walker : walkers) {\n\t\tif (walker->IsDead()) {\n\t\t\t_nav.RemoveWalker(walker->GetId());\n\t\t\twalker->DestroyController();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.15425380425615}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t", "CodeBleu_score": 4.932770825794737}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = _uid;\n\tdescription.id = _id;\n\tdescription.attributes.reserve(_attributes.size());\n\tfor (auto &attribute : _attributes) {\n\t\tdescription.attributes.push_back(attribute.second.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 77.84273955005796}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\n/*\n * The following code is generated by the RPC generator.\n *\n * It creates an rpc::ActorDescription object. It initializes the description with the UID and ID of the actor.\n * It then reserves space for the attributes and copies each attribute from the ActorBlueprint to the description.\n * Finally, it returns the fully constructed rpc::ActorDescription object.\n */\n  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeAttributeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 83.9988739578627}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t/*\n * This function, BlueprintLibrary::FilterByAttribute, filters blueprints by a specified attribute name and value.\nIt iterates through the blueprints, checks if the attribute exists, and compares its value or recommended values to the specified value.\nMatching blueprints are added to the result.\nFinally, it returns a new BlueprintLibrary containing the filtered blueprints.\n */\n    map_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.HasAttribute(name)) {\n        if (pair.second.GetAttribute(name) == value) {\n          result.emplace(pair);\n        } else if (pair.second.GetAttribute(name) == \"Any\") {\n          result.emplace(pair);\n        } else {\n          // Check if the value is in the recommended values.\n          auto recommended_values = pair.second.GetAttribute(name);\n          auto found = std::find(recommended_values.begin(), recommended_values.end(), value);\n          if (found!= recommended_values.end()) {\n            result.emplace(pair);\n          }\n        }\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 62.4122651264045}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\nmap_type result;\n\nfor (auto &pair : _blueprints) {\nif (pair.second.HasAttribute(name)) {\nif (pair.second.GetAttribute(name) == value) {\nresult.emplace(pair);\n}\nelse if (pair.second.GetAttribute(name).find(value)!= std::string::npos) {\nresult.emplace(pair);\n}\n}\n}\n\nreturn SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 44.34491989299376}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t", "CodeBleu_score": 7.837249333138888}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Construct the full file path using a base folder and version information\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Validate the file path\n\tif (fullpath.empty()) return false;\n\n\t// Open the file in binary mode to truncate its contents\n\tFILE* file = fopen(fullpath.c_str(), \"wb\");\n\tif (file == NULL) return false;\n\n\t// Write the content to the file\n\tfwrite(content.data(), 1, content.size(), file);\n\n\t// Close the file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 47.82169776057063}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Construct the full file path using a base folder and version information\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Validate the file path\n\tif (path.empty()) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file\n\tfile.write((char*) content.data(), content.size());\n\n\t// Close the file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 53.052319103764276}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Construct the full file path\n\tstd::string fullpath = _filesBaseFolder;\n\tfullpath += \"/\";\n\tfullpath += ::carla::version();\n\tfullpath += \"/\";\n\tfullpath += path;\n\n\t// Validate the file path\n\tif (path.empty()) return false;\n\tif (path[0] == '/') return false;\n\n\t// Open the file in binary mode to truncate its contents\n\tFILE *file = fopen(fullpath.c_str(), \"wb\");\n\tif (file == nullptr) return false;\n\n\t// Write the content to the file\n\tfwrite(content.data(), 1, content.size(), file);\n\n\t// Close the file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 47.880518581163365}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// Make sure the parent is alive.\nauto parent = snapshot.Find(_parent);\nif (!parent) {\n  return nullptr;\n}\n\n// Calculate the location by adding the parent's bounding box location to the transform's location.\nconst auto location = _parent_bounding_box.location + transform.location;\n\n// Calculate the four corners of the bounding box by rotating the extents based on the yaw angle.\nconst auto yaw = transform.rotation.yaw;\nconst auto extents = _parent_bounding_box.extents;\nconst auto corner_0 = Rotate(yaw, location - extents);\nconst auto corner_1 = Rotate(yaw, location + geom::Vector3D(extents.x, -extents.y, 0.0f));\nconst auto corner_2 = Rotate(yaw, location + extents);\nconst auto corner_3 = Rotate(yaw, location + geom::Vector3D(-extents.x, -extents.y, 0.0f));\n\n// Create a shared pointer to a Bounds object containing the frame number and the calculated corners.\nreturn MakeShared<Bounds>(frame, {corner_0, corner_1, corner_2, corner_3});\n}", "CodeBleu_score": 50.49514257410742}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nstd::vector<LightState> lights_state;\n_server->QueryLightsState(lights_state);\n_lights_state.clear();\nfor(const LightState& light_state : lights_state) {\nauto it = _lights.find(light_state._id);\nif(it == _lights.end()) {\n_lights[light_state._id] = Light(light_state._id);\n}\n_lights_state[light_state._id] = light_state;\n}\n_dirty = false;\n}", "CodeBleu_score": 38.26845541102081}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nstd::vector<Light> lights = _client->GetWorld()->GetLights();\nfor(Light light : lights) {\nif(_lights.find(light._id) == _lights.end()) {\n_lights[light._id] = light;\n}\n_lights_state[light._id] = LightState(light._color, light._intensity, light._group, light._active);\n}\n_dirty = false;\n}", "CodeBleu_score": 33.273109763086076}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\nstd::vector<Light> server_lights = _server_client->GetLights();\n\nfor(const Light& light : server_lights) {\nauto it = _lights.find(light._id);\nif(it == _lights.end()) {\n_lights.emplace(light._id, light);\n}\n\nLightState& state = _lights_state[light._id];\nstate._active = light._state._active;\nstate._color = light._state._color;\nstate._intensity = light._state._intensity;\nstate._group = light._state._group;\n}\n}", "CodeBleu_score": 42.59334954048694}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif(_dirty) {\nstd::vector<rpc::LightState> message;\nfor(const auto& it : _lights_changes) {\nmessage.push_back(rpc::LightState(it.second._id, it.second._intensity, it.second._color.r, it.second._color.g, it.second._color.b, it.second._group, it.second._active));\n}\n_episode.Lock()->GetServer().Send(message);\n_dirty = false;\n}\nif(discard_client) {\n_lights_changes.clear();\n}\n}", "CodeBleu_score": 45.087239325962344}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif(_dirty) {\nstd::vector<rpc::LightState> light_states;\nfor(const auto& it : _lights_changes) {\nlight_states.push_back(rpc::LightState(\n    it.second._id,\n    it.second._color.r,\n    it.second._color.g,\n    it.second._color.b,\n    it.second._intensity,\n    it.second._group,\n    it.second._active\n));\n}\n_episode.Lock()->SendLightsStateToServer(light_states, discard_client);\n_lights_changes.clear();\n_dirty = false;\n}\n}", "CodeBleu_score": 48.56854919383365}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif(!_dirty)\nreturn;\n\n// Create message\nstd::vector<rpc::LightState> message;\nfor(const auto& it : _lights_changes)\nmessage.push_back(rpc::LightState(\nit.second._color.r,\nit.second._color.g,\nit.second._color.b,\nit.second._intensity,\nstatic_cast<rpc::LightGroup>(it.second._group),\nit.second._active\n));\n\n// Send message\n_episode.Lock()->SendLightsStateToServer(message, discard_client);\n\n// Clear changes\n_lights_changes.clear();\n_dirty = false;\n}", "CodeBleu_score": 43.371982303067405}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tf (GetDisplayId()!= \"sensor.other.v2x_custom\") {\nlog_warning(\n\"attempting to send message to sensor with ID different than sensor.other.v2x_custom:\",\nGetDisplayId());\nreturn;\n}\nlog_debug(\"calling sensor Send() \", GetDisplayId());\nGetEpisode().Lock()->SendToSensor(*this, message);\n}", "CodeBleu_score": 63.694890090088016}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (GetContext().id!= \"sensor.other.v2x_custom\") {\nlog_warning(\n\"attempting to send a message to a sensor that is not \\\"sensor.other.v2x_custom\\\":\",\nGetDisplayId());\nreturn;\n}\n\nlog_debug(\"calling sensor Send() \", GetDisplayId());\n\nGetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 61.77694833653881}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"attempting to send a message to a sensor that is not a v2x_custom sensor\", GetDisplayId());\n\t\treturn;\n\t}\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\tGetEpisode().Lock()->SendV2XMessage(message, GetContext());\n}", "CodeBleu_score": 60.95453028409236}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tauto tm = GetActorList().GetTrafficManager(tm_port);\n\tif (enabled) {\n\t\ttm->RegisterActor(this);\n\t} else {\n\t\ttm->UnregisterActor(this);\n\t}\n}", "CodeBleu_score": 43.38131045870654}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tTM::RegisterVehicle(this, tm_port);\n\t} else {\n\t\tTM::UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 31.82747857608858}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tauto &tm = detail::Simulator::GetInstance().GetTrafficManager();\n\tif (enabled) {\n\t\ttm.RegisterVehicle(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 45.20051449651342}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor.\n\tauto walker_actor = GetActor();\n\n\t// Add the walker actor to the navigation system.\n\tauto& navigation = detail::Simulator::GetInstance().GetNavigation();\n\tnavigation.AddActor(walker_actor);\n\n\t// Disable the physics simulation and collisions for the walker actor.\n\twalker_actor->SetSimulatePhysics(false);\n\twalker_actor->SetEnableCollision(false);\n}", "CodeBleu_score": 28.195726829564936}, {"code": "void WalkerAIController::Start(){\n\t\tauto walker = GetWalker();\n\tauto actor_id = GetId();\n\tauto &navigation = detail::Simulator::GetInstance().GetNavigationSystem();\n\tnavigation.AddActor(actor_id, walker->GetLocation(), walker->GetRotation());\n\twalker->SetSimulatePhysics(false);\n\twalker->SetEnablePhysicsControl(false);\n\twalker->SetAutopilot(true);\n}", "CodeBleu_score": 37.50699503450009}, {"code": "void WalkerAIController::Start(){\n\t\tauto &walker = GetWalkerActor();\n\tauto &walker_navigation = GetWalkerNavigation();\n\twalker_navigation.AddWalker(walker.id, GetLocation());\n\twalker.SetSimulatePhysics(false);\n\twalker.SetEnableCollision(false);\n}", "CodeBleu_score": 27.670411504640903}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tav = GetEpisode().Lock()->GetNavigation();\n\tif (nav!= nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker!= nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed, \"(parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 71.23302088248639}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tav = GetEpisode().Lock()->GetNavigation();\n\tif (nav!= nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker!= nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set maximum speed to \", max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set maximum speed to \", max_speed, \"(parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 69.42822981382749}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tav = GetEpisode().Lock()->GetNavigation();\n\tif (nav!= nullptr) {\n\t\tauto walker = GetParent();\n\t\tif (walker!= nullptr) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"NAV: Failed to set max speed to \", max_speed, \"(parent does not exist)\");\n\t\t}\n\t}\n}", "CodeBleu_score": 71.23302088248639}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(waypoints.size());\n\tfor (auto &waypoint : waypoints) {\n\t\tresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n\t}\n\treturn result;\n}", "CodeBleu_score": 97.7382971857276}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\nstd::vector<SharedPtr<Landmark>> result;\n\nauto signals = GetSignalsInDistance(distance);\n\nfor (auto &signal : signals) {\n  if (signal.second.has_value()) {\n    auto signal_waypoint = signal.second.value();\n    if (signal_waypoint.road_id == _waypoint.road_id &&\n        signal_waypoint.lane_id == _waypoint.lane_id &&\n        signal_waypoint.s_position == _waypoint.s_position) {\n      continue;\n    }\n\n    auto signal_waypoint_ptr = SharedPtr<Waypoint>(new Waypoint(_parent, std::move(signal_waypoint)));\n    auto signal_landmark = SharedPtr<Landmark>(new Landmark(_parent, signal.first, signal_waypoint_ptr));\n    result.emplace_back(signal_landmark);\n  }\n}\n\nif (stop_at_junction) {\n  return result;\n}\n\nauto junctions = GetJunctionsInDistance(distance);\n\nfor (auto &junction : junctions) {\n  auto junction_waypoint = junction.second.value();\n  if (junction_waypoint.road_id == _waypoint.road_id &&\n      junction_waypoint.lane_id == _waypoint.lane_id &&\n      junction_waypoint.s_position == _waypoint.s_position) {\n    continue;\n  }\n\n  auto junction_waypoint_ptr = SharedPtr<Waypoint>(new Waypoint(_parent, std::move(junction_waypoint)));\n  auto junction_landmark = SharedPtr<Landmark>(new Landmark(_parent, junction.first, junction_waypoint_ptr));\n  result.emplace_back(junction_landmark);\n}\n\nreturn result;\n}", "CodeBleu_score": 51.64953914966536}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t", "CodeBleu_score": 7.227538970210187}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n//    std::cout << \"Waypoint::GetAllLandmarksInDistance(double distance, bool stop_at_junction) const called\" << std::endl;\n\n    std::vector<SharedPtr<Landmark>> result;\n    auto signals = GetSignalsInDistance(distance);\n    for (auto &signal : signals) {\n      auto signal_waypoint = _parent->GetMap().GetWaypoint(signal.GetSignalId());\n      if (signal_waypoint.has_value()) {\n        auto landmark = SharedPtr<Landmark>(new Landmark(_parent, std::move(*signal_waypoint)));\n        auto landmark_found = false;\n        for (auto &landmark_result : result) {\n          if (landmark_result->GetWaypoint() == landmark->GetWaypoint()) {\n            landmark_found = true;\n            break;\n          }\n        }\n        if (!landmark_found) {\n          result.emplace_back(landmark);\n        }\n      }\n    }\n\n    if (stop_at_junction) {\n      return result;\n    }\n\n    auto junctions = GetJunctionsInDistance(distance);\n    for (auto &junction : junctions) {\n      auto junction_waypoint = _parent->GetMap().GetWaypoint(junction.GetJunctionId());\n      if (junction_waypoint.has_value()) {\n        auto landmark = SharedPtr<Landmark>(new Landmark(_parent, std::move(*junction_waypoint)));\n        auto landmark_found = false;\n        for (auto &landmark_result : result) {\n          if (landmark_result->GetWaypoint() == landmark->GetWaypoint()) {\n            landmark_found = true;\n            break;\n          }\n        }\n        if (!landmark_found) {\n          result.emplace_back(landmark);\n        }\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 47.345970497812765}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// Set the timeout.\n\tif (timeout == time_duration::max()) {\n\t\ttimeout = _episode.Lock()->GetEpisodeSettings().GetNetworkingTimeout();\n\t}\n\t_episode.Lock()->SetTimeout(timeout);\n\t// Apply the settings.\n\tconst uint64_t id = _episode.Lock()->ApplySettings(settings);\n\t// Verify the settings.\n\tif (settings.HasFixedDeltaTime()) {\n\t\tconst double delta_time = settings.GetFixedDeltaTime().GetSeconds();\n\t\tconst uint64_t ticks = 100;\n\t\tconst double max_delta = delta_time * 0.01;\n\t\tdouble min_delta = delta_time;\n\t\tfor (uint64_t i = 0; i < ticks; ++i) {\n\t\t\tconst double start = _episode.Lock()->GetClock().Now().GetSeconds();\n\t\t\tconst double end = _episode.Lock()->GetClock().Now().GetSeconds();\n\t\t\tconst double delta = end - start;\n\t\t\tif (delta < min_delta) {\n\t\t\t\tmin_delta = delta;\n\t\t\t}\n\t\t\tif (delta > max_delta) {\n\t\t\t\tCARLA_LOG_E(\n\t\t\t\t\t\"Delta time verification failed. The provided delta time is not accurate enough. \"\n\t\t\t\t\t\"Please, check the documentation for further details.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (min_delta > 0.0) {\n\t\t\tCARLA_LOG_E(\n\t\t\t\t\"Delta time verification failed. The provided delta time is not accurate enough. \"\n\t\t\t\t\"Please, check the documentation for further details.\");\n\t\t}\n\t}\n\treturn id;\n}", "CodeBleu_score": 46.305836026101964}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tf (vertices.size() == 0) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum() + 2;\n AddVertices(vertices);\n while (i < GetVerticesNum()) {\n AddIndex(i - 1);\n AddIndex(i);\n AddIndex(i + 1);\n ++i;\n }\n }", "CodeBleu_score": 69.85510239232377}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tf (vertices.size() < 3) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum() + 1;\n AddVertices(vertices);\n while (i < GetVerticesNum()) {\n AddIndex(i - 1);\n AddIndex(i);\n ++i;\n }\n }", "CodeBleu_score": 61.878661654390434}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tf (vertices.size() < 3) {\n return;\n }\n size_t i = GetVerticesNum();\n AddVertices(vertices);\n while (i < GetVerticesNum()) {\n AddIndex(i);\n AddIndex(i - 1);\n AddIndex(i - 2);\n ++i;\n }\n }", "CodeBleu_score": 54.603348048638324}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\nDEBUG_ASSERT(message);\n\n_strand.post([this, message] {\n\nif (!_socket.is_open()) {\nCARLA_LOG_ERROR(\n\"Failed to write message to socket, socket is not open\");\nreturn;\n}\n\n// set timeout\n_deadline.expires_from_now(_timeout);\n\n// write message\nboost::asio::async_write(\n_socket,\nboost::asio::buffer(message->data(), message->size()),\nboost::asio::bind_executor(\n_strand,\n[this, message](boost::system::error_code ec, std::size_t bytes_transferred) {\n\nif (ec) {\nCARLA_LOG_ERROR(\n\"Failed to write message to socket, error: {}\",\nec.message());\n} else {\nCARLA_LOG_DEBUG(\n\"Wrote {} bytes to socket\",\nbytes_transferred);\n}\n\n// check if connection was closed\nif (ec == boost::asio::error::eof) {\nCARLA_LOG_DEBUG(\n\"Connection closed by peer\");\n}\n\n// close socket\nif (ec || ec == boost::asio::error::eof) {\nClose();\n}\n\n}));\n\n});\n\n}", "CodeBleu_score": 41.26343579056077}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\nDEBUG_ASSERT(message);\n\n\n// Ensure the message is valid.\n\nDEBUG_ASSERT(message->IsValid());\n\n\n// Post a lambda function to the strand to execute.\n\n_strand.post([this, message]() {\n\n\n// Check if the socket is open.\n\nif (!_socket.is_open()) {\n\n\n// Log an error and close the connection.\n\nCARLA_LOG_EVERY_N(Error, 1000) << \\\"[tcp multigpu server session \\\" << _session_id << \\\"] \\\"\n\n<< \\\"Connection closed by peer.\\\"\n\n<< \\\"Message: \\\" << message->ToString();\n\n\n// Close the connection.\n\nClose();\n\n\nreturn;\n\n}\n\n\n// Set a timeout.\n\n_deadline.expires_from_now(_timeout);\n\n\n// Initiate an asynchronous write.\n\nboost::asio::async_write(\n\n_socket,\n\nmessage->GetBuffer(),\n\nboost::asio::bind_executor(\n\n_strand,\n\nstd::bind(&Primary::HandleSent, shared_from_this(), std::placeholders::_1, std::placeholders::_2, message)));\n\n});\n\n}", "CodeBleu_score": 29.839577086971815}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\nDEBUG_ASSERT(message);\n\n\n\nif (!message->IsValid()) {\nCARLA_LOG_EVERYTHING(\n\"carla.streaming.tcp.primary\",\n\"Invalid message received. Closing connection.\");\n\nClose();\nreturn;\n}\n\n_strand.post([this, message] {\n\nif (!_socket.is_open()) {\nCARLA_LOG_EVERYTHING(\n\"carla.streaming.tcp.primary\",\n\"Connection closed. Closing connection.\");\n\nClose();\nreturn;\n}\n\n_deadline.expires_from_now(_timeout);\n\nboost::asio::async_write(\n_socket,\nboost::asio::buffer(message->data(), message->size()),\nboost::asio::bind_executor(\n_strand,\n[this, message](const boost::system::error_code &ec, std::size_t size) {\n\nif (ec) {\nCARLA_LOG_EVERYTHING(\n\"carla.streaming.tcp.primary\",\n\"Error sending message: \" << ec.message());\n\nClose();\nreturn;\n}\n\n_on_response(message->id(), size);\n\nif (message->id() == carla::streaming::detail::tcp::Message::Type::Close) {\nCARLA_LOG_EVERYTHING(\n\"carla.streaming.tcp.primary\",\n\"Connection closed. Closing connection.\");\n\nClose();\nreturn;\n}\n\nReadData();\n}));\n});\n}", "CodeBleu_score": 38.73779022374859}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (_deadline.expires_at() <= boost::asio::deadline_timer::traits_type::now()) {\n\t\tlog_debug(\"session \", _session_id, \" time out\");\n\t\tClose();\n\t} else {\n\t\t_deadline.cancel();\n\t\tif (!ec && _socket.is_open()) {\n\t\t\tboost::system::error_code ec;\n\t\t\t_socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n\t\t\t_socket.close();\n\t\t}\n\t\tif (_on_closed) {\n\t\t\t_on_closed(shared_from_this());\n\t\t}\n\t\tlog_debug(\"session \", _session_id, \" closed\");\n\t}\n}", "CodeBleu_score": 57.47258352222207}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\tboost::system::error_code ec;\n\t\t_socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n\t\t_socket.close();\n\t}\n\t_on_closed(shared_from_this());\n\tlog_debug(\"session \", _session_id, \" closed\");\n}", "CodeBleu_score": 59.653894279346176}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (_deadline.expires_at() <= boost::asio::deadline_timer::traits_type::now()) {\n\t\tlog_debug(\"session \", _session_id, \" time out\");\n\t\tClose();\n\t} else {\n\t\t_deadline.cancel();\n\t}\n\n\tif (!ec && _socket.is_open()) {\n\t\tboost::system::error_code ec;\n\t\t_socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n\t\t_socket.close();\n\t}\n\n\t_on_closed(shared_from_this());\n\tlog_debug(\"session \", _session_id, \" closed\");\n}", "CodeBleu_score": 57.37939969403184}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 19);\n\t_router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tlog_info(\"sending \\\"Are you alive?\\\" command\");\n\tauto fut = _router->WriteToNext(MultiGPUCommand::IS_ALIVE);\n\tauto response = fut.get();\n\tlog_info(\"got response: \\\"\", response.buffer, \"\\\"\");\n}", "CodeBleu_score": 58.70493419678331}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((unsigned char *) \"Are you alive?\", (size_t) 17);\n\t_router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tlog_info(\"sending is alive command\");\n\tauto fut = _router->ReadFromNext(MultiGPUCommand::YOU_ALIVE);\n\tauto response = fut.get();\n\tlog_info(\"received is alive response: \", response.buffer);\n}", "CodeBleu_score": 68.18433008845791}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tcarla::Buffer buf((unsigned char *) \"Are you alive?\", (size_t) 17);\n\t_router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\tlog_info(\"sending is alive command\");\n\tauto response = _router->ReadFromNext(MultiGPUCommand::YOU_ALIVE).get();\n\tlog_info(\"received response: \", response.buffer.data());\n}", "CodeBleu_score": 64.7837623250672}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor is found on any secondary server.\n\tbool found = false;\n\tfor (auto& secondary : _router->GetSecondaryServers()) {\n\t\tif (secondary->IsSensorEnabled(sensor_id)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If the sensor is found, create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router.\n\tif (found) {\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n\t\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\t\tauto response = fut.get();\n\t}\n\t// If the sensor is not found, log an error message.\n\telse {\n\t\tlog_error(\"The sensor with ID {} is not found on any secondary server.\", sensor_id);\n\t}\n}", "CodeBleu_score": 65.76538666415689}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(sensor_id));\nauto response = fut.get();\nif (response.buffer.size() > 0) {\nlog_info(\"Sensor ID: \", sensor_id, \" is enabled for ROS\");\n} else {\nlog_error(\"Sensor ID: \", sensor_id, \" is not enabled for ROS\");\n}\n}", "CodeBleu_score": 37.19192974790174}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tlog_info(\"sending enable for ros\");\n\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n\tauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n\n\tauto response = fut.get();\n\tlog_info(\"response from enable for ros: \", response.buffer.data());\n}", "CodeBleu_score": 49.623234287690366}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tsearch if the sensor has been activated in any secondary server\nauto it = _servers.find(sensor_id);\nif (it!= _servers.end()) {\ncarla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                  (size_t) sizeof(stream_id));\nauto fut = _router->WriteToOne(it->second, MultiGPUCommand::GET_TOKEN, std::move(buf));\n\nauto response = fut.get();\ntoken_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\nlog_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\nreturn new_token;\n} else {\nlog_error(\"token for sensor\", sensor_id, \" not found on any server\");\nreturn token_type();\n}\n}", "CodeBleu_score": 46.64409733777236}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tg_info(\"asking for a token\");\n\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n\tauto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n\tauto response = fut.get();\n\ttoken_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n\tlog_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n\treturn new_token;\n}", "CodeBleu_score": 35.622027672749425}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t search if the sensor has been activated in any secondary server\n\tauto it = _servers.find(sensor_id);\n\tif (it!= _servers.end()) {\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n\t\t\t\t(size_t) sizeof(stream_id));\n\t\tauto fut = _router->WriteToOne(it->second, MultiGPUCommand::GET_TOKEN,\n\t\t\t\tstd::move(buf));\n\n\t\tauto response = fut.get();\n\t\ttoken_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(\n\t\t\t\tresponse.buffer.data()));\n\t\tlog_info(\"got a token: \", new_token.get_stream_id(), \", \",\n\t\t\t\tnew_token.get_port());\n\t\treturn new_token;\n\t} else {\n\t\tlog_info(\"asking for a token\");\n\t\tcarla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n\t\t\t\t(size_t) sizeof(stream_id));\n\t\tauto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN,\n\t\t\t\tstd::move(buf));\n\n\t\tauto response = fut.get();\n\t\ttoken_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(\n\t\t\t\tresponse.buffer.data()));\n\t\tlog_info(\"got a token: \", new_token.get_stream_id(), \", \",\n\t\t\t\tnew_token.get_port());\n\t\treturn new_token;\n\t}\n}", "CodeBleu_score": 44.870308344084044}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\n//  std::cout << \"Loading navigation data from: \" << filename << std::endl;\n\n//  std::ifstream file(filename, std::ios::binary);\n//  if (!file.is_open()) {\n//    return false;\n//  }\n//\n//  std::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n//  file.close();\n//\n//  return Load(buffer);\n}", "CodeBleu_score": 4.959533208684141}, {"code": "bool Navigation::Load(const std::string &filename){\n\t", "CodeBleu_score": 4.792014253953123}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream file(filename, std::ios::in | std::ios::binary);\n\tif (!file.is_open()) {\n\t\tCARLA_ERROR_SLOW(\n\t\t\t\"Navigation::Load: cannot open file '%s' for reading\", filename.c_str());\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(buffer);\n}", "CodeBleu_score": 52.58348099918982}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// check if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\n\t// find the walker\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\t// get the index found\n\t\tint index = it->second;\n\t\tif (index!= -1) {\n\t\t\t// remove the walker\n\t\t\t{\n\t\t\t\t// critical section, force single thread running this\n\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t_crowd->removeAgent(index);\n\t\t\t}\n\n\t\t\t// update the walker manager\n\t\t\t_walker_manager.RemoveWalker(id);\n\n\t\t\t// remove the id\n\t\t\t_mapped_walkers_id.erase(it);\n\t\t\t_mapped_by_index.erase(index);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// find the vehicle\n\tit = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\t// get the index found\n\t\tint index = it->second;\n\t\tif (index!= -1) {\n\t\t\t// remove the vehicle\n\t\t\t{\n\t\t\t\t// critical section, force single thread running this\n\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t_crowd->removeAgent(index);\n\t\t\t}\n\n\t\t\t// update the vehicle manager\n\t\t\t_vehicle_manager.RemoveVehicle(id);\n\n\t\t\t// remove the id\n\t\t\t_mapped_vehicles_id.erase(it);\n\t\t\t_mapped_by_index.erase(index);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 71.37135823587481}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\n\t// search for the id in walker\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\t// get the index found\n\t\tint index = it->second;\n\t\tif (index!= -1) {\n\t\t\t// remove the walker\n\t\t\t_walker_manager.RemoveWalker(id);\n\t\t\t// remove the agent\n\t\t\t{\n\t\t\t\t// critical section, force single thread running this\n\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t_crowd->removeAgent(index);\n\t\t\t}\n\t\t\t// remove the id\n\t\t\t_mapped_walkers_id.erase(it);\n\t\t\t_mapped_by_index.erase(index);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// search for the id in vehicles\n\tit = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\t// get the index found\n\t\tint index = it->second;\n\t\tif (index!= -1) {\n\t\t\t// remove the vehicle\n\t\t\t{\n\t\t\t\t// critical section, force single thread running this\n\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t_crowd->removeAgent(index);\n\t\t\t}\n\t\t\t// remove the id\n\t\t\t_mapped_vehicles_id.erase(it);\n\t\t\t_mapped_by_index.erase(index);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 71.46674904606016}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// check if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\n\t// search for the agent id in the walker and vehicle mappings\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\t// get the index found\n\t\tint index = it->second;\n\t\tif (index!= -1) {\n\t\t\t// remove the walker from the crowd\n\t\t\t{\n\t\t\t\t// critical section, force single thread running this\n\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t_crowd->removeAgent(index);\n\t\t\t}\n\n\t\t\t// remove the walker from the walker manager\n\t\t\t_walker_manager.RemoveWalker(id);\n\n\t\t\t// remove the id from the mappings\n\t\t\t_mapped_walkers_id.erase(it);\n\t\t\t_mapped_by_index.erase(index);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tit = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\t// get the index found\n\t\tint index = it->second;\n\t\tif (index!= -1) {\n\t\t\t// remove the vehicle from the crowd\n\t\t\t{\n\t\t\t\t// critical section, force single thread running this\n\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t_crowd->removeAgent(index);\n\t\t\t}\n\n\t\t\t// remove the vehicle from the vehicle manager\n\t\t\t_vehicle_manager.RemoveVehicle(id);\n\n\t\t\t// remove the id from the mappings\n\t\t\t_mapped_vehicles_id.erase(it);\n\t\t\t_mapped_by_index.erase(index);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 71.37135823587481}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tconst WalkerEvent &event = info.route[info.currentIndex];\n\t// create a visitor\n\tWalkerEventVisitor visitor(id, info.from, info.to, delta, _simulator);\n\t// execute the event\n\tboost::variant2::visit(visitor, event);\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 58.095300082829546}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tWalkerEvent &event = info.route[info.currentIndex];\n\t// create a visitor\n\tWalkerEventVisitor visitor(_simulator, id, info.from, info.to);\n\t// process the event\n\tboost::variant2::visit(visitor, event);\n\t// return the result\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 55.07595212740792}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// check\n\tif (_nav == nullptr)\n\t\treturn EventResult::Continue;\n\n\t// get the current route point\n\tWalkerEventVisitor visitor(id, info.route[info.currentIndex].location, delta, _simulator);\n\n\t// process the event\n\tboost::variant2::visit(visitor, info.route[info.currentIndex].event);\n\n\t// return the result\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 47.34943421645349}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * Iterate through each road node.\n */\n  for (pugi::xml_node road_node : xml.children(\"road\")) {\n\n/*\n * Retrieve the road ID and call the ParseLanes method to process each lane section.\n */\n    const std::string road_id = road_node.attribute(\"id\").value();\n    ParseLanes(road_node, map_builder, road_id);\n  }\n}", "CodeBleu_score": 22.581455075243078}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * Iterate through each road node in the XML document.\n */\n  for (pugi::xml_node road_node : xml.child(\"roadNetwork\").children(\"road\")) {\n\n/*\n * Retrieve the road ID from the road node.\n */\n    const std::string road_id = road_node.attribute(\"id\").value();\n\n/*\n * Create a new road with the road ID and add it to the map builder.\n */\n    map_builder.CreateRoad(road_id);\n\n/*\n * Iterate through each lane section node under the lanes node.\n */\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n/*\n * Retrieve the lane ID from the lane section node.\n */\n      const std::string lane_id = lane_section_node.attribute(\"id\").value();\n\n/*\n * Create a new lane with the lane ID and add it to the road.\n */\n      carla::road::Lane *lane = map_builder.CreateLane(road_id, lane_id);\n\n/*\n * Parse the left, center, and right lane nodes.\n */\n      ParseLanes(lane_section_node, lane, map_builder);\n    }\n  }\n}", "CodeBleu_score": 38.98680322256958}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n//  std::cout << \"on_publication_matched\" << std::endl;\n\n  if (info.current_count_change() == 0) {\n    return;\n  }\n\n  if (info.current_count() == 0) {\n    if (info.previous_count() == 0) {\n      std::cout << \"No match\" << std::endl;\n      return;\n    }\n    std::cout << \"No match\" << std::endl;\n    _matched = 0;\n    _first_connected = false;\n  } else if (info.current_count() == 1) {\n    if (info.previous_count() == 0) {\n      std::cout << \"Match\" << std::endl;\n      _matched = 1;\n      _first_connected = true;\n    } else {\n      std::cout << \"Match\" << std::endl;\n      _matched = 1;\n    }\n  } else {\n    std::cout << \"Invalid match\" << std::endl;\n    _matched = -1;\n  }\n}", "CodeBleu_score": 52.60805559649482}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change() > 0) {\n\t\t_matched += info.current_count_change();\n\t\tif (!_first_connected) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change() < 0) {\n\t\t_matched += info.current_count_change();\n\t} else {\n\t\tstd::cerr << \"Invalid count change: \" << info.current_count_change() << std::endl;\n\t}\n}", "CodeBleu_score": 58.38820907770147}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change() > 0) {\n\t\tif (info.current_count() == 1) {\n\t\t\tif (!_first_connected) {\n\t\t\t\t_matched++;\n\t\t\t\t_first_connected = true;\n\t\t\t} else {\n\t\t\t\t_matched++;\n\t\t\t}\n\t\t} else {\n\t\t\t_matched++;\n\t\t}\n\t} else if (info.current_count_change() < 0) {\n\t\tif (info.current_count() == 0) {\n\t\t\t_matched--;\n\t\t\t_first_connected = false;\n\t\t} else {\n\t\t\t_matched--;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Error: invalid count change\" << std::endl;\n\t}\n}", "CodeBleu_score": 53.03094203006397}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == efd::SubscriptionMatchedStatus::SUBSCRIPTION_MATCHED_STATUS_CURRENT_COUNT_ZERO) {\nif (info.total_count == 0) {\nif (_first_connected) {\nstd::cout << \"No more subscribers for \" << _owner->get_topic_name() << std::endl;\n_owner->destroy_subscriber();\n}\n} else {\nif (!_first_connected) {\nstd::cout << \"New subscriber for \" << _owner->get_topic_name() << std::endl;\n_first_connected = true;\n}\n}\n} else if (info.current_count_change == efd::SubscriptionMatchedStatus::SUBSCRIPTION_MATCHED_STATUS_CURRENT_COUNT_POSITIVE) {\n_matched += info.current_count_change;\n} else if (info.current_count_change == efd::SubscriptionMatchedStatus::SUBSCRIPTION_MATCHED_STATUS_CURRENT_COUNT_NEGATIVE) {\n_matched += info.current_count_change;\n} else {\nstd::cerr << \"Invalid change count \" << info.current_count_change << \" for \" << _owner->get_topic_name() << std::endl;\n}\n}", "CodeBleu_score": 59.265124460422584}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == efd::NO_COUNT_CHANGE) {\n\t\tstd::cerr << \"Invalid change count in subscription matched status\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (info.current_count == 0) {\n\t\t_matched--;\n\t\tif (_matched == 0) {\n\t\t\t_owner->_destroy_subscriber();\n\t\t}\n\t} else {\n\t\t_matched++;\n\t\tif (!_first_connected) {\n\t\t\t_first_connected = true;\n\t\t\t_owner->_create_subscriber();\n\t\t}\n\t}\n}", "CodeBleu_score": 51.068890842015634}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == efd::SubscriptionMatchedStatus::SUBSCRIPTION_MATCHED) {\n\t\t++_matched;\n\t\tif (_matched == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == efd::SubscriptionMatchedStatus::SUBSCRIPTION_UNMATCHED) {\n\t\t--_matched;\n\t\tif (_matched == 0) {\n\t\t\t_first_connected = false;\n\t\t\t_owner->destroy();\n\t\t}\n\t} else {\n\t\tstd::cerr << \"Error: Subscription change count is invalid.\" << std::endl;\n\t}\n}", "CodeBleu_score": 53.313424460212445}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\tif (isGetKeyDefined()) {\n\t\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n\t\t\t\tCarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\t\teprosima::fastcdr::Cdr ser(fastbuffer,\n\t\t\t\teprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\t\tp_type->serializeKey(ser);\n\t\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\t\tm_md5.init();\n\t\t\tm_md5.update(m_keyBuffer,\n\t\t\t\t\tCarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\t\t\tm_md5.finalize();\n\t\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (uint8_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize();\n\t\t\t\t\t++i) {\n\t\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 83.30491959981791}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\tif (m_isGetKeyDefined) {\n\t\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n\t\t\t\tCarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\t\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\t\tp_type->serializeKey(ser);\n\t\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\t\tm_md5.finalize();\n\t\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(&handle->value[0], m_keyBuffer, 16);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 74.06485659990551}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tf FASTRTPS_API_VERSION >= 11\n            // Object to serialize\n            const CarlaEgoVehicleControl* m_data = static_cast<const CarlaEgoVehicleControl*>(data);\n            // Create a buffer\n            eprosima::fastcdr::FastBuffer fastbuffer;\n            // Create a CDR object\n            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n                    eprosima::fastcdr::Cdr::DDS_CDR);\n            // Serialize encapsulation\n            ser.serialize_encapsulation();\n            // Serialize the object\n            m_data->serialize(ser);\n            // Finalize the buffer\n            payload->encapsulation = ser.getEncapsulation();\n            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n            payload->data = reinterpret_cast<uint8_t*>(malloc(payload->length));\n            memcpy(payload->data, ser.getSerializedData(), payload->length);\n            return true;\n#else\n            return false;\n#endif\n        }", "CodeBleu_score": 62.80260002355655}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tf defined(FASTCDR_FORCE_ALIGNED_PACKING_MODE)\n#pragma pack(push, 1)\n#endif\n            CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n            // Serialize encapsulation\n            ser.serialize_encapsulation();\n            try {\n                // Serialize the object:\n                p_type->serialize(ser);\n            }\n            catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n                return false;\n            }\n            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n            return true;\n#if defined(FASTCDR_FORCE_ALIGNED_PACKING_MODE)\n#pragma pack(pop)\n#endif\n        }", "CodeBleu_score": 84.52958515567343}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t/ Object to serialize\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n\t// Serialize encapsulation\n\teprosima::fastcdr::FastBuffer fastbuffer(1024);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS?\n\t\t\t\tSerializedPayload_t::ENCAPSULATION_ENCAPSULATED : SerializedPayload_t::ENCAPSULATION_PLAIN;\n\n\t// Serialize the object: use a temporary buffer to avoid issuing another call to m_data.\n\teprosima::fastcdr::FastBuffer fastbuffertmp(1024);\n\teprosima::fastcdr::Cdr sertmp(fastbuffertmp, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tsertmp.serialize_object(*p_type);\n\tpayload->length = static_cast<uint32_t>(sertmp.getSerializedDataLength());\n\tpayload->data = reinterpret_cast<uint8_t*>(malloc(payload->length));\n\tmemcpy(payload->data, sertmp.getSerializedData(), payload->length);\n\n\treturn true;\n}", "CodeBleu_score": 61.23914252699385}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.g.sysid_target!= 0) {\n\t\treturn;\n\t}\n\n\ttracker.g.sysid_target = msg.sysid;\n\n\t// request position and air pressure data streams from the target\n\tmavlink_request_data_stream_t request;\n\trequest.target_system = tracker.g.sysid_target;\n\trequest.target_component = tracker.g.compid;\n\trequest.req_stream_id = MAV_DATA_STREAM_POSITION;\n\trequest.req_message_rate = 1;\n\trequest.start_stop = 1;\n\tmavlink_msg_request_data_stream_encode(tracker.g.sysid, tracker.g.compid, &request, &tracker.msg);\n\ttracker.send_message(tracker.msg);\n\n\trequest.req_stream_id = MAV_DATA_STREAM_RAW_PRESSURE;\n\trequest.req_message_rate = 1;\n\trequest.start_stop = 1;\n\tmavlink_msg_request_data_stream_encode(tracker.g.sysid, tracker.g.compid, &request, &tracker.msg);\n\ttracker.send_message(tracker.msg);\n\n\ttracker.g.target_set = true;\n}", "CodeBleu_score": 45.77134597374541}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 28.352534043391863}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 7.704762978796939}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t// set flag to indicate that altitude calibration is needed on next barometer update\n\t\ttracker.need_altitude_calibration = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 67.95045786686414}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\t// arm\n\t\tif (tracker.gcs().arm_disarm(true)) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else if (packet.param1 == 0.0f) {\n\t\t// disarm\n\t\tif (tracker.gcs().arm_disarm(false)) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 53.360246704693346}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\t// arm\n\t\tif (gcs().arm_disarm_servos(true)) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else if (packet.param1 == 0.0f) {\n\t\t// disarm\n\t\tif (gcs().arm_disarm_servos(false)) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else {\n\t\t// unsupported\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 51.97129522470224}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\ttracker.gcs().arm_disarm(1);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0f) {\n\t\ttracker.gcs().arm_disarm(0);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 56.77734384566106}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < GCS_CHANNEL_COUNT; i++) {\n\t\tif (gcs_channels[i].has_payload_space()) {\n\t\t\tgcs_channels[i].request_datastream(sysid, compid, MAVLINK_MSG_ID_POSITION, 10);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.348740263707484}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (gcs_channels[i].available()) {\n\t\t\tgcs_channels[i].request_datastream(sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.56468429674731}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels\n\tfor (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n\t\t// Check for available payload space\n\t\tif (gcs_channels[i].payload_space() >= sizeof(mavlink_message_t)) {\n\t\t\t// Send the request to start the data stream on the corresponding channel\n\t\t\tmavlink_msg_request_data_stream_pack(sysid, compid, &gcs_channels[i].gcs_mavlink_channel, 1, 1, 1, 10);\n\t\t\t// Print the request\n\t\t\tprintf(\"Requesting position data stream from system %d with component ID %d\n\", sysid, compid);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.410750350503115}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = ahrs.cos_roll() * pitch + ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n\tef_yaw = -ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\treturn true;\n}", "CodeBleu_score": 64.96788929147273}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch()!= 0) {\n\t\tef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n\t\tef_yaw = ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 64.4881417090279}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch() == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = ahrs.cos_roll() * pitch + ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n\tef_yaw = -ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\treturn true;\n}", "CodeBleu_score": 64.96788929147273}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// Set the target yaw and pitch based on the navigation status and parameters\n\tif (target_distance_valid) {\n\t\t// If the target distance is valid, set the target yaw and pitch\n\t\ttarget_yaw = (float) navigation_status.heading_cd;\n\t\ttarget_pitch = (float) navigation_status.pitch_cd;\n\t} else {\n\t\t// If the target distance is invalid, set the target yaw and pitch to the current yaw and pitch\n\t\ttarget_yaw = (float) navigation_status.yaw_cd;\n\t\ttarget_pitch = (float) navigation_status.pitch_cd;\n\t}\n\n\t// If the target yaw is reversed, set the target yaw to the negative of the current yaw\n\tif (target_yaw_reversed) {\n\t\ttarget_yaw = -target_yaw;\n\t}\n\n\t// Compute the angle error\n\tfloat yaw_error = target_yaw - navigation_status.yaw_cd;\n\tfloat pitch_error = target_pitch - navigation_status.pitch_cd;\n\n\t// Convert the errors from earth frame to body frame\n\tyaw_error = -yaw_error;\n\tpitch_error = -pitch_error;\n\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n\tif (target_distance_valid ||!minimum_distance_valid) {\n\t\t// Update the pitch servo\n\t\tpitch_servo.update(pitch_error);\n\n\t\t// Update the yaw servo\n\t\tyaw_servo.update(yaw_error);\n\t}\n}", "CodeBleu_score": 34.97506460571208}, {"code": "void Mode::update_auto(void){\n\t\t// TODO: Update target yaw and pitch for the tracker based on navigation status and parameters.\n\t// Calculate the yaw and pitch in centidegrees, check if the direction is reversed, and compute the angle error.\n\t// Convert the errors from earth frame to body frame.\n\t// If the target distance is valid or no minimum distance is set, it updates the pitch and yaw servos accordingly.\n}", "CodeBleu_score": 1.5024751854113272}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tif (AP::gps().available()) {\n\t\tgps.update();\n\t\tif (gps.last_message_time!= last_gps_message_time) {\n\t\t\tlast_gps_message_time = gps.last_message_time;\n\t\t\tif (gps.status() >= GPS::FIX_3D) {\n\t\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t\tif (gps.location.valid()) {\n\t\t\t\t\t\thome_location = gps.location;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tground_start_countdown = 10;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.106537059735594}, {"code": "void Tracker::update_GPS(void){\n\tif (AP::gps().available()) {\n\t\t// update GPS\n\t\tAP::gps().update();\n\n\t\t// check if last message time has changed\n\t\tif (AP::gps().last_msg_time!= last_msg_time) {\n\t\t\tlast_msg_time = AP::gps().last_msg_time;\n\n\t\t\t// check if GPS is at least 3D fix\n\t\t\tif (AP::gps().fix_type >= 3) {\n\t\t\t\t// check if ground start countdown is active\n\t\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t\t// if yes, decrement countdown\n\t\t\t\t\tground_start_countdown--;\n\n\t\t\t\t\t// check if countdown reached zero\n\t\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\t\t// if yes, set home location\n\t\t\t\t\t\tif (AP::gps().fix_type >= 3) {\n\t\t\t\t\t\t\thome_location.lat = AP::gps().latitude;\n\t\t\t\t\t\t\thome_location.lng = AP::gps().longitude;\n\t\t\t\t\t\t\thome_location.alt = AP::gps().altitude;\n\t\t\t\t\t\t\thome_location.valid = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thome_location.valid = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.27750290533268}, {"code": "void Tracker::update_GPS(void){\n\t// Check if GPS is ready\n\tif (!GPS.ready()) {\n\t\treturn;\n\t}\n\n\t// Check if GPS has a valid fix\n\tif (GPS.fix() < 3) {\n\t\treturn;\n\t}\n\n\t// Check if the last message time has changed\n\tif (GPS.last_message_time()!= last_message_time) {\n\t\tlast_message_time = GPS.last_message_time();\n\n\t\t// If we are in ground start, start the countdown\n\t\tif (ground_start) {\n\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t}\n\t}\n\n\t// If we are in ground start, countdown\n\tif (ground_start) {\n\t\tground_start_countdown--;\n\t\tif (ground_start_countdown == 0) {\n\t\t\t// If we have a valid location, set it as home\n\t\t\tif (GPS.valid_location()) {\n\t\t\t\tGPS.get_location(&home_location);\n\t\t\t}\n\t\t\t// Otherwise, reset the countdown\n\t\t\telse {\n\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have a valid location, update the GPS location\n\tif (GPS.valid_location()) {\n\t\tGPS.get_location(&gps_location);\n\t}\n}", "CodeBleu_score": 40.89787339358877}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// calculate new servo position\n\tfloat new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n\t// position limit pitch servo\n\tif (new_servo_out <= g.pitch_min) {\n\t\tnew_servo_out = g.pitch_min;\n\t\tg.pidPitch2Srv.reset_I();\n\t}\n\tif (new_servo_out >= g.pitch_max) {\n\t\tnew_servo_out = g.pitch_max;\n\t\tg.pidPitch2Srv.reset_I();\n\t}\n\t// rate limit pitch servo\n\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n\tif (pitch_servo_out_filt_init) {\n\t\tpitch_servo_out_filt.apply(new_servo_out, G_Dt);\n\t} else {\n\t\tpitch_servo_out_filt.reset(new_servo_out);\n\t\tpitch_servo_out_filt_init = true;\n\t}\n}", "CodeBleu_score": 37.50751781620358}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// calculate new servo position\n\tfloat new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n\t// position limit pitch servo\n\tif (new_servo_out <= g.pitch_min) {\n\t\tnew_servo_out = g.pitch_min;\n\t\tg.pidPitch2Srv.reset_I();\n\t}\n\tif (new_servo_out >= g.pitch_max) {\n\t\tnew_servo_out = g.pitch_max;\n\t\tg.pidPitch2Srv.reset_I();\n\t}\n\t// rate limit pitch servo\n\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n\tif (pitch_servo_out_filt_init) {\n\t\tpitch_servo_out_filt.apply(new_servo_out, G_Dt);\n\t} else {\n\t\tpitch_servo_out_filt.reset(new_servo_out);\n\t\tpitch_servo_out_filt_init = true;\n\t}\n}", "CodeBleu_score": 37.50751781620358}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tf (!check_enabled(ARMING_CHECK_BARO)) {\n// this check has been disabled\nreturn true;\n}\n\n// check barometer altitude\nif (!AP_Arming::barometer_checks(display_failure)) {\nreturn false;\n}\n\n// check barometer altitude\nif (copter.g.baro_altitude_ref == BARO_ALT_REF_INERTIAL) {\nif (copter.baro->get_altitude() - copter.inertial_nav.get_altitude() > copter.g.baro_altitude_ref_disparity_limit) {\ncheck_failed(ARMING_CHECK_BARO, display_failure, \"Barometer altitude disparity\");\nreturn false;\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 40.4990409891945}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!check_enabled(ARMING_CHECK_BARO)) {\n\t\t// this check has been disabled\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer altitude against inertial navigation altitude\n\tconst float baro_alt = copter.baro.get_altitude();\n\tconst float inertial_alt = copter.inertial_nav.get_alt();\n\tconst float disparity = fabsf(baro_alt - inertial_alt);\n\n\tif (disparity > copter.g.baro_alt_disparity) {\n\t\tcheck_failed(ARMING_CHECK_BARO, display_failure, \"Barometer altitude %f m disparity with inertial navigation altitude %f m\", baro_alt, inertial_alt);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 51.99342681889729}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!check_enabled(ARMING_CHECK_BARO)) {\n\t\t// this check has been disabled\n\t\treturn true;\n\t}\n\n\t// check barometer reference\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tif (!check_altitude_baro(display_failure)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 19.027292546510942}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.terrain_source == TerrainSource::RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.terrain_source == TerrainSource::TERRAIN_DATABASE && copter.g.rtl_alt_type == RTL_ALT_TYPE::TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 63.28421736072911}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.terrain_source == TerrainSource::RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.terrain_source == TerrainSource::TERRAIN_DATABASE && copter.g.rtl_alt_type == RTL_ALT_TYPE::TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 63.28421736072911}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t// if the terrain source is from a rangefinder, it returns false\n\tif (copter.g.terrain_source == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\n\t// if the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true\n\tif (copter.g.terrain_source == TerrainSource::TerrainDatabase && copter.g.rtl_altitude_type == RTL_ALTITUDE_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.08349343926899}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// run attitude rate controllers\n\tattitude_control.run_rate_controller();\n\n\t// run position rate controllers\n\tposition_control.run_rate_controller();\n\n\t// run motor rate controllers\n\tmotor_control.run_rate_controller();\n}", "CodeBleu_score": 32.24456694210484}, {"code": "void Copter::run_rate_controller(){\n\t\t// run rate controllers\n\t// 100hz loop\n\tif (scheduler.get_loop_time() == 100) {\n\t\t// run attitude controller\n\t\tattitude_controller.run();\n\t\t// run position controller\n\t\tposition_controller.run();\n\t\t// run motor controller\n\t\tmotor_controller.run();\n\t}\n}", "CodeBleu_score": 16.34001707011199}, {"code": "void Copter::run_rate_controller(){\n\t", "CodeBleu_score": 3.377031594114963}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (flightmode->get_wp(new_loc) && new_loc.alt_msl_m == old_loc.alt_msl_m) {\n\t\tset_target_location(new_loc);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 38.87104267088017}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if the old location is not valid, then set the new location as the target location\n\tif (!old_loc.is_valid()) {\n\t\t// set the new location as the target location\n\t\tset_target_location(new_loc);\n\t\treturn true;\n\t}\n\n\t// if the new location is not valid, then set the old location as the target location\n\tif (!new_loc.is_valid()) {\n\t\t// set the old location as the target location\n\t\tset_target_location(old_loc);\n\t\treturn true;\n\t}\n\n\t// if the altitude frames of the old and new locations are not the same, then set the old location as the target location\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\t// set the old location as the target location\n\t\tset_target_location(old_loc);\n\t\treturn true;\n\t}\n\n\t// if the old location is not the same as the new location, then set the new location as the target location\n\tif (old_loc!= new_loc) {\n\t\t// set the new location as the target location\n\t\tset_target_location(new_loc);\n\t\treturn true;\n\t}\n\n\t// return false if the old location and new location are the same\n\treturn false;\n}", "CodeBleu_score": 52.20304404838259}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (!flightmode->get_wp(new_loc)) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.is_valid() && old_loc.is_same(new_loc)) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_is_relative() && new_loc.alt_is_relative()) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_is_relative() &&!new_loc.alt_is_relative()) {\n\t\treturn false;\n\t}\n\n\tif (!old_loc.alt_is_relative() && new_loc.alt_is_relative()) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.alt_is_relative() && new_loc.alt_is_relative()) {\n\t\tif (old_loc.alt_relative()!= new_loc.alt_relative()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!old_loc.alt_is_relative() &&!new_loc.alt_is_relative()) {\n\t\tif (old_loc.alt_absolute()!= new_loc.alt_absolute()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tflightmode->set_wp(new_loc);\n\treturn true;\n}", "CodeBleu_score": 50.20419106883796}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t(ch_flag == AuxSwitchPos::HIGH) {\n\t\t// if the switch is in the HIGH position, it attempts to set the mode using the copter's set_mode method\n\t\tif (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n\t\t\treturn;\n\t\t}\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\t// if the switch is not in the HIGH position and the current flight mode matches the given mode, it resets the mode switch using rc().reset_mode_switch\n\t\tif (copter.get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 59.91350620328277}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t(ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (copter.get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 57.470476066389864}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t(ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (!copter.set_mode(mode, ModeReason::AUX_SWITCH)) {\n\t\t\treturn;\n\t\t}\n\t} else if (copter.get_mode() == mode) {\n\t\trc().reset_mode_switch(mode);\n\t}\n}", "CodeBleu_score": 50.82873063768123}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// calculate trim values from control inputs\n\tfloat roll_trim = 0.0f;\n\tfloat pitch_trim = 0.0f;\n\tif (channel_roll->get_control_in_range()) {\n\t\troll_trim = (channel_roll->get_control_in() - 1500) * 0.002f;\n\t}\n\tif (channel_pitch->get_control_in_range()) {\n\t\tpitch_trim = (channel_pitch->get_control_in() - 1500) * 0.002f;\n\t}\n\n\t// add trim to ahrs\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// log event\n\tLOGGER_WRITE_EVENT(LogEvent::TRIM_SAVE);\n\n\t// send confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 63.82225591239368}, {"code": "void Copter::save_trim(){\n\t\tif (ap.is_trimming_enabled()) {\n\t\tfloat trim_roll = (rc_channels.get_normalized_channel(RC_CHANNEL::ROLL) - 0.5f) * 2.0f;\n\t\tfloat trim_pitch = (rc_channels.get_normalized_channel(RC_CHANNEL::PITCH) - 0.5f) * 2.0f;\n\t\ttrim_roll *= trim_roll * trim_roll;\n\t\ttrim_pitch *= trim_pitch * trim_pitch;\n\t\ttrim_roll *= trim_roll * trim_roll;\n\t\ttrim_pitch *= trim_pitch * trim_pitch;\n\t\tahrs.add_trim(trim_roll, trim_pitch);\n\t\tLOGGER_WRITE_EVENT(LogEvent::TRIM_SAVED);\n\t\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim Saved\");\n\t}\n}", "CodeBleu_score": 49.22532089445273}, {"code": "void Copter::save_trim(){\n\t#if AHRS_TYPE == AHRS_TYPE_DCM\n    // calculate the trim values from the control inputs of the roll and pitch channels\n    float roll_trim = (rc_data[ROLL] - 1500) / 1000.0f;\n    float pitch_trim = (rc_data[PITCH] - 1500) / 1000.0f;\n\n    // convert the trim values to radians\n    float roll_trim_rad = roll_trim * M_PI / 180.0f;\n    float pitch_trim_rad = pitch_trim * M_PI / 180.0f;\n\n    // add the trim values to the AHRS trim\n    ahrs.add_trim(roll_trim_rad, pitch_trim_rad);\n\n    // log the event\n    LOGGER_WRITE_EVENT(LogEvent::TRIM_SAVED);\n\n    // send a confirmation message with MAV_SEVERITY_INFO\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n#endif\n}", "CodeBleu_score": 55.03978057447823}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Calculate the speed squared.\n\tfloat speed_squared = copter.inertial_nav.get_velocity_xy_cm_s_s().length_squared();\n\n\t// Check if the copter's position is valid and the speed exceeds a minimum threshold.\n\tif (copter.inertial_nav.get_position_xy_cm().is_valid() && speed_squared >= MIN_SPEED_SQUARED) {\n\t\t// Calculate the look-ahead yaw angle using the arctangent of the velocity components.\n\t\tfloat look_ahead_yaw = atan2f(copter.inertial_nav.get_velocity_xy_cm_s_s().y(), copter.inertial_nav.get_velocity_xy_cm_s_s().x());\n\n\t\t// Return the computed look-ahead yaw angle.\n\t\treturn look_ahead_yaw;\n\t}\n\n\t// Return the invalid yaw angle.\n\treturn INVALID_YAW;\n}", "CodeBleu_score": 36.76089947835921}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (!copter.inertial_nav.is_position_valid()) {\n\t\treturn 0.0f;\n\t}\n\n\tconst float speed_squared = copter.inertial_nav.get_velocity_xy_cm_s().length_squared();\n\tif (speed_squared < MIN_SPEED_SQUARED) {\n\t\treturn 0.0f;\n\t}\n\n\tconst float yaw_angle = atan2f(copter.inertial_nav.get_velocity_xy_cm_s().y(), copter.inertial_nav.get_velocity_xy_cm_s().x());\n\tlook_ahead_yaw_angle = yaw_angle;\n\n\treturn yaw_angle;\n}", "CodeBleu_score": 38.49511573653408}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tconst auto& velocity = copter.inertial_nav.get_velocity_xy_cm_s();\n\n\t// Get the speed squared\n\tconst auto speed_squared = velocity.x() * velocity.x() + velocity.y() * velocity.y();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter.inertial_nav.is_position_valid() && speed_squared > 0.01f) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tlook_ahead_yaw_ = atan2f(velocity.y(), velocity.x());\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn look_ahead_yaw_;\n}", "CodeBleu_score": 46.81878125841583}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (plane.channel_rudder->get_reverse()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (plane.g.throttle_fs_enabled.get() && plane.channel_throttle->get_radio_value() < plane.channel_throttle->get_radio_trim()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (plane.channel_throttle->get_radio_value() == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::WATCHDOG) {\n\t\tif (plane.watchdog_armed.get()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.36446206257021}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tbool ret = true;\n\n\tif (method == AP_Arming::RUDDER) {\n\t\t// rudder arming is disabled or throttle is not zero\n\t\tif (!plane.channel_rudder->is_enabled() || plane.g.throttle_zero_throttle.get()) {\n\t\t\treturn false;\n\t\t}\n\t} else if (method == AP_Arming::WATCHDOG) {\n\t\t// watchdog arming is disabled or watchdog is armed\n\t\tif (!plane.g.watchdog_arming_enabled.get() || plane.g.watchdog_armed.get()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// call parent class checks\n\tret &= AP_Arming::arm_checks(method);\n\n\treturn ret;\n}", "CodeBleu_score": 46.16731960806006}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tbool ret = true;\n\n\tif (method == AP_Arming::Method::RUDDER) {\n\t\tif (!plane.channel_rudder->get_rudder_armed()) {\n\t\t\tcheck_failed(ARMING_CHECK_RUDDER, true, \"Rudder arming disabled\");\n\t\t\tret = false;\n\t\t} else if (plane.g.throttle_fs_enabled.get() && plane.g.throttle_fs_value > 0) {\n\t\t\tcheck_failed(ARMING_CHECK_RUDDER, true, \"Throttle is not zero\");\n\t\t\tret = false;\n\t\t}\n\t}\n\n\tif (check_enabled(ARMING_CHECK_PARAMETERS) &&!AP_Arming::arm_checks(method)) {\n\t\tret = false;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 48.70052227548653}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool ret = true;\n\n\tif (!AP_Arming::arm(method, do_arming_checks)) {\n\t\treturn false;\n\t}\n\n\t// update the home location\n\tif (plane.home_is_set()) {\n\t\tplane.home.set_location(plane.get_location());\n\t}\n\n\t// update the current location\n\tplane.get_location().set_location(plane.get_location());\n\n\t// set the arm state\n\tchange_arm_state();\n\n\t// set a delay arming flag\n\tif (method == AP_Arming::Method::DELAY) {\n\t\tplane.delay_armed = true;\n\t}\n\n\t// send a status text\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n\treturn ret;\n}", "CodeBleu_score": 57.86188236940932}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (method == AP_Arming::Method::RUDDER) {\n\t\tconst AP_Arming::RudderArming arming_rudder = get_rudder_arming_type();\n\n\t\tif (arming_rudder == AP_Arming::RudderArming::IS_DISABLED) {\n\t\t\t//parameter disallows rudder arming/disabling\n\n\t\t\t// if we emit a message here then someone doing surface\n\t\t\t// checks may be bothered by the message being emitted.\n\t\t\t// check_failed(true, \"Rudder arming disabled\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// if throttle is not down, then pilot cannot rudder arm/disarm\n\t\tif (!is_zero(plane.get_throttle_input())) {\n\t\t\tcheck_failed(true, \"Non-zero throttle\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//are arming checks disabled?\n\tif (checks_to_perform == 0) {\n\t\treturn true;\n\t}\n\n\tif (hal.util->was_watchdog_armed()) {\n\t\t// on watchdog reset bypass arming checks to allow for\n\t\t// in-flight arming if we were armed before the reset. This\n\t\t// allows a reset on a BVLOS flight to return home if the\n\t\t// operator can command arming over telemetry\n\t\tgcs().send_text(MAV_SEVERITY_WARNING, \"watchdog: Bypassing arming checks\");\n\t\treturn true;\n\t}\n\n\t// call parent class checks\n\tif (!AP_Arming::arm(method, do_arming_checks)) {\n\t\treturn false;\n\t}\n\n\t// update the current location\n\tupdate_current_location();\n\n\t// change the arm state\n\tchange_arm_state();\n\n\t// set a delay arming flag\n\tdelay_arming_flag = true;\n\n\t// send a status text indicating that the throttle is armed\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n\treturn true;\n}", "CodeBleu_score": 55.253487460584985}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t", "CodeBleu_score": 4.868891087689006}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if there's a disarm button\n\tif (has_disarm_function()) {\n\t\t// if there's a disarm button, check if the vehicle is armed\n\t\tif (is_armed()) {\n\t\t\t// if the vehicle is armed, display a failure message and return false\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::console->println_P(PSTR(\"Disarm button is configured, but vehicle is armed\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if the vehicle is not armed, call the standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 60.747144816756524}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (sub.armed) {\n\t\treturn true;\n\t}\n\n\tif (has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\t_failure_reason = \"Disarm button is configured\";\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 62.481984966637796}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// Get the yaw angle from the AHRS.\n\tfloat yaw_angle = ahrs.get_yaw_rad();\n\n\t// Calculate the rotation matrix.\n\tfloat cos_yaw = cosf(yaw_angle);\n\tfloat sin_yaw = sinf(yaw_angle);\n\n\t// Rotate the coordinates.\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\n\t// Update the coordinates.\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 60.70870772280714}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat yaw = ahrs.getYaw();\n\tfloat cos_yaw = cosf(yaw);\n\tfloat sin_yaw = sinf(yaw);\n\tfloat ne_x = x * cos_yaw + y * sin_yaw;\n\tfloat ne_y = -x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 61.623570870723476}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat yaw = ahrs.getYaw();\n\tfloat yaw_rad = yaw * (M_PI / 18000);\n\tfloat cos_yaw = cosf(yaw_rad);\n\tfloat sin_yaw = sinf(yaw_rad);\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 59.94664361540022}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 < 0 || packet.param4 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param5 < 0 || packet.param5 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param6 < 0 || packet.param6 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param7 < 0 || packet.param7 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param8 < 0 || packet.param8 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tsub.mode_auto.set_auto_yaw(packet.param4, packet.param5, packet.param6, packet.param7, packet.param8);\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.37602838869546}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 < 0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param4 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param5 < 0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param5 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tsub.mode_auto.set_auto_yaw_heading(packet.param5);\n\tsub.mode_auto.set_auto_yaw_angle(packet.param4);\n\tsub.mode_auto.set_auto_yaw_direction(packet.param1);\n\tsub.mode_auto.set_auto_yaw_speed(packet.param2);\n\tsub.mode_auto.set_auto_yaw_use_gps(packet.param3);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.38175737829742}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 < 0.0f || packet.param1 > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param2 < 0.0f || packet.param2 > 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param3 < 0.0f || packet.param3 > 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param4 < 0.0f || packet.param4 > 1.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (!sub.set_mode(Mode::Number::AUTO, ModeReason::GCS_COMMAND)) {\n\t\treturn MAV_RESULT_FAILED;\n\t}\n\n\tsub.mode_auto.set_auto_yaw_heading(packet.param1);\n\tsub.mode_auto.set_auto_yaw_speed(packet.param2);\n\tsub.mode_auto.set_auto_yaw_distance(packet.param3);\n\tsub.mode_auto.set_auto_yaw_direction(packet.param4);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.028636970664735}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn (uint8_t) (sub.pos_control.get_tgt_heading_deg() / 2.0f + 180.0f);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 75.94368932360427}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn (uint8_t) (sub.mode_guided.get_tgt_bearing() / 2);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 75.7805877990112}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\t// convert waypoint bearing from -18000->18000 to 0->360\n\t\tint16_t bearing = sub.pos_control.get_pos_target_bearing_deg();\n\t\tif (bearing < 0) {\n\t\t\tbearing += 36000;\n\t\t}\n\t\treturn bearing / 2;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 72.82312486723079}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\ttime_us : AP_HAL::micros64(),\n\t\t\tid : (uint8_t)id,\n\t\t\tdata_value : value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 90.9941031113905}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\ttime_us     : AP_HAL::micros64(),\n\t\t\tid          : (uint8_t)id,\n\t\t\tdata_value  : value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 92.43140207394389}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\t\ttime_us : AP_HAL::micros64(),\n\t\t\t\tid : (uint8_t) id,\n\t\t\t\tdata_value : value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 88.18364304283072}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\t// check if motors are armed\n\tif (motors_armed) {\n\t\t// set home to current location\n\t\thome_lat = home_lat_set;\n\t\thome_lon = home_lon_set;\n\t\thome_alt = home_alt_set;\n\t\thome_is_set = true;\n\t} else {\n\t\t// try to set home to EKF location\n\t\tif (ekf_home_is_set) {\n\t\t\thome_lat = ekf_home_lat;\n\t\t\thome_lon = ekf_home_lon;\n\t\t\thome_alt = ekf_home_alt;\n\t\t\thome_is_set = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 19.093245118723885}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\n\t// if armed, set home to current location\n\tif (armed) {\n\t\thome_lat = home_lat_ekf;\n\t\thome_lng = home_lng_ekf;\n\t\thome_alt = home_alt_ekf;\n\t\thome_set = true;\n\t\treturn;\n\t}\n\n\t// if not armed, try to set home to EKF location and ignore failure\n\thome_lat = home_lat_ekf;\n\thome_lng = home_lng_ekf;\n\thome_alt = home_alt_ekf;\n\thome_set = true;\n}", "CodeBleu_score": 12.94172059933161}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed) {\n\t\thome_is_set = true;\n\t\thome_position = {\n\t\t\tcurrent_ekf_position.north,\n\t\t\tcurrent_ekf_position.east,\n\t\t\tcurrent_ekf_position.down\n\t\t};\n\t\thome_position_valid = true;\n\t\thome_position_is_relative = false;\n\t\thome_position_is_global = true;\n\t\thome_position_is_set = true;\n\t\treturn;\n\t}\n\n\tif (home_position_valid) {\n\t\thome_is_set = true;\n\t\thome_position_is_set = true;\n\t\treturn;\n\t}\n\n\t// if we get here, we need to set the home position\n\thome_position_valid = true;\n\thome_position_is_relative = false;\n\thome_position_is_global = true;\n\thome_position_is_set = true;\n\thome_position = {\n\t\tcurrent_ekf_position.north,\n\t\tcurrent_ekf_position.east,\n\t\tcurrent_ekf_position.down\n\t};\n}", "CodeBleu_score": 13.825371382388244}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// if the motors are not armed, set throttle to zero\n\tif (!motors->armed()) {\n\t\t// set throttle to zero\n\t\tmotors->set_throttle(0);\n\t\t// set spool state to unlimited throttle\n\t\tspool->set_state(Spool::STATE_UNLIMITED_THROTTLE);\n\t\t// relaxes the attitude controllers\n\t\tattitude_control->relax();\n\t\t// exit\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tspool->set_state(Spool::STATE_UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to desired body frame rates\n\t// get pilot inputs\n\tfloat roll_rate = sub.get_roll_rate();\n\tfloat pitch_rate = sub.get_pitch_rate();\n\tfloat yaw_rate = sub.get_yaw_rate();\n\tfloat throttle = sub.get_throttle();\n\n\t// convert to body frame rates\n\troll_rate = body_frame_rate_conversion(roll_rate, pitch_rate, yaw_rate);\n\tpitch_rate = body_frame_rate_conversion(pitch_rate, roll_rate, yaw_rate);\n\tyaw_rate = body_frame_rate_conversion(yaw_rate, roll_rate, pitch_rate);\n\n\t// run attitude controller with these rates\n\tattitude_control->run(roll_rate, pitch_rate, yaw_rate);\n\n\t// output throttle input without angle boost\n\tmotors->set_throttle(throttle);\n\n\t// set forward and lateral motor inputs based on pilot controls\n\tmotors->set_forward_motor_input(sub.get_forward_motor_input());\n\tmotors->set_lateral_motor_input(sub.get_lateral_motor_input());\n}", "CodeBleu_score": 45.50453419134538}, {"code": "void ModeAcro::run(){\n\t\t// if motors are not armed, set throttle to zero\n\tif (!armed) {\n\t\t// set throttle to zero\n\t\tset_throttle(0.0f);\n\n\t\t// set spool state to unlimited throttle\n\t\tset_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\n\t\t// release attitude controllers\n\t\trelease_attitude_controllers();\n\n\t\t// exit\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tset_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to desired body frame rates\n\tfloat body_rates[3];\n\tconvert_pilot_inputs_to_body_rates(body_rates);\n\n\t// run attitude controller with these rates\n\tattitude_controller->run(body_rates);\n\n\t// output the pilot's throttle input without angle boost\n\tset_throttle(pilot_controls.throttle);\n\n\t// set forward and lateral motor inputs based on pilot controls\n\tset_motor_inputs(pilot_controls.forward, pilot_controls.lateral);\n}", "CodeBleu_score": 32.29489921116995}, {"code": "void ModeAcro::run(){\n\t\t// If the motors are not armed, set throttle to zero, adjust spool state,\n\t// and exit.\n\tif (!armed) {\n\t\t// set throttle to zero, adjust spool state\n\t\tsub.set_neutral_controls();\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tsub.set_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to desired body frame rates\n\tfloat roll_rate_radps = pilot->get_roll_rate_radps();\n\tfloat pitch_rate_radps = pilot->get_pitch_rate_radps();\n\tfloat yaw_rate_radps = pilot->get_yaw_rate_radps();\n\tfloat thrust_cmd = pilot->get_thrust_cmd();\n\n\t// run the attitude controller with these rates\n\tattitude_controller->run(roll_rate_radps, pitch_rate_radps, yaw_rate_radps, thrust_cmd);\n\n\t// output the pilot's throttle input without angle boost\n\tpilot->set_throttle_cmd(attitude_controller->get_throttle_cmd());\n\n\t// set forward and lateral motor inputs based on pilot controls\n\tsub.set_motor_inputs(pilot->get_forward_cmd(), pilot->get_lateral_cmd());\n}", "CodeBleu_score": 43.74380072734615}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// start in position control mode\n\tif (g.rtl_land_complete) {\n\t\tg.land_complete = false;\n\t}\n\n\t// get the stopping point\n\tVector3f pos_cm;\n\tif (g.rtl_land_complete) {\n\t\tpos_cm = g.land_pos;\n\t} else {\n\t\tpos_cm = g.home_pos;\n\t}\n\n\t// set the stopping point as the waypoint destination\n\tg.wp_next_pos_reached = false;\n\tg.wp_next_wp_index = 0;\n\tg.wp_next_pos = pos_cm;\n\n\t// initialize the yaw\n\tg.auto_yaw_mode = get_default_auto_yaw_mode(g.rtl_land_complete);\n}", "CodeBleu_score": 42.00063687162605}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t//  if (g.rtl_land) {\n//    // if we are in RTL mode, we want to land at the current position\n//    guided_set_destination(g.land_pos);\n//  } else {\n//    // otherwise, set the destination to the next waypoint\n//    guided_set_destination(g.next_wp);\n//  }\n\n//  // set the yaw to the default auto yaw mode\n//  guided_set_auto_yaw_mode(get_default_auto_yaw_mode(g.rtl_land));\n\n//  // set the position controller to position control mode\n//  guided_set_pos_control_mode();\n}", "CodeBleu_score": 3.006399650678141}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// start in position control mode\n\tset_mode(MODE_POSITION_CONTROL);\n\n\t// set the waypoint destination to the stopping point\n\twp_set_destination(wp_current_index, &posvel_pos_target_cm, &posvel_vel_target_cms);\n\n\t// initialize the yaw controller\n\tauto_yaw_mode = get_default_auto_yaw_mode(false);\n\tauto_yaw_init(auto_yaw_mode, &posvel_pos_target_cm);\n}", "CodeBleu_score": 28.865019355342163}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_VEL;\n\n\t// initialise velocity controller\n\tsub.vel_nav.init();\n\n\t// initialise vertical velocity controller\n\tsub.vel_nav.set_max_climb_rate_cms(g.max_climb_rate_cms);\n\tsub.vel_nav.set_max_descend_rate_cms(g.max_descend_rate_cms);\n\n\t// initialise horizontal velocity controller\n\tsub.vel_nav.set_max_vel_xy_cms(g.max_vel_xy_cms);\n\tsub.vel_nav.set_max_vel_z_cms(g.max_vel_z_cms);\n\tsub.vel_nav.set_max_accel_xy_cms(g.max_accel_xy_cms);\n\tsub.vel_nav.set_max_accel_z_cms(g.max_accel_z_cms);\n\n\t// set to auto yaw mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 40.622100942120746}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_VEL;\n\n\t// initialise vertical speed controller\n\tsub.vel_sp.z = g.vel_max_cms;\n\tsub.vel_sp.z_acc = g.vel_acc_cms;\n\tsub.vel_sp.z_dec = g.vel_acc_cms;\n\n\t// initialise horizontal speed controller\n\tsub.vel_sp.x = 0.0f;\n\tsub.vel_sp.y = 0.0f;\n\tsub.vel_sp.x_acc = g.vel_acc_cms;\n\tsub.vel_sp.y_acc = g.vel_acc_cms;\n\n\t// set to auto yaw mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 36.62732399141782}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_VEL;\n\n\t// initialise vertical velocity controller\n\tsub.vel_ctrl.set_max_vel(g.max_vel_cms);\n\tsub.vel_ctrl.set_max_accel(g.max_accel_cms_s);\n\n\t// initialise horizontal velocity controller\n\tsub.vel_ctrl.set_max_vel(g.max_vel_cms);\n\tsub.vel_ctrl.set_max_accel(g.max_accel_cms_s);\n\n\t// set to hold yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 36.80129435540158}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n\tuint32_t tnow = AP_HAL::millis();\n\tif (tnow - guided_limit.timeout_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n\t\t// timeout - clear guided mode\n\t\tguided_limit_clear();\n\t\treturn true;\n\t}\n\n\t// check altitude limits\n\tif (inertial_nav.get_position_neu_cm().z < guided_limit.alt_min_cm) {\n\t\t// altitude is below minimum - clear guided mode\n\t\tguided_limit_clear();\n\t\treturn true;\n\t}\n\n\tif (inertial_nav.get_position_neu_cm().z > guided_limit.alt_max_cm) {\n\t\t// altitude is above maximum - clear guided mode\n\t\tguided_limit_clear();\n\t\treturn true;\n\t}\n\n\t// check horizontal limits\n\tif (inertial_nav.get_position_neu_cm().xy().length() > guided_limit.horiz_max_cm) {\n\t\t// horizontal distance moved is above limit - clear guided mode\n\t\tguided_limit_clear();\n\t\treturn true;\n\t}\n\n\t// check for time limit\n\tif (tnow - guided_limit.start_time > GUIDED_ATTITUDE_TIMEOUT_MS) {\n\t\t// time limit exceeded - clear guided mode\n\t\tguided_limit_clear();\n\t\treturn true;\n\t}\n\n\t// no limit breached - return false\n\treturn false;\n}", "CodeBleu_score": 42.881353940059576}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check for timeout - return true if timeout has been exceeded\n\tuint32_t tnow = AP_HAL::millis();\n\tif (tnow - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// check altitude limits\n\tfloat alt_cm = inertial_nav.get_position_neu_cm().z;\n\tif (alt_cm < guided_limit.alt_min_cm) {\n\t\treturn true;\n\t}\n\tif (alt_cm > guided_limit.alt_max_cm) {\n\t\treturn true;\n\t}\n\n\t// check horizontal limits\n\tfloat horiz_dist_cm = sqrtf(sq(inertial_nav.get_position_neu_cm().x) + sq(inertial_nav.get_position_neu_cm().y));\n\tif (horiz_dist_cm > guided_limit.horiz_max_cm) {\n\t\treturn true;\n\t}\n\n\t// no limit breached\n\treturn false;\n}", "CodeBleu_score": 43.49127908457726}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\n// check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\nuint32_t tnow = AP_HAL::millis();\nif (tnow - guided_limit.timeout_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n    guided_limit.alt_min_cm = 0.0f;\n    guided_limit.alt_max_cm = 0.0f;\n    guided_limit.horiz_max_cm = 0.0f;\n}\n\n// check altitude limits\nif (guided_limit.alt_min_cm > 0.0f) {\n    if (inertial_nav.get_position_neu_cm().z < guided_limit.alt_min_cm) {\n        return true;\n    }\n}\nif (guided_limit.alt_max_cm > 0.0f) {\n    if (inertial_nav.get_position_neu_cm().z > guided_limit.alt_max_cm) {\n        return true;\n    }\n}\n\n// check horizontal distance moved\nVector2f pos_diff = inertial_nav.get_position_neu_cm() - guided_limit.start_pos;\nif (pos_diff.length() > guided_limit.horiz_max_cm) {\n    return true;\n}\n\nreturn false;\n}", "CodeBleu_score": 49.09267701464996}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}, {"code": "bool Sub::verify_motor_test(){\n\t\t// check if we have timed out waiting for a motor test request\n\tif (AP_HAL::millis() > last_do_motor_test_ms + MOTOR_TEST_TIMEOUT_MS) {\n\t\t// timeout waiting for motor test request\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n\t\tap.motor_test = false;\n\t\tarm_disarm(false);\n\t\tlast_do_motor_test_fail_ms = AP_HAL::millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.556858641906786}, {"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_in = wp_nav.roll_target;\n\tfloat pitch_in = wp_nav.pitch_target;\n\n\t// constrain roll and pitch within a specified maximum angle range\n\troll_in = constrain_float(roll_in, -max_roll_pitch_angle_deg, max_roll_pitch_angle_deg);\n\tpitch_in = constrain_float(pitch_in, -max_roll_pitch_angle_deg, max_roll_pitch_angle_deg);\n\n\t// normalize roll and pitch\n\tfloat roll_norm = roll_in / max_roll_pitch_angle_deg;\n\tfloat pitch_norm = pitch_in / max_roll_pitch_angle_deg;\n\n\t// assign normalized values to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 41.80221894938977}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tif (ap.wp_nav_mode == AP_WPNav::Mode::OFF) {\n\t\tlateral_out = 0.0f;\n\t\tforward_out = 0.0f;\n\t\treturn;\n\t}\n\n\t// get wp_nav roll and pitch targets\n\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\t// constrain roll and pitch targets to range -180 to 180\n\troll_target = constrain_float(roll_target, -180.0f, 180.0f);\n\tpitch_target = constrain_float(pitch_target, -180.0f, 180.0f);\n\n\t// normalize roll and pitch targets to range -1.0 to 1.0\n\troll_target = (roll_target + 180.0f) / 360.0f;\n\tpitch_target = (pitch_target + 180.0f) / 360.0f;\n\n\t// assign normalized roll and pitch targets to lateral and forward\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 36.63267713837819}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get wpnav roll and pitch targets in centidegrees\n\tfloat roll_target_centidegrees = wp_nav.roll_target_centidegrees();\n\tfloat pitch_target_centidegrees = wp_nav.pitch_target_centidegrees();\n\n\t// constrain roll and pitch targets to a maximum angle range\n\troll_target_centidegrees = constrain_float(roll_target_centidegrees, -max_angle_centidegrees, max_angle_centidegrees);\n\tpitch_target_centidegrees = constrain_float(pitch_target_centidegrees, -max_angle_centidegrees, max_angle_centidegrees);\n\n\t// normalize roll and pitch targets to a range of -1 to 1\n\tfloat roll_target_normalized = roll_target_centidegrees / max_angle_centidegrees;\n\tfloat pitch_target_normalized = pitch_target_centidegrees / max_angle_centidegrees;\n\n\t// assign normalized roll and pitch targets to lateral and forward outputs\n\tlateral_out = roll_target_normalized;\n\tforward_out = pitch_target_normalized;\n}", "CodeBleu_score": 42.20668289942916}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// read barometer data\n\tbaro_data = baro.read_baro();\n\t// update barometer calibration\n\tif (baro_data.altitude > 0) {\n\t\tbaro_data.baro_calibrated = true;\n\t}\n\t// update sensor health status\n\tif (depth_sensor.present) {\n\t\tif (baro_data.altitude > 0) {\n\t\t\tdepth_sensor.health = true;\n\t\t} else {\n\t\t\tdepth_sensor.health = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 51.20623597283368}, {"code": "void Sub::read_barometer(){\n\t\t// read the barometer\n\tfloat altitude = barometer.readAltitude(SEALEVELPRESSURE_HPA);\n\t// update the barometer calibration\n\tif (altitude > 0) {\n\t\tbarometer.setSeaLevelPressure(altitude);\n\t\tbarometer.setTemperature(temperature);\n\t}\n\t// update the depth sensor health status\n\tif (depth_sensor) {\n\t\tif (altitude > 0) {\n\t\t\tdepth_sensor->update_health_status(altitude);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.724408221520264}, {"code": "void Sub::read_barometer(){\n\t\t// Update the barometer\n\tbarometer.update();\n\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.altitude > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status\n\tif (depth_sensor!= nullptr) {\n\t\tdepth_sensor->update_health();\n\t}\n}", "CodeBleu_score": 54.93360680128529}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t/ check ekf position estimate\n\tif (ap.inav_mode == AP_INAV::INAV_MODE_DISABLED) {\n\t\treturn false;\n\t}\n\n\t// if motors are disarmed, accept a predicted horizontal position\n\tif (rc_disarmed()) {\n\t\treturn true;\n\t}\n\n\t// if motors are armed, check that the EKF is not in constant position mode\n\tif (rc_armed()) {\n\t\tif (ekf.get_mode() == INS_MODE_CONST_POS) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we get here, we are in a position mode that is good\n\treturn true;\n}", "CodeBleu_score": 29.76332291042968}, {"code": "bool Sub::ekf_position_ok(){\n\t/ return false if ekf failsafe has triggered\n\tif (failsafe.ekf) {\n\t\treturn false;\n\t}\n\n\t// check ekf position estimate\n\tif (!ahrs.get_absolute_position_ok()) {\n\t\treturn false;\n\t}\n\n\t// if motors are disarmed, accept a predicted horizontal position\n\tif (!rc_override) {\n\t\treturn true;\n\t}\n\n\t// if motors are armed, require a good absolute position and ensure the EKF is not in constant position mode\n\tif (!ahrs.get_absolute_position_ok()) {\n\t\treturn false;\n\t}\n\n\tif (ekf_pos_mode == EKF_POS_MODE_POSCTL) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 34.70334245316559}, {"code": "bool Sub::ekf_position_ok(){\n\t/ check if inertial navigation is available\n\tif (!ap.inertial_nav_available) {\n\t\treturn false;\n\t}\n\n\t// check if motors are armed\n\tif (!motors.armed()) {\n\t\t// if motors are disarmed, we accept a predicted horizontal position\n\t\treturn true;\n\t}\n\n\t// check if the EKF is in constant position mode\n\tif (ekf.get_position_mode() == EKF::CONST_POS) {\n\t\t// if the EKF is in constant position mode, we accept a predicted horizontal position\n\t\treturn true;\n\t}\n\n\t// check if the EKF has a good absolute position estimate\n\tif (ekf.get_position_valid()) {\n\t\t// if the EKF has a good absolute position estimate, we accept the EKF's horizontal absolute position\n\t\treturn true;\n\t}\n\n\t// if we get to this point, the EKF has not been able to determine a good absolute position\n\treturn false;\n}", "CodeBleu_score": 37.29794185728572}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// check if GPS is ready\n\tif (!rover.gps_ready()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"GPS not ready\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (rover.ekf_failsafe_active()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if GPS position is valid\n\tif (!rover.gps_position_valid()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"GPS position invalid\");\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 45.02087763024918}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// if this is not a position-controlled system, return true\n\tif (!rover.is_position_control()) {\n\t\treturn true;\n\t}\n\n\t// check if EKF is ready\n\tif (!rover.ekf.is_ready()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF not ready\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (rover.ekf.is_failsafe_active()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (!rover.ekf.is_position_valid()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF position invalid\");\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 49.713363543412065}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (rover.ahrs == NULL) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (rover.ahrs->get_ekf_failsafe()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if position is valid\n\tif (!rover.ahrs->get_position_valid()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"GPS position invalid\");\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 46.53697274010562}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t check if we are already armed\n\tif (is_armed()) {\n\t\t// if we are already armed then skip the checks\n\t\treturn true;\n\t}\n\n\t// are arming checks disabled?\n\tif (checks_to_perform == 0) {\n\t\treturn mandatory_checks(false);\n\t}\n\n\t// check if we are arming\n\tif (do_arming_checks) {\n\t\tif (!AP_Arming::arm(method)) {\n\t\t\t// failed to arm\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we are armed, set the home location to the current location\n\tif (is_armed()) {\n\t\t// set home location to current location\n\t\trover.set_home_location(rover.get_location());\n\n\t\t// set the simple mode heading to the current heading\n\t\trover.simple_mode_heading = rover.get_heading();\n\n\t\t// record the home heading for sail vehicles\n\t\tif (rover.g2.sailboat.sail_enabled()) {\n\t\t\trover.g2.sailboat.set_home_heading(rover.get_heading());\n\t\t}\n\n\t\t// update the soft armed status\n\t\tupdate_soft_armed();\n\n\t\t// send an arm/disarm status text\n\t\tif (rover.get_location().valid()) {\n\t\t\tsend_arm_disarm_status_text(true);\n\t\t}\n\n\t\t// return true if we are armed\n\t\treturn true;\n\t}\n\n\t// return false if we are not armed\n\treturn false;\n}", "CodeBleu_score": 48.09809484120067}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t (do_arming_checks &&!arm_checks(method)) {\n\t\treturn false;\n\t}\n\n\t// arm motors\n\trover.arm_motors();\n\n\t// set the arming state\n\tarmed = true;\n\n\t// set the arming method\n\tarming_method = method;\n\n\t// set the arming time\n\tarming_time = hal.scheduler->millis();\n\n\t// set the arming event\n\tif (arming_event) {\n\t\tarming_event->trigger();\n\t}\n\n\t// set the arming_failed event\n\tif (arming_failed_event) {\n\t\tarming_failed_event->trigger();\n\t}\n\n\t// set the soft armed status\n\tupdate_soft_armed();\n\n\t// send the arming status text\n\tif (arming_status_text) {\n\t\tarming_status_text->send(AP_Arming::ARMED);\n\t}\n\n\t// set the home location\n\tif (rover.g2.sailboat.sail_enabled()) {\n\t\trover.g2.sailboat.set_home_heading(rover.g2.windvane.heading());\n\t}\n\n\t// set the simple mode heading\n\tif (rover.simple_mode) {\n\t\trover.simple_mode->set_heading(rover.g2.windvane.heading());\n\t}\n\n\t// set the failsafe status\n\trover.failsafe.set_failsafe_status(false);\n\n\treturn true;\n}", "CodeBleu_score": 47.02045458583242}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t check if arming checks are disabled\n\tif (!do_arming_checks) {\n\t\t// do not perform arming checks\n\t\tchecks_to_perform = 0;\n\t} else {\n\t\t// perform arming checks\n\t\tchecks_to_perform = 1;\n\t}\n\n\t// call parent arm method\n\tif (!AP_Arming::arm(method)) {\n\t\t// arming failed\n\t\treturn false;\n\t}\n\n\t// set the home location to the current location\n\tif (rover.g2.sailboat.sail_enabled()) {\n\t\t// set the home location to the current location\n\t\trover.g2.sailboat.set_home_location(rover.g2.sailboat.get_current_location());\n\t}\n\n\t// set the home heading to the current heading\n\tif (rover.g2.sailboat.sail_enabled()) {\n\t\t// set the home heading to the current heading\n\t\trover.g2.sailboat.set_home_heading(rover.g2.sailboat.get_current_heading());\n\t}\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// send an arm/disarm status text\n\tif (method == AP_Arming::METHOD_RC_OVERRIDE) {\n\t\t// send an arm/disarm status text\n\t\tsend_arm_status_text(true);\n\t}\n\n\t// return true if arming succeeded\n\treturn true;\n}", "CodeBleu_score": 47.87480717568633}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (should_charge) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t} else {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disabled_millis = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (should_charge) {\n\t\t\t\tif (millis() - charging_disabled_millis > 1000) {\n\t\t\t\t\tcharging_enabled = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (millis() - charging_disabled_millis > 1000) {\n\t\t\t\t\tcharging_enabled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_millis = millis();\n\t\t} else {\n\t\t\tif (millis() - charging_disabled_millis > 1000) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.23280564787311}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tif (checkShouldCharge()) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_enabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (!checkShouldCharge()) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tif (millis() - charging_enabled_time > CHARGING_ENABLED_RETRY_DELAY) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.829912236602965}, {"code": "void updateChargingEnabled(){\n\t#ifdef ENABLE_CHARGING\n    if (charging_allowed) {\n        // Charging allowed, check if we should continue charging\n        if (checkShouldCharge()) {\n            // Charging allowed and should continue, enable charging\n            charging_enabled = true;\n            charging_enabled_millis = millis();\n            charging_enabled_retries = 0;\n        } else {\n            // Charging allowed, but should not continue, disable charging\n            charging_enabled = false;\n            charging_enabled_millis = 0;\n            charging_enabled_retries = 0;\n        }\n    } else {\n        // Charging not allowed, check if we should continue disabling charging\n        if (charging_enabled) {\n            // Charging not allowed, but should continue, disable charging\n            charging_enabled = false;\n            charging_enabled_millis = 0;\n            charging_enabled_retries = 0;\n        } else {\n            // Charging not allowed, but should not continue, check if we should retry enabling charging\n            if (charging_enabled_retries == 0) {\n                // Charging not allowed, and should not continue, and we haven't tried to enable charging yet, try to enable charging\n                charging_enabled = true;\n                charging_enabled_millis = millis();\n                charging_enabled_retries = 1;\n            } else {\n                // Charging not allowed, and should not continue, and we have tried to enable charging, check if we should continue retrying to enable charging\n                if (millis() - charging_enabled_millis < 30000) {\n                    // We have tried to enable charging, but haven't succeeded, so continue retrying\n                    charging_enabled_retries++;\n                } else {\n                    // We have tried to enable charging, but haven't succeeded, so stop retrying\n                    charging_enabled = false;\n                    charging_enabled_millis = 0;\n                    charging_enabled_retries = 0;\n                }\n            }\n        }\n    }\n#endif\n}", "CodeBleu_score": 44.39344617097946}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\tif (ROS_running && size >= 4) {\nuint32_t crc = crc32_be(message, size - 4);\nmemcpy(message + size, &crc, 4);\npacketSerial.send(message, size + 4);\n}\n}", "CodeBleu_score": 29.05353845194414}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ROS_running && size >= 4) {\nuint16_t crc = crc16_ccitt((uint8_t *) message, size - 2);\n*((uint16_t *) (message + size - 2)) = crc;\npacketSerial.send((uint8_t *) message, size);\n}\n}", "CodeBleu_score": 44.03155993446588}, {"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ROS_running\n    if (size >= 4) {\n        uint16_t crc = crc16_ccitt((uint8_t *) message, size);\n        memcpy((uint8_t *) message + size, &crc, 2);\n        packetSerial.send(message, size + 2);\n    }\n#endif\n}", "CodeBleu_score": 41.79967522682417}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t\tif (soundSerial.begin(9600)) {\n\t\tif (myMP3.begin(soundSerial)) {\n\t\t\tthis->anzSoundfiles = myMP3.getMP3Count();\n\t\t\tthis->playing = false;\n\t\t\tthis->sound_available = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 44.287206422825825}, {"code": "bool MP3Sound::begin(){\n\t\t// Initialize the serial communication with the sound module\n\tif (!soundSerial.begin(9600, SERIAL_8N1, PIN_SOUND_TX, PIN_SOUND_RX)) {\n\t\tSerial.println(\"Sound module not found!\");\n\t\treturn false;\n\t}\n\n\t// Clear any existing data in the serial buffer\n\twhile (soundSerial.available()) {\n\t\tsoundSerial.read();\n\t}\n\n\t// Initialize the sound module\n\tif (!myMP3.begin(soundSerial)) {\n\t\tSerial.println(\"Sound module not found!\");\n\t\treturn false;\n\t}\n\n\t// Retrieve the number of sound files available on the SD card\n\tthis->anzSoundfiles = myMP3.getMP3Count();\n\n\t// Check if there are one or more sound files available\n\tif (this->anzSoundfiles > 0) {\n\t\tSerial.print(\"Found \");\n\t\tSerial.print(this->anzSoundfiles);\n\t\tSerial.println(\" sound files on the SD card.\");\n\t\treturn true;\n\t} else {\n\t\tSerial.println(\"No sound files found on the SD card.\");\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.32773863789895}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif ((this->active_sounds.size() == 0) || (this->playing))\nreturn this->active_sounds.size();\n\nint soundNr = this->active_sounds.back();\nthis->active_sounds.pop_back();\n\nthis->playing = true;\nthis->myMP3.play(soundNr);\n\nreturn this->active_sounds.size();\n}", "CodeBleu_score": 23.89472697427543}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || playing)\n\t\treturn active_sounds.size();\n\n\tint soundNr = active_sounds.back();\n\tactive_sounds.pop_back();\n\tmyMP3.play(soundNr);\n\tplaying = true;\n\treturn active_sounds.size();\n}", "CodeBleu_score": 50.42710071048552}, {"code": "int MP3Sound::processSounds(){\n\t\tif (this->playing || this->sounds2play() == 0)\n\t\treturn this->sounds2play();\n\n\tint soundNr = this->active_sounds.back();\n\tthis->active_sounds.pop_back();\n\tthis->playing = true;\n\tthis->playSoundAdHoc(soundNr);\n\treturn this->sounds2play();\n}", "CodeBleu_score": 21.35941880396622}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\nbool handled = false;\n\nswitch (command) {\n  case C_CAMERA_MEMORY_MAPPED_FILE: {\n    wb_abstract_camera_cleanup(d);\n    int fd = -1;\n#ifdef _WIN32\n    HANDLE file_handle;\n    DWORD file_size;\n    char *file_name = \"webots_camera_memory_mapped_file\";\n\n    file_handle = CreateFile(file_name, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (file_handle == INVALID_HANDLE_VALUE) {\n      printf(\"Failed to create file %s.\n\", file_name);\n      break;\n    }\n\n    file_size = c->width * c->height * 3;\n    if (!WriteFile(file_handle, c->image->data, file_size, NULL, NULL))\n      printf(\"Failed to write file %s.\n\", file_name);\n\n    CloseHandle(file_handle);\n#else  // memory mapped files\n    char *file_name = \"/tmp/webots_camera_memory_mapped_file\";\n    fd = open(file_name, O_RDWR | O_CREAT | O_TRUNC, 0666);\n    if (fd == -1) {\n      printf(\"Failed to create file %s.\n\", file_name);\n      break;\n    }\n\n    if (ftruncate(fd, c->width * c->height * 3) == -1) {\n      printf(\"Failed to truncate file %s.\n\", file_name);\n      break;\n    }\n\n    c->image->data = (unsigned char *)mmap(NULL, c->width * c->height * 3, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if (c->image->data == MAP_FAILED) {\n      printf(\"Failed to map file %s.\n\", file_name);\n      break;\n    }\n#endif\n    c->enable = true;\n    handled = true;\n    break;\n  }\n  default:\n    handled = false;\n    break;\n}\n\nreturn handled;\n}", "CodeBleu_score": 51.5580935713006}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n\nif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n// cleanup\nimage_cleanup(c->image);\nfree(c->image);\n\n// read file name\nchar *file_name = NULL;\nif (!request_read_string(r, &file_name))\nreturn false;\n\n// read file size\nuint32_t file_size = 0;\nif (!request_read_uint32(r, &file_size))\nreturn false;\n\n// read file data\nuint8_t *file_data = NULL;\nif (!request_read_uchar_array(r, file_size, &file_data))\nreturn false;\n\n// open file\nint fd = -1;\n#ifdef _WIN32\nfd = _open(file_name, _O_RDWR | _O_BINARY);\n#else  // memory mapped files\nfd = open(file_name, O_RDWR);\n#endif\nif (fd == -1) {\nprintf(\"Error: could not open file %s\n\", file_name);\nreturn false;\n}\n\n// create memory mapped file\nc->image = image_new();\nimage_set_data(c->image, file_data, file_size);\n\n// close file\n#ifdef _WIN32\n_close(fd);\n#else  // memory mapped files\nclose(fd);\n#endif\n\n// cleanup\nfree(file_name);\nfree(file_data);\n\n// done\nreturn true;\n}\n\n// not handled\nreturn false;\n}", "CodeBleu_score": 43.24173282690314}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n\nswitch (command) {\n  case C_CAMERA_MEMORY_MAPPED_FILE: {\n    int fd;\n    struct stat st;\n    char *buffer;\n\n    request_read_uchar(r);  // ignore the command id\n    request_read_uint32(r);  // ignore the file size\n    request_read_uint32(r);  // ignore the file offset\n    request_read_uint32(r);  // ignore the file length\n    if (fstat(fd, &st) == 0)\n      buffer = (char *)mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    else\n      buffer = NULL;\n    if (buffer!= NULL)\n      image_set_buffer(c->image, buffer, c->width, c->height);\n    else\n      fprintf(stderr, \"Error: could not map the camera memory-mapped file.\n\");\n    close(fd);\n    break;\n  }\n  default:\n    return false;\n}\nreturn true;\n}", "CodeBleu_score": 51.227548864772785}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tbstractCamera *c = d->pdata;\nif (c)\nreturn c->height;\nreturn -1;\n}", "CodeBleu_score": 11.570553897695753}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tnt height = -1;\nrobot_mutex_lock();\nconst AbstractCamera *ac = d->pdata;\nif (ac)\nheight = ac->height;\nrobot_mutex_unlock();\nreturn height;\n}", "CodeBleu_score": 74.09766708968549}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tbstractCamera *c = d->pdata;\nif (c == NULL)\nreturn -1;\nrobot_mutex_lock();\nint height = c->height;\nrobot_mutex_unlock();\nreturn height;\n}", "CodeBleu_score": 52.55409485364561}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t result = 0;\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn result;\n}", "CodeBleu_score": 67.36297258690965}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t result = 0;\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn result;\n}", "CodeBleu_score": 67.36297258690965}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t result = 0;\n\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\n\nreturn result;\n}", "CodeBleu_score": 67.36297258690965}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 38.166184039894674}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.245249918562564}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 41.90011620056393}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass,\\\"argument not a box\\\");\n\nconst dReal *const s = ((dxBox*) g)->side;\ndReal dist = 0;\nint axis = 0;\n\nif (x < s[0] / 2) {\ndist -= x;\naxis = 1;\n} else if (x > s[0] / 2) {\ndist += x;\naxis = 1;\n}\n\nif (y < s[1] / 2) {\ndist -= y;\naxis = 2;\n} else if (y > s[1] / 2) {\ndist += y;\naxis = 2;\n}\n\nif (z < s[2] / 2) {\ndist -= z;\naxis = 3;\n} else if (z > s[2] / 2) {\ndist += z;\naxis = 3;\n}\n\nplane[0] = 0;\nplane[1] = 0;\nplane[2] = 0;\nplane[3] = 0;\n\nswitch (axis) {\ncase 0:\nplane[0] = 1;\nplane[3] = -s[0] / 2;\nbreak;\ncase 1:\nplane[1] = 1;\nplane[3] = -s[1] / 2;\nbreak;\ncase 2:\nplane[2] = 1;\nplane[3] = -s[2] / 2;\nbreak;\ncase 3:\nplane[3] = 1;\nbreak;\n}\n}", "CodeBleu_score": 33.058161236369976}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass,\\\"argument not a box\\\");\n\ndxBox *box = (dxBox *) g;\nconst dReal *const s = box->side;\n\ndReal dx = x - box->pos[0];\ndReal dy = y - box->pos[1];\ndReal dz = z - box->pos[2];\n\ndReal dist = 0;\ndReal maxDist = 0;\n\nif (dx * dx < maxDist) {\nmaxDist = dx * dx;\ndist = dx;\n}\nif (dy * dy < maxDist) {\nmaxDist = dy * dy;\ndist = dy;\n}\nif (dz * dz < maxDist) {\nmaxDist = dz * dz;\ndist = dz;\n}\n\nif (dist < 0) {\ndist = -dist;\n}\n\nplane[0] = plane[1] = plane[2] = 0;\n\nif (dist < s[0]) {\nplane[0] = -dx / dist;\n}\nif (dist < s[1]) {\nplane[1] = -dy / dist;\n}\nif (dist < s[2]) {\nplane[2] = -dz / dist;\n}\n\nplane[3] = dist;\n}", "CodeBleu_score": 43.01543437960717}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tsBoxImmersionData *data = new sBoxImmersionData(box, fluidPlane, flags, immersion);\nreturn data->performImmersionChecking();\n}", "CodeBleu_score": 43.82651714038846}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#if 0\n  dIASSERT(box);\n  dIASSERT(immersion);\n  dIASSERT(fluidPlane);\n  dIASSERT(box->body);\n  dIASSERT(flags & dxImmersionFlags);\n  dIASSERT(flags & dxImmersionFlags & ~dxImmersionOutlineDisabled);\n\n  sBoxImmersionData *const data = new sBoxImmersionData(box, fluidPlane, flags, immersion);\n  int result = data->performImmersionChecking();\n  delete data;\n  return result;\n#endif\n}", "CodeBleu_score": 46.81907626746956}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\nreturn 0;\n\ndxBox *const box = (dxBox *) o1;\ndxCapsule *const capsule = (dxCapsule *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\nreturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.126000195825}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\ndContactGeom c[1];\nconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\nreturn 0;\n\ndxBox *const box = (dxBox *) o1;\ndxCapsule *const capsule = (dxCapsule *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\nreturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.126000195825}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\ndUASSERT (o1->body && o2->capsule, \"The first argument of dImmerseBoxCapsule has no body or the second has no capsule\");\n\ndContactGeom c[1];\nconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\nif (collision == 0)\nreturn 0;\n\ndxBox *const box = (dxBox *) o1;\ndxCapsule *const capsule = (dxCapsule *) o2;\n\nimmersion->g1 = o1;\nimmersion->g2 = o2;\n\ndVector4 fluidPlane;\ndGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\nreturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 93.84901542936205}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\nconst dReal end = asin(sinTheta1);\nconst dReal singularityStart = singularityFactor * end;\ndReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\nvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\nreturn 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.37044387586516}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\nconst dReal end = asin(sinTheta1);\nconst dReal singularityStart = singularityFactor * end;\ndReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\nvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\nreturn volume;\n}", "CodeBleu_score": 90.77935417985923}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\nconst dReal end = asin(sinTheta1);\nconst dReal singularityStart = singularityFactor * end;\ndReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\nvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\nreturn volume;\n}", "CodeBleu_score": 90.77935417985923}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst dReal singularityStart = singularityFactor * sinTheta1;\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\ndReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\nx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\nreturn x * m_fRadius * volume;\n}", "CodeBleu_score": 66.14776994939587}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst dReal singularityStart = singularityFactor * sinTheta1;\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\ndReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\nx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\nreturn x * m_fRadius * volume;\n}", "CodeBleu_score": 66.14776994939587}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst dReal singularityStart = singularityFactor * sinTheta1;\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\ndReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\nxBuoyancyCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\nxBuoyancyCenter *= m_fRadius;\nxBuoyancyCenter += volume;\nreturn xBuoyancyCenter;\n}", "CodeBleu_score": 62.72583651398392}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTrimesh *const trimesh = (dxTrimesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomTrimeshGetImmersionPlane(trimesh, fluidPlane);\n\n\treturn dImmerseCapsule(capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 84.65090170707502}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTrimesh *const trimesh = (dxTrimesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomTrimeshGetImmersionPlane(trimesh, fluidPlane);\n\n\treturn dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 84.92615346475415}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTriMesh *const triMesh = (dxTriMesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tconst dReal *const rotation = triMesh->final_posr->R;\n\tconst dReal *const center = triMesh->final_posr->pos;\n\tconst dReal r = triMesh->radius;\n\tconst dVector3 p = { r * rotation[0 + FLUID_PLANE_NORMAL] + center[0], r * rotation[4 + FLUID_PLANE_NORMAL] + center[1], r * rotation[8 + FLUID_PLANE_NORMAL] + center[2] };\n\tdVector4 fluidPlane;\n\tdGeomTriMeshGetTangentPlane(triMesh, p[0], p[1], p[2], fluidPlane);\n\n\treturn dImmerseCapsule (capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 76.11102886953071}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\tstd::string duration_str = getInput<std::string>(\"duration\");\n\tif (duration_str.empty()) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tint64_t duration_ms = 0;\n\ttry {\n\t\tduration_ms = std::stoi(duration_str);\n\t} catch (std::invalid_argument& e) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tif (duration_ms <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_waiting_ = true;\n\ttimer_.expires_from_now(std::chrono::milliseconds(duration_ms));\n\ttimer_.async_wait(\n\t\t[this](const boost::system::error_code& ec) {\n\t\t\tif (!ec) {\n\t\t\t\tsetStatus(NodeStatus::SUCCESS);\n\t\t\t} else {\n\t\t\t\tsetStatus(NodeStatus::FAILURE);\n\t\t\t}\n\t\t\ttimer_waiting_ = false;\n\t\t}\n\t);\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 50.5826329908613}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (config_.params.size()!= 1) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\ttry {\n\t\tsleep_duration_ = std::chrono::milliseconds(std::stoll(config_.params[0]));\n\t} catch (std::invalid_argument& e) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tif (sleep_duration_.count() <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_ = std::make_shared<Timer>(sleep_duration_);\n\ttimer_->setCallback([this]() {\n\t\ttimer_waiting_ = false;\n\t\twakeUp();\n\t});\n\ttimer_->start();\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.592925466740525}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tconst auto& params = getInputParameters();\n\tif (params.size()!= 1) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tconst auto& param = params.at(0);\n\tif (!param.is_number()) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tconst auto& duration_ms = param.as_number();\n\tif (duration_ms <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_waiting_ = false;\n\ttimer_.reset(new Timer(duration_ms, [this]() {\n\t\tif (timer_waiting_) {\n\t\t\ttimer_waiting_ = false;\n\t\t\temitWakeUp();\n\t\t}\n\t}));\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 46.415761543460874}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// get entry from blackboard\n\tauto entry = getInput<Blackboard::Entry>(entry_key_);\n\n\t// check if entry is not found\n\tif (entry.second == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// check if entry is updated\n\tif (entry.second->sequence_id!= sequence_id_) {\n\t\tsequence_id_ = entry.second->sequence_id;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// entry is not updated\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.787758716457716}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tauto entry = getInput<Blackboard::Entry>(entry_key_);\n\tif (!entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex\n\tentry->mutex.lock();\n\n\t// Compare the sequence ID\n\tif (entry->sequence_id!= sequence_id_) {\n\t\t// Update the stored sequence ID\n\t\tsequence_id_ = entry->sequence_id;\n\t\t// Return SUCCESS\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Unlock the mutex\n\tentry->mutex.unlock();\n\n\t// Return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 38.17043884263599}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t", "CodeBleu_score": 3.7010066864531876}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tcess_threshold_ < 0) {\nreturn children_nodes_.size() + success_threshold_;\n} else {\nreturn static_cast<size_t>(success_threshold_);\n}\n}", "CodeBleu_score": 46.44126554004443}, {"code": "size_t ParallelNode::successThreshold() const{\n\tcess_threshold_ < 0) {\n// If the success threshold is negative, it adjusts the value based on the number of child nodes, ensuring the result is non-negative.\nconst size_t children_count = children_nodes_.size();\nif (children_count == 0) {\nreturn 0;\n}\nreturn std::max(static_cast<size_t>(0), children_count + success_threshold_);\n}\nreturn static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 49.33692572047652}, {"code": "size_t ParallelNode::successThreshold() const{\n\tess_threshold_ < 0) {\nreturn static_cast<size_t>(std::max(0, children_nodes_.size() + success_threshold_));\n}\nreturn static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 44.56204115354359}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (_p->should_run) {\n\t\t// wait for 10ms\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// check if the heartbeat is still active\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\tif (_p->heartbeat_last_time == 0) {\n\t\t\t// heartbeat is not active\n\t\t\tcontinue;\n\t\t}\n\n\t\t// calculate the time elapsed since the last heartbeat\n\t\tauto now = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());\n\t\tauto elapsed = now - _p->heartbeat_last_time;\n\n\t\t// check if the heartbeat is still active\n\t\tif (elapsed.count() < _p->heartbeat_timeout) {\n\t\t\t// heartbeat is still active\n\t\t\tcontinue;\n\t\t}\n\n\t\t// heartbeat is not active\n\t\t_p->heartbeat_last_time = 0;\n\n\t\t// disable all breakpoints\n\t\tenableAllHooks(false);\n\t}\n}", "CodeBleu_score": 43.270220895611665}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\tif(_p->heartbeat_time!= _p->last_heartbeat_time) {\n\t\t\tenableAllHooks(true);\n\t\t\t_p->last_heartbeat_time = _p->heartbeat_time;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.507850521889363}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\t// wait for 10ms\n\t\t_p->status_cv.wait_for(lk, std::chrono::milliseconds(10));\n\t\t// check if the heartbeat is still active\n\t\tif (_p->last_heartbeat_time == _p->last_heartbeat_time_active) {\n\t\t\t// heartbeat is still active, do nothing\n\t\t\tcontinue;\n\t\t}\n\t\t// heartbeat is not active, disable all breakpoints\n\t\tenableAllHooks(false);\n\t\t// update the last heartbeat time\n\t\t_p->last_heartbeat_time = _p->last_heartbeat_time_active;\n\t}\n}", "CodeBleu_score": 27.115503820417203}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t", "CodeBleu_score": 5.780157160879095}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> out;\n\tauto bb_names = split(bb_list, ',');\n\n\tfor(const auto& bb_name : bb_names) {\n\t\tif(bb_name.empty()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto bb_tree = _p->blackboard_tree.find(bb_name);\n\t\tif(bb_tree == _p->blackboard_tree.end()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstd::unique_lock<std::mutex> lock(bb_tree->second->mutex);\n\t\tif(!bb_tree->second->valid) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto bb_json = bb_tree->second->to_json();\n\t\tout.insert(out.end(), bb_json.begin(), bb_json.end());\n\t}\n\n\treturn out;\n}", "CodeBleu_score": 49.47330657903627}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> mp_dump;\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\tfor (auto& bb_name : bb_names) {\n\t\tstd::string bb_name_trimmed = trim(bb_name);\n\t\tstd::string bb_name_trimmed_lower = to_lower(bb_name_trimmed);\n\t\tauto subtree = _p->blackboard_tree.find(bb_name_trimmed_lower);\n\t\tif (subtree!= _p->blackboard_tree.end()) {\n\t\t\tstd::unique_lock<std::mutex> lk(subtree->second->mutex);\n\t\t\tif (subtree->second->valid) {\n\t\t\t\tauto json = subtree->second->to_json();\n\t\t\t\tmp_dump.insert(mp_dump.end(), json.begin(), json.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn mp_dump;\n}", "CodeBleu_score": 50.523668656192335}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tTreeNode::Ptr node = it->second.lock();\n\tif (!node) {\n\t\treturn false;\n\t}\n\n\tauto hook = _p->pre_hooks.find(node_uid);\n\tif (hook == _p->pre_hooks.end()) {\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lk(hook->second->mutex);\n\n\tif (hook->second->mode!= Monitor::Hook::Mode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\thook->second->desired_status = result;\n\thook->second->remove_when_done = remove;\n\thook->second->ready = true;\n\thook->second->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 60.982728082482105}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tTreeNode::Ptr node = it->second.lock();\n\tif (!node) {\n\t\treturn false;\n\t}\n\n\tauto it_hook = _p->pre_hooks.find(node_uid);\n\tif (it_hook == _p->pre_hooks.end()) {\n\t\treturn false;\n\t}\n\n\tstd::unique_lock<std::mutex> lk(it_hook->second->mutex);\n\tif (it_hook->second->mode!= Monitor::Hook::Mode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\tit_hook->second->desired_status = result;\n\tit_hook->second->remove_when_done = remove;\n\tit_hook->second->ready = true;\n\tit_hook->second->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 59.155469717975116}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tTreeNode::Ptr node = it->second.lock();\n\tif (!node) {\n\t\treturn false;\n\t}\n\n\tauto hook = getHook(pos, node_uid);\n\tif (!hook) {\n\t\treturn false;\n\t}\n\n\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\tif (hook->mode!= Monitor::Hook::Mode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\thook->desired_status = result;\n\thook->remove_when_done = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 77.43763465878615}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t (status() == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_.store(false);\n\t\tstd::thread t(tick_functor_);\n\t\tt.detach();\n\t}\n\t//------------------------------------------\n\tif (status() == NodeStatus::RUNNING) {\n\t\tif (halt_requested_.load()) {\n\t\t\tonHalted();\n\t\t\tresetStatus();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tsetStatus(tick_functor_(*this));\n\t\t\t} catch (std::exception& e) {\n\t\t\t\tLOG_ERROR(e.what());\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t}\n\t\t}\n\t}\n\treturn status();\n}", "CodeBleu_score": 38.31073830238994}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t (status() == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tresetHaltRequested();\n\t\tstd::thread t([this]() {\n\t\t\ttry {\n\t\t\t\ttick();\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl;\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (stored_exception_) {\n\t\t\t\t\tstd::rethrow_exception(stored_exception_);\n\t\t\t\t}\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl;\n\t\t\t}\n\t\t\tsetStatus(status());\n\t\t});\n\t\tt.detach();\n\t} else if (status() == NodeStatus::RUNNING) {\n\t\ttick();\n\t\tif (!isHaltRequested()) {\n\t\t\tsetStatus(status());\n\t\t}\n\t}\n\treturn status();\n}", "CodeBleu_score": 45.607028967762055}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tnst NodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tNodeStatus new_status = onStart();\n\t\tif (new_status == NodeStatus::IDLE) {\n\t\t\tthrow LogicError(\n\t\t\t\t\t\"ThreadedAction::onStart() must not return IDLE\");\n\t\t}\n\t\treturn new_status;\n\t}\n\t//------------------------------------------\n\tif (prev_status == NodeStatus::RUNNING) {\n\t\tNodeStatus new_status = onRunning();\n\t\tif (new_status == NodeStatus::IDLE) {\n\t\t\tthrow LogicError(\n\t\t\t\t\t\"ThreadedAction::onRunning() must not return IDLE\");\n\t\t}\n\t\treturn new_status;\n\t}\n\treturn prev_status;\n}", "CodeBleu_score": 29.232786437196346}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tconst auto separator = \"------------------------------------------------------------------------\n\";\n\nauto print_node = [&](const TreeNode* node) {\nstream << separator;\n\nconst auto node_name = node->name();\nconst auto node_depth = node->depth();\n\nstream << std::string(node_depth,'') << node_name << '\n';\n\nif (auto control = dynamic_cast<const ControlNode*>(node)) {\nfor (const auto& child : control->children()) {\nprint_node(static_cast<const TreeNode*>(child));\n}\n} else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\nprint_node(decorator->child());\n}\n};\n\nprint_node(root_node);\n\nstream << separator;\n}", "CodeBleu_score": 39.62104946130329}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif(!root_node)\n{\nthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nstream << \"-------------------------------------------------\n\";\nstream << \"Tree structure:\n\";\nstream << \"-------------------------------------------------\n\";\n\nauto print_node = [&](const TreeNode* node) {\nstream << std::string(node->depth(),'') << node->name() << \"\n\";\n};\n\napplyRecursiveVisitor(root_node, print_node);\n\nstream << \"-------------------------------------------------\n\";\n}", "CodeBleu_score": 23.63688913960021}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tauto print_node = [&stream](const TreeNode* node) {\nif (node == nullptr) {\nthrow std::logic_error(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\n// Print separator lines\nstream << std::string(node->depth() * 2,'') << \"+- \" << node->name() << \"\n\";\n\n// Print children\nif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor (const auto& child : control->children()) {\nprint_node(static_cast<const TreeNode*>(child));\n}\n} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\nprint_node(decorator->child());\n}\n};\n\n// Print separator lines\nstream << \"--- \" << root_node->name() << \"\n\";\n\n// Print root node\nprint_node(root_node);\n\n// Print separator lines\nstream << std::string(root_node->depth() * 2,'') << \"+- \" << root_node->name() << \"\n\";\n}", "CodeBleu_score": 46.34950437409252}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr)\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\n\tvisitor(node);\n\tif (const ControlNode* cn = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const TreeNode* child : cn->children)\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t} else if (const DecoratorNode* dn = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(dn->child, visitor);\n\t}\n}", "CodeBleu_score": 52.56314173262133}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->isComposite()) {\n\t\tfor (const auto& child : node->children()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->isDecorator()) {\n\t\tapplyRecursiveVisitor(node->child(0), visitor);\n\t}\n}", "CodeBleu_score": 42.01662744595996}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"Null node passed to applyRecursiveVisitor\");\n\t}\n\n\tvisitor(node);\n\n\tif (node->is_composite()) {\n\t\tfor (auto& child : node->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t}\n\telse if (node->is_decorator()) {\n\t\tapplyRecursiveVisitor(node->child, visitor);\n\t}\n}", "CodeBleu_score": 41.16045026018323}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif(this->_p->builders.count(manifest.registration_id)) {\nthrow BehaviorTreeException(\n\"The registration ID [\" + manifest.registration_id + \"] is already registered\");\n}\nthis->_p->builders[manifest.registration_id] = builder;\nthis->_p->manifests[manifest.registration_id] = manifest;\n}", "CodeBleu_score": 41.89287849767279}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t", "CodeBleu_score": 4.749989352683406}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (this->builtinNodes().count(manifest.ID)) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"You can not register the builtin registration ID [\" + manifest.ID + \"]\");\n\t}\n\tauto it = _p->builders.find(manifest.ID);\n\tif (it!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"You can not register the registration ID [\" + manifest.ID +\n\t\t\t\"] because it already exists\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.ID, builder));\n\t_p->manifests.insert(std::make_pair(manifest.ID, manifest));\n}", "CodeBleu_score": 52.12372410816146}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\todeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n  return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n};\n\nTreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 97.03597300689803}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t", "CodeBleu_score": 10.694302164157746}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t", "CodeBleu_score": 10.694302164157746}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> backup;\nbackup.reserve(tree.subtrees.size());\nfor(const auto& subtree : tree.subtrees) {\nauto bb = std::make_shared<Blackboard>();\nbb->cloneInto(*subtree->blackboard);\nbackup.push_back(bb);\n}\nreturn backup;\n}", "CodeBleu_score": 58.856784099721224}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> backup;\nbackup.reserve(tree.subtrees.size());\nfor(const auto& subtree : tree.subtrees) {\nbackup.emplace_back(std::make_shared<Blackboard>());\nsubtree->blackboard->cloneInto(*(backup.back()));\n}\nreturn backup;\n}", "CodeBleu_score": 61.63763951452287}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> backup;\nbackup.reserve(tree.subtrees.size());\nfor(auto const& subtree : tree.subtrees) {\nauto bb = std::make_shared<Blackboard>();\nbb->cloneInto(*subtree->blackboard);\nbackup.push_back(bb);\n}\nreturn backup;\n}", "CodeBleu_score": 57.987470294090805}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\treturn ParseScript(script)(env);\n}", "CodeBleu_score": 23.883290906960614}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\treturn ParseScript(script)(env);\n}", "CodeBleu_score": 23.883290906960614}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tchar error_msgs_buffer[2048];\n\n\tauto input = lexy::string_input<lexy::utf8_encoding>(script);\n\tauto result = lexy::parse<BT::Grammar::stmt>(input, ErrorReport().to(error_msgs_buffer));\n\tif(result.has_value() && result.error_count() == 0) {\n\t\ttry {\n\t\t\tstd::vector<BT::Ast::ExprBase::Ptr> exprs = LEXY_MOV(result).value();\n\t\t\tif(exprs.empty()) {\n\t\t\t\treturn nonstd::make_unexpected(\"Empty Script\");\n\t\t\t}\n\n\t\t\treturn [exprs, script](Ast::Environment& env) -> Any {\n\t\t\t\ttry {\n\t\t\t\t\tfor(auto i = 0u; i < exprs.size() - 1; ++i) {\n\t\t\t\t\t\texprs[i]->evaluate(env);\n\t\t\t\t\t}\n\t\t\t\t\treturn exprs.back()->evaluate(env);\n\t\t\t\t}\n\t\t\t\tcatch(RuntimeError& err) {\n\t\t\t\t\tthrow RuntimeError(StrCat(\"Error in script [\", script, \"]\n\", err.what()));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcatch(std::runtime_error& err) {\n\t\t\treturn nonstd::make_unexpected(err.what());\n\t\t}\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(error_msgs_buffer);\n\t}\n}", "CodeBleu_score": 48.822228641916325}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_handle) {\n\t\tthrow RuntimeError(\"SharedLibrary already loaded\");\n\t}\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!_handle) {\n\t\tconst char* error = dlerror();\n\t\tthrow RuntimeError(error);\n\t}\n\t_path = path;\n}", "CodeBleu_score": 58.90029503195095}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\tif (_handle!= nullptr) {\n\t\tthrow RuntimeError(\"SharedLibrary: library already loaded\");\n\t}\n\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\tif (_handle == nullptr) {\n\t\tstd::string error_msg = dlerror();\n\t\tthrow RuntimeError(\"SharedLibrary: could not load library: \" + error_msg);\n\t}\n\n\t_path = path;\n}", "CodeBleu_score": 61.994443194286134}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tif (_handle!= nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (_handle == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\n\t_path = path;\n}", "CodeBleu_score": 50.082626488761385}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif(str.size() < 3) {\nreturn false;\n}\n\nauto stripped = str.substr(0, str.size() - 1);\nstripped = stripped.substr(1, stripped.size() - 1);\n\nif(stripped.empty()) {\nreturn false;\n}\n\nif(stripped_pointer) {\n*stripped_pointer = stripped;\n}\n\nreturn true;\n}", "CodeBleu_score": 23.761372095590076}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif(str.size() < 3) {\n\t\treturn false;\n\t}\n\tstd::string stripped = str.substr(1, str.size() - 2);\n\tif(stripped.empty()) {\n\t\treturn false;\n\t}\n\tif(stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif(stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 26.520287892530764}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tauto stripped = str.strip(StringView::WHITESPACE, StringView::WHITESPACE);\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front()!= '{' || stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 27.775986945419074}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t", "CodeBleu_score": 4.037265882870389}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\n\t//initialize the line iterator\n\tLineIterator iterator(costmap_, x0, y0, x1, y1);\n\n\t//iterate through the line\n\tfor(int i = 0; i < iterator.size(); ++i, ++iterator) {\n\t\t//get the cost of the current point\n\t\tunsigned char cost = costmap_.getCost(iterator.getX(), iterator.getY());\n\n\t\t//if the point is not traversable, return the cost\n\t\tif(cost == NO_INFORMATION || cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n\t\t\treturn -cost;\n\n\t\t//update the line cost if the point cost is higher\n\t\tline_cost = std::max(line_cost, cost);\n\t}\n\n\t//return the total line cost\n\treturn line_cost;\n}", "CodeBleu_score": 51.39799704680237}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator it(costmap_, x0, y0, x1, y1);\n\tfor(unsigned int i = 0; i < it.size(); ++i, ++it) {\n\t\tunsigned char cost = costmap_.getCost(it.getX(), it.getY());\n\t\tif(cost == NO_INFORMATION)\n\t\t\treturn -2.0;\n\t\tif(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n\t\t\treturn -1.0;\n\t\tline_cost = std::max(line_cost, cost);\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 52.297325140605636}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Got an empty path to publish\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\n\tfor (std::vector<geometry_msgs::PoseStamped>::const_iterator it = path.begin(); it!= path.end(); ++it) {\n\t\tmsg.poses.push_back(it->pose);\n\t}\n\n\tpub.publish(msg);\n}", "CodeBleu_score": 52.7236266898468}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Received plan with zero length\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\tmsg.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tmsg.poses[i] = path[i].pose;\n\t}\n\tpub.publish(msg);\n}", "CodeBleu_score": 65.06783283116005}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path msg;\n\tmsg.header.frame_id = path[0].header.frame_id;\n\tmsg.header.stamp = path[0].header.stamp;\n\tfor (std::vector<geometry_msgs::PoseStamped>::const_iterator it = path.begin(); it!= path.end(); it++) {\n\t\tmsg.poses.push_back(it->pose);\n\t}\n\tpub.publish(msg);\n}", "CodeBleu_score": 54.111570117588585}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t//check to see if we've reached our goal position\n\tdouble linear_velocity = base_odom.twist.twist.linear.x;\n\tdouble angular_velocity = base_odom.twist.twist.angular.z;\n\n\tif (linear_velocity <= trans_stopped_velocity && angular_velocity <= rot_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 50.172636047639685}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tdouble linear_velocity = base_odom.twist.twist.linear.x;\n\tdouble angular_velocity = base_odom.twist.twist.angular.z;\n\n\tif (fabs(linear_velocity) <= trans_stopped_velocity && fabs(angular_velocity) <= rot_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 50.46115173501787}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t//check to see if we've stopped moving\n\n    if (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n      return true;\n    }\n    return false;\n  }", "CodeBleu_score": 83.57795036117388}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif(restore_defaults) {\n\t\tROS_INFO(\"Restoring default configuration\");\n\t\tconfig_mutex_.lock();\n\t\tconfig_ = default_config_;\n\t\tconfig_mutex_.unlock();\n\t} else {\n\t\tROS_INFO(\"Reconfiguring limits\");\n\t\tconfig_mutex_.lock();\n\t\tconfig_ = config;\n\t\tconfig_mutex_.unlock();\n\t}\n}", "CodeBleu_score": 35.8857129291152}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// Check if we are already setup\n\tif (!initialized_) {\n\t\t// Initialize the configuration\n\t\tconfig_ = config;\n\t\t// Set up the flag\n\t\tsetup_ = true;\n\t\t// Set the limits\n\t\tsetLimits(config_);\n\t\t// Lock the configuration mutex\n\t\tconfig_mutex_.lock();\n\t\t// Set the current limits\n\t\tcurrent_config_ = config_;\n\t\t// Unlock the configuration mutex\n\t\tconfig_mutex_.unlock();\n\t} else {\n\t\t// Check if we are supposed to restore the defaults\n\t\tif (restore_defaults) {\n\t\t\t// Lock the configuration mutex\n\t\t\tconfig_mutex_.lock();\n\t\t\t// Set the current limits\n\t\t\tcurrent_config_ = config_;\n\t\t\t// Unlock the configuration mutex\n\t\t\tconfig_mutex_.unlock();\n\t\t} else {\n\t\t\t// Lock the configuration mutex\n\t\t\tconfig_mutex_.lock();\n\t\t\t// Set the current limits\n\t\t\tcurrent_config_ = config;\n\t\t\t// Unlock the configuration mutex\n\t\t\tconfig_mutex_.unlock();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.626786074985446}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\teck the cost of the cell\nunsigned int cost = costmap.getCost(check_cell->cx, check_cell->cy);\nif(cost == costmap_2d::LETHAL_OBSTACLE) {\n//obstacle, set target distance to maximum obstacle cost and return false\ncurrent_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\nreturn false;\n} else if(cost == costmap_2d::NO_INFORMATION) {\n//no information, set target distance to maximum obstacle cost and return false\ncurrent_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\nreturn false;\n}\n\n//calculate the new target distance\ndouble new_dist = current_cell->target_dist + costmap.getCost(check_cell->cx, check_cell->cy);\n\n//if the new distance is shorter, update the cell's target distance\nif(new_dist < current_cell->target_dist) {\ncurrent_cell->target_dist = new_dist;\nreturn true;\n}\n\n//if the new distance is longer, return false\nreturn false;\n}", "CodeBleu_score": 55.37359645746769}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\teck if the cell is an obstacle or has no information\nif (costmap.getCost(check_cell->cx, check_cell->cy) == costmap_2d::NO_INFORMATION) {\ncheck_cell->target_dist = costmap.getCostmap()->getCost(check_cell->cx, check_cell->cy);\nreturn false;\n}\n\n//calculate the new target distance\ndouble new_dist = costmap.getCost(check_cell->cx, check_cell->cy) +\ncurrent_cell->target_dist;\n\n//update the target distance if the new distance is shorter\nif (new_dist < check_cell->target_dist) {\ncheck_cell->target_dist = new_dist;\nreturn true;\n}\n\nreturn false;\n}", "CodeBleu_score": 56.404887271835236}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\teck if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->cx, check_cell->cy) == costmap_2d::NO_INFORMATION) {\n\t\t//the cell is an obstacle or has no information\n\t\t//set the target distance to the maximum obstacle cost and return false\n\t\tcheck_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\n\t\treturn false;\n\t}\n\n\t//calculate the new target distance\n\tunsigned int new_target_dist = costmap.getCost(check_cell->cx, check_cell->cy) + current_cell->dist_from_start;\n\n\t//if the new target distance is shorter, update the cell's target distance\n\tif (new_target_dist < check_cell->target_dist) {\n\t\tcheck_cell->target_dist = new_target_dist;\n\t}\n\n\t//return true\n\treturn true;\n}", "CodeBleu_score": 61.756910049051314}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/ Initialize cost and scaling factor based on the trajectory and speed parameters.\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty\");\n\t\treturn -9.0;\n\t}\n\n\t// Calculate the footprint cost for each point in the trajectory.\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n\t\t// Get the footprint cost for the current point.\n\t\tdouble footprint_cost = getFootprintCost(traj.getPoint(i));\n\n\t\t// If the footprint cost is negative, return immediately.\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn -1.0;\n\t\t}\n\n\t\t// Sum the scores or take the maximum score based on the sum_scores_ flag.\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\t// Calculate the scaling factor based on the current speed and scaling speed.\n\tscaling_factor = std::min(1.0, std::max(0.0, (traj.getSpeed() - min_speed_) / scaling_speed_));\n\n\t// Return the total cost.\n\treturn cost * scaling_factor;\n}", "CodeBleu_score": 49.12724509218857}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/ initialize cost and scaling factor\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// check if footprint is specified\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9.0;\n\t}\n\n\t// calculate footprint cost\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble footprint_cost = world_model_->footprintCost(traj.getPoint(i), footprint_spec_);\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn -9.0;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\n\t// calculate scaling factor\n\tdouble scaling_speed_cost = 1.0 / std::max(scaling_speed_, 0.0001);\n\tdouble speed_cost = 1.0 - scaling_speed_cost * traj.getSpeed();\n\tscaling_factor = std::max(scaling_factor, speed_cost);\n\n\t// calculate total cost\n\tcost *= scaling_factor;\n\n\treturn cost;\n}", "CodeBleu_score": 54.906766861514654}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t    ROS_DEBUG(\"Calculating footprint cost for x=%f, y=%f, th=%f, scale=%f\", x, y, th, scale);\n\n    // scale the footprint points\n    std::vector<geometry_msgs::Point> scaled_footprint_spec;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point p;\n        p.x = footprint_spec[i].x * scale;\n        p.y = footprint_spec[i].y * scale;\n        scaled_footprint_spec.push_back(p);\n    }\n\n    // check if the robot's footprint is legal\n    double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint_spec, costmap);\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    // check if the robot is outside the costmap\n    if (!world_model->isPositionValid(x, y, th)) {\n        return -7.0;\n    }\n\n    // compute the footprint cost at the given position\n    double cell_cost = costmap->getCost(x, y);\n    if (cell_cost < 0) {\n        return -8.0;\n    }\n\n    // return the maximum of the footprint cost and the cell cost\n    return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 65.9557761840522}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t/  ROS_INFO(\"ObstacleCostFunction::footprintCost called\");\n\n//  ROS_INFO(\"ObstacleCostFunction::footprintCost called\");\n\n  //check if the footprint is legal\n  if (!isFootprintLegal(footprint_spec)) {\n    ROS_ERROR(\"Footprint specification is not legal\");\n    return -6.0;\n  }\n\n  //scale the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  scaled_footprint_spec.reserve(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point p;\n    p.x = footprint_spec[i].x * scale;\n    p.y = footprint_spec[i].y * scale;\n    scaled_footprint_spec.push_back(p);\n  }\n\n  //check if the footprint is legal\n  if (!isFootprintLegal(scaled_footprint_spec)) {\n    ROS_ERROR(\"Footprint specification is not legal\");\n    return -6.0;\n  }\n\n  //check if the footprint is inside the costmap\n  if (!world_model->isPositionValid(x, y, th, scaled_footprint_spec)) {\n    ROS_ERROR(\"Footprint is not inside the costmap\");\n    return -7.0;\n  }\n\n  //compute the footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint_spec, costmap);\n  if (footprint_cost < 0) {\n    ROS_ERROR(\"Footprint cost is negative\");\n    return -6.0;\n  }\n\n  //compute the cell cost\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    ROS_ERROR(\"Position is not on the costmap\");\n    return -7.0;\n  }\n  double cell_cost = costmap->getCost(mx, my);\n\n  //return the maximum of the footprint cost and the cell cost\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 64.20888712671248}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Setting odom topic to: %s\", odom_topic.c_str());\n\n//  if(odom_topic_ == odom_topic)\n//    return;\n\n//  if(odom_topic!= \"\") {\n//    odom_sub_ = node_handle_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n//  } else {\n//    odom_sub_.shutdown();\n//  }\n//  odom_topic_ = odom_topic;\n}", "CodeBleu_score": 3.8817094643040866}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\\\"dwa_local_planner\\\", \\\"Setting odometry topic to: %s\\\", odom_topic.c_str());\n//  if (odom_topic.empty()) {\n    if (!odom_sub_.getTopic().empty()) {\n      odom_sub_.shutdown();\n    }\n  }\n  else {\n    if (odom_sub_.getTopic().empty()) {\n      odom_sub_.subscribe(nh_, odom_topic, 1);\n      odom_sub_.registerCallback(boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    }\n    else if (odom_sub_.getTopic()!= odom_topic) {\n      odom_sub_.shutdown();\n      odom_sub_.subscribe(nh_, odom_topic, 1);\n      odom_sub_.registerCallback(boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    }\n  }\n}", "CodeBleu_score": 44.792011526090825}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tboost::mutex::scoped_lock lock(odom_mutex_);\n\n\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\n\t\tif (!odom_topic_.empty()) {\n\t\t\tros::NodeHandle n;\n\t\t\todom_sub_ = n.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 51.57911963160713}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\n//calculate the squared distance\ndouble dist_sq = (pos - prev).squaredNorm();\n\n//if the distance exceeds the threshold, reset the oscillation flags\nif (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_) {\n\n//calculate the angular difference\ndouble angle = fabs(pos.z() - prev.z());\n\n//if the angle exceeds the threshold, reset the oscillation flags\nif (angle > oscillation_reset_angle_) {\n\n//reset the oscillation flags\nforward_pos_only_ = false;\nforward_neg_only_ = false;\nstrafe_pos_only_ = false;\nstrafe_neg_only_ = false;\nrot_pos_only_ = false;\nrot_neg_only_ = false;\n}\n}\n}", "CodeBleu_score": 34.522065950191184}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tif (std::abs(prev.x() - pos.x()) > oscillation_reset_dist_) {\nforward_pos_only_ = forward_neg_only_ = false;\n}\nif (std::abs(prev.y() - pos.y()) > oscillation_reset_dist_) {\nstrafe_pos_only_ = strafe_neg_only_ = false;\n}\nif (std::abs(prev.z() - pos.z()) > oscillation_reset_dist_) {\nrot_pos_only_ = rot_neg_only_ = false;\n}\n}", "CodeBleu_score": 33.38723214947245}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tdouble sq_dist = (pos - prev).squaredNorm();\ndouble angle = fabs(atan2(pos.y() - prev.y(), pos.x() - prev.x()) - atan2(pos.y(), pos.x()));\nif (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ || angle > oscillation_reset_angle_) {\nforward_pos_only_ = false;\nforward_neg_only_ = false;\nstrafe_pos_only_ = false;\nstrafe_neg_only_ = false;\nrot_pos_only_ = false;\nrot_neg_only_ = false;\n}\n}", "CodeBleu_score": 43.991406717293216}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tunsigned int gx, gy;\n\tif (!gridCoords(pt, gx, gy))\n\t\treturn;\n\n\tunsigned int index = gridIndex(gx, gy);\n\tcells_[index].push_back(pt);\n}", "CodeBleu_score": 63.75984829793403}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tunsigned int gx, gy;\n\n//if the grid coordinates are outside the bounds of the grid... return\nif(!gridCoords(pt, gx, gy))\nreturn;\n\n//get the associated index\nunsigned int index = gridIndex(gx, gy);\n\n//if the index is out of bounds... return\nif(index >= cells_.size())\nreturn;\n\n//insert the point into the cell\ncells_[index].push_back(pt);\n}", "CodeBleu_score": 71.08747132615166}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\nunsigned int gx, gy;\nif (!gridCoords(pt, gx, gy)) {\n//printf(\\\"Point (%.2f, %.2f) is too close to its nearest neighbor.\n\\\", pt.x, pt.y);\nreturn;\n}\n\n//get the associated index\nunsigned int index = gridIndex(gx, gy);\n\n//insert the point into the cell\ncells_[index].push_back(pt);\n}", "CodeBleu_score": 62.70825628654032}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t", "CodeBleu_score": 6.285623149499962}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\nEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n// For each of the three velocity components, it increases or decreases the current velocity towards the target velocity within the acceleration limits.\n\nnew_vel[0] = sample_target_vel[0] - vel[0];\nnew_vel[0] = std::min(acclimits[0] * dt, std::max(new_vel[0], -acclimits[0] * dt));\n\nnew_vel[1] = sample_target_vel[1] - vel[1];\nnew_vel[1] = std::min(acclimits[1] * dt, std::max(new_vel[1], -acclimits[1] * dt));\n\nnew_vel[2] = sample_target_vel[2] - vel[2];\nnew_vel[2] = std::min(acclimits[2] * dt, std::max(new_vel[2], -acclimits[2] * dt));\n\n// Finally, it returns the new velocity vector.\nreturn new_vel;\n}", "CodeBleu_score": 39.66712965305895}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t", "CodeBleu_score": 6.285623149499962}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble heading_diff = DBL_MAX;\n\n\t//get the coordinates of the goal cell\n\tint goal_x, goal_y;\n\tif (!costmap_.worldToMap(global_plan_[global_plan_.size() - 1].pose.position.x, global_plan_[global_plan_.size() - 1].pose.position.y, goal_x, goal_y)) {\n\t\tROS_ERROR(\"Could not convert global goal pose to map coordinates\");\n\t\treturn heading_diff;\n\t}\n\n\t//iterate through the global plan in reverse\n\tfor (int i = global_plan_.size() - 1; i >= 0; --i) {\n\t\t//get the coordinates of the point\n\t\tint point_x, point_y;\n\t\tif (!costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, point_x, point_y)) {\n\t\t\tROS_ERROR(\"Could not convert global plan point to map coordinates\");\n\t\t\treturn heading_diff;\n\t\t}\n\n\t\t//check if the point is on the same cell as the goal\n\t\tif (point_x == goal_x && point_y == goal_y) {\n\t\t\t//get the angle between the point and the goal\n\t\t\tdouble angle = atan2(global_plan_[i].pose.position.y - y, global_plan_[i].pose.position.x - x);\n\n\t\t\t//calculate the shortest angular distance between the angle and the robot's heading\n\t\t\tdouble temp_diff = fabs(angle - heading);\n\t\t\tif (temp_diff > M_PI) {\n\t\t\t\ttemp_diff = 2.0 * M_PI - temp_diff;\n\t\t\t}\n\n\t\t\t//if the angle is closer to the goal, set the heading difference\n\t\t\tif (temp_diff < heading_diff) {\n\t\t\t\theading_diff = temp_diff;\n\t\t\t}\n\n\t\t\t//we found the farthest point with a clear line of sight, so we can stop iterating\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn heading_diff;\n}", "CodeBleu_score": 49.608303443418365}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = 0.0;\n\tdouble goal_x = global_plan_[global_plan_.size() -1].pose.position.x;\n\tdouble goal_y = global_plan_[global_plan_.size() -1].pose.position.y;\n\tdouble goal_heading = atan2(goal_y - y, goal_x - x);\n\tdouble theta = heading;\n\tint i = 0;\n\tint num_steps = 10;\n\tfor(i = 0; i < num_steps; ++i) {\n\t\tdouble x_i, y_i, theta_i;\n\n\t\tcomputeNewPosition(x, y, theta, i, num_steps, x_i, y_i, theta_i);\n\n\t\tunsigned int cell_x_i, cell_y_i;\n\n\t\tif(!costmap_.worldToMap(x_i, y_i, cell_x_i, cell_y_i)) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tdouble cost = footprintCost(x_i, y_i, theta_i);\n\n\t\tif(cost < 0) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif(cost == 0) {\n\n\t\t\t//we found a valid point\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\ttheta = theta_i;\n\n\t}\n\tif(i == num_steps) {\n\t\t//we didn't find a valid point\n\n\t\treturn DBL_MAX;\n\n\t}\n\t//we found a valid point\n\n\t//convert to world coordinates\n\n\tdouble goal_x_w, goal_y_w;\n\n\tcostmap_.mapToWorld(cell_x_i, cell_y_i, goal_x_w, goal_y_w);\n\n\t//compute the difference in heading\n\n\tdiff = fabs(angles::shortest_angular_distance(theta, goal_heading));\n\n\treturn diff;\n\n}", "CodeBleu_score": 43.71892057644685}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n//check that the velocity will not cause the robot to move out of the local costmap\ndouble robot_x = x;\ndouble robot_y = y;\ndouble robot_theta = theta;\n\n//check the trajectory\nif (!isTrajectoryValid(robot_x, robot_y, robot_theta, vx_samp, vy_samp, vtheta_samp)) {\nROS_WARN(\"TrajectoryPlanning: Exceeded costmap bounds, trajectory not valid.\");\nreturn false;\n}\n\n//score the trajectory\ndouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\nif (cost >= 0) {\nreturn true;\n} else {\nROS_WARN(\"TrajectoryPlanning: Cost is negative! This should not happen, please report this! vx=%.2f, vy=%.2f, vtheta=%.2f, vx_samp=%.2f, vy_samp=%.2f, vtheta_samp=%.2f, cost=%.2f\", vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\nreturn false;\n}\n}", "CodeBleu_score": 66.25365286561889}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\ndouble time = 0.0;\ndouble dt = 0.05;\ndouble acc_x = 0.0;\ndouble acc_y = 0.0;\ndouble acc_theta = 0.0;\n\ndouble x_i = x;\ndouble y_i = y;\ndouble theta_i = theta;\ndouble vx_i = vx;\ndouble vy_i = vy;\ndouble vtheta_i = vtheta;\n\ndouble occ_cost = 0.0;\n\nfor (int i = 0; i < numsteps_; ++i) {\n\n//calculate velocities\nvx_i = computeNewVelocity(vx_samp, vx_i, acc_x, dt);\nvy_i = computeNewVelocity(vy_samp, vy_i, acc_y, dt);\nvtheta_i = computeNewVelocity(vtheta_samp, vtheta_i, acc_theta, dt);\n\n//calculate positions\nx_i = computeNewXPosition(x_i, vx_i, vy_i, theta_i, dt);\ny_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\ntheta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n//increment time\ntime += dt;\n}\n\n//ROS_INFO(\"OccCost: %f, vx: %.2f, vy: %.2f, vtheta: %.2f\", occ_cost, vx_samp, vy_samp, vtheta_samp);\ndouble cost = -1.0;\nif (!heading_scoring_) {\ncost = path_distance_bias_ * path_dist + goal_dist * goal_distance_bias_ + occdist_scale_ * occ_cost;\n} else {\ncost = occdist_scale_ * occ_cost + path_distance_bias_ * path_dist + 0.3 * heading_diff + goal_dist * goal_distance_bias_;\n}\ntraj.cost_ = cost;\n\nreturn cost >= 0.0;\n}", "CodeBleu_score": 35.97756593428184}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"Global costmap is NULL, unable to clear costmap\");\n\t\treturn;\n\t}\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"Local costmap is NULL, unable to clear costmap\");\n\t\treturn;\n\t}\n\tif (affected_maps_ == \"local\") {\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing the local costmap inside the specified area\");\n\t\t}\n\t\tclearLocalCostmap();\n\t} else if (affected_maps_ == \"global\") {\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing the global costmap inside the specified area\");\n\t\t}\n\t\tclearGlobalCostmap();\n\t} else if (affected_maps_ == \"both\") {\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing both costmaps inside the specified area\");\n\t\t}\n\t\tclearGlobalCostmap();\n\t\tclearLocalCostmap();\n\t} else {\n\t\tROS_ERROR(\"Invalid value for affected_maps parameter: %s\", affected_maps_.c_str());\n\t\treturn;\n\t}\n\tif (force_updating_) {\n\t\tif (affected_maps_ == \"local\") {\n\t\t\tlocal_costmap_->resetLayers();\n\t\t} else if (affected_maps_ == \"global\") {\n\t\t\tglobal_costmap_->resetLayers();\n\t\t} else if (affected_maps_ == \"both\") {\n\t\t\tglobal_costmap_->resetLayers();\n\t\t\tlocal_costmap_->resetLayers();\n\t\t}\n\t}\n}", "CodeBleu_score": 44.27676270929896}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\tif (!global_costmap_ ||!local_costmap_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must have a valid global and local costmap before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tdouble start_time, end_time;\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"clearing inside the specified area, not outside\");\n\t}\n\n\tif (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n\t\tstart_time = ros::Time::now().toSec();\n\t\tif (force_updating_) {\n\t\t\tglobal_costmap_->resetLayers();\n\t\t}\n\t\tglobal_costmap_->clearCostmap();\n\t\tend_time = ros::Time::now().toSec();\n\t\tROS_INFO(\n\t\t\t\t\"cleared global costmap in %f seconds\", end_time - start_time);\n\t}\n\n\tif (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n\t\tstart_time = ros::Time::now().toSec();\n\t\tif (force_updating_) {\n\t\t\tlocal_costmap_->resetLayers();\n\t\t}\n\t\tlocal_costmap_->clearCostmap();\n\t\tend_time = ros::Time::now().toSec();\n\t\tROS_INFO(\n\t\t\t\t\"cleared local costmap in %f seconds\", end_time - start_time);\n\t}\n}", "CodeBleu_score": 51.2275573199793}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t(!initialized_) {\nROS_ERROR(\"This object must be initialized before runBehavior is called\");\nreturn;\n}\nif (global_costmap_ == NULL || local_costmap_ == NULL) {\nROS_ERROR(\"This object must have costmaps assigned before runBehavior is called\");\nreturn;\n}\n\nif (invert_area_to_clear_) {\nROS_WARN(\"Clearing inside the specified area\");\n} else {\nROS_WARN(\"Clearing outside the specified area\");\n}\n\nif (affected_maps_ == \"local\") {\nclearLocalCostmap();\n} else if (affected_maps_ == \"global\") {\nclearGlobalCostmap();\n} else if (affected_maps_ == \"both\") {\nclearLocalCostmap();\nclearGlobalCostmap();\n}\n\n}", "CodeBleu_score": 29.44743482360167}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\n// initialize the polygon outline cells object\nPolygonOutlineCells outline_cells(polygon);\n\n// iterate through the polygon, gathering the cells between each pair of points\nfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\n// get the next pair of points\nMapLocation p1 = polygon[i];\nMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\n// get the cells between these points\nstd::vector<MapLocation> cells;\nraytraceLine(p1, p2, cells);\n\n// add the cells to the outline cells object\noutline_cells.addCells(cells);\n}\n\n// close the polygon by connecting the last point to the first\nMapLocation p1 = polygon[polygon.size() - 1];\nMapLocation p2 = polygon[0];\nstd::vector<MapLocation> cells;\nraytraceLine(p1, p2, cells);\noutline_cells.addCells(cells);\n\n// get the cells from the outline cells object\noutline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 50.22452148595144}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t", "CodeBleu_score": 5.034306355366355}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\n// we assume the polygon is given in the global_frame... we need to transform it to map coordinates\nstd::vector<MapLocation> map_polygon;\nfor (unsigned int i = 0; i < polygon.size(); ++i) {\nMapLocation loc;\nif (!worldToMap(polygon[i].x, polygon[i].y, loc.x, loc.y)) {\n// (\\\"Polygon lies outside map bounds, so we can't fill it\\\");\nreturn;\n}\nmap_polygon.push_back(loc);\n}\n\nstd::vector<MapLocation> polygon_cells;\n\n// get the cells that fill the polygon\nconvexFillCells(map_polygon, polygon_cells);\n\n// set the cost of those cells\nfor (unsigned int i = 0; i < polygon_cells.size(); ++i) {\nunsigned int index = getIndex(polygon_cells[i].x, polygon_cells[i].y);\ncostmap_[index] = cost_value;\n}\nreturn true;\n}", "CodeBleu_score": 48.85651450890527}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t", "CodeBleu_score": 10.992937465607893}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (!active_)\n{\n// we're not active, so we don't need to do anything\nreturn;\n}\n\n// prepare the grid\nif (!prepareGrid())\nreturn;\n\n// publish the grid\nif (always_send_full_costmap_)\n{\ncostmap_pub_.publish(grid_);\n}\nelse\n{\nmap_msgs::OccupancyGridUpdate update;\nupdate.header.frame_id = global_frame_;\nupdate.header.stamp = ros::Time::now();\nupdate.x = xn_;\nupdate.y = yn_;\nupdate.width = x0_ - xn_;\nupdate.height = y0_ - yn_;\nupdate.data = grid_.data;\ncostmap_update_pub_.publish(update);\n}\n}", "CodeBleu_score": 48.474447529703404}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tif (active_) {\n\t\t// If this is the first subscriber, we need to publish the full costmap\n\t\t// and wait for the first update to set up the grid.\n\t\tif (pub.getNumPublishers() == 1) {\n\t\t\tprepareGrid();\n\t\t\tpublishGrid();\n\t\t}\n\t} else {\n\t\t// If this is the first subscriber, we need to wait for the first update\n\t\t// to set up the grid.\n\t\tactive_ = true;\n\t}\n}", "CodeBleu_score": 50.8308982583115}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the mutex, and get the resolution\n\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\t// Set the header\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\t// Set the resolution\n\tgrid_.info.resolution = resolution;\n\t// Set the width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t// Set the origin\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\t// Resize the data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t// Populate the data vector\n\tfor (unsigned int i = 0; i < grid_.data.size(); i++) {\n\t\tgrid_.data[i] = cost_translation_table_[costmap_->getCost(xn_, yn_)];\n\t}\n}", "CodeBleu_score": 67.30748859185854}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t", "CodeBleu_score": 0.7655082089124154}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tROS_DEBUG(\"Preparing grid\");\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tfloat res = costmap_->getResolution();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = res;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tfor (int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = costmap_->getCost(i % grid_.info.width, i / grid_.info.width);\n\t}\n}", "CodeBleu_score": 56.55626970634046}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint_string!= old_config.footprint_string) {\n\t\tif (new_config.footprint_string.empty()) {\n\t\t\tROS_ERROR(\"Footprint string is empty, using default footprint.\");\n\t\t\tsetUnpaddedRobotFootprint(unpadded_footprint_);\n\t\t\treturn;\n\t\t}\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (!parseFootprint(new_config.footprint_string, footprint)) {\n\t\t\tROS_ERROR(\"Footprint string is invalid, using default footprint.\");\n\t\t\tsetUnpaddedRobotFootprint(unpadded_footprint_);\n\t\t\treturn;\n\t\t}\n\t\tsetRobotFootprint(footprint);\n\t}\n\tif (new_config.robot_radius!= old_config.robot_radius) {\n\t\tsetUnpaddedRobotFootprint(unpadded_footprint_);\n\t}\n}", "CodeBleu_score": 49.6532093286816}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.robot_radius == old_config.robot_radius && new_config.footprint.size() == old_config.footprint.size()) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (new_config.footprint.size() > 0) {\n\t\tif (setUnpaddedRobotFootprint(new_config.footprint)) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tROS_ERROR(\"Footprint string is invalid\");\n\t\t}\n\t}\n\n\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\tsetUnpaddedRobotFootprint(new_config.robot_radius);\n}", "CodeBleu_score": 44.387434077171406}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t", "CodeBleu_score": 4.722552995136935}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!is_current_pose_valid_) {\n\t\tROS_WARN_THROTTLE(1.0, \"No valid pose received. Cannot reconfigure costmap.\");\n\t\treturn;\n\t}\n\n\tgeometry_msgs::PoseStamped new_pose;\n\tnew_pose.header.frame_id = robot_base_frame_;\n\tnew_pose.header.stamp = ros::Time::now();\n\tnew_pose.pose = current_pose_;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose. Cannot reconfigure costmap.\");\n\t\treturn;\n\t}\n\tif (new_pose.pose.position.x!= current_pose_.position.x\n\t\t\t|| new_pose.pose.position.y!= current_pose_.position.y) {\n\t\tcurrent_pose_ = new_pose.pose;\n\t\tis_current_pose_valid_ = true;\n\t\tlayered_costmap_->updateRobotPose(current_pose_);\n\t}\n}", "CodeBleu_score": 54.884973318854044}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped pose;\n\tif (!getRobotPose(pose)) {\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\tnew_pose_ = pose;\n}", "CodeBleu_score": 65.17875317250768}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// get the list of plugins\nros::NodeHandle nh;\nstd::vector<std::string> plugins;\n\n// check if the costmap is stopped\nif (stopped_) {\n// reactivate the plugins\nfor (std::vector<std::string>::iterator plugin = plugins.begin(); plugin!= plugins.end(); ++plugin) {\n// activate the plugin\n// set the stopped flag to false\n}\n// set the stop_updates_ flag to false\n}\n\n// wait for the map to be initialized\nwhile (!ros::ok() &&!layered_costmap_->isCurrent()) {\nros::Duration(0.1).sleep();\n}\n\n// wait for the map update thread to be active\nwhile (!ros::ok() &&!map_update_thread_->joinable()) {\nros::Duration(0.1).sleep();\n}\n\n// set the stopped flag to false\nstopped_ = false;\n}", "CodeBleu_score": 50.1828280588987}, {"code": "void Costmap2DROS::start(){\n\t\t// get the list of plugins\n\tros::NodeHandle nh;\n\tros::NodeHandle private_nh(\"~\");\n\tstd::vector<std::string> plugins;\n\tgetPlugins(nh, private_nh, plugins);\n\n\t// check if the costmap was stopped\n\tif (stopped_) {\n\t\t// re-subscribe to topics\n\t\tfor (std::vector<std::string>::iterator plugin = plugins.begin(); plugin!= plugins.end(); ++plugin) {\n\t\t\tstd::string topic = \"/\" + name_ + \"/\" + *plugin + \"/costmap\";\n\t\t\tif (private_nh.hasParam(topic)) {\n\t\t\t\tprivate_nh.subscribe(topic, 1, &Costmap2DROS::subscribePlugin, this);\n\t\t\t}\n\t\t}\n\n\t\t// set the stopped flag to false\n\t\tstopped_ = false;\n\t}\n\n\t// set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// wait until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::isStarted()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\twhile (!initialized_) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\twhile (!map_update_thread_->joinable()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n}", "CodeBleu_score": 50.05303479394178}, {"code": "void Costmap2DROS::start(){\n\t\t// get list of plugins\n\tstd::vector<std::string> plugins;\n\tgetPlugins(plugins);\n\n\t// check if costmap is stopped\n\tif (stopped_) {\n\t\t// re-subscribe to topics\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\tif (plugins[i] == \\\"Costmap2D\\\") {\n\t\t\t\tplugin_ = &plugins[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// reactivate plugins\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\tif (plugins[i]!= \\\"Costmap2D\\\") {\n\t\t\t\tplugin_manager_->activatePlugin(plugins[i]);\n\t\t\t}\n\t\t}\n\n\t\tstopped_ = false;\n\t}\n\n\t// set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// wait for ROS to be ready\n\tros::Rate r(10);\n\twhile (!ros::isStarted()) {\n\t\tr.sleep();\n\t}\n\n\t// wait for costmap to be initialized\n\twhile (!layered_costmap_->isCurrent()) {\n\t\tr.sleep();\n\t}\n\n\t// wait for map update thread to be active\n\twhile (!map_update_thread_->joinable()) {\n\t\tr.sleep();\n\t}\n}", "CodeBleu_score": 53.64083741127661}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\nobservation_list_.pop_back();\n} else {\nlist<Observation>::iterator obs_it = observation_list_.end();\n\nwhile (obs_it!= observation_list_.begin()) {\nobs_it--;\n\nif (obs_it->last_updated_.toSec() + observation_keep_time_ > ros::Time::now().toSec()) {\nbreak;\n}\n\nobservation_list_.erase(obs_it);\n}\n}\n}", "CodeBleu_score": 34.921920346839634}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t// if the observation keep time is zero, we keep only the most recent observation\nif (observation_keep_time_ == 0) {\nobservation_list_.pop_back();\n} else {\n// otherwise, we need to remove any stale observations\nros::Time now = ros::Time::now();\nlist<Observation>::iterator obs_it = observation_list_.begin();\nwhile (obs_it!= observation_list_.end()) {\nif (now - obs_it->last_updated_ > ros::Duration(observation_keep_time_)) {\nobs_it = observation_list_.erase(obs_it);\n} else {\nbreak;\n}\n}\n}\n}", "CodeBleu_score": 38.76074990466757}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\nobservation_list_.pop_back();\n} else {\nlist<Observation>::iterator obs_it;\nfor (obs_it = observation_list_.begin(); obs_it!= observation_list_.end();) {\nif (ros::Time::now() - obs_it->last_updated_ > observation_keep_time_) {\nobs_it = observation_list_.erase(obs_it);\n} else {\n++obs_it;\n}\n}\n}\n}", "CodeBleu_score": 36.80606004094985}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//    std::cout << \"Interpolating between \" << start_index << \" and \" << end_index << std::endl;\n\n    // Get the yaw angles at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Calculate the shortest angular distance between the start and end yaw angles\n    double diff = angles::shortest_angular_distance(end_yaw, start_yaw);\n\n    // Compute the incremental change in angle for each pose in the specified range\n    double angle_increment = diff / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i <= end_index; i++) {\n        double new_angle = start_yaw + angle_increment * (i - start_index);\n        set_angle(&path[i], new_angle);\n    }\n}", "CodeBleu_score": 68.60185269993389}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\ndouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\ndouble diff = fabs(angles::shortest_angular_distance(end_yaw, start_yaw));\ndouble angle_increment = diff / (end_index - start_index);\nfor (int i = start_index; i <= end_index; i++) {\nset_angle(&path[i], start_yaw + (i - start_index) * angle_increment);\n}\n}", "CodeBleu_score": 62.563013532168554}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\ndouble end_angle = tf2::getYaw(path[end_index].pose.orientation);\ndouble diff = fabs(angles::shortest_angular_distance(end_angle, start_angle));\ndouble increment = diff / (end_index - start_index);\n\nfor (int i = start_index; i <= end_index; i++) {\ndouble new_angle = start_angle + increment * (i - start_index);\nset_angle(&path[i], new_angle);\n}\n}", "CodeBleu_score": 64.97980919574911}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// call makePlan to generate a path\n\tvector<rm::PoseStamped> plan;\n\tif (!makePlan(req.start, req.goal, plan)) {\n\t\tROS_DEBUG(\"No plan found\");\n\t\tresp.plan.poses.clear();\n\t\treturn true;\n\t}\n\n\tROS_DEBUG(\"Found a plan with %zu points\", plan.size());\n\n\t// update the response with the success status and the generated path\n\tresp.plan.poses = plan;\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.success = true;\n\treturn true;\n}", "CodeBleu_score": 56.09056421005887}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// generate the plan\n\tbool found_plan = makePlan(req.start, req.goal, resp.plan);\n\n\t// set the response\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.found_path = found_plan;\n\n\treturn true;\n}", "CodeBleu_score": 56.00988923533288}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan)) {\n\t\t// Set the success status to true\n\t\tresp.success = true;\n\t} else {\n\t\t// Set the success status to false\n\t\tresp.success = false;\n\t}\n\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 48.70490821528827}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tcmap_ = cmap;\n\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tpose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 77.80120045264638}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tcmap_ = cmap;\n\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tpose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 77.80120045264638}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n/*\n * This constructor, PlannerWithCostmap::PlannerWithCostmap, initializes a PlannerWithCostmap object with a given name and Costmap2DROS pointer.\nIt calls the base class constructor with the planner name, costmap, and global frame ID.\nIt sets up a private ROS node handle, advertises a \"make_plan\" service, and subscribes to the \"goal\" topic to receive PoseStamped messages for planning purposes.\n */\n    cmap_ = cmap;\n    make_plan_service_ = private_nh_.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh_.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 70.77358668307076}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t", "CodeBleu_score": 3.975936983732389}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// Check if the world coordinates are within the bounds of the costmap's origin.\n\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() ||\n\t\twy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\tROS_ERROR(\"The world coordinates (%f, %f) are not within the bounds of the costmap's origin.\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates using the costmap's resolution and an offset.\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution() - convert_offset_;\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution() - convert_offset_;\n\n\t// Check if the map coordinates are within the costmap's size limits.\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_ERROR(\"The map coordinates (%f, %f) are not within the bounds of the costmap.\", mx, my);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.547944566624004}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\treturn true;\n}", "CodeBleu_score": 40.776261806020706}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\nreturn;\n}\n\nnav_msgs::Path msg;\nmsg.header.stamp = ros::Time::now();\nmsg.header.frame_id = frame_id_;\n\nfor (unsigned int i = 0; i < path.size(); ++i) {\nmsg.poses.push_back(path[i]);\n}\n\nplan_pub_.publish(msg);\n}", "CodeBleu_score": 70.70601401638565}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\n\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\nreturn;\n}\n\nnav_msgs::Path gui_path; // A visualization marker for the path\n\ngui_path.header.frame_id = frame_id_;\ngui_path.header.stamp = ros::Time::now();\n\nfor (unsigned int i = 0; i < path.size(); i++) {\ngui_path.poses.push_back(path[i]);\n}\n\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 81.83138057415414}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\nreturn;\n}\n\nnav_msgs::Path gui_path; // A path to visualize in Rviz\ngui_path.poses.resize(path.size());\n\nfor (unsigned int i = 0; i < path.size(); i++) {\ngui_path.poses[i] = path[i];\n}\n\ngui_path.header.frame_id = frame_id_;\ngui_path.header.stamp = ros::Time::now();\n\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.00405225995267}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 7.204876027809698}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In goal callback, wrapping goal in action message\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.header.frame_id = goal->header.frame_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal.goal.target_pose.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose.header.frame_id = goal->header.frame_id;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 67.69962195327753}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping goal in MoveBaseActionGoal and publishing\");\n\n\t//start executing recovery behaviors if we are in a planning state\n\tif(state_ == PLANNING) {\n\t\texecuteRecoveryBehaviors();\n\t}\n\n\t//if we have a goal and are in a planning state, clear the plan to start planning anew\n\tif(state_ == PLANNING) {\n\t\tplanner_plan_->clear();\n\t}\n\n\t//if we have a goal and are in a planning state, clear the plan to start planning anew\n\tif(state_ == CONTROLLING) {\n\t\tcontroller_plan_->clear();\n\t}\n\n\t//create a new action goal\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t//set the time stamp on the goal\n\taction_goal.goal.header.stamp = ros::Time::now();\n\n\t//set the goal pose\n\taction_goal.goal.target_pose = *goal;\n\n\t//publish the action goal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.9105922157299}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif(getSqDistance() > limited_distance_ * limited_distance_) {\n\t\tROS_INFO(\"Robot has moved %f m. Stopping speed limit.\", sqrt(getSqDistance()));\n\t\tremoveLimitThread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 48.967106916230875}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tgeometry_msgs::PoseStamped global_pose;\n\tglobal_costmap_->getRobotPose(global_pose);\n\tdouble x1 = global_pose.pose.position.x;\n\tdouble y1 = global_pose.pose.position.y;\n\n\tdouble x2 = speed_limit_pose_.pose.position.x;\n\tdouble y2 = speed_limit_pose_.pose.position.y;\n\n\tdouble sq_distance = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\n\tif (sq_distance > limited_distance_ * limited_distance_) {\n\t\tROS_INFO(\n\t\t\t\t\"The robot has moved a distance of %f, which is greater than the limited distance of %f\",\n\t\t\t\tsqrt(sq_distance), sqrt(limited_distance_ * limited_distance_));\n\t\tdistance_check_timer_.stop();\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t\tremove_limit_thread_ = NULL;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(\n\t\t\t\tboost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t}\n}", "CodeBleu_score": 52.07853347560317}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble dist = getSqDistance();\n\tif (dist > limited_distance_ * limited_distance_) {\n\t\tROS_INFO(\n\t\t\t\t\"Robot has moved far enough, stopping speed limit and removing speed limit thread.\");\n\t\tlimit_set_ = false;\n\t\tdistance_check_timer_.stop();\n\t\tremove_limit_thread_->join();\n\t\tdelete remove_limit_thread_;\n\t\tremove_limit_thread_ = NULL;\n\t}\n}", "CodeBleu_score": 49.28610868851146}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tPoseStamped start;\n\tPoseStamped goal;\n\tvector<PoseStamped> path;\n\tbool success = false;\n\n\tif (getRobotPose(start, goal)) {\n\t\tsuccess = makePlan(start, goal, path);\n\t}\n}", "CodeBleu_score": 51.681634816351284}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tPoseStamped goal_pose;\n\tgoal_pose = *goal;\n\tgoal_pose.header.frame_id = \"map\";\n\tvector<PoseStamped> path;\n\tbool success = makePlan(goal_pose, path);\n}", "CodeBleu_score": 55.97759174491751}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tPoseStamped start;\n\tstart.header.frame_id = \"map\";\n\tstart.header.stamp = ros::Time::now();\n\tstart.pose.position.x = cmap_->getRobotPose().x;\n\tstart.pose.position.y = cmap_->getRobotPose().y;\n\tstart.pose.position.z = 0.0;\n\tstart.pose.orientation.x = 0.0;\n\tstart.pose.orientation.y = 0.0;\n\tstart.pose.orientation.z = 0.0;\n\tstart.pose.orientation.w = 1.0;\n\tmakePlan(start, *goal, path_);\n}", "CodeBleu_score": 44.54761615313816}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_msg;\n\tparam_set_msg.request.param_id = param_set.param_id;\n\tparam_set_msg.request.value = param_set.value;\n\tthis->param_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 61.46200240249545}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_msg;\n\tparam_set_msg.request.param_id = param_set.param_id;\n\tparam_set_msg.request.value = param_set.value;\n\tparam_set_msg.request.target_component = 0;\n\tparam_set_msg.request.target_system = 0;\n\tthis->param_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 56.799900721814936}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.target_system = 1;\n\tparam_set_srv.request.target_component = 1;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 57.70045230184175}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tis->swarm_control_!= NULL && this->swarm_num_!= 0) {\n\t\t// \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n\t\tthis->swarm_control_->updateAllUAVCommand(uav_cmd);\n\t\t// \u53d1\u5e03\u8bdd\u9898\n\t\tthis->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n\t}\n}", "CodeBleu_score": 26.47434891842285}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tis->swarm_control_!= NULL && this->swarm_num_!= 0) {\n\t\t// \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n\t\tthis->swarm_control_->updateAllUAVCommand(uav_cmd);\n\t\t// \u53d1\u5e03\u8bdd\u9898\n\t\tthis->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n\t}\n}", "CodeBleu_score": 26.47434891842285}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tis->swarm_control_!= NULL && this->swarm_num_!= 0) {\n\t\t// \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n\t\tthis->swarm_control_->updateAllUAVCommand(uav_cmd);\n\t\t// \u53d1\u5e03\u8bdd\u9898\n\t\tthis->swarm_control_->allUAVCommandPub(this->swarm_control_->getMultiUAVCommand());\n\t}\n}", "CodeBleu_score": 26.47434891842285}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (this->uav_basic_ == NULL) {\n\t\treturn;\n\t}\n\tif (mode_selection.use_mode == ModeSelection::Mode::REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == ModeSelection::Mode::EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else {\n\t\tif (mode_selection.use_mode == ModeSelection::Mode::CREATEMODE) {\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t} else if (mode_selection.use_mode == ModeSelection::Mode::DELETEMODE) {\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t}\n\t}\n}", "CodeBleu_score": 62.12974188036091}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == ModeSelection::USE_MODE::REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == ModeSelection::USE_MODE::EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else {\n\t\tif (mode_selection.use_mode == ModeSelection::USE_MODE::CREATEMODE) {\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t} else if (mode_selection.use_mode == ModeSelection::USE_MODE::DELETMODE) {\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t}\n\t}\n}", "CodeBleu_score": 59.63290797222037}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// \u5207\u6362\u6a21\u5f0f\n\tif (mode_selection.use_mode) {\n\t\tif (mode_selection.mode == ModeSelection::Mode::REBOOTNX) {\n\t\t\t// \u91cd\u542fNX\n\t\t\tsystem(\"sudo reboot\");\n\t\t} else if (mode_selection.mode == ModeSelection::Mode::EXITNX) {\n\t\t\t// \u9000\u51faNX\n\t\t\tsystem(\"sudo poweroff\");\n\t\t} else {\n\t\t\t// \u5207\u6362\u6a21\u5f0f\n\t\t\tcreateMode(mode_selection.mode);\n\t\t}\n\t}\n}", "CodeBleu_score": 54.42279851888274}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\trone_id;\n\tif (msg->drone_id == drone_id_) {\n\t\tdrone_id = drone_id_;\n\t} else {\n\t\tdrone_id = msg->drone_id;\n\t}\n\tstd::vector<Bspline> bsplines;\n\tfor (int i = 0; i < msg->bsplines.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.knots = msg->bsplines[i].knots;\n\t\tbspline.pos_points = msg->bsplines[i].pos_points;\n\t\tbspline.yaw_points = msg->bsplines[i].yaw_points;\n\t\tbsplines.push_back(bspline);\n\t}\n\tcommunication->sendBspline(bsplines);\n}", "CodeBleu_score": 34.84624448587686}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); ++i) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 78.99116715478624}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\nif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\nthis->multi_uav_state_.uav_state_all[i] = uav_state;\nbreak;\n}\n}\n}", "CodeBleu_score": 91.24852636415021}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.uav_state_all.size(); ++i) {\n\t\tif (multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.84571693861371}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tint end_idx = q.cols() - order_;\n\tdouble a = 3, b = -3, a2 = 1 / a / a, b2 = 1 / b / b;\n\tfor (int i = order_; i < end_idx; i++) {\n\t\tdouble time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\t\tdouble t_now = ros::Time::now().toSec();\n\t\tEigen::Vector3d ref_point = cps_.points.col(i);\n\t\tEigen::Vector3d vel_vec = cps_.points.col(i + 1) - cps_.points.col(i);\n\t\tvel_vec.normalize();\n\t\tEigen::Vector3d pos_err = ref_point - q.col(i);\n\t\tEigen::Vector3d vel_err = vel_vec - cps_.direction[i];\n\t\tEigen::Vector3d grad_pos_err = pos_err;\n\t\tEigen::Vector3d grad_vel_err = vel_err;\n\t\tcost += pow(pos_err.dot(pos_err), 2) + pow(vel_err.dot(vel_err), 2);\n\t\tgradient.col(i) += 2 * pos_err.dot(vel_err) * vel_err + 2 * pos_err.dot(pos_err) * pos_err;\n\t}\n}", "CodeBleu_score": 42.72616915336381}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tdouble jerk = 0.0;\ndouble dur = getTimeSum();\nEigen::VectorXd p_l = evaluateDeBoorT(0.0), p_n;\nfor (double t = 0.0; t <= dur + 1e-4; t += 0.001) {\np_n = evaluateDeBoorT(t);\njerk += (p_n - p_l).squaredNorm();\np_l = p_n;\n}\nreturn jerk;\n}", "CodeBleu_score": 28.552326504603087}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0.0;\n\tdouble dur = getTimeSum();\n\tEigen::VectorXd p_l = evaluateDeBoorT(0.0), p_n;\n\tfor (double t = 0.0; t <= dur + 1e-4; t += 0.01) {\n\t\tp_n = evaluateDeBoorT(t);\n\t\tjerk += (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm()\n\t\t\t\t* (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm();\n\t\tp_l = p_n;\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 30.316496050204826}, {"code": "double UniformBspline::getJerk(){\n\tdouble jerk = 0.0;\ndouble dur = getTimeSum();\nEigen::VectorXd p_l = evaluateDeBoorT(0.0), p_n;\nfor (double t = 0.0; t <= dur + 1e-4; t += 0.01) {\np_n = evaluateDeBoorT(t);\njerk += (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm() * (p_n - p_l).norm();\np_l = p_n;\n}\nreturn jerk;\n}", "CodeBleu_score": 30.356183702647144}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.67477930149333}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.67477930149333}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t/    ROS_INFO_STREAM(\\\"depth2Pos: u = \\\" << u << \\\", v = \\\" << v << \\\", depth = \\\" << depth);\n//    ROS_INFO_STREAM(\\\"cx_ = \\\" << cx_ << \\\", cy_ = \\\" << cy_ << \\\", fx_ = \\\" << fx_ << \\\", fy_ = \\\" << fy_);\n//    ROS_INFO_STREAM(\\\"u = \\\" << u << \\\", v = \\\" << v << \\\", depth = \\\" << depth);\n    Eigen::Vector4d pos;\n    pos << (u - cx_)/fx_, (v - cy_)/fy_, depth, 1.0;\n    return pos;\n}", "CodeBleu_score": 37.51173520013245}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id.substr(7));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::invalid_argument& e) {\n\t\tROS_ERROR(\"Could not extract drone ID from odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 54.09667651095778}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\tstd::string child_frame_id = odom.child_frame_id;\n\tint drone_id;\n\ttry {\n\t\tdrone_id = std::stoi(child_frame_id.substr(child_frame_id.size() - 1));\n\t} catch (std::invalid_argument& e) {\n\t\tROS_WARN(\"invalid argument in child_frame_id: %s\", child_frame_id.c_str());\n\t\treturn;\n\t}\n\trcvDroneOdomCallbackBase(odom, drone_id);\n}", "CodeBleu_score": 44.94631066294479}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id.substr(5));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::invalid_argument& e) {\n\t\tROS_WARN(\"Could not extract drone ID from odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 54.1560951663865}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// get the true pose of the drone in the camera frame\n\tEigen::Vector4d true_pose_cam = depth2Pos(true_pixel(0), true_pixel(1), depth_img_.at<float>(true_pixel(1), true_pixel(0)));\n\t// check if the drone is found\n\tif (findDrone(drone_id, true_pose_cam)) {\n\t\t// compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = getPoseError(drone_id, true_pose_cam);\n\t\t// update the debug result\n\t\tdebug_result_.pose_error_cam_world_x[drone_id] = pose_error(0);\n\t\tdebug_result_.pose_error_cam_world_y[drone_id] = pose_error(1);\n\t\tdebug_result_.pose_error_cam_world_z[drone_id] = pose_error(2);\n\t\t// publish the pose error\n\t\tpose_error_pub_.publish(pose_error);\n\t} else {\n\t\t// update the debug result to indicate failure\n\t\tdebug_result_.pose_error_cam_world_x[drone_id] = 1000000000.0;\n\t\tdebug_result_.pose_error_cam_world_y[drone_id] = 1000000000.0;\n\t\tdebug_result_.pose_error_cam_world_z[drone_id] = 1000000000.0;\n\t\t// publish the pose error\n\t\tpose_error_pub_.publish(pose_error);\n\t}\n}", "CodeBleu_score": 39.88326415106416}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\npath.push_back(current);\nwhile (current->cameFrom!= nullptr) {\ncurrent = current->cameFrom;\npath.push_back(current);\n}\nreturn path;\n}", "CodeBleu_score": 84.53530289104613}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\npath.push_back(current);\nwhile (current->cameFrom!= nullptr) {\ncurrent = current->cameFrom;\npath.push_back(current);\n}\nreturn path;\n}", "CodeBleu_score": 84.53530289104613}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\npath.push_back(current);\nwhile (current->cameFrom!= nullptr) {\ncurrent = current->cameFrom;\npath.push_back(current);\n}\nreturn path;\n}", "CodeBleu_score": 84.53530289104613}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start point to grid indices\nstart_idx = Vector3i(round(start_pt(0) / resolution_ + 0.5), round(start_pt(1) / resolution_ + 0.5), round(start_pt(2) / resolution_ + 0.5));\n\n// Convert end point to grid indices\nend_idx = Vector3i(round(end_pt(0) / resolution_ + 0.5), round(end_pt(1) / resolution_ + 0.5), round(end_pt(2) / resolution_ + 0.5));\n\n// Adjust start point if it is inside an obstacle\nif (!grid_map_->isOccupied(start_idx)) {\n\n// Move the start point away from the end point\nwhile (grid_map_->isOccupied(start_idx)) {\nstart_idx(0) += (end_idx(0) - start_idx(0)) / 2;\nstart_idx(1) += (end_idx(1) - start_idx(1)) / 2;\nstart_idx(2) += (end_idx(2) - start_idx(2)) / 2;\n}\n\n// If the start point is still inside an obstacle, the conversion or adjustment failed\nif (grid_map_->isOccupied(start_idx)) {\nreturn false;\n}\n}\n\n// Adjust end point if it is inside an obstacle\nif (!grid_map_->isOccupied(end_idx)) {\n\n// Move the end point away from the start point\nwhile (grid_map_->isOccupied(end_idx)) {\nend_idx(0) += (start_idx(0) - end_idx(0)) / 2;\nend_idx(1) += (start_idx(1) - end_idx(1)) / 2;\nend_idx(2) += (start_idx(2) - end_idx(2)) / 2;\n}\n\n// If the end point is still inside an obstacle, the conversion or adjustment failed\nif (grid_map_->isOccupied(end_idx)) {\nreturn false;\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 35.781036088150756}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tbool success = true;\n\tstart_idx = start_pt.cast<int>();\n\tend_idx = end_pt.cast<int>();\n\tif (!grid_map_->isInside(start_idx)) {\n\t\tsuccess = false;\n\t}\n\tif (!grid_map_->isInside(end_idx)) {\n\t\tsuccess = false;\n\t}\n\tif (!success) {\n\t\t//cout << \"Start or end point is inside an obstacle.\" << endl;\n\t\t//cout << \"Adjusting start and end points to be outside obstacles.\" << endl;\n\t\tVector3d adjusted_start_pt = start_pt;\n\t\tVector3d adjusted_end_pt = end_pt;\n\t\twhile (!grid_map_->isInside(adjusted_start_pt.cast<int>())) {\n\t\t\tadjusted_start_pt += 0.5 * (adjusted_end_pt - adjusted_start_pt);\n\t\t}\n\t\twhile (!grid_map_->isInside(adjusted_end_pt.cast<int>())) {\n\t\t\tadjusted_end_pt += 0.5 * (adjusted_end_pt - adjusted_start_pt);\n\t\t}\n\t\tstart_idx = adjusted_start_pt.cast<int>();\n\t\tend_idx = adjusted_end_pt.cast<int>();\n\t}\n\treturn success;\n}", "CodeBleu_score": 33.0798920350592}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tool start_success = ConvertToIndex(start_pt, start_idx);\nif (!start_success) {\nstart_idx = Vector3i(0, 0, 0);\nstart_pt = grid_map_->indexToWorld(start_idx, grid_map_->getResolution());\n}\nbool end_success = ConvertToIndex(end_pt, end_idx);\nif (!end_success) {\nend_idx = Vector3i(0, 0, 0);\nend_pt = grid_map_->indexToWorld(end_idx, grid_map_->getResolution());\n}\nif (start_success && end_success) {\nwhile (grid_map_->isOccupied(start_idx) || grid_map_->isOccupied(end_idx)) {\nif (start_idx == end_idx) {\nreturn false;\n}\nif (grid_map_->isOccupied(start_idx)) {\nstart_pt = grid_map_->indexToWorld(start_idx, grid_map_->getResolution());\nstart_pt.x() += 0.01;\nstart_success = ConvertToIndex(start_pt, start_idx);\n}\nif (grid_map_->isOccupied(end_idx)) {\nend_pt = grid_map_->indexToWorld(end_idx, grid_map_->getResolution());\nend_pt.x() -= 0.01;\nend_success = ConvertToIndex(end_pt, end_idx);\n}\n}\n}\nreturn start_success && end_success;\n}", "CodeBleu_score": 40.60053858417639}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\n  min_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n  max_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\n  // set the buffer to zero\n  for (int i = min_id(0); i <= max_id(0); ++i)\n  {\n    for (int j = min_id(1); j <= max_id(1); ++j)\n    {\n      for (int k = min_id(2); k <= max_id(2); ++k)\n      {\n        md_.occupancy_buffer_inflate_[k * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(0) + j * mp_.map_voxel_num_(0) + i] = 0;\n      }\n    }\n  }\n\n  // reset the raycast number\n  md_.raycast_num_ = 0;\n\n  md_.occ_need_update_ = true;\n  md_.local_updated_ = true;\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n}", "CodeBleu_score": 52.23653363145346}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\n  // \u5750\u6807\u8f6c\u6362\n  min_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n  max_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\n  // \u5750\u6807\u8303\u56f4\u9650\u5236\n  if (min_id(0) < 0)\n    min_id(0) = 0;\n  if (min_id(1) < 0)\n    min_id(1) = 0;\n  if (min_id(2) < 0)\n    min_id(2) = 0;\n  if (max_id(0) >= mp_.map_voxel_num_(0))\n    max_id(0) = mp_.map_voxel_num_(0) - 1;\n  if (max_id(1) >= mp_.map_voxel_num_(1))\n    max_id(1) = mp_.map_voxel_num_(1) - 1;\n  if (max_id(2) >= mp_.map_voxel_num_(2))\n    max_id(2) = mp_.map_voxel_num_(2) - 1;\n\n  // \u8fed\u4ee3\u91cd\u7f6e\n  for (int i = min_id(0); i <= max_id(0); ++i)\n    for (int j = min_id(1); j <= max_id(1); ++j)\n      for (int k = min_id(2); k <= max_id(2); ++k)\n        md_.occupancy_buffer_inflate_[i * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) + j * mp_.map_voxel_num_(2) + k] = 0;\n\n  md_.occ_need_update_ = true;\n}", "CodeBleu_score": 47.68235501986016}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// \u8ba1\u7b97\u91cd\u7f6e\u8303\u56f4\u5185\u7684\u5730\u56fe\u7d22\u5f15\n\tEigen::Vector3i min_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n\tEigen::Vector3i max_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\n\t// \u91cd\u7f6e\u81a8\u80c0\u56fe\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (min_id(i) < 0) {\n\t\t\tmin_id(i) = 0;\n\t\t}\n\t\tif (max_id(i) > mp_.map_voxel_num_(i) - 1) {\n\t\t\tmax_id(i) = mp_.map_voxel_num_(i) - 1;\n\t\t}\n\t}\n\n\t// \u91cd\u7f6e\u81a8\u80c0\u56fe\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = min_id(i); j <= max_id(i); ++j) {\n\t\t\tmd_.occupancy_buffer_inflate_[j * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) + i] = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.93349633545192}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = (md_.local_bound_max_(0) - md_.local_bound_min_(0)) * mp_.resolution_;\n\tdouble max_y = (md_.local_bound_max_(1) - md_.local_bound_min_(1)) * mp_.resolution_;\n\tdouble max_z = (md_.local_bound_max_(2) - md_.local_bound_min_(2)) * mp_.resolution_;\n\n\tdouble min_x = (md_.local_bound_min_(0) - md_.local_bound_min_(0)) * mp_.resolution_;\n\tdouble min_y = (md_.local_bound_min_(1) - md_.local_bound_min_(1)) * mp_.resolution_;\n\tdouble min_z = (md_.local_bound_min_(2) - md_.local_bound_min_(2)) * mp_.resolution_;\n\n\tif (diff(0) > max_x) {\n\t\tdiff(0) = max_x;\n\t} else if (diff(0) < min_x) {\n\t\tdiff(0) = min_x;\n\t}\n\n\tif (diff(1) > max_y) {\n\t\tdiff(1) = max_y;\n\t} else if (diff(1) < min_y) {\n\t\tdiff(1) = min_y;\n\t}\n\n\tif (diff(2) > max_z) {\n\t\tdiff(2) = max_z;\n\t} else if (diff(2) < min_z) {\n\t\tdiff(2) = min_z;\n\t}\n\n\treturn pt - diff;\n}", "CodeBleu_score": 32.79776503045523}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// \u66f4\u65b0\u6700\u540e\u4e00\u6b21\u66f4\u65b0\u65f6\u95f4\n\tmd_.last_update_time_ = ros::Time::now();\n\t// \u5224\u65ad\u662f\u5426\u9700\u8981\u66f4\u65b0\n\tif (md_.need_update_) {\n\t\t// \u66f4\u65b0\u5730\u56fe\n\t\tupdateMap();\n\t}\n}", "CodeBleu_score": 19.892900476153674}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat fmeasure = 0.f;\nunsigned n = image_fns.size();\nfor (unsigned i = 0; i < n; ++i) {\nMat3b img = imread(image_fns[i]);\nMat1b gt, dt;\n_load_ellipse_GT(gt_fns[i], gt, gt_angle_radians);\n_load_ellipse_DT(dt_fns[i], dt, gt_angle_radians);\nfmeasure += _ellipse_evaluate_one(gt, dt, img);\n}\nfmeasure /= n;\nreturn fmeasure;\n}", "CodeBleu_score": 57.711235505263424}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_avg(0.f);\n\tfor (unsigned i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img;\n\t\t_load_image(image_fns[i], img);\n\n\t\tvector<Ellipse> ell_gt;\n\t\t_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\n\t\tvector<Ellipse> ell_dt;\n\t\t_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\t\tfmeasure_avg += fmeasure;\n\t}\n\treturn fmeasure_avg / float(image_fns.size());\n}", "CodeBleu_score": 64.67168670557024}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat avg_fmeasure = 0.f;\n\nfor (unsigned i = 0; i < image_fns.size(); ++i) {\nMat3b img = imread(image_fns[i], IMREAD_COLOR);\n\nvector<Ellipse> ell_gt;\n_load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n\nvector<Ellipse> ell_dt;\n_load_ellipse_DT(dt_fns[i], ell_dt, gt_angle_radians);\n\nfloat fmeasure = _ellipse_evaluate_one(ell_gt, ell_dt, img);\n\navg_fmeasure += fmeasure;\n}\n\navg_fmeasure /= image_fns.size();\n\nreturn avg_fmeasure;\n}", "CodeBleu_score": 66.56141827608091}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a, b, c, d, e, f;\n\tfloat angle;\n\n\t/* check parameters */\n\tif (foci == NULL) fprintf(stderr, \"ellipse_normal_angle: invalid input ellipse.\");\n\n\t/* compute angles */\n\ta = _angle_diff(atan2(y - foci[1], x - foci[0]), atan2(y - foci[3], x - foci[2]));\n\tb = _angle_diff(atan2(y - foci[1], x - foci[0]), atan2(y - foci[5], x - foci[4]));\n\tc = _angle_diff(atan2(y - foci[3], x - foci[2]), atan2(y - foci[5], x - foci[4]));\n\td = _angle_diff(atan2(y - foci[1], x - foci[0]), atan2(y - foci[7], x - foci[6]));\n\te = _angle_diff(atan2(y - foci[3], x - foci[2]), atan2(y - foci[7], x - foci[6]));\n\tf = _angle_diff(atan2(y - foci[5], x - foci[4]), atan2(y - foci[7], x - foci[6]));\n\n\t/* compute angle */\n\tangle = a + b + c + d + e + f;\n\n\treturn angle;\n}", "CodeBleu_score": 47.28679259969339}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle;\n\tif (foci == NULL) fprintf(stderr, \"ellipse_normal_angle: invalid input ellipse.\n\");\n\tfloat foci_x[2], foci_y[2];\n\tfoci_x[0] = foci[0];\n\tfoci_x[1] = foci[2];\n\tfoci_y[0] = foci[1];\n\tfoci_y[1] = foci[3];\n\tangle = atan2(y - foci_y[0], x - foci_x[0]) - atan2(y - foci_y[1], x - foci_x[1]);\n\twhile (angle <= -M_PI) angle += M_2__PI;\n\twhile (angle > M_PI) angle -= M_2__PI;\n\treturn angle;\n}", "CodeBleu_score": 55.78956985675501}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a, b, c, d, e, f;\n\tfloat angle;\n\n\t/* check parameters */\n\tif (foci == NULL) {\n\t\tfprintf(stderr, \"ellipse_normal_angle: invalid input ellipse.\n\");\n\t\treturn 0.0;\n\t}\n\n\t/* compute angles */\n\ta = atan2(y - foci[1], x - foci[0]);\n\tb = atan2(y - foci[3], x - foci[2]);\n\n\t/* compute angle */\n\tc = a - b;\n\td = M_PI - fabs(c);\n\te = fabs(c);\n\tf = M_PI - d;\n\tif (f < e) {\n\t\tangle = c;\n\t} else {\n\t\tangle = d;\n\t}\n\n\t/* adjust angle to [-\u03c0, \u03c0] */\n\tif (angle > M_PI) {\n\t\tangle -= M_2__PI;\n\t} else if (angle < -M_PI) {\n\t\tangle += M_2__PI;\n\t}\n\n\treturn angle;\n}", "CodeBleu_score": 59.78003614295224}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\nint integral_u(0), integral_d(0);\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nx_min = MIN(x_min, val.x);\nx_max = MAX(x_max, val.x);\ny_min = MIN(y_min, val.y);\ny_max = MAX(y_max, val.y);\n}\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nintegral_u += (val.y - y_min);\nintegral_d += (y_max - val.y);\n}\nif (integral_u > integral_d)\nreturn false;\nelse\nreturn true;\n}", "CodeBleu_score": 91.73184093893155}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u > integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 91.985043025344}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\nint integral_u(0), integral_d(0);\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nx_min = MIN(x_min, val.x);\nx_max = MAX(x_max, val.x);\ny_min = MIN(y_min, val.y);\ny_max = MAX(y_max, val.y);\n}\nfor (int i = start; i <= end; i++) {\nPoint& val = vp1[i];\nintegral_u += (val.y - y_min);\nintegral_d += (y_max - val.y);\n}\nif (integral_u > integral_d)\nreturn false;\nelse\nreturn true;\n}", "CodeBleu_score": 91.73184093893155}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tnum_lost = 0;\n\tnum_regain = 0;\n\tis_detected = false;\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tis_detected = true;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t}\n\t}\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t}\n\tif (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n}", "CodeBleu_score": 48.003564549686516}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t//    ROS_INFO(\"ellipse_det_cb\");\n    num_lost = 0;\n    num_regain = 0;\n    for (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].name == \"T\") {\n            num_regain++;\n            ellipse_det = msg->detections[i];\n        } else {\n            num_lost++;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    } else if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n}", "CodeBleu_score": 52.10681914481755}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (Occupy_map_ptr->getCost(cur_pos) <= safe_distance) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.380797655752176}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3i idx = posToIndex(cur_pos);\n\tif (idx[0] < 0 || idx[0] >= Occupy_map_ptr->get_map_size()[0] || idx[1] < 0 || idx[1] >= Occupy_map_ptr->get_map_size()[1] || idx[2] < 0 || idx[2] >= Occupy_map_ptr->get_map_size()[2]) {\n\t\treturn false;\n\t}\n\treturn Occupy_map_ptr->is_free(idx);\n}", "CodeBleu_score": 32.963995688674316}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// \u8ba1\u7b97\u5b89\u5168\u8ddd\u79bb\n\tdouble safe_distance_ = safe_distance * safe_distance;\n\n\t// \u8ba1\u7b97\u5f53\u524d\u70b9\u5230\u969c\u788d\u7269\u7684\u8ddd\u79bb\n\tdouble cur_pos_to_obstacle_distance = Occupy_map_ptr->getCost(cur_pos);\n\t// \u5982\u679c\u5f53\u524d\u70b9\u5230\u969c\u788d\u7269\u7684\u8ddd\u79bb\u5c0f\u4e8e\u5b89\u5168\u8ddd\u79bb\uff0c\u5219\u8fd4\u56defalse\n\tif (cur_pos_to_obstacle_distance < safe_distance_)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 38.97644894854937}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t//  cout << GREEN << \\\"Astar search: [ retrieve path ]\\\"  << TAIL <<endl;\n  NodePtr cur_node = end_node;\n  path_nodes_.push_back(cur_node);\n\n  while (cur_node->parent!= NULL) {\n    cur_node = cur_node->parent;\n    path_nodes_.push_back(cur_node);\n  }\n\n  // \u53cd\u8f6c\u8def\u5f84\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 90.54260405567308}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr cur_node = end_node;\n\tpath_nodes_.clear();\n\n\twhile (cur_node!= NULL) {\n\t\tpath_nodes_.push_back(cur_node);\n\t\tcur_node = cur_node->parent;\n\t}\n\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.21497239049587}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t//  cout << \"retrievePath: start\" << endl;\n  NodePtr cur_node = end_node;\n  path_nodes_.clear();\n  while (cur_node!= NULL) {\n    path_nodes_.push_back(cur_node);\n    cur_node = cur_node->parent;\n  }\n  reverse(path_nodes_.begin(), path_nodes_.end());\n//  cout << \"retrievePath: end\" << endl;\n}", "CodeBleu_score": 69.71763127481773}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n//    ROS_INFO(\"nei_odom_cb\");\n\n    // \u65e0\u4eba\u8f66\u7f16\u53f7\n    int ugv_id = id;\n\n    // \u65e0\u4eba\u8f66\u72b6\u6001\n    state_nei[ugv_id] = odom->pose.pose;\n    get_nei_state[ugv_id] = true;\n}", "CodeBleu_score": 19.92768305386427}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n//    cout << \"nei_odom_cb\" << endl;\n    // \u65e0\u4eba\u8f66\u7f16\u53f7 1\u53f7\u65e0\u4eba\u8f66\u5219\u4e3a1\n    // \u65e0\u4eba\u8f66\u72b6\u6001\n    this->all_ugv_states_[id-1].ugv_state = odom->pose.pose.position.z;\n    // \u65e0\u4eba\u8f66\u4f4d\u7f6e\n    this->all_ugv_states_[id-1].ugv_x = odom->pose.pose.position.x;\n    this->all_ugv_states_[id-1].ugv_y = odom->pose.pose.position.y;\n    // \u65e0\u4eba\u8f66\u59ff\u6001\n    this->all_ugv_states_[id-1].ugv_yaw = tf::getYaw(odom->pose.pose.orientation);\n    // \u65e0\u4eba\u8f66\u901f\u5ea6\n    this->all_ugv_states_[id-1].ugv_vx = odom->twist.twist.linear.x;\n    this->all_ugv_states_[id-1].ugv_vy = odom->twist.twist.linear.y;\n    this->all_ugv_states_[id-1].ugv_vth = odom->twist.twist.angular.z;\n\n    // \u65e0\u4eba\u8f66\u4f4d\u7f6e\n    this->state_nei[id-1] << this->all_ugv_states_[id-1].ugv_x, this->all_ugv_states_[id-1].ugv_y, this->all_ugv_states_[id-1].ugv_yaw;\n    // \u65e0\u4eba\u8f66\u72b6\u6001\n    this->get_nei_state[id-1] = true;\n\n}", "CodeBleu_score": 30.135898672188333}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tif (sensor_ready) {\n\t\tcounter_update++;\n\t}\n\n\tsensor_ready = true;\n\n\tif (counter_update >= 5) {\n\t\tcounter_update = 0;\n\n\t\t// \u66f4\u65b0\u5730\u56fe\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t}\n}", "CodeBleu_score": 52.92304318015502}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 5.371612362555575}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready)\n\t\treturn;\n\n\tsensor_ready = true;\n\tsensor_update_counter++;\n\n\tif (sensor_update_counter % 5 == 0) {\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t\tsensor_update_counter = 0;\n\t}\n}", "CodeBleu_score": 50.290900775942035}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\t// \u8f6c\u6362\u70b9\u4e91\n\t\tpcl::fromROSMsg(*global_point, *global_point_cloud_map);\n\t\t// \u81a8\u80c0\n\t\tpcl::transformPointCloud(*global_point_cloud_map, *cloud_inflate_vis_, transform_map_to_ugv);\n\t\t// \u5b58\u50a8\n\t\tpcl::copyPointCloud(*cloud_inflate_vis_, *global_point_cloud_map);\n\t}\n}", "CodeBleu_score": 54.2905827809458}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a sensor_msgs::PointCloud2\n\tsensor_msgs::PointCloud2 laser_point;\n\tsensor_msgs::convertLaserScanToPointCloud(\"laser\", *local_point, 100, laser_point, tf_listener_);\n\t// \u7531sensor_msgs::PointCloud2 \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\tpcl::fromROSMsg(laser_point, *input_point_cloud);\n\thas_global_point = true;\n\n\tif (sim_mode) {\n\t\tif (queue_size <= 0) {\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *input_point_cloud;\n\t\t} else {\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor (iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 56.980128732691526}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a PointCloud2\n\tsensor_msgs::PointCloud2 laser_point;\n\tsensor_msgs::convertLaserScanToPointCloud(*local_point, \"base_laser_link\", odom, laser_point);\n\n\t// \u7531sensor_msgs::PointCloud2 \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\tpcl::fromROSMsg(laser_point, *input_point_cloud);\n\n\thas_global_point = true;\n\n\tif (sim_mode) {\n\t\tif (queue_size <= 0) // without slide windows\n\t\t{\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *input_point_cloud;\n\t\t} else // with slide windows\n\t\t{\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor (iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 56.8270883000309}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a PointCloud2\n\tsensor_msgs::PointCloud2 laser_point;\n\tsensor_msgs::convertLaserScanToPointCloud(*local_point, \"base_link\", 1.0, laser_point);\n\n\t// \u7531sensor_msgs::PointCloud2 \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\tpcl::fromROSMsg(laser_point, *input_point_cloud);\n\n\tif (sim_mode) {\n\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t*global_point_cloud_map += *input_point_cloud;\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n\n\t// downsample\n\t*pcl_ptr = *global_point_cloud_map;\n\tvg.setInputCloud(pcl_ptr);\n\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\tvg.filter(*global_point_cloud_map);\n\tinflate_point_cloud();\n}", "CodeBleu_score": 58.79277940616895}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// \u53d1\u5e03\u70b9\u4e91\u6d88\u606f\n\t// \u8f6c\u5316\u4e3aROS\u6d88\u606f\n\tpcl::toROSMsg(*global_point_cloud_map, global_pcl_msg_);\n\tglobal_pcl_msg_.header.frame_id = \"world\";\n\tglobal_pcl_msg_.header.stamp = ros::Time::now();\n\tglobal_pcl_pub_.publish(global_pcl_msg_);\n\n\t// \u8f6c\u5316\u4e3aROS\u6d88\u606f\n\tpcl::toROSMsg(*cloud_inflate_vis_, inflate_pcl_msg_);\n\tinflate_pcl_msg_.header.frame_id = \"world\";\n\tinflate_pcl_msg_.header.stamp = ros::Time::now();\n\tinflate_pcl_pub_.publish(inflate_pcl_msg_);\n}", "CodeBleu_score": 53.782931179558226}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tif (!has_global_point) {\n\t\treturn;\n\t}\n\t// \u8f6c\u5316\u4e3aPCL\u7684\u683c\u5f0f\u8fdb\u884c\u5904\u7406\n\tpcl::PointCloud<pcl::PointXYZ> latest_global_cloud_ = *global_point_cloud_map;\n\tif ((int)latest_global_cloud_.points.size() == 0) {\n\t\treturn;\n\t}\n\n\t// \u8f6c\u5316\u4e3aROS\u7684\u683c\u5f0f\u8fdb\u884c\u5904\u7406\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr latest_global_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(latest_global_cloud_, *latest_global_cloud);\n\n\t// \u53d1\u5e03\u5168\u5c40\u70b9\u4e91\n\tpcl_conversions::fromPCL(*latest_global_cloud, global_pcl_msg);\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// \u53d1\u5e03\u81a8\u80c0\u540e\u7684\u70b9\u4e91\n\tpcl_conversions::fromPCL(*cloud_inflate_vis_, inflate_pcl_msg);\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 51.05891065372852}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5168\u5c40\u70b9\u4e91\u4e00\u822c\u8f83\u5927\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n\tif (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n\t\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t}\n}", "CodeBleu_score": 78.7040738011076}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n\tif (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n\t\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t}\n}", "CodeBleu_score": 78.7040738011076}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u66f4\u65b0\u591a\u6b21\n\tif (Astar_ptr->Occupy_map_ptr->get_lpcl) {\n\t\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t}\n}", "CodeBleu_score": 78.96436315615705}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tos::Time now = ros::Time::now();\n\tros::Duration dt = now - last_time_;\n\tlast_time_ = now;\n\n\t// Calculate target foot positions based on desired pose\n\tbody_controller_.update(req_pose_, dt);\n\tbody_controller_.getFootPositions(target_foot_positions_);\n\n\t// Compute velocity commands for the legs and perform inverse kinematics to determine target joint positions\n\tleg_controller_.update(target_foot_positions_, dt);\n\tleg_controller_.getJointPositions(target_joint_positions_);\n\n\t// Publish foot contact information and joint positions\n\tif (publish_foot_contacts_) {\n\t\tpublishFootContacts();\n\t}\n\tif (publish_joint_states_) {\n\t\tpublishJointStates();\n\t}\n\tif (publish_joint_control_) {\n\t\tpublishJointCommands();\n\t}\n}", "CodeBleu_score": 49.24778903129678}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tos::Time now = ros::Time::now();\n\tros::Duration elapsed = now - last_loop_time_;\n\tlast_loop_time_ = now;\n\n\t// Compute target foot positions based on desired pose\n\tbase_.computeTargetFootPositions(req_pose_, target_foot_positions_);\n\n\t// Compute velocity commands for the legs\n\tleg_controller_.computeLegCommands(target_foot_positions_, leg_commands_);\n\n\t// Perform inverse kinematics to determine target joint positions\n\tkinematics_.computeJointPositions(leg_commands_, target_joint_positions_);\n\n\t// Publish foot contact information and joint positions\n\tif(publish_foot_contacts_) {\n\t\tpublishFootContacts();\n\t}\n\tif(publish_joint_states_) {\n\t\tpublishJointStates();\n\t}\n\tif(publish_joint_control_) {\n\t\tpublishJointCommands();\n\t}\n}", "CodeBleu_score": 45.10017264812872}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped foot_contacts_msg;\n\t\tfoot_contacts_msg.header.stamp = ros::Time::now();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfoot_contacts_msg.contacts.push_back(foot_contacts[i]);\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(foot_contacts_msg);\n\t}\n}", "CodeBleu_score": 54.09757332376527}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped foot_contacts_msg;\n\t\tfoot_contacts_msg.header.stamp = ros::Time::now();\n\t\tfoot_contacts_msg.header.frame_id = \"base_footprint\";\n\n\t\tfoot_contacts_msg.contacts.resize(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfoot_contacts_msg.contacts[i].contact = foot_contacts[i];\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(foot_contacts_msg);\n\t}\n}", "CodeBleu_score": 61.80042456749838}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped foot_contacts_msg;\n\t\tfoot_contacts_msg.header.stamp = ros::Time::now();\n\t\tfoot_contacts_msg.header.frame_id = \"base_link\";\n\t\tfoot_contacts_msg.contacts.resize(4);\n\t\tfoot_contacts_msg.contacts[0].name = \"left_front_leg\";\n\t\tfoot_contacts_msg.contacts[1].name = \"right_front_leg\";\n\t\tfoot_contacts_msg.contacts[2].name = \"left_back_leg\";\n\t\tfoot_contacts_msg.contacts[3].name = \"right_back_leg\";\n\n\t\tfor (size_t i = 0; i < 4; ++i) {\n\t\t\tfoot_contacts_msg.contacts[i].contact = foot_contacts[i];\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(foot_contacts_msg);\n\t}\n}", "CodeBleu_score": 54.03363453617753}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a minimal joints message\n\tjoints_minimal = Joints()\n\tjoints_minimal.joint_names = self.joint_names\n\tjoints_minimal.positions = []\n\tfor i in range(0, 12):\n\t\tjoints_minimal.positions.append(joints.position[i])\n\n\t# Publish the minimal joints message\n\tself.joint_minimal_pub.publish(joints_minimal)\n\n\t# Create a joint trajectory message\n\tjoint_trajectory = JointTrajectory()\n\tjoint_trajectory.joint_names = self.joint_names\n\tjoint_trajectory.points = []\n\tjoint_trajectory_point = JointTrajectoryPoint()\n\tjoint_trajectory_point.positions = joints.position\n\tjoint_trajectory_point.time_from_start = rospy.Duration(rospy.get_param('champ_controller/joint_trajectory_time'))\n\tjoint_trajectory.points.append(joint_trajectory_point)\n\n\t# Publish the joint trajectory message\n\tself.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 52.72144001649862}, {"code": "def joints_cmd_callback(self, joints){\n\t\tjoint_names = self.joint_names\n\tjoints_minimal = Joints()\n\tjoints_minimal.header.stamp = rospy.Time.now()\n\tjoints_minimal.header.frame_id = \"base_link\"\n\tjoints_minimal.joint_names = joint_names\n\tjoints_minimal.joint_positions = []\n\tfor i in range(12):\n\t\tjoints_minimal.joint_positions.append(joints.position[i])\n\tself.joint_minimal_pub.publish(joints_minimal)\n\tjoints_trajectory = JointTrajectory()\n\tjoints_trajectory.header.stamp = rospy.Time.now()\n\tjoints_trajectory.header.frame_id = \"base_link\"\n\tjoints_trajectory.joint_names = joint_names\n\tjoints_trajectory.points = []\n\tjoints_trajectory.points.append(JointTrajectoryPoint())\n\tjoints_trajectory.points[0].positions = joints.position\n\tjoints_trajectory.points[0].velocities = joints.velocity\n\tjoints_trajectory.points[0].accelerations = joints.acceleration\n\tjoints_trajectory.points[0].time_from_start = rospy.Duration(0.1)\n\tself.joint_trajectory_pub.publish(joints_trajectory)\n}", "CodeBleu_score": 51.02853742182303}, {"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a minimal joints message\n\tminimal_joints = Joints()\n\tminimal_joints.header.stamp = rospy.Time.now()\n\tminimal_joints.header.frame_id = 'base_link'\n\tminimal_joints.name = self.joint_names\n\tminimal_joints.position = joints.position[0:12]\n\tminimal_joints.velocity = [0.0]*12\n\tminimal_joints.effort = [0.0]*12\n\tself.joint_minimal_pub.publish(minimal_joints)\n\n\t# Create a joint trajectory message\n\ttrajectory = JointTrajectory()\n\ttrajectory.header.stamp = rospy.Time.now()\n\ttrajectory.header.frame_id = 'base_link'\n\ttrajectory.joint_names = self.joint_names\n\ttrajectory_point = JointTrajectoryPoint()\n\ttrajectory_point.positions = joints.position[0:12]\n\ttrajectory_point.velocities = [0.0]*12\n\ttrajectory_point.accelerations = [0.0]*12\n\ttrajectory_point.effort = [0.0]*12\n\ttrajectory_point.time_from_start = rospy.Duration(2.0)\n\ttrajectory.points.append(trajectory_point)\n\tself.joint_trajectory_pub.publish(trajectory)\n}", "CodeBleu_score": 43.69017292166251}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link_name = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> link_name_split;\n\t\tboost::split(link_name_split, link_name, boost::is_any_of(\\\"/\\\"), boost::token_compress_on);\n\t\tif (std::find(foot_links_.begin(), foot_links_.end(), link_name_split[2])!= foot_links_.end()) {\n\t\t\tfoot_contacts_[std::distance(foot_links_.begin(), std::find(foot_links_.begin(), foot_links_.end(), link_name_split[2]))] = true;\n\t\t}\n\t}\n\tchamp_msgs::ContactsStamped foot_contacts_msg;\n\tfoot_contacts_msg.header.stamp = ros::Time::now();\n\tfoot_contacts_msg.header.frame_id = \\\"world\\\";\n\tfoot_contacts_msg.contacts.push_back(foot_contacts_[0]);\n\tfoot_contacts_msg.contacts.push_back(foot_contacts_[1]);\n\tfoot_contacts_msg.contacts.push_back(foot_contacts_[2]);\n\tfoot_contacts_msg.contacts.push_back(foot_contacts_[3]);\n\tcontacts_publisher_.publish(foot_contacts_msg);\n}", "CodeBleu_score": 56.105279441941924}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contacts_ = {false, false, false, false};\n\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\tstd::vector<std::string> parts;\n\t\tboost::split(parts, _msg->contact(i).collision1(), boost::is_any_of(\\\"/\\\"));\n\t\tif (std::find(foot_links_.begin(), foot_links_.end(), parts[1])!= foot_links_.end()) {\n\t\t\tfoot_contacts_[0] = true;\n\t\t}\n\t\tparts.clear();\n\t\tboost::split(parts, _msg->contact(i).collision2(), boost::is_any_of(\\\"/\\\"));\n\t\tif (std::find(foot_links_.begin(), foot_links_.end(), parts[1])!= foot_links_.end()) {\n\t\t\tfoot_contacts_[1] = true;\n\t\t}\n\t}\n\tchamp_msgs::ContactsStamped contacts_msg;\n\tcontacts_msg.header.stamp = ros::Time::now();\n\tcontacts_msg.header.frame_id = \\\"base_footprint\\\";\n\tcontacts_msg.contacts.push_back(foot_contacts_[0]);\n\tcontacts_msg.contacts.push_back(foot_contacts_[1]);\n\tcontacts_msg.contacts.push_back(foot_contacts_[2]);\n\tcontacts_msg.contacts.push_back(foot_contacts_[3]);\n\tcontacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 43.765049625995765}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_[i] = false;\n\t}\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string contact_link = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> tokens;\n\t\tboost::split(tokens, contact_link, boost::is_any_of(\\\"/\\\"), boost::token_compress_on);\n\t\tif (tokens.size() >= 2) {\n\t\t\tstd::string link_name = tokens[1];\n\t\t\tfor (int i = 0; i < foot_links_.size(); i++) {\n\t\t\t\tif (link_name.compare(foot_links_[i]) == 0) {\n\t\t\t\t\tfoot_contacts_[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tchamp_msgs::ContactsStamped msg;\n\tmsg.header.stamp = ros::Time::now();\n\tmsg.header.frame_id = \\\"base_footprint\\\";\n\tmsg.contacts.resize(4);\n\tfor (int i = 0; i < 4; i++) {\n\t\tmsg.contacts[i].contact = foot_contacts_[i];\n\t}\n\tcontacts_publisher_.publish(msg);\n}", "CodeBleu_score": 57.41348525552596}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\nROS_ERROR(\n\"LeePositionController::CalculateRotorVelocities: \"\n\"Parameters not initialized. Call InitializeParameters() first.\");\nreturn;\n}\nif (!controller_active_) {\n*rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_configuration_.rotors.size());\nreturn;\n}\n\n// Calculate desired acceleration.\nEigen::Vector3d desired_acceleration =\ncontroller_parameters_.attitude_gain_ * (vehicle_parameters_.attitude_ - desired_attitude_) +\ncontroller_parameters_.angular_rate_gain_ * (vehicle_parameters_.angular_rate_ - desired_angular_rate_);\n\n// Calculate desired angular acceleration.\nEigen::Vector3d desired_angular_acceleration =\nangular_acc_to_rotor_velocities_ * desired_acceleration;\n\n// Project thrust onto the body z-axis.\nEigen::Vector3d thrust_body = thrust_ * vehicle_parameters_.rotor_configuration_.rotors.front().axis;\n\n// Combine thrust and angular acceleration.\nEigen::Vector3d angular_acceleration_body =\ndesired_angular_acceleration + thrust_body;\n\n// Compute the rotor velocities.\n*rotor_velocities =\ncontroller_parameters_.allocation_matrix_ * angular_acceleration_body;\n\n// Ensure non-negative values.\n*rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->size()));\n\n// Take the square root of each component.\n*rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 53.19349644915452}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\nROS_ERROR(\"LeePositionController::CalculateRotorVelocities: Parameters not initialized!\");\nreturn;\n}\n\nif (!controller_active_) {\n*rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_configuration_.rotors.size());\nreturn;\n}\n\nEigen::Vector4d desired_acceleration;\nEigen::Vector4d desired_angular_acceleration;\n\nCalculateDesiredAcceleration(rotor_velocities->size(), &desired_acceleration);\nCalculateDesiredAngularAcceleration(rotor_velocities->size(), &desired_angular_acceleration);\n\nEigen::Vector4d thrust_projection;\nthrust_projection.setZero();\nthrust_projection(2) = desired_acceleration(2);\n\nEigen::Vector4d angular_acc_projection;\nangular_acc_projection.setZero();\nangular_acc_projection(2) = desired_angular_acceleration(2);\n\nEigen::Vector4d rotor_velocities_combined;\nrotor_velocities_combined = thrust_projection + angular_acc_projection;\n\nfor (unsigned int i = 0; i < rotor_velocities->size(); i++) {\nrotor_velocities->coeffRef(i) = std::sqrt(rotor_velocities_combined.coeff(i));\n}\n\nrotor_velocities->array() = rotor_velocities->array().cwiseMax(0.);\n}", "CodeBleu_score": 50.44963994143692}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\nassert(initialized_params_);\n\nEigen::Vector3d position_error;\nposition_error.setZero();\nposition_error(0) = command_trajectory_.position(0) - odometry_.position(0);\nposition_error(1) = command_trajectory_.position(1) - odometry_.position(1);\nposition_error(2) = command_trajectory_.position(2) - odometry_.position(2);\n\nEigen::Vector3d velocity_error;\nvelocity_error.setZero();\nvelocity_error(0) = command_trajectory_.velocity(0) - odometry_.velocity(0);\nvelocity_error(1) = command_trajectory_.velocity(1) - odometry_.velocity(1);\nvelocity_error(2) = command_trajectory_.velocity(2) - odometry_.velocity(2);\n\nEigen::Vector3d desired_acceleration;\ndesired_acceleration.setZero();\ndesired_acceleration(0) = controller_parameters_.position_gain_(0) * position_error(0)\n+ controller_parameters_.velocity_gain_(0) * velocity_error(0);\ndesired_acceleration(1) = controller_parameters_.position_gain_(1) * position_error(1)\n+ controller_parameters_.velocity_gain_(1) * velocity_error(1);\ndesired_acceleration(2) = controller_parameters_.position_gain_(2) * position_error(2)\n+ controller_parameters_.velocity_gain_(2) * velocity_error(2);\n\nEigen::Vector3d gravity_acceleration;\ngravity_acceleration.setZero();\ngravity_acceleration(2) = -vehicle_parameters_.mass_ * vehicle_parameters_.gravity_;\n\n*acceleration = desired_acceleration + gravity_acceleration;\n}", "CodeBleu_score": 46.09950796773271}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n// Compute the position error.\nEigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n// Compute the velocity error.\nEigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n// Compute the desired acceleration.\n*acceleration = -vehicle_parameters_.mass_ * (\n// Position error.\ncontroller_parameters_.position_gain_ * position_error +\n// Velocity error.\ncontroller_parameters_.velocity_gain_ * velocity_error +\n// Gravity.\nEigen::Vector3d(0.0, 0.0, -vehicle_parameters_.gravity_));\n}", "CodeBleu_score": 38.66577363079067}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\nassert(initialized_params_);\n\nEigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\nEigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n// Transform the vehicle's velocity to the world frame.\nEigen::Vector3d velocity_world = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n// Calculate the desired acceleration.\n*acceleration = (controller_parameters_.position_gain_ * position_error + controller_parameters_.velocity_gain_ * velocity_error)\n- (vehicle_parameters_.mass_ * (vehicle_parameters_.gravity_ - velocity_world) + vehicle_parameters_.mass_ * command_trajectory_.acceleration);\n}", "CodeBleu_score": 50.33832076782675}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\nstd::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: Parameters not initialized!\" << std::endl;\nreturn;\n}\n\nif (rotor_velocities->size()!= amount_rotors_) {\nstd::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: Rotor velocities vector size does not match number of rotors!\" << std::endl;\nreturn;\n}\n\nEigen::Vector4d desired_angular_acceleration;\ndesired_angular_acceleration << 0, 0, 0, 0;\n\n// calculate desired angular acceleration\ndesired_angular_acceleration(0) = -2 * (reference_attitude_(0) - current_attitude_(0)) / (dt_ * dt_);\ndesired_angular_acceleration(1) = -2 * (reference_attitude_(1) - current_attitude_(1)) / (dt_ * dt_);\ndesired_angular_acceleration(2) = -2 * (reference_attitude_(2) - current_attitude_(2)) / (dt_ * dt_);\n\n// calculate desired angular velocity\ndesired_angular_velocity_ = desired_angular_velocity_ + dt_ * desired_angular_acceleration;\n\n// calculate desired rotor velocities\nEigen::Vector4d desired_rotor_velocities;\ndesired_rotor_velocities = allocation_matrix_ * desired_angular_velocity_;\n\n// make sure rotor velocities are at least one\ndesired_rotor_velocities.array() = desired_rotor_velocities.array().max(1);\n\n// compute rotor velocities\n*rotor_velocities = desired_rotor_velocities.array().sqrt();\n}", "CodeBleu_score": 37.167093846256066}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!initialized_params_) {\n\t\tROS_ERROR(\"AttitudeControllerSamy::CalculateRotorVelocities: Parameters not initialized!\");\n\t\treturn;\n\t}\n\tif (rotor_velocities->size()!= amount_rotors_) {\n\t\trotor_velocities->resize(amount_rotors_);\n\t}\n\tEigen::Vector4d angular_acc_desired;\n\tangular_acc_desired.setZero();\n\tangular_acc_desired(0) = -1 * (reference_attitude_.roll() - current_attitude_.roll()) * gain_attitude_(0);\n\tangular_acc_desired(1) = -1 * (reference_attitude_.pitch() - current_attitude_.pitch()) * gain_attitude_(1);\n\tangular_acc_desired(2) = -1 * (reference_attitude_.yaw() - current_attitude_.yaw()) * gain_attitude_(2);\n\tangular_acc_desired(3) = 0;\n\tEigen::Vector4d angular_acc_to_rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acc_desired;\n\trotor_velocities->setZero();\n\tfor (int i = 0; i < amount_rotors_; i++) {\n\t\trotor_velocities->coeffRef(i) = sqrt(angular_acc_to_rotor_velocities.coeff(i));\n\t}\n}", "CodeBleu_score": 41.7741805645697}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Check input\n\tif (!initialized_params_) {\n\t\tthrow std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: Controller not initialized.\");\n\t}\n\tif (rotor_velocities->size()!= amount_rotors_) {\n\t\tthrow std::invalid_argument(\"AttitudeControllerSamy::CalculateRotorVelocities: Rotor velocities vector size does not match the number of rotors.\");\n\t}\n\n\t// Compute desired angular acceleration\n\tEigen::Vector4d angular_acc;\n\tangular_acc << 0, 0, 0, 0;\n\tangular_acc(0) = -1 * gain_attitude_(0) * (reference_attitude_ - current_attitude_);\n\tangular_acc(1) = -1 * gain_attitude_(1) * (reference_attitude_ - current_attitude_);\n\tangular_acc(2) = -1 * gain_attitude_(2) * (reference_angular_rate_ - current_angular_rate_);\n\n\t// Compute rotor velocities\n\tEigen::Vector4d rotor_velocities_tmp = angular_acc_to_rotor_velocities_ * angular_acc;\n\tfor (int i = 0; i < 4; ++i) {\n\t\trotor_velocities_tmp(i) = sqrt(rotor_velocities_tmp(i));\n\t}\n\t*rotor_velocities = allocation_matrix_ * rotor_velocities_tmp;\n}", "CodeBleu_score": 41.6524956988998}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.searchsorted(self.time, start_time)\n    end_idx = numpy.searchsorted(self.time, end_time)\n    if start_idx == 0 and end_idx == 0:\n        raise ValueError(\\\"Start time must be greater than end time.\\\")\n    if start_idx == 0:\n        start_idx = 1\n    if end_idx == 0:\n        end_idx = 1\n    if end_idx > len(self.time):\n        end_idx = len(self.time)\n    if start_idx > len(self.time):\n        start_idx = len(self.time)\n    copy = copy.deepcopy(self)\n    copy.time = self.time[start_idx:end_idx]\n    copy.bag_time = self.bag_time[start_idx:end_idx]\n    return copy\n\n", "CodeBleu_score": 21.215253125439887}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.searchsorted(self.time, start_time)\n    end_idx = numpy.searchsorted(self.time, end_time)\n    if start_idx == end_idx:\n        return None\n    else:\n        copied_object = copy.deepcopy(self)\n        for attr in dir(self):\n            if isinstance(getattr(self, attr), numpy.ndarray):\n                setattr(copied_object, attr, getattr(self, attr)[start_idx:end_idx])\n        return copied_object\n\n", "CodeBleu_score": 31.453611051132718}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.searchsorted(self.time, start_time)\n    end_idx = numpy.searchsorted(self.time, end_time)\n    start_idx = max(0, start_idx - 1)\n    end_idx = min(len(self.time), end_idx)\n    if start_idx == end_idx:\n        return copy.deepcopy(self)\n    else:\n        new_obj = copy.deepcopy(self)\n        for attr in self.__dict__.keys():\n            if isinstance(getattr(self, attr), numpy.ndarray):\n                setattr(new_obj, attr, getattr(self, attr)[start_idx:end_idx])\n            elif isinstance(getattr(self, attr), list):\n                setattr(new_obj, attr, getattr(self, attr)[start_idx:end_idx])\n            elif isinstance(getattr(self, attr), BaseWithTime):\n                setattr(new_obj, attr, getattr(self, attr).slice(start_time, end_time))\n            else:\n                setattr(new_obj, attr, getattr(self, attr))\n        return new_obj\n", "CodeBleu_score": 42.558482635031815}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.empty = False\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n    euler_angles = tf.transformations.euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    yaw = euler_angles[2]\n    point = Point(position.x, position.y, position.z)\n    if not self.empty:\n        if (point.x!= self.x[-1] or point.y!= self.y[-1] or point.z!= self.z[-1] or yaw!= self.yaw[-1]):\n            self.append_point(point)\n            self.yaw = numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 42.58209629702673}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if self.empty:\n        self.empty = False\n        self.append_point(waypoint_msg.pose.position)\n        self.yaw = numpy.append(self.yaw, waypoint_msg.pose.orientation.z)\n        self.append_times(msg_time, bag_time)\n    else:\n        if (self.x[-1]!= waypoint_msg.pose.position.x) or (self.y[-1]!= waypoint_msg.pose.position.y) or (self.z[-1]!= waypoint_msg.pose.position.z) or (self.yaw[-1]!= waypoint_msg.pose.orientation.z):\n            self.append_point(waypoint_msg.pose.position)\n            self.yaw = numpy.append(self.yaw, waypoint_msg.pose.orientation.z)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 28.739811240786352}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if self.empty:\n        self.x = numpy.append(self.x, waypoint_msg.position.x)\n        self.y = numpy.append(self.y, waypoint_msg.position.y)\n        self.z = numpy.append(self.z, waypoint_msg.position.z)\n        self.yaw = numpy.append(self.yaw, waypoint_msg.orientation.z)\n        self.empty = False\n    else:\n        if self.x[len(self.x) - 1]!= waypoint_msg.position.x or self.y[len(self.y) - 1]!= waypoint_msg.position.y or self.z[len(self.z) - 1]!= waypoint_msg.position.z or self.yaw[len(self.yaw) - 1]!= waypoint_msg.orientation.z:\n            self.x = numpy.append(self.x, waypoint_msg.position.x)\n            self.y = numpy.append(self.y, waypoint_msg.position.y)\n            self.z = numpy.append(self.z, waypoint_msg.position.z)\n            self.yaw = numpy.append(self.yaw, waypoint_msg.orientation.z)\n    self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 29.676728964954446}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        if \"Accel\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n        elif \"Imu\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n        else:\n            print(\"Got unknown type: %s\" % type(msg))\n\n", "CodeBleu_score": 45.24069321579257}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        elif \"Accel\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear)\n            self.acc[index].append_times(msg_time, bag_time)\n        elif \"Imu\" in str(type(msg)):\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n        elif \"ImuStamped\" in str(type(msg)):\n            self.acc[index].append_point(msg.accel.linear)\n            self.acc[index].append_times(msg_time, bag_time)\n        else:\n            print(\"Got unknown type: %s\" % type(msg))\n", "CodeBleu_score": 45.07163513831047}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        self.acc[index].append_point(msg.linear_acceleration)\n        self.acc[index].append_times(msg_time, bag_time)\n\n        self.ang_vel[index].append_point(msg.angular_velocity)\n        self.ang_vel[index].append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 51.33747319242813}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                     box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 70.62357102847226}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_accelerations' if self.prefix else 'accelerations'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 77.60384819029613}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    # Shrink current axis's height by 10% on the bottom\n    box = a_x.get_position()\n    a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                     box.width, box.height * 0.8])\n\n    # Put a legend below current axis\n    a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n               fancybox=True, shadow=True, ncol=5)\n    pyplot.grid(b=True, which='both')\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n", "CodeBleu_score": 70.4091509707524}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print('Error: At least two pose indices required for comparison.')\n        return\n    for index, pose_index in enumerate(pose_indeces):\n        if index == 0:\n            continue\n        else:\n            self.compare_two_xyz(pose_index, pose_indeces[index - 1])\n\n", "CodeBleu_score": 42.22984255838132}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError('At least two pose indices required.')\n    for index, pose_index in enumerate(pose_indeces):\n        if index == len(pose_indeces) - 1:\n            break\n        else:\n            self.compare_two_xyz(pose_index, pose_indeces[index + 1])\n\n", "CodeBleu_score": 38.79344848533305}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print 'Error: at least two pose indices required for comparison'\n        return\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 36.15286362413313}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for index, wrench in enumerate(self.wrench):\n        if wrench.time > start_time and wrench.time < end_time:\n            collision_times.append(wrench.time)\n    return collision_times\n", "CodeBleu_score": 37.8468915430317}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        if wrench.time >= start_time and wrench.time <= end_time:\n            collision_times.append(wrench.time)\n    return collision_times\n\n", "CodeBleu_score": 33.56452015331139}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        if start_time and wrench.time < start_time:\n            continue\n        if end_time and wrench.time > end_time:\n            break\n        collision_times.append(wrench.time)\n    return collision_times\n\n", "CodeBleu_score": 39.633707645216546}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 71.55115547094847}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 71.55115547094847}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix)\n    analyze_bag.plot_angular_velocity_error(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        y_range=[-1.5, 1.5],\n        plot_suffix=plot_suffix)\n\n", "CodeBleu_score": 71.55115547094847}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n// Check if data pointer is null and return if it is\nif (data == nullptr) {\nreturn;\n}\n\n// Calculate multiplier based on camera parameters\nconst float multiplier = 1.0f / (this->camera_info.fx * this->camera_info.fy);\n\n// Map data to Eigen vector\nEigen::Map<Eigen::VectorXf> depth_vector(data, width * height);\n\n// Compute RMS noise\nconst float rms_noise = this->ComputeRMSNoise(depth_vector);\n\n// Compute noise values\nconst float noise_value = rms_noise * multiplier;\n\n// Add noise if pixel is in range, otherwise set pixel to bad point value\nfor (size_t i = 0; i < depth_vector.size(); ++i) {\nif (this->InRange(depth_vector(i))) {\ndepth_vector(i) += noise_value;\n} else {\ndepth_vector(i) = this->bad_point_value;\n}\n}\n}", "CodeBleu_score": 42.39859482851784}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\n\nconst float multiplier = this->multiplier_ * this->multiplier_;\nconst float multiplier_squared = multiplier * multiplier;\n\nEigen::VectorXf depth_data(width * height);\n\nfor (uint32_t i = 0; i < width * height; ++i) {\ndepth_data[i] = data[i];\n}\n\nconst float rms_noise = std::sqrt(multiplier_squared / (2.0 * this->sigma_ * this->sigma_));\nconst float noise_value = rms_noise * std::sqrt(-2.0 * std::log(this->noise_probability_));\n\nfor (uint32_t i = 0; i < width * height; ++i) {\nif (InRange(depth_data[i])) {\ndepth_data[i] += noise_value * std::sqrt(depth_data[i]);\n} else {\ndepth_data[i] = this->bad_point_value_;\n}\n}\n\nstd::copy(depth_data.data(), depth_data.data() + width * height, data);\n}", "CodeBleu_score": 53.51064301357772}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == NULL) {\nreturn;\n}\n\n// Calculate the multiplier based on the camera parameters\nfloat multiplier = this->depth_noise_multiplier;\nif (this->depth_noise_multiplier_auto) {\nmultiplier = this->depth_noise_multiplier * this->depth_noise_multiplier_factor;\n}\n\n// Map the data to an Eigen vector\nEigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n\n// Compute the RMS noise\nfloat rms_noise = this->depth_noise_rms * multiplier;\n\n// Compute the noise values\nEigen::VectorXf noise_values = rms_noise *\nEigen::VectorXf::Random(width * height);\n\n// Apply the noise\nfor (size_t i = 0; i < width * height; ++i) {\nif (InRange(depth_data[i])) {\ndepth_data[i] += noise_values[i];\n} else {\ndepth_data[i] = this->bad_point_value;\n}\n}\n}", "CodeBleu_score": 49.33999654108581}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\ncommon::Time now = world_->SimTime();\nros::Time ros_now = ros::Time(now.sec, now.nsec);\nwriteBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 98.30113847064948}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\ncommon::Time now = world_->SimTime();\nros::Time ros_now = ros::Time(now.sec, now.nsec);\nwriteBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 98.30113847064948}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\ncommon::Time now = world_->SimTime();\nros::Time ros_now = ros::Time(now.sec, now.nsec);\nwriteBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 98.30113847064948}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n// Prepare the message.\nmav_msgs::Actuators motor_velocities;\nmotor_velocities.time_stamp = ros_now;\n\n// Iterate through the motor joints.\nfor (int i = 0; i < world_->ModelCount(); ++i) {\nconst physics::ModelPtr& model = world_->ModelByIndex(i);\n\n// Get the joints.\nconst std::vector<physics::JointPtr>& joints = model->GetJoints();\n\n// Iterate through the joints.\nfor (int j = 0; j < joints.size(); ++j) {\nconst physics::JointPtr& joint = joints[j];\n\n// Get the joint name.\nstd::string joint_name = joint->GetName();\n\n// Get the joint type.\nphysics::JointType joint_type = joint->GetType();\n\n// Get the joint velocity.\ndouble joint_velocity = joint->GetVelocity(0);\n\n// Get the motor joint velocity.\ndouble motor_joint_velocity = joint_velocity * slowdown_factor_;\n\n// Get the motor joint name.\nstd::string motor_joint_name = joint_name + \\\"_velocity\\\";\n\n// Check if the motor joint velocity is zero.\nif (motor_joint_velocity == 0.0) {\ncontinue;\n}\n\n// Get the motor joint index.\nint motor_joint_index = GetMotorJointIndex(motor_joint_name);\n\n// Check if the motor joint index is valid.\nif (motor_joint_index < 0) {\ncontinue;\n}\n\n// Set the motor joint velocity.\nmotor_velocities.angular_velocities[motor_joint_index] = motor_joint_velocity;\n}\n}\n\n// Write the message to the bag file.\nwriteBag(namespace_ + \\\"/\\\" + control_motor_speed_topic_, ros_now, motor_velocities);\n}", "CodeBleu_score": 43.420273713943715}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Get the ROS time.\nros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n// Prepare a message for actuator velocities.\nmav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators());\nactuators_msg->time_stamp = ros_now;\n\n// Iterate through the motor joints and calculate the slowed-down rotational velocities.\nfor (const auto& joint_name : motor_joint_names_) {\ndouble joint_velocity;\ndouble joint_slowdown_velocity;\n\n// Get the joint velocity.\njoint_velocity = joint_velocity_map_[joint_name];\n\n// Calculate the slowed-down rotational velocity.\njoint_slowdown_velocity = joint_velocity / slowdown_factor_;\n\n// Assign the slowed-down rotational velocity to the message.\nactuators_msg->angular_velocities[motor_joint_map_[joint_name]] = joint_slowdown_velocity;\n}\n\n// Write the message to the bag file.\nwriteBag(namespace_ + \"/\" + control_motor_speed_topic_, ros_now, actuators_msg);\n}", "CodeBleu_score": 47.934946350469744}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tif (kPrintOnUpdates) {\ngzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n}\n\n// Get the current simulation time.\nros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n// Prepare the message.\nmav_msgs::Actuators actuator_msg;\nactuator_msg.header.stamp = ros_now;\n\n// Iterate through the motor joints.\nfor (int i = 0; i < motor_joints_.size(); ++i) {\n// Get the joint name.\nstd::string joint_name = motor_joints_[i]->GetName();\n\n// Get the joint velocity.\ndouble joint_velocity = motor_joints_[i]->GetVelocity(0);\n\n// Get the joint position.\ndouble joint_position = motor_joints_[i]->GetAngle(0).Radian();\n\n// Get the joint velocity.\ndouble joint_velocity_slowed_down = slow_down_factor_ * joint_velocity;\n\n// Get the joint position.\ndouble joint_position_slowed_down = slow_down_factor_ * joint_position;\n\n// Set the joint velocity.\nactuator_msg.angular_velocities.push_back(joint_velocity_slowed_down);\n\n// Set the joint position.\nactuator_msg.angular_positions.push_back(joint_position_slowed_down);\n}\n\n// Write the message to the bag file.\nwriteBag(namespace_ + \"/\" + control_motor_speed_topic_, ros_now, actuator_msg);\n}", "CodeBleu_score": 53.31756193369481}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t if (kPrintOnMsgCallback) {\n gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n }\n\n delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\n delta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\n delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\n delta_flap_ = NormalizedInputToAngle(vehicle_params_.flap,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.flap.channel));\n delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\n throttle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 65.0153531408852}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (kPrintOnMsgCallback) {\ngzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n}\n\ndouble roll_angle = NormalizedInputToAngle(vehicle_params_.aileron_left, roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\ndouble pitch_angle = NormalizedInputToAngle(vehicle_params_.elevator, roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\ndouble yaw_rate = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.yawrate_channel);\n\nthrottle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n\n}", "CodeBleu_score": 57.625639519379504}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t if (kPrintOnMsgCallback) {\n gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n }\n\n delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n roll_pitch_yawrate_thrust_msg->normalized(\n vehicle_params_.aileron_left.channel));\n delta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n roll_pitch_yawrate_thrust_msg->normalized(\n vehicle_params_.aileron_right.channel));\n delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n roll_pitch_yawrate_thrust_msg->normalized(\n vehicle_params_.elevator.channel));\n delta_flap_ = NormalizedInputToAngle(vehicle_params_.flap,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.flap.channel));\n delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\n throttle_ = roll_pitch_yawrate_thrust_msg->normalized(\n vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 64.9085983724959}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if defined(IGN_ENABLE_ROS)\n  // ROS message handling\n  ros_poll_for_messages(_dt);\n#endif\n\n  // Poll for MAVLink messages\n  struct pollfd fds[1];\n  fds[0].fd = serial_fd_;\n  fds[0].events = POLLIN;\n\n  int ret = poll(fds, 1, _timeoutMs);\n\n  if (ret < 0) {\n    gzerr << \"GazeboMavlinkInterface::pollForMAVLinkMessages() poll() failed: \"\n          << strerror(errno) << \"\n\";\n    return;\n  }\n\n  if (ret == 0) {\n    gzwarn << \"GazeboMavlinkInterface::pollForMAVLinkMessages() poll() timed out\n\";\n    return;\n  }\n\n  if (fds[0].revents & POLLIN) {\n    // Read available bytes from serial port\n    int bytesRead = 0;\n    char buffer[1024];\n\n    bytesRead = read(serial_fd_, buffer, 1024);\n\n    if (bytesRead < 0) {\n      gzerr << \"GazeboMavlinkInterface::pollForMAVLinkMessages() read() failed: \"\n            << strerror(errno) << \"\n\";\n      return;\n    }\n\n    // Parse received bytes\n    uint8_t *buf = (uint8_t *)buffer;\n\n    while (bytesRead > 0) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      // Parse the message\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[0], &msg, &status)) {\n        // Message successfully parsed\n        if (status.packet_rx_drop_count > 0) {\n          gzwarn << \"GazeboMavlinkInterface::pollForMAVLinkMessages() dropped \"\n                 << status.packet_rx_drop_count << \" MAVLink messages\n\";\n        }\n\n        // Handle the message\n        handleMessage(msg);\n      }\n\n      // Move to the next byte\n      buf++;\n      bytesRead--;\n    }\n  }\n}", "CodeBleu_score": 42.97442818149608}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef _WIN32\n  // Windows does not support poll()\n  return;\n#else\n  // Poll for MAVLink messages\n  fd_set fds;\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n  FD_ZERO(&fds);\n  FD_SET(fd_serial_, &fds);\n  if (fd_serial_ > 0) {\n    if (select(fd_serial_ + 1, &fds, NULL, NULL, &tv) > 0) {\n      // MAVLink message received\n      char buf[1024];\n      ssize_t bytes_read = read(fd_serial_, buf, sizeof(buf));\n      if (bytes_read > 0) {\n        // Parse MAVLink messages\n        mavlink_message_t msg;\n        for (int i = 0; i < bytes_read; i++) {\n          mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status_);\n        }\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 59.86765321044256}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\topen_ = false;\n\t}\n}", "CodeBleu_score": 65.34930655507922}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (serial_dev_.is_open()) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 66.0657953761309}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// lock mutex\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\t// check if open\n\tif (is_open_) {\n\t\t// stop io service\n\t\tio_service_.stop();\n\n\t\t// close serial device\n\t\tserial_dev_.close();\n\n\t\t// if io thread is joinable, join it\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\n\t\t// set is_open to false\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 65.28947523098043}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d p1;\n\tignition::math::Vector3d p2;\n\tdouble x;\n}", "CodeBleu_score": 6.6423686138688405}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (this->timePos!= _time) {\nthis->timePos = _time;\nif (this->loop) {\nthis->timePos = std::fmod(_time, this->length);\n} else {\nthis->timePos = std::min(this->timePos, this->length);\nthis->timePos = std::max(this->timePos, 0.0);\n}\n}\n}", "CodeBleu_score": 52.11141584531871}, {"code": "void Animation::SetTime(double _time){\n\tif (this->timePos!= _time) {\nthis->timePos = _time;\nif (this->loop) {\nthis->timePos = std::fmod(this->timePos, this->length);\n} else {\nthis->timePos = std::min(this->timePos, this->length);\nthis->timePos = std::max(this->timePos, 0.0);\n}\n}\n}", "CodeBleu_score": 52.3270567664619}, {"code": "void Animation::SetTime(double _time){\n\t\n}", "CodeBleu_score": 2.3054066121187096}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+\\\"hovering\\\")\n", "CodeBleu_score": 75.00346329014124}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+\\\"hovering\\\")\n\n\n", "CodeBleu_score": 78.19545752108819}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+\\\"hovering\\\")\n\n", "CodeBleu_score": 75.00346329014124}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+': failed to switch to '+self.flight_mode)\n            return False\n\n", "CodeBleu_score": 63.41662727324484}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n        return True\n    elif self.flightModeService(self.flight_mode):\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\": failed to switch to \"+self.flight_mode)\n        return False\n", "CodeBleu_score": 67.30314085274327}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": switching to \"+self.flight_mode+\" failed!\\\")\n            return False\n\n", "CodeBleu_score": 55.80176790872062}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        self.hover_flag = 0\n        self.flight_mode_service(custom_mode=0)\n        print(self.vehicle_type + '_' + self.vehicle_id + ': OFFBOARD')\n    else:\n        if (self.hover_flag == 0):\n            self.hover_flag = 1\n            self.flight_mode_service(custom_mode=1)\n            print(self.vehicle_type + '_' + self.vehicle_id + ': HOVER')\n            self.hover_action()\n", "CodeBleu_score": 37.08947791853055}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.flightModeService(custom_mode='OFFBOARD')\n    else:\n        if self.hover_flag == 0:\n            self.flightModeService(custom_mode='HOVER')\n            self.hover_flag = 1\n\n", "CodeBleu_score": 40.60515117521355}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        self.hover_flag = 0\n        self.flightModeService(custom_mode=1)\n    else:\n        if (self.hover_flag == 0 and self.flight_mode!= 'HOVER'):\n            self.hover_flag = 1\n            self.flightModeService(custom_mode=3)\n            self.hold_flag = 0\n            self.hold_state_transition(x, y, z, w, 'flu')\n\n", "CodeBleu_score": 36.276722847320535}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        yaw = Quaternion(q[0], q[1], q[2], q[3]).yaw\n    return yaw\n\n", "CodeBleu_score": 36.644194759173175}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": Hovering at \" + str(self.current_position))\n\n", "CodeBleu_score": 44.46993745362658}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 0\n    self.motion_type = 0\n    self.target_motion = self.construct_target()\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": Hovering at \\\" + str(self.current_position))\n\n", "CodeBleu_score": 39.88099987230922}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 8\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": hovering in \" + self.flight_mode)\n", "CodeBleu_score": 44.27159928230889}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": switching to \\\" + self.flight_mode + \\\": failed!\\\")\n            return False\n\n", "CodeBleu_score": 55.30588171251654}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n\n        return True\n\n    else:\n\n        if self.flightModeService(self.flight_mode):\n\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n            return True\n\n        else:\n\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": failed to switch flight mode to \\\" + self.flight_mode)\n\n            return False\n\n\n\n", "CodeBleu_score": 51.334469005677555}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": switching to \\\" + self.flight_mode + \\\": failed!\\\")\n            return False\n\n", "CodeBleu_score": 52.147288118084475}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n    return self.total_reward\n\n\n\n", "CodeBleu_score": 55.929247471399535}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n    return self.total_reward\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 55.929247471399535}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 59.237293478588235}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[i] = self.local_pose\n        self.global_pose[i].pose.position.x += self.bias_x\n        self.global_pose[i].pose.position.y += self.bias_y\n        self.global_pose[i].pose.position.z += self.bias_z\n        if self.gcs_cmd == 'AUTO.TAKEOFF':\n            self.takeoff_target_pose = self.local_pose\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = self.local_pose\n\n", "CodeBleu_score": 33.23908560326825}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose[i] = self.local_pose\n        self.global_pose[i].pose.position.x += self.x_bias\n        self.global_pose[i].pose.position.y += self.y_bias\n        self.global_pose[i].pose.position.z += self.z_bias\n\n        if self.gcs_cmd == 'AUTO.TAKEOFF':\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.pose.position.z = self.takeoff_height\n            self.target_pose = self.construct_target(self.takeoff_target_pose.pose.position.x,\n                                                 self.takeoff_target_pose.pose.position.y, self.takeoff_target_pose.pose.position.z,\n                                                 self.current_heading)\n            self.local_target_pub.publish(self.target_pose)\n\n            if self.takeoff_detection():\n                print(self.namespace, \\\": Takeoff Success!\\\")\n            else:\n                print(self.namespace, \\\": Takeoff Failed!!!\\\")\n            # self.frameService(1)\n\n        elif self.gcs_cmd == 'FORM_0':\n            self.last_gcs_cmd = 'FORM_0'\n            if self.mavros_state!= 'OFFBOARD':\n                self.flight_mode_set(mode='OFFBOARD')\n\n        elif self.gcs_cmd == 'FORM_1':\n            self.last_gcs_cmd = 'FORM_1'\n            if self.form_flag!= 1:\n                self.read_set_file('FORM_1_id','FORM_1_pos')\n            self.form_flag = 1\n            if self.mavros_state!= 'OFFBOARD':\n                self.flight_mode_set(mode='OFFBOARD')\n            self.formation_control()\n            self.twist_target_pub.publish(self.target_", "CodeBleu_score": 23.94711609333467}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.namespace + '/mavros/local_position/pose':\n        self.local_pose[i] = msg\n        self.local_pose[i].pose.position.x = self.local_pose[i].pose.position.x + self.bias[0]\n        self.local_pose[i].pose.position.y = self.local_pose[i].pose.position.y + self.bias[1]\n        self.local_pose[i].pose.position.z = self.local_pose[i].pose.position.z + self.bias[2]\n        self.global_pose[i] = self.local_pose_to_global(self.local_pose[i])\n        if self.gcs_cmd == 'AUTO.TAKEOFF':\n            self.takeoff_target_pose = self.local_pose[i]\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = self.local_pose[i]\n\n", "CodeBleu_score": 31.85765767367498}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state and self.local_pose.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 63.74420584470499}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z >= 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 74.10148156291044}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t    orig_formation = numpy.array(orig_formation)\n    change_formation = numpy.array(change_formation)\n    # Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\n    distances = numpy.linalg.norm(orig_formation[:, 0:2] - change_formation[:, 0:2], axis=1)\n    # Adjust the distances by subtracting them from 50 and converting to integers.\n    distances = numpy.floor(distances - 50).astype(int)\n    # Create a distance matrix based on the adjusted distances.\n    distance_matrix = numpy.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i, j] = distances[j]\n    return distance_matrix\n\n", "CodeBleu_score": 20.44882174093615}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t    # Calculate the distance between each pair of UAVs in the original and changed formations.\n\n    # The distance is adjusted by subtracting it from 50 and converting it to an integer.\n\n    # The resulting distance matrix is returned.\n\n    # The distance matrix is used to establish a graph for the KM algorithm.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the communication topology.\n\n    # The graph is used to determine the new formation pattern.\n\n    # The graph is used to determine the", "CodeBleu_score": 1.3540510543840176}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t    # The pairwise distances between UAVs in the original and changed formations are calculated.\n    dist_matrix = numpy.linalg.norm(numpy.array(orig_formation) - numpy.array(change_formation), axis=1)\n    # The distances are adjusted by subtracting them from 50 and converted to integers.\n    dist_matrix = numpy.round(50 - dist_matrix).astype(int)\n    return dist_matrix\n", "CodeBleu_score": 8.565922846315468}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] == 0:\n            continue\n        if self.visit_right[j] == 1:\n            continue\n        self.label_left[i] = self.label_left[i] - self.adj_matrix[i][j]\n        self.label_right[j] = self.label_right[j] + self.adj_matrix[i][j]\n        if self.label_left[i] == 0:\n            self.match_right[i] = j\n            self.visit_right[j] = 1\n            if self.find_path(j):\n                return True\n            else:\n                self.slack_right[j] = self.slack_right[j] + self.adj_matrix[i][j]\n                return False\n        else:\n            if self.slack_right[j] > self.label_left[i]:\n                self.slack_right[j] = self.label_left[i]\n            return False\n    return False\n\n    # 'KM' function is the main function for KM algorithm.\n    # It iterates through all left vertices and checks if they can find a path.\n    # If a path is found, it updates the match.\n    # If no path is found, it updates the label of the right vertex.\n    # The function returns the changed_id list.\n    def KM(self):\n        changed_id = []\n        for i in range(self.uav_num - 1):\n            if self.find_path(i):\n                changed_id.append(i)\n                self.label_left[i] = 0\n                self.label_right[self.match_right[i]] = 0\n                self.match_right[i] = -1\n            else:\n                self.label_left[i] = self.label_left[i] + self.slack_right[i]\n        return changed_id\n\n    # 'get_new_formation' function is used to get a new formation pattern based on the changed_id list.\n    def get_new_formation(", "CodeBleu_score": 32.509868980478416}, {"code": "def find_path(self, i)\n\t    if self.visit_left[i] == 1:\n        return False\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] == 0:\n            continue\n        if self.visit_right[j] == 1:\n            continue\n        if self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j] == 0:\n            self.visit_right[j] = 1\n            if self.match_right[j] == -1:\n                return True\n            if not self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                self.match_right[i] = j\n                return True\n        else:\n            self.slack_right[j] = min(self.slack_right[j], self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j])\n    return False\n\n    # KM algorithm.\n    def KM(self):\n        \"\"\"This function, KM, implements the KM algorithm for matching purposes.", "CodeBleu_score": 41.548660969122686}, {"code": "def find_path(self, i)\n\t    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] > 0 and self.visit_right[j] == 0:\n            if self.label_left[i] + self.label_right[j] == self.adj_matrix[i][j]:\n                self.visit_right[j] = 1\n                if self.match_right[j] == -1:\n                    self.match_right[j] = i\n                    return True\n                elif self.find_path(self.match_right[j]) == True:\n                    self.match_right[j] = i\n                    return True\n            elif self.label_left[i] + self.label_right[j] < self.adj_matrix[i][j]:\n                self.slack_right[j] = self.adj_matrix[i][j] - (self.label_left[i] + self.label_right[j])\n                return False\n    return False\n\n    # KM algorithm\n    def KM(self):\n        \"\"\"This function, KM, is the main function of KM algorithm.\n        It iterates through all left vertices and finds a path for each left vertex.\n        It updates the label value for each left vertex.\n        It returns the set of changed IDs.\"\"\"\n        for i in range(self.uav_num - 1):\n            if self.visit_left[i] == 0:\n                self.label_left[i] = 0\n                for j in range(self.uav_num - 1):\n                    self.label_right[j] = 0\n                self.find_path(i)\n                for j in range(self.uav_num - 1):\n                    if self.visit_right[j] == 0:\n                        self.label_right[j] += self.slack_right[j]\n        changed_id = numpy.where(self.match_right!= -1)[0]\n        return changed_id\n\n    # Get a new formation pattern of UAV", "CodeBleu_score": 35.79177819816597}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t    self.label_left = numpy.max(self.adj_matrix, axis=1)\n    self.label_right = numpy.array([0] * (self.uav_num - 1))\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    while True:\n        for i in range(self.uav_num - 1):\n            if self.visit_left[i]:\n                continue\n            if self.find_path(i):\n                break\n            else:\n                self.slack_right[i] = min(self.slack_right[i], self.label_left[i] + self.label_right[i] - self.adj_matrix[i][j])\n        else:\n            break\n        self.label_left = self.label_left + self.slack_right - self.label_right\n        self.label_right = self.label_right - self.slack_right + self.label_left\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    return self.changed_id\n\n", "CodeBleu_score": 44.83841454300171}, {"code": "def KM(self)\n\t    self.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    changed_id = []\n    for i in range(self.uav_num - 1):\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        if self.find_path(i):\n            continue\n        min_slack = min(self.slack_right)\n        self.label_left = self.label_left + min_slack\n        self.label_right = self.label_right - min_slack\n        self.slack_right = self.slack_right - min_slack\n        changed_id.append(i)\n        print(\\\"Changed ID: \\\", i)\n    return changed_id\n\n    # Get a new formation pattern of UAVs based on the match results.\n    def get_new_formation(self, changed_id, formation):\n        new_formation = formation.copy()\n        for i in changed_id:\n            new_formation[:, i] = formation[:, self.match_right[i]]\n        return new_formation\n\n    # Get a communication topology based on the new formation pattern.\n    def get_communication_topology(self, new_formation):\n        communication_topology = numpy.zeros((self.uav_num - ", "CodeBleu_score": 37.61389408432547}, {"code": "def KM(self)\n\t    for i in range(self.uav_num - 1):\n        self.visit_left[i] = False\n        self.visit_right = numpy.array([0] * (self.uav_num - 1))\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.match_right = numpy.array([-1] * (self.uav_num - 1))\n        while True:\n            for j in range(self.uav_num - 1):\n                if self.visit_right[j]:\n                    continue\n                if self.slack_right[j] == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        break\n                    else:\n                        self.slack_right[j] = 100\n                else:\n                    self.slack_right[j] = min(self.slack_right[j], self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j])\n            if self.find_path(i):\n                break\n            else:\n                self.label_left[i] += 1\n    return self.changed_id\n\n    # This function is used to adjust the labels based on the minimum slack value.\n    def adjust_label(self):\n        delta = 100\n        for i in range(self.uav_num - 1):\n            if self.label_left[i] < delta:\n                delta = self.label_left[i]\n        for i in range(self.uav_num - 1):\n            self.label_left[i] -= delta\n            self.label_right[i] += delta\n\n    # This function is used to get a new formation pattern based on the match results.\n    def get_new_formation(self, changed_id, formation):\n        new_formation = formation\n", "CodeBleu_score": 47.29591025216606}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([15, 60, 60])\n    upper_yellow = np.array([35, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.04057546638531}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.array([20, 100, 100])\n    upper = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 31.598554051886964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n// Check if the description is in the map\nif (standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end())\n{\n// If so, return the description\ndescriptionContainer = standalone_tag_descriptions_[id];\nreturn true;\n}\nelse\n{\n// Otherwise, if the warning flag is set, log a warning message\nif (printWarning)\n{\nROS_WARN(\\\"TagDetector: No description found for tag with ID %d\\\", id);\n}\n// And return false\nreturn false;\n}\n}", "CodeBleu_score": 27.384716272810223}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}]}
