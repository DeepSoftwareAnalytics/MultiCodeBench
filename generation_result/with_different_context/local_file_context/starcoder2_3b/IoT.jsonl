{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\n\t/*\n\t * If the provided descriptor is NULL, the function returns NULL.\n\t */\n\tif (NULL == desc) {\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If the provided descriptor is the end of the interface descriptor, the function returns NULL.\n\t */\n\tif (desc == udc_get_eof_conf()) {\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * The function moves to the next descriptor by incrementing the descriptor pointer by the length of the current descriptor.\n\t */\n\tnext_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc + le16_to_cpu(desc->desc->bLength));\n\n\t/*\n\t * The function continues this until it either finds the specified descriptor type or reaches the end of the configuration descriptor.\n\t */\n\twhile (next_desc!= udc_get_eof_conf()) {\n\t\t/*\n\t\t * If the descriptor type is the specified descriptor type, the function returns a pointer to that descriptor.\n\t\t */\n\t\tif (next_desc->desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\t/*\n\t\t * The function moves to the next descriptor by incrementing the descriptor pointer by the length of the current descriptor.\n\t\t */\n\t\tnext_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) next_desc + le16_to_cpu(next_desc->desc->bLength));\n\t}\n\n\t/*\n\t * If the function reaches the end of the configuration descriptor, the function returns NULL.\n\t */\n\treturn NULL;\n}", "CodeBleu_score": 56.6264425346081}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint16_t desc_len;\n\tuint8_t desc_type;\n\n\twhile (desc!= NULL) {\n\t\tdesc_type = desc->desc.bDescriptorType;\n\t\tdesc_len = le16_to_cpu(desc->desc.bLength);\n\t\tnext_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +\n\t\t\t\tdesc_len);\n\t\tif (desc_type == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tif (desc_type == USB_DT_INTERFACE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdesc = next_desc;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 46.80258646772211}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_ptr = desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *desc_end;\n\n\twhile (desc_ptr) {\n\t\tdesc_end = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc_ptr +\n\t\t\t\tle16_to_cpu(desc_ptr->desc.bLength));\n\n\t\tif (desc_ptr->desc.bDescriptorType == desc_id) {\n\t\t\treturn desc_ptr;\n\t\t}\n\n\t\tif (desc_end >= udc_get_eof_conf()) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdesc_ptr = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc_ptr +\n\t\t\t\tle16_to_cpu(desc_ptr->desc.bLength));\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 54.54488169540408}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// Check if there is a valid configuration\n\tif (NULL == udc_ptr_conf) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tusb_conf_desc_t *conf_desc = (usb_conf_desc_t *) ((uint8_t *) udc_ptr_conf->desc + le16_to_cpu(udc_ptr_conf->desc->wTotalLength));\n\twhile (conf_desc < udc_get_eof_conf()) {\n\t\t// Check if the descriptor is an interface descriptor\n\t\tif (USB_DT_INTERFACE == conf_desc->bDescriptorType) {\n\t\t\t// Check if the interface number and setting number match\n\t\t\tif (conf_desc->bInterfaceNumber == iface_num && conf_desc->bAlternateSetting == setting_num) {\n\t\t\t\t// Update the internal pointer to the interface descriptor\n\t\t\t\tudc_ptr_iface = (usb_iface_desc_t *) conf_desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Go to the next descriptor\n\t\tconf_desc = (usb_conf_desc_t *) ((uint8_t *) conf_desc + conf_desc->bLength);\n\t}\n\n\t// No matching interface descriptor found\n\treturn false;\n}", "CodeBleu_score": 51.20478010886582}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// Check if there is a valid configuration\n\tif (NULL == udc_ptr_conf) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tusb_conf_desc_t UDC_DESC_STORAGE *desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) udc_ptr_conf->desc + le16_to_cpu(udc_ptr_conf->desc->wTotalLength));\n\n\t// Check each descriptor to see if it matches the specified interface number and setting number\n\twhile (desc!= NULL) {\n\t\tif (USB_DT_INTERFACE == desc->bDescriptorType) {\n\t\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc = (UDC_DESC_STORAGE usb_iface_desc_t *) desc;\n\n\t\t\tif (iface_num == iface_desc->bInterfaceNumber && setting_num == iface_desc->bAlternateSetting) {\n\t\t\t\tudc_ptr_iface = iface_desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Go to next descriptor\n\t\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc + desc->bLength);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 59.38823996959637}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udd_g_ctrlreq.req.wIndex & 0x0F;\n\tuint8_t ep_dir = (udd_g_ctrlreq.req.wIndex & 0x80)? 1 : 0;\n\tuint8_t ep_status;\n\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tif (ep_dir) {\n\t\tif (ep_num < USB_DEVICE_EP_IN_NUM) {\n\t\t\tep_status = udd_ep_get_status(ep_num);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (ep_num < USB_DEVICE_EP_OUT_NUM) {\n\t\t\tep_status = udd_ep_get_status(ep_num);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ep_status & USB_EP_STATUS_HALT) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) &ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 56.80925981204597}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint8_t ep_status;\n\tuint8_t ep_dir;\n\tuint8_t ep_type;\n\tuint16_t ep_max_packet_size;\n\n\tep_num = udd_g_ctrlreq.req.wIndex & 0x0F;\n\tep_dir = udd_g_ctrlreq.req.wIndex & 0x80;\n\tep_type = udd_g_ctrlreq.req.wValue & 0x03;\n\n\tif (ep_num >= UDD_EP_MAX) {\n\t\treturn false;\n\t}\n\n\tif (ep_dir == UDD_EP_DIR_IN) {\n\t\tep_max_packet_size = udd_ep_in_max_packet_size(ep_num);\n\t} else {\n\t\tep_max_packet_size = udd_ep_out_max_packet_size(ep_num);\n\t}\n\n\tif (ep_type == UDD_EP_TYPE_CONTROL) {\n\t\tep_status = (ep_dir == UDD_EP_DIR_IN)? UDD_EP_STATUS_CONTROL_IN : UDD_EP_STATUS_CONTROL_OUT;\n\t} else if (ep_type == UDD_EP_TYPE_BULK) {\n\t\tep_status = (ep_dir == UDD_EP_DIR_IN)? UDD_EP_STATUS_BULK_IN : UDD_EP_STATUS_BULK_OUT;\n\t} else if (ep_type == UDD_EP_TYPE_INTERRUPT) {\n\t\tep_status = (ep_dir == UDD_EP_DIR_IN)? UDD_EP_STATUS_INTERRUPT_IN : UDD_EP_STATUS_INTERRUPT_OUT;\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (udd_ep_is_halted(ep_num, ep_dir)) {\n\t\tep_status |= UDD_EP_STATUS_HALTED;\n\t}\n\n\tudd_set_setup_payload((uint8_t *) &ep_status, 1);\n\treturn true;\n}", "CodeBleu_score": 46.296099299032434}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\tuint16_t ep_status_le;\n\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tep_addr = (uint8_t) (udd_g_ctrlreq.req.wIndex & 0x00ff);\n\tep_status = udd_ep_get_status(ep_addr);\n\tep_status_le = cpu_to_le16(ep_status);\n\tudd_set_setup_payload((uint8_t *) &ep_status_le, sizeof(ep_status_le));\n\treturn true;\n}", "CodeBleu_score": 48.99735288839913}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\n\tif (!udd_is_configured()) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update pointer of the interface descriptor\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\treturn udi_api->setup();\n}", "CodeBleu_score": 60.36340626592178}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Select first alternate setting of the interface to update udc_ptr_iface\n\t// before call iface->setup()\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Link value to payload pointer of request\n\tudd_set_setup_payload(&udc_iface_setting, 1);\n\treturn udc_ptr_conf->udi_apis[iface_num]->setup();\n}", "CodeBleu_score": 51.854843117854585}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\n\tif (!udd_is_configured()) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update pointer of the interface descriptor\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\treturn udc_ptr_conf->udi_apis[iface_num]->setup();\n}", "CodeBleu_score": 49.72003130621018}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t\t// Initialize the MSC interface\n\tudi_msc_init();\n\t// Check if there are any LUNs available\n\tif (udi_msc_nb_lun == 0) {\n\t\t// No LUNs available\n\t\treturn false;\n\t}\n\t// Unload the medium on each LUN\n\tfor (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n\t\tudi_msc_lun[i].medium_state = UDI_MSC_MEDIUM_UNLOADED;\n\t}\n\t// Wait for a Command Block Wrapper (CBW) reception\n\tudi_msc_cbw_wait();\n\treturn true;\n}", "CodeBleu_score": 35.63199748595288}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t", "CodeBleu_score": 15.883820043266303}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t// Check status of transfer\nif (UDD_EP_TRANSFER_OK!= status) {\n// Transfer aborted\n// Now wait MSC setup reset to relaunch CBW reception\nreturn;\n}\n// Check CSW integrity:\n// transfer status/CSW length/CSW signature\nif ((sizeof(udi_msc_csw)!= nb_sent)\n|| (udi_msc_csw.dCSWSignature!=\nCPU_TO_BE32(USB_CSW_SIGNATURE))) {\n// (5.2.1) Devices receiving a CSW with an invalid signature should stall\n// further traffic on the Bulk In pipe, and either stall further traffic\n// or accept and discard further traffic on the Bulk Out pipe, until\n// reset recovery.\nudi_msc_b_csw_invalid = true;\nudi_msc_csw_invalid();\nreturn;\n}\n// Update CSW residue field with the amount of data sent\nudi_msc_csw.dCSWDataResidue -= nb_sent;\n// Process updated CSW\nudi_msc_csw_process();\n}", "CodeBleu_score": 67.84089668004943}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t/*\n * Check status of transfer\n */\n  if (UDD_EP_TRANSFER_OK!= status) {\n    // Transfer aborted\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Check CSW integrity:\n  // transfer status/CSW length/CSW signature\n  if ((sizeof(udi_msc_csw)!= nb_sent)\n      || (udi_msc_csw.dCSWSignature!= CPU_TO_BE32(USB_CSW_SIGNATURE))) {\n    // (5.2.1) Devices receiving a CSW with an invalid signature should stall\n    // further traffic on the Bulk In pipe, and either stall further traffic\n    // or accept and discard further traffic on the Bulk Out pipe, until\n    // reset recovery.\n    udi_msc_b_csw_invalid = true;\n    udi_msc_csw_invalid();\n    return;\n  }\n  // Update CSW residue field with the size sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 68.62398834784116}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// If data residue is non-zero, then stall the next request\n  if (udi_msc_csw.dCSWDataResidue!= 0) {\n    // If data residue is non-zero, then stall the next request\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n      // Stall IN endpoint\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    } else {\n      // Stall OUT endpoint\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    }\n    // Wait a clear of halt\n    udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_process);\n    udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_csw_process);\n  }\n  // Prepare CSW\n  udi_msc_csw.dCSWTag = CPU_TO_LE32(udi_msc_csw.dCSWTag);\n  udi_msc_csw.dCSWDataResidue = CPU_TO_LE32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw.dCSWStatus = CPU_TO_LE32(udi_msc_csw.dCSWStatus);\n  // Send CSW\n  udi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 60.36769736642057}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check if there is a non-zero data residue\n\tif (udi_msc_csw.dCSWDataResidue!= 0) {\n\t\t// There is a non-zero data residue, then stall the next request from the USB host on the appropriate endpoint\n\t\t// based on the direction of the Command Block Wrapper (CBW)\n\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\t// CBW is IN, then stall IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\t// CBW is OUT, then stall OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\t// Prepare CSW by setting its tag and converting the data residue to little-endian format\n\tudi_msc_csw.dCSWTag = le32_to_cpu(udi_msc_cbw.dCBWTag);\n\tudi_msc_csw.dCSWDataResidue = le32_to_cpu(udi_msc_csw.dCSWDataResidue);\n\t// Send CSW\n\tudi_msc_data_send((uint8_t *) &udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 60.171850022027606}, {"code": "static void udi_msc_csw_process(void){\n\t\tif (udi_msc_csw.dCSWDataResidue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_sense_fail_phase();\n\t\t} else {\n\t\t\tudi_msc_sense_fail_phase();\n\t\t}\n\t} else {\n\t\tudi_msc_sense_pass();\n\t}\n\t// Prepare CSW\n  udi_msc_csw.dCSWTag = le32_to_cpu(udi_msc_cbw.dCBWTag);\n  udi_msc_csw.dCSWDataResidue = le32_to_cpu(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASSED;\n\n  // Send CSW\n  udi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 53.37595239593782}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t// Cancel any scheduled reset\n\t\tcancelReset();\n\t} else {\n\t\t// Schedule a reset if the DTR rate is 1200\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Schedule a reset\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 25.27530847148025}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\tmain_b_dtr_active = true;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Schedule a system reset\n\t\t\tinitiateReset();\n\t\t}\n\t} else {\n\t\tmain_b_dtr_active = false;\n\t\tif (dwDTERate == 1200) {\n\t\t\t// Cancel any pending reset\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 35.032004136510444}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\t// Update DTR status\n\tmain_b_dtr_active = b_enable;\n\t// Check if the DTR rate is 1200\n\tif (dwDTERate == 1200) {\n\t\t// If the DTR signal is disabled, schedule a system reset\n\t\tif (!b_enable) {\n\t\t\t// Reset the watchdog, just to be sure\n\t\t\tREG_WDT_CR = WDT_CR_WDRSTT | WDT_CR_KEY(0xA5);\n\t\t\t// Schedule a system reset\n\t\t\tinitiateReset();\n\t\t}\n\t\t// If the DTR signal is enabled, cancel any scheduled reset\n\t\telse {\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 55.636206184753256}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\t// Check if request is for Microsoft-compatible ID and extended properties descriptors\n\tif (udd_g_ctrlreq.req.wValue == 0x04) {\n\t\t// Link payload pointer to the Microsoft-compatible ID descriptor\n\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t// Set payload size\n\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\treturn true;\n\t}\n\tif (udd_g_ctrlreq.req.wValue == 0x05) {\n\t\t// Link payload pointer to the Microsoft-compatible extended properties descriptor\n\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t// Set payload size\n\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_extended_properties_descriptor);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 22.060977726861815}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t\tif (udd_g_ctrlreq.req.bmRequestType == USB_REQ_TYPE_VENDOR) {\n\t\tswitch (udd_g_ctrlreq.req.bRequest) {\n\t\t\tcase UDI_CDC_IAD_STRING_ID:\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(udi_cdc_name) - 1;\n\t\t\t\tudd_g_ctrlreq.payload = udi_cdc_name;\n\t\t\t\treturn true;\n\t\t\t#if HAS_MEDIA\n\t\t\tcase UDI_MSC_STRING_ID:\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(udi_msc_name) - 1;\n\t\t\t\tudd_g_ctrlreq.payload = udi_msc_name;\n\t\t\t\treturn true;\n\t\t\t#endif\n\t\t\tcase 0xEE:\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(udi_msft_magic) - 1;\n\t\t\t\tudd_g_ctrlreq.payload = udi_msft_magic;\n\t\t\t\treturn true;\n\t\t\tcase 0x04:\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t\t\treturn true;\n\t\t\tcase 0x05:\n\t\t\t\tudd_g_ctrlreq.payload_size = sizeof(microsoft_extended_properties_descriptor);\n\t\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 41.7201714392359}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) return;\n\n// write dummy byte with address and end transmission flag\nSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\nwhile (nbyte--) {\nWHILE_TX(0);\nWHILE_RX(0);\n*buf++ = SPI0->SPI_RDR;\n}\n\n// read last byte\n*buf++ = spiRec();\n}", "CodeBleu_score": 44.46415011176568}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) return;\n\n// write dummy byte with address and end transmission flag\nSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n// read bytes\nfor (uint16_t i = 0; i < nbyte; i++) {\nWHILE_TX(0);\nWHILE_RX(0);\nbuf[i] = SPI0->SPI_RDR;\n}\n\n// read last byte\nWHILE_TX(0);\nWHILE_RX(0);\nbuf[nbyte] = SPI0->SPI_RDR;\n}", "CodeBleu_score": 64.4264584485355}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\t// write dummy byte with address and end transmission flag\n\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\n\twhile (nbyte--) {\n\t\tWHILE_TX(0);\n\t\t*buf++ = SPI0->SPI_RDR;\n\t}\n\n\t// read last byte\n\t*buf = spiRec(SPI_CHAN);\n}", "CodeBleu_score": 45.55773978552185}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* table = get_relocated_table_addr();\n\n\t// Disable global interrupts to ensure atomic operation\n\tCRITICAL_SECTION_START();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = table[irq];\n\n\t// Replace the current handler with the new handler\n\ttable[irq] = newHandler;\n\n\t// Re-enable global interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 69.12946333313121}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* isrTable = get_relocated_table_addr();\n\n\t// Disable global interrupts to ensure atomic operation\n\tCRITICAL_SECTION_START();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = isrTable[irq];\n\n\t// Replace the current handler with the new handler\n\tisrTable[irq] = newHandler;\n\n\t// Re-enable global interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 69.70742060491297}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t// Get the address of the relocated interrupt vector table\npfnISR_Handler* isr_table = get_relocated_table_addr();\n\n// Get the original handler for the specified IRQ\npfnISR_Handler originalHandler = isr_table[irq];\n\n// Replace the original handler with the new handler\nisr_table[irq] = newHandler;\n\n// Return the original handler\nreturn originalHandler;\n}", "CodeBleu_score": 50.62086147381212}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (pending_char!= -1) return pending_char;\n\tif (!usb_task_cdc_isenabled()) return -1;\n\tif (!usb_task_cdc_dtr_active()) return -1;\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\treturn udi_cdc_getc();\n}", "CodeBleu_score": 44.1423134214124}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (pending_char!= -1) {\n\t\treturn pending_char;\n\t}\n\tif (usb_task_cdc_isenabled() && usb_task_cdc_dtr_active()) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\tpending_char = udi_cdc_getc();\n\t\t\treturn pending_char;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 43.55456159939143}, {"code": "int MarlinSerialUSB::peek(){\n\t\n// If a pending character exists, return it.\nif (pending_char!= -1) return pending_char;\n\n// If the USB CDC is not enabled or configured on the PC side, or if no bytes are sent from the PC, return -1.\nif (!usb_task_cdc_isenabled() ||!usb_task_cdc_dtr_active()) return -1;\n\n// If bytes are available, read the next character, process it if the emergency parser is enabled, and return the character.\nif (udi_cdc_is_rx_ready()) {\npending_char = udi_cdc_getc();\nif (EMERGENCY_PARSER_ENABLED && pending_char == 27) {\npending_char = -1;\nEMERGENCY_PARSER_ENABLED = false;\n}\nreturn pending_char;\n}\n\n// If no bytes are available, return -1.\nreturn -1;\n}", "CodeBleu_score": 55.887206814435}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0)\n\t\treturn pending_char;\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tpending_char = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n\treturn pending_char;\n}", "CodeBleu_score": 57.498363637002214}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tint c = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n\treturn c;\n}", "CodeBleu_score": 82.04364536024487}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tint c = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n\n\treturn c;\n}", "CodeBleu_score": 82.04364536024487}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (pending_char >= 0)\n\t\treturn 1;\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn 0;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn 0;\n\n\treturn 1;\n}", "CodeBleu_score": 30.08916915057386}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (pending_char >= 0)\n\t\treturn 1;\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn 0;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn 0;\n\n\treturn 1;\n}", "CodeBleu_score": 30.08916915057386}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (pending_char >= 0)\n\t\treturn 1;\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn 0;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn 0;\n\n\treturn 1;\n}", "CodeBleu_score": 30.08916915057386}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint16_t read = 0;\nwhile (size--) {\nuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\nuint8_t v = ee_Read(uint32_t(p));\nif (value) *value = v;\ncrc16(crc, &v, 1);\npos++;\nif (writing) {\nif (v!= ee_Read(uint32_t(p))) {\nSERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);\nreturn true;\n}\n}\nvalue++;\n}\nreturn false;\n}", "CodeBleu_score": 55.14079661650164}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\twhile (size--) {\nuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\nuint8_t v = ee_Read(uint32_t(p));\nif (writing) *value = v;\ncrc16(crc, &v, 1);\npos++;\nvalue++;\n}\nreturn false;\n}", "CodeBleu_score": 64.67597783973287}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint16_t read = 0;\nwhile (size--) {\nuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\nuint8_t v = ee_Read(uint32_t(p));\nif (writing) *value = v;\ncrc16(crc, &v, 1);\npos++;\nvalue++;\n}\nreturn false;\n}", "CodeBleu_score": 63.338677535088635}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t", "CodeBleu_score": 3.7373796348143205}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(invert? res - value : value, 0, res, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(invert? res - value : value, 0, res, 0, _BV(res)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 47.59150761416889}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(invert? _BV(res) - value : value, 0, _BV(res), 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(invert? _BV(res) - value : value, 0, _BV(res), 0, _BV(res)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 46.676422661028525}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\n//static_assert(sizeof(servo_delays) / sizeof(servo_delays[0]) == SERVO_CHANNELS, \"Servo delay array length mismatch\");\n\nif (channel >= 0) {\n\n// write the desired value to the servo\ndegrees = constrain(value, MIN_ANGLE, MAX_ANGLE);\nint us = map(degrees, MIN_ANGLE, MAX_ANGLE, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);\nint duty = map(us, 0, TAU_USEC, 0, MAX_COMPARE);\nledcWrite(channel, duty);\n\n// wait for the servo to move\nif (DEACTIVATE_SERVOS_AFTER_MOVE)\ndetach();\nelse\ndelay(servo_delays[channel]);\n}\n}", "CodeBleu_score": 44.65158110740466}, {"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH >= SERVO_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be >= SERVO_COUNT\");\nif (channel >= 0) {\nledcWrite(channel, value);\n#if defined(DEACTIVATE_SERVOS_AFTER_MOVE) && DEACTIVATE_SERVOS_AFTER_MOVE\ndetach();\n#endif\n}\n}", "CodeBleu_score": 39.041371172924656}, {"code": "void Servo::move(const int value){\n\t#if defined(DEACTIVATE_SERVOS_AFTER_MOVE)\n  detach();\n#endif\n#if defined(SERVO_DELAY_ARRAY_LENGTH)\n  static_assert(SERVO_DELAY_ARRAY_LENGTH > 0, \"SERVO_DELAY_ARRAY_LENGTH must be greater than zero\");\n#endif\n  if (channel >= 0) {\n    ledcWrite(channel, value);\n    delay(SERVO_DELAY_ARRAY[channel]);\n  }\n}", "CodeBleu_score": 43.99643348066217}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\nfor (uint8_t pin = 0; pin < 16; pin++) {\nif (TEST(I2S0.conf_single_data, pin)) {\nif (stepper_state[pin] == 0) {\ni2s_write(pin, 1);\nstepper_state[pin] = 1;\nstepper_tick[pin] = stepper_period[pin];\n} else {\ni2s_write(pin, 0);\nstepper_state[pin] = 0;\nstepper_tick[pin] = stepper_period[pin];\n}\n}\n}\n#endif\n\nfor (uint8_t pin = 0; pin < 16; pin++) {\nif (TEST(i2s_port_data, pin)) {\nif (stepper_state[pin] == 0) {\ni2s_write(pin, 1);\nstepper_state[pin] = 1;\nstepper_tick[pin] = stepper_period[pin];\n} else {\ni2s_write(pin, 0);\nstepper_state[pin] = 0;\nstepper_tick[pin] = stepper_period[pin];\n}\n}\n}\n}", "CodeBleu_score": 36.40222997756112}, {"code": "void i2s_push_sample(){\n\t#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (pin >= 16) {\n      SET_BIT_TO(I2S0.conf_single_data, pin, i2s_state(pin));\n      continue;\n    }\n    if (i2s_state(pin)) {\n      if (i2s_tick_count[pin] == 0) {\n        i2s_port_data[pin] =!i2s_port_data[pin];\n        i2s_tick_count[pin] = i2s_ticks[pin];\n      }\n      else {\n        i2s_tick_count[pin]--;\n      }\n    }\n  }\n#else\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (i2s_state(pin)) {\n      if (i2s_tick_count[pin] == 0) {\n        i2s_port_data[pin] =!i2s_port_data[pin];\n        i2s_tick_count[pin] = i2s_ticks[pin];\n      }\n      else {\n        i2s_tick_count[pin]--;\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 42.509960498987894}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t count;\n\ttimer_get_counter_value(timer.group, timer.idx, &count);\n\n\treturn count;\n}", "CodeBleu_score": 81.3773694972116}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n\treturn counter_value;\n}", "CodeBleu_score": 97.86105963185919}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t count_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &count_value);\n\n\treturn count_value;\n}", "CodeBleu_score": 84.17996887834805}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\nvalue[i] = HAL_eeprom_data[pos + i];\ncrc16(crc, &value[i], 1);\nif (writing)\nHAL_eeprom_data[pos + i] = value[i];\n}\npos += size;\nreturn false;\n}", "CodeBleu_score": 72.44343931442026}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\nuint8_t data = HAL_eeprom_data[pos + i];\ncrc16(crc, &data, 1);\nif (writing) value[i] = data;\n}\npos += size;\nreturn false;\n}", "CodeBleu_score": 80.70222485162985}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = HAL_eeprom_data[pos + i];\n\t\tcrc16(crc, &value[i], 1);\n\t\tif (writing) HAL_eeprom_data[pos + i] = value[i];\n\t}\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 71.65563084830437}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 73.2521382568653}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 73.2521382568653}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 73.2521382568653}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\tcase TIMER_TEMP:\n\t\ttemp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n\t\tbreak;\n\tcase TIMER_STEP:\n\t\tstep_timer.start(frequency, STEP_TIMER_PRESCALE);\n\t\tbreak;\n\tdefault:\n\t\tassert_param(0);\n\t}\n}", "CodeBleu_score": 19.128657470736066}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER) {\n\t\ttemp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n\t\tHAL_NVIC_SetPriority(TEMP_TIMER_IRQn, TEMP_TIMER_PRIORITY, 0);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tstep_timer.start(frequency, STEP_TIMER_PRESCALE);\n\t\tHAL_NVIC_SetPriority(STEP_TIMER_IRQn, STEP_TIMER_PRIORITY, 0);\n\t} else {\n\t\tHAL_assert(0);\n\t}\n}", "CodeBleu_score": 37.26339403855915}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\t\tcase TEMP_TIMER:\n\t\t\ttemp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n\t\t\tNVIC_SetPriority(TEMP_TIMER_IRQn, TEMP_TIMER_IRQ_PRIORITY);\n\t\t\tbreak;\n\t\tcase STEP_TIMER:\n\t\t\tstep_timer.start(frequency, STEP_TIMER_PRESCALE);\n\t\t\tNVIC_SetPriority(STEP_TIMER_IRQn, STEP_TIMER_IRQ_PRIORITY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert_param(false);\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 27.490635928798017}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tFILE *file = fopen(filename, \"r+b\");\n\tif (file == NULL) {\n\t\tfile = fopen(filename, \"w+b\");\n\t\tif (file == NULL) return false;\n\t\tmemset(buffer, 0xFF, MARLIN_EEPROM_SIZE);\n\t} else {\n\t\tfread(buffer, sizeof(buffer), 1, file);\n\t\tif (ferror(file)) {\n\t\t\tfclose(file);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 35.445835035929875}, {"code": "bool PersistentStore::access_start(){\n\t\tFILE* f = fopen(filename, \"rb+\");\n\tif (!f) {\n\t\tf = fopen(filename, \"wb+\");\n\t\tif (!f) return false;\n\t\tfwrite(buffer, 1, capacity(), f);\n\t\tfseek(f, 0, SEEK_SET);\n\t} else {\n\t\tfseek(f, 0, SEEK_SET);\n\t\tfread(buffer, 1, capacity(), f);\n\t}\n\tfclose(f);\n\treturn true;\n}", "CodeBleu_score": 34.13271229617708}, {"code": "bool PersistentStore::access_start(){\n\t#if EEPROM_FILE_MODE == EEPROM_FILE_MODE_READ_ONLY\n  return false;\n#endif\n#if EEPROM_FILE_MODE == EEPROM_FILE_MODE_READ_WRITE\n  if (access(filename, F_OK)!= 0) {\n    if (access(filename, W_OK)!= 0) {\n      return false;\n    }\n    FILE* f = fopen(filename, \"wb\");\n    if (f == NULL) {\n      return false;\n    }\n    for (size_t i = 0; i < capacity(); i++) {\n      fputc(EEPROM_ERASE_VALUE, f);\n    }\n    fclose(f);\n  }\n  FILE* f = fopen(filename, \"rb+\");\n  if (f == NULL) {\n    return false;\n  }\n  size_t size = fread(buffer, 1, MARLIN_EEPROM_SIZE, f);\n  if (size < MARLIN_EEPROM_SIZE) {\n    for (size_t i = size; i < MARLIN_EEPROM_SIZE; i++) {\n      buffer[i] = EEPROM_ERASE_VALUE;\n    }\n  }\n  fclose(f);\n  return true;\n#endif\n}", "CodeBleu_score": 38.69856884349431}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t data = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\tdata <<= 1;\n\t\tif (b & 0x80) {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\t} else {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, LOW);\n\t\t}\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\tb <<= 1;\n\t\tif (IN_READ(SD_MISO_PIN)) {\n\t\t\tdata |= 0x01;\n\t\t}\n\t\tdelaySPIFunc();\n\t}\n\treturn data;\n}", "CodeBleu_score": 49.621145870717555}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\tif (b & 0x80) {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\t} else {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, LOW);\n\t\t}\n\t\tb <<= 1;\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\tif (IN_READ(SD_MISO_PIN)) {\n\t\t\tr |= 0x80;\n\t\t}\n\t\tr <<= 1;\n\t}\n\tOUT_WRITE(SD_SCK_PIN, LOW);\n\treturn r;\n}", "CodeBleu_score": 44.82111062056925}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t out = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\tif (b & 0x80) {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\t} else {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, LOW);\n\t\t}\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\tout <<= 1;\n\t\tif (IN_READ(SD_MISO_PIN)) {\n\t\t\tout |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t\tdelaySPIFunc();\n\t}\n\treturn out;\n}", "CodeBleu_score": 49.28053351381503}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/ Check the parameters\n\tassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 80.19143777812154}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/ Check the parameters\n\tassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 80.19143777812154}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/ Check the parameters\n\tassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE)\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\telse\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 80.19143777812154}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif ENABLED(EMERGENCY_PARSER)\n  // If we're in emergency parser mode, call the parser with the received byte\n  if (parser_mode == EMERGENCY_PARSER) {\n    e_parser.receive_byte(obj->read());\n  }\n#endif\n\n  // Read the byte\n  uint8_t c = obj->read();\n\n  // If no error, add to buffer\n  if (obj->error() == 0) {\n    // If there is space in the buffer\n    if (_rx_buffer_tail < _rx_buffer_size) {\n      // Store the byte in the buffer\n      _rx_buffer[_rx_buffer_tail] = c;\n      // Calculate the next buffer index\n      _rx_buffer_tail = (_rx_buffer_tail + 1) % _rx_buffer_size;\n    }\n  }\n}", "CodeBleu_score": 34.15679119567061}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif ENABLED(EMERGENCY_PARSER)\n  if (EParser.enabled) {\n    EParser.rx_callback(obj);\n  }\n#endif\n#if ENABLED(SERIAL_DMA)\n  if (obj->rx_buffer_tail!= obj->rx_buffer_head) {\n    obj->rx_buffer[obj->rx_buffer_head++] = obj->read();\n    if (obj->rx_buffer_head >= SERIAL_BUFFER_SIZE) {\n      obj->rx_buffer_head = 0;\n    }\n  }\n#else\n  if (obj->rx_buffer_tail!= obj->rx_buffer_head) {\n    obj->rx_buffer[obj->rx_buffer_head++] = obj->read();\n    if (obj->rx_buffer_head >= SERIAL_BUFFER_SIZE) {\n      obj->rx_buffer_head = 0;\n    }\n  }\n#endif\n}", "CodeBleu_score": 36.28942071760066}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t// Check for error\n\tif (obj->get_error()) {\n\t\t#if ENABLED(SERIAL_DEBUG)\n\n\t\t\tSerial.print(F(\"Error: \"));\n\n\t\t\tSerial.println(obj->get_error_message());\n\n\t\t#endif\n\n\t\tobj->clear_error();\n\n\t\treturn;\n\n\t}\n\n\t// Read the byte\n\tuint8_t c = obj->getc();\n\n\t// Update the emergency parser\n\t#if ENABLED(EMERGENCY_PARSER)\n\n\t\te_parser.parse_byte(c);\n\n\t#endif\n\n\n\t// Store the byte in the receive buffer\n\tif (c!= 0) {\n\t\t// Update the receive buffer\n\t\t_rx_buffer[_rx_buffer_head] = c;\n\n\t\t_rx_buffer_head = (_rx_buffer_head + 1) % _rx_buffer_size;\n\n\n\t\t// Update the receive buffer counter\n\t\t_rx_buffer_count++;\n\n\t}\n\n}", "CodeBleu_score": 33.31230715580406}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (HAL_timer_initialized(timer_num)) {\nif (!HAL_timer_has_interrupt(timer_num)) {\nswitch (timer_num) {\ncase MF_TIMER_STEP:\nattachInterrupt(digitalPinToInterrupt(STEPPER_TIMER_PIN), Step_Handler, RISING);\nbreak;\ncase MF_TIMER_TEMP:\nattachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\nbreak;\n}\n}\n}\n}", "CodeBleu_score": 49.766732830825845}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (HAL_timer_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\nswitch (timer_num) {\ncase MF_TIMER_STEP:\nattachInterrupt(STEP_TIMER, Step_Handler, RISING);\nbreak;\ncase MF_TIMER_TEMP:\nattachInterrupt(TEMP_TIMER, Temp_Handler, RISING);\nbreak;\n}\n}\n}", "CodeBleu_score": 49.632950384745655}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t", "CodeBleu_score": 2.7080419141460643}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 56.2897686230429}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 56.2897686230429}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 56.2897686230429}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t// disable interrupts\n\tinterrupt.Disable()\n\n\t// check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// send data to USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// no data in buffer\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// restore interrupts\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// Disable interrupts\n\tinterrupt.Disable()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// Send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data, so set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.87745586516516}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// disable interrupts\n\tinterrupt.Disable()\n\t// check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t\t// set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t} else {\n\t\t// set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 47.53473571798941}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\tClear the interrupt flag to start the transmission.\n\ti2c.crReg.Set(i2c.crINT)\n\ti2c.crReg.Set(i2c.crSTA)\n\ti2c.crReg.Set(i2c.crEN)\n\n\t// Wait for the start condition to be transmitted.\n\tfor i2c.crReg.Get()&i2c.crINT == 0 {\n\t}\n\n\t// Write the address to the bus.\n\ti2c.writeByte(address | (uint8(write) << 7))\n}", "CodeBleu_score": 38.27292458182373}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\tClear interrupt flag\n\ti2c.crReg.ClearBits(i2c.crINT)\n\n\t// Put a start condition on the SDA line\n\ti2c.crReg.SetBits(i2c.crSTA)\n\n\t// Wait for the start condition to be transmitted\n\tfor i2c.crReg.GetBits(i2c.crINT) == 0 {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus\n\ti2c.writeByte(address | write)\n}", "CodeBleu_score": 36.85907791156287}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t.crReg.ClearBits(i2c.crINT)\n\ti2c.crReg.SetBits(i2c.crSTA)\n\tfor i2c.crReg.Load()&i2c.crSTA!= 0 {\n\t}\n\ti2c.writeByte(address | uint8(write))\n}", "CodeBleu_score": 36.12072213593691}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errFlashNegativeSize\n\t}\n\tif FlashDataStart()+uintptr(start)*eraseBlockSize() > FlashDataEnd() {\n\t\treturn errFlashCannotWritePastEOF\n\t}\n\tif FlashDataStart()+uintptr(start+len)*eraseBlockSize() > FlashDataEnd() {\n\t\treturn errFlashCannotWritePastEOF\n\t}\n\n\taddress := FlashDataStart() + uintptr(start)*eraseBlockSize()\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor j := int64(0); j < len; j++ {\n\t\t// erase block\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0xFFFFFFFF\n\t\taddress += eraseBlockSize()\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.978935714568095}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errFlashInvalidEraseRange\n\t}\n\n\tif FlashDataStart()+uintptr(start)*eraseBlockSize() > FlashDataEnd() {\n\t\treturn errFlashCannotErasePastEOF\n\t}\n\n\tstartAddress := FlashDataStart() + uintptr(start)*eraseBlockSize()\n\tendAddress := startAddress + uintptr(len)*eraseBlockSize()\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor address := startAddress; address < endAddress; address += eraseBlockSize() {\n\t\t// erase block\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0xFFFFFFFF\n\t\twaitWhileFlashBusy()\n\t}\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 50.2524368290047}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start > f.Size() || len < 0 || start+len > f.Size() {\n\t\treturn errFlashInvalidEraseRange\n\t}\n\n\twaitWhileFlashBusy()\n\n\t// calculate start address\n\taddress := FlashDataStart() + uintptr(start)*eraseBlockSize()\n\n\t// set flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\t// erase blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// erase block\n\t\t*(*uint32)(unsafe.Pointer(address)) = 0xFFFFFFFF\n\t\taddress += uintptr(eraseBlockSize())\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.800518637611}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tstartAddr := FlashDataStart() + uintptr(off)\n\tpad := make([]byte, flashBlockSize-((len(p) % flashBlockSize)))\n\tfor i := 0; i < len(pad); i++ {\n\t\tpad[i] = 0xFF\n\t}\n\tp = append(p, pad...)\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Wen << nrf.NVMC_CONFIG_WEN_Pos)\n\tfor i := 0; i < len(p); i += flashBlockSize {\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddr + uintptr(i))\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\t\tnrf.NVMC.ERASEPAGE.Set(0)\n\t\tnrf.NVMC.WRITE_WORD.Set(uint32(binary.LittleEndian.Uint64(p[i:i+8])))\n\t\tfor nrf.NVMC.READY.Get() == 0 {\n\t\t}\n\t\tnrf.NVMC.WRITE_WORD.Set(0)\n\t}\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren << nrf.NVMC_CONFIG_WEN_Pos)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 44.7384281982455}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tstart := FlashDataStart() + uintptr(off)\n\tdata := make([]byte, flashBlockSize)\n\tcopy(data, p)\n\tfor len(data) > 0 {\n\t\tn := len(data)\n\t\tif n > flashBlockSize {\n\t\t\tn = flashBlockSize\n\t\t}\n\n\t\tnrf.FLASH.TASKS_WRITE.Set(1)\n\t\tnrf.FLASH.ADDR.Set(start)\n\t\tnrf.FLASH.DATA.Set(uint32(data[0]) | uint32(data[1])<<8 | uint32(data[2])<<16 | uint32(data[3])<<24)\n\t\tnrf.FLASH.TASKS_ERASEPAGE.Set(1)\n\t\tfor nrf.FLASH.EVENTS_END.Get() == 0 {\n\t\t}\n\t\tnrf.FLASH.EVENTS_END.Set(0)\n\t\tnrf.FLASH.EVENTS_WRITE.Set(0)\n\t\tstart += flashBlockSize\n\t\tdata = data[n:]\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 41.570585515031254}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tstart := FlashDataStart() + uintptr(off)\n\tpad := (flashBlockSize - (start % flashBlockSize)) % flashBlockSize\n\tpadded := make([]byte, len(p)+pad)\n\tcopy(padded, p)\n\tfor i := 0; i < pad; i++ {\n\t\tpadded[len(p)+i] = 0xFF\n\t}\n\n\tnrf.FLASH.TASKS_WRITE.Set(1)\n\tfor i := 0; i < len(padded); i += flashBlockSize {\n\t\tnrf.FLASH.ADDR.Set(start + uintptr(i))\n\t\tnrf.FLASH.DATA.Set(uint32(binary.LittleEndian.Uint64(padded[i:i+8])))\n\t\tfor nrf.FLASH.EVENTS_END.Get() == 0 {\n\t\t}\n\t\tnrf.FLASH.EVENTS_END.Set(0)\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 44.68644652475684}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tDarwin has a limit on the number of open files.\n\t// If we get an error, try again until we get a file descriptor\n\t// that is not in use.\n\tfor {\n\t\tnewFd, errno := syscall.Dup(int(fd))\n\t\tif errno == nil {\n\t\t\tdir, errno := syscall.Fdopendir(newFd)\n\t\t\tif errno == nil {\n\t\t\t\treturn dir, \"opendir\", nil\n\t\t\t}\n\t\t\t// If the error is not EINTR, return it.\n\t\t\tif errno!= syscall.EINTR {\n\t\t\t\treturn 0, \"opendir\", errno\n\t\t\t}\n\t\t}\n\t\t// Close the duplicate file descriptor.\n\t\tif err := syscall.Close(newFd); err!= nil {\n\t\t\treturn 0, \"close\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 50.79901113921643}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tDuplicate the file descriptor.\n\tdupfd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"dup\", err\n\t}\n\t// Attempt to open the directory.\n\tdir, errno := syscall.Fdopendir(dupfd)\n\tif errno!= nil {\n\t\t// If the error is not EINTR, close the duplicated file descriptor and return the error.\n\t\tif errno!= syscall.EINTR {\n\t\t\tsyscall.Close(dupfd)\n\t\t\treturn 0, \"opendir\", errno\n\t\t}\n\t\t// Otherwise, close the duplicated file descriptor and try again.\n\t\tsyscall.Close(dupfd)\n\t}\n\treturn dir, \"opendir\", nil\n}", "CodeBleu_score": 53.382089703726976}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t, errno := syscall.Fdopendir(int(fd))\n\tif errno!= nil {\n\t\tif errno == syscall.EINTR {\n\t\t\tdir, errno = darwinOpenDir(fd)\n\t\t}\n\t\treturn 0, \\\"opendir\\\", errno\n\t}\n\treturn uintptr(dir), \\\"opendir\\\", nil\n}", "CodeBleu_score": 33.05500778691942}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n\tif (it == NULL) {\n\t\treturn 0;\n\t}\n\tesp_partition_t *part = esp_partition_get(it);\n\tif (part == NULL) {\n\t\treturn 0;\n\t}\n\tesp_partition_read(part, 0, part, sizeof(esp_partition_t));\n\tesp_image_metadata_t *metadata = (esp_image_metadata_t *)part->data;\n\tif (response == sketchSize_t::FREE) {\n\t\treturn part->size - metadata->header_size - metadata->code_size;\n\t} else {\n\t\treturn part->size;\n\t}\n}", "CodeBleu_score": 42.2933125073589}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t#if CONFIG_IDF_TARGET_ESP32C6 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32 || CONFIG_IDF_TARGET_ESP32H2\n  uint32_t sketch_size = 0;\n  esp_partition_t *running = esp_ota_get_running_partition();\n  esp_app_desc_t running_app;\n  esp_partition_get_description(running, &running_app);\n  if (response == sketchSize_t::sketchSize_t_free) {\n    sketch_size = running_app.app_size - running_app.offset;\n  } else {\n    sketch_size = running_app.app_size;\n  }\n  return sketch_size;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 43.65697059777175}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t", "CodeBleu_score": 2.073033576343574}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % DISK_SECTOR_SIZE) {\n\t\tlog_e(\"Offset not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, offset, DISK_SECTOR_SIZE)!= ESP_OK) {\n\t\tlog_e(\"Failed to erase sector at offset %u\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 48.65965671453106}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tuint32_t sector_size = esp_partition_get_page_size(partition);\n\tuint32_t sector_offset = offset % sector_size;\n\tuint32_t sector_start = offset - sector_offset;\n\tuint32_t sector_end = sector_start + size;\n\tuint32_t sector_count = (sector_end + sector_size - 1) / sector_size;\n\tif (sector_offset == 0) {\n\t\tfor (uint32_t i = 0; i < sector_count; i++) {\n\t\t\tif ((err = esp_partition_erase_range(partition, sector_start, sector_size))!= ESP_OK) {\n\t\t\t\tlog_e(\"Failed to erase partition: %d\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif ((err = esp_partition_write(partition, sector_start, data, size))!= ESP_OK) {\n\t\t\t\tlog_e(\"Failed to write partition: %d\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tsector_start += sector_size;\n\t\t\tdata = (uint8_t *)data + size;\n\t\t}\n\t} else {\n\t\tif ((err = esp_partition_erase_range(partition, sector_start, sector_size))!= ESP_OK) {\n\t\t\tlog_e(\"Failed to erase partition: %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\tif ((err = esp_partition_write(partition, sector_start, data, size))!= ESP_OK) {\n\t\t\tlog_e(\"Failed to write partition: %d\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}", "CodeBleu_score": 47.218881096708174}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tuint32_t aligned_offset = offset & ~(FLASH_SECTOR_SIZE - 1);\n\tsize_t aligned_size = size & ~(FLASH_SECTOR_SIZE - 1);\n\tesp_err_t err = ESP_OK;\n\tif (aligned_offset!= offset) {\n\t\terr = esp_partition_erase_range(partition, aligned_offset, FLASH_SECTOR_SIZE);\n\t\tif (err!= ESP_OK) {\n\t\t\tlog_e(\"Failed to erase partition: %s\", esp_err_to_name(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, aligned_offset, data, aligned_size);\n\tif (err!= ESP_OK) {\n\t\tlog_e(\"Failed to write partition: %s\", esp_err_to_name(err));\n\t}\n\treturn err;\n}", "CodeBleu_score": 53.86490132609926}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tif (len % 2!= 0)\n\t\treturn 0;\n\tsize_t count = len / 2;\n\tif (count > maxlen)\n\t\treturn 0;\n\tfor (size_t i = 0; i < count; i++) {\n\t\tuint8_t b = hex_char_to_byte(in[i * 2]) * 16 + hex_char_to_byte(in[i * 2 + 1]);\n\t\tout[i] = b;\n\t}\n\treturn count;\n}", "CodeBleu_score": 36.30276696834059}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t outlen = 0;\n\tfor (size_t i = 0; i < strlen(in); i += 2) {\n\t\tuint8_t high = hex_char_to_byte(in[i]);\n\t\tuint8_t low = hex_char_to_byte(in[i + 1]);\n\t\tif (high < 0x10 || low < 0x10) {\n\t\t\tbreak;\n\t\t}\n\t\tout[outlen++] = (high << 4) | low;\n\t\tif (outlen >= maxlen) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 38.11223955056474}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (i < len && j < maxlen) {\n\t\tunsigned char c1 = hex_char_to_byte(in[i++]);\n\t\tunsigned char c2 = hex_char_to_byte(in[i++]);\n\t\tif (c1 < 0x10 || c2 < 0x10) {\n\t\t\tout[j++] = (c1 << 4) | c2;\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 33.017924242056964}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (!tx_ring_buf ||!tx_lock) {\nreturn 0;\n}\nif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS)!= pdTRUE) {\nreturn 0;\n}\nsize_t free_size = xRingbufferGetFreeSpace(tx_ring_buf);\nxSemaphoreGive(tx_lock);\nreturn free_size;\n}", "CodeBleu_score": 69.20927557200449}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buf == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS)!= pdTRUE) {\n\t\treturn 0;\n\t}\n\tsize_t free_size = xRingbufferGetFreeSpace(tx_ring_buf);\n\txSemaphoreGive(tx_lock);\n\treturn free_size;\n}", "CodeBleu_score": 86.11331009951664}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!tx_ring_buf) {\n\t\treturn 0;\n\t}\n\tif (!tx_lock) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS)!= pdTRUE) {\n\t\treturn 0;\n\t}\n\tsize_t free_size = xRingbufferGetFreeSpace(tx_ring_buf);\n\txSemaphoreGive(tx_lock);\n\treturn free_size;\n}", "CodeBleu_score": 68.74877456018716}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tX_LOCK();\n// function may be NULL to cancel onReceive() from its respective task\n_onReceiveCB = function;\n// this can be called after Serial.begin(), therefore it shall create the event task\nif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n_createEventTask(this);\n}\n_onReceiveTimeout = onlyOnTimeout;\n_rxTimeout = 2;\nHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 34.41060542221764}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tX_LOCK();\n// function may be NULL to cancel onReceive() from its respective task\n_onReceiveCB = function;\n// this can be called after Serial.begin(), therefore it shall create the event task\nif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n_createEventTask(this);\n}\n// set the receive timeout behavior\n_onReceiveTimeout = onlyOnTimeout;\n_rxTimeout = 2;\nHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 34.41060542221764}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tX_LOCK();\n// function may be NULL to cancel onReceive() from its respective task\n_onReceiveCB = function;\n// this can be called after Serial.begin(), therefore it shall create the event task\nif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n_createEventTask(this);\n}\n// set receive timeout\n_onReceiveTimeout = onlyOnTimeout;\n_rxTimeout = 2;\nHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 34.41060542221764}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tsize_t count = 0;\nwhile (count < length) {\nint c = timedRead();\nif (c < 0) {\nbreak;\n}\nif (c == terminator) {\nbreak;\n}\n*buffer++ = (char)c;\ncount++;\n}\nreturn count;\n}", "CodeBleu_score": 61.37998997603673}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tsize_t count = 0;\nwhile (count < length) {\nint c = timedRead();\nif (c < 0) {\nbreak;\n}\nif (c == terminator) {\nbreak;\n}\n*buffer++ = (char)c;\ncount++;\n}\nreturn count;\n}", "CodeBleu_score": 61.37998997603673}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tsize_t count = 0;\n\nwhile (count < length) {\nint c = timedRead();\nif (c < 0) {\nbreak;\n}\nif (c == terminator) {\nbreak;\n}\n*buffer++ = (char)c;\ncount++;\n}\nreturn count;\n}", "CodeBleu_score": 61.37998997603673}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (tone_init()) {\n\t\ttone_msg_t tone_msg = {\n\t\t\t.tone_cmd = TONE_START,\n\t\t\t.pin = pin,\n\t\t\t.frequency = frequency,\n\t\t\t.duration = duration\n\t\t};\n\t\txQueueReset(_tone_queue);  // clear queue\n\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t} else {\n\t\tlog_e(\"Tone is already running on given pin %d\", pin);\n\t}\n}", "CodeBleu_score": 54.20531056812553}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (tone_init()) {\n\t\ttone_msg_t tone_msg = {\n\t\t\t\t.tone_cmd = TONE_START,\n\t\t\t\t.pin = pin,\n\t\t\t\t.frequency = frequency,\n\t\t\t\t.duration = duration,\n\t\t};\n\t\txQueueReset(_tone_queue); // clear queue\n\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t} else {\n\t\tlog_e(\"Tone is not running on given pin %d\", pin);\n\t}\n}", "CodeBleu_score": 55.02993798843239}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (_pin == -1) {\n\t\tif (tone_init()) {\n\t\t\ttone_msg_t tone_msg = {\n\t\t\t\t\t.tone_cmd = TONE_START,\n\t\t\t\t\t.pin = pin,\n\t\t\t\t\t.frequency = frequency,\n\t\t\t\t\t.duration = duration,\n\t\t\t};\n\t\t\txQueueReset(_tone_queue); // clear queue\n\t\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t\t}\n\t} else {\n\t\tlog_e(\"Tone is already running on pin %d\", pin);\n\t}\n}", "CodeBleu_score": 58.43449842795706}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CFG_TUD_WEBUSB\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = 0x0210;\n    }\n  }\n  return!_started;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 63.504013632038706}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_started) {\nwebusb_enabled = enabled;\nif (enabled) {\nusb_version = (usb_version & 0xFF00) | 0x0210;\n}\n}\nreturn!_started;\n}", "CodeBleu_score": 65.00930333070318}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CFG_TUD_WEBUSB\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      usb_version = usb_version < 0x0210? 0x0210 : usb_version;\n    }\n  }\n  return!_started;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 64.17514714429554}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t ch;\n\twhile (USB_CDC_Read(&ch, 1)) {\n\t\tif (!xQueueSend(rx_queue, &ch, 0)) {\n\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\tp.rx_overflow.dropped_bytes = 1;\n\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 25.220895219921104}, {"code": "void USBCDC::_onRX(){\n\tuint8_t ch = 0;\nif (xQueueReceive(rx_queue, &ch, 0)) {\nif (!xQueueSend(rx_queue, &ch, 0)) {\narduino_usb_cdc_event_data_t p;\np.rx_overflow.dropped_bytes = 1;\narduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\nlog_e(\"CDC RX Overflow.\");\n}\n}\n}", "CodeBleu_score": 27.084848065231625}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t ch = 0;\n\twhile (xQueueReceive(rx_queue, &ch, 0)) {\n\t\tif (!xQueueSend(rx_queue, &ch, 0)) {\n\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\tp.rx_overflow.dropped_bytes = uxQueueSpacesAvailable(rx_queue) + uxQueueMessagesWaiting(rx_queue);\n\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 29.679124285306624}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\\\":robot\\\")).\n\t\tDevice(req.URL.Query().Get(\\\":device\\\")).(gobot.Commander).\n\t\tCommand(req.URL.Query().Get(\\\":command\\\")),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 31.076033971332805}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\\\":robot\\\")).\n\t\tDevice(req.URL.Query().Get(\\\":device\\\")).\n\t\tCommand(req.URL.Query().Get(\\\":command\\\")),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 29.537041897711937}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.executeCommand(a.master.Robot(req.URL.Query().Get(\\\":robot\\\")).Device(req.URL.Query().Get(\\\":device\\\")).(gobot.Commander).Command(req.URL.Query().Get(\\\":command\\\")),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 30.749564866251767}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the authorization header from the request\n\t\tauthorization := r.Header.Get(\"Authorization\")\n\n\t\t// Decode the base64-encoded authorization header\n\t\tdecoded, err := base64.StdEncoding.DecodeString(authorization)\n\t\tif err!= nil {\n\t\t\t// If the decoding fails, respond with an error message and a \"401 Unauthorized\" status\n\t\t\thttp.Error(w, \"Authorization header is not valid base64\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the authorization header into a username and password\n\t\tparts := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(parts)!= 2 {\n\t\t\t// If the authorization header is not in the expected format, respond with an error message and a \"401 Unauthorized\" status\n\t\t\thttp.Error(w, \"Authorization header is not in the expected format\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password from the authorization header with the provided credentials\n\t\tif subtle.ConstantTimeCompare([]byte(parts[0]), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(parts[1]), []byte(password))!= 1 {\n\t\t\t// If the comparison fails, respond with an error message and a \"401 Unauthorized\" status\n\t\t\thttp.Error(w, \"Authorization header is not valid\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the comparison succeeds, proceed to the next handler\n\t\t//...\n\t}\n}", "CodeBleu_score": 47.80057571110246}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tauth = strings.TrimPrefix(auth, \"Basic \")\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(decoded), \":\", 2)\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tr.Header.Del(\"Authorization\")\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.78109313059268}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\\\"Authorization\\\")\n\t\tif authHeader == \\\"\\\" {\n\t\t\tw.Header().Set(\\\"WWW-Authenticate\\\", \\\"Basic realm=\\\\\\\"My Realm\\\\\\\"\\\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\\\"No Authorization header provided.\\\"))\n\t\t\treturn\n\t\t}\n\t\tauth, err := base64.StdEncoding.DecodeString(authHeader[6:])\n\t\tif err!= nil {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\\\"Invalid Authorization header.\\\"))\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare(auth, []byte(username+\\\":\\\"+password))!= 1 {\n\t\t\tw.Header().Set(\\\"WWW-Authenticate\\\", \\\"Basic realm=\\\\\\\"My Realm\\\\\\\"\\\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\\\"Invalid username or password.\\\"))\n\t\t\treturn\n\t\t}\n\t\t// Authentication successful. Proceed to the next handler.\n\t}\n}", "CodeBleu_score": 44.492726821831646}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.driver.SupportsAnalogRead() {\n\t\treturn -1, -1, errors.New(a.driver.Name() + \" does not support analog read\")\n\t}\n\trawValue, err := a.driver.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 46.29575472256152}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.driver.Connected() {\n\t\treturn -1, -1, errors.New(a.driverCfg.name + \" is not connected\")\n\t}\n\n\tif!a.driver.SupportsAnalogRead() {\n\t\treturn -1, -1, errors.New(a.driverCfg.name + \" does not support analog reading\")\n\t}\n\n\trawValue, err := a.driver.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 48.496614724959265}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.driver.SupportsAnalog() {\n\t\treturn -1, -1, errors.New(\\\"Analog sensor does not support analog read\\\")\n\t}\n\n\trawValue, err := a.driver.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\treturn rawValue, a.lastValue, nil\n}", "CodeBleu_score": 49.25426439301718}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 66.51736880538208}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 87.40223700581173}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\td.AddEvent(Sound)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n\t\t\td.Publish(d.Event(Sound), data)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 66.51736880538208}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, commandRegSoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tif err := d.readByteData(regCommand); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.29797422248707}, {"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, cmdSoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tif err := d.readByteData(regCommand); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.97477148277546}, {"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, cmdSoftReset); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(initTime)\n\n\tif err := d.checkStatus(); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.58100647867731}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// read the FIFO buffer and check the number of bytes in it\n\tfifoLength, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif uint(len(backData))!= fifoLength {\n\t\treturn 0, fmt.Errorf(\\\"backData length not equal to FIFO length %d - %d\\\", uint(len(backData)), fifoLength)\n\t}\n\n\t// read the data from the FIFO buffer into the provided byte slice\n\tfor i := 0; i < int(fifoLength); i++ {\n\t\tb, err := d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\n\t// read the control register to get the last bits received\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 61.78596176397224}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// read the number of bytes in the FIFO buffer\n\tfifoLength, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif len(backData)!= int(fifoLength) {\n\t\treturn 0, fmt.Errorf(\\\"backData length %d does not match FIFO length %d\\\", len(backData), fifoLength)\n\t}\n\n\t// read the data from the FIFO buffer\n\tfor i := 0; i < int(fifoLength); i++ {\n\t\tbackData[i], err = d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// read the last bits received from the FIFO\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 52.96274811997201}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// read the number of bytes in the FIFO\n\tfifoLength, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif len(backData)!= int(fifoLength) {\n\t\treturn 0, fmt.Errorf(\\\"the length of the provided data (%d) does not match the length of the FIFO (%d)\\\", len(backData), fifoLength)\n\t}\n\t// read the data from the FIFO\n\tfor i := 0; i < fifoLength; i++ {\n\t\tb, err := d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\t// read the last bits received from the FIFO\n\tlastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 54.422834699150755}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\thaltCmd := []byte{piccCommandHalt, 0x00, 0x00}\n\thaltCmd = append(haltCmd, crc(haltCmd)...)\n\tif err := d.writeByteData(regCommand, piccCommandHalt); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regFIFOData, haltCmd); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regCommand, piccCommandIdle); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.071691498318536}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\n\thaltCommand := []byte{piccCommandHalt}\n\tif err := d.writeByteData(regBitFramingReg, 0x00); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regTxMode, 0x00); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regRxMode, 0x00); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regBitRateReg, 0x00); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := d.writeData(regCommandReg, haltCommand); err!= nil {\n\t\treturn err\n\t}\n\n\t// wait for the PICC to be in state IDLE\n\tif err := d.waitForPiccState(piccStateIdle, 1000); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.41709762413274}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"Halt command\\\")\n\t}\n\thaltCommand := []byte{piccCommandHaltA, 0x00}\n\n\tcrc, err := d.calculateCRC(haltCommand)\n\tif err!= nil {\n\n\t\treturn err\n\n\t}\n\n\thaltCommand = append(haltCommand, crc[0], crc[1])\n\n\tif err := d.writeByteData(regBitFraming, 0x80); err!= nil {\n\n\t\treturn err\n\n\t}\n\n\tif err := d.writeByteData(regCommand, piccCommandHaltA); err!= nil {\n\n\t\treturn err\n\n\t}\n\n\treturn d.waitForReady()\n}", "CodeBleu_score": 49.54773260822872}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\t// The data to be sent to the MFRC522 to execute a READ command via the FIFO.\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\t// Create a buffer to store the response data\n\tbackData := make([]byte, 18)\n\t// The last bits of the received data frame.\n\ttxLastBits := uint8(0x00)\n\t// Calculate and append the CRC_A value to the end of the data to be sent to the MFRC522.\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\t// Transmit the data to the MFRC522 and receive the response.\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\t// Remove the CRC_A and CRC_B values from the end of the data.\n\tbackData = backData[:len(backData)-2]\n\treturn backData, nil\n}", "CodeBleu_score": 76.56811564222023}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t", "CodeBleu_score": 3.9226551888190304}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\t// The \"read\" command requires a command-specific 4-byte block address.\n\t// The address is in little-endian format, meaning the most-significant\n\t// byte is the first byte sent, and the least-significant byte is the last\n\t// byte sent.\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify CRC_A.\n\t// The data in the buffer (backData) is not automatically removed from the buffer.\n\tif err := d.verifyCRC(backData, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 76.66437243958872}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\n\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err!= nil {\n\t\treturn err\n\t}\n\n\t// prepare the command\n\tvar command []byte\n\tswitch reqMode {\n\tcase piccCommandReqModeIdle:\n\t\tcommand = []byte{piccCommandReqModeIdle}\n\tcase piccCommandReqModeWakeUp:\n\t\tcommand = []byte{piccCommandReqModeWakeUp}\n\tcase piccCommandReqModeAntiColl:\n\t\tcommand = []byte{piccCommandReqModeAntiColl}\n\tcase piccCommandReqModeSelect:\n\t\tcommand = []byte{piccCommandReqModeSelect}\n\tcase piccCommandReqModeSelectH:\n\t\tcommand = []byte{piccCommandReqModeSelectH}\n\tcase piccCommandReqModeAnticollH:\n\t\tcommand = []byte{piccCommandReqModeAnticollH}\n\tcase piccCommandReqModeHalt:\n\t\tcommand = []byte{piccCommandReqModeHalt}\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown request mode %d\", reqMode)\n\t}\n\n\t// transmit the command\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tif reqMode == piccCommandReqModeSelect || reqMode == piccCommandReqModeSelectH {\n\t\ttxLastBits = uint8(0x03) // we use 3 bits of the last byte\n\t}\n\tif err := d.communicateWithPICC(commandRegTransceive, command, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.00959975518558}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\\\"answer buffer too small for request, need at least 2 bytes\\\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err!= nil {\n\t\treturn err\n\t}\n\tvar txLastBits uint8\n\tswitch reqMode {\n\tcase piccCommandReqMode1, piccCommandReqMode2:\n\t\ttxLastBits = uint8(0x07)\n\tcase piccCommandReqMode3:\n\t\ttxLastBits = uint8(0x04)\n\tdefault:\n\t\treturn fmt.Errorf(\\\"unknown request mode %d\\\", reqMode)\n\t}\n\tsendCommand := []byte{reqMode}\n\tif err := d.communicateWithPICC(commandRegTransceive, sendCommand, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 61.87432867627837}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regBitFraming, bitFramingRegReset); err!= nil {\n\t\treturn err\n\t}\n\tvar txLastBits uint8\n\tif reqMode == piccCommandReqMode1 {\n\t\ttxLastBits = uint8(0x07)\n\t} else if reqMode == piccCommandReqMode2 {\n\t\ttxLastBits = uint8(0x08)\n\t} else {\n\t\ttxLastBits = uint8(0x00)\n\t}\n\ttxData := []byte{piccCommandReqMode1, reqMode}\n\tif err := d.communicateWithPICC(commandRegTransceive, txData, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 62.72435568782764}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.disabled {\n\t\treturn nil\n\t}\n\n\tif d.sleeping {\n\t\treturn fmt.Errorf(\\\"%s is sleeping\\\", d.driverCfg.name)\n\t}\n\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.driverCfg.delay)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 73.10558713401286}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.disabled {\n\t\treturn nil\n\t}\n\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\t// wait for a short time\n\ttime.Sleep(d.delay)\n\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\t// increment or decrement the step number based on the direction\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 72.84529104261169}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.disabled {\n\t\treturn fmt.Errorf(\\\"%s is disabled\\\", d.driverCfg.name)\n\t}\n\n\t// set the step pin low\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\t// wait for the step delay\n\ttime.Sleep(d.stepDelay)\n\n\t// set the step pin high\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\t// increment or decrement the step number depending on the direction\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 70.77962236002222}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo d.startDistanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 36.46068108173134}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo d.distanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 36.227250376570275}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopWaitGroup!= nil {\n\t\treturn errors.New(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\terr := d.measureDistance()\n\t\t\tif err!= nil {\n\t\t\t\tfmt.Printf(\\\"error on measure distance: %v\n\\\", err)\n\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 51.68192757509882}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := int64(0)\n\treturn func(pinID int, duration time.Duration, name string, pin uint32, edge uint32) {\n\t\tswitch edge {\n\t\tcase gobot.EdgeRising:\n\t\t\tstartTimestamp = time.Now().UnixNano()\n\t\tcase gobot.EdgeFalling:\n\t\t\td.delayMicroSecChan <- time.Now().UnixNano() - startTimestamp\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 47.34770184485648}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\t// init a variable to track the start timestamp of the pulse\n\tvar startTs time.Time\n\n\treturn func(pinID int, ts time.Duration, name string, pin uint32, value uint32) {\n\t\t// when a rising edge event is detected, it records the timestamp\n\t\tif value == 1 {\n\t\t\tstartTs = time.Now()\n\t\t} else { // when a falling edge event is detected, it calculates the duration of the pulse, sends this duration to a channel, and resets the start timestamp\n\t\t\td.delayMicroSecChan <- int64(ts.Nanoseconds() / 1000)\n\t\t\tstartTs = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.288228679197076}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, name string, pinNum uint32, event uint32) {\n\t\tif event == gobot.EdgeRising {\n\t\t\tstart = time.Now()\n\t\t} else if event == gobot.EdgeFalling {\n\t\t\td.delayMicroSecChan <- int64(duration.Microseconds())\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.35145428800574}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\tif err := d.triggerPin.Write(gobot.HIGH); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulseDuration)\n\tif err := d.triggerPin.Write(gobot.LOW); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin: %v\", err)\n\t}\n\n\t// wait for echo pin to trigger\n\tselect {\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\"timeout on waiting for echo pin to trigger\")\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.547165433204086}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\tif err := d.triggerPin.Write(gobot.HIGH); err!= nil {\n\t\treturn fmt.Errorf(\\\"error on trigger pin write: %v\\\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerDelay)\n\tif err := d.triggerPin.Write(gobot.LOW); err!= nil {\n\t\treturn fmt.Errorf(\\\"error on trigger pin write: %v\\\", err)\n\t}\n\n\t// wait for the echo\n\tselect {\n\tcase delay := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delay\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\\\"timeout on waiting for echo pin\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.11231157580619}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// lock the mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor by setting the trigger pin high\n\tif err := d.triggerPin.DigitalWrite(1); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\t// wait for the sensor to start measuring\n\t// TODO: use a timeout\n\ttime.Sleep(hcsr04TriggerPulseDuration)\n\n\t// stop the trigger pin by setting it low\n\tif err := d.triggerPin.DigitalWrite(0); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\t// wait for the sensor to complete the measurement\n\tselect {\n\tcase delayMicroSec := <-d.delayMicroSecChan:\n\t\td.lastMeasureMicroSec = delayMicroSec\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\"timeout on measurement\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.957361352115115}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        token = os.environ[\\\"PLATFORMIO_ACCOUNT_TOKEN\\\"]\n    except KeyError:\n        account = app.get_state_item(\\\"account\\\")\n        if not account:\n            raise AccountNotAuthorized()\n        try:\n            token = account[\\\"auth\\\"][\\\"access_token\\\"]\n        except KeyError:\n            raise AccountNotAuthorized()\n        try:\n            expires_in = account[\\\"auth\\\"][\\\"expires_in\\\"]\n        except KeyError:\n            raise AccountNotAuthorized()\n        if time.time() > expires_in:\n            if \\\"refresh_token\\\" not in account[\\\"auth\\\"]:\n                raise AccountNotAuthorized()\n            try:\n                token = self.refresh_authentication_token(account[\\\"auth\\\"][\\\"refresh_token\\\"])\n            except AccountError:\n                raise AccountNotAuthorized()\n            account[\\\"auth\\\"][\\\"access_token\\\"] = token\n            account[\\\"auth\\\"][\\\"expires_in\\\"] = time.time() + expires_in\n            app.set_state_item(\\\"account\\\", account)\n    return token\n\n\n\n", "CodeBleu_score": 34.1837771176115}, {"code": "def fetch_authentication_token(self)\n\t\n    # pylint: disable=too-many-branches\n    try:\n        return os.environ[\\\"PLATFORMIO_AUTH_TOKEN\\\"]\n    except KeyError:\n        account = app.get_state_item(\\\"account\\\")\n        if account and \\\"auth\\\" in account:\n            if \\\"access_token\\\" in account[\\\"auth\\\"]:\n                if account[\\\"auth\\\"][\\\"access_token\\\"]:\n                    if \\\"expires_in\\\" in account[\\\"auth\\\"]:\n                        expires_in = account[\\\"auth\\\"][\\\"expires_in\\\"]\n                        if time.time() + 60 < expires_in:\n                            return account[\\\"auth\\\"][\\\"access_token\\\"]\n                        if \\\"refresh_token\\\" in account[\\\"auth\\\"]:\n                            self.fetch_authentication_token_with_refresh_token()\n                            return account[\\\"auth\\\"][\\\"access_token\\\"]\n        raise AccountNotAuthorized()\n\n    def fetch_authentication_token_with_refresh_token(self):\n        account = app.get_state_item(\\\"account\\\")\n        if account and \\\"auth\\\" in account:\n            if \\\"refresh_token\\\" in account[\\\"auth\\\"]:\n                response = self.fetch_json_data(\n                    \\\"/oauth/token\\\",\n                    method=\\\"POST\\\",\n                    data={\n                        \\\"grant_type\\\": \\\"refresh_token\\\",\n                        \\\"refresh_token\\\": account[\\\"auth\\\"][\\\"refresh_token\\\"]\n                    }\n                )\n                if \\\"access_token\\\" in response:\n                    account[\\\"auth\\\"][\\\"access_token\\\"] = response[\\\"access_token\\\"]\n                    account[\\\"auth\\\"][\\\"expires_in\\\"] = response[\\\"expires_in\\\"]\n                    app.set_state_item(\\\"account\\\", account)\n\n    def get_summary(self):\n        if not self._summary_cache or time.time() > self._summary_cache[\\\"expires_in\\\"]:\n            self._summary_cache = self.fetch_json_data(\\\"/summary\\\")\n            self._summary_cache[\\\"expires_in\\\"] = time.time() + self.SUMMARY_CACHE_TTL\n        return self._summary_cache\n\n    def get_user(self):\n        return self.fetch_json_data(\\\"/user\\\")", "CodeBleu_score": 30.656632135076677}, {"code": "def fetch_authentication_token(self)\n\t\n    if \"ACCOUNT_TOKEN\" in os.environ:\n        return os.environ[\\\"ACCOUNT_TOKEN\\\"]\n    account = app.get_state_item(\\\"account\\\")\n    if account and \\\"auth\\\" in account and \\\"access_token\\\" in account[\\\"auth\\\"]:\n        if time.time() < account[\\\"auth\\\"][\\\"expires_at\\\"]:\n            return account[\\\"auth\\\"][\\\"access_token\\\"]\n    if account and \\\"auth\\\" in account and \\\"refresh_token\\\" in account[\\\"auth\\\"]:\n        try:\n            self.fetch_authentication_token_by_refresh_token(account[\\\"auth\\\"][\\\"refresh_token\\\"])\n            return account[\\\"auth\\\"][\\\"access_token\\\"]\n        except AccountNotAuthorized:\n            pass\n    raise AccountNotAuthorized()\n", "CodeBleu_score": 26.54840337789428}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.fetch_authentication_token()\n    except AccountNotAuthorized:\n        return\n    self.delete_local_session()\n    self.fetch_json_data(\n        \"post\",\n        \"/v1/logout\",\n        headers={\n            \"Authorization\": \"Bearer %s\" % refresh_token,\n        },\n    )\n    return True\n\n", "CodeBleu_score": 48.8943778943633}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.fetch_authentication_token()\n    except AccountNotAuthorized:\n        return True\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 65.469128357786}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \\\"post\\\",\n            \\\"/v1/logout\\\",\n            headers={\n                \\\"Authorization\\\": \\\"Bearer %s\\\" % refresh_token\n            },\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.06269797135606}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        versions = [options.get(\"version\")]\n        if options.get(\"optionalVersions\"):\n            versions.extend(options.get(\"optionalVersions\"))\n        for version in versions:\n            if not version:\n                continue\n            pkg = self.get_package(name, self.get_package_spec(name, version))\n            if pkg:\n                result.append(pkg)\n    return result\n\n", "CodeBleu_score": 47.945502333873314}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        versions = [options.get(\"version\")]\n        versions.extend(options.get(\"optionalVersions\", []))\n        for version in versions:\n            if not version:\n                continue\n            pkg = self.get_package(name, self.get_package_spec(name, version))\n            if pkg:\n                result.append(pkg)\n    return result\n\n", "CodeBleu_score": 49.14208230385354}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for name, options in sorted(self.packages.items()):\n        if options.get(\"optional\"):\n            continue\n        versions = [options.get(\"version\")]\n        if options.get(\"optionalVersions\"):\n            versions.extend(options.get(\"optionalVersions\"))\n        for version in versions:\n            if not version:\n                continue\n            pkg = self.get_package(name, self.get_package_spec(name, version))\n            if pkg:\n                packages.append((pkg, version))\n    return packages\n\n", "CodeBleu_score": 40.411823999957974}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    # pylint: disable=import-outside-toplevel\n    from platformio.package.manager.platform import PlatformPackageManager\n    from platformio.project.config import ProjectConfig\n    from platformio.project.exception import UndefinedEnvPlatformError\n\n    project_config = ProjectConfig.get_instance()\n    platform_spec = project_config.get_platform_spec(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    return cls.new(platform_spec, autoinstall=autoinstall).configure(env, targets)\n\n", "CodeBleu_score": 40.31603830354455}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env or not isinstance(env, str):\n        raise TypeError(\\\"The \\\"env\\\" argument must be a string. Received: %s\\\" % type(env))\n\n    project_config = ProjectConfig()\n    platform_spec = project_config.get_env_platform(env, targets)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n\n    return cls.new(platform_spec, autoinstall)\n\n    @classmethod\n    def get_platform_names(cls):\n        return [cls.get_clsname(p) for p in cls.get_platform_names_static()]\n\n    @classmethod\n    def get_platform_names_static(cls):\n        return [p.metadata.name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static(cls):\n        return [p.metadata.pretty_name for p in PlatformPackageManager().get_installed()]\n\n    @classmethod\n    def get_platform_names_pretty_static", "CodeBleu_score": 33.43112673507267}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    # pylint: disable=import-outside-toplevel\n    from platformio.package.manager.platform import PlatformPackageManager\n\n    platform_spec = ProjectConfig().get(\\\"env\\\", env, \\\"platform\\\")\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n\n    platform_dir = None\n    if isinstance(platform_spec, PackageItem):\n        platform_dir = platform_spec.path\n    elif isinstance(platform_spec, (str, bytes)) and os.path.isdir(platform_spec):\n        platform_dir = platform_spec\n    else:\n        pkg = PlatformPackageManager().get_package(platform_spec)\n        if pkg:\n            platform_dir = pkg.path\n\n    if not platform_dir or not os.path.isfile(\n        os.path.join(platform_dir, \\\"platform.json\\\")\n    ):\n        if autoinstall:\n            return cls.from_env(\n                env,\n                PlatformPackageManager().install(\n                    platform_spec, skip_dependencies=True\n                )\n            )\n        raise UnknownPlatform(platform_spec)\n\n    if not targets:\n        targets = ProjectConfig().get(\\\"env\\\", env, \\\"targets\\\")\n\n    _instance = cls.new(platform_spec, autoinstall=autoinstall)\n    _instance.set_env(env)\n    _instance.configure_package_deps(targets)\n    return _instance\n\n", "CodeBleu_score": 35.48550831135102}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tif (time_in_us == 0) {\n\t\tSetSleep();\n\t\tWire1.beginTransmission(0x34);\n\t\tWire1.write(0x45);\n\t\tWire1.endTransmission();\n\t\tWire1.requestFrom(0x34, 1);\n\t\tuint8_t buf = Wire1.read();\n\t\tbuf |= 0x01;\n\t\tWire1.beginTransmission(0x34);\n\t\tWire1.write(0x45);\n\t\tWire1.write(buf);\n\t\tWire1.endTransmission();\n\t} else {\n\t\tSetSleep();\n\t\tWire1.beginTransmission(0x34);\n\t\tWire1.write(0x45);\n\t\tWire1.endTransmission();\n\t\tWire1.requestFrom(0x34, 1);\n\t\tuint8_t buf = Wire1.read();\n\t\tbuf &= 0xFE;\n\t\tWire1.beginTransmission(0x34);\n\t\tWire1.write(0x45);\n\t\tWire1.write(buf);\n\t\tWire1.endTransmission();\n\t\tWire1.beginTransmission(0x34);\n\t\tWire1.write(0x46);\n\t\tWire1.write(time_in_us & 0xff);\n\t\tWire1.write((time_in_us >> 8) & 0xff);\n\t\tWire1.write((time_in_us >> 16) & 0xff);\n\t\tWire1.write((time_in_us >> 24) & 0xff);\n\t\tWire1.endTransmission();\n\t}\n}", "CodeBleu_score": 44.06263238532739}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef SCREEN_BUFFER\n  if (this->screen_buffer->size() >= MAX_SCREEN_BUFFER)\n    this->scrollScreenBuffer();\n#endif\n\n  if (yDraw >= yArea) {\n    yDraw = yStart;\n  }\n\n  tft.fillRect(0, yDraw, TFT_WIDTH, TEXT_HEIGHT, color);\n  yDraw += TEXT_HEIGHT;\n\n  return yDraw;\n}", "CodeBleu_score": 14.403606408875103}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifndef SCREEN_BUFFER\n  //Serial.println(F(\\\"scroll_line()\\\"));\n\n  // Save current y-coordinate\n  int y = yDraw;\n\n  // Fill rectangle with color\n  tft.fillRect(0, y, TFT_WIDTH, TEXT_HEIGHT, color);\n\n  // Increment y-coordinate and wrap around if necessary\n  if ((y + TEXT_HEIGHT) > yArea) {\n    if (!tteBar) {\n      yDraw = TOP_FIXED_AREA;\n    } else {\n      yDraw = TOP_FIXED_AREA_2;\n    }\n  } else {\n    yDraw += TEXT_HEIGHT;\n  }\n\n  // Update scroll address\n  scroll_address = yDraw;\n\n  // Return previous y-coordinate\n  return y;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 25.120008894024537}, {"code": "int Display::scroll_line(uint32_t color){\n\t", "CodeBleu_score": 1.6688059799790205}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->setup();\n\n\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\tif (!this->setupHTML(ssids)) {\n\t\treturn false;\n\t}\n\n\tthis->start();\n\n\treturn true;\n}", "CodeBleu_score": 57.014390880989374}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (this->has_ap) {\n\t\treturn false;\n\t}\n\n\tthis->has_ap = true;\n\n\tthis->ap_ssid = ssids;\n\tthis->ap_access_points = access_points;\n\n\tthis->setup();\n\n\treturn this->runServer;\n}", "CodeBleu_score": 50.40753420612278}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setup_ap(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\tif (!this->setup_html()) {\n\t\treturn false;\n\t}\n\n\tthis->setup();\n\treturn true;\n}", "CodeBleu_score": 64.20963363442706}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (!this->queue)\n\t\t\tthis->new_queue();\n\t\tif (!this->text)\n\t\t\tthis->text = new LinkedList<String>;\n\t\tif (!this->text_in)\n\t\t\tthis->text_in = new LinkedList<String>;\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 46.16952169934724}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue) {\n\t\t\tif (this->text) {\n\t\t\t\tif (this->text_in) {\n\t\t\t\t\tthis->text_cycles = 0;\n\t\t\t\t\tthis->text_in = new LinkedList<String>();\n\t\t\t\t} else\n\t\t\t\t\tthis->text_in = new LinkedList<String>();\n\t\t\t} else {\n\t\t\t\tthis->text_cycles = 0;\n\t\t\t\tthis->text = new LinkedList<String>();\n\t\t\t\tthis->text_in = new LinkedList<String>();\n\t\t\t}\n\t\t} else\n\t\t\tthis->new_queue();\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 29.171187807842202}, {"code": "void GpsInterface::enable_queue(){\n\t\tif(this->queue_enabled_flag)\n\t\tif(this->queue)\n\t\t\tif(this->text)\n\t\t\t\tif(this->text_in)\n\t\t\t\t\treturn;\n\n\tthis->flush_queue();\n\tthis->queue_enabled_flag=true;\n}", "CodeBleu_score": 18.354580387626278}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tif (this->queue->size()) {\n\t\t\tLinkedList<nmea_sentence_t> *new_queue = new LinkedList<nmea_sentence_t>;\n\t\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\t\tthis->queue = new_queue;\n\t\t\tdelete delme;\n\t\t}\n\t} else\n\t\tthis->new_queue();\n}", "CodeBleu_score": 70.68857513050182}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tif (this->queue->size()) {\n\t\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n\t\t\tdelete delme;\n\t\t}\n\t} else\n\t\tthis->new_queue();\n}", "CodeBleu_score": 73.69328572633252}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tif (this->queue->size()) {\n\t\t\tthis->new_queue();\n\t\t\tthis->queue->clear();\n\t\t}\n\t} else\n\t\tthis->new_queue();\n}", "CodeBleu_score": 32.97502743701165}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tifdef HAS_ILI9341\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2 - area->x1 + 1, area->y2 - area->y1 + 1);\n    for (int16_t x = area->x1; x <= area->x2; x++) {\n      for (int16_t y = area->y1; y <= area->y2; y++) {\n        display_obj.tft.writeColor(color_p->full);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n#endif\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 71.73033797729859}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t#ifdef DEBUG\n  Serial.println(\\\"showMenuList\\\");\n#endif\n  display_obj.tft.setCursor(0, 0);\n  display_obj.tft.setTextColor(TFT_WHITE, TFT_BLACK);\n  display_obj.tft.setTextSize(2);\n  display_obj.tft.setTextWrap(false);\n\n  int y = 0;\n  int x = 0;\n  int indent = 0;\n  int line_length = 0;\n\n  // Iterate through all menu nodes\n  for (int i = 0; i < menu->list->length; i++) {\n    // Get the current menu node\n    MenuNode * node = menu->list->get(i);\n\n    // Get the node's indentation level based on the layer level\n    indent = layer * INDENT_WIDTH;\n\n    // Get the line length with indentation\n    line_length = indent + strlen(node->name);\n\n    // If the line length exceeds the screen width, break the line\n    if (line_length > SCREEN_WIDTH) {\n      display_obj.tft.println();\n      y += TEXT_HEIGHT;\n      x = 0;\n      indent = layer * INDENT_WIDTH;\n      line_length = indent + strlen(node->name);\n    }\n\n    // Print the node name with indentation\n    display_obj.tft.setCursor(x, y);\n    display_obj.tft.print(String(indent, DEC) + \\\" \\\");\n    display_obj.tft.print(node->name);\n\n    // Update the cursor position\n    x += line_length;\n  }\n\n  // Print an empty line at the end of the menu list\n  display_obj.tft.println();\n  y += TEXT_HEIGHT;\n  x = 0;\n}", "CodeBleu_score": 44.43890441548886}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tdisplay_obj.tft.setCursor(0, 0);\n\tdisplay_obj.tft.setTextColor(TFT_WHITE, TFT_BLACK);\n\tdisplay_obj.tft.setTextSize(1);\n\tdisplay_obj.tft.setTextWrap(false);\n\n\t// Iterate through all menu nodes and print each node's name with indentation proportional to the layer level\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tMenuNode * node = menu->list->get(i);\n\n\t\t// Print the node name with indentation based on the layer level\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tdisplay_obj.tft.print(\\\" \\\");\n\t\t}\n\t\tdisplay_obj.tft.println(node->name);\n\n\t\t// Recursively call showMenuList() on the node's submenu if it exists\n\t\tif (node->subMenu!= NULL) {\n\t\t\tshowMenuList(node->subMenu, layer + 1);\n\t\t}\n\t}\n\n\t// Print an empty line after listing all nodes\n\tdisplay_obj.tft.println();\n}", "CodeBleu_score": 49.999444899385516}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tMenuNode * node = menu->list->get(i);\n\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tdisplay_obj.tft.print(\\\"    \\\");\n\t\t}\n\n\t\tdisplay_obj.tft.println(node->name);\n\t}\n\n\tdisplay_obj.tft.println();\n}", "CodeBleu_score": 55.784930716089065}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num_generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString essid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tint random_char = random(97, 123);\n\t\t\tchar c = (char) random_char;\n\t\t\tessid += c;\n\t\t}\n\t\tthis->addSSID(essid);\n\t\tnum_generated++;\n\t}\n\treturn num_generated;\n}", "CodeBleu_score": 36.99208840996885}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num_added = 0;\n\twhile (num_added < count) {\n\t\tString essid = \"\";\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tchar c = random(97, 122);\n\t\t\tessid.concat((char) c);\n\t\t}\n\t\tif (this->addSSID(essid))\n\t\t\tnum_added++;\n\t}\n\treturn num_added;\n}", "CodeBleu_score": 33.06937606237886}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num_generated = 0;\n\twhile (num_generated < count) {\n\t\tString essid = \"\";\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tchar c = random(97, 123);\n\t\t\tessid += c;\n\t\t}\n\t\tnum_generated += addSSID(essid);\n\t}\n\treturn num_generated;\n}", "CodeBleu_score": 31.010451224525255}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n", "CodeBleu_score": 53.58447548238634}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n", "CodeBleu_score": 53.58447548238634}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n", "CodeBleu_score": 53.58447548238634}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \\\"iat\\\": datetime.datetime.utcnow(),\n        \\\"exp\\\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        \\\"aud\\\": project_id\n    }\n    with open(private_key_file, \\\"r\\\") as f:\n        private_key = str(f.read())\n    return jwt.encode(token, private_key, algorithm=algorithm).decode(\\\"UTF-8\\\")\n", "CodeBleu_score": 39.90222313543054}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\\\"iat\\\": datetime.datetime.utcnow(),", "CodeBleu_score": 8.577384979900904}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\\\"iat\\\": datetime.datetime.utcnow(),\n            \\\"exp\\\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n            \\\"aud\\\": project_id}\n    with open(private_key_file, \\\"r\\\") as f:\n        private_key = json.load(f)\n    print(\\\"Creating JWT using {} from private key file {}\\\".format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 51.025904548052104}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        # Capture image\n        cap = cv2.VideoCapture(0)\n        ret, frame = cap.read()\n        cv2.imwrite('image.jpg', frame)\n        cap.release()\n        # Upload image to GCS\n        storage_client = storage.Client()\n        bucket = storage_client.get_bucket('bucket-name')\n        blob = bucket.blob('image.jpg')\n        blob.upload_from_filename('image.jpg')\n        # Publish URL to MQTT\n        url = 'https://storage.googleapis.com/bucket-name/image.jpg'\n        publish_messages('project-id', 'topic-name', url)\n    else:\n        print('off')\n", "CodeBleu_score": 47.16121923885517}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        print('Capturing preview image...')\n        preview_image_file = capture_preview_image()\n        print('Uploading preview image to bucket...')\n        upload_file_to_bucket(preview_image_file)\n        print('Publishing preview image URL to event topic...')\n        publish_messages(PROJECT_ID, TOPIC_NAME, preview_image_url)\n    elif message.payload == b'off':\n        print('Preview image is not being captured.')\n    else:\n        print('Unexpected payload received.')\n\n", "CodeBleu_score": 36.04925741080553}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        print('Capturing image...')\n        os.system('fswebcam -r 1280x720 --no-banner --no-timestamp -D 1 /home/pi/image.jpg')\n        print('Uploading image...')\n        upload_blob(bucket_name, image_name, '/home/pi/image.jpg')\n        print('Publishing image URL...')\n        publish_messages(project_id, topic_name, image_url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 31.639420487595675}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Connect to a Google Cloud IoT Core MQTT device.')\n    parser.add_argument('--project_id', help='Project ID of the Google Cloud IoT Core registry.', required=False)\n    parser.add_argument('--registry_id', help='ID of the Google Cloud IoT Core registry.', required=True)\n    parser.add_argument('--device_id', help='ID of the Google Cloud IoT Core device.', required=True)\n    parser.add_argument('--private_key_file', help='Path to private key file.', required=True)\n    parser.add_argument('--algorithm', help='Name of the private key file.', required=False, default='RS256')\n    parser.add_argument('--ca_certs', help='Path to CA certs.', required=False, default='roots.pem')\n    parser.add_argument('--cloud_region', help='GCP cloud region.', required=False, default='us-central1')\n    parser.add_argument('--registry_id', help='ID of the Google Cloud IoT Core registry.', required=True)\n    parser.add_argument('--device_id', help='ID of the Google Cloud IoT Core device.', required=True)\n    parser.add_argument('--num_messages', help='Number of messages to publish.', required=False, default=10)\n    parser.add_argument('--interval', help='Interval (seconds) between publishing messages.', required=False, default=1)\n    parser.add_argument('--message_type', help='Type of message to publish.', required=False, default='event')\n    parser.add_argument('--message_field', help='Field to publish.', required=False, default='temperature')\n    parser.add_argument('--message_data', help='Data to publish.', required=False, default='0')\n    parser.add_argument('--message_data_type', help='Data type to publish.', required=False, default='string')\n    parser.add_argument('--message_qos', help='QOS to publish.', required=False, default=0)\n    parser.add_argument('--message_retain', help='Retain flag to publish.', required=False, default=False)\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname.', required=False, default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt", "CodeBleu_score": 27.634432979677104}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Connect to Google Cloud IoT Core using MQTT and subscribe to a subscription.\")\n    parser.add_argument(\"--project_id\", help=\"GCP project ID\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--region\", help=\"GCP region\", default=\"us-central1\")\n    parser.add_argument(\"--registry_id\", help=\"GCP registry ID\", default=\"my-registry\")\n    parser.add_argument(\"--device_id\", help=\"GCP device ID\", default=\"my-device\")\n    parser.add_argument(\"--private_key_file\", help=\"Path to private key file\", default=\"private_key.pem\")\n    parser.add_argument(\"--algorithm\", help=\"Signing algorithm (RS256)\", default=\"RS256\")\n    parser.add_argument(\"--ca_certs\", help=\"Path to CA root certificate\", default=\"ca_certs.pem\")\n    parser.add_argument(\"--cloud_region\", help=\"GCP cloud region\", default=\"us-central1\")\n    parser.add_argument(\"--registry_id\", help=\"GCP registry ID\", default=\"my-registry\")\n    parser.add_argument(\"--device_id\", help=\"GCP device ID\", default=\"my-device\")\n    parser.add_argument(\"--num_messages\", help=\"Number of messages to publish\", default=10)\n    parser.add_argument(\"--qos\", help=\"QoS level\", default=1)\n    parser.add_argument(\"--message_type\", help=\"Type of message\", default=\"event\")\n    parser.add_argument(\"--message_format\", help=\"Format of message\", default=\"json\")\n    parser.add_argument(\"--message_payload\", help=\"Message payload\", default=\"Hello, world!\")\n    parser.add_argument(\"--num_messages\", help=\"Number of messages to publish\", default=10)\n    parser.add_argument(\"--qos\", help=\"QoS level\", default=1)\n    parser.add_argument(\"--message_type\", help=\"Type of message\", default=\"event\")\n    parser.add_argument(\"--message_format\", help=\"Format of message\", default=\"json\")\n    parser.add_argument(\"--message_payload\", help=\"Message payload\", default=\"Hello, world!\")\n    parser.add_argument(\"--num_messages\", help=\"Number of messages to publish\", default=10)\n   ", "CodeBleu_score": 31.031936403774253}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Connect to a Google Cloud IoT MQTT device and subscribe to a subscription.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project ID\",\n    )\n    parser.add_argument(\n        \"--region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--registry_id\", help=\"GCP cloud IoT registry ID\", required=True\n    )\n    parser.add_argument(\n        \"--device_id\", help=\"GCP cloud IoT device ID\", required=True\n    )\n    parser.add_argument(\n        \"--private_key_file\", help=\"Path to private key file.\", required=True\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=[\"RS256\", \"ES256\"],\n        default=\"RS256\",\n        help=\"Which cryptographic algorithm to use for authentication and encryption.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\", help=\"Path to root CA certs\", default=\"/tmp/roots.pem\"\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        choices=[\"us-central1\", \"europe-west1\"],\n        default=\"us-central1\",\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=0,\n        help=\"Number of messages to publish. If 0, publish forever.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=[\"event\", \"state\"],\n        default=\"event\",\n        help=\"Type of message to publish.\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=0,\n        help=\"Number of messages to publish. If 0, publish forever.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=[\"event\", \"state\"],\n        default=\"event\",\n        help=\"Type of message to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        help=\"MQTT bridge hostname\",\n        default=\"mqtt.googleapis.com\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"", "CodeBleu_score": 37.0324114591084}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    return discovery.build(\"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 19.270001169178737}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    return discovery.build(\"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 21.364493672196268}, {"code": "def get_client(service_account_json)\n\t\n    # The scopes required by the Google Cloud IoT Core API.\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    # The version of the Google Cloud IoT Core API to use.\n    API_VERSION = 'v1'\n    # The discovery URL for the Google Cloud IoT Core API.\n    DISCOVERY_URL = 'https://cloudiot.googleapis.com/$discovery/rest'\n    # The path to the service account JSON file.\n    service_account_json = service_account_json\n    # The service account credentials.\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=SCOPES)\n    # The client for the Google Cloud IoT Core API.\n    client = discovery.build(\n        'cloudiot',\n        API_VERSION,\n        credentials=credentials,\n        discoveryServiceUrl=DISCOVERY_URL)\n    return client\n\n", "CodeBleu_score": 21.358797646121946}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = get_asn1_hash_method(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError('Invalid hash method')\n    hash_value_asn1 = hash_method_asn1 + hash_value\n    padded_hash_value_asn1 = _pad_for_signing(hash_value_asn1, 128)\n    encrypted_hash_value_asn1 = encrypt(padded_hash_value_asn1, priv_key)\n    return encrypted_hash_value_asn1\n\n", "CodeBleu_score": 25.883259366204946}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"sha256\":\n        hash_method = \"1.2.840.113549.2.7\"\n    elif hash_method == \"sha384\":\n        hash_method = \"1.3.14.3.2.26\"\n    elif hash_method == \"sha512\":\n        hash_method = \"1.3.14.3.2.27\"\n    else:\n        raise ValueError(\"Invalid hash method.\")\n    asn1_hash_method = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    asn1_hash_method += hash_method\n    hash_value_with_asn1 = asn1_hash_method + hash_value\n    padded_hash_value = _pad_for_signing(hash_value_with_asn1, 128)\n    encrypted_hash_value = encrypt(padded_hash_value, priv_key)\n    return encrypted_hash_value\n\n", "CodeBleu_score": 22.90131304890276}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"SHA1\":\n        hash_method = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"SHA224\":\n        hash_method = b\"\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c\"\n    elif hash_method == \"SHA256\":\n        hash_method = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA384\":\n        hash_method = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA512\":\n        hash_method = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method.\")\n    return encrypt(hash_method + hash_value, priv_key)\n\n", "CodeBleu_score": 12.12569905965113}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    keylength = common.byte_size(pub_key.n)\n    signature = transform.bytes2int(signature)\n    decrypted = pub_key.blinded_decrypt(signature)\n    cleartext = transform.int2bytes(decrypted, keylength)\n\n    if cleartext[0:2]!= b'\\x00\\x02':\n        raise VerificationError('Verification failed')\n\n    try:\n        sep_idx = cleartext.index(b'\\x00', 2)\n    except ValueError:\n        raise VerificationError('Verification failed')\n\n    asn1code = cleartext[0:sep_idx]\n    hash_method = HASH_NAMES[asn1code]\n    msg_hash = compute_hash(message, hash_method)\n    expected_hash = _pad_for_signing(asn1code + msg_hash, keylength)\n\n    if cleartext[sep_idx + 1:]!= expected_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 42.10870336632546}, {"code": "def verify(message, signature, pub_key)\n\t\n    keylength = common.byte_size(pub_key.n)\n    block = transform.bytes2int(signature)\n    decrypted = pub_key.blinded_decrypt(block)\n    cleartext = transform.int2bytes(decrypted, keylength)\n    if cleartext[0:2]!= b'\\x00\\x02':\n        raise VerificationError('Verification failed')\n    try:\n        sep_idx = cleartext.index(b'\\x00', 2)\n    except ValueError:\n        raise VerificationError('Verification failed')\n    asn1code = cleartext[0:sep_idx]\n    hash_method = HASH_NAME[asn1code]\n    msg_hash = compute_hash(message, hash_method)\n    expected_hash = _pad_for_verification(asn1code, keylength)\n    if expected_hash!= msg_hash:\n        raise VerificationError('Verification failed')\n    return hash_method\n\n", "CodeBleu_score": 43.189847429360434}, {"code": "def verify(message, signature, pub_key)\n\t\n    keylength = common.byte_size(pub_key.n)\n    block = transform.bytes2int(signature)\n    decrypted = pub_key.blinded_decrypt(block)\n    cleartext = transform.int2bytes(decrypted, keylength)\n\n    # If we can't find the cleartext marker, decryption failed.\n    if cleartext[0:2]!= b'\\x00\\x02':\n        raise VerificationError('Verification failed')\n\n    # Find the 00 separator between the padding and the message\n    try:\n        sep_idx = cleartext.index(b'\\x00', 2)\n    except ValueError:\n        raise VerificationError('Verification failed')\n\n    # Extract the ASN.1 code for the hash method\n    asn1code = cleartext[2:sep_idx]\n\n    # Find the start of the hash\n    hash_start = sep_idx + 1\n\n    # Get the hash method name\n    hash_method = HASH_ASN1_REVERSE[asn1code]\n\n    # Get the expected hash\n    expected_hash = cleartext[hash_start:]\n\n    # Compute the actual hash\n    actual_hash = compute_hash(message, hash_method)\n\n    # Compare the expected and actual hashes\n    if expected_hash!= actual_hash:\n        raise VerificationError('Verification failed')\n\n    # Return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 42.67252445666978}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch;\n\tepoch = time(NULL) + UNIX_OFFSET;\n\tupdateJWT(epoch);\n\tif (connectMQTTSocket() == 0) {\n\t\tdebug_printError(\"CLOUD: MQTT connection established\n\");\n\t\twaitingForMQTT = false;\n\t\tsendSubscribe = true;\n\t} else {\n\t\tdebug_printError(\"CLOUD: MQTT connection failed\n\");\n\t\twaitingForMQTT = true;\n\t}\n}", "CodeBleu_score": 51.40304070617899}, {"code": "static void connectMQTT(){\n\t\t// Get the current time in seconds since the UNIX epoch\n\ttime_t current_time = time(NULL);\n\t// Check if the time is valid\n\tif (current_time!= -1) {\n\t\t// Update the JWT using the current UNIX time format\n\t\tupdateJWT(current_time);\n\t}\n\n\t// Connect to the MQTT client\n\tint8_t ret = connectMQTTSocket();\n\n\t// Check if the connection was successful\n\tif (ret == M2M_SUCCESS) {\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tsendSubscribe = true;\n\t} else {\n\t\t// Print a debug message indicating the MQTT connection attempt failed\n\t\tdebug_printError(\"CLOUD: MQTT connection failed\");\n\t}\n}", "CodeBleu_score": 58.19659841362835}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch;\n\tepoch = time(NULL);\n\tif (epoch == 0) {\n\t\tdebug_printError(\"CLOUD: Time is not valid\n\");\n\t\treturn;\n\t}\n\tupdateJWT(epoch);\n\tif (connectMQTTSocket() == SOCK_OK) {\n\t\tsendSubscribe = true;\n\t\tdebug_printError(\"CLOUD: MQTT Connection Established\n\");\n\t} else {\n\t\tdebug_printError(\"CLOUD: MQTT Connection Failed\n\");\n\t}\n}", "CodeBleu_score": 50.57879353371444}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t val = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = *(str++);\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = val * 10 + (c - '0');\n\t}\n\t*num = val;\n\treturn str;\n}", "CodeBleu_score": 25.48263255480642}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t digit = *(str++);\n\t\tif (digit >= '0' && digit <= '9') {\n\t\t\tresult = result * 10 + (digit - '0');\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t*num = result;\n\treturn str;\n}", "CodeBleu_score": 22.229449397366395}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + (*str - '0');\n\t\tstr++;\n\t}\n\t*num = result;\n\treturn str;\n}", "CodeBleu_score": 28.93392692968443}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tlist == NULL)\n\t\treturn false;\n\tif (*list == NULL)\n\t\treturn false;\n\tif (timer == NULL)\n\t\treturn false;\n\tif ((*list) == timer) {\n\t\t*list = timer->next;\n\t\treturn true;\n\t}\n\ttimerStruct_t *temp = *list;\n\twhile (temp->next!= NULL) {\n\t\tif (temp->next == timer) {\n\t\t\ttemp->next = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.6504297087544}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tStruct_t *volatile *volatile listPtr = list;\ntimerStruct_t *volatile *volatile timerPtr = &timer;\n\nwhile (*listPtr!= NULL) {\nif (*timerPtr == *listPtr) {\n*listPtr = (*timerPtr)->next;\nreturn true;\n}\nlistPtr = &(*listPtr)->next;\n}\nreturn false;\n}", "CodeBleu_score": 17.245442761113456}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tist == NULL || timer == NULL)\nreturn false;\ntimerStruct_t * volatile *point = list;\nwhile (*point!= NULL)\n{\nif (*point == timer)\n{\n*point = timer->next;\nreturn true;\n}\npoint = &(*point)->next;\n}\nreturn false;\n}", "CodeBleu_score": 20.70565752310398}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint returnValue = BSD_ERROR;\n\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (!bsdSocket) {\n\t\tdebug_printError(\"BSD: close error unknown socket number\");\n\t} else {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t\treturnValue = close(socket);\n\t\tif (returnValue < 0) {\n\t\t\tdebug_printError(\"BSD: close error %d\", returnValue);\n\t\t\tswitch (returnValue) {\n\t\t\tcase EBADF:\n\t\t\t\tbsd_setErrNo(EBADF);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\tbreak;\n\t\t\tcase EIO:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printGOOD(\"BSD: socket (%d) closed\", socket);\n\t\t\treturnValue = BSD_SUCCESS;\n\t\t}\n\t}\n\treturn returnValue;\n}", "CodeBleu_score": 54.96017497498873}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = SOCKET_NOT_A_SOCKET;\n\t}\n\n\tif (close(socket) < 0) {\n\t\tswitch (errno) {\n\t\tcase EBADF:\n\t\t\tbsd_setErrNo(EBADF);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbsd_setErrNo(EACCES);\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 51.16266846828702}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif (bsdSocket) {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t\tif (close(socket) < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tbsd_setErrNo(EBADF);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase EIO:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbsd_setErrNo(EACCES);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn BSD_ERROR;\n\t\t} else {\n\t\t\treturn BSD_SUCCESS;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 56.64280678364961}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 78.92056359289724}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\twincListenReturn = listen((int8_t)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else if (backlog < 0) {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 69.26447897785228}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d, %d)\n\", socket, backlog);\n\twincListenReturn = listen((int8_t) socket, (uint8_t) backlog);\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 76.57054632913345}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\twincSupported_sockaddr winc_sockaddr;\n\n\tif (addr!= NULL) {\n\t\twinc_sockaddr.sa_family = addr->sa_family;\n\t\tmemcpy((void*) winc_sockaddr.sa_data, (const void *) addr->sa_data,\n\t\t\t\tsizeof(winc_sockaddr.sa_data));\n\n\t\tswitch (winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET) socket, (struct sockaddr*) &winc_sockaddr,\n\t\t\t\t\t(uint8_t*) addrlen);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\n\t\tif (wincAcceptReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\t\tswitch (wincAcceptReturn) {\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t} else if (addr!= NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t} else if (addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn BSD_ERROR;\n\t\t} else {\n\t\t\treturn BSD_SUCCESS;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 74.9686791392225}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\twincSupported_sockaddr winc_sockaddr;\n\n\tif (addr!= NULL) {\n\t\twinc_sockaddr.sa_family = addr->sa_family;\n\t\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data,\n\t\t\t\tsizeof(winc_sockaddr.sa_data));\n\t}\n\n\tswitch (winc_sockaddr.sa_family) {\n\tcase PF_INET:\n\t\twinc_sockaddr.sa_family = AF_INET;\n\t\twincAcceptReturn = accept((SOCKET) socket,\n\t\t\t\t(struct sockaddr *) &winc_sockaddr, (uint8_t *) addrlen);\n\t\tbreak;\n\tdefault:\n\t\t// Address family not supported by WINC\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincAcceptReturn) {\n\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 83.25975944017163}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch (winc_sockaddr.sa_family) {\n\tcase PF_INET:\n\t\twinc_sockaddr.sa_family = AF_INET;\n\t\twincAcceptReturn = accept((SOCKET) socket, (struct sockaddr*) &winc_sockaddr, (uint8_t*) addrlen);\n\t\tbreak;\n\tdefault:\t\t//Address family not supported by WINC\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincAcceptReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tif (socket < 0) {\n\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t} else if (addr!= NULL) {\n\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t} else if (addrlen == 0) {\n\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 82.26726473041427}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tuint32_t now = 0;\n\tuint32_t timeOffset = 0;\n\tuint32_t timeOffsetSec = 0;\n\tuint32_t timeOffsetSec_temp = 0;\n\n\tif (getUnixTime(&epoch) == false) {\n\t\tdebug_printError(\"CLOUD: Failed to get the current time from the device clock\");\n\t\treturn;\n\t}\n\n\tnow = epoch;\n\ttimeOffset = epoch - UNIX_OFFSET;\n\ttimeOffsetSec = timeOffset / 1000;\n\ttimeOffsetSec_temp = timeOffsetSec;\n\n\t// Check if the time is valid\n\tif (timeOffsetSec > 1000000000) {\n\t\tdebug_printError(\"CLOUD: Time is not valid\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time offset\n\tupdateJWT(timeOffsetSec);\n\n\t// Connect to the MQTT broker\n\tif (connectMQTTSocket()!= 0) {\n\t\tdebug_printError(\"CLOUD: Failed to connect to the MQTT broker\");\n\t\treturn;\n\t}\n\n\t// Send the MQTT SUBSCRIBE packet\n\tif (sendSubscribe) {\n\t\tif (sendMQTTSubscribePacket()!= 0) {\n\t\t\tdebug_printError(\"CLOUD: Failed to send the MQTT SUBSCRIBE packet\");\n\t\t}\n\t\tsendSubscribe = false;\n\t}\n\n\t// Set the flag to indicate that the MQTT connection is established\n\twaitingForMQTT = true;\n\n\t// Print debug message\n\tdebug_printInfo(\"CLOUD: MQTT connection established\");\n}", "CodeBleu_score": 42.43829724052058}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch == 0) {\n\t\tdebug_printError(\"CLOUD: Time is not valid\n\");\n\t\treturn;\n\t}\n\tupdateJWT(epoch);\n\tif (sendSubscribe) {\n\t\tsendSubscribe = false;\n\t\tif (mqtt_sendSubscribePacket(mqttSubscribeTopic, TOPIC_SIZE)!= MQTT_SUCCESS) {\n\t\t\tdebug_printError(\"CLOUD: MQTT SUBSCRIBE failed\n\");\n\t\t}\n\t}\n}", "CodeBleu_score": 47.16557308449192}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentEpochTime = 0;\n\tuint32_t currentEpochTimeOffset = 0;\n\tuint32_t timeOffset = 0;\n\n\tif (getTime(&currentEpochTime) == 0) {\n\t\tdebug_printError(\"CLOUD: Time is not valid\");\n\t\treturn;\n\t}\n\n\tcurrentEpochTimeOffset = currentEpochTime + UNIX_OFFSET;\n\ttimeOffset = currentEpochTimeOffset - mqttGoogleApisComIP;\n\n\tupdateJWT(timeOffset);\n\n\tif (mqtt_connect(MQTT_SERVER_IP, MQTT_PORT, MQTT_CLIENT_ID, MQTT_USERNAME, MQTT_PASSWORD) == 0) {\n\t\tdebug_printError(\"CLOUD: MQTT Connection Established\");\n\t\tsendSubscribe = true;\n\t}\n}", "CodeBleu_score": 45.31239006944616}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tdebug_printError(\"CLOUD: Disconnect\n\");\n\tMQTT_CLIENT_disconnect();\n}", "CodeBleu_score": 19.252345022828347}, {"code": "void CLOUD_disconnect(void){\n\tdebug_printError(\"CLOUD: Disconnect\");\n\tMQTT_CLIENT_disconnect();\n}", "CodeBleu_score": 20.602810158164868}, {"code": "void CLOUD_disconnect(void){\n\tdebug_printError(\"CLOUD: Disconnect\");\n\tMQTT_CLIENT_disconnect();\n}", "CodeBleu_score": 20.602810158164868}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t Generate a client\n\tconst client = generateClient();\n\n\t// Send a GraphQL query to fetch sensor data\n\tconst response = await client.query(listSensors);\n\n\t// Log the API response\n\tconsole.log(response);\n\n\t// Check if the response contains data\n\tif (response.data && response.data.listSensors) {\n\t\t// Log the retrieval of sensors\n\t\tconsole.log('Retrieved sensors');\n\n\t\t// Iterate through each sensor\n\t\tresponse.data.listSensors.items.forEach((sensor) => {\n\t\t\t// Create a marker for the sensor\n\t\t\tvar marker = CreateSensorMarker(sensor);\n\n\t\t\t// Place the marker on the map at the sensor's geographical coordinates\n\t\t\tvar sensorMarker = new Marker(marker)\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 49.56264265509479}, {"code": "async function DisplaySensors(map){\n\tr sensors = await listSensors();\nconsole.log('Retrieved sensors:', sensors);\n\nfor (var i = 0; i < sensors.length; i++) {\nvar sensor = sensors[i];\n\nvar marker = CreateSensorMarker(sensor);\n\nvar markerElement = new Marker(marker);\nmarkerElement.setLngLat([sensor.longitude, sensor.latitude])\n.addTo(map);\n\n}\n}", "CodeBleu_score": 26.679641155365218}, {"code": "async function DisplaySensors(map){\n\tnst client = generateClient();\n\tconst response = await client.query({ query: listSensors });\n\tif (response.data.listSensors.items.length > 0) {\n\t\tconsole.log(\"Retrieved sensors: \", response.data.listSensors.items);\n\t\tresponse.data.listSensors.items.forEach((sensor) => {\n\t\t\tvar marker = CreateSensorMarker(sensor);\n\t\t\tvar markerPosition = [sensor.longitude, sensor.latitude];\n\t\t\tvar markerIcon = new Marker(marker);\n\t\t\tmarkerIcon.setLngLat(markerPosition);\n\t\t\tmarkerIcon.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 50.38356145026286}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t", "CodeBleu_score": 0.7059713833405259}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tonst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = '#ff0000';\n\tmarker.style.border = '2px solid #000000';\n\treturn marker;\n}", "CodeBleu_score": 44.95240144300102}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t", "CodeBleu_score": 0.7059713833405259}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"homeassistant.components.mfa_auth.modules.{module_name}\\\"\n    module = await async_import_module(module_path)\n    if requirements.HAS_REQUIREMENTS.get(module_name, False):\n        await requirements.async_process_requirements(hass, module_path)\n        return module\n    return module\n\n", "CodeBleu_score": 15.845143560918167}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"multi_factor_auth_modules.{module_name}\\\"\n    try:\n        module = await async_import_module(module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\\\"Multi-factor auth module %s not found\\\", module_name)\n        raise\n    except Exception as err:\n        _LOGGER.error(\\\"Error importing multi-factor auth module %s\\\", module_name)\n        raise\n\n    if module.REQUIREMENTS:\n        _LOGGER.debug(\\\"Processing requirements for multi-factor auth module %s\\\", module_name)\n        await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n        _LOGGER.debug(\\\"Requirements for multi-factor auth module %s processed\\\", module_name)\n\n    return module\n\n", "CodeBleu_score": 34.79805972537029}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\\\"homeassistant.components.mfa_auth.{module_name}\\\"\n    # Attempt to import the module\n    try:\n        module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\\\"Failed to import MFA module %s: %s\\\", module_name, err)\n        raise\n    # Check if the module has requirements and pip installation is not skipped\n    if module.REQUIREMENTS and not requirements.REQUIREMENTS_PIP_INSTALL_SKIP:\n        # Check if the module's requirements have already been processed\n        if DATA_REQS.get(module_path) is None:\n            # Process the module's requirements\n            await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n            # Mark the module's requirements as processed\n            DATA_REQS[module_path] = True\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 29.984440018397084}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    self._data = setup_data.get(\\\"data\\\")\n    for entry in self._data:\n        if entry[\\\"user_id\\\"] == user_id:\n            entry[\\\"pin\\\"] = setup_data[\\\"pin\\\"]\n            return\n    self._data.append({\n        \\\"user_id\\\": user_id,\n        \\\"pin\\\": setup_data[\\\"pin\\\"],\n    })\n    return\n\n", "CodeBleu_score": 34.76999315021402}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    pin = setup_data[\\\"pin\\\"]\n    for entry in self._data:\n        if entry[\\\"user_id\\\"] == user_id:\n            entry[\\\"pin\\\"] = pin\n            return True\n    self._data.append({\\\"user_id\\\": user_id, \\\"pin\\\": pin})\n    return True\n\n", "CodeBleu_score": 37.90303469908988}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    for entry in self._data:\n        if entry[\\\"user_id\\\"] == user_id:\n            entry[\\\"pin\\\"] = setup_data[\\\"pin\\\"]\n            return True\n    self._data.append({\\\"user_id\\\": user_id, \\\"pin\\\": setup_data[\\\"pin\\\"]})\n    return True\n", "CodeBleu_score": 38.1057689786539}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t    if self._user_settings is None:\n        async with self._init_lock:\n            if self._user_settings is None:\n                self._user_settings = await self._user_store.async_load(STORAGE_USERS, {})\n                for user_id, data in self._user_settings.items():\n                    self._user_settings[user_id] = NotifySetting(\n                        secret=data[STORAGE_USER_ID][\\\"secret\\\"],\n                        counter=data[STORAGE_USER_ID][\\\"counter\\\"],\n                        notify_service=data[STORAGE_USER_ID][\\\"notify_service\\\"],\n                        target=data[STORAGE_USER_ID][\\\"target\\\"],\n                    )\n\n", "CodeBleu_score": 39.36202241285728}, {"code": "async def _async_load(self) -> None\n\t    if self._init_lock.locked():\n        return\n    async with self._init_lock:\n        if self._user_settings is None:\n            self._user_settings = {}\n            data = await self._user_store.async_load(STORAGE_USERS)\n            if data:\n                for user_id, user_data in data.items():\n                    self._user_settings[user_id] = NotifySetting(**user_data)\n\n    @callback\n    def _async_update_user_setting(self, user_id: str, notify_service: str, target: str) -> None:\n        \\\"\\\"\\\"Update user setting for a user.\n\n        If the user does not exist, it is created.\n        If the user exists, the notify service and target are updated.\n        \\\"\\\"\\\"\n        if user_id not in self._user_settings:\n            self._user_settings[user_id] = NotifySetting(notify_service=notify_service, target=target)\n        else:\n            self._user_settings[user_id].notify_service = notify_service\n            self._user_settings[user_id].target = target\n\n    @callback\n    def _async_delete_user_setting(self, user_id: str) -> None:\n        \\\"\\\"\\\"Delete user setting for a user.\n\n        If the user exists, it is deleted.\n        \\\"\\\"\\\"\n        if user_id in self._user_settings:\n            del self._user_settings[user_id]\n\n    async def _async_get_user_setting(self, user_id: str) -> NotifySetting | None:\n        \\\"\\\"\\\"Get user setting for a user.\n\n        If the user exists, it is returned.\n        If the user does not exist, it is created.\n        \\\"\\\"\\\"\n        if user_id in self._user_settings:\n            return self._user_settings[user_id]\n        else:\n            self._user_settings[user_id] = NotifySetting()\n            return self._user_settings[user_id]\n\n    async def async_get_otp(self, user_id: str) -> str:\n        \\\"\\\"\\\"Get one time password", "CodeBleu_score": 35.10390324342115}, {"code": "async def _async_load(self) -> None\n\t    if self._user_settings is None:\n        await self._init_lock.acquire()\n        try:\n            if self._user_settings is None:\n                data = await self._user_store.async_load(STORAGE_USERS)\n                if not data:\n                    self._user_settings = {}\n                else:\n                    self._user_settings = {\n                        user_id: NotifySetting(**user_data)\n                        for user_id, user_data in data.items()\n                    }\n        finally:\n            self._init_lock.release()\n\n", "CodeBleu_score": 38.02044483781495}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n    try:\n        await self._async_validate(notify_setting, user_input.get(INPUT_FIELD_CODE))\n    except asyncio.CancelledError:\n        raise\n    except Exception as err:\n        _LOGGER.error(\"Failed to validate OTP: %s\", err)\n        return False\n    return True\n\n", "CodeBleu_score": 64.98338923720969}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    notify_service = notify_setting.notify_service\n    target = notify_setting.target\n    if notify_service is None or target is None:\n        return False\n\n    code = user_input[INPUT_FIELD_CODE]\n    return await self.hass.async_add_executor_job(\n        _verify_otp, notify_setting.secret, code, notify_setting.counter\n    )\n", "CodeBleu_score": 65.53809773781336}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    secret = notify_setting.secret\n    counter = notify_setting.counter\n    otp = user_input[INPUT_FIELD_CODE]\n    if not _verify_otp(secret, otp, counter):\n        return False\n\n    notify_setting.counter = counter + 1\n    await self._async_save()\n    return True\n\n", "CodeBleu_score": 63.72547964128742}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity = perm_lookup.entity_id_to_entity.get(entity_id)\n    if entity is None or entity.device_id is None:\n        return None\n    device = perm_lookup.device_id_to_device.get(entity.device_id)\n    if device is None or device.area_id is None:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 63.66653811526615}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t device_id = entity_id.partition(\\\".\\\").pop(0)\n    device = perm_lookup.get(device_id)\n    if device is None:\n        return None\n    area_id = device.get(\\\"area_id\\\")\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n\n\n\n", "CodeBleu_score": 45.217967110155314}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None or not device.area_id:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 47.991106676652386}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category]]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 43.348906503892394}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    new_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                for other_policy in policies:\n                    if category in other_policy:\n                        new_policy[category] = merge_categories(category, new_policy[category], other_policy[category])\n    return cast(PolicyType, new_policy)\n\n", "CodeBleu_score": 57.54543655789482}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category]] + [merged_policy.get(category)]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 47.064134604448356}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  _LOGGER.debug(\\\"Loading auth provider module: %s\\\", provider)\n    try:\n        module = async_import_module(hass, \\\"auth_providers\\\", provider)\n    except HomeAssistantError as err:\n        _LOGGER.error(\\\"Failed to load auth provider module: %s\\\", provider)\n        raise\n\n    if not module.AUTH_PROVIDER_SCHEMA.is_valid(module.CONFIG_SCHEMA):\n        _LOGGER.error(\n            \\\"Invalid configuration for auth provider %s: %s\\\",\n            provider,\n            humanize_error(module.CONFIG_SCHEMA, module.AUTH_PROVIDER_SCHEMA),\n        )\n        raise\n\n    if not module.AUTH_PROVIDER_SCHEMA.is_valid(module.CONFIG_SCHEMA):\n        _LOGGER.error(\n            \\\"Invalid configuration for auth provider %s: %s\\\",\n            provider,\n            humanize_error(module.CONFIG_SCHEMA, module.AUTH_PROVIDER_SCHEMA),\n        )\n        raise\n\n    if not module.AUTH_PROVIDER_SCHEMA.is_valid(module.CONFIG_SCHEMA):\n        _LOGGER.error(\n            \\\"Invalid configuration for auth provider %s: %s\\\",\n            provider,\n            humanize_error(module.CONFIG_SCHEMA, module.AUTH_PROVIDER_SCHEMA),\n        )\n        raise\n\n    if not module.AUTH_PROVIDER_SCHEMA.is_valid(module.CONFIG_SCHEMA):\n        _LOGGER.error(\n            \\\"Invalid configuration for auth provider %s: %s\\\",\n            provider,\n            humanize_error(module.CONFIG_SCHEMA, module.AUTH_PROVIDER_SCHEMA),\n        )\n        raise\n\n    if not module.AUTH_PROVIDER_SCHEMA.is_valid(module.CONFIG_SCHEMA):\n        _LOGGER.error(\n            \\\"Invalid configuration for auth provider %s: %s\\\",\n            provider,\n            humanize_error(module.CONFIG_SCHEMA, module.AUTH_PROVIDER_SCHEMA),\n        )\n        raise\n\n    if not module.AUTH_PROVIDER_SCHEMA.is_valid(module.CONFIG_SCHEMA):\n        _LOGGER.error(\n            \\\"Invalid configuration for auth provider %s: %s\\\",\n", "CodeBleu_score": 30.101195348640918}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  try:\n    module = await async_import_module(hass, provider, \\\"auth_providers\\\")", "CodeBleu_score": 10.679898001858042}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  try:\n        module = await async_import_module(hass, provider)\n    except HomeAssistantError as err:\n        raise HomeAssistantError(\n            f\\\"Failed to load auth provider module {provider}: {err}\\\"\n        ) from err\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\\\"Failed to load auth provider module {provider}: {err}\\\"\n        ) from err\n    except ImportError as err:\n        raise HomeAssistantError(\n            f\\\"Failed to load auth provider module {provider}: {err}\\\"\n        ) from err\n    except Exception as err:\n        raise HomeAssistantError(\n            f\\\"Failed to load auth provider module {provider}: {err}\\\"\n        ) from err\n    return module\n\n", "CodeBleu_score": 35.298712938401266}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t   self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n    else:\n        # Check for non-normalized usernames and assign to internal variable.\n        self.is_legacy = True\n        for username, users in self._data.items():\n            if not username.casefold() == username:\n                self.is_legacy = False\n                break\n    self._data = {self.normalize_username(username): users for username, users in self._data.items()}\n    self._data[\\\"admin\\\"] = [self._create_user(\\\"admin\\\", \\\"admin\\\", \\\"Admin\\\", \\\"\\\", \\\"\\\", \\\"\\\", True)]\n\n\n", "CodeBleu_score": 25.460017295086544}, {"code": "async def async_load(self) -> None\n\t   self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n        self._store.async_save(self._data)\n        return\n\n    for username, user_data in self._data.items():\n        if not self.is_legacy:\n            if username.casefold()!= username:\n                _LOGGER.warning(\n                    \\\"Username %s contains non-normalized characters.\\\", username\n                )\n                self._data[username.casefold()] = user_data\n                del self._data[username]\n                self._store.async_save(self._data)\n            continue\n\n        if username.strip():\n            _LOGGER.warning(\n                \\\"Username %s contains whitespace.\\\", username\n            )\n            self._data[username.casefold()] = user_data\n            del self._data[username]\n            self._store.async_save(self._data)\n        else:\n            _LOGGER.warning(\\\"Username %s is empty.\\\", username)\n            del self._data[username]\n            self._store.async_save(self._data)\n    self._data = {self.normalize_username(username): user_data for username, user_data in self._data.items()}\n    self.is_legacy = True\n\n", "CodeBleu_score": 22.091078590518833}, {"code": "async def async_load(self) -> None\n\t   self.data = Data(self.hass)\n    self.data._data = self.data._store.async_load()\n    self.data.is_legacy = any(\n        user[CONF_USERNAME].startswith(\" \") or user[CONF_USERNAME].endswith(\" \")\n        for user in self.data._data.values()\n    )\n\n", "CodeBleu_score": 25.576152106582462}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t  if self.is_legacy:\n        username = self.normalize_username(username)\n\n    for user in self.users:\n        if self.normalize_username(user[\\\"username\\\"]) == username:\n            if \\\"password\\\" not in user:\n                raise InvalidAuth(\n                    \\\"No password set for user\\\",\n                    translation_placeholders={\n                        \\\"username\\\": user[\\\"username\\\"],\n                    },\n                )\n\n            password_hash = user[\\\"password\\\"]\n            if bcrypt.checkpw(password.encode(), password_hash.encode()):\n                return\n\n            raise InvalidAuth(\n                \\\"Invalid password\\\",\n                translation_placeholders={\n                    \\\"username\\\": user[\\\"username\\\"],\n                },\n            )\n\n    raise InvalidAuth(\n        \\\"Invalid username\\\",\n        translation_placeholders={\n            \\\"username\\\": username,\n        },\n    )\n\n", "CodeBleu_score": 37.009103888667426}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t  if self.is_legacy:\n        username = self.normalize_username(username)\n\n    for user in self.users:\n        if user[\\\"username\\\"] == username:\n            if bcrypt.checkpw(password.encode(), user[\\\"password\\\"].encode()):\n                return\n\n    if bcrypt.checkpw(password.encode(), \\\"dummy\\\".encode()):\n        raise InvalidAuth(\\\"Invalid credentials\\\")\n\n    raise InvalidAuth(\\\"Invalid credentials\\\")\n\n", "CodeBleu_score": 43.00248993218656}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t  self.async_load()\n    normalized_username = self.normalize_username(username)\n    for user in self.users:\n        if user[\\\"username\\\"] == normalized_username:\n            stored_password_hash = user[\\\"password\\\"]\n            if not bcrypt.checkpw(password.encode(), stored_password_hash.encode()):\n                raise InvalidAuth()\n            break\n    else:\n        # No matching user found, perform a dummy hash check to prevent timing attacks\n        bcrypt.checkpw(password.encode(), b\\\"dummy_hash\\\")\n        raise InvalidAuth()\n\n", "CodeBleu_score": 37.26997557204651}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            self.users.remove(user)\n            return\n\n    raise InvalidUser(translation_key=\\\"user_not_found\\\", translation_placeholders={\\\"username\\\": username})\n", "CodeBleu_score": 40.44416031398006}, {"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(translation_key=\\\"user_not_found\\\", translation_placeholders={\\\"username\\\": username})\n", "CodeBleu_score": 40.44416031398006}, {"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(translation_key=\\\"user_not_found\\\", translation_placeholders={\\\"username\\\": username})\n", "CodeBleu_score": 40.44416031398006}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    self.data.async_remove_auth(credentials.data[\\\"username\\\"])\n    await self.data.async_save()\n\n", "CodeBleu_score": 70.91240486803694}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\\\"username\\\"])\n    except InvalidUser:\n        pass\n\n    await self.data.async_save()\n\n    async def async_credentials(self) -> list[Credentials]:\n        \\\"\\\"\\\"Get all credentials.\n\n        Returns a list of credentials.\n        \\\"\\\"\\\"\n        if self.data is None:\n            await self.async_initialize()\n            assert self.data is not None\n\n        return [self.async_create_credentials(user[\\\"username\\\"]) for user in self.data.users]\n\n    async def async_create_credentials(self, data: dict[str, Any]) -> Credentials:\n        \\\"\\\"\\\"Create a credentials object.\n\n        Returns a credentials object.\n        \\\"\\\"\\\"\n        return Credentials(self.hass, data=data)\n\n    async def async_update_user_credentials_data(self, credentials: Credentials, data: dict[str, Any]) -> None:\n        \\\"\\\"\\\"Update the data of a credentials object.\n\n        Returns nothing.\n        \\\"\\\"\\\"\n        credentials.data.update(data)\n\n    async def async_remove_credentials(self, credentials: Credentials) -> None:\n        \\\"\\\"\\\"Remove credentials.\n\n        Returns nothing.\n        \\\"\\\"\\\"\n        self.async_will_remove_credentials(credentials)\n        self.data.users.remove(credentials.data)\n        await self.data.async_save()\n\n    async def async_remove_all_credentials(self) -> None:\n        \\\"\\\"\\\"Remove all credentials.\n\n        Returns nothing.\n        \\\"\\\"\\\"\n        self.data.users.clear()\n        await self.data.async_save()\n\n    async def async_save(self) -> None:\n        \\\"\\\"\\\"Save data.\n\n        Returns nothing.\n        \\\"\\\"\\\"\n        if self.data is not None:\n            await self.data.async_save()\n\n", "CodeBleu_score": 63.33953686762035}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    self.data.async_remove_auth(credentials.data[\\\"username\\\"])\n    await self.data.async_save()\n\n", "CodeBleu_score": 70.91240486803694}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread_timeout = timeout / len(threads)\n        thread_name = thread.name\n        if thread.ident is not None:\n            thread_name = f\\\"{thread_name}[{thread.ident}]\\\"\n        try:\n            thread.join(thread_timeout)\n            joined.add(thread)\n        except Exception:\n            if log:\n                _log_thread_running_at_shutdown(thread_name, thread.ident)\n            joined.add(thread)\n    for thread in threads:\n        if thread.ident is not None:\n            try:\n                async_raise(thread.ident, SystemExit)\n            except Exception:\n                pass\n    return joined\n\n", "CodeBleu_score": 51.130040816677806}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined_threads = set()\n    for thread in threads:\n        if thread.ident is None:\n            joined_threads.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            joined_threads.add(thread)\n            continue\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            joined_threads.add(thread)\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                async_raise(thread.ident, SystemExit)\n            except Exception:\n                pass\n    return joined_threads\n\n", "CodeBleu_score": 49.84122048461107}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread_timeout = timeout / len(threads)\n            try:\n                thread.join(thread_timeout)\n            except Exception:\n                _LOGGER.error(\n                    \\\"Thread[%s] has failed to join within the specified timeout: %s\\\",\n                    thread.name,\n                    thread_timeout,\n                )\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n            if thread.is_alive():\n                joined.add(thread)\n    if joined:\n        _LOGGER.info(\n            \\\"Failed to join %s threads within the specified timeout: %s\\\",\n            len(joined),\n            timeout,\n        )\n    for thread in joined:\n        try:\n            async_raise(thread.ident, SystemExit)\n        except Exception:\n            _LOGGER.error(\n                \\\"Failed to raise SystemExit in thread[%s]: %s\\\",\n                thread.name,\n                timeout,\n            )\n    return joined\n\n", "CodeBleu_score": 47.643983918044185}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [t for t in threading.enumerate() if t.name!= \\\"main\\\" and not t.daemon]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(\\\"Failed to join thread %s\\\", thread.name, exc_info=e)\n\n", "CodeBleu_score": 26.25953774471564}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = []\n    for thread in threading.enumerate():\n        if thread is not threading.current_thread() and not thread.daemon and thread.is_alive():\n            threads.append(thread)\n    for thread in threads:\n        timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n        if not thread.join(timeout):\n            _LOGGER.warning(f\\\"Thread {thread.name} did not terminate in {timeout} seconds\\\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 35.00841562930321}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = []\n    for thread in threading.enumerate():\n        if thread is not threading.current_thread() and thread.is_alive():\n            threads.append(thread)\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except:\n            _LOGGER.warning(\n                \"Failed to join thread %s\", thread.name, exc_info=True\n            )\n\n", "CodeBleu_score": 31.656945288251404}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if (\n        remaining_with_setup_started\n        or not self._previous_was_empty\n    ) and self._handle is None:\n        self._handle = self._loop.call_later(\n            SLOW_STARTUP_CHECK_INTERVAL, self._async_watch\n        )\n    elif not remaining_with_setup_started and self._handle is not None:\n        self._handle.cancel()\n        self._handle = None\n    self._previous_was_empty = not remaining_with_setup_started\n\n", "CodeBleu_score": 50.155205099878806}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_was_empty:\n        self._hass.bus.async_fire(\n            CORE_SLOW_STARTUP_SIGNAL,\n            remaining_with_setup_started,\n        )\n        self._previous_was_empty = False\n    else:\n        self._previous_was_empty = True\n\n    # The timer is reset to 0 after the first run\n    self._duration_count = 0\n\n    # The timer is set to run again after SLOW_STARTUP_CHECK_INTERVAL seconds\n    self._handle = self._loop.call_later(\n        SLOW_STARTUP_CHECK_INTERVAL,\n        self._async_watch,\n    )\n\n", "CodeBleu_score": 49.55394899442454}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if (\n        remaining_with_setup_started\n        or self._previous_was_empty\n    ) and self._handle is None:\n        self._handle = self._loop.call_later(\n            SLOW_STARTUP_CHECK_INTERVAL, self._async_watch\n        )\n    elif not remaining_with_setup_started and self._handle is not None:\n        self._handle.cancel()\n        self._handle = None\n    self._previous_was_empty = not remaining_with_setup_started\n\n\n    def async_setup(self) -> None:\n        \\\"\\\"\\\"Setup the WatchPendingSetups class.\\\"\\\"\\\"\n        self._hass.bus.async_listen_once(\n            core.EVENT_HOMEASSISTANT_STARTUP, self._async_watch\n        )\n\n", "CodeBleu_score": 42.701096068580355}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t   if config.bluetooth_content is None:\n        config.bluetooth_content = generate_and_validate(integrations)\n        config.save()\n    else:\n        if config.bluetooth_content!= generate_and_validate(integrations):\n            config.bluetooth_content = generate_and_validate(integrations)\n            config.save()\n            config.add_error(\n                \"bluetooth.py is not up to date. Please run `hass --script check_bluetooth` to generate the file.\"\n            )\n\n", "CodeBleu_score": 36.21494776945845}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t   if not config.bluetooth_file_path.exists():\n        return\n\n    generated_content = generate_and_validate(integrations)\n    current_content = config.bluetooth_file_path.read_text()\n\n    if generated_content!= current_content:\n        config.bluetooth_file_path.write_text(generated_content)\n        config.add_error(\n            \"bluetooth.py\",\n            \"The bluetooth.py file is not up to date. Please run `hass --script check_bluetooth` to generate a new bluetooth.py file.\",\n            \"Fix\",\n        )\n\n", "CodeBleu_score": 43.37111345739885}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t   # Check if the file is already valid\n    if config.bluetooth_py_content is not None:\n        return\n\n    # Generate and validate the bluetooth.py content\n    bluetooth_py_content = generate_and_validate(integrations)\n\n    # Check if the content is the same as the current content\n    if bluetooth_py_content == config.bluetooth_py_content:\n        return\n\n    # Add an error to the configuration\n    config.add_warning(\n        \"bluetooth.py is not up to date. Please run `hass --script check_bluetooth_py` to fix this.\"\n    )\n\n    # Add a suggestion to the configuration\n    config.add_suggestion(\n        \"Run `hass --script check_bluetooth_py` to fix this.\"\n    )\n\n    # Store the new content in the configuration\n    config.bluetooth_py_content = bluetooth_py_content\n\n", "CodeBleu_score": 38.08928026675365}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 91.21194251915983}, {"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 91.21194251915983}, {"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 91.21194251915983}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t body []byte\n\tvar err error\n\tvar req *resty.Request\n\tvar res *resty.Response\n\tvar e TokenError\n\tfor i := 0; i < 3; i++ {\n\t\treq = base.RestyClient.R().SetResult(resp).SetError(&e).SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\t\treq.SetHeader(\\\"X-Goog-Drive-Upload\\\", \\\"resumable=false\\\")\n\t\treq.SetHeader(\\\"X-Upload-Content-Type\\\", \\\"application/octet-stream\\\")\n\t\treq.SetHeader(\\\"X-Upload-Content-Length\\\", strconv.FormatInt(d.Size, 10))\n\t\treq.SetHeader(\\\"Content-Length\\\", strconv.FormatInt(d.Size, 10))\n\t\tif callback!= nil {\n\t\t\tcallback(req)\n\t\t}\n\t\tswitch method {\n\t\tcase \\\"POST\\\":\n\t\t\tres, err = req.SetBody(d.Body).Post(url)\n\t\tcase \\\"PUT\\\":\n\t\t\tres, err = req.SetBody(d.Body).Put(url)\n\t\tcase \\\"DELETE\\\":\n\t\t\tres, err = req.Delete(url)\n\t\t}\n\t\tif err!= nil {\n\t\t\tif e.Error!= \\\"\\\" {\n\t\t\t\treturn nil, fmt.Errorf(e.Error)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif res.StatusCode() == 401 {\n\t\t\tif err = d.refreshToken(); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbody, err = res.RawBody()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn body, nil\n\t}\n\treturn nil, fmt.Errorf(\\\"request failed\\\")\n}", "CodeBleu_score": 41.696618110127744}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.MountPointReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\terr = service.MyService.Storage().DeleteConfigByName(req.MountPoint)\n\tif err!= nil {\n\t\tlogger.Error(\"DeleteConfigByName\", zap.Any(\"err\", err))\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 63.34907345101146}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.UmountReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"MountPoint is empty\"})\n\t\treturn\n\t}\n\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\n\terr = service.MyService.Storage().DeleteConfigByName(req.MountPoint)\n\tif err!= nil {\n\t\tlogger.Error(\"DeleteConfigByName\", zap.Any(\"err\", err))\n\t}\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: \"success\"})\n}", "CodeBleu_score": 69.17048623735576}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\terr := service.MyService.Storage().UmountStorage(req.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\terr = service.MyService.Storage().DeleteConfigByName(req.MountPoint)\n\tif err!= nil {\n\t\tlogger.Error(\"DeleteConfigByName\", zap.Any(\"err\", err))\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: \"\"})\n}", "CodeBleu_score": 68.58639652747813}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t/ Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\t// Check if the file path is valid\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// Open the file and read its contents\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tdefer file.Close()\n\t// Return the file to the client\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 67.8390443914281}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewCommonError(common_err.ErrBind, err.Error()))\n\t}\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewCommonError(common_err.ErrParam, \"name is required\"))\n\t}\n\tif err := service.SendNotification(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewCommonError(common_err.ErrSendNotify, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.NewCommonError(common_err.ErrNone, \"\"))\n}", "CodeBleu_score": 49.90837408110421}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := service.PostNotifyMessage(message[\"name\"], message[\"message\"]); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.SuccessResponse{Message: \"Notification sent successfully.\"})\n}", "CodeBleu_score": 46.58523261148721}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\" from the message map.\n\tif err := service.SendNotification(name, message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Notification sent successfully.\")\n}", "CodeBleu_score": 49.9362582795316}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tctx.Logger().Debug(\"websocket connection established\")\n\tgo service.SendMsg(ws)\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tctx.Logger().Error(err)\n\t\t\tbreak\n\t\t}\n\t\tctx.Logger().Debug(\"msg type: \", msg[0])\n\t\tctx.Logger().Debug(\"msg: \", string(msg[1:]))\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.32266862787353}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection.\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to a list of connections.\n\tconnections = append(connections, conn)\n\n\t// Ensure that the message sending service is running.\n\tgo func() {\n\t\tfor {\n\t\t\t// Read a message from the WebSocket connection.\n\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\tif err!= nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Print the message type, message, and any errors.\n\t\t\tfmt.Println(\"Message type:\", messageType)\n\t\t\tfmt.Println(\"Message:\", string(message))\n\t\t\tfmt.Println(\"Error:\", err)\n\n\t\t\t// Write a message to the WebSocket connection.\n\t\t\tif err := conn.WriteMessage(messageType, message); err!= nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Send a message to the WebSocket connection.\n\tif err := conn.WriteMessage(websocket.TextMessage, []byte(\"notify\")); err!= nil {\n\t\treturn err\n\t}\n\n\t// Close the WebSocket connection.\n\tif err := conn.Close(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Remove the closed WebSocket connection from the list of connections.\n\tfor i, c := range connections {\n\t\tif c == conn {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 38.12084580932043}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// \u5347\u7ea7\u8fde\u63a5\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// \u53d1\u9001\u6d88\u606f\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(\"notify\"))\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// \u8bfb\u53d6\u6d88\u606f\n\tfor {\n\t\tmt, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"message type: %d, message: %s\n\", mt, message)\n\t}\n}", "CodeBleu_score": 47.234672380868524}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdata := make(map[string]interface{}, 2)\n\tdata[\"model\"] = common.GetSystemModel()\n\tdata[\"architecture\"] = runtime.GOARCH\n\tif common.IsLinux() {\n\t\tdata[\"cpu\"] = common.GetCPUInfo()\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: data})\n}", "CodeBleu_score": 41.95646409190947}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\tcpuInfo *model.CpuInfo\n\t\terr     error\n\t)\n\tif cpuInfo, err = service.MyService.System().GetCpuInfo(); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: cpuInfo})\n}", "CodeBleu_score": 45.39451740648471}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdata := make(map[string]interface{}, 2)\n\tdata[\"cpu\"] = service.MyService.System().GetCpuInfo()\n\tdata[\"disk\"] = service.MyService.System().GetDiskInfo()\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: data})\n}", "CodeBleu_score": 55.44590403722491}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar services map[bool]*[]string\n\tvar err error\n\tservices, err = systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tvar runningServices, notRunningServices []string\n\tfor _, service := range services {\n\t\tif service.Status == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 58.09435805724926}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos-\") {\n\t\t\tif systemctl.IsServiceRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 62.44547291979894}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar (\n\t\trunningServices = []string{}\n\t\tnotRunningServices = []string{}\n\t)\n\n\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif systemctl.IsServiceRunning(service) {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue: &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 48.49145073434955}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tif c.db == nil {\n\t\tpanic(\"database not initialized\")\n\t}\n\n\tvar (\n\t\terr error\n\t\tbus *message_bus.ClientWithResponses\n\t)\n\n\tbus, err = message_bus.NewClientWithResponses(c.db)\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n\n\tif len(config.RuntimePath) > 0 {\n\t\tbus.Server = config.RuntimePath + \"message_bus\"\n\t} else {\n\t\tbus.Server = \"http://127.0.0.1:8080\"\n\t}\n\n\treturn bus\n}", "CodeBleu_score": 33.87577885461452}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tvar (\n\t\terr error\n\t\taddr string\n\t)\n\tif len(RuntimePath) > 0 {\n\t\taddr, err = config.GetMessageBusAddress(RuntimePath)\n\t\tif err!= nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tclient, err := message_bus.NewClientWithResponses(addr)\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}", "CodeBleu_score": 34.98963098438185}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tvar (\n\t\terr error\n\t\tbus *message_bus.ClientWithResponses\n\t)\n\n\tif len(config.RuntimePath) > 0 {\n\t\tbus, err = message_bus.NewClientWithResponses(config.RuntimePath)\n\t} else {\n\t\tbus, err = message_bus.NewClientWithResponses(message_bus.DefaultAddress)\n\t}\n\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n\n\tbus.SetServer(bus.Server)\n\n\treturn bus\n}", "CodeBleu_score": 31.77257745956562}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\txForwardedFor := request.Header.Get(\\\"x-forwarded-for\\\")\n\tif len(xForwardedFor) > 0 {\n\t\treturn strings.Split(xForwardedFor, \\\", \\\")[0]\n\t}\n\treturn request.RemoteAddr\n}", "CodeBleu_score": 19.703721800068237}, {"code": "func GetIP(request *http.Request) string{\n\t// Check the \"x-forwarded-for\" header and extract the first IP if present.\n\tif forwardedFor := request.Header.Get(\\\"x-forwarded-for\\\"); forwardedFor!= \\\"\\\" {\n\t\tips := strings.Split(forwardedFor, \\\",\\\")\n\t\tif len(ips) > 0 {\n\t\t\treturn ips[0]\n\t\t}\n\t}\n\n\t// Use the request's remote address if the \"x-forwarded-for\" header is not available.\n\treturn request.RemoteAddr\n}", "CodeBleu_score": 23.0847260543706}, {"code": "func GetIP(request *http.Request) string{\n\t// Check for the \"x-forwarded-for\" header and extract the first IP if present.\n\tif ip := request.Header.Get(\"x-forwarded-for\"); ip!= \"\" {\n\t\tips := strings.Split(ip, \",\")\n\t\treturn ips[0]\n\t}\n\n\t// Use the request's remote address if the \"x-forwarded-for\" header is not available.\n\treturn strings.Split(request.RemoteAddr, \":\")[0]\n}", "CodeBleu_score": 27.00110310625938}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\tntryPath := config.AppInfo.AppPath + \"/entry.json\"\n\tentry, err := os.Create(entryPath)\n\tif err!= nil {\n\t\tlogger.Error(\"create entry.json failed\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entry.Close()\n\tentry.WriteString(\"[\")\n\tmodulesPath := config.AppInfo.AppPath + \"/modules\"\n\tfiles, err := ioutil.ReadDir(modulesPath)\n\tif err!= nil {\n\t\tlogger.Error(\"read modules failed\", zap.Error(err))\n\t\treturn\n\t}\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tpath := modulesPath + \"/\" + file.Name() + \"/entry.json\"\n\t\t\tdata, err := ioutil.ReadFile(path)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"read entry.json failed\", zap.Error(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tentry.Write(data)\n\t\t\tentry.WriteString(\",\")\n\t\t}\n\t}\n\tentry.WriteString(\"]\")\n}", "CodeBleu_score": 43.69582029116817}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tar err error\n\t// 1. get the modules directory path\n\tmodulesPath := config.AppInfo.ModulesPath\n\t// 2. get the entry file path\n\tentryPath := config.AppInfo.EntryPath\n\t// 3. read the entry file content\n\tentryContent, err := file.ReadFullFile(entryPath)\n\tif err!= nil {\n\t\tlogger.Logger.Error(\"Failed to read entry file\",\n\t\t\tzap.String(\"entry file path\", entryPath),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\t// 4. read the entry file content\n\tmodules, err := file.ReadDir(modulesPath)\n\tif err!= nil {\n\t\tlogger.Logger.Error(\"Failed to read modules directory\",\n\t\t\tzap.String(\"modules directory path\", modulesPath),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\t// 5. get the entry file content\n\tentryContent = []byte(\"[]\")\n\t// 6. loop through each module directory\n\tfor _, module := range modules {\n\t\t// 7. get the module directory path\n\t\tmodulePath := filepath.Join(modulesPath, module)\n\t\t// 8. read the entry.json file content\n\t\tentryJson, err := file.ReadFullFile(filepath.Join(modulePath, \"entry.json\"))\n\t\tif err!= nil {\n\t\t\tlogger.Logger.Error(\"Failed to read entry.json file\",\n\t\t\t\tzap.String(\"entry.json file path\", filepath.Join(modulePath, \"entry.json\")),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t// 9. append the entry.json file content to the entryContent\n\t\tentryContent = append(entryContent, entryJson...)\n\t}\n\t// 10. write the entry file content\n\terr = file.WriteFile(entryPath, entryContent)\n\tif err!= nil {\n\t\tlogger.Logger.Error(\"Failed to write entry file\",\n\t\t\tzap.String(\"entry file path\", entryPath),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 45.32377652172806}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.GetNet(false)\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range netNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 59.53407425233097}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\tnets := MyService.System().GetNet(false)\n\tfor _, net := range nets {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == net {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \\\"\\\", errors.New(\\\"no network interface found\\\")\n}", "CodeBleu_score": 62.568943991505385}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\ta list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service.\n\tnames, err := c.GetNet(false)\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names.\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\t// Return the MAC address of the first matching interface.\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// No matching interface found.\n\treturn \"\", errors.New(\\\"No matching interface found.\\\")\n}", "CodeBleu_score": 58.68475033903285}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\tif (pRequest->refCnt == 0) {\n\t\trc = tref_add(&pRequest->ref, clientReqRefPool, TREF_OBJ_REQUEST, pRequest);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\tpRequest->refCnt++;\n\tif (pTscObj->appInfo.name!= NULL) {\n\t\tpTscObj->appInfo.reqCnt++;\n\t\tpTscObj->appInfo.reqCntCur++;\n\t}\n\treturn rc;\n}", "CodeBleu_score": 30.2322873613585}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (pRequest->pDb == NULL) {\nreturn true;\n}\n\nif (strcmp(pRequest->pDb, exceptDb) == 0) {\nreturn false;\n}\n\nif (pRequest->dbList == NULL) {\nreturn true;\n}\n\nfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\nchar* db = taosArrayGet(pRequest->dbList, i);\nchar* dot = strchr(db, '.');\nif (dot!= NULL) {\ndb = dot + 1;\n}\n\nif (strcmp(db, exceptDb) == 0) {\nreturn false;\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 75.74038400993531}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\tif (pRequest->dbList!= NULL) {\n\t\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\t\tchar* dot = strchr(db, '.');\n\t\t\tif (dot!= NULL) {\n\t\t\t\tdb = dot + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 68.91343540538669}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (strcmp(pRequest->pDb, exceptDb) == 0) {\n\t\treturn true;\n\t}\n\n\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\tchar* dot = strchr(db, '.');\n\t\tif (dot!= NULL) {\n\t\t\tdb = dot + 1;\n\t\t}\n\n\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 69.77984181540134}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_REDIRECT_TO_MASTER || code == TSDB_CODE_REDIRECT_TO_SLAVE || code == TSDB_CODE_REDIRECT_TO_MASTER_SLAVE) {\n\t\tif (msgType!= TMSG_TYPE_QUERY_RESULT && msgType!= TMSG_TYPE_QUERY_RESULT_EX && msgType!= TMSG_TYPE_QUERY_RESULT_EX_V2) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 38.50695985852851}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\treturn (code == TSDB_CODE_REDIRECT || code == TSDB_CODE_REDIRECT_TO_MASTER || code == TSDB_CODE_REDIRECT_TO_SLAVE || code == TSDB_CODE_REDIRECT_TO_MASTER_OR_SLAVE) &&\n\t\t(msgType!= TSDB_MSG_TYPE_QUERY_RESULT_DATA && msgType!= TSDB_MSG_TYPE_QUERY_RESULT_DATA_WITH_META && msgType!= TSDB_MSG_TYPE_QUERY_RESULT_DATA_WITH_META_AND_ROW_COUNT && msgType!= TSDB_MSG_TYPE_QUERY_RESULT_DATA_WITH_META_AND_ROW_COUNT_AND_COL_COUNT);\n}", "CodeBleu_score": 34.77005768457397}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_REDIRECT) {\n\t\tswitch (msgType) {\n\t\tcase TMSG_TYPE_REQ:\n\t\tcase TMSG_TYPE_RESP:\n\t\tcase TMSG_TYPE_RESP_ERR:\n\t\tcase TMSG_TYPE_RESP_ERR_MSG:\n\t\tcase TMSG_TYPE_RESP_ERR_MSG_DETAIL:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 36.11731935874707}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tvoid *pIter = taosHashIterate(pRequests, NULL);\nwhile (pIter!= NULL) {\nint64_t *rid = pIter;\n\nSRequestObj *pRequest = acquireRequest(*rid);\nif (pRequest) {\nstopRequest(pRequest);\ndestroyRequest(pRequest);\nreleaseRequest(*rid);\n}\n\npIter = taosHashIterate(pRequests, pIter);\n}\n}", "CodeBleu_score": 82.48935278590997}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\tif (pRequest->pQuery->pRoot) {\n\t\t\t\t\tif (QUERY_NODE_VNODE_MODIFY_STMT == pRequest->pQuery->pRoot->type || QUERY_NODE_INSERT_STMT == pRequest->pQuery->pRoot->type) {\n\t\t\t\t\t\tstopRequest(pRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 75.26273556606857}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tstopRequest(pRequest);\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 86.66259480226269}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tint32_t ret = atomic_val_compare_exchange_32(&clientStop, -1, 1);\n\tif (!ret) {\n\t\ttscError(\"crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\ttscInfo(\"stop crash report thread\");\n\twhile (clientStop > 0) {\n\t\ttaosMsleep(200);\n\t}\n}", "CodeBleu_score": 58.633687258586576}, {"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n\t\treturn;\n\t}\n\n\ttscError(\"failed to stop crash report thread since it is already stopped\");\n}", "CodeBleu_score": 35.79287482808541}, {"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n\t\ttscInfo(\"stop crash report thread\");\n\t\treturn;\n\t}\n\n\ttscError(\"crash report thread already stopped\");\n}", "CodeBleu_score": 38.38365732402597}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t code = 0;\n\nSViewHbRsp hbRsp = {0};\nif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n  terrno = TSDB_CODE_INVALID_MSG;\n  return -1;\n}\n\nint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\nfor (int32_t i = 0; i < numOfMeta; ++i) {\n  SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n  if (rsp->numOfColumns < 0) {\n    tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n    catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n  } else {\n    tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n    if (rsp->pSchemas[0].colId!= PRIMARYKEY_TIMESTAMP_COL_ID) {\n      tscError(\"invalid colId[%\" PRIi16 \"] for the first column in table meta rsp msg\", rsp->pSchemas[0].colId);\n      tFreeSViewHbRsp(&hbRsp);\n      return TSDB_CODE_TSC_INVALID_VALUE;\n    }\n\n    catalogAsyncUpdateViewMeta(pCatalog, rsp);\n  }\n}\n\nint32_t numOfIndex = taosArrayGetSize(hbRsp.pIndexRsp);\nfor (int32_t i = 0; i < numOfIndex; ++i) {\n  SViewIndexRsp *rsp = taosArrayGet(hbRsp.pIndexRsp, i);\n\n  catalogUpdateViewIndex(pCatalog, rsp);\n}\n\ntaosArrayDestroy(hbRsp.pIndexRsp);\nhbRsp.pIndexRsp = NULL;\n\ntFreeSViewHbRsp(&hbRsp);\nreturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 75.41845586164317}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t code = 0;\n\nSViewHbRsp hbRsp = {0};\nif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n  terrno = TSDB_CODE_INVALID_MSG;\n  return -1;\n}\n\nint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\nfor (int32_t i = 0; i < numOfMeta; ++i) {\n  SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n  if (rsp->numOfColumns < 0) {\n    tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n    catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n  } else {\n    tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n    if (rsp->pSchemas[0].colId!= PRIMARYKEY_TIMESTAMP_COL_ID) {\n      tscError(\"invalid colId[%\" PRIi16 \"] for the first column in table meta rsp msg\", rsp->pSchemas[0].colId);\n      tFreeSViewHbRsp(&hbRsp);\n      return TSDB_CODE_TSC_INVALID_VALUE;\n    }\n\n    catalogAsyncUpdateViewMeta(pCatalog, rsp);\n  }\n}\n\nint32_t numOfIndex = taosArrayGetSize(hbRsp.pIndexRsp);\nfor (int32_t i = 0; i < numOfIndex; ++i) {\n  SViewIndexRsp *rsp = taosArrayGet(hbRsp.pIndexRsp, i);\n\n  catalogUpdateViewIndex(pCatalog, rsp);\n}\n\ntaosArrayDestroy(hbRsp.pIndexRsp);\nhbRsp.pIndexRsp = NULL;\n\ntFreeSViewHbRsp(&hbRsp);\nreturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 75.41845586164317}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t code = 0;\n\nSViewHbRsp hbRsp = {0};\nif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n  terrno = TSDB_CODE_INVALID_MSG;\n  return -1;\n}\n\nint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\nfor (int32_t i = 0; i < numOfMeta; ++i) {\n  SViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n  if (rsp->numOfColumns < 0) {\n    tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n    catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n  } else {\n    tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n    if (rsp->pSchemas[0].colId!= PRIMARYKEY_TIMESTAMP_COL_ID) {\n      tscError(\"invalid colId[%\" PRIi16 \"] for the first column in table meta rsp msg\", rsp->pSchemas[0].colId);\n      tFreeSViewHbRsp(&hbRsp);\n      return TSDB_CODE_TSC_INVALID_VALUE;\n    }\n\n    catalogAsyncUpdateViewMeta(pCatalog, rsp);\n  }\n}\n\nint32_t numOfIndex = taosArrayGetSize(hbRsp.pIndexRsp);\nfor (int32_t i = 0; i < numOfIndex; ++i) {\n  SViewIndexRsp *rsp = taosArrayGet(hbRsp.pIndexRsp, i);\n\n  catalogUpdateViewIndex(pCatalog, rsp);\n}\n\ntaosArrayDestroy(hbRsp.pIndexRsp);\nhbRsp.pIndexRsp = NULL;\n\ntFreeSViewHbRsp(&hbRsp);\nreturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 75.41845586164317}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tTS3SizeCBD *cbData = (TS3SizeCBD *)callbackData;\n\nif (cbData->content_length == 0) {\nif (properties->contentLength) {\ncbData->content_length = *properties->contentLength;\n}\n}\n\nreturn S3StatusOK;\n}", "CodeBleu_score": 60.92423613376705}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3SizeCBD *cbData = (TS3SizeCBD *)callbackData;\n\tif (cbData->content_length == 0 && properties->contentLength > 0) {\n\t\tcbData->content_length = properties->contentLength;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 64.0610383997575}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tTS3SizeCBD *cbData = (TS3SizeCBD *)callbackData;\n\nif (cbData->content_length == 0) {\nif (properties->contentLength > 0) {\ncbData->content_length = properties->contentLength;\n}\n}\nreturn S3StatusOK;\n}", "CodeBleu_score": 68.49168039507632}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tdef WINDOWS\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \"rsync.exe --daemon --port=%d --config=%srsync.conf\", tsRsyncPort, tsCheckpointBackupDir);\n#else\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --port=%d --config=%srsync.conf\", tsRsyncPort, tsCheckpointBackupDir);\n#endif\n  int32_t code = execCommand(command);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed, command:%s\", command);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 37.965031949563546}, {"code": "void startRsync(){\n\tdef WINDOWS\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --port=%d --config=%srsync.conf\", tsCheckpointBackupPort, tsCheckpointBackupDir);\n  int32_t code = system(cmd);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed, cmd:%s, code:%d\", cmd, code);\n    return;\n  }\n  uDebug(\"[rsync] start rsync server successful\");\n#else\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --port=%d --config=%srsync.conf\", tsCheckpointBackupPort, tsCheckpointBackupDir);\n  int32_t code = system(cmd);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed, cmd:%s, code:%d\", cmd, code);\n    return;\n  }\n  uDebug(\"[rsync] start rsync server successful\");\n#endif\n}", "CodeBleu_score": 54.29232928896255}, {"code": "void startRsync(){\n\tdef WINDOWS\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s\\\\rsync.conf\", tsCheckpointBackupDir);\n#else\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n#endif\n\n  if (taosMkdir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] create checkpoint backup directory error, dir:%s, errno:%d, msg:%s\", tsCheckpointBackupDir, errno, strerror(errno));\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(confDir) < 0) {\n    uError(\"[rsync] generate config file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char command[PATH_MAX] = {0};\n  snprintf(command, PATH_MAX, \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n  uDebug(\"[rsync] start rsync server, command:%s\", command);\n  int32_t code = execCommand(command);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed, command:%s, code:%d\", command, code);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 59.90680239290954}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher current = dispatchers.remove(dispatcherId);\nif (current == null) {\nthrow new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n}\ncurrent.shutdown();\n}", "CodeBleu_score": 64.12566950292948}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher current = dispatchers.remove(dispatcherId);\nif (current == null) {\nthrow new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n}\ncurrent.shutdown();\n}", "CodeBleu_score": 41.58251123392296}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher current = dispatchers.get(dispatcherId);\nif (current == null) {\nthrow new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n}\ncurrent.shutdown();\ndispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 65.89219098399401}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.getOrDefault(parent, Collections.emptySet());\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n try {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox!= null) {\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n } else {\n log.warn(\\\"Child actor with id [{}] is not registered!\\\", child);\n }\n } catch (Exception e) {\n log.error(\\\"Error while sending message to actor with id [{}]: {}\\\", child, e.getMessage());\n }\n }\n }\n }", "CodeBleu_score": 41.66463698790553}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.get(parent);\n if (children!= null) {\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox!= null) {\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n } else {\n log.warn(\\\"Child actor with id [{}], of parent actor with id [{}], is not registered!\\\", child, parent);\n }\n }\n }\n } else {\n log.warn(\\\"Parent actor with id [{}] is not registered!\\\", parent);\n }\n }", "CodeBleu_score": 38.87593557796391}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\ttorMailbox parentMailbox = actors.get(parent);\n if (parentMailbox == null) {\n throw new TbActorNotRegisteredException(parent, \"Parent actor with id [\" + parent + \"] is not registered!\");\n }\n Set<TbActorId> children = parentChildMap.get(parent);\n if (children == null) {\n return;\n }\n List<TbActorId> filteredChildren = children.stream()\n.filter(childFilter)\n.collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n TbActorMailbox childMailbox = actors.get(child);\n if (childMailbox == null) {\n log.warn(\"Child actor with id [{}] is not registered!\", child);\n continue;\n }\n if (highPriority) {\n childMailbox.tellWithHighPriority(msg);\n } else {\n childMailbox.tell(msg);\n }\n }\n }", "CodeBleu_score": 46.80448150941246}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (destroyInProgress.get()) {\nif (msg.getType() == MsgType.RULE_NODE_UPDATED_MSG &&!((RuleNodeUpdatedMsg) msg).isReinitOnFailure()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\n} else {\nmsg.notifyActorStopped(TbActorStopReason.DESTROY_IN_PROGRESS);\n}\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n}\n}", "CodeBleu_score": 52.22963813628033}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (!destroyInProgress.get()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n} else {\nif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\nlog.info(\\\"[{}] Enqueuing message {} during destruction, reinitializing actor.\\\", selfId, msg.getMsgType());\nactor.init(this);\n} else {\nlog.info(\\\"[{}] Enqueuing message {} during destruction, actor is stopping.\\\", selfId, msg.getMsgType());\nmsg.setActorStopped(true);\n}\n}\n}", "CodeBleu_score": 49.81649335893089}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (destroyInProgress.get()) {\nif (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\nif (actor.onRuleNodeUpdated(msg)) {\ntryInit(1);\n}\n}\nmsg.notifyActorStopped(TbActorStopReason.ACTOR_DESTROYED);\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n}\n}", "CodeBleu_score": 45.03924040168381}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t {\nif (destroyInProgress.get()) {\nreturn;\n}\n\nif (highPriorityMsgs.isEmpty()) {\nif (normalPriorityMsgs.isEmpty()) {\nready.set(NOT_READY);\n}\n}\n\nif (system.getSettings().getActorThroughput() > 0) {\nint processed = 0;\nwhile (processed < system.getSettings().getActorThroughput()) {\nif (highPriorityMsgs.isEmpty()) {\nif (normalPriorityMsgs.isEmpty()) {\nbreak;\n}\n}\n\nTbActorMsg msg = null;\nif (!highPriorityMsgs.isEmpty()) {\nmsg = highPriorityMsgs.poll();\n} else if (!normalPriorityMsgs.isEmpty()) {\nmsg = normalPriorityMsgs.poll();\n}\n\nif (msg!= null) {\nif (msg.getMsgType().equals(MsgType.RULE_NODE_UPDATED_MSG)) {\nsynchronized (this) {\nif (stopReason == TbActorStopReason.INIT_FAILED) {\ndestroyInProgress.set(false);\nstopReason = null;\ninitActor();\nreturn;\n} else {\nmsg.onTbActorStopped(stopReason);\n}\n}\n}\nactor.process(msg);\nprocessed++;\n} else {\nbreak;\n}\n}\n}\n} catch (Throwable t) {\nlog.error(\\\"[{}] Error processing actor mailbox\\\", selfId, t);\nactor.onProcessFailure(t);\n} finally {\nbusy.set(FREE);\ntryProcessQueue(false);\n}\n}", "CodeBleu_score": 34.66167386336906}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\t {\nprocessHighPriorityMsgs();\nprocessNormalPriorityMsgs();\n} catch (Throwable t) {\nlog.error(\\\"[{}] Error processing mailbox\\\", selfId, t);\nprocessFailure(t);\n} finally {\nbusy.set(FREE);\ntryProcessQueue(false);\n}\n}", "CodeBleu_score": 7.45167560006849}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (destroyInProgress.compareAndSet(false, true)) {\nstopReason = TbActorStopReason.DESTROYED;\n\ndispatcher.getExecutor().execute(() -> {\ntry {\nactor.destroy(cause);\n} catch (Throwable t) {\nlog.warn(\"Failed to destroy actor, cause: {}.\", cause, t);\n}\n\nready.set(NOT_READY);\n\nsynchronized (this) {\nfor (TbActorMsg msg : highPriorityMsgs) {\nmsg.onTbActorStopped(stopReason);\n}\nfor (TbActorMsg msg : normalPriorityMsgs) {\nmsg.onTbActorStopped(stopReason);\n}\n}\n\ndestroyInProgress.set(false);\n});\n}\n}", "CodeBleu_score": 46.98892727084167}, {"code": "public void destroy(Throwable cause){\n\tif (destroyInProgress.compareAndSet(false, true)) {\nlog.debug(\"[{}] Destroying actor, cause: {}\", selfId, cause);\nstopReason = TbActorStopReason.DESTROYED;\ndispatcher.getExecutor().execute(() -> {\nready.set(NOT_READY);\nactor.destroy(cause);\nnotifyQueue();\n});\n} else {\nlog.debug(\"[{}] Destroy in progress, cause: {}\", selfId, cause);\n}\n}", "CodeBleu_score": 25.879185156856366}, {"code": "public void destroy(Throwable cause){\n\tif (destroyInProgress.compareAndSet(false, true)) {\nstopReason = TbActorStopReason.STOPPED_BY_USER;\nready.set(NOT_READY);\ndispatcher.getExecutor().execute(() -> {\ntry {\nactor.destroy(stopReason, cause);\n} catch (Throwable t) {\nlog.warn(\"Failed to destroy actor: {}\", selfId, t);\n}\nnotifyMsgQueue();\n});\n}\n}", "CodeBleu_score": 42.76522023639039}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlog.trace(\"DTLS session in-memory store evicting timeout sessions...\");\nlong expirationTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\nif (entry.getValue().getLastActivityTime() < expirationTime) {\nlog.trace(\"DTLS session in-memory store evicting timeout session: [{}] timestamp: [{}]\", entry.getKey(), entry.getValue().getLastActivityTime());\ndtlsSessionsMap.remove(entry.getKey());\n}\n}\n}", "CodeBleu_score": 42.90825817842975}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nlog.trace(\\\"DTLS session in-memory store evicting expired sessions older than [{}]\\\", expirationTime);\n\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\n\nif (entry.getValue().getLastActivityTime() < expirationTime) {\n\nlog.trace(\\\"DTLS session in-memory store evicting expired session: [{}]\\\", entry.getKey());\n\ndtlsSessionsMap.remove(entry.getKey());\n\n}\n\n}\n\n}", "CodeBleu_score": 41.9293544108741}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nlog.trace(\\\"DTLS session in-memory store is evicting sessions older than [{}]\\\", expirationTime);\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\nif (entry.getValue().getLastActivityTime() < expirationTime) {\nlog.trace(\\\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\\\", entry.getKey(), entry.getValue().getLastActivityTime());\ndtlsSessionsMap.remove(entry.getKey());\n}\n}\n}", "CodeBleu_score": 43.34200445367903}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream()\n.map(entry -> {\nList<JsonNode> values = entry.getValue();\nList<KvEntry> kvEntries = new ArrayList<>(values.size());\nfor (JsonNode value : values) {\nKvEntry entry = parseValue(value.get(TS).asText(), value.get(VALUE));\nkvEntries.add(entry);\n}\nreturn new BasicTsKvEntry(entry.getKey(), kvEntries, entry.getLastUpdateTs());\n})\n.collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 48.82672705639012}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nList<TsKvEntry> tsKvEntries = new ArrayList<>();\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nList<JsonNode> jsonNodes = entry.getValue();\nList<KvEntry> kvEntries = new ArrayList<>();\nfor (JsonNode jsonNode : jsonNodes) {\nKvEntry kvEntry = parseValue(jsonNode.get(TS).asText(), jsonNode.get(VALUE));\nkvEntries.add(kvEntry);\n}\ntsKvEntries.add(new BasicTsKvEntry(entry.getKey(), kvEntries));\n}\nreturn tsKvEntries;\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 46.52549944362841}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream().map(entry -> {\nList<JsonNode> data = entry.getValue();\nList<KvEntry> kvEntries = new ArrayList<>();\nfor (JsonNode dataEntry : data) {\nString ts = dataEntry.get(TS).asText();\nKvEntry kvEntry = parseValue(entry.getKey(), dataEntry.get(VALUE));\nkvEntries.add(new BasicTsKvEntry(kvEntry, Long.parseLong(ts)));\n}\nreturn new TsKvEntry(entry.getKey(), kvEntries);\n}).collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 47.223212283244145}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\\\"refreshToken\\\", refreshToken);\n\nString response = restTemplate.postForObject(baseURL + \\\"/api/auth/token\\\", requestMap, String.class);\n\nif (response!= null) {\nJSONObject responseJson = new JSONObject(response);\nrefreshToken = responseJson.getString(\\\"refreshToken\\\");\nmainToken = responseJson.getString(\\\"token\\\");\nmainTokenExpTs = responseJson.getLong(\\\"expTs\\\");\nrefreshTokenExpTs = responseJson.getLong(\\\"refreshExpTs\\\");\nclientServerTimeDiff = responseJson.getLong(\\\"clientServerTimeDiff\\\");\n}\n}", "CodeBleu_score": 26.666879312833718}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\\\"refreshToken\\\", refreshToken);\n\ntry {\nResponseEntity<Map> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/refresh\\\", requestMap, Map.class);\nMap<String, String> body = response.getBody();\nrefreshToken = body.get(\\\"refreshToken\\\");\nmainToken = body.get(\\\"token\\\");\nmainTokenExpTs = System.currentTimeMillis() + Long.parseLong(body.get(\\\"tokenExpTs\\\"));\nrefreshTokenExpTs = System.currentTimeMillis() + Long.parseLong(body.get(\\\"refreshTokenExpTs\\\"));\nclientServerTimeDiff = Long.parseLong(body.get(\\\"clientServerTimeDiff\\\"));\n} catch (Exception e) {\n\nthrow new ThingsboardRestException(\\\"Error while refreshing token\\\", e);\n\n}\n}", "CodeBleu_score": 28.26590637242835}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\\\"refreshToken\\\", refreshToken);\n\nHttpHeaders headers = new HttpHeaders();\nheaders.setContentType(MediaType.APPLICATION_JSON);\n\nHttpEntity<Map> request = new HttpEntity<>(requestMap, headers);\n\nResponseEntity<Map> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/token\\\", request, Map.class);\n\nMap<String, String> responseBody = response.getBody();\n\nif (responseBody!= null) {\nrefreshToken = responseBody.get(\\\"refreshToken\\\");\nmainToken = responseBody.get(\\\"token\\\");\nmainTokenExpTs = System.currentTimeMillis() + Long.parseLong(responseBody.get(\\\"tokenExpTs\\\"));\nrefreshTokenExpTs = System.currentTimeMillis() + Long.parseLong(responseBody.get(\\\"refreshTokenExpTs\\\"));\nclientServerTimeDiff = Long.parseLong(responseBody.get(\\\"clientServerTimeDiff\\\"));\n}\n}", "CodeBleu_score": 35.63480696626102}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t long ts = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", );\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 64.15678951856698}, {"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", );\n long ts = System.currentTimeMillis();\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 55.452447270068795}, {"code": " private void doLogin(){\n\t long ts = System.currentTimeMillis();\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", );\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 64.15678951856698}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 89.28734550304821}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 89.28734550304821}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 89.28734550304821}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.ofNullable(restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class).getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 51.480727922589395}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.ofNullable(restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class).getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 51.480727922589395}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.ofNullable(restTemplate.postForEntity(baseURL + \\\"/api/device-with-credentials\\\", new DeviceWithCredentials(device, credentials), Device.class).getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 33.54548586234277}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (typeof addr === \\\"undefined\\\") {\nthis.each(function(device) {\nthis.brightness(device, val);\n});\n} else {\nthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, val);\n}\nreturn this;\n}", "CodeBleu_score": 62.273112046021296}, {"code": "brightness(addr, val){\n\t\tif (typeof addr === \"undefined\") {\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tif (typeof val === \"undefined\") {\n\t\t\tval = addr;\n\t\t\taddr = 0;\n\t\t}\n\t\tthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, Math.round(val * 15 / 100));\n\t}\n\treturn this;\n}", "CodeBleu_score": 65.42014724920995}, {"code": "brightness(addr, val){\n\tif (typeof addr === \\\"undefined\\\") {\nthis.each(function(device) {\nthis.brightness(device, val);\n});\nreturn this;\n}\n\nif (typeof val === \\\"undefined\\\") {\nval = addr;\naddr = 0;\n}\n\nthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, val);\nreturn this;\n}", "CodeBleu_score": 60.95558463955988}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tlet device = Object.create(LedControl.prototype);\nObject.keys(LedControl.prototype).forEach(function(key) {\ndevice[key] = LedControl.prototype[key].bind(this, addr);\n}, this);\nObject.keys(this).forEach(function(key) {\ndevice[key] = this[key];\n}, this);\nreturn device;\n}", "CodeBleu_score": 36.10774430865167}, {"code": "device(addr){\n\t\n}", "CodeBleu_score": 1.622727129683248}, {"code": "device(addr){\n\t// create a new object with the bound methods\nlet bound = {};\n\n// iterate over the prototype of LedControl\nfor (let key in LedControl.prototype) {\n// if the key is not a function, continue\nif (typeof LedControl.prototype[key]!== \\\"function\\\") {\ncontinue;\n}\n\n// bind the function to the given address\nbound[key] = LedControl.prototype[key].bind(this, addr);\n}\n\n// iterate over the own properties of this object\nfor (let key in this) {\n// if the key is not a function, continue\nif (typeof this[key]!== \\\"function\\\") {\ncontinue;\n}\n\n// bind the function to the given address\nbound[key] = this[key].bind(this, addr);\n}\n\n// return the object with bound methods\nreturn bound;\n}", "CodeBleu_score": 54.09409832538087}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tonst duration = 1000;\n\tconst callback = noop;\n\tconst schedule = (method, duration) => {\n\t\treturn function(...args) {\n\t\t\tconst length = this.length;\n\t\t\tconst promises = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis[i][method](...args);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tPromise.all(promises).then(callback);\n\t\t};\n\t};\n\n\treturn methods.reduce((accum, method) => {\n\t\taccum[method] = schedule(method, duration);\n\t\treturn accum;\n\t}, target);\n}", "CodeBleu_score": 41.640615697313024}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tonst defaultDuration = 1000;\n\tconst duration = defaultDuration;\n\tconst promises = [];\n\tconst callback = () => {\n\t\treturn Promise.all(promises);\n\t};\n\tconst schedule = (method, duration = defaultDuration) => {\n\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tresolve(method());\n\t\t\t}, duration);\n\t\t}));\n\t};\n\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = defaultDuration) => {\n\t\t\ttarget.each(entry => {\n\t\t\t\tschedule(entry[method], duration);\n\t\t\t});\n\t\t\treturn callback();\n\t\t};\n\t});\n\treturn target;\n}", "CodeBleu_score": 29.81562483457144}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tonst duration = 1000;\n\tconst callback = (method, callback) => {\n\t\treturn function(...args) {\n\t\t\tlet promises = [];\n\t\t\tlet length = this.length;\n\t\t\tlet i = 0;\n\t\t\tfor (; i < length; i++) {\n\t\t\t\tpromises.push(this[i][method](...args));\n\t\t\t}\n\t\t\treturn Promise.all(promises).then(() => {\n\t\t\t\tif (typeof callback === \\\"function\\\") {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n\treturn Object.getOwnPropertyNames(target).reduce((accum, method) => {\n\t\tif (methods.includes(method)) {\n\t\t\taccum[method] = callback(method, noop);\n\t\t}\n\t\treturn accum;\n\t}, target);\n}", "CodeBleu_score": 37.6965143251589}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n\n// Initialize the input string\nstate.input = \\\"\\\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, (data) => {\nstate.input += data;\n\n// Split the input string into sentences\nconst sentences = state.input.split(\\\"\\\\r\\\n\\\");\n\n// Remove the last sentence from the input string\nstate.input = sentences.pop();\n\n// Process each sentence\nsentences.forEach((sentence) => {\nthis.parseNmeaSentence(sentence);\n});\n});\n}", "CodeBleu_score": 37.83547420713721}, {"code": "listen(){\n\tconst state = priv.get(this);\nconst port = this.io.serialPort(state.portId);\nconst input = \\\"\\\";\nlet incomplete = \\\"\\\";\n\n// Read data from the serial port and append it to the input string\nport.on(\\\"data\\\", data => {\ninput += data.toString();\n});\n\n// Split the input string into sentences based on the \"\\r\n\" delimiter\nconst sentences = input.split(\\\"\\\\r\\\n\\\");\n\n// Process each sentence\nfor (let i = 0; i < sentences.length - 1; i++) {\nconst sentence = sentences[i];\n\n// If the sentence is incomplete, append it to the incomplete string\nif (sentence.indexOf(\\\"$\\\")) {\nincomplete += sentence;\n} else {\n// If the sentence is complete, process it and clear the incomplete string\nif (incomplete.length > 0) {\nthis.parseNmeaSentence(incomplete);\nincomplete = \\\"\\\";\n}\n\n// Process the current sentence\nthis.parseNmeaSentence(sentence);\n}\n}\n\n// If there is an incomplete sentence, process it now\nif (incomplete.length > 0) {\nthis.parseNmeaSentence(incomplete);\nincomplete = \\\"\\\";\n}\n\n// Start a new read loop\nsetTimeout(() => {\nthis.listen();\n}, 0);\n}", "CodeBleu_score": 49.87123235691659}, {"code": "listen(){\n\t\nconst state = priv.get(this);\n\n// Initialize an empty input string\nlet input = \\\"\\\";\n\n// Start a read loop on the serial port\nthis.io.serialRead(state.portId, data => {\n\n// Append the data to the input string\ninput += String.fromCharCode(data);\n\n// Split the input string into sentences based on the \"\\r\n\" delimiter\nconst sentences = input.split(\\\"\\\\r\\\n\\\");\n\n// Process each sentence\nfor (let i = 0; i < sentences.length; ++i) {\n\n// Get the current sentence\nconst sentence = sentences[i];\n\n// If the sentence is not empty, process it\nif (sentence.length > 0) {\n\n// Call the \"parseNmeaSentence\" function to process the sentence\nthis.parseNmeaSentence(sentence);\n\n// If the sentence is incomplete, store it for the next read\n} else {\ninput = \\\"\\\";\n}\n}\n});\n}", "CodeBleu_score": 52.20800426306524}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size = 0;\n\tuint32_t channels = 0;\n\tuint32_t i;\n\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].channel_id >= AD559X_PIN_MAX) {\n\t\t\tLOG_ERR(\"invalid channel id %d\", sequence->channels[i].channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchannels |= BIT(sequence->channels[i].channel_id);\n\t}\n\n\tbuffer_size = channels * sequence->buffer_size;\n\n\tif (buffer_size > data->ctx.buffer_size) {\n\t\tLOG_ERR(\"buffer size %d is too small\", buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.746440995397734}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t active_channels = 0;\n\tuint8_t buffer_size = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].channel_id < AD559X_PIN_MAX) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * sizeof(uint16_t);\n\n\tif (buffer_size > data->ctx.sequence->buffer_size) {\n\t\tLOG_ERR(\"insufficient memory for buffer\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.7806335109978}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels = 0;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint16_t buffer_size = 0;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tchannels += sequence->channels[i].channel_id;\n\t}\n\n\tfor (j = 0; j < channels; j++) {\n\t\tfor (k = 0; k < data->channels; k++) {\n\t\t\tif (sequence->channels[j].channel_id == data->channels[k].channel_id) {\n\t\t\t\tfor (l = 0; l < data->channels[k].buffer_size; l++) {\n\t\t\t\t\tbuffer_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.72289787595185}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > AD559X_PIN_MAX) {\n\t\tLOG_ERR(\"Invalid channels %d\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = sequence->channels;\n\n\tadc_context_start(&data->ctx, &data->thread, data->buffer, data->channels);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn ret;\n}", "CodeBleu_score": 74.92019743947185}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tsize_t needed;\n\tint ret;\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"buffer size %d too small\", sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_context_set_buffer(&data->ctx, sequence->buffer, needed);\n\n\tret = adc_context_start(&data->ctx);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn ret;\n}", "CodeBleu_score": 63.75284495795264}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution %d, expected %d\", sequence->resolution, AD559X_ADC_RESOLUTION);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > AD559X_PIN_MAX) {\n\t\tLOG_ERR(\"Invalid number of channels %d, expected %d\", channels, AD559X_PIN_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = channels;\n\tdata->repeat_buffer = NULL;\n\n\tadc_context_start(&data->ctx, &data->thread, &data->sem, adc_ad559x_read_done,\n\t\t\t  adc_ad559x_read_next, data);\n\n\treturn adc_context_wait_for_completion(&data->ctx, K_FOREVER);\n}", "CodeBleu_score": 68.30369494313598}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tuint8_t channels = POPCOUNT(ctx->sequence->channels);\n\tuint16_t *buffer = ctx->sequence->buffer;\n\tuint16_t *repeat_buffer = data->repeat_buffer;\n\tuint8_t i;\n\n\tdata->channels = channels;\n\n\tfor (i = 0; i < channels; i++) {\n\t\trepeat_buffer[i] = buffer[i];\n\t}\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 56.604629677065724}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tuint8_t channels;\n\tuint8_t i;\n\n\t/* Set channels */\n\tdata->adc_conf = 0;\n\tchannels = POPCOUNT(sequence->channels);\n\tfor (i = 0; i < channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tdata->adc_conf |= BIT(i);\n\t\t}\n\t}\n\n\t/* Set repeat buffer */\n\tdata->repeat_buffer = sequence->buffer;\n}", "CodeBleu_score": 52.925598646928215}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tconst struct adc_sequence *sequence = ctx->sequence;\n\tuint8_t channels = POPCOUNT(sequence->channels);\n\tuint16_t *buffer = sequence->buffer;\n\tuint16_t *repeat_buffer = data->repeat_buffer;\n\tuint8_t i;\n\n\t/* Set the channels to be sampled */\n\tdata->adc_conf = 0;\n\tfor (i = 0; i < channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tdata->adc_conf |= BIT(i);\n\t\t}\n\t}\n\n\t/* Set the repeat buffer */\n\tfor (i = 0; i < channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\trepeat_buffer[i] = buffer[i];\n\t\t}\n\t}\n\n\t/* Release the semaphore to start sampling */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 52.14336270438494}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 83.69996608713699}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t} else {\n\t\tdata->buffer = ctx->sequence.buffer;\n\t}\n}", "CodeBleu_score": 76.76223031715924}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 83.69996608713699}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_sequence *sequence = &data->ctx.sequence;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tfor_each_set_bit(channel, &data->channels, AD559X_PIN_MAX) {\n\t\t\tuint16_t result;\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\\\"failed to read channel %d\\\", channel);\n\t\t\t\tadc_context_complete(&data->ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t*data->buffer++ = result;\n\t\t}\n\n\t\tadc_context_complete(&data->ctx);\n\t}\n}", "CodeBleu_score": 54.16547558330377}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tuint16_t *buffer = data->buffer;\n\tuint8_t channels = data->channels;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (uint8_t i = 0; i < channels; i++) {\n\t\t\tif (channels & BIT(i)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, i, buffer);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\\\"Failed to read channel %d\\\", i);\n\t\t\t\t\tadc_context_complete(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbuffer++;\n\t\t\t}\n\t\t}\n\t}\n\n\t\tadc_context_complete(ctx);\n}", "CodeBleu_score": 41.79567992792828}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channels;\n\tuint16_t val;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for a semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels */\n\t\tchannels = data->channels;\n\t\twhile (channels!= 0) {\n\t\t\t/* Get the channel ID */\n\t\t\tuint8_t channel = __builtin_ctz(channels);\n\n\t\t\t/* Read the ADC value */\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d failed to read\", channel);\n\t\t\t\tadc_context_complete(&data->ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Store the ADC value in the buffer */\n\t\t\t*data->buffer++ = val;\n\n\t\t\t/* Clear the channel bit */\n\t\t\tchannels &= ~(1 << channel);\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_complete(&data->ctx);\n\t}\n}", "CodeBleu_score": 50.84737710760685}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\tuint8_t config_reg;\n\n\trc = k_sem_take(&data->acq_sem, data->ready_time);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tif (config_reg & ADS1112_CONFIG_MASK_READY) {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.87605910726516}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t reg_val[2] = {0};\n\tint rc = 0;\n\tint retries = 0;\n\tint odr = 0;\n\n\t/* Wait for data ready */\n\tdo {\n\t\tk_sleep(data->ready_time);\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\todr = ads1112_acq_time_to_dr(dev, ADC_ACQ_TIME_DEFAULT);\n\t\tif (odr < 0) {\n\t\t\treturn odr;\n\t\t}\n\n\t\tif (reg_val[0] & ADS1112_CONFIG_MASK_READY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (retries++ > 100) {\n\t\t\tLOG_ERR(\"ADS1112 device timed out waiting for data ready\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} while (1);\n\n\treturn 0;\n}", "CodeBleu_score": 42.84553762981176}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t reg_val[2];\n\tint rc;\n\n\twhile (1) {\n\t\trc = k_sem_take(&data->acq_sem, data->ready_time);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val[0] & ADS1112_CONFIG_MASK_READY) {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 46.25970401704153}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t buffer_size = 0;\n\tuint32_t num_samplings = 0;\n\tuint32_t num_extra_samplings = 0;\n\tuint32_t i;\n\n\t/* Calculate the number of samplings based on the number of channels and the number of samplings per channel */\n\tnum_samplings = sequence->options & ADC_SEQ_OPTIONS_REPEAT_MASK;\n\tif (num_samplings == 0) {\n\t\tnum_samplings = 1;\n\t}\n\tnum_samplings *= sequence->channels;\n\n\t/* Calculate the number of extra samplings based on the number of extra samplings per channel */\n\tnum_extra_samplings = sequence->options & ADC_SEQ_OPTIONS_EXTRA_MASK;\n\tif (num_extra_samplings == 0) {\n\t\tnum_extra_samplings = 1;\n\t}\n\tnum_extra_samplings *= sequence->channels;\n\n\t/* Calculate the required buffer size based on the number of samplings and the number of extra samplings */\n\tbuffer_size = num_samplings + num_extra_samplings;\n\n\t/* Check if the buffer size is sufficient */\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is not sufficient for the specified sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.532644453595225}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t num_samplings = 0;\n\tuint16_t num_extra_samplings = 0;\n\tuint16_t num_samplings_per_channel = 0;\n\tuint16_t num_channels = 0;\n\tuint16_t buffer_size = 0;\n\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tnum_channels = sequence->options & ADC_SEQ_OPTIONS_MASK_CHANNELS;\n\tnum_extra_samplings = sequence->options & ADC_SEQ_OPTIONS_MASK_EXTRA_SAMPLING;\n\tnum_samplings = sequence->options & ADC_SEQ_OPTIONS_MASK_SAMPLING;\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnum_samplings_per_channel = num_samplings / num_channels;\n\n\tif (num_samplings_per_channel == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size = num_samplings_per_channel * num_channels;\n\tbuffer_size += num_extra_samplings;\n\n\tif (buffer_size < num_samplings) {\n\t\tLOG_ERR(\"Buffer size %d is not sufficient for %d samplings\", buffer_size, num_samplings);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.510629909942764}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t required_size = 0;\n\tuint16_t samplings = 0;\n\tuint16_t extra_samplings = 0;\n\tuint16_t i;\n\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tsamplings = sequence->options & ADC_SEQ_OPTIONS_SAMPLING_MASK;\n\textra_samplings = sequence->options & ADC_SEQ_OPTIONS_EXTRA_SAMPLING_MASK;\n\n\tif (samplings == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (samplings > 1) {\n\t\trequired_size = (samplings - 1) * (extra_samplings + 1);\n\t} else {\n\t\trequired_size = extra_samplings + 1;\n\t}\n\n\tif (required_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is not sufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.49496760955785}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t", "CodeBleu_score": 7.040677167376957}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\tif (wait) {\n\t\trc = k_sem_take(&data->acq_sem, K_FOREVER);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tadc_context_update_buffer_pointer(&data->ctx, sequence->options->extra_samplings > 0);\n\tadc_context_start_sampling(&data->ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 64.20014238352397}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\tif (sequence->channels!= BIT(0)) {\n\t\tLOG_ERR(\"Invalid Channel 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = ads1112_validate_buffer_size(sequence);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tdata->sequence = sequence;\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_sampling(&data->ctx);\n\n\tif (wait) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.606176634475}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\taudio_codec_apply_property(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 91.0673440888328}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\taudio_codec_apply_property(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 91.0673440888328}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Invalid state: %d\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\tret = i2s_trigger(config->comm_master, I2S_TRIGGER_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to start I2S: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Invalid state: %d\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tret = i2s_trigger(config->comm_master, I2S_TRIGGER_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to stop I2S: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid command: %d\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.21112038625863}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state!= MPXXDTYY_STATE_IDLE) {\n\t\t\tLOG_ERR(\"Invalid state for start command (%d)\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tret = i2s_configure(config->comm_master);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S configure failed (%d)\", ret);\n\t\t\tdata->state = MPXXDTYY_STATE_IDLE;\n\t\t\treturn ret;\n\t\t}\n\t\tret = i2s_start(config->comm_master);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S start failed (%d)\", ret);\n\t\t\tdata->state = MPXXDTYY_STATE_IDLE;\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Invalid state for stop command (%d)\", data->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = i2s_stop(config->comm_master);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Invalid DMIC trigger command (%d)\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 60.90402312214531}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tint ret;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state!= MPXXDTYY_STATE_STOPPED) {\n\t\t\tLOG_ERR(\"DMIC is not stopped\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_CMD_START);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"Failed to start DMIC (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state!= MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC is not active\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tret = i2s_trigger(config->comm_master, I2S_CMD_STOP);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"Failed to stop DMIC (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_STATE_STOPPED;\n\t} else {\n\t\tLOG_ERR(\"Invalid DMIC trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.59423480153239}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_POSITION_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 86.29737688291684}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_POSITION_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 90.40655435613981}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_POSITION_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 86.29737688291684}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t", "CodeBleu_score": 7.639466910398654}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint rc = 0;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = gpio_pin_get_dt(&config->busy_gpio, &config->busy_gpio_status);\n\n\treturn rc;\n}", "CodeBleu_score": 74.05695751988888}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tstruct auxdisplay_itron_data *data = dev->data;\n\tint rc = 0;\n\n\tif (data->busy_gpio.port) {\n\t\trc = gpio_pin_get_dt(&data->busy_gpio, &data->busy_gpio_status);\n\t} else {\n\t\trc = -ENOTSUP;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 54.25933876490039}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[3] = {SERLCD_BEGIN_SPECIAL_COMMAND, command, 0};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 76.12062481658461}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[3] = {SERLCD_BEGIN_SPECIAL_COMMAND, command, 0};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\n\treturn rc;\n}", "CodeBleu_score": 76.12062481658461}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[3] = {SERLCD_BEGIN_SPECIAL_COMMAND, command, 0};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 76.12062481658461}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\tsize_t mem_size = config->size;\n\n\tif (offset + size > mem_size) {\n\t\tLOG_ERR(\"Read operation would exceed memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, bbram_data->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 62.286421163654396}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tint ret;\n\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_dev = dev->data;\n\n\t/* Check if the requested read size is valid */\n\tif (size == 0 || size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation exceeds the memory bounds */\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the memory is in an invalid state */\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, data_dev->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 73.83551106845442}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint err;\n\n\tif (offset >= config->size) {\n\t\tLOG_ERR(\"Invalid offset %zu\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid size %zu\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_ptr->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.18553998049934}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tconst struct device *dev;\n\tconst char *dev_name;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_name = argv[1];\n\tdev = device_get_binding(dev_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_open(dev, DEVICE_MODE_ALL);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to open device %s: %d\", dev_name, ret);\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 63.580845705961366}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tconst struct device *dev;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_open(dev, DEVICE_MODE_ALL);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to open device %s\", argv[1]);\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 66.75308999450834}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_open(*bbram_dev, DEVICE_MODE_ALL);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to open device %s\", argv[1]);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 71.52067716388241}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tint err;\n\n\t/* Calculate number of bytes already read */\n\tint bytes_read = h4->rx.hdr_len - h4->rx.remaining;\n\n\t/* Read remaining bytes from UART FIFO */\n\terr = uart_fifo_read(cfg->uart, h4->rx.hdr + bytes_read, h4->rx.remaining);\n\tif (err < 0) {\n\t\tLOG_ERR(\"Unable to read H:4 header\");\n\t\treturn;\n\t}\n\n\t/* Update remaining byte count */\n\th4->rx.remaining -= err;\n}", "CodeBleu_score": 76.41510294522772}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tint ret;\n\n\t/* Calculate number of bytes already read */\n\tuint16_t n = h4->rx.hdr_len - h4->rx.remaining;\n\n\t/* Read remaining bytes from UART FIFO */\n\tret = uart_fifo_read(cfg->uart, &h4->rx.hdr[n], h4->rx.remaining);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Unable to read H:4 header\");\n\t\treturn;\n\t}\n\n\t/* Update remaining byte count */\n\th4->rx.remaining -= ret;\n}", "CodeBleu_score": 60.25143011744494}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tuint16_t bytes_read = 0;\n\tuint16_t remaining = h4->rx.remaining;\n\tuint16_t discard = h4->rx.discard;\n\n\t/* Get the number of bytes already read */\n\tif (h4->rx.have_hdr) {\n\t\tbytes_read = h4->rx.hdr_len - h4->rx.discard;\n\t}\n\n\t/* Read the remaining bytes from the UART FIFO */\n\tif (uart_fifo_read(cfg->uart, h4->rx.hdr + bytes_read, remaining)!= remaining) {\n\t\tLOG_WRN(\"Unable to read H:4 header\");\n\t\treturn;\n\t}\n\n\t/* Update the remaining byte count based on the number of bytes successfully read */\n\tremaining -= bytes_read;\n\th4->rx.remaining = remaining;\n\th4->rx.discard = discard;\n\th4->rx.have_hdr = true;\n}", "CodeBleu_score": 61.8699735333192}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t bytes_read = 0;\n\tsize_t total_bytes_read = 0;\n\tuint8_t temp_buf[33];\n\n\twhile (total_bytes_read < len) {\n\t\tbytes_read = uart_fifo_read(uart, temp_buf, sizeof(temp_buf));\n\t\tif (bytes_read < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", bytes_read);\n\t\t\treturn 0;\n\t\t}\n\t\ttotal_bytes_read += bytes_read;\n\t}\n\n\treturn total_bytes_read;\n}", "CodeBleu_score": 46.9317460349863}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t total = 0;\n\tsize_t remaining = len;\n\tuint8_t buffer[33];\n\tsize_t bytes_read;\n\tint ret;\n\n\twhile (remaining > 0) {\n\t\tif (remaining > 33) {\n\t\t\tbytes_read = 33;\n\t\t} else {\n\t\t\tbytes_read = remaining;\n\t\t}\n\n\t\tret = uart_fifo_read(uart, buffer, bytes_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tremaining -= ret;\n\t\ttotal += ret;\n\t}\n\n\treturn total;\n}", "CodeBleu_score": 38.08777197251108}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t bytes_read = 0;\n\tsize_t bytes_remaining = len;\n\tuint8_t *temp_buf = (uint8_t *)k_malloc(sizeof(uint8_t) * 33);\n\tif (temp_buf == NULL) {\n\t\tLOG_ERR(\"Failed to allocate memory for temporary buffer.\");\n\t\treturn 0;\n\t}\n\twhile (bytes_remaining) {\n\t\tint ret = uart_fifo_read(uart, temp_buf, 33);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART: %d\", ret);\n\t\t\treturn 0;\n\t\t}\n\t\tbytes_remaining -= ret;\n\t\tbytes_read += ret;\n\t}\n\tk_free(temp_buf);\n\treturn bytes_read;\n}", "CodeBleu_score": 37.134703046017}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint16_t highest_priority = ZBUS_OBSERVER_PRIORITY_MAX;\n\tint16_t priority;\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\t/* Static observer event dispatcher logic */\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;\n\t     i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t_ZBUS_ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriority = obs->data->priority;\n\n\t\tif (priority < highest_priority) {\n\t\t\thighest_priority = priority;\n\t\t}\n\t}\n\n#if defined(CONFIG_ZBUS_RUNTIME_OBSERVERS)\n\t/* Dynamic observer event dispatcher logic */\n\tstruct zbus_observer_node *obs_nd;\n\tSYS_SLIST_FOR_EACH_CONTAINER(&chan->data->observers, obs_nd, node) {\n\t\tconst struct zbus_observer *obs = obs_nd->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriority = obs->data->priority;\n\n\t\tif (priority < highest_priority) {\n\t\t\thighest_priority = priority;\n\t\t}\n\t}\n#endif /* CONFIG_ZBUS_RUNTIME_OBSERVERS */\n\n\tchan->data->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 74.0799876140075}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tconst struct zbus_channel_data *data = chan->data;\n\tconst struct zbus_observer_node *obs_nd, *tmp;\n\tint16_t highest_priority = 0;\n\n\t_ZBUS_ASSERT(data!= NULL, \"data must be not NULL\");\n\n\t_zbus_lock(data);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&data->observers, obs_nd, tmp, node) {\n\t\tconst struct zbus_observer *obs = obs_nd->obs;\n\n\t\t_ZBUS_ASSERT(obs!= NULL, \"obs must be not NULL\");\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->priority < highest_priority) {\n\t\t\tcontinue;\n\t\t}\n\n\t\thighest_priority = obs->priority;\n\t}\n\n\t_zbus_unlock(data);\n\n\tchan->data->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 33.85601842848772}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *data = chan->data;\n\tconst struct zbus_observer *highest_observer = NULL;\n\tint16_t highest_observer_priority = INT16_MAX;\n\n\t/* Lock the channel data */\n\tk_mutex_lock(&data->lock, K_FOREVER);\n\n\t/* Iterate through the observers, checking each observer's priority and whether it is enabled */\n\tfor (int16_t i = 0; i < data->observers_end_idx; i++) {\n\t\tstruct zbus_channel_observation *observation;\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->data->priority < highest_observer_priority) {\n\t\t\thighest_observer = obs;\n\t\t\thighest_observer_priority = obs->data->priority;\n\t\t}\n\t}\n\n\t/* Set the channel's highest observer priority to the determined value */\n\tdata->highest_observer_priority = highest_observer_priority;\n\n\t/* Unlock the channel data */\n\tk_mutex_unlock(&data->lock);\n}", "CodeBleu_score": 53.90844261191666}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channels_end_idx;\n\n\t\tfor (int16_t i = _zbus_channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_observer *obs_in_chan = observation->obs;\n\n\t\t\tif (!obs_in_chan->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (obs_in_chan == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.105371875014967}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channels_end_idx;\n\n\t\tfor (int16_t i = _zbus_channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_observer *chan_obs = observation->obs;\n\n\t\t\tif (!chan_obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.16644223809724}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_count;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_observer *observation_obs = observation->obs;\n\n\t\t\tif (!observation_obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation_obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.255946704183565}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\nint current_thread_priority = k_thread_priority_get(k_current_get());\n\nK_SPINLOCK(&obs_slock) {\n\tif (obs->data->priority!= current_thread_priority) {\n\t\tobs->data->priority = current_thread_priority;\n\n\t\tupdate_all_channels_hop(obs);\n\t}\n}\n\nreturn 0;\n}", "CodeBleu_score": 68.80363433677611}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tif (chan->validator!= NULL &&!chan->validator(chan->message, chan->message_size)) {\n\t\treturn -ENOMSG;\n\t}\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 88.2246880682945}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tif (chan->validator!= NULL &&!chan->validator(chan->message, chan->message_size)) {\n\t\treturn -ENOMSG;\n\t}\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 88.2246880682945}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tif (chan->validator!= NULL &&!chan->validator(chan->message, chan->message_size)) {\n\t\treturn -ENOMSG;\n\t}\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 88.2246880682945}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_IT(Int));\n\tif (enable) {\n\t\tif (Int & ETH_IT_NORMAL) {\n\t\t\tETH->NIE_b.NIE = TRUE;\n\t\t}\n\t\tif (Int & ETH_IT_ABNORMAL) {\n\t\t\tETH->AIE_b.AIE = TRUE;\n\t\t}\n\t} else {\n\t\tif (Int & ETH_IT_NORMAL) {\n\t\t\tETH->NIE_b.NIE = FALSE;\n\t\t}\n\t\tif (Int & ETH_IT_ABNORMAL) {\n\t\t\tETH->AIE_b.AIE = FALSE;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.00341000980937}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_IT(Int));\n\tassert_param(IS_BOOL(enable));\n\n\tif (enable) {\n\t\tif (Int & ETH_IT_NORMAL) {\n\t\t\tETH->NIE |= Int & ETH_IT_NORMAL;\n\t\t}\n\n\t\tif (Int & ETH_IT_ABNORMAL) {\n\t\t\tETH->AIE |= Int & ETH_IT_ABNORMAL;\n\t\t}\n\t} else {\n\t\tif (Int & ETH_IT_NORMAL) {\n\t\t\tETH->NIE &= ~(Int & ETH_IT_NORMAL);\n\t\t}\n\n\t\tif (Int & ETH_IT_ABNORMAL) {\n\t\t\tETH->AIE &= ~(Int & ETH_IT_ABNORMAL);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.105986390105706}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESLA;\n\tETH_TX_DESC *buf = desc;\n\n\tdo {\n\t\tif (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n\t\t\treturn desc;\n\t\t}\n\n\t\tdesc = (ETH_TX_DESC *)desc->nextDescAddr;\n\t} while (desc!= buf);\n\n\treturn 0;\n}", "CodeBleu_score": 61.14155496203655}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESLA;\n\tuint32_t tmp;\n\tuint8_t first, last;\n\n\tif (!desc) {\n\t\treturn 0;\n\t}\n\n\tif (ETH->OPERATION_b.ST) {\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\ttmp = desc->bufAddr;\n\t\tfirst = desc->TX_0.TX0_b.FS;\n\t\tlast = desc->TX_0.TX0_b.LS;\n\n\t\tif (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n\t\t\tif (first == last) {\n\t\t\t\t// clear all bits\n\t\t\t\tdesc->TX_0.TX0 = 0;\n\t\t\t\tdesc->TX_0.TX0_b.FS = first;\n\t\t\t\tdesc->TX_0.TX0_b.LS = last;\n\t\t\t\tdesc->TX_0.TX0_b.TCH = TRUE;\n\t\t\t\tdesc->TX_0.TX0_b.IC = TRUE;\n\t\t\t\tdesc->TX_0.TX0_b.OWN = ETH_DESC_OWN_BY_SELF;\n\n\t\t\t\tdesc->bufAddr = GLB_ConvertToMappingFromAddr(desc->bufAddr);\n\t\t\t\tdesc->nextDescAddr = GLB_ConvertToMappingFromAddr(desc->nextDescAddr);\n\n\t\t\t\treturn desc;\n\t\t\t}\n\t\t}\n\n\t\tdesc = (ETH_TX_DESC *)desc->nextDescAddr;\n\t} while (desc!= (ETH_TX_DESC *)ETH->TDESLA);\n\n\treturn 0;\n}", "CodeBleu_score": 51.832394402257734}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t", "CodeBleu_score": 2.546149641071209}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trslt_t result;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\t/* get current dac channel*/\n\tcy_rslt_t result = Cy_CSDIDAC_OutputEnable(cyp_dac_get_channel(channel), value, &csdidac_context);\n\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 62.59402669357145}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trslt_t result;\n\n\trt_uint32_t cyp_channel;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\t/* get current dac channel*/\n\tcyp_channel = cyp_dac_get_channel(channel);\n\n\t/*DAC device init*/\n\tresult = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\n\t/*DAC output enable*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 64.63733166061537}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trslt_t result;\n\n\trt_uint32_t cyp_channel;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyhal_dac_t *dac_device;\n\n\tdac_device = device->parent.user_data;\n\n\t/* get current dac channel*/\n\tcyp_channel = cyp_dac_get_channel(channel);\n\n\t/*DAC device init*/\n\tresult = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\n\t/*DAC free device*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 64.63733166061537}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page_addr = 0;\n\trt_uint32_t i = 0;\n\trt_uint32_t j = 0;\n\trt_uint8_t *ptr = buf;\n\n\tif ((addr + size) > (block_info.start + block_info.size)) {\n\t\tLOG_E(\"Read address exceeds the flash memory's end address.\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i += 4) {\n\t\tpage_addr = get_page_32k(addr + i);\n\t\tcyhal_flash_read_data(&flash_obj, page_addr, ptr, 4);\n\t\tptr += 4;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 47.14215959355536}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page = 0;\n\trt_uint32_t page_end = 0;\n\trt_uint32_t offset = 0;\n\trt_uint32_t read_size = 0;\n\trt_uint8_t *read_addr = NULL;\n\n\t/* Check the address */\n\tif (addr + size > block_info.end_address) {\n\t\tLOG_E(\"Read addr out of range\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tpage = get_page_32k(addr);\n\tpage_end = get_page_32k(addr + size);\n\n\t/* Read data from flash */\n\twhile (page <= page_end) {\n\t\t/* Get the read address */\n\t\tread_addr = (rt_uint8_t *)page;\n\n\t\t/* Get the read size */\n\t\tif (page_end == page) {\n\t\t\tread_size = size % IFX_EFLASH_PAGE_SIZE;\n\t\t} else {\n\t\t\tread_size = IFX_EFLASH_PAGE_SIZE;\n\t\t}\n\n\t\t/* Read data from flash */\n\t\tmemcpy(buf + offset, read_addr, read_size);\n\n\t\t/* Update the read address and offset */\n\t\toffset += read_size;\n\t\tread_addr += read_size;\n\t\tpage += IFX_EFLASH_PAGE_SIZE;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 40.257370544190415}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 34.073364357991565}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 34.073364357991565}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 34.073364357991565}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t nr;\nint index;\nstruct dfs_file **fds = NULL;\n\nif (startfd < fdt->maxfd) {\nfor (index = startfd; index < fdt->maxfd; index++) {\nif (!fdt->fds[index]) {\nreturn index;\n}\n}\n}\nif (startfd >= DFS_FD_MAX) {\nreturn -1;\n}\n\nnr = ((startfd + 4) & ~3);\nif (nr > DFS_FD_MAX) {\nnr = DFS_FD_MAX;\n}\nfds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\nif (!fds) {\nreturn -1;\n}\n\n/* clean the new allocated fds */\nfor (index = fdt->maxfd; index < nr; index++) {\nfds[index] = NULL;\n}\nfdt->fds   = fds;\nfdt->maxfd = nr;\n\nreturn startfd;\n}", "CodeBleu_score": 47.13348679419476}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t nr;\nint index;\nstruct dfs_file **fds = NULL;\n\nif (startfd < fdt->maxfd) {\nfor (index = startfd; index < fdt->maxfd; index++) {\nif (!fdt->fds[index]) {\nreturn index;\n}\n}\n}\n\nnr = ((startfd + 4) & ~3);\nif (nr > DFS_FD_MAX) {\nnr = DFS_FD_MAX;\n}\nfds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\nif (!fds) {\nreturn -1;\n}\n\n/* clean the new allocated fds */\nfor (index = fdt->maxfd; index < nr; index++) {\nfds[index] = NULL;\n}\nfdt->fds   = fds;\nfdt->maxfd = nr;\n\nreturn startfd;\n}", "CodeBleu_score": 45.65459811109225}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t nr;\nint index;\nstruct dfs_file **fds = NULL;\n\nif (startfd < fdt->maxfd) {\nfor (index = startfd; index < fdt->maxfd; index++) {\nif (fdt->fds[index] == NULL) {\nreturn index;\n}\n}\n}\n\nnr = ((startfd + 4) & ~3);\nif (nr > DFS_FD_MAX) {\nnr = DFS_FD_MAX;\n}\nfds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\nif (!fds) {\nreturn -1;\n}\n\n/* clean the new allocated fds */\nfor (index = fdt->maxfd; index < nr; index++) {\nfds[index] = NULL;\n}\nfdt->fds = fds;\nfdt->maxfd = nr;\n\nreturn startfd;\n}", "CodeBleu_score": 45.794731266986425}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++) {\n\t\tif (rt_errno_strs[i].error == error) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 76.48796774236426}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t err;\n\trt_size_t i;\n\n\tif (error < 0) {\n\t\terr = -error;\n\t} else {\n\t\terr = error;\n\t}\n\n\tfor (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++) {\n\t\tif (rt_errno_strs[i].error == err) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 71.0325727264641}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t err;\n\trt_uint8_t i;\n\n\t/* convert error code to positive value if it is negative */\n\tif (error < 0) {\n\t\terr = -error;\n\t} else {\n\t\terr = error;\n\t}\n\n\t/* search for error string in the array */\n\tfor (i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n\t\tif (rt_errno_strs[i].error == err) {\n\t\t\treturn rt_errno_strs[i].str;\n\t\t}\n\t}\n\n\t/* return unknown error string */\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 62.514557227232736}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = -RT_EFULL;\n\trt_base_t level;\n\n\t/* lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\trt_spinlock_take(&_hook_spinlock, RT_WAITING_FOREVER);\n\n\t/* find a empty slot */\n\tfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock the spinlock */\n\trt_spinlock_release(&_hook_spinlock);\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 68.36849124302302}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result = RT_EOK;\nrt_base_t level;\n\n/*\n * Lock the spinlock to ensure thread safety.\n */\nlevel = rt_hw_interrupt_disable();\n\n/*\n * Iterate through the idle hook list to find an empty slot.\n */\nfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\nif (idle_hook_list[i] == RT_NULL) {\nidle_hook_list[i] = hook;\nbreak;\n}\n}\n\n/*\n * If no empty slot is available, return an error code.\n */\nif (idle_hook_list[RT_IDLE_HOOK_LIST_SIZE - 1] == RT_NULL) {\nresult = -RT_EFULL;\n}\n\n/*\n * Release the spinlock and return the result.\n */\nrt_hw_interrupt_enable(level);\nreturn result;\n}", "CodeBleu_score": 52.4145977704949}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t ret = -RT_EFULL;\nrt_base_t level;\n\nlevel = rt_hw_interrupt_disable();\n\nif (rt_list_isempty(&_rt_thread_defunct)) {\nrt_list_insert_after(&_rt_thread_defunct, &(idle_thread[0].tlist));\nrt_hw_interrupt_enable(level);\n\nret = RT_EOK;\n} else {\nrt_list_t *list = &_rt_thread_defunct;\n\nwhile (!rt_list_isempty(list)) {\nrt_list_t *next = list->next;\n\nif (idle_hook_list[list - &_rt_thread_defunct] == RT_NULL) {\nidle_hook_list[list - &_rt_thread_defunct] = hook;\nret = RT_EOK;\nbreak;\n}\n\nlist = next;\n}\n}\n\nif (ret!= RT_EOK) {\nrt_hw_interrupt_enable(level);\n}\n\nreturn ret;\n}", "CodeBleu_score": 52.87114082799097}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_base_t level;\n\trt_err_t ret = -RT_ENOSYS;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 87.2455563769329}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_base_t level;\n\trt_err_t ret = -RT_ENOSYS;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 87.2455563769329}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_base_t level;\n\trt_err_t ret = -RT_ENOSYS;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 87.2455563769329}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\",\n\t\t\t\t\t__func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.00937036070866}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.07326881772602}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\",\n\t\t\t\t\t__func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.00937036070866}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t#ifdef RT_USING_DEVICE\n    rt_device_t device = RT_NULL;\n    rt_device_t old_device = _console_device;\n\n    if (name) {\n        device = rt_device_find(name);\n        if (device) {\n            if (device!= old_device) {\n                if (old_device) {\n                    rt_device_close(old_device);\n                }\n                rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n                _console_device = device;\n            }\n        }\n    }\n\n    return old_device;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 62.04462878955381}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console_device = _console_device;\n\trt_device_t new_console_device;\n\n\tif (name == RT_NULL) {\n\t\t/* set console device to NULL */\n\t\tif (_console_device!= RT_NULL) {\n\t\t\t/* close the old console device */\n\t\t\trt_device_close(_console_device);\n\t\t\t_console_device = RT_NULL;\n\t\t}\n\t} else {\n\t\t/* set console device to new device */\n\t\tnew_console_device = rt_device_find(name);\n\t\tif (new_console_device!= RT_NULL) {\n\t\t\tif (new_console_device!= _console_device) {\n\t\t\t\t/* close the old console device */\n\t\t\t\tif (_console_device!= RT_NULL) {\n\t\t\t\t\trt_device_close(_console_device);\n\t\t\t\t}\n\t\t\t\t/* open the new console device */\n\t\t\t\trt_device_open(new_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM);\n\t\t\t\t_console_device = new_console_device;\n\t\t\t}\n\t\t} else {\n\t\t\t/* new device is not found */\n\t\t\trt_kprintf(\\\"Console device \\\"%s\\\" is not found.\n\\\", name);\n\t\t}\n\t}\n\treturn old_console_device;\n}", "CodeBleu_score": 56.986328835816}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t#ifdef RT_USING_DEVICE\n    rt_device_t old_device = RT_NULL;\n    rt_device_t new_device = RT_NULL;\n\n    /* get the old device */\n    old_device = rt_console_get_device();\n\n    /* get the new device */\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        return old_device;\n    }\n\n    /* check if the new device is the same as the old device */\n    if (old_device!= new_device) {\n        /* close the old device */\n        if (old_device!= RT_NULL) {\n            rt_device_close(old_device);\n        }\n\n        /* open the new device */\n        if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM)!= RT_EOK) {\n            return old_device;\n        }\n\n        /* set the new device as the console device */\n        _console_device = new_device;\n    }\n\n    return old_device;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 67.86944441785455}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\tfor (index = 0; index < RT_Object_Info_Unknown; index++)\n\t\tif (_object_container[index].type == type)\n\t\t\treturn _object_container[index].length;\n\n\treturn 0;\n}", "CodeBleu_score": 19.836148022719286}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\tint length = 0;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\tfor (index = 0; index < RT_Object_Info_Unknown; index++)\n\t\tif (_object_container[index].type == type) {\n\t\t\tlength++;\n\t\t}\n\n\treturn length;\n}", "CodeBleu_score": 21.539161241051417}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\tint count = 0;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\trt_spin_lock(&_object_container[RT_Object_Info_Unknown].lock);\n\n\tfor (index = 0; index < RT_Object_Info_Unknown; index ++) {\n\t\tif (_object_container[index].type == type) {\n\t\t\tcount ++;\n\t\t}\n\t}\n\n\trt_spin_unlock(&_object_container[RT_Object_Info_Unknown].lock);\n\n\treturn count;\n}", "CodeBleu_score": 37.87323091552474}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n\tstruct rt_object_information *information;\n\tstruct rt_list_node *node;\n\n#ifdef RT_DEBUGING_ASSERT\n\tRT_ASSERT(object!= RT_NULL);\n#endif /* RT_DEBUGING_ASSERT */\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type & ~RT_Object_Class_Static);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* enter critical */\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\t/* try to find object */\n\tfor (node  = information->object_list.next;\n\t\t\tnode!= &(information->object_list);\n\t\t\tnode  = node->next) {\n\t\tstruct rt_object *obj;\n\n\t\tobj = rt_list_entry(node, struct rt_object, list);\n\t\tRT_ASSERT(obj!= object);\n\t}\n\t/* leave critical */\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* enter critical */\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\t/* remove object from list */\n\trt_list_remove(&(object->list));\n\t/* leave critical */\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\tobject->type = 0;\n}", "CodeBleu_score": 72.16179534007716}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n#ifdef RT_DEBUGING_ASSERT\n\tstruct rt_list_node *node = RT_NULL;\n#endif /* RT_DEBUGING_ASSERT */\n\tstruct rt_object_information *information;\n\tRT_ASSERT(object!= RT_NULL);\n\tRT_ASSERT(object->type & RT_Object_Class_Static);\n\tRT_ASSERT(object->type & RT_Object_Class_Thread);\n\tRT_ASSERT(object->type & RT_Object_Class_Static);\n\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n#ifdef RT_DEBUGING_ASSERT\n\t/* check object type to avoid re-detachment */\n\tfor (node  = information->object_list.next;\n\t\t\tnode!= &(information->object_list);\n\t\t\tnode  = node->next) {\n\t\tstruct rt_object *obj;\n\n\t\tobj = rt_list_entry(node, struct rt_object, list);\n\t\tRT_ASSERT(obj!= object);\n\t}\n#endif /* RT_DEBUGING_ASSERT */\n\trt_list_remove(&(object->list));\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n}", "CodeBleu_score": 61.52882246141521}, {"code": "void rt_object_detach(rt_object_t object){\n\t#ifdef RT_DEBUGING_ASSERT\n    RT_ASSERT(object!= RT_NULL);\n#endif /* RT_DEBUGING_ASSERT */\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n    struct rt_object_information *information = RT_NULL;\n    rt_base_t level;\n\n    /* get object information */\n    information = rt_object_get_information(object->type);\n    RT_ASSERT(information!= RT_NULL);\n\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove object from information object list */\n    rt_list_remove(&(object->list));\n\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    /* set object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 72.83877035259869}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tstruct rt_custom_object *cobj;\n\trt_err_t result = RT_EOK;\n\n\t/* parameter check */\n\tif ((obj == RT_NULL) || (obj->type!= RT_Object_Class_Custom)) {\n\t\treturn -RT_EINVAL;\n\t}\n\n\tcobj = (struct rt_custom_object *)obj;\n\tif (cobj->destroy) {\n\t\tresult = cobj->destroy(cobj->data);\n\t}\n\n\trt_object_delete(obj);\n\treturn result;\n}", "CodeBleu_score": 65.9906979571754}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = -RT_EINVAL;\n\tstruct rt_custom_object *cobj = RT_NULL;\n\n\t/* parameter check */\n\tif (obj!= RT_NULL) {\n\t\tcobj = (struct rt_custom_object *)obj;\n\t\tif (cobj->destroy) {\n\t\t\tresult = cobj->destroy(cobj->data);\n\t\t}\n\t\trt_object_delete(obj);\n\t}\n\treturn result;\n}", "CodeBleu_score": 60.062274372006094}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\nstruct rt_custom_object *cobj = (struct rt_custom_object *)obj;\nif (cobj!= RT_NULL) {\nif (cobj->destroy!= RT_NULL) {\nresult = cobj->destroy(cobj->data);\n}\nrt_object_delete(obj);\n}\nreturn result;\n}", "CodeBleu_score": 60.39614430976778}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n\tthread = rt_thread_self();\n\n\t/* enter critical section */\n\trt_enter_critical();\n\n\t/* close the thread */\n\trt_thread_close(thread);\n\n\t/* add the thread to the defunct thread list */\n\trt_thread_list_insert(&rt_thread_defunct_list, thread);\n\n\t/* trigger the context switch */\n\trt_schedule();\n\n\t/* exit critical section */\n\trt_exit_critical();\n\n\t/* never reach here */\n\treturn;\n}", "CodeBleu_score": 35.264232153104814}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\trt_uint32_t level;\n\n\tthread = rt_thread_self();\n\t/* enter critical */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* set thread to defunct */\n\tthread->stat = RT_THREAD_CLOSE;\n\n\t/* add thread to defunct list */\n\trt_list_insert_before(&(rt_thread_defunct_list), &(thread->tlist));\n\n\t/* exit critical */\n\trt_hw_interrupt_enable(level);\n\n\t/* switch to next thread */\n\trt_schedule();\n}", "CodeBleu_score": 59.32349390685361}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\trt_base_t critical_level;\n\n\tthread = (struct rt_thread *)parameter;\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\n\tcritical_level = rt_enter_critical();\n\n\t/* check thread is suspended */\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_set_errno(RT_EOK);\n\t\tgoto _exit;\n\t}\n\n\t/* set thread error number to timeout */\n\tthread->error = RT_ETIMEOUT;\n\n\t/* remove from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert to ready list */\n\trt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]), &(thread->tlist));\n\n\t/* set thread state to ready */\n\tthread->stat = RT_THREAD_READY;\n\n\t/* reschedule */\n\trt_schedule();\n\n_exit:\n\trt_exit_critical_safe(critical_level);\n}", "CodeBleu_score": 47.14097674381814}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\t/* get current thread */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* check parameter */\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check thread is suspended */\n\tif (thread->stat & RT_THREAD_SUSPEND_MASK) {\n\t\t/* set thread error */\n\t\tthread->error = RT_ETIMEOUT;\n\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->thread_list));\n\n\t\t/* insert thread to ready list */\n\t\trt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]), &(thread->thread_list));\n\n\t\t/* unlock scheduler */\n\t\trt_hw_interrupt_enable(level);\n\t} else {\n\t\t/* unlock scheduler */\n\t\trt_hw_interrupt_enable(level);\n\t}\n}", "CodeBleu_score": 47.72797760506913}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\tthread = (struct rt_thread *)parameter;\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check thread status */\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* set thread error */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert to ready list */\n\trt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]), &(thread->tlist));\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 55.37280900083547}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\ttruct rt_mutex *mutex;\n\tstruct rt_thread *thread_next;\n\tstruct rt_list_node *node;\n\trt_base_t level;\n\n\t/* lock the thread spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if the thread is waiting on a mutex */\n\tif (thread->mutex!= RT_NULL) {\n\t\tmutex = thread->mutex;\n\n\t\t/* remove the thread from the mutex's waiting list */\n\t\tnode = rt_list_prev(&mutex->wait_list);\n\t\tthread_next = rt_list_entry(node, struct rt_thread, wait_node);\n\t\trt_list_remove(&thread->wait_node);\n\t\tmutex->owner = thread_next;\n\n\t\t/* clear the pending object */\n\t\tthread->mutex = RT_NULL;\n\t}\n\n\t/* unlock the thread spinlock */\n\trt_hw_interrupt_enable(level);\n\n\t/* release all mutexes the thread has taken */\n\twhile (thread->mutex_list!= RT_NULL) {\n\t\tmutex = thread->mutex_list;\n\t\tthread->mutex_list = mutex->next;\n\t\tmutex->next = RT_NULL;\n\t\trt_mutex_release(mutex);\n\t}\n}", "CodeBleu_score": 50.6768554089007}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\ttruct rt_mutex *mutex;\n\tstruct rt_thread *cur_thread;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get current thread */\n\tcur_thread = rt_thread_self();\n\n\t/* check if thread is waiting on a mutex */\n\tmutex = rt_mutex_control(thread, RT_THREAD_CTRL_GET_MUTEX, RT_NULL);\n\tif (mutex!= RT_NULL) {\n\t\t/* remove thread from mutex waiting list */\n\t\trt_mutex_control(mutex, RT_MUTEX_CTRL_DETACH_THREAD, thread);\n\t\t/* clear pending object */\n\t\trt_mutex_control(mutex, RT_MUTEX_CTRL_CLEAR_PENDING, RT_NULL);\n\t}\n\n\t/* restore spinlock */\n\trt_hw_interrupt_enable(level);\n\n\t/* release all mutexes the thread has taken */\n\trt_mutex_control(thread, RT_THREAD_CTRL_RELEASE_MUTEX, RT_NULL);\n}", "CodeBleu_score": 37.269430152788885}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tt_base_t level;\n\tstruct rt_mutex *mutex;\n\tstruct rt_mutex_list *mutex_list;\n\n\t/* lock the thread spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if the thread is waiting on a mutex */\n\tmutex_list = rt_list_entry(thread->mutex_list.next, struct rt_mutex_list, thread_list);\n\tif (mutex_list!= RT_NULL) {\n\t\t/* remove from mutex waiting list */\n\t\trt_list_remove(&mutex_list->thread_list);\n\t\t/* clear the pending object */\n\t\tmutex_list->mutex = RT_NULL;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\twhile (thread->mutex_list.next!= &thread->mutex_list) {\n\t\tmutex_list = rt_list_entry(thread->mutex_list.next, struct rt_mutex_list, thread_list);\n\t\tmutex = mutex_list->mutex;\n\t\t/* remove from mutex waiting list */\n\t\trt_list_remove(&mutex_list->thread_list);\n\t\t/* release the mutex */\n\t\trt_mutex_release(mutex);\n\t}\n\n\t/* restore the thread spinlock */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 47.485963846950234}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n\t/* log thread information */\n\trt_kprintf(\"thread: %s, priority: %d\n\", thread->parent.name, thread->current_priority);\n\n\t/* calculate thread priority attributes */\n\trt_uint32_t priority_attr = rt_thread_priority_get_attr(thread->current_priority);\n\n\t/* reset thread state */\n\tthread->status = RT_THREAD_INIT;\n\tthread->suspend_tick = 0;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler */\n\trt_schedule_insert_thread(thread, priority_attr);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 44.7847035059971}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\n\trt_kprintf(\"thread %s priority %d\n\", thread->parent.name, thread->parent.priority);\n\trt_thread_priority_set(thread, thread->parent.priority);\n\tthread->parent.flag &= ~RT_THREAD_INIT;\n\tthread->parent.flag |= RT_THREAD_SUSPEND;\n\trt_thread_resume(thread);\n\trt_thread_scheduler_resume();\n\treturn RT_EOK;\n}", "CodeBleu_score": 43.207769750312565}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_list_t *node;\n\tstruct rt_timer *timer;\n\n\t/* get the highest level of the timer skip list */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (!rt_list_isempty(list)) {\n\t\t/* get the first timer entry */\n\t\tnode = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t\t/* set the provided timeout tick to the timer's timeout value */\n\t\t*timeout_tick = node->timeout_tick;\n\n\t\t/* return RT_EOK */\n\t\treturn RT_EOK;\n\t}\n\n\t/* return RT_ERROR */\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 64.24178716905273}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\tstruct rt_timer *timer;\n\n\t/* get the first timer entry */\n\tlist = rt_list_first(&(timer_list[0]));\n\tif (list == RT_NULL) {\n\t\t/* no timer entry */\n\t\treturn -RT_ERROR;\n\t}\n\n\ttimer = rt_list_entry(list, struct rt_timer, row[0]);\n\n\t/* set timeout tick */\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 51.13378011868668}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_entry;\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the first timer entry */\n\ttimer_entry = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t/* set the timeout tick to the timer's timeout value */\n\t*timeout_tick = timer_entry->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 74.43528413943609}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* parameter check */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\t/* timer object initialization */\n\ttimer = rt_calloc(1, sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\trt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\treturn timer;\n}", "CodeBleu_score": 76.71641679590697}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\t/* parameter check */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\t/* allocate timer object */\n\trt_timer_t timer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* timer object initialization */\n\trt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\treturn timer;\n}", "CodeBleu_score": 75.48212481990421}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n/* parameter check */\nRT_ASSERT(timeout!= RT_NULL);\nRT_ASSERT(time < RT_TICK_MAX / 2);\n\n/* allocate memory for timer object */\ntimer = rt_malloc(sizeof(struct rt_timer));\nif (timer!= RT_NULL) {\nrt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n_timer_init(timer, timeout, parameter, time, flag);\n}\n\nreturn timer;\n}", "CodeBleu_score": 68.31676495608522}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tCreate a new recorder to capture the response\n\trec := httptest.NewRecorder()\n\t// Create a new request with the original request's headers\n\tnewReq := req.WithContext(req.Context())\n\t// Set the recorder's header to the original response's header\n\trec.Header().Set(\\\"Content-Type\\\", res.Header().Get(\\\"Content-Type\\\"))\n\t// Set the recorder's status to the original response's status\n\trec.WriteHeader(res.StatusCode)\n\t// Set the recorder's body to the original response's body\n\trec.Body = res.Body\n\n\t// Iterate over the api handlers\n\tfor _, handler := range a.handlers {\n\t\t// Call the handler with the recorder and the new request\n\t\thandler(rec, newReq)\n\t}\n\n\t// If the status code is 401, send a \"Not Authorized\" error response\n\tif rec.Code == 401 {\n\t\thttp.Error(res, \\\"Not Authorized\\\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 49.79592215406468}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tCreate a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Call the router to handle the request\n\ta.router.ServeHTTP(recorder, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the recorder's status code to the original response\n\tres.WriteHeader(recorder.Code)\n\n\t// Copy the recorder's body to the original response\n\t_, _ = res.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 45.12111689754871}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tSet CORS headers\n\tres.Header().Set(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\")\n\tres.Header().Set(\\\"Access-Control-Allow-Methods\\\", \\\"POST, GET, OPTIONS, PUT, DELETE\\\")\n\tres.Header().Set(\\\"Access-Control-Allow-Headers\\\", \\\"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\\\")\n\tres.Header().Set(\\\"Content-Type\\\", \\\"application/json\\\")\n\n\t// Check if the request is a CORS preflight request\n\tif req.Method == \\\"OPTIONS\\\" {\n\t\treturn\n\t}\n\n\t// Process handlers\n\tfor _, h := range a.handlers {\n\t\th(res, req)\n\t}\n\n\t// Serve the request using the router\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 38.463874807912134}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tet := req.URL.Path[1:]\n\tasset = strings.Replace(asset, \\\"//\\\", \\\"/\\\", -1)\n\n\tif asset == \\\"\\\" {\n\t\tasset = \\\"index.html\\\"\n\t}\n\n\tassetPath := \\\"./assets/\\\" + asset\n\tassetData, err := Asset(assetPath)\n\n\tif err!= nil {\n\t\thttp.Error(res, \\\"Asset not found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(asset, \\\".js\\\"):\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"application/javascript\\\")\n\tcase strings.HasSuffix(asset, \\\".css\\\"):\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/css\\\")\n\tcase strings.HasSuffix(asset, \\\".html\\\"):\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"text/html\\\")\n\tdefault:\n\t\tres.Header().Set(\\\"Content-Type\\\", \\\"application/octet-stream\\\")\n\t}\n\n\tres.Write(assetData)\n}", "CodeBleu_score": 35.81497329754987}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tet := strings.TrimPrefix(req.URL.Path, \\\"/api/\\\").TrimPrefix(\\\"/\\\").TrimSuffix(\\\"/\\\")\n\tif asset == \\\"\\\" {\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\tasset = strings.Replace(asset, \\\"/\\\", \\\"/\\\", -1)\n\tasset = \\\"/\\\" + asset\n\tif _, err := os.Stat(asset); err!= nil {\n\t\tif os.IsNotExist(err) {\n\t\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\t\treturn\n\t\t} else {\n\t\t\thttp.Error(res, \\\"Internal Server Error\\\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\tassetType := http.DetectContentType(a.master.Assets.Asset(asset))\n\tres.Header().Set(\\\"Content-Type\\\", assetType)\n\tres.Header().Set(\\\"Cache-Control\\\", \\\"public, max-age=31536000\\\")\n\tres.Header().Set(\\\"Expires\\\", time.Now().AddDate(1, 0, 0).Format(time.RFC1123))\n\tif _, err := res.Write(a.master.Assets.Asset(asset)); err!= nil {\n\t\thttp.Error(res, \\\"Internal Server Error\\\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 30.12713195465291}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\th := req.URL.Path[1:]\n\tvar asset []byte\n\tvar err error\n\tif strings.Contains(path, \\\"/\\\") {\n\t\tasset, err = Asset(path)\n\t} else {\n\t\tasset, err = Asset(path + \\\"/index.html\\\")\n\t}\n\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.Header().Set(\\\"Content-Type\\\", mime.TypeByExtension(path))\n\tres.Write(asset)\n}", "CodeBleu_score": 32.85484254284763}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"connections\": jsonConnections,\n\t\t}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 85.23889845279786}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tconnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"connections\": connections,\n\t\t}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 80.45276516578768}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tconnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"connections\": connections,\n\t\t}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 80.45276516578768}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(\"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 57.63607244638823}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif len(auth) == 0 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth = auth[len(\"Basic \"):]\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tusername, password, ok := extractUsernamePassword(decoded)\n\t\tif!ok {\n\t\t\thttp.Error(w, \"Invalid basic auth credentials\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(username)) == 0 || subtle.ConstantTimeCompare([]byte(password), []byte(password)) == 0 {\n\t\t\thttp.Error(w, \"Invalid basic auth credentials\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.75827499724103}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"api\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth = strings.Replace(auth, \"Basic \", \"\", 1)\n\t\tauth = strings.TrimSpace(auth)\n\t\tauth = strings.Replace(auth, \" \", \"+\", -1)\n\t\tauth = strings.Replace(auth, \"\n\", \"\", -1)\n\t\tauth = strings.Replace(auth, \"\\r\", \"\", -1)\n\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tusernamePassword := strings.Split(string(decoded), \":\")\n\t\tif subtle.ConstantTimeCompare([]byte(username), []byte(usernamePassword[0]))!= 1 || subtle.ConstantTimeCompare([]byte(password), []byte(usernamePassword[1]))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"api\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.196388715774134}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) int {\n\t\treturn int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t}\n}", "CodeBleu_score": 52.16219291333689}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\talculate the slope and intercept of the scaling transformation.\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\t// Return a function that performs the scaling.\n\treturn func(input float64) int {\n\t\t// Clamp the input value to the source range.\n\t\tif input < fromMin {\n\t\t\tinput = fromMin\n\t\t} else if input > fromMax {\n\t\t\tinput = fromMax\n\t\t}\n\n\t\t// Perform the scaling transformation.\n\t\tvalue = int(math.Round(slope*input + intercept))\n\n\t\t// Clamp the output value to the target range.\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 54.42401731751447}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\talculate slope and intercept\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\t// Return the scaling function\n\treturn func(input float64) int {\n\t\t// Calculate the scaled value\n\t\tscaledValue := slope*input + intercept\n\n\t\t// Clamp the scaled value to the target range\n\t\treturn int(math.Max(math.Min(scaledValue, float64(toMax)), float64(toMin)))\n\t}\n}", "CodeBleu_score": 54.28604479272595}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.driver.Connected() {\n\t\treturn -1, -1, errors.New(a.driver.Connection().Error())\n\t}\n\n\trawValue, err := a.driver.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 45.00970624046279}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif err := a.driver.CheckConnection(); err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err!= nil {\n\t\treturn rawValue, value, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = a.sensorCfg.scale(rawValue)\n\treturn rawValue, a.lastValue, nil\n}", "CodeBleu_score": 54.27647354202808}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.lastRawValue!= -1 {\n\t\treturn a.lastRawValue, a.lastValue, nil\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err!= nil {\n\t\treturn rawValue, value, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 44.957091511060646}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 42.79973249779121}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\t// Calculate the slope (m) and intercept (n) for the linear transformation.\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 42.74734244660933}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\t// Calculate the slope and intercept of the linear transformation.\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\n\t// Return the scaling function.\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 42.92903555936869}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.driverCfg.events = append(d.driverCfg.events, \"vibration\")\n\td.vibrationEvent = d.NewEvent(d.driverCfg.events[0])\n\td.vibrationEvent.AddSubscriber(d.driverCfg.events[0], d.handleVibrationEvent)\n\td.vibrationEvent.SetHandler(d.driverCfg.events[0], d.handleVibrationEvent)\n\n\tgo func() {\n\t\td.vibrationEvent.Emit(d.driverCfg.events[0], 0)\n\t\tfor {\n\t\t\td.vibrationEvent.Emit(d.driverCfg.events[0], d.analogSensorDriver.Read())\n\t\t}\n\t}()\n\n\treturn &d\n}", "CodeBleu_score": 49.56356616648737}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(gobot.VibrationEvent, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(gobot.VibrationEvent, true)\n\t\t}\n\t})\n\tif err := d.setupEvent(gobot.VibrationEvent); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn &d\n}", "CodeBleu_score": 68.3104454882569}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(\n\t\t\"vibration\",\n\t\tfunc(data interface{}) {\n\t\t\tif data.(int) > 1000 {\n\t\t\t\td.Publish(\"vibration\", data)\n\t\t\t}\n\t\t},\n\t)\n\td.on(\n\t\t\"data\",\n\t\tfunc(data interface{}) {\n\t\t\td.Publish(\"vibration\", data)\n\t\t},\n\t)\n\treturn &d\n}", "CodeBleu_score": 59.91057347248856}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 1 / (hz * 60 / d.BPM())\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0.0; i < duration; i += tonePeriod {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.98421151862342}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 1000.0 / (hz * 60.0 / d.BPM())\n\n\t// Repeat the tone for the specified duration\n\tfor i := 0.0; i < duration; i += tonePeriod {\n\t\t// Toggle the buzzer on and off at the tone period intervals\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.79863770307928}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := (1 / hz) * (60 / d.bpm)\n\n\t// Repeat the tone for the specified duration\n\tfor i := 0.0; i < duration; i += tonePeriod {\n\t\t// Toggle the buzzer on\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\n\t\t// Toggle the buzzer off\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.83853070939447}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 94.72520543716337}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\t// we need to wait 1ms after sleeping before doing a step to charge the step pump (according to data sheet)\n\ttime.Sleep(1 * time.Millisecond)\n\n\treturn nil\n}", "CodeBleu_score": 89.60916534863705}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleep pin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\t// we need to wait 1ms after sleeping before doing a step to charge the step pump (according to data sheet)\n\ttime.Sleep(1 * time.Millisecond)\n\n\treturn nil\n}", "CodeBleu_score": 87.4458307651252}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"AnalogPinsAdaptor: no pins have been initialized\\\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 57.58201536464993}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins not initialized\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\tpath, r, w, bufLen, err := a.translate(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = system.NewAnalogPin(path, r, w, bufLen)\n\t\ta.pins[id] = pin\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 65.12104216799285}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tf a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"no pins connected\\\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 60.76772821996046}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"not connected to any pins\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\tpin.ApplyOptions(opts...)\n\t\treturn pin, nil\n\t}\n\n\tchip, line, err := a.pinIdToChipAndLine(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err = a.newDigitalPin(chip, line, opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 54.416927809753965}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"digital pins not connected\")\n\t}\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\tchip, line, err := system.ParsePin(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = system.NewDigitalPin(chip, line)\n\t\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := pin.Export(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 59.105318471317524}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"no pins connected\")\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"no pins configured\")\n\t}\n\tif _, ok := a.pins[id]; ok {\n\t\treturn a.pins[id], nil\n\t}\n\tpin, err := a.newDigitalPin(id, opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 41.252333979673516}]}
