{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint16_t desc_len;\n\n\twhile (desc) {\n\t\tnext_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc\n\t\t\t\t+ le16_to_cpu(desc->bLength));\n\t\tdesc_len = le16_to_cpu(desc->bLength);\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t} else if (desc_len < next_desc->bLength) {\n\t\t\t/*\n\t\t\t * The descriptor length is less than the length of the next descriptor. This means that the descriptor is truncated and the next descriptor is not valid.\n\t\t\t * Therefore, we skip this descriptor and move to the next one.\n\t\t\t */\n\t\t\tdesc = next_desc;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor length is greater than or equal to the length of the next descriptor. This means that the descriptor is valid and the next descriptor is also valid.\n\t\t\t * Therefore, we move to the next descriptor.\n\t\t\t */\n\t\t\tdesc = next_desc;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 50.7524962984223}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc = NULL;\n\twhile (NULL!= desc) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\tnext_desc = desc;\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ le16_to_cpu(desc->bLength));\n\t}\n\treturn next_desc;\n}", "CodeBleu_score": 40.85166869347632}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_end;\n\tdesc_end = udc_get_eof_conf();\n\twhile (desc < desc_end) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc\n\t\t\t\t+ le16_to_cpu(desc->bLength));\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 49.55071455639104}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;\n\n\t// Check the validity of the configuration descriptor\n\tif (NULL == udc_ptr_conf) {\n\t\treturn false;\n\t}\n\n\t// Check the validity of the interface number\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Check the validity of the setting number\n\tif (setting_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Go to the beginning of the configuration descriptor\n\tptr_eof_desc = udc_get_eof_conf();\n\n\t// Go to the beginning of the interface descriptor\n\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t *) udc_ptr_conf->desc + udc_ptr_conf->desc->bLength);\n\n\t// Go to the beginning of the interface descriptor\n\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t *) udc_ptr_conf->desc + udc_ptr_conf->desc->bLength);\n\n\t// Iterate through the descriptors until the end of the configuration descriptor\n\twhile (ptr_eof_desc > udc_ptr_iface) {\n\t\t// If a new interface descriptor is found, then it is the end of the current global interface descriptor\n\t\tif (USB_DT_INTERFACE == udc_ptr_iface->desc.bDescriptorType) {\n\t\t\tbreak; // End of global interface descriptor\n\t\t}\n\t\t// If the interface descriptor matches the specified interface number and setting number, then return true\n\t\tif ((iface_num == udc_ptr_iface->desc.bInterfaceNumber) && (setting_num == udc_ptr_iface->desc.bAlternateSetting)) {\n\t\t\treturn true;\n\t\t}\n\t\t// Go to the next descriptor\n\t\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t *) udc_ptr_iface + udc_ptr_iface->desc.bLength);\n\t}\n\treturn false;\n}", "CodeBleu_score": 63.122436121048686}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *ptr_desc;\n\tuint8_t iface_num_desc;\n\tuint8_t setting_num_desc;\n\n\t// Check if a valid configuration is selected\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is within bounds\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tptr_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_conf->desc;\n\twhile (ptr_desc->bLength) {\n\t\t// Check if it is an interface descriptor\n\t\tif (USB_DT_INTERFACE == ptr_desc->bDescriptorType) {\n\t\t\t// Get interface number and setting number from the interface descriptor\n\t\t\tiface_num_desc = ptr_desc->bInterfaceNumber;\n\t\t\tsetting_num_desc = ptr_desc->bAlternateSetting;\n\n\t\t\t// Check if the interface number and setting number match the specified values\n\t\t\tif ((iface_num_desc == iface_num) && (setting_num_desc == setting_num)) {\n\t\t\t\t// Update the internal pointer to the interface descriptor\n\t\t\t\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ptr_desc;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Go to next descriptor\n\t\tptr_desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) ptr_desc + ptr_desc->bLength);\n\t}\n\n\t// No matching interface descriptor was found\n\treturn false;\n}", "CodeBleu_score": 62.01228357258909}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status)) {\n\t\treturn false;\n\t}\n\tudd_set_setup_payload((uint8_t *) &udd_ep_status, sizeof(udd_ep_status));\n\treturn true;\n}", "CodeBleu_score": 35.45949096060007}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udc_endpoint_status)) {\n\t\treturn false;\n\t}\n\n\tudc_endpoint_status = udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;\n\tudd_set_setup_payload((uint8_t *) &udc_endpoint_status, sizeof(udc_endpoint_status));\n\treturn true;\n}", "CodeBleu_score": 53.113604294348974}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udc_ep_status)) {\n\t\treturn false;\n\t}\n\n\tudc_ep_status = 0;\n\tif (udd_ep_is_stalled(udd_g_ctrlreq.req.wIndex)) {\n\t\tudc_ep_status = CPU_TO_LE16(USB_EP_STATUS_HALTED);\n\t}\n\n\tudd_set_setup_payload((uint8_t *) &udc_ep_status, sizeof(udc_ep_status));\n\treturn true;\n}", "CodeBleu_score": 63.743784412489255}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num, setting_num;\n\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tsetting_num = udd_g_ctrlreq.req.wValue & 0xFF;\n\n\t// Disable current setting\n\tif (!udc_iface_disable(iface_num)) {\n\t\treturn false;\n\t}\n\n\t// Update pointer of the interface descriptor\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Update pointer of the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tif (!udc_ptr_conf->udi_apis[iface_num]->setup()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 59.722145241183235}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tuint8_t ep_num;\n\tudi_api_t UDC_DESC_STORAGE *udi_api;\n\n\tif (!udc_num_configuration) {\n\t\treturn false; // The device is not is configured state yet\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the pointer of the interface descriptor\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Check the alternate setting number included in the request\n\tsetting_num = udd_g_ctrlreq.req.wValue & 0xFF;\n\tif (setting_num >= udc_ptr_iface->desc->bNumConfigurations) {\n\t\treturn false;\n\t}\n\n\t// Update the pointer of the alternate setting descriptor\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Update the pointer of the endpoint descriptor\n\tfor (ep_num = 0; ep_num < udc_ptr_iface->desc->bNumEndpoints; ep_num++) {\n\t\tif (!udc_update_ep_desc(iface_num, ep_num, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\treturn udi_api->setup(udc_ptr_iface->desc, udc_ptr_iface->alt_setting, udc_ptr_iface->ep_desc);\n}", "CodeBleu_score": 72.80264344597954}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tudi_api_t *udi_api;\n\n\t// Check if the device is in a configured state\n\tif (!udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check the interface number included in the request\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Select first alternate setting of the interface to update udc_ptr_iface\n\t// before call iface->getsetting()\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Get alternate setting from UDI\n\tudi_api = udc_ptr_conf->udi_apis[iface_num];\n\tudc_iface_setting = udi_api->getsetting();\n\n\t// Link value to payload pointer of request\n\tudd_set_setup_payload(&udc_iface_setting,1);\n\treturn true;\n}", "CodeBleu_score": 56.195303014627726}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Initialize the MSC interface\n\tudi_msc_init();\n\n\t// Check if the external enable function is defined\n\tif (udi_msc_enable_ext) {\n\t\t// Call the external enable function\n\t\tif (!udi_msc_enable_ext()) {\n\t\t\t// Return false if the external enable function fails\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Get the number of LUNs\n\tudi_msc_nb_lun = udi_msc_get_nb_lun();\n\n\t// Check if there are any LUNs available\n\tif (udi_msc_nb_lun == 0) {\n\t\t// Return false if there are no LUNs available\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tfor (udi_msc_lun = 0; udi_msc_lun < udi_msc_nb_lun; udi_msc_lun++) {\n\t\tudi_msc_unload_medium(udi_msc_lun);\n\t}\n\n\t// Start the MSC process\n\tudi_msc_cbw_wait();\n\n\t// Return true if the MSC interface is enabled\n\treturn true;\n}", "CodeBleu_score": 44.5500838439924}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\t// Check status of transfer\n\tif (UDD_EP_TRANSFER_OK!= status) {\n\t\t// Transfer aborted\n\t\t// Now wait MSC setup reset to relaunch CBW reception\n\t\treturn;\n\t}\n\t// Update sense data\n\tudi_msc_sense_data_update();\n\t// Decrease data residue in CSW\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\t// Process CSW\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 77.08270695473631}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\n\t// Check status of transfer\n\tif (UDD_EP_TRANSFER_OK!= status) {\n\t\t// Transfer aborted\n\t\t// Now wait MSC setup reset to relaunch CBW reception\n\t\treturn;\n\t}\n\n\t// Update sense data\n\tudi_msc_sense_data_update(nb_sent);\n\n\t// Decrease data residue in CSW\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\n\t// Process CSW\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 73.52446125594201}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\n\t// Check status of transfer\n\tif (UDD_EP_TRANSFER_OK!= status) {\n\t\t// Transfer aborted\n\t\t// Now wait MSC setup reset to relaunch CBW reception\n\t\treturn;\n\t}\n\n\t// Update sense data\n\tudi_msc_sense_data_update();\n\n\t// Decrease data residue in CSW by the amount of data sent\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\n\t// Process CSW\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 77.08270695473631}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\tif (0!= udi_msc_csw.dCSWDataResidue) {\n\t\tif (USB_CBW_DIRECTION_IN == (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)) {\n\t\t\t// Stall IN endpoint\n\t\t\tudd_ep_set_stall(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\t// Stall OUT endpoint\n\t\t\tudd_ep_set_stall(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\t// Prepare CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.\n\tudi_msc_csw.dCSWSignature = CPU_TO_BE32(USB_CSW_SIGNATURE);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 51.962274764058}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\tif (USB_CBW_DIRECTION_IN == (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)) {\n\t\t\t// Stall IN endpoint\n\t\t\tudd_ep_set_stall(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\t// Stall OUT endpoint\n\t\t\tudd_ep_set_stall(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\t// Prepare CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASSED;\n\t// Send CSW\n\tudi_msc_data_send((uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 60.941781870463196}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\tif (0!= udi_msc_csw.dCSWDataResidue) {\n\t\tif (USB_CBW_DIRECTION_IN == (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)) {\n\t\t\t// Stall next request from USB host on IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\t// Stall next request from USB host on OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\t// Prepare CSW by setting its tag and converting the data residue to little-endian format.\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t// Sends data on IN endpoint\n\tif (!udd_ep_run(UDI_MSC_EP_IN, true, (uint8_t *) & udi_msc_csw, sizeof(udi_msc_csw), udi_msc_csw_sent)) {\n\t\t// If endpoint not available, then exit process command\n\t\tudi_msc_sense_fail_hardware();\n\t}\n}", "CodeBleu_score": 70.59222162524954}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tmain_b_dtr_active = b_enable;\n\tif (!b_enable) {\n\t\tif (dwDTERate == 1200) {\n\t\t\tcancelReset();\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 49.44545749390217}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tmain_b_dtr_active = b_enable;\n\tif (!b_enable && dwDTERate == 1200) {\n\t\t// If DTR is disabled and the DTE rate is 1200, reset the system\n\t\tinitiateReset();\n\t} else {\n\t\t// If DTR is enabled, cancel any scheduled reset\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 42.602824180601004}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tmain_b_dtr_active = b_enable;\n\tif (!b_enable) {\n\t\tif (dwDTERate == 1200) {\n\t\t\tcancelReset();\n\t\t\tinitiateReset();\n\t\t}\n\t} else {\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 52.02308423487756}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t\t// Check request type\n\tif (UDD_GET_REQUEST_TYPE(udd_g_ctrlreq.req.bmRequestType)!= UDC_REQ_TYPE_VENDOR) {\n\t\treturn false;\n\t}\n\n\t// Check request index\n\tswitch (udd_g_ctrlreq.req.bRequest) {\n\t\tcase UDI_CDC_GET_MS_COMPATIBLE_ID:\n\t\t\t// Set up pointer and size for Microsoft-compatible ID descriptor\n\t\t\tudd_g_ctrlreq.payload_size = microsoft_compatible_id_descriptor.dwLength;\n\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_compatible_id_descriptor;\n\t\t\tbreak;\n\t\tcase UDI_CDC_GET_EXTENDED_PROPERTIES:\n\t\t\t// Set up pointer and size for extended properties descriptor\n\t\t\tudd_g_ctrlreq.payload_size = microsoft_extended_properties_descriptor.dwLength;\n\t\t\tudd_g_ctrlreq.payload = (uint8_t*)&microsoft_extended_properties_descriptor;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t// Update control request payload and size\n\tudd_g_ctrlreq.payload_size = Min(udd_g_ctrlreq.payload_size, udd_g_ctrlreq.req.wLength);\n\n\treturn true;\n}", "CodeBleu_score": 31.727011106094743}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t", "CodeBleu_score": 3.1810042918173207}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\t// read data from SPI\n\tfor (uint16_t i = 0; i < nbyte; i++) {\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\t\twhile ((SPI0->SPI_SR & SPI_SR_RDRF) == 0);\n\t\tbuf[i] = SPI0->SPI_RDR;\n\t}\n\n\t// read last byte\n\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\twhile ((SPI0->SPI_SR & SPI_SR_RDRF) == 0);\n\tbuf[nbyte] = SPI0->SPI_RDR;\n}", "CodeBleu_score": 60.17023781657438}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\n\twhile (nbyte--) {\n\t\t// write dummy byte with address and end transmission flag\n\t\tSPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;\n\t\tWHILE_RX(0);\n\n\t\t*buf++ = SPI0->SPI_RDR;\n\t}\n\n\t// read last byte\n\t*buf = spiRec();\n}", "CodeBleu_score": 45.53991538943231}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = nullptr;\n\tCRITICAL_SECTION_START();\n\toldHandler = get_relocated_table_addr()[irq];\n\tget_relocated_table_addr()[irq] = newHandler;\n\tCRITICAL_SECTION_END();\n\treturn oldHandler;\n}", "CodeBleu_score": 62.05714269540219}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* table = get_relocated_table_addr();\n\n\t// Disable global interrupts to ensure atomic operation\n\tCRITICAL_SECTION_START();\n\n\t// Retrieve the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = table[irq];\n\n\t// Replace it with the new handler\n\ttable[irq] = newHandler;\n\n\t// Re-enable global interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 69.12946333313121}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the address of the relocated interrupt vector table\n\tpfnISR_Handler* relocatedTable = get_relocated_table_addr();\n\n\t// Disable global interrupts\n\tCRITICAL_SECTION_START();\n\n\t// Get the current ISR handler for the specified IRQ\n\tpfnISR_Handler oldHandler = relocatedTable[irq];\n\n\t// Replace the current ISR handler with the new handler\n\trelocatedTable[irq] = newHandler;\n\n\t// Re-enable global interrupts\n\tCRITICAL_SECTION_END();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 68.57285618127472}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  // If a character is pending, return it\n  if (pending_char >= 0) return pending_char;\n\n  // If the USB CDC is not enabled, return -1\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If the DTR line is not active, return -1\n  if (!usb_task_cdc_dtr_active()) return -1;\n\n  // If no bytes are available, return -1\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  // Read the next character\n  int c = udi_cdc_getc();\n\n  // Process the character if the emergency parser is enabled\n  if (c == EMERGENCY_PARSER_CMD) {\n    // Read the next character\n    c = udi_cdc_getc();\n\n    // If the character is a 'M', return the character\n    if (c == 'M') return c;\n\n    // Otherwise, process the character\n    else {\n      // If the character is a 'N', return -1\n      if (c == 'N') return -1;\n\n      // Otherwise, save the character\n      pending_char = c;\n    }\n  }\n\n  // Return the character\n  return c;\n#else\n  // If the USB CDC is not enabled, return -1\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If the DTR line is not active, return -1\n  if (!usb_task_cdc_dtr_active()) return -1;\n\n  // If no bytes are available, return -1\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  // Read the next character\n  int c = udi_cdc_getc();\n\n  // Return the character\n  return c;\n#endif\n}", "CodeBleu_score": 56.62635008771383}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (pending_char!= -1) {\n\t\treturn pending_char;\n\t}\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn -1;\n\t}\n\tif (!usb_task_cdc_dtr_active()) {\n\t\treturn -1;\n\t}\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tint c = udi_cdc_getc();\n\tif (c!= -1) {\n\t\tif (parser) {\n\t\t\tparser->process_char(c);\n\t\t}\n\t\tpending_char = c;\n\t}\n\treturn c;\n}", "CodeBleu_score": 42.45282230989497}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (pending_char!= -1)\n    return pending_char;\n\n  if (usb_task_cdc_isenabled() && usb_task_cdc_dtr_active()) {\n    if (udi_cdc_is_rx_ready()) {\n      pending_char = udi_cdc_getc();\n      return pending_char;\n    }\n  }\n#endif\n  return -1;\n}", "CodeBleu_score": 49.23490185029372}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tpending_char = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n\treturn pending_char;\n}", "CodeBleu_score": 74.43017384788754}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tpending_char = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n\treturn pending_char;\n}", "CodeBleu_score": 74.43017384788754}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char >= 0) {\n\t\tint c = pending_char;\n\t\tpending_char = -1;\n\t\treturn c;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled())\n\t\treturn -1;\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tpending_char = udi_cdc_getc();\n\n\tTERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n\n\treturn pending_char;\n}", "CodeBleu_score": 74.43017384788754}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if HAS_USB_SERIAL\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  return 1;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 22.591385903131677}, {"code": "int MarlinSerialUSB::available(){\n\t#if HAS_USB_SERIAL\n  // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return 0;\n\n  // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return 0;\n\n  // If there are pending characters\n  if (pending_char >= 0)\n    return 1;\n\n  // If there are no pending characters\n  pending_char = udi_cdc_getc();\n  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n  return 1;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 47.6216724930014}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (pending_char >= 0) {\n\t\treturn 1;\n\t}\n\n\t// If USB CDC not enumerated or not configured on the PC side\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn 0;\n\t}\n\n\t// If no bytes sent from the PC\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "CodeBleu_score": 28.75876955872254}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint16_t read = 0;\n\twhile (size--) {\n\t\tuint8_t v = ee_Read(uint32_t(REAL_EEPROM_ADDR(pos)));\n\t\tif (writing) *value = v;\n\t\tcrc16(crc, &v, 1);\n\t\tpos++;\n\t\tvalue++;\n\t\tread++;\n\t}\n\treturn read < size;\n}", "CodeBleu_score": 68.75974590413179}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t * const p = (uint8_t * const)REAL_EEPROM_ADDR(pos);\nuint8_t v = ee_Read(uint32_t(p));\nif (writing) {\n*value = v;\nvalue++;\n}\ncrc16(crc, &v, 1);\npos++;\nreturn --size;\n}", "CodeBleu_score": 56.61788590951813}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint16_t read = 0;\n\twhile (size--) {\n\t\tuint8_t v = ee_Read(uint32_t(REAL_EEPROM_ADDR(pos)));\n\t\tif (value) *value = v;\n\t\tif (writing) crc16(crc, &v, 1);\n\t\tpos++;\n\t\tvalue++;\n\t\tread++;\n\t}\n\treturn read < size;\n}", "CodeBleu_score": 62.911371855479835}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    pwm_pin_t &pindata = pwm_pin_data[pin & 0x7F];\n    if (value == 0) {\n      pindata.pwm_duty_ticks = 0; // turn off PWM for this pin\n      CBI32(i2s_port_data, pin & 0x7F); // set pin level\n    }\n    else {\n      pindata.pwm_duty_ticks = map(value, 0, 1023, 0, pindata.pwm_cycle_ticks); // PWM duty count = # of 4s ticks per full PWM cycle\n      SBI32(i2s_port_data, pin & 0x7F); // set pin level\n    }\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) ledcWrite(cid, value);\n}", "CodeBleu_score": 42.94155843225951}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(value, 0, 255, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    const uint32_t duty = map(value, 0, 255, 0, _BV(PWM_RESOLUTION)-1);\n    ledcWrite(cid, duty);\n  }\n}", "CodeBleu_score": 46.47519049292947}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if ENABLED(I2S_STEPPER_STREAM)\n  if (pin > 127) {\n    const uint8_t pinlo = pin & 0x7F;\n    pwm_pin_t &pindata = pwm_pin_data[pinlo];\n    const uint32_t duty = map(value, 0, _BV(PWM_RESOLUTION)-1, 0, pindata.pwm_cycle_ticks);\n    if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)\n      pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin\n      duty? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level\n    }\n    else\n      pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4s ticks per full PWM cycle\n\n    return;\n  }\n#endif\n\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0)\n    ledcWrite(cid, value);\n}", "CodeBleu_score": 47.83919662889189}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifdef STATIC_ASSERT\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"Servo delay array length does not match number of servos\");\n#endif\n  if (channel >= 0) {\n    ledcWrite(channel, value);\n    delayMicroseconds(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 50.70931550956789}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"SERVO_DELAY_ARRAY_LENGTH does not match NUM_SERVOS\");\n\tif (channel >= 0) {\n\t\twrite(value);\n\t\tdelay(SERVO_DELAY_ARRAY[channel]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}", "CodeBleu_score": 48.815046019697974}, {"code": "void Servo::move(const int value){\n\t#if defined(DEACTIVATE_SERVOS_AFTER_MOVE) && DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n  write(value);\n  delay(SERVO_DELAY_US);\n}", "CodeBleu_score": 34.49011789490193}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n  // If the current buffer position is equal to the buffer count, it wraps back to the first buffer.\n  if (dma.buf_idx == DMA_BUF_COUNT) dma.buf_idx = 0;\n\n  // If the current buffer position is equal to the buffer count, it wraps back to the first buffer.\n  if (dma.buf_idx == DMA_BUF_COUNT) dma.buf_idx = 0;\n\n  // Update the PWM states for each pin and write the resulting data to the current position of the DMA buffer.\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (pwm_state[pin].active) {\n      if (pwm_state[pin].tick_count == 0) {\n        pwm_state[pin].state =!pwm_state[pin].state;\n        pwm_state[pin].tick_count = pwm_state[pin].tick_length;\n      }\n      else {\n        pwm_state[pin].tick_count--;\n      }\n\n      // Store the updated port data into the current position of the DMA buffer.\n      dma.buf[dma.buf_idx] |= pwm_state[pin].state << pin;\n    }\n  }\n\n  // Increment the buffer position.\n  dma.buf_idx++;\n#endif\n}", "CodeBleu_score": 31.565196162013855}, {"code": "void i2s_push_sample(){\n\t#if ENABLED(I2S_STEPPER_SPLIT_STREAM)\n  // Update the PWM states for each pin\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (stepper_pwm_active[pin]) {\n      if (stepper_pwm_tick_count[pin] == 0) {\n        stepper_pwm_tick_count[pin] = stepper_pwm_tick_count_max[pin];\n        stepper_pwm_state[pin] =!stepper_pwm_state[pin];\n      }\n      stepper_pwm_tick_count[pin]--;\n    }\n  }\n\n  // Write the updated port data to the DMA buffer\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (stepper_pwm_active[pin]) {\n      SET_BIT_TO(dma.desc[dma.buf_idx], pin, stepper_pwm_state[pin]);\n    }\n  }\n#else\n  // Update the PWM states for each pin\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (stepper_pwm_active[pin]) {\n      if (stepper_pwm_tick_count[pin] == 0) {\n        stepper_pwm_tick_count[pin] = stepper_pwm_tick_count_max[pin];\n        stepper_pwm_state[pin] =!stepper_pwm_state[pin];\n      }\n      stepper_pwm_tick_count[pin]--;\n    }\n  }\n\n  // Write the updated port data to the DMA buffer\n  for (uint8_t pin = 0; pin < 16; pin++) {\n    if (stepper_pwm_active[pin]) {\n      SET_BIT_TO(i2s_port_data, pin, stepper_pwm_state[pin]);\n    }\n  }\n#endif\n\n  // Increment the buffer position and wrap around if necessary\n  dma.buf_idx = (dma.buf_idx + 1) % DMA_BUF_COUNT;\n\n  // Update the DMA descriptor with the next buffer\n  I2S0.out_link.addr = (uint32_t)dma.desc[dma.buf_idx];\n}", "CodeBleu_score": 38.27235419120383}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\n\treturn counter_value;\n}", "CodeBleu_score": 97.86105963185919}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tconst tTimerConfig timer = timer_config[timer_num];\n\nuint64_t counter_value;\ntimer_get_counter_value(timer.group, timer.idx, &counter_value);\n\nreturn counter_value;\n}", "CodeBleu_score": 97.84667124074724}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tconst tTimerConfig timer = timer_config[timer_num];\n\n\tuint64_t current_counter_value;\n\ttimer_get_counter_value(timer.group, timer.idx, &current_counter_value);\n\n\treturn current_counter_value;\n}", "CodeBleu_score": 83.07607388960679}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = HAL_eeprom_data[pos + i];\n\t\tcrc16(crc, &value[i], 1);\n\t\tif (writing) HAL_eeprom_data[pos + i] = value[i];\n\t}\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 71.65563084830437}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = HAL_eeprom_data[pos + i];\n\t\tcrc16(crc, &value[i], 1);\n\t\tif (writing) HAL_eeprom_data[pos + i] = value[i];\n\t}\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 71.65563084830437}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) value[i] = HAL_eeprom_data[pos + i];\n\t}\n\n\tcrc16(crc, value, size);\n\tpos += size;\n\treturn false;\n}", "CodeBleu_score": 67.663926131864}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 73.2521382568653}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t* The function \"SDIO_WriteBlock\" attempts to write a block of data to an SD card using the SDIO interface.\nIt first asserts that the SDIO handle and source pointer are not null.\nIt then tries to write the block, retrying up to a defined number of times if the write operation fails.\nIf the write operation succeeds, it returns \"true\".\nIf all retries fail, it prints an error message and returns \"false\".\n */\n  CORE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n  WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n  })\n\n  return false;\n}", "CodeBleu_score": 68.6966983748571}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tE_ASSERT(handle!= nullptr, \"SDIO not initialized\", return false);\n\tCORE_ASSERT(src!= nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n\n\tWITH_RETRY(SDIO_WRITE_RETRIES, {\n\t\ten_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n\t\tif (rc == Ok) return true;\n\t\tprintf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\n\", rc, handle->u32ErrorCode);\n\t})\n\n\treturn false;\n}", "CodeBleu_score": 80.05454715617007}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER) {\n\t\ttemp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n\t\tNVIC_SetPriority(TEMP_TIMER_IRQn, TEMP_TIMER_PRIORITY);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tstep_timer.start(frequency, STEP_TIMER_PRESCALE);\n\t\tNVIC_SetPriority(STEP_TIMER_IRQn, STEP_TIMER_PRIORITY);\n\t} else {\n\t\tASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 37.0800396646567}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER) {\n\t\ttemp_timer.start(frequency, TEMP_PRESCALE);\n\t\ttemp_timer.set_callback_priority(TEMP_CALLBACK_PRIORITY);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tstep_timer.start(frequency, STEP_PRESCALE);\n\t\tstep_timer.set_callback_priority(STEP_CALLBACK_PRIORITY);\n\t} else {\n\t\tASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 43.40446657781121}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER) {\n\t\ttemp_timer.start(frequency, TIMER_PRESCALE_TEMP);\n\t\ttemp_timer.set_callback_priority(TEMP_TIMER_PRIORITY);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tstep_timer.start(frequency, TIMER_PRESCALE_STEP);\n\t\tstep_timer.set_callback_priority(STEP_TIMER_PRIORITY);\n\t} else {\n\t\tassert_param(0);\n\t}\n}", "CodeBleu_score": 43.85947366405339}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tFILE *file;\n\tsize_t file_size;\n\tsize_t i;\n\n\t// Open the file\n\tfile = fopen(filename, \"r+\");\n\n\t// If the file cannot be opened, return false\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\n\t// Get the file size\n\tfseek(file, 0, SEEK_END);\n\tfile_size = ftell(file);\n\tfseek(file, 0, SEEK_SET);\n\n\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value\n\tif (file_size < MARLIN_EEPROM_SIZE) {\n\t\tfor (i = file_size; i < MARLIN_EEPROM_SIZE; i++) {\n\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t}\n\t}\n\n\t// Read the file's contents into the buffer\n\tfread(buffer, 1, file_size, file);\n\n\t// Close the file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 46.55115179301001}, {"code": "bool PersistentStore::access_start(){\n\t\tFILE *fp;\n\tfp = fopen(filename, \"r+\");\n\tif (fp == NULL) {\n\t\tfp = fopen(filename, \"w+\");\n\t\tif (fp == NULL) {\n\t\t\tprintf(\"Could not open file\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tfseek(fp, 0, SEEK_END);\n\tsize_t file_size = ftell(fp);\n\tif (file_size < MARLIN_EEPROM_SIZE) {\n\t\tfor (size_t i = file_size; i < MARLIN_EEPROM_SIZE; i++) {\n\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t}\n\t}\n\tfseek(fp, 0, SEEK_SET);\n\tfread(buffer, sizeof(uint8_t), MARLIN_EEPROM_SIZE, fp);\n\tfclose(fp);\n\treturn true;\n}", "CodeBleu_score": 45.85566444824938}, {"code": "bool PersistentStore::access_start(){\n\t#if ENABLED(EEPROM_SETTINGS)\n  FILE *file = fopen(filename, \\\"r\\\");\n  if (file) {\n    size_t size = fread(buffer, 1, MARLIN_EEPROM_SIZE, file);\n    if (size < MARLIN_EEPROM_SIZE) {\n      memset(buffer + size, 0xFF, MARLIN_EEPROM_SIZE - size);\n    }\n    fclose(file);\n    return true;\n  }\n#endif\n  return false;\n}", "CodeBleu_score": 33.398134939683914}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t rx_data = 0;\n\tuint8_t tx_data = b;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\t// Set clock low\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\n\t\t// Write most significant bit of tx_data to MOSI\n\t\tOUT_WRITE(SD_MOSI_PIN, (tx_data & 0x80)? HIGH : LOW);\n\n\t\t// Toggle clock pin high\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\n\t\t// Read bit from MISO\n\t\trx_data = (rx_data << 1) | (IN_READ(SD_MISO_PIN)? 1 : 0);\n\n\t\t// Shift tx_data left\n\t\ttx_data <<= 1;\n\t}\n\t// Introduce a small delay before returning the received byte\n\tdelaySPIFunc();\n\treturn rx_data;\n}", "CodeBleu_score": 47.57385267338427}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t rx = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\t// Set clock low\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\n\t\t// Write most significant bit of byte to MOSI pin\n\t\tif (b & 0x80) {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\t} else {\n\t\t\tOUT_WRITE(SD_MOSI_PIN, LOW);\n\t\t}\n\n\t\t// Toggle clock pin high\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\n\t\t// Read bit from MISO pin\n\t\tif (IN_READ(SD_MISO_PIN)) {\n\t\t\trx |= 0x01;\n\t\t}\n\n\t\t// Shift byte left\n\t\tb <<= 1;\n\n\t\t// Introduce small delay before returning received byte\n\t\tdelaySPIFunc();\n\t}\n\treturn rx;\n}", "CodeBleu_score": 50.29341687405212}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t rx = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\t// set clock low\n\t\tOUT_WRITE(SD_SCK_PIN, LOW);\n\t\t// write MSB\n\t\tif (b & 0x80)\n\t\t\tOUT_WRITE(SD_MOSI_PIN, HIGH);\n\t\telse\n\t\t\tOUT_WRITE(SD_MOSI_PIN, LOW);\n\t\t// toggle clock high\n\t\tOUT_WRITE(SD_SCK_PIN, HIGH);\n\t\t// read MISO\n\t\trx <<= 1;\n\t\tif (IN_READ(SD_MISO_PIN))\n\t\t\trx |= 1;\n\t\t// delay\n\t\tdelaySPIFunc();\n\t\t// shift byte\n\t\tb <<= 1;\n\t}\n\treturn rx;\n}", "CodeBleu_score": 51.64685460771423}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t Check the parameters\nassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\nassert_param(IS_FUNCTIONAL_STATE(NewState));\nif (NewState!= DISABLE)\n  RCC->AHBENR |= RCC_AHBPeriph;\nelse\n  RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 81.39945320639934}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t Check the parameters\nassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\nassert_param(IS_FUNCTIONAL_STATE(NewState));\nif (NewState!= DISABLE)\n  RCC->AHBENR |= RCC_AHBPeriph;\nelse\n  RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 81.39945320639934}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t Check the parameters\nassert_param(IS_RCC_AHB_CLOCK_PERIPH(RCC_AHBPeriph));\n\nassert_param(IS_FUNCTIONAL_STATE(NewState));\nif (NewState!= DISABLE)\n  RCC->AHBENR |= RCC_AHBPeriph;\nelse\n  RCC->AHBENR &= ~RCC_AHBPeriph;\n}", "CodeBleu_score": 81.39945320639934}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif ENABLED(EMERGENCY_PARSER)\n  _rx_callback(obj);\n#endif\n}", "CodeBleu_score": 7.277642151254687}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = obj->read();\n\t#if ENABLED(EMERGENCY_PARSER)\n\t\tif (c == 0x03) {\n\t\t\t// Emergency stop received\n\t\t\tif (e_parser_active) {\n\t\t\t\t// Stop the emergency parser\n\t\t\t\te_parser_active = false;\n\t\t\t\t// Clear the buffer\n\t\t\t\te_parser_buffer.clear();\n\t\t\t\t// Clear the parser\n\t\t\t\te_parser_parser.clear();\n\t\t\t}\n\t\t}\n\t#endif\n\t// If the buffer is full, we discard the byte\n\tif (obj->rx_head!= obj->rx_tail) {\n\t\t// Update the buffer index\n\t\tobj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t// If the buffer is full, we discard the byte\n\t\tif (obj->rx_head == obj->rx_tail) {\n\t\t\tobj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t}\n\t\t// Store the byte in the buffer\n\t\tobj->rx_buffer[obj->rx_head] = c;\n\t}\n\t#if ENABLED(EMERGENCY_PARSER)\n\t\t// If the emergency parser is active, we add the byte to the buffer\n\t\tif (e_parser_active) {\n\t\t\t// Add the byte to the buffer\n\t\t\te_parser_buffer.push(c);\n\t\t\t// If the buffer is full, we discard the byte\n\t\t\tif (e_parser_buffer.size() == EMERGENCY_PARSER_BUFFER_SIZE) {\n\t\t\t\te_parser_buffer.pop();\n\t\t\t}\n\t\t\t// If the parser is not active, we start it\n\t\t\tif (!e_parser_parser.active()) {\n\t\t\t\te_parser_parser.start();\n\t\t\t}\n\t\t}\n\t#endif\n}", "CodeBleu_score": 43.61471465965003}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif ENABLED(EMERGENCY_PARSER)\n  // Read the byte\n  uint8_t c = obj->read();\n  // Update the emergency parser\n  EmergencyParser::update(c);\n#endif\n}", "CodeBleu_score": 14.63765336762162}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized(timer_num)) {\n\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[MF_TIMER_STEP]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[MF_TIMER_TEMP]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.96279110639438}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized(timer_num)) {\n\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\t// Attach the Stepper Timer ISR.\n\t\t\t\ttimer_instance[MF_TIMER_STEP]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\t// Attach the Temperature Timer ISR.\n\t\t\t\ttimer_instance[MF_TIMER_TEMP]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.96279110639438}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (!HAL_timer_initialized(timer_num)) {\n\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 73.69328517909624}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 55.96082125462184}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 55.96082125462184}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp search\n\thashss, pow := HashStr(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && string(s[:n]) == string(sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && string(s[i-n:i]) == string(sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 55.96082125462184}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t// Disable interrupts to prevent re-entrancy.\n\tinterrupt.Disable()\n\tdefer interrupt.Enable()\n\n\t// Send any available data in the transmit buffer.\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\n\t// If there is no data available, set \"waitTxc\" to false.\n\tif usbcdc.txBuffer.Used() == 0 {\n\t\tusbcdc.waitTxc = false\n\t}\n}", "CodeBleu_score": 43.840726076780534}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// disable interrupts\n\tinterrupt.Disable()\n\n\t// check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// send it to the USB endpoint\n\t\tSendUSBInPacket(usbcdc.txBuffer.GetSlice(0, usbcdc.txBuffer.Used()))\n\n\t\t// set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t} else {\n\t\t// set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 45.99765061560328}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// disable interrupts\n\tinterrupt.Disable()\n\t// check if there is data in the transmit buffer\n\tif usbcdc.txBuffer.Used() > 0 {\n\t\t// send data to USB endpoint\n\t\tSendUSBInPacket(usbcdc.txBuffer.Get(), usbcdc.txBuffer.Used())\n\t\t// set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t} else {\n\t\t// no data in the transmit buffer\n\t\t// set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// restore interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 46.5194373959598}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\tClear interrupt flag.\n\ti2c.crReg.ClearBits(i2c.crINT)\n\n\t// Send start condition.\n\ti2c.crReg.SetBits(i2c.crSTO | i2c.crSTA)\n\n\t// Wait for start condition to be transmitted.\n\tfor!i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\n\t// Send peripheral address.\n\ti2c.writeByte(address << 1 | uint8(write))\n}", "CodeBleu_score": 40.66191287258599}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t.crReg.ClearBits(i2c.crINT)\n\ti2c.crReg.Set(i2c.crEN)\n\ti2c.crReg.Set(i2c.crSTA)\n\tfor!i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\ti2c.writeByte(address<<1 | (0x01 &^ uint8(write)))\n}", "CodeBleu_score": 44.577938638656015}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t.crReg.ClearBits(i2c.crINT)\n\ti2c.crReg.SetBits(i2c.crEN | i2c.crSTA)\n\tfor!i2c.crReg.HasBits(i2c.crINT) {\n\t}\n\ti2c.writeByte(address << 1)\n\tif write {\n\t\ti2c.crReg.ClearBits(i2c.crEA)\n\t} else {\n\t\ti2c.crReg.SetBits(i2c.crEA)\n\t}\n\ti2c.writeByte(address << 1 | 1)\n}", "CodeBleu_score": 42.09725118341166}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif FlashDataStart()+uintptr(start)*uintptr(f.EraseBlockSize()) > FlashDataEnd() {\n\t\treturn errFlashCannotErasePastEOF\n\t}\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := start; i < start+len; i++ {\n\t\tnrf.NVMC.SetERASEALL(1)\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.79054413396067}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := FlashDataStart() + uintptr(start)*uintptr(f.EraseBlockSize())\n\tendAddress := startAddress + uintptr(len)*uintptr(f.EraseBlockSize())\n\tif endAddress > FlashDataEnd() {\n\t\treturn errFlashCannotErasePastEOF\n\t}\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\tdefer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\tfor i := startAddress; i < endAddress; i += uintptr(f.EraseBlockSize()) {\n\t\tnrf.NVMC.SetERASEALL(nrf.NVMC_ERASEALL_Eraseall)\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.2538238723446}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := FlashDataStart() + uintptr(start)*uintptr(f.EraseBlockSize())\n\tendAddress := startAddress + uintptr(len)*uintptr(f.EraseBlockSize())\n\n\twaitWhileFlashBusy()\n\n\tnrf.NVMC.SetCONFIG_ERASE(nrf.NVMC_CONFIG_ERASE_Erase)\n\tdefer nrf.NVMC.SetCONFIG_ERASE(nrf.NVMC_CONFIG_ERASE_Erase)\n\n\tfor address := startAddress; address < endAddress; address += uintptr(f.EraseBlockSize()) {\n\t\tnrf.NVMC.SetADDRESS(uint32(address))\n\t\twaitWhileFlashBusy()\n\t}\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn nil\n}", "CodeBleu_score": 55.12694700427097}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(FlashDataStart()+uintptr(off))), len(p))\n\tcopy(data, p)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 27.627574701030326}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotWritePastEOF\n\t}\n\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(FlashDataStart()+uintptr(off))), len(p))\n\tcopy(data, p)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 27.627574701030326}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n\t\treturn 0, errFlashCannotReadPastEOF\n\t}\n\n\tdata := unsafe.Slice((*byte)(unsafe.Pointer(FlashDataStart()+uintptr(off))), len(p))\n\tcopy(data, p)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 26.359628747576913}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t, err := syscall.Fdopendir(fd)\n\tif err!= nil {\n\t\treturn 0, \\\"Fdopendir\\\", err\n\t}\n\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dir)\n\t\tif err!= nil {\n\t\t\tif errno, ok := err.(syscall.Errno);\n\t\t\t\tok && errno == syscall.EINTR {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tsyscall.Close(dir)\n\t\t\treturn 0, \\\"Fdopendir\\\", err\n\t\t}\n\t}", "CodeBleu_score": 48.5515342749614}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tFirst, duplicate the file descriptor.\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \\\"dup\\\", err\n\t}\n\tdefer syscall.Close(newFd)\n\n\t// Next, repeatedly attempt to open the directory using syscall.Fdopendir until it succeeds or encounters an error other than syscall.EINTR.\n\tfor {\n\t\tdir, err := syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \\\"\\\", nil\n\t\t}\n\t\tif errno, ok := err.(syscall.Errno);!ok || errno!= syscall.EINTR {\n\t\t\treturn 0, \\\"fdopendir\\\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 47.20448530343326}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t, err := syscall.Fdopendir(fd)\n\tif err!= nil {\n\t\treturn 0, \\\"fdopendir\\\", err\n\t}\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \\\"\\\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tsyscall.Close(fd)\n\treturn 0, \\\"fdopendir\\\", err\n}", "CodeBleu_score": 53.7190030056337}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t#if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C2 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6 || CONFIG_IDF_TARGET_ESP32H2\n  esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n  if (it == NULL) {\n    return 0;\n  }\n  esp_partition_t *partition = esp_partition_get(it);\n  esp_partition_iterator_release(it);\n  if (partition == NULL) {\n    return 0;\n  }\n  uint32_t image_length = 0;\n  if (esp_image_metadata_len(partition, &image_length) == ESP_OK) {\n    if (response) {\n      return esp_partition_get_free_size(partition);\n    } else {\n      return image_length;\n    }\n  }\n  return 0;\n#else\n  return 0;\n#endif\n}", "CodeBleu_score": 39.94736811770528}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t#if defined(ARDUINO_ARCH_ESP8266)\n  if (response) {\n    return ESP.getFreeSketchSpace();\n  } else {\n    return ESP.getSketchSize();\n  }\n#else\n  esp_partition_t *running = esp_ota_get_running_partition();\n  if (running == NULL) {\n    return 0;\n  }\n\n  uint32_t total_space = 0;\n  uint32_t used_space = 0;\n  esp_partition_info_t part_info;\n  esp_partition_get_info(running, &part_info);\n  if (part_info.type == ESP_PARTITION_TYPE_APP) {\n    total_space = part_info.size;\n    esp_image_metadata_t metadata;\n    esp_image_metadata_load(running->address, &metadata);\n    if (response) {\n      used_space = total_space - metadata.free_space;\n    } else {\n      used_space = total_space - metadata.app_size;\n    }\n  }\n  return used_space;\n#endif\n}", "CodeBleu_score": 47.721165398972126}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t#if CONFIG_IDF_TARGET_ESP32\n  esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n#else\n  esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n#endif\n  if (it == NULL) {\n    return 0;\n  }\n  esp_partition_iterator_release(it);\n  esp_partition_t *partition = esp_partition_get(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n  if (partition == NULL) {\n    return 0;\n  }\n  uint32_t size = 0;\n  if (response) {\n    size = partition->size - partition->address;\n  } else {\n    size = partition->size;\n  }\n  return size;\n}", "CodeBleu_score": 38.42103165524955}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tize_t total_sectors = msc_update_get_required_disk_sectors();\n\tif (total_sectors == 0) {\n\t\tlog_e(\"Failed to get required disk sectors\");\n\t\treturn false;\n\t}\n\n\tmsc_total_sectors = total_sectors;\n\tmsc_ram_disk = (uint8_t *)malloc(total_sectors * DISK_SECTOR_SIZE);\n\tif (msc_ram_disk == NULL) {\n\t\tlog_e(\"Failed to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\n\tmsc_boot = (fat_boot_sector_t *)msc_ram_disk;\n\tmsc_table = msc_ram_disk + (msc_total_sectors - msc_table_sectors) * DISK_SECTOR_SIZE;\n\tif (!fat_setup_boot_sector(msc_boot, msc_total_sectors, msc_table, DISK_SECTOR_SIZE, mcs_is_fat16)) {\n\t\tlog_e(\"Failed to set up boot sector\");\n\t\treturn false;\n\t}\n\n\tif (msc_run_partition) {\n\t\tfw_start_sector = msc_total_sectors - msc_table_sectors - FAT_SIZE_TO_SECTORS(fw_size);\n\t\tfw_end_sector = fw_start_sector + FAT_SIZE_TO_SECTORS(fw_size) - 1;\n\t\tif (!fat_add_file_to_root_dir(msc_boot, msc_table, fw_start_sector, fw_size, volume_label, serial_number)) {\n\t\t\tlog_e(\"Failed to add firmware file to root directory\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.12601531179983}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % ESP_PARTITION_WRITE_SIZE) {\n\t\tlog_e(\"Offset %u is not aligned with sector size %u\", offset, ESP_PARTITION_WRITE_SIZE);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (offset + size > partition->size) {\n\t\tlog_e(\"Offset %u + size %u exceeds partition size %u\", offset, size, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = ESP_OK;\n\tif (offset % partition->erase_size) {\n\t\terr = esp_partition_erase_range(partition, offset & ~(partition->erase_size - 1), partition->erase_size);\n\t\tif (err!= ESP_OK) {\n\t\t\tlog_e(\"Failed to erase partition at offset %u\", offset);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tlog_e(\"Failed to write to partition at offset %u\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 48.29356202572723}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->erase_size) {\n\t\tlog_e(\"Offset not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, offset, size)) {\n\t\tlog_e(\"Failed to erase flash sector\");\n\t\treturn ESP_ERR_INVALID_STATE;\n\t}\n\tif (esp_partition_write(partition, offset, data, size)) {\n\t\tlog_e(\"Failed to write to flash\");\n\t\treturn ESP_FAIL;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 37.48787927611836}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % DISK_SECTOR_SIZE) {\n\t\tlog_e(\"offset not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % DISK_SECTOR_SIZE) {\n\t\tlog_e(\"size not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err) {\n\t\tlog_e(\"failed to erase flash sector: %s\", esp_err_to_name(err));\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err) {\n\t\tlog_e(\"failed to write data: %s\", esp_err_to_name(err));\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 46.69849951412438}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\twhile (*in && i < maxlen) {\n\t\tuint8_t c = hex_char_to_byte(*in++);\n\t\tif (c < 0x10) {\n\t\t\tuint8_t c2 = hex_char_to_byte(*in++);\n\t\t\tif (c2 < 0x10) {\n\t\t\t\tout[i++] = (c << 4) | c2;\n\t\t\t}\n\t\t}\n\t\tin++;\n\t}\n\treturn i;\n}", "CodeBleu_score": 36.9248978458258}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\tuint8_t b;\n\tuint8_t c;\n\n\twhile (in[i]!= 0 && j < maxlen) {\n\t\tc = hex_char_to_byte(in[i++]);\n\t\tif (c < 0x10) {\n\t\t\tb = c << 4;\n\t\t\tc = hex_char_to_byte(in[i++]);\n\t\t\tif (c < 0x10) {\n\t\t\t\tout[j++] = b | c;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn j;\n}", "CodeBleu_score": 37.314694179509914}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i, j;\n\tuint8_t c;\n\n\tfor (i = j = 0; i < strlen(in) && j < maxlen; i++) {\n\t\tc = hex_char_to_byte(in[i]);\n\t\tif (c < 16) {\n\t\t\tif (i & 1) {\n\t\t\t\tout[j++] |= c;\n\t\t\t} else {\n\t\t\t\tout[j] = c << 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn j;\n}", "CodeBleu_score": 41.237782912617135}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buf == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, (TickType_t)10) == pdTRUE) {\n\t\tint free_space = xRingbufferGetFreeSpace(tx_ring_buf);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free_space;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 72.49529158369485}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buf == NULL || tx_lock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, (TickType_t)10) == pdTRUE) {\n\t\tuint32_t free_size = xRingbufferGetFreeSize(tx_ring_buf);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free_size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 73.09959410558446}, {"code": "int HWCDC::availableForWrite(void){\n\tif (!tx_ring_buf) {\nreturn 0;\n}\nif (xSemaphoreTake(tx_lock, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\nsize_t free_size = xRingbufferGetFreeSize(tx_ring_buf);\nxSemaphoreGive(tx_lock);\nreturn free_size;\n}\nreturn 0;\n}", "CodeBleu_score": 55.76192607438648}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tISABLE_HAL_LOCKS\n  HSERIAL_MUTEX_LOCK();\n#endif\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n  // this can be called after Serial.begin(), therefore it shall create the event task\n  if (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n    _createEventTask(this);\n  }\n#if!CONFIG_DISABLE_HAL_LOCKS\n  HSERIAL_MUTEX_UNLOCK();\n#endif\n}", "CodeBleu_score": 30.06817408450253}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tX_LOCK();\n// function may be NULL to cancel onReceive() from its respective task\n_onReceiveCB = function;\n// this can be called after Serial.begin(), therefore it shall create the event task\nif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n_createEventTask(this);\n}\nHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 26.04607333271014}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tEX_LOCK();\n\t// function may be NULL to cancel onReceive() from its respective task\n\t_onReceiveCB = function;\n\t// this can be called after Serial.begin(), therefore it shall create the event task\n\tif (function!= NULL && _uart!= NULL && _eventTask == NULL) {\n\t\t_createEventTask(this);\n\t}\n\tHSERIAL_MUTEX_UNLOCK();\n}", "CodeBleu_score": 26.341643165694524}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length - 1) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\t*buffer = 0;\n\treturn index;\n}", "CodeBleu_score": 77.21260769789812}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\twhile (count < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tcount++;\n\t}\n\treturn count;\n}", "CodeBleu_score": 62.08442318041103}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\twhile (count < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tcount++;\n\t}\n\treturn count;\n}", "CodeBleu_score": 62.08442318041103}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (tone_init()) {\n\t\ttone_msg_t tone_msg = {\n\t\t\t.tone_cmd = TONE_START,\n\t\t\t.pin = pin,\n\t\t\t.frequency = frequency,\n\t\t\t.duration = duration,\n\t\t};\n\t\txQueueReset(_tone_queue);  // clear queue\n\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 48.49995217290274}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (tone_init()) {\n\t\ttone_msg_t tone_msg = {\n\t\t\t.tone_cmd = TONE_START,\n\t\t\t.pin = pin,\n\t\t\t.frequency = frequency,\n\t\t\t.duration = duration,\n\t\t};\n\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 44.44309713297493}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t_d(\"tone was called\");\n\tif (tone_init()) {\n\t\ttone_msg_t tone_msg = {\n\t\t\t.tone_cmd = TONE_START,\n\t\t\t.pin = pin,\n\t\t\t.frequency = frequency,\n\t\t\t.duration = duration,\n\t\t};\n\t\txQueueReset(_tone_queue);  // clear queue\n\t\txQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 48.49995217290274}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3\n  if (serial_number == \"__MAC__\") {\n    StreamString s;\n    uint8_t m[6];\n    esp_efuse_mac_get_default(m);\n    s.printf(\"%02X%02X%02X%02X%02X%02X\", m[0], m[1], m[2], m[3], m[4], m[5]);\n    serial_number = s;\n  }\n#endif\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled && usb_version < 0x0210) {\n      usb_version = 0x0210;\n    }\n  }\n  return!_started;\n}", "CodeBleu_score": 75.45332915236311}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CFG_TUD_WEBUSB\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      if (usb_version < 0x0210) {\n        usb_version = 0x0210;\n      }\n    }\n  }\n  return!_started;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 73.115114960558}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t#if CFG_TUD_WEBUSB\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled) {\n      if (usb_version < 0x0210) {\n        usb_version = 0x0210;\n      }\n    }\n  }\n  return!_started;\n#else\n  return false;\n#endif /* CFG_TUD_WEBUSB */\n}", "CodeBleu_score": 71.66873826470848}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t#if ARDUINO_USB_CDC_DEBUG\n  log_d(\"USBCDC::_onRX\");\n#endif\n  if (!connected) {\n    return;\n  }\n\n  uint8_t buf[64];\n  uint32_t len = 0;\n  while (len < sizeof(buf)) {\n    uint32_t rlen = arduino_usb_cdc_read_data(itf, buf + len, sizeof(buf) - len);\n    if (rlen == 0) {\n      break;\n    }\n    len += rlen;\n  }\n\n  if (len) {\n    arduino_usb_cdc_event_data_t p;\n    p.rx_data.data = buf;\n    p.rx_data.length = len;\n    arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_DATA_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n  }\n}", "CodeBleu_score": 42.16286687512418}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t ch = 0;\n\twhile (arduino_usb_cdc_read(itf, &ch, 1) == 1) {\n\t\tif (rx_queue) {\n\t\t\tif (!xQueueSend(rx_queue, &ch, 0)) {\n\t\t\t\tarduino_usb_cdc_event_data_t p;\n\t\t\t\tp.rx_overflow.dropped_bytes = uxQueueMessagesWaiting(rx_queue);\n\t\t\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t\t\t\tlog_e(\"CDC RX Overflow.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (rx_queue) {\n\t\tarduino_usb_cdc_event_data_t p;\n\t\tp.rx_data.length = uxQueueMessagesWaiting(rx_queue);\n\t\tarduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_DATA_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n\t}\n}", "CodeBleu_score": 47.58612129272864}, {"code": "void USBCDC::_onRX(){\n\t#if CONFIG_ARDUINO_USB_CDC_RX_QUEUE_SIZE\n  size_t rx_queue_len = uxQueueSpacesAvailable(rx_queue) + uxQueueMessagesWaiting(rx_queue);\n  if (rx_queue_len == 0) {\n    return;\n  }\n#endif\n  uint8_t buf[64];\n  int len = arduino_usb_cdc_read(itf, buf, sizeof(buf));\n  if (len <= 0) {\n    return;\n  }\n#if CONFIG_ARDUINO_USB_CDC_RX_QUEUE_SIZE\n  for (int i = 0; i < len; i++) {\n    if (!xQueueSend(rx_queue, &buf[i], 0)) {\n      arduino_usb_cdc_event_data_t p;\n      p.rx_overflow.dropped_bytes = len - i;\n      arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n      log_e(\"CDC RX Overflow.\");\n      break;\n    }\n  }\n#else\n  arduino_usb_cdc_event_data_t p;\n  p.rx_data.data = buf;\n  p.rx_data.length = len;\n  arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_DATA_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n#endif\n}", "CodeBleu_score": 58.89814678086638}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"devices\": robot.Devices}, res)\n\t}\n}", "CodeBleu_score": 32.29602164992657}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 88.42531884715702}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot, err := a.jsonRobotFor(req.URL.Query().Get(\":robot\")); err!= nil {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"connections\": robot.Connections,\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 31.69381715879941}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 88.42531884715702}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Device found with the name \" + req.URL.Query().Get(\":device\"),\n\t\t}, res)\n\t\treturn\n\t}\n\n\ta.executeCommand(device.Command(req.URL.Query().Get(\":command\")),\n\t\tres,\n\t\treq,\n\t)\n}", "CodeBleu_score": 56.96007789312778}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tif device := robot.Device(req.URL.Query().Get(\":device\")); device!= nil {\n\t\t\tif command := device.Command(req.URL.Query().Get(\":command\")); command!= nil {\n\t\t\t\ta.executeCommand(command, res, req)\n\t\t\t} else {\n\t\t\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\t\t\"error\": \"No Command found with the name \" + req.URL.Query().Get(\":command\"),\n\t\t\t\t}, res)\n\t\t\t}\n\t\t} else {\n\t\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\t\"error\": \"No Device found with the name \" + req.URL.Query().Get(\":device\"),\n\t\t\t}, res)\n\t\t}\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 50.39530312690115}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tcommandName := req.URL.Query().Get(\":command\")\n\n\tif robot := a.master.Robot(robotName); robot!= nil {\n\t\tif device := robot.Device(deviceName); device!= nil {\n\t\t\tif err := device.Command(commandName).Execute(); err!= nil {\n\t\t\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\t\t\"error\": err.Error(),\n\t\t\t\t}, res)\n\t\t\t}\n\t\t} else {\n\t\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\t\"error\": \"No Device found with the name \" + deviceName,\n\t\t\t}, res)\n\t\t}\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + robotName,\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 50.98511424091463}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method!= http.MethodGet && r.Method!= http.MethodHead {\n\t\t\treturn\n\t\t}\n\n\t\texpected := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\t\tactual := r.Header.Get(\"Authorization\")\n\n\t\tif actual == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare([]byte(expected), []byte(actual)) == 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.Header.Del(\"Proxy-Authorization\")\n\t}\n}", "CodeBleu_score": 55.33639295997411}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.analogRead == nil {\n\t\treturn -1, -1, errors.New(\\\"AnalogSensorDriver does not support analog reading\\\")\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 42.361550410526675}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.sensorCfg.readInterval == 0 || a.halt == nil {\n\t\t// cyclic reading deactivated\n\t\treturn 0, 0.0, nil\n\t}\n\n\trawValue, err := a.analogRead()\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 45.251218484109096}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\trawValue, err := a.analogRead()\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\tvalue := a.sensorCfg.scale(rawValue)\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 38.465646639738424}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 87.40223700581173}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 87.40223700581173}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 87.40223700581173}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, commandSoftReset); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(initTime)\n\n\tstatus, err := d.readByteData(regCommand)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif status&commandSoftReset == commandSoftReset {\n\t\treturn fmt.Errorf(\\\"MFRC522: soft reset took too long\\\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.14998139324698}, {"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, cmdSoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\n\tstatus, err := d.readByteData(regCommand)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&cmdSoftResetBit == cmdSoftResetBit {\n\t\treturn fmt.Errorf(\\\"MFRC522: soft reset failed\\\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 62.07154320553848}, {"code": "func (d *MFRC522Common) softReset() error{\n\t := d.writeByteData(regCommand, commandRegSoftReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(initTime)\n\tstatus, err := d.readByteData(regCommand)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&commandRegSoftResetBit == commandRegSoftResetBit {\n\t\treturn fmt.Errorf(\\\"MFRC522: soft reset failed, status: 0x%X\\\", status)\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.00361143759068}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// the register command is always the same, the pointer in FIFO is incremented automatically after each read\n\t// the number of bytes to be read is stored in FIFOLevel register\n\tfifoLevel, err := d.readByteData(regFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif fifoLevel&fifoLevelRegEmpty == fifoLevelRegEmpty {\n\t\treturn 0, fmt.Errorf(\"no data available in FIFO\")\n\t}\n\tif fifoLevel > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"the buffer is too small\")\n\t}\n\tfor i := uint8(0); i < fifoLevel; i++ {\n\t\tb, err := d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\t// the last bits of the received data are stored in the last byte of the backData\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 55.934394871504}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// the register command is always the same, the pointer in FIFO is incremented automatically after each write\n\tfor i := 0; i < len(backData); i++ {\n\t\tb, err := d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 35.683883322847464}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// the register command is always the same, the pointer in FIFO is incremented automatically after each write\n\tfor i := 0; i < len(backData); i++ {\n\t\tb, err := d.readByteData(regFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\t// read the control register to get the last bits received\n\trxLastBits, err := d.readByteData(regControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn rxLastBits, nil\n}", "CodeBleu_score": 35.683883322847464}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\tif err := d.writeByteData(regCommand, piccCommandHalt); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 17.184322056520955}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\tif err := d.writeByteData(regCommand, piccCommandHalt); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regComIEnReg, 0x80); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.19200693753458}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif piccDebug {\n\t\tfmt.Println(\\\"piccHalt\\\")\n\t}\n\t// Halt command: 4 bytes\n\t// 0x50 = 0b01010000\n\t// 0x00 = 0b00000000\n\t// 0x00 = 0b00000000\n\t// 0x00 = 0b00000000\n\thaltCommand := []byte{0x50, 0x00, 0x00, 0x00}\n\tcrc, err := d.calculateCRC(haltCommand)\n\tif err!= nil {\n\t\treturn err\n\t}\n\thaltCommand = append(haltCommand, crc...)\n\tif err := d.writeByteData(regCommand, piccCommandHalt); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.writeByteData(regDivIrq, 0x04); err!= nil {\n\t\treturn err\n\t}\n\t// Wait for the FIFO buffer to be emptied and stop requesting IRQ interrupts.\n\t// This avoids bugs where the card status is not updated after a halt command.\n\t// See issue #25.\n\tif err := d.waitUntilIdle(); err!= nil {\n\t\treturn err\n\t}\n\t// Wait for the card to go to state HALT.\n\tif err := d.waitUntil(func() bool { return d.readByteData(regCommand) == piccCommandHalt }); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.440326380699005}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif piccDebug {\n\t\tfmt.Println(\"backData\", backData)\n\t}\n\treturn backData, nil\n}", "CodeBleu_score": 77.9755093388608}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t\tfmt.Println(\"block\", block)\n\t}\n\t// MIFARE Classic protocol requires two steps to perform a read.\n\t// Step 1: Tell the PICC we want to read from block blockAddr.\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tbackData := make([]byte, 16)\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\tif piccDebug {\n\t\tfmt.Println(\"backData\", backData)\n\t}\n\n\t// Step 2: Retrieve the data from the specified block.\n\tvar readData []byte\n\treadData = append(readData, backData...)\n\treturn readData, nil\n}", "CodeBleu_score": 74.71603454583007}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif piccDebug {\n\t\tfmt.Println(\"-read-\")\n\t}\n\treadDataCommand := []byte{piccCommandMFRegREAD, block}\n\tcrcResult := []byte{0x00, 0x00}\n\tif err := d.calculateCRC(readDataCommand, crcResult); err!= nil {\n\t\treturn nil, err\n\t}\n\treadDataCommand = append(readDataCommand, crcResult...)\n\n\tbackData := make([]byte, 16)\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tif err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, false); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn backData, nil\n}", "CodeBleu_score": 78.01183695559773}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\\\"piccRequest: answer buffer too small\\\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tif reqMode == piccRequestMode16Bit {\n\t\ttxLastBits = 0x07\n\t}\n\n\tsendData := []byte{reqMode}\n\tif err := d.communicateWithPICC(commandRegTransceive, sendData, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.93697428267294}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif piccDebug {\n\t\tfmt.Println(\"-request-\")\n\t}\n\n\t// build the request\n\tsendData := []byte{reqMode}\n\n\t// check if the answer buffer has at least 2 bytes of space\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\\\"answer buffer too small\\\")\n\t}\n\n\t// clear the bits in the collission register\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\n\t// transmit the request\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tif err := d.communicateWithPICC(commandRegTransceive, sendData, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.94869431395114}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\\\"answer buffer too small\\\")\n\t}\n\n\tif err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err!= nil {\n\t\treturn err\n\t}\n\n\ttxLastBits := uint8(0x00) // we use all 8 bits\n\tswitch reqMode {\n\tcase piccRequestStd:\n\t\ttxLastBits = uint8(0x07) // 7 bits\n\t\tbreak\n\tcase piccRequest14443A:\n\t\ttxLastBits = uint8(0x03) // 3 bits\n\t\tbreak\n\tcase piccRequest14443B:\n\t\ttxLastBits = uint8(0x00) // 10 bits\n\t\tbreak\n\tcase piccRequest14443B2nd:\n\t\ttxLastBits = uint8(0x00) // 10 bits\n\t\tbreak\n\tcase piccRequest14443A2nd:\n\t\ttxLastBits = uint8(0x00) // 10 bits\n\t\tbreak\n\tdefault:\n\t\treturn fmt.Errorf(\\\"unknown request mode\\\")\n\t}\n\n\tsendCommand := []byte{reqMode, txLastBits}\n\tif err := d.communicateWithPICC(commandRegTransceive, sendCommand, answer, txLastBits, false); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.54180024596166}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// stepPin is active low\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.delay())\n\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 74.21954253299712}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t to ensure thread safety while accessing shared variables\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// trigger a valid step\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\t// increment or decrement the step number\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.0360705018735}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == StepperDriverForward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\tif d.stepperDebug {\n\t\tfmt.Printf(\\\"step %d %s\\\", d.stepNumber, d.direction)\n\t}\n\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay())\n\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.267912988629114}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\\\"distance monitor is already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\terr := d.measureDistance()\n\t\t\tif err!= nil {\n\t\t\t\tfmt.Printf(\\\"error on distance measurement: %v\\\n\\\", err)\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\treturn\n\t\t\tcase <-time.After(hcsr04MonitorUpdate):\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 52.105469755951674}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopWaitGroup.Done()\n\t\t\t\treturn\n\t\t\tcase <-time.After(hcsr04MonitorUpdate):\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\\\"error on measure distance: %v\\\n\\\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 52.44886374431156}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\teMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\\\"distance monitor already running\\\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.startDistanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 36.389808016795676}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startMicroSec int64\n\treturn func(pinID int, duration time.Duration, name string, pinValue, pinEdge uint32) {\n\t\tif pinEdge == system.PinEdgeRising {\n\t\t\tstartMicroSec = time.Now().UnixNano() / 1000\n\t\t} else if pinEdge == system.PinEdgeFalling {\n\t\t\td.delayMicroSecChan <- time.Now().UnixNano()/1000 - startMicroSec\n\t\t}\n\t}\n}", "CodeBleu_score": 39.172703745893045}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pinID int, duration time.Duration, name string, pinValue, edge uint32) {\n\t\tif name!= d.echoPin.Name() {\n\t\t\treturn\n\t\t}\n\t\tif edge == system.EdgeFallingEdge {\n\t\t\td.measureMutex.Lock()\n\t\t\td.lastMeasureMicroSec = duration.Nanoseconds() / 1000\n\t\t\td.measureMutex.Unlock()\n\t\t}\n\t}\n}", "CodeBleu_score": 42.070960253434876}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pinID int, duration time.Duration, event string, value uint32, timestamp uint32) {\n\t\tif event == system.EventRisingEdge {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if event == system.EventFallingEdge {\n\t\t\td.delayMicroSecChan <- int64(time.Since(startTimestamp) / time.Microsecond)\n\t\t}\n\t}\n}", "CodeBleu_score": 42.45219670329096}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerPin.Write(system.DigitalPinValueHigh); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulseDuration)\n\n\tif err := d.triggerPin.Write(system.DigitalPinValueLow); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\tselect {\n\tcase d.lastMeasureMicroSec = <-d.delayMicroSecChan:\n\t\treturn nil\n\tcase <-time.After(hcsr04MeasureTimeout):\n\t\treturn fmt.Errorf(\"timeout on measurement\")\n\t}\n}", "CodeBleu_score": 60.16147982675204}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.triggerPin.Write(0); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\ttime.Sleep(hcsr04TriggerPulseDuration)\n\tif err := d.triggerPin.Write(1); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger pin write: %v\", err)\n\t}\n\n\tselect {\n\tcase d.lastMeasureMicroSec = <-d.delayMicroSecChan:\n\t\treturn nil\n\tcase <-time.After(hcsr04Timeout):\n\t\treturn fmt.Errorf(\"timeout on measure distance\")\n\t}\n}", "CodeBleu_score": 61.31127692327543}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// ensure that start and stop can not interfere\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already started for '%s'\", d.driverCfg.name)\n\t}\n\n\t// trigger the sensor\n\tif err := d.triggerPin.DigitalWrite(1); err!= nil {\n\t\treturn fmt.Errorf(\"error on trigger sensor: %v\", err)\n\t}\n\n\t// wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.delayMicroSecChan:\n\t\t// measurement completed\n\tcase <-time.After(hcsr04MeasureTimeout):\n\t\t// timeout occurred\n\t\treturn fmt.Errorf(\"timeout on measurement for '%s'\", d.driverCfg.name)\n\t}\n\n\t// store the measured time in microseconds\n\td.lastMeasureMicroSec = <-d.delayMicroSecChan\n\n\treturn nil\n}", "CodeBleu_score": 52.92544331586877}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\\\"PLATFORMIO_ACCOUNT_TOKEN\\\")\n    if token:\n        return token\n\n    account = app.get_state_item(\\\"account\\\")\n    if not account or \\\"auth\\\" not in account:\n        raise AccountNotAuthorized()\n\n    auth = account[\\\"auth\\\"]\n    if \\\"access_token\\\" not in auth or \\\"expires_at\\\" not in auth:\n        raise AccountNotAuthorized()\n\n    expires_at = int(auth[\\\"expires_at\\\"])\n    if expires_at > time.time():\n        return auth[\\\"access_token\\\"]\n\n    if \\\"refresh_token\\\" not in auth:\n        raise AccountNotAuthorized()\n\n    self.refresh_token(auth[\\\"refresh_token\\\"])\n    return auth[\\\"access_token\\\"]\n\n", "CodeBleu_score": 28.89344270967465}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ.get(\\\"PLATFORMIO_ACCOUNT_ACCESS_TOKEN\\\")\n    except Exception as exc:\n        raise AccountError(exc) from exc\n\n    try:\n        account = app.get_state_item(\\\"account\\\")\n        if not account or not account.get(\\\"auth\\\") or not account[\\\"auth\\\"].get(\\\"access_token\\\") or not account[\\\"auth\\\"].get(\\\"expires_at\\\"):\n            raise AccountNotAuthorized()\n        expires_at = account[\\\"auth\\\"].get(\\\"expires_at\\\")\n        if expires_at < int(time.time()) and account[\\\"auth\\\"].get(\\\"refresh_token\\\"):\n            self.refresh_authentication_token()\n        return account[\\\"auth\\\"].get(\\\"access_token\\\")\n    except Exception as exc:\n        raise AccountError(exc) from exc\n\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 32.752860802744046}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.getenv(\\\"PIO_ACCOUNT_ACCESS_TOKEN\\\")\n    if token is not None:\n        return token\n\n    account = app.get_state_item(\\\"account\\\")\n    if account is None:\n        raise AccountNotAuthorized()\n\n    token = account.get(\\\"auth\\\").get(\\\"access_token\\\")\n    if token is None:\n        raise AccountNotAuthorized()\n\n    expires_at = account.get(\\\"auth\\\").get(\\\"expires_at\\\")\n    if expires_at is None:\n        raise AccountNotAuthorized()\n\n    if expires_at < time.time():\n        refresh_token = account.get(\\\"auth\\\").get(\\\"refresh_token\\\")\n        if refresh_token is None:\n            raise AccountNotAuthorized()\n\n        try:\n            data = self.fetch_json_data(\\\"/auth/refresh\\\", method=\\\"POST\\\", data={\\\"refresh_token\\\": refresh_token})\n        except AccountError as exc:\n            raise AccountNotAuthorized() from exc\n\n        expires_at = data.get(\\\"expires_at\\\")\n        if expires_at is None:\n            raise AccountNotAuthorized()\n\n        account[\\\"auth\\\"] = {\\\"access_token\\\": data.get(\\\"access_token\\\"), \\\"expires_at\\\": expires_at, \\\"refresh_token\\\": refresh_token}\n        app.set_state_item(\\\"account\\\", account)\n\n        return account[\\\"auth\\\"][\\\"access_token\\\"]\n\n    return token\n\n", "CodeBleu_score": 33.31092220288435}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \\\"post\\\",\n            \\\"/v1/logout\\\",\n            headers={\n                \\\"Authorization\\\": \\\"Bearer %s\\\" % refresh_token\n            },\n        )\n        return True\n    except AccountError:\n        pass\n    return False\n\n    def get_summary(self, username=None):\n        \"\"\"The function \"get_summary\" retrieves the user's summary data from the \"/v1/users/{username}/summary\" endpoint.", "CodeBleu_score": 48.74451088340168}, {"code": "def logout(self)\n\t\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\"Authorization\": \"Bearer %s\" % self.get_refresh_token()},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 53.882287972265395}, {"code": "def logout(self)\n\t\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            headers={\n                \"Authorization\": \"Bearer %s\" % self.get_refresh_token()\n            },\n        )\n    except AccountError:\n        pass\n    return True\n", "CodeBleu_score": 53.562268438945104}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\"optional\"):\n            continue\n        version = options.get(\"version\")\n        pkg = self.get_package(name, self.get_package_spec(name, version))\n        if pkg:\n            result.append(pkg)\n    return result\n", "CodeBleu_score": 42.50858467128942}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\\\"optional\\\"):\n            continue\n        versions = [options.get(\\\"version\\\")]\n        versions.extend(options.get(\\\"optionalVersions\\\", []))\n        for version in versions:\n            if not version:\n                continue\n            pkg = self.get_package(name, self.get_package_spec(name, version))\n            if pkg:\n                result.append(pkg)\n        return result\n\n\n\n", "CodeBleu_score": 37.03717239343632}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, options in dict(sorted(self.packages.items())).items():\n        if options.get(\\\"optional\\\"):\n            continue\n        versions = [options.get(\\\"version\\\")]\n        versions.extend(options.get(\\\"optionalVersions\\\", []))\n        for version in versions:\n            if not version:\n                continue\n            pkg = self.get_package(name, self.get_package_spec(name, version))\n            if pkg:\n                result.append(pkg)\n        return result\n\n\n", "CodeBleu_score": 37.03717239343632}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env:\n        raise UndefinedEnvPlatformError(env)\n\n    env_name = env.upper()\n    env_spec = ProjectConfig.get(\\\"env:%s\\\" % env_name)\n    if not env_spec:\\\n        raise UndefinedEnvPlatformError(env)\n\n    if not targets:\\\n        targets = ProjectConfig.get(\\\"env:%s.build.targets\\\" % env_name, [])\\\n\n    platform_spec = env_spec.get(\\\"platform\\\")\n    if not platform_spec:\\\n        raise UndefinedEnvPlatformError(env)\n\n    return cls.new(platform_spec, autoinstall).configure_env(env, targets)\n", "CodeBleu_score": 40.08404554373419}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env or not isinstance(env, str):\n        raise TypeError(\n            \"The environment name must be a string, not %r\" % type(env).__name__\n        )\n\n    env = ProjectConfig.get_instance().get(\\\"env:%s\\\" % env)\n    if not env:\\\n        raise UndefinedEnvPlatformError(env)\n\n    return cls.new(env, targets, autoinstall)\n\n", "CodeBleu_score": 38.561608099501235}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if env not in ProjectConfig.get_instance().envs:\n        raise UndefinedEnvPlatformError(env)\n    platform_spec = ProjectConfig.get_instance().envs[env].get(\\\"platform\\\")\n    if not platform_spec:\\\n        raise UndefinedEnvPlatformError(env)\n    return cls.new(platform_spec, autoinstall=autoinstall).configure_default_packages(env, targets=targets)\n", "CodeBleu_score": 25.619960756665627}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us!= 0) {\n\t\tWrite1Byte(0x88, 0x01);\n\t\tWrite32bit(0x8C, time_in_us);\n\t}\n\tWrite1Byte(0x30, 0x00);\n\tWrite1Byte(0x30, Read8bit(0x30) | 0x80);\n}", "CodeBleu_score": 31.23345523147482}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tWire1.beginTransmission(0x34);\n\t\tWire1.write(0x40);\n\t\tWire1.write((time_in_us >> 24) & 0xFF);\n\t\tWire1.write((time_in_us >> 16) & 0xFF);\n\t\tWire1.write((time_in_us >> 8) & 0xFF);\n\t\tWire1.write(time_in_us & 0xFF);\n\t\tWire1.endTransmission();\n\t}\n\tWire1.beginTransmission(0x34);\n\tWire1.write(0x41);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, 1);\n\tuint8_t buf = Wire1.read();\n\tif (time_in_us) {\n\t\tif (buf & 0x01) {\n\t\t\tWire1.beginTransmission(0x34);\n\t\t\tWire1.write(0x41);\n\t\t\tWire1.write(buf & 0xFE);\n\t\t\tWire1.endTransmission();\n\t\t}\n\t}\n}", "CodeBleu_score": 41.13333416162268}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\t// Enable timer\n\t\tWrite1Byte(0x82, 0x80);\n\t\t// Set timer\n\t\tWrite32bit(0x84, time_in_us);\n\t}\n\t// Initiate deep sleep\n\tWrite1Byte(0x12, 0x80);\n}", "CodeBleu_score": 36.15301804791679}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t//  Serial.println(F(\"scroll_line()\"));\n  int y_prev = yDraw;\n  tft.fillRect(0, yDraw, HEIGHT_1, TEXT_HEIGHT, color);\n  yDraw += TEXT_HEIGHT;\n  if (yDraw >= yArea) {\n    yDraw = yStart;\n  }\n  if (tteBar) {\n    yDraw = yStart;\n  }\n  return y_prev;\n}", "CodeBleu_score": 19.364782597231446}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_old = yDraw;\n\tif (!tteBar)\n\t\ttft.fillRect(0, yDraw, SCREEN_WIDTH, TEXT_HEIGHT, color);\n\telse\n\t\ttft.fillRect(0, yDraw, SCREEN_WIDTH, TEXT_HEIGHT, color);\n\tyDraw += TEXT_HEIGHT;\n\tif (yDraw > yArea) {\n\t\tyDraw = yStart;\n\t\tscroll_addr = 0;\n\t}\n\treturn y_old;\n}", "CodeBleu_score": 23.20631902895096}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y;\n\n\tif (!tteBar) {\n\t\ty = yStart;\n\t\tyStart += TEXT_HEIGHT;\n\t\tif (yStart >= YMAX - BOT_FIXED_AREA) {\n\t\t\tyStart = TOP_FIXED_AREA;\n\t\t}\n\t} else {\n\t\ty = yStart;\n\t\tyStart += TEXT_HEIGHT;\n\t\tif (yStart >= YMAX - BOT_FIXED_AREA_2) {\n\t\t\tyStart = TOP_FIXED_AREA_2;\n\t\t}\n\t}\n\ttft.fillRect(0, y, TFT_WIDTH, TEXT_HEIGHT, color);\n\treturn y;\n}", "CodeBleu_score": 33.51936216672073}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->setup();\n\n\tthis->has_html = this->setupHTML(html_files);\n\n\tthis->has_ap = this->setupAccessPoints(access_points);\n\n\tif (this->has_html && this->has_ap) {\n\t\tthis->runServer = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 37.983623098393494}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t#ifdef HAS_SD\n\t\tif (sd_obj.supported) {\n\t\t\tsd_obj.listDirToLinkedList(html_files, \"/\", \"html\");\n\n\t\t\tSerial.println(\"Evil Portal Found \" + (String)html_files->size() + \" HTML files\");\n\t\t}\n\t#endif\n\n\tif (this->setupAccessPoints(access_points) && this->setupHTML(html_files)) {\n\t\tthis->runServer = true;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 48.18763901432911}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\n  #ifdef HAS_SD\n    if (sd_obj.supported) {\n      sd_obj.listDirToLinkedList(html_files, \\\"/\\\", \\\"html\\\");\n\n      Serial.println(\\\"Evil Portal Found \\\" + (String)html_files->size() + \\\" HTML files\\\");\n    }\n  #endif\n\n  if (this->has_ap) {\n    Serial.println(\\\"Evil Portal has already been started\\\");\n    return false;\n  }\n\n  if (access_points->size() == 0) {\n    Serial.println(\\\"Evil Portal: No access points to start\\\");\n    return false;\n  }\n\n  this->has_ap = true;\n\n  if (this->has_html) {\n    this->runServer = true;\n    this->startServer();\n    return true;\n  }\n\n  Serial.println(\\\"Evil Portal: Starting Access Points\\\");\n  this->has_ap = this->startAccessPoints(access_points);\n\n  if (this->has_ap) {\n    Serial.println(\\\"Evil Portal: Starting HTML content\\\");\n    this->has_html = this->startHTML(ssids);\n  }\n\n  if (this->has_ap && this->has_html) {\n    this->runServer = true;\n    this->startServer();\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 45.11783773774175}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue) {\n\t\t\tif (this->queue->size()) {\n\t\t\t\tthis->flush_queue();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis->new_queue();\n\t\t}\n\n\t\tif (this->text) {\n\t\t\tif (this->text->size()) {\n\t\t\t\tthis->flush_text();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis->new_text();\n\t\t}\n\n\t\tif (this->text_in) {\n\t\t\tif (this->text_in->size()) {\n\t\t\t\tthis->flush_text_in();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis->new_text_in();\n\t\t}\n\t}\n\telse {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 23.101593831463727}, {"code": "void GpsInterface::enable_queue(){\n\t\tif(this->queue_enabled_flag) {\n\t\tif(!this->queue)\n\t\t\tthis->new_queue();\n\n\t\tif(!this->text) {\n\t\t\tthis->text = new LinkedList<String>;\n\t\t\tthis->text_cycles = 0;\n\t\t}\n\n\t\tif(!this->text_in)\n\t\t\tthis->text_in = new LinkedList<String>;\n\t} else {\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->flush_queue();\n\t}\n}", "CodeBleu_score": 45.40224318411532}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (!this->queue_enabled_flag) {\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->flush_queue();\n\t}\n}", "CodeBleu_score": 15.9563545665248}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n\t\tdelete delme;\n\t} else\n\t\tthis->new_queue();\n}", "CodeBleu_score": 64.99678260565457}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\t#ifdef GPS_NMEA_MAXQUEUE\n\t\t\tif (this->queue->size() >= GPS_NMEA_MAXQUEUE)\n\t\t#else\n\t\t\tif (this->queue->size() >= 30)\n\t\t#endif\n\t\t\tthis->queue->clear();\n\t\telse {\n\t\t\tLinkedList<nmea_sentence_t> *delme = this->queue;\n\t\t\tthis->queue = new LinkedList<nmea_sentence_t>;\n\t\t\tdelete delme;\n\t\t}\n\t}\n\telse\n\t\tthis->new_queue();\n}", "CodeBleu_score": 66.95230006534035}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif(this->queue){\n\t\tLinkedList<nmea_sentence_t> *delme=this->queue;\n\t\tthis->queue=new LinkedList<nmea_sentence_t>;\n\t\tdelete delme;\n\t}\n\telse\n\t\tthis->new_queue();\n}", "CodeBleu_score": 66.20603033851474}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tifdef HAS_ILI9341\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(color_p->full);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n#endif\n#ifdef HAS_ILI9488\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(color_p->full);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n#endif\n  }", "CodeBleu_score": 64.12614266754318}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tifdef HAS_ILI9341\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1) + 1, (area->y2 - area->y1) + 1);\n    display_obj.tft.pushColors(color_p, (area->x2 - area->x1) * (area->y2 - area->y1), true);\n#endif\n  }", "CodeBleu_score": 25.1583715656306}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t#if (defined(MARAUDER_V6_1))\n  display_obj.tft.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, TFT_BLACK);\n#endif\n  display_obj.tft.setTextColor(TFT_WHITE, TFT_BLACK);\n  display_obj.tft.setTextWrap(false);\n  display_obj.tft.setCursor(0, 0);\n  for (int i = 0; i < menu->list->size(); i++) {\n    MenuNode * node = menu->list->get(i);\n    if (node->isHidden()) {\n      continue;\n    }\n    for (int j = 0; j < layer; j++) {\n      display_obj.tft.print(' ');\n    }\n    display_obj.tft.print(node->name);\n    display_obj.tft.println();\n  }\n  display_obj.tft.println();\n}", "CodeBleu_score": 51.73138895643446}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println(menu->list->get(i).name);\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 69.4569381218936}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t#ifdef MARAUDER_V6_1\n  if (menu->list->size() == 0) {\n    return;\n  }\n\n  // Iterate through all nodes in the list\n  for (int i = 0; i < menu->list->size(); i++) {\n    // Get current node\n    MenuNode * node = menu->list->get(i);\n\n    // Print name of node\n    display_obj.tft.print(String(node->name).c_str());\n\n    // Print indentation\n    for (int j = 0; j < layer; j++) {\n      display_obj.tft.print(\\\"  \\\");\n    }\n\n    // Print checkmark if node is selected\n    if (node->selected) {\n      display_obj.tft.print(\\\"\\\\u2713\\\");\n    }\n\n    // Print newline\n    display_obj.tft.println();\n  }\n\n  // Print newline\n  display_obj.tft.println();\n#endif\n}", "CodeBleu_score": 54.63350033870792}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tfor (int i = 0; i < count; i++) {\n\t\tString essid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tessid += (char)random(65, 90);\n\t\t}\n\t\tthis->addSSID(essid);\n\t}\n\treturn ssids->size();\n}", "CodeBleu_score": 29.306871625154983}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tfor (int i = 0; i < count; i++) {\n\t\tString essid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tessid += String(random(0, 10));\n\t\t}\n\t\taddSSID(essid);\n\t}\n\treturn ssids->size();\n}", "CodeBleu_score": 29.02957520198791}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\t// Iterate through the given count\n\tfor (int i = 0; i < count; i++) {\n\t\t// Create a random SSID\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char)random(97, 122);\n\t\t}\n\n\t\t// Create a random channel\n\t\tint channel = random(1, 12);\n\n\t\t// Create a random MAC address\n\t\tuint8_t mac[6];\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tmac[j] = random(256);\n\t\t}\n\n\t\t// Create a random hidden flag\n\t\tbool hidden = random(2);\n\n\t\t// Create a new SSID object\n\t\tssid s = {ssid, channel, mac, hidden};\n\n\t\t// Add the SSID to the list\n\t\tssids->add(s);\n\n\t\t// Print the SSID to the serial output\n\t\tSerial.println(ssids->get(ssids->size() - 1).essid);\n\t}\n\n\t// Return the number of generated SSIDs\n\treturn ssids->size();\n}", "CodeBleu_score": 56.667399770471924}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    topic = publisher.create_topic(topic)\n    print(\\\"Created topic: {}\\\".format(topic.name))\n\n", "CodeBleu_score": 47.32607285393667}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    topic = publisher.create_topic(topic)\n    print(f\"Created topic: {topic}\")\n\n\n\n", "CodeBleu_score": 45.856964764076196}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\\\"Created topic {topic.name}\\\")\n\n", "CodeBleu_score": 47.49287496985148}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.88837816894339}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.88837816894339}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.88837816894339}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\\"{}\\\" on topic \\\"{}\\\" with QoS {}'.format(\n        message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        print('Turning on...')\n        # Capture a preview image\n        preview = subprocess.run(['raspistill', '-o', 'preview.jpg', '-w', '640', '-h', '480', '-n', '-t', '1'], capture_output=True, text=True)\n        if preview.returncode!= 0:\n            print(preview.stderr)\n            return\n        # Upload the preview image to a specified bucket\n        storage_client = storage.Client()\n        bucket = storage_client.bucket(os.environ.get('BUCKET_NAME'))\n        blob = bucket.blob('preview.jpg')\n        blob.upload_from_filename('preview.jpg')\n        # Publish the file's URL to an MQTT event topic\n        url = 'https://storage.googleapis.com/{}/{}'.format(bucket.name, blob.name)\n        publish_messages(os.environ.get('PROJECT_ID'), os.environ.get('TOPIC_NAME'), url)\n    else:\n        print('Turning off...')", "CodeBleu_score": 42.15709271321918}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\\"{}\\\" on topic \\\"{}\\\" with QoS {}'.format(\n        str(message.payload.decode('utf-8')), message.topic, message.qos))\n    if str(message.payload.decode('utf-8')) == 'on':\n        print('Capturing image...')\n        os.system('fswebcam -r 1280x720 -S 10 -D 1 --no-banner /home/pi/Desktop/image.jpg')\n        print('Uploading image...')\n        upload_blob(bucket_name, 'image.jpg', '/home/pi/Desktop/image.jpg')\n        print('Publishing image URL...')\n        publish_messages(project_id, topic_name, 'https://storage.googleapis.com/pi-camera-iot-bucket/image.jpg')\n    else:\n        print('off')\n", "CodeBleu_score": 31.628616201133475}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \"{}\" on topic \"{}\" with QoS {}'.format(message.payload.decode('utf-8'), message.topic, message.qos))\n    if message.payload.decode('utf-8') == 'on':\n        print('Capturing image...')\n        # Capture a preview image from the camera and upload it to a specified bucket.\n        preview_image = capture_preview()\n        upload_blob(preview_image, bucket_name)\n        # Publish the image's URL to an MQTT event topic.\n        publish_messages(project_id, topic_name, preview_image.public_url)\n    else:\n        print('off')", "CodeBleu_score": 28.89166765707884}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Google Cloud IoT MQTT device connection')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP project ID')\n    parser.add_argument(\n        '--subscription_name',\n        help='Pub/Sub subscription name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 47.595756960536406}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Cloud IoT MQTT device connection.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP project id where the Cloud IoT Core device is located in. '\n        'If not provided, falls back to the value of the GOOGLE_CLOUD_PROJECT '\n        'environment variable.'\n    )\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Cloud IoT Core registry id where the device is registered in.'\n    )\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Cloud IoT Core device id.'\n    )\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='The name of the Cloud Pub/Sub subscription to which messages are '\n        'published by the device.'\n    )\n    return parser.parse_args()\n\n", "CodeBleu_score": 41.48326694134596}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection')\n    parser.add_argument('--project_id',\n                        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n                        help='GCP project ID')\n    parser.add_argument('--subscription_name',\n                        default='projects/iot-270916/subscriptions/iot-subscription',\n                        help='Pub/Sub subscription name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 44.723993418538946}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}'.format(project_id, location, registry_id)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    credentials = credentials.with_scopes(scopes)\n    return discovery.build('cloudiot', version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 38.059256040033304}, {"code": "def get_client(service_account_json)\n\t\n\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}/devices:publish'.format(PROJECT_ID, LOCATION, REGISTRY_ID)\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n\n    credentials = credentials.with_scopes(scopes)\n\n    return discovery.build('cloudiot', version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 38.4793294621139}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    credentials = credentials.with_scopes(scopes)\n    return discovery.build(\n        \"cloudiot\", \"v1\", credentials=credentials, discoveryServiceUrl=\"https://cloudiot.googleapis.com/v1/services/\"\n    )\n\n", "CodeBleu_score": 21.2979621636623}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method\n    try:\n        asn1_code = hashes.get_asn1_digest_code(hash_method)\n    except ValueError:\n        raise ValueError('Invalid hash method')\n\n    # Concatenate the ASN1 code with the hash value\n    asn1_hash = asn1_code + hash_value\n\n    # Pad the concatenated hash for signing\n    padded_hash = _pad_for_signing(asn1_hash, common.byte_size(priv_key.n))\n\n    # Encrypt the padded hash using the private key\n    encrypted_signature = encrypt(padded_hash, priv_key)\n\n    return encrypted_signature\n\n", "CodeBleu_score": 41.766198565549566}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method not in HASH_METHODS:\n        raise ValueError('Invalid hash method')\n    hash_asn1 = HASH_METHODS[hash_method]\n    hash_value = hash_asn1 + hash_value\n    padded_hash = _pad_for_signing(hash_value, common.byte_size(priv_key.n))\n    encrypted_signature = encrypt(padded_hash, priv_key)\n    return encrypted_signature\n\n", "CodeBleu_score": 39.688613812039094}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_asn1 = HASH_ASN1_MAP[hash_method]\n    if hash_asn1 is None:\n        raise ValueError('Unknown hash method: %s' % hash_method)\n    hash_asn1_bytes = transform.int2bytes(hash_asn1, 2)\n    hash_asn1_and_hash = hash_asn1_bytes + hash_value\n    padded_hash = _pad_for_signing(hash_asn1_and_hash, common.byte_size(priv_key.n))\n    encrypted_signature = encrypt(padded_hash, priv_key)\n    return encrypted_signature\n\n", "CodeBleu_score": 39.32746492473695}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the signature\n    cleartext = pub_key.blinded_decrypt(signature_int)\n\n    # Get the hash method\n    hash_method = get_hash_method(cleartext)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the padded hash\n    padded_hash = _pad_for_signing(message_hash, common.byte_size(pub_key.n))\n\n    # Compare the padded hash to the clear signature\n    if padded_hash!= cleartext:\n        raise VerificationError('Signature verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 23.075977188964764}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Get the hash method used\n    if signature[0:2]!= b'\\x00\\x01':\n        raise VerificationError('Invalid signature')\n    sep_idx = signature.index(b'\\x00', 2)\n    asn1code = signature[2:sep_idx]\n    hash_method = HASH_ASN1_REVERSE[asn1code]\n\n    # Get the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n\n    # Decrypt the signature and check it against the expected hash\n    keylength = common.byte_size(pub_key.n)\n    padded = _pad_for_signing(msg_hash, keylength)\n    payload = transform.bytes2int(padded)\n    encrypted = transform.bytes2int(signature[sep_idx + 1:])\n    decrypted = pub_key.blinded_decrypt(encrypted)\n    cleartext = transform.int2bytes(decrypted, keylength)\n    if cleartext!= padded:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 53.77751283684654}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt the signature\n    decrypted = pub_key.blinded_decrypt(signature_int)\n\n    # Determine the hash method used\n    hash_method = _get_hash_method(decrypted)\n\n    # Compute the hash of the message\n    msg_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the padded hash\n    padded_hash = _pad_for_signing(msg_hash, common.byte_size(pub_key.n))\n\n    # If the padded hash does not match the clear signature, raise a verification error\n    if padded_hash!= decrypted:\n        raise VerificationError('Signature verification failed')\n\n    return hash_method\n", "CodeBleu_score": 23.67066688039846}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch = getEpoch();\n\tif (epoch!= 0) {\n\t\tupdateJWT(epoch);\n\t}\n\tif (connectMQTTSocket() == SOCK_ERR_NO_ERROR) {\n\t\tsendSubscribe = true;\n\t\tdebug_printInfo(\\\"CLOUD: MQTT connection established\\\");\n\t} else {\n\t\tdebug_printError(\\\"CLOUD: MQTT connection failed\\\");\n\t}\n}", "CodeBleu_score": 43.752004336508364}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentTime = 0;\n\tuint32_t epoch = 0;\n\tuint8_t status;\n\n\tcurrentTime = clock_getUnixTime();\n\tif (currentTime!= 0) {\n\t\tepoch = currentTime + UNIX_OFFSET;\n\t\tupdateJWT(epoch);\n\t}\n\n\tstatus = connectMQTTSocket();\n\tif (status == MQTT_CONNECT_SUCCESS) {\n\t\tsendSubscribe = true;\n\t\tdebug_printInfo(\\\"CLOUD: MQTT Connection Established\\\");\n\t} else {\n\t\tdebug_printError(\\\"CLOUD: MQTT Connection Failed\\\");\n\t}\n}", "CodeBleu_score": 48.013430589815286}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch!= (uint32_t)-1) {\n\t\tupdateJWT(epoch);\n\t}\n\tif (connectMQTTSocket() == 0) {\n\t\twaitingForMQTT = false;\n\t\tdebug_printInfo(\\\"CLOUD: MQTT Connection Established\\\");\n\t} else {\n\t\tdebug_printError(\\\"CLOUD: MQTT Connection Failed\\\");\n\t}\n}", "CodeBleu_score": 44.39036025807586}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t", "CodeBleu_score": 6.372040539859879}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t", "CodeBleu_score": 6.372040539859879}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t", "CodeBleu_score": 6.372040539859879}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret;\n\tuint8_t digest[32];\n\tuint8_t signature[64];\n\tuint8_t* tbs_digest = NULL;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tif (cert_size < cert_def->cert_size) {\n\t\treturn ATCACERT_E_BAD_CERT;\n\t}\n\n\tif (cert_def->cert_size == 0) {\n\t\treturn ATCACERT_E_BAD_CERT;\n\t}\n\n\t// Get the TBS digest and signature\n\ttbs_digest = (uint8_t*)cert + cert_def->tbs_offset;\n\tret = atcacert_get_signature(cert, cert_size, signature);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the signature\n\tret = atcacert_verify_signature_hw(cert_def, tbs_digest, signature, ca_public_key);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 61.87700072489777}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tlist == NULL)\n\t\treturn false;\n\tif (timer == NULL)\n\t\treturn false;\n\tif (*list == NULL)\n\t\treturn false;\n\tif (*list == timer)\n\t{\n\t\t*list = timer->next;\n\t\treturn true;\n\t}\n\ttimerStruct_t *prev = *list;\n\ttimerStruct_t *next = prev->next;\n\twhile (next!= NULL)\n\t{\n\t\tif (next == timer)\n\t\t{\n\t\t\tprev->next = next->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = next;\n\t\tnext = next->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 38.946838849006106}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tStruct_t * volatile *prev = list;\ntimerStruct_t * volatile *curr = *prev;\nwhile (curr!= NULL) {\nif (curr == timer) {\n*prev = curr->next;\nreturn true;\n}\nprev = &curr->next;\ncurr = curr->next;\n}\nreturn false;\n}", "CodeBleu_score": 23.82085781691769}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tStruct_t *basePoint = *list;\ntimerStruct_t *prevPoint = NULL;\nwhile(basePoint!= NULL)\n{\nif(basePoint == timer)\n{\nif (prevPoint == NULL)\n{\n*list = basePoint->next;\n}\nelse\n{\nprevPoint->next = basePoint->next;\n}\nreturn true;\n}\nprevPoint = basePoint;\nbasePoint = basePoint->next;\n}\nreturn false;\n}", "CodeBleu_score": 29.784861175809073}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\twincSocketResponses_t wincCloseReturn = WINC_SOCK_ERR_INVALID;\n\n\tif (bsdSocket) {\n\t\tdebug_printGOOD(\"BSD: socket (%d) closing\", *bsdSocket->socket);\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t\twincCloseReturn = close((SOCKET)socket);\n\t\tif (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\t\tswitch (wincCloseReturn) {\n\t\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\t\tdebug_printError(\"BSD: close error %d\", wincCloseReturn);\n\t\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\t\tdebug_printError(\"BSD: close error %d\", wincCloseReturn);\n\t\t\t\t\tbsd_setErrNo(EBADF);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\treturn BSD_SUCCESS;\n\t} else {\n\t\tdebug_printError(\"BSD: close error unknown socket number\");\n\t\tbsd_setErrNo(EBADF);\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 64.47601609399545}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif(!bsdSocket) {\n\t\tdebug_printError(\"BSD: close error unknown socket number\");\n\t}\n\telse {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t\tint returnValue = close(socket);\n\t\tif(returnValue!= 0) {\n\t\t\tswitch(returnValue) {\n\t\t\t\tcase EBADF:\n\t\t\t\t\tbsd_setErrNo(EBADF);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EINVAL:\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EIO:\n\t\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 53.09662475905523}, {"code": "int BSD_close(int socket){\n\t\tpacketReceptionHandler_t *bsdSocket = getSocketInfo(socket);\n\tif(!bsdSocket) {\n\t\tdebug_printError(\"BSD: close error unknown socket number\");\n\t}\n\telse {\n\t\tbsdSocket->socketState = NOT_A_SOCKET;\n\t\tif(close((SOCKET)socket) < 0) {\n\t\t\tdebug_printError(\"BSD: close error %d\",close((SOCKET)socket));\n\t\t\tbsd_setErrNo(EIO);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 36.47693180464028}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d, %d)\", socket, backlog);\n\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\tbreak;\n\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(EIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 66.48125443888785}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d, %d)\", socket, backlog);\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tbsd_setErrNo(EBADF);\n\t\t\t\t} else if (backlog < 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t} else {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 73.65945685315303}, {"code": "int BSD_listen(int socket, int backlog){\n\t\twincSocketResponses_t wincListenReturn;\n\n\tdebug_printGOOD(\"BSD: BSD_listen (%d, %d)\", socket, backlog);\n\twincListenReturn = listen((SOCKET)socket, (uint8_t)backlog);\n\tif (wincListenReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch (wincListenReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif (socket < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: ENOTSOCK\");\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t} else if (backlog < 0) {\n\t\t\t\t\tdebug_printError(\"BSD: EINVAL\");\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tdebug_printError(\"BSD: EIO\");\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 69.16900212268018}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptResponse;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptResponse = accept((int8_t)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptResponse!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincAcceptResponse) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr!= NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 75.0643176147912}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptReturn;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t *)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif(wincAcceptReturn!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincAcceptReturn) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr!= NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 82.17899099298793}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\twincSocketResponses_t wincAcceptResponse;\n\twincSupported_sockaddr winc_sockaddr;\n\n\twinc_sockaddr.sa_family = addr->sa_family;\n\tmemcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n\n\tswitch(winc_sockaddr.sa_family) {\n\t\tcase PF_INET:\n\t\t\twinc_sockaddr.sa_family = AF_INET;\n\t\t\twincAcceptResponse = accept((int8_t)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t*)addrlen);\n\t\tbreak;\n\t\tdefault:\t\t//Address family not supported by WINC\n\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\treturn BSD_ERROR;\n\t}\n\n\tif (wincAcceptResponse!= WINC_SOCK_ERR_NO_ERROR) {\n\t\tswitch(wincAcceptResponse) {\n\t\t\tcase WINC_SOCK_ERR_INVALID_ARG:\n\t\t\t\tif(socket < 0) {\n\t\t\t\t\tbsd_setErrNo(ENOTSOCK);\n\t\t\t\t}\n\t\t\t\telse if(addr == NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(addrlen == NULL) {\n\t\t\t\t\tbsd_setErrNo(EFAULT);\n\t\t\t\t}\n\t\t\t\telse if(*addrlen == 0) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WINC_SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t} else {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 74.16936172175794}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t current_time = time(NULL);\n\tif (current_time!= (uint32_t)-1) {\n\t\tupdateJWT(current_time);\n\t\tif (connectMQTTSocket() == SOCKET_ERROR) {\n\t\t\tdebug_printError(\"CLOUD: MQTT Connection failed\");\n\t\t} else {\n\t\t\tdebug_printInfo(\"CLOUD: MQTT Connection established\");\n\t\t\twaitingForMQTT = false;\n\t\t\tsendSubscribe = true;\n\t\t}\n\t} else {\n\t\tdebug_printError(\"CLOUD: Time not valid\");\n\t}\n}", "CodeBleu_score": 52.912010474667085}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tepoch = time(NULL);\n\tif (epoch!= -1) {\n\t\tupdateJWT(epoch);\n\t\tdebug_printInfo(\\\"CLOUD: Connecting to MQTT\\\");\n\t\tif (connectMQTTSocket() == 0) {\n\t\t\tdebug_printInfo(\\\"CLOUD: Connected to MQTT\\\");\n\t\t\twaitingForMQTT = true;\n\t\t\tsendSubscribe = true;\n\t\t} else {\n\t\t\tdebug_printError(\\\"CLOUD: Failed to connect to MQTT\\\");\n\t\t}\n\t} else {\n\t\tdebug_printError(\\\"CLOUD: Failed to get time\\\");\n\t}\n}", "CodeBleu_score": 47.67809377838396}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = clock_getCurrentTime();\n\tif (epoch!= 0) {\n\t\tupdateJWT(epoch);\n\t\twaitingForMQTT = true;\n\t\tdebug_printInfo(\\\"CLOUD: MQTT Connection Attempt\\\");\n\t\tmqtt_connect();\n\t\tsendSubscribe = true;\n\t} else {\n\t\tdebug_printError(\\\"CLOUD: MQTT Connection failed. Time is invalid\\\");\n\t}\n}", "CodeBleu_score": 47.05973622257058}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tdebug_printError(\"CLOUD: Disconnect\");\n\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTT_CLIENT_disconnect();\n\t}\n}", "CodeBleu_score": 68.87833757416291}, {"code": "void CLOUD_disconnect(void){\n\tdebug_printError(\"CLOUD: Disconnect\");\n\tMQTT_CLIENT_disconnect();\n}", "CodeBleu_score": 20.602810158164868}, {"code": "void CLOUD_disconnect(void){\n\tdebug_printInfo(\"CLOUD: Disconnect\");\n\tMQTT_CLIENT_disconnect();\n}", "CodeBleu_score": 18.39800000116729}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrM2mWifiConnectParam connect_param;\n\tuint8_t wifi_creds = passed_wifi_creds;\n\tif (wifi_creds == WIFI_CREDS_DEFAULT) {\n\t\tconnect_param.pszSsid = WIFI_SSID;\n\t\tconnect_param.pszPass = WIFI_PASSWORD;\n\t\tconnect_param.u8SecType = M2M_WIFI_SEC_WPA_PSK;\n\t} else if (wifi_creds == WIFI_CREDS_NEW) {\n\t\tconnect_param.pszSsid = new_wifi_creds.ssid;\n\t\tconnect_param.pszPass = ;\n\t\tconnect_param.u8SecType = new_wifi_creds.sec_type;\n\t} else {\n\t\treturn false;\n\t}\n\tif (m2m_wifi_connect((char *)connect_param.pszSsid, connect_param.u8SecType,\n\t\t\tconnect_param.u8KeyInd, (char *)connect_param.pszPass,\n\t\t\tconnect_param.u8KeySz)!= M2M_SUCCESS) {\n\t\tdebug_printError(\"Failed to connect to AP\");\n\t\tnetworking_error_status = 1;\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.07659189078196}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif(passed_wifi_creds) {\n\t\tdebug_printInfo(\"Connecting to AP with new credentials\");\n\t\tif (m2m_wifi_connect((char *)wifi_ssid, sizeof(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, (char *)wifi_password, sizeof(wifi_password))!= M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Failed to connect to AP with new credentials\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tdebug_printInfo(\"Connecting to AP with default credentials\");\n\t\tif (m2m_wifi_connect((char *)wifi_ssid, sizeof(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, (char *)wifi_password, sizeof(wifi_password))!= M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Failed to connect to AP with default credentials\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.9811573736242}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tnst client = await generateClient({\nregion: 'us-east-1',\n});\n\nconst response = await client.query({\nquery: listSensors,\n});\n\nconsole.log('DisplaySensors response: ', response);\n\nif (response.data.listSensors.items.length > 0) {\n\nconsole.log('DisplaySensors: Retrieved'+ response.data.listSensors.items.length +'sensors');\n\nresponse.data.listSensors.items.forEach(function (sensor) {\n\nvar marker = new Marker(CreateSensorMarker(sensor));\n\nmarker.setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n});\n}\n}", "CodeBleu_score": 44.76813526728298}, {"code": "async function DisplaySensors(map){\n\t create a client to send GraphQL queries\nconst api = generateClient();\n\n// send a GraphQL query to fetch sensor data\nconst response = await api.graphql({\n\n// GraphQL query to fetch sensor data\nquery: listSensors,\n\n// GraphQL query variables\nvariables: {\n\n// fetch all sensors\nlimit: 100,\n\n// sort sensors by sensorId\nsortField:'sensorId',\n\n// sort sensors in ascending order\nsortDirection: 'ASC'\n\n}\n\n});\n\n// log the API response\nconsole.log(response);\n\n// check if the response contains data\nif (response.data.listSensors.items.length > 0) {\n\n// log the retrieval of sensors\nconsole.log('Retrieved sensors:');\n\n// iterate through each sensor\nresponse.data.listSensors.items.forEach(sensor => {\n\n// create a marker for the sensor\nvar marker = CreateSensorMarker(sensor);\n\n// create a new marker on the map at the sensor's geographical coordinates\nvar sensorMarker = new Marker(marker).setLngLat([sensor.longitude, sensor.latitude]);\n\n// add the marker to the map\nsensorMarker.addTo(map);\n\n// log the sensor\nconsole.log(sensor);\n\n});\n\n}\n\n}", "CodeBleu_score": 49.97978534189586}, {"code": "async function DisplaySensors(map){\n\tnst client = await generateClient({ region: 'us-west-2' });\n\nconst { data } = await client.query({\n\nquery: listSensors,\n\nfetchPolicy: 'no-cache',\n\n});\n\nif (data && data.listSensors && data.listSensors.items) {\n\nconsole.log('Retrieved sensors:'+ data.listSensors.items.length);\n\ndata.listSensors.items.forEach(sensor => {\n\nvar marker = new Marker(CreateSensorMarker(sensor))\n\nmarker.setLngLat([sensor.longitude, sensor.latitude]).addTo(map);\n\n});\n\n} else {\n\nconsole.log('No sensors retrieved');\n\n}\n\n}", "CodeBleu_score": 42.39462925061475}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tonst marker = document.createElement('div');\nmarker.id = sensor.id;\nmarker.className ='sensor-marker';\nmarker.style.backgroundColor = '#008000';\nmarker.style.border = '2px solid #000000';\nmarker.style.width = '10px';\nmarker.style.height = '10px';\nmarker.style.borderRadius = '50%';\nmarker.style.marginLeft = '-5px';\nmarker.style.marginTop = '-5px';\n\nreturn marker;\n}", "CodeBleu_score": 45.62040827681455}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t", "CodeBleu_score": 0.7059713833405259}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t", "CodeBleu_score": 0.7059713833405259}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"homeassistant.components.{module_name}.mfa_module\\\"\n\n    try:\n        module = async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\\\"Failed to import module %s: %s\\\", module_path, err)\n        raise HomeAssistantError(f\\\"Failed to import module {module_path}\\\") from err\n\n    if not requirements.async_check_requirements(hass, module.REQUIREMENTS):\n        raise HomeAssistantError(f\\\"Failed to import module {module_path}\\\")\n\n    if not DATA_REQS.get(module_name, False):\n        requirements.async_process_requirements(hass, module.REQUIREMENTS)\n        DATA_REQS[module_name] = True\n\n    return module\n\n", "CodeBleu_score": 38.38243555048735}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"multi_factor_auth.modules.{module_name}\\\"\n    try:\n        module = async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\\\"Failed to import MFA module %s: %s\\\", module_name, err)\n        raise\n\n    if not requirements.async_has_requirements(hass, module_path):\n        _LOGGER.debug(\\\"Skipping pip install of requirements for MFA module %s\\\", module_name)\n        return module\n\n    if DATA_REQS.get(hass) is None:\n        DATA_REQS[hass] = set()\n\n    if module_name in DATA_REQS[hass]:  # type: ignore[no-any-return]\n        return module\n\n    DATA_REQS[hass].add(module_name)\n\n    try:\n        await requirements.async_process_requirements(hass, module_path)\n    except requirements.RequirementsNotFound as err:\n        _LOGGER.error(\\\"Failed to install requirements for MFA module %s: %s\\\", module_name, err)\n        raise\n\n    return module\n\n", "CodeBleu_score": 43.56639762858777}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\\\"homeassistant.components.mfa.{module_name.lower()}\\\"\n\n    try:\n        module = async_import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\\\"Failed to import multi-factor module %s: %s\\\", module_name, err)\n        raise\n\n    if not requirements.async_check_requirements(hass, [\\\"mfa\\\"], module_name):\n        return module\n\n    if DATA_REQS.get(hass, set()) == {module_name}:\n        return module\n\n    try:\n        requirements.async_process_requirements(hass, [\\\"mfa\\\"], module_name)\n    except HomeAssistantError as err:\n        _LOGGER.error(\\\"Failed to install multi-factor module %s: %s\\\", module_name, err)\n        raise\n\n    DATA_REQS.setdefault(hass, set()).add(module_name)\n    return module\n\n", "CodeBleu_score": 41.37713553641237}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    pin = setup_data[\\\"pin\\\"]\n    for data in self._data:\n        if data[\\\"user_id\\\"] == user_id:\n            data[\\\"pin\\\"] = pin\n            return data\n    self._data.append({\n        \\\"user_id\\\": user_id,\n        \\\"pin\\\": pin\n    })\n    return data\n", "CodeBleu_score": 42.70007738196321}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    pin = setup_data[\\\"pin\\\"]\n    if user_id in self._data:\n        self._data[user_id][\\\"pin\\\"] = pin\n    else:\n        self._data.append({\\\"user_id\\\": user_id, \\\"pin\\\": pin})\n    return None\n", "CodeBleu_score": 33.353967784254245}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t    pin = setup_data[\\\"pin\\\"]\n    if user_id in self._data:\n        self._data[user_id][\\\"pin\\\"] = pin\n    else:\n        self._data[user_id] = {\\\"user_id\\\": user_id, \\\"pin\\\": pin}\n\n    return self._data[user_id]\n\n", "CodeBleu_score": 33.533208004339876}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t    async with self._init_lock:\n        # Check if user settings are already loaded\n        if self._user_settings is not None:\n            return\n\n        # Attempt to load user settings from the user store\n        user_settings = await self._user_store.async_load()\n        if user_settings is None:\n            user_settings = {}\n\n        # Initialize an empty dictionary for user settings\n        self._user_settings = {}\n\n        # Populate the user settings by creating \"NotifySetting\" objects for each user\n        for user_id, user_data in user_settings.items():\n            # Check if the user is excluded\n            if user_id in self._exclude:\n                continue\n\n            # Check if the user is included\n            if self._include and user_id not in self._include:\n                continue\n\n            # Create a \"NotifySetting\" object for the user\n            self._user_settings[user_id] = NotifySetting(\n                **user_data,\n            )\n\n    @property\n    def users(self) -> list[str]:\n        \\\"\\\"\\\"Return a list of user IDs.\\\"\\\"\\\"\n        return list(self._user_settings.keys())\n\n    def get_user(self, user_id: str) -> NotifySetting:\n        \\\"\\\"\\\"Get a user setting by user ID.\\\"\\\"\\\"\n        return self._user_settings[user_id]\n\n    async def async_add_user(self, user_id: str) -> None:\n        \\\"\\\"\\\"Add a user to the user settings.\\\"\\\"\\\"\n        # Check if the user is excluded\n        if user_id in self._exclude:\n            return\n\n        # Check if the user is included\n        if self._include and user_id not in self._include:\n            return\n\n        # Create a \"NotifySetting\" object for the user\n        self._user_settings[user_id] = NotifySetting()\n\n        # Save the user settings to the user store\n        await self._user_store.async_save(self._user_settings)\n\n    async def async_remove_user", "CodeBleu_score": 35.31982252677235}, {"code": "async def _async_load(self) -> None\n\t    async with self._init_lock:\n        if self._user_settings is None:\n            user_settings = await self._user_store.async_load()\n            if user_settings is None:\n                user_settings = {}\n            self._user_settings = OrderedDict(user_settings)\n\n", "CodeBleu_score": 31.689656064195802}, {"code": "async def _async_load(self) -> None\n\t    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = {}\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {}\n        for user_id in data:\n            self._user_settings[user_id] = NotifySetting(data[user_id])\n\n", "CodeBleu_score": 41.586166430857496}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n\n    if notify_setting is None:\n        return False\n\n    if not notify_setting.notify_service or not notify_setting.target:\n        return False\n\n    if not _verify_otp(notify_setting.secret, user_input[INPUT_FIELD_CODE], notify_setting.counter):\n        return False\n\n    self._user_settings[user_id].counter += 1\n    await self._async_save()\n\n    return True\n\n", "CodeBleu_score": 62.46736774362331}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    executor = self.hass.executor\n    otp = user_input[INPUT_FIELD_CODE]\n    result = await executor.async_run_in_executor(\n        None, _verify_otp, notify_setting.secret, otp, notify_setting.counter\n    )\n    if result:\n        notify_setting.counter += 1\n        await self._async_save()\n    return result\n\n    return False\n", "CodeBleu_score": 62.86088862565863}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n\n    notify_setting = self._user_settings.get(user_id)\n    if notify_setting is None:\n        return False\n\n    secret = notify_setting.secret\n    otp = user_input[INPUT_FIELD_CODE]\n    count = notify_setting.counter\n\n    if not _verify_otp(secret, otp, count):\n        return False\n\n    self._user_settings[user_id].counter += 1\n    await self._async_save()\n\n    return True\n\n    async def async_get_setup_data(self, user_id: str) -> dict[str, Any]:\n    \"\"\"The function \"async_get_setup_data\" asynchronously retrieves the setup data for a given user ID.", "CodeBleu_score": 63.80096686788923}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity = perm_lookup.get_entity(entity_id)\n    if entity is None or entity.device_id is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None or device.area_id is None:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 58.10713896176232}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry or not entity_entry.device_id:\n        return None\n\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry or not device_entry.area_id:\n        return None\n\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 52.41104644031975}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t entity = perm_lookup.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get(entity.device_id)\n    if device is None or device.area_id is None:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 53.84725390597994}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = cast(PolicyType, {})\n    seen_categories: set[CategoryType] = set()\n\n    for policy in policies:\n        for category in policy.categories:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = merge_categories(merged_policy.get(category, {}), policy.get(category, {}))\n\n    return cast(PolicyType, merged_policy)\n\n\n", "CodeBleu_score": 46.147288205911416}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category in policy.get(\"categories\", []):\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[\"categories\"].append(category)\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 48.84284674360463}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t    merged_policy: PolicyType = {}\n    seen_categories: set[CategoryType] = set()\n    for policy in policies:\n        for category, category_value in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                if category in merged_policy:\n                    merged_policy[category] = cast(\n                        CategoryType,\n                        merge_categories(merged_policy[category], category_value),\n                    )\n                else:\n                    merged_policy[category] = category_value\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 48.756026038734035}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  if provider in AUTH_PROVIDERS:\n        return AUTH_PROVIDERS[provider]\n\n    module = async_import_module(hass, f\\\"auth_provider_{provider}\\\")\n    if module is None:\n        raise HomeAssistantError(f\\\"Auth provider {provider} not found\\\")\n\n    reqs = requirements.async_get_requirements(hass, module)\n    if reqs:\n        if DATA_REQS.get(hass) is None:\n            DATA_REQS.set(hass, set())\n\n        reqs_processed = DATA_REQS.get(hass)\n        for req in reqs:\n            if req in reqs_processed:\n                continue\n\n            if not await requirements.async_process_requirements(hass, req):\n                raise HomeAssistantError(f\\\"Auth provider {provider} requires {req}\\\")\n\n            reqs_processed.add(req)\n\n    return module\n\n", "CodeBleu_score": 37.57673656962704}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  if provider in AUTH_PROVIDERS:\n        return AUTH_PROVIDERS[provider]  # type: ignore[no-any-return]\n\n    module = async_import_module(hass, f\\\"auth_provider_{provider}\\\")\n    if not module:\n        raise HomeAssistantError(\n            f\\\"Could not load auth provider {provider}\\\"\n        )\n\n    if provider in DATA_REQS:\n        return module\n\n    requirements = module.AUTH_PROVIDER_REQUIREMENTS\n    if not requirements:\n        return module\n\n    hass.async_create_task(\n        requirements.async_process_requirements(hass, DATA_REQS, provider)\n    )\n    return module\n\n", "CodeBleu_score": 34.746574746506056}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t  if provider in AUTH_PROVIDERS:\n        return AUTH_PROVIDERS[provider]\n\n    if provider in DATA_REQS(hass):\n        return AUTH_PROVIDERS[provider]\n\n    try:\n        module = async_import_module(hass, f\\\"auth_provider_{provider}\\\")\n    except ImportError as err:\n        _LOGGER.error(\n            \\\"Failed to import auth provider module %s: %s\\\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError(f\\\"Failed to import auth provider module {provider}\\\") from err\n\n    reqs = module.AUTH_PROVIDER_REQUIREMENTS\n    if reqs is None:\n        reqs = []\n    if not requirements.async_check_requirements(hass, reqs):\n        _LOGGER.warning(\n            \\\"Auth provider %s is missing requirements: %s\\\",\n            provider,\n            reqs,\n        )\n        raise HomeAssistantError(f\\\"Auth provider {provider} is missing requirements\\\")\n\n    DATA_REQS(hass).add(provider)\n    return module\n\n", "CodeBleu_score": 40.29454008652302}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t   self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n\n    # Legacy mode will allow usernames to start/end with whitespace\n    # and will compare usernames case-insensitive.\n    # Deprecated in June 2019 and will be removed in 2026.7\n    self.is_legacy = False\n\n    # Check for non-normalized usernames and normalize them\n    for username in self._data:\n        if username!= self.normalize_username(username):\n            self.is_legacy = True\n            self._data[self.normalize_username(username)] = self._data.pop(username)\n\n", "CodeBleu_score": 25.10711493039398}, {"code": "async def async_load(self) -> None\n\t   self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n\n    for user in self._data:\n        if self.is_legacy:\n            continue\n\n        self._data[user] = [entry for entry in self._data[user] if entry[\\\"username\\\"] == user]\n\n", "CodeBleu_score": 24.555266210765776}, {"code": "async def async_load(self) -> None\n\t   self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n\n    # Check for non-normalized usernames and normalize them.\n    for username, users in self._data.items():\n        for user in users:\n            if username!= self.normalize_username(user[CONF_ID]):\n                # Normalize the username and update the user data.\n                user[CONF_ID] = self.normalize_username(user[CONF_ID])\n                self._data[username] = users\n\n    # Update the internal data variable.\n    self._data = self._data\n\n", "CodeBleu_score": 24.215257071887017}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t  username = self.normalize_username(username)\n\n    dummy_hash = bcrypt.gensalt(rounds=10, prefix=b\\\"homeassistant\\\")\n\n    for user in self.users:\n        if user[\\\"username\\\"] == username:\n            if bcrypt.checkpw(password.encode(\\\"utf-8\\\"), base64.b64decode(user[\\\"hash\\\"])):  # nosec\n                return\n\n            raise InvalidAuth(\\\"Invalid password\\\")\n\n    raise InvalidAuth(\\\"Invalid username\\\")\n\n", "CodeBleu_score": 33.10430150816136}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t  normalized_username = self.normalize_username(username)\n\n    dummy_hash = b\\\"\\\\x00\\\" * 60\n\n    for user in self.users:\n        if user[\\\"username\\\"] == normalized_username:\n            stored_hash = user[\\\"hash\\\"]\n\n            if bcrypt.checkpw(password, stored_hash):\n                return\n\n            raise InvalidAuth(\n                \\\"Invalid password for user '%s'.\\\" % username\n            )\n\n    raise InvalidAuth(\n        \\\"Invalid username or password for user '%s'.\\\" % username\n    )\n\n", "CodeBleu_score": 33.59343024791593}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t  # Normalize the username\n    normalized_username = self.normalize_username(username)\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\\\"\\\", bcrypt.gensalt())\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        # Decode the stored password hash\n        stored_password_hash = base64.b64decode(user[\\\"password_hash\\\"])\n        # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n        if bcrypt.checkpw(password.encode(), stored_password_hash):\n            # If the passwords match, return the user data\n            return user\n        # If the passwords do not match, perform a dummy hash check to prevent timing attacks\n        bcrypt.checkpw(dummy_hash, stored_password_hash)\n    # If no matching user is found, raise an \"InvalidAuth\" exception\n    raise InvalidAuth(\\\"Invalid authentication\\\")\n\n", "CodeBleu_score": 35.66674967388255}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t  self._validate_username(username)\n\n    username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\\\"username\\\"]) == username:\n            self.users.remove(user)\n            return\n\n    raise InvalidUser(f\\\"User '{username}' not found\\\")\n\n", "CodeBleu_score": 36.4044854129496}, {"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n    for user in self.users:\n        if self.normalize_username(user[\\\"username\\\"]) == username:\n            self.users.remove(user)\n            return\n\n    raise InvalidUser(f\\\"User '{username}' not found\\\")\n\n", "CodeBleu_score": 33.153200646946736}, {"code": "def async_remove_auth(self, username: str) -> None\n\t  username = self.normalize_username(username)\n    try:\n        self.users.remove(user)\n    except ValueError:\n        raise InvalidUser(\\\"user_not_found\\\")\n\n", "CodeBleu_score": 20.57350203164445}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\\\"username\\\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 87.4268327971704}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\\\"username\\\"])\n        await self.data.async_save()\n    except InvalidUser:\n        pass\n\n\n    async def async_get_or_create_credentials(self, flow_result: Mapping[str, str]) -> Credentials:\n        \\\"\\\"\\\"Get credentials based on the flow result.\\\"\\\"\\\"\n        if self.data is None:\n            await self.async_initialize()\n            assert self.data is not None\n\n        norm_username = self.data.normalize_username\n        username = norm_username(flow_result[\\\"username\\\"])\n\n        for credential in await self.async_credentials():\n            if norm_username(credential.data[\\\"username\\\"]) == username:\n                return credential\n\n        # Create new credentials.\n        return self.async_create_credentials({\\\"username\\\": username})\n\n    async def async_user_meta_for_credentials(self, credentials: Credentials) -> UserMeta:\n        \\\"\\\"\\\"Get extra info for this credential.\\\"\\\"\\\"\n        return UserMeta(name=credentials.data[\\\"username\\\"], is_active=True)\n\n\n\n", "CodeBleu_score": 67.52851190014368}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n\n    try:\n        self.data.async_remove_auth(credentials.data[\\\"username\\\"])\n    except InvalidUser:\n        pass\n    await self.data.async_save()\n\n", "CodeBleu_score": 84.88640280257991}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    start = time.time()\n    joined = set()\n    remaining_threads = set(threads)\n    while remaining_threads:\n        remaining_timeout = timeout - (time.time() - start)\n        if remaining_timeout <= 0:\n            break\n        for thread in remaining_threads:\n            if not thread.is_alive():\n                remaining_threads.remove(thread)\n                joined.add(thread)\n            elif thread.ident is not None:\n                try:\n                    thread.join(remaining_timeout)\n                except RuntimeError:\n                    remaining_threads.remove(thread)\n                    joined.add(thread)\n    if log:\n        for thread in remaining_threads:\n            if thread.ident is not None:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in remaining_threads:\n        if thread.ident is not None:\n            async_raise(SystemExit)\n    return joined\n\n", "CodeBleu_score": 48.33855209256805}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread.join(timeout=timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        async_raise(SystemExit, \\\"Thread is still running at shutdown\\\")\n    return joined\n\n", "CodeBleu_score": 54.510603009562374}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread_ident = thread.ident\n        thread_name = thread.name\n        thread_timeout = timeout - time.time() + thread.start_time\n        if thread_timeout <= 0:\n            thread.join()\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout=thread_timeout)\n        except RuntimeError:\n            thread.join()\n            joined.add(thread)\n            continue\n        except Exception:\n            if log:\n                _log_thread_running_at_shutdown(thread_name, thread_ident)\n            thread.join()\n            joined.add(thread)\n            continue\n        else:\n            joined.add(thread)\n    for thread in threads:\n        if thread not in joined:\n            try:\n                async_raise(thread, SystemExit)\n            except RuntimeError:\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n                thread.join()\n                joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 48.706359508364706}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    _LOGGER.info(\\\"Attempting to shutdown\\\")\n    threads = [thread for thread in threading.enumerate() if not thread.daemon and thread is not threading.current_thread()]\n    total_timeout = THREADING_SHUTDOWN_TIMEOUT\n    for thread in threads:\n        if thread.is_alive():\n            timeout = total_timeout / len(threads)\n            _LOGGER.warning(\\\"Attempting to join thread %s with timeout %s\\\", thread, timeout)\n            thread.join(timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\\\"Thread %s did not shutdown within timeout %s\\\", thread, timeout)\n    _LOGGER.info(\\\"Shutdown complete\\\")\n\n", "CodeBleu_score": 35.52714847169436}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    _LOGGER.info(\\\"Starting deadlock safe shutdown\\\")\n\n    threads = [t for t in threading.enumerate() if t.is_alive() and not t.daemon and t.name!= \\\"MainThread\\\"]\n    timeout = THREADING_SHUTDOWN_TIMEOUT / len(threads)\n    for thread in threads:\n        _LOGGER.info(\\\"Joining thread %s\\\", thread.name)\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(\\\"Failed to join thread %s: %s\\\", thread.name, e)\n\n    _LOGGER.info(\\\"Deadlock safe shutdown complete\\\")\n\n", "CodeBleu_score": 34.24974560389446}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the current thread\n    current_thread = threading.current_thread()\n    # Get all alive threads\n    alive_threads = threading.enumerate()\n    # Filter out the current thread and main thread\n    alive_threads = [thread for thread in alive_threads if thread is not current_thread and thread is not threading.main_thread()]\n    # Calculate the timeout for each thread\n    total_timeout = THREADING_SHUTDOWN_TIMEOUT\n    timeout_per_thread = total_timeout / len(alive_threads)\n    # Attempt to join each thread\n    for thread in alive_threads:\n        try:\n            thread.join(timeout=timeout_per_thread)\n        except Exception as e:\n            _LOGGER.warning(f\\\"Failed to join thread {thread.name} with exception {e}.\\\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 34.77974874973107}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._previous_was_empty = bool(remaining_with_setup_started)\n        self._hass.bus.async_fire(EVENT_SLOW_SETUP, remaining_with_setup_started)\n\n    self._handle = self._loop.call_later(\n        SLOW_STARTUP_CHECK_INTERVAL, self._async_watch\n    )\n\n", "CodeBleu_score": 59.11889520150386}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._previous_was_empty = False\n        self._hass.async_dispatch_internal(SIGNAL_SLOW_STARTUP, remaining_with_setup_started)\n    else:\n        self._previous_was_empty = True\n", "CodeBleu_score": 55.28342984688883}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or not self._previous_was_empty:\n        self._previous_was_empty = False\n        self._loop.create_task(self._hass.async_dispatch(SIGNAL_SLOW_STARTUP, remaining_with_setup_started))\n    else:\n        self._previous_was_empty = True\n\n\n    def _async_watch_start(self) -> None:\n        \\\"\\\"\\\"Start the watch.\n\n        This will be called by the setup function.\n        \\\"\\\"\\\"\n        self._handle = self._loop.call_later(SLOW_STARTUP_CHECK_INTERVAL, self._async_watch)\n\n", "CodeBleu_score": 48.25398396631599}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t   from.model import Config, Integration\n\n    from.serializer import format_python_namespace\n\n    match_list = []\n\n    for domain in sorted(integrations):\n        match_types = integrations[domain].manifest.get(\"bluetooth\", [])\n\n        if not match_types:\n            continue\n\n        match_list.extend({\"domain\": domain, **entry} for entry in match_types)\n\n    if not config.bluetooth:\n        config.bluetooth = match_list\n        return\n\n    if config.bluetooth!= match_list:\n        config.add_error(\n            \"bluetooth\",\n            \"bluetooth.py is not up to date. Please run `ha generate bluetooth` to update it.\",\n            fixable=True,\n            fix_suggested=\"ha generate bluetooth\",\n        )\n\n", "CodeBleu_score": 40.13257579570525}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t   if config.bluetooth_file_path is None:\n        return\n\n    match_list = generate_and_validate(integrations)\n\n    with open(config.bluetooth_file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as file:\n        current_content = file.read()\n\n    if current_content!= match_list:\n        config.add_error(\n            \\\"bluetooth.py\\\", \\\"bluetooth.py is not up to date. Please run \\\"\n            f\\\"ha generate bluetooth {config.config_path}\\\"\\\"\n        )\n\n\n\n\n", "CodeBleu_score": 41.19088597321829}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t   match_list = []\n\n    for domain in sorted(integrations):\n        match_types = integrations[domain].manifest.get(\"bluetooth\", [])\n\n        if not match_types:\n            continue\n\n        match_list.extend({\"domain\": domain, **entry} for entry in match_types)\n\n    if config.bluetooth is None:\n        config.bluetooth = match_list\n        return\n\n    if config.bluetooth!= match_list:\n        config.add_error(\n            \"bluetooth.py\",\n            \"bluetooth.py is not up to date\",\n            \"Please run `ha generate bluetooth` to generate the Bluetooth content.\",\n        )\n\n\n", "CodeBleu_score": 39.062205952205225}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"code\":         d.Code,\n\t\t\t\"grant_type\":   \"authorization_code\",\n\t\t\t\"redirect_uri\": \"https://cloudoauth.files.casaos.app\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.RefreshToken = resp.RefreshToken\n\treturn nil\n\n}", "CodeBleu_score": 79.20947730868737}, {"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"code\":         d.Code,\n\t\t\t\"grant_type\":   \"authorization_code\",\n\t\t\t\"redirect_uri\": \"https://cloudoauth.files.casaos.app\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n\n}", "CodeBleu_score": 81.72283340754613}, {"code": "func (d *Dropbox) refreshToken() error{\n\trl := \"https://api.dropbox.com/oauth2/token\"\n\tvar resp base.TokenResp\n\tvar e TokenError\n\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"code\":         d.Code,\n\t\t\t\"grant_type\":   \"authorization_code\",\n\t\t\t\"redirect_uri\": \"https://cloudoauth.files.casaos.app\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n\tif e.Error!= \"\" {\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.RefreshToken = resp.RefreshToken\n\treturn nil\n\n}", "CodeBleu_score": 79.20947730868737}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tset the authorization header with the access token\n\treq := base.RestyClient.R().SetHeader(\\\"Authorization\\\", \\\"Bearer \\\"+d.AccessToken)\n\t// include parameters for supporting all drives\n\treq.SetQueryParams(map[string]string{\n\t\t\\\"supportsAllDrives\\\": \\\"true\\\",\n\t})\n\t// customize the request\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\t// set the request result\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\t// handle errors\n\tvar e TokenError\n\treq.SetError(&e)\n\t// send the request\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// handle 401 errors\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\t// refresh the token\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// retry the request\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\t// return the response body or an error if the request failed\n\tif res.IsError() {\n\t\treturn nil, res.Error()\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 63.18480123463361}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tnkSize  = 10 * 1024 * 1024 // 10 MB\n\t\tfileSize   = stream.Size()\n\t\tnumChunks  = int(math.Ceil(float64(fileSize) / float64(chunkSize)))\n\t\tchunkCount = 0\n\t)\n\tfor {\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tchunkData, err := stream.Read(chunkSize)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(chunkData) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tchunkCount++\n\t\t// Prepare the request body for the chunk upload\n\t\tbody := bytes.NewReader(chunkData)\n\t\treq, err := http.NewRequest(http.MethodPut, url, body)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set the Content-Range header for the chunk upload\n\t\treq.Header.Set(\\\"Content-Range\\\", fmt.Sprintf(\\\"bytes %d-%d/%d\\\", chunkCount*chunkSize, (chunkCount+1)*chunkSize-1, fileSize))\n\t\t// Set the Content-Length header to the length of the chunk data\n\t\treq.Header.Set(\\\"Content-Length\\\", strconv.Itoa(len(chunkData)))\n\t\t// Send the request\n\t\tresp, err := http.DefaultClient.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check the response status code\n\t\tif resp.StatusCode!= http.StatusCreated {\n\t\t\treturn fmt.Errorf(\\\"unexpected status code: %d\\\", resp.StatusCode)\n\t\t}\n\t\t// Close the response body\n\t\tdefer resp.Body.Close()\n\t}\n\treturn nil\n}", "CodeBleu_score": 37.34985604799195}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\\\"UmountStorage\\\", zap.Any(\\\"req\\\", req))\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 63.98787436796979}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\treq.Validate()\n\n\tlogger.Info(\\\"UmountStorage\\\", zap.Any(\\\"req\\\", req))\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\tif err := service.MyService.Storage().DeleteConfig(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}", "CodeBleu_score": 63.02705986269432}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t req model.UmountStorageReq\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: err.Error()})\n\t}\n\treq.Validate()\n\n\tlogger.Info(\"UmountStorage\", zap.Any(\"req\", req))\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point can not be empty\"})\n\t}\n\n\tif err := service.MyService.Storage().UmountStorage(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfig(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t}\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: nil})\n}", "CodeBleu_score": 69.48094557445332}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tilePath := ctx.QueryParam(\"path\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(common_err.CLIENT_ERROR, model.Result{\n\t\t\tSuccess: common_err.INVALID_PARAMS,\n\t\t\tMessage: common_err.GetMsg(common_err.INVALID_PARAMS),\n\t\t})\n\t}\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_DOES_NOT_EXIST,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n\t\t})\n\t}\n\t// \u6587\u4ef6\u8bfb\u53d6\u4efb\u52a1\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u8bfb\u53d6\u5230\u5185\u5b58\u4e2d\u3002\n\tinfo, err := ioutil.ReadFile(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(common_err.SERVICE_ERROR, model.Result{\n\t\t\tSuccess: common_err.FILE_READ_ERROR,\n\t\t\tMessage: common_err.GetMsg(common_err.FILE_READ_ERROR),\n\t\t\tData:    err.Error(),\n\t\t})\n\t}\n\tresult := string(info)\n\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{\n\t\tSuccess: common_err.SUCCESS,\n\t\tMessage: common_err.GetMsg(common_err.SUCCESS),\n\t\tData:    result,\n\t})\n}", "CodeBleu_score": 70.57949407995115}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\tname := ctx.Param(\\\"name\\\")\n\tif err := service.NotifyMessage(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\treturn ctx.NoContent(http.StatusOK)\n}", "CodeBleu_score": 41.877658682446096}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar (\n\t\tname    string\n\t\tmessage map[string]interface{}\n\t)\n\n\tif err := ctx.Bind(&name); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\n\tif err := service.NotifyMessage(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, model.Response{\n\t\tCode:    0,\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 51.142270426850814}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\\\"name\\\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\n\tif err := service.NotifyMessage(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\\\"message\\\": \\\"success\\\",\n\t})\n}", "CodeBleu_score": 49.4585473138057}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\ttoken := ctx.Param(\"token\")\n\tif token == \"\" {\n\t\treturn ctx.JSON(http.StatusNotFound, \"token is empty\")\n\t}\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tdefer conn.Close()\n\t// \u6ce8\u518c\u8fde\u63a5\n\tservice.RegisterWSConn(token, conn)\n\t// \u53d1\u9001\u6d88\u606f\n\tgo service.NotifyWS(token, \"notify\")\n\treturn ctx.String(http.StatusOK, \"ok\")\n}", "CodeBleu_score": 32.73115796255934}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\ttoken := ctx.Param(\"token\")\n\tif token == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, types.ErrTokenRequired)\n\t}\n\n\t// \u9a8c\u8bc1token\n\tif err := service.VerifyToken(token); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, types.ErrTokenInvalid)\n\t}\n\n\t// \u5347\u7ea7http\u8bf7\u6c42\u5230websocket\u8fde\u63a5\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, types.ErrTokenInvalid)\n\t}\n\n\t// \u542f\u52a8\u6d88\u606f\u53d1\u9001\u670d\u52a1\n\tif err := service.NotifyService(); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, types.ErrTokenInvalid)\n\t}\n\n\t// \u4fdd\u5b58\u8fde\u63a5\n\tservice.AddNotifyConn(token, ws)\n\n\t// \u63a5\u6536\u6d88\u606f\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tservice.RemoveNotifyConn(token)\n\t\t\treturn ctx.JSON(http.StatusBadRequest, types.ErrTokenInvalid)\n\t\t}\n\n\t\tfmt.Printf(\"Received message: %s\n\", msg)\n\t}\n}", "CodeBleu_score": 34.10131328695722}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\ttoken := ctx.Param(\"token\")\n\tif token == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, types.NewError(types.BadRequest, \"token is empty\"))\n\t}\n\tconn, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, types.NewError(types.BadRequest, err.Error()))\n\t}\n\tdefer conn.Close()\n\tservice.AddNotifyConn(conn)\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(message))\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.523897994856306}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// TODO: Add your code here\n\treturn nil\n}", "CodeBleu_score": 3.0575629981301633}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tinfo := service.MyService.System().GetHardwareInfo()\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: info})\n}", "CodeBleu_score": 30.517445816877455}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar cpuInfo *model.CPUInfo\n\tif runtime.GOOS == \\\"linux\\\" {\n\t\tcpuInfo = service.MyService.System().GetCPUInfo()\n\t}\n\treturn ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: cpuInfo})\n}", "CodeBleu_score": 39.18738445973062}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 71.65044899780663}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.Status == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.79446879423598}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.57881417774232}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t", "CodeBleu_score": 2.3785515821632637}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\truntimePath := config.GetRuntimePath()\n\tmessageBusAddress := config.GetMessageBusAddress()\n\tif len(messageBusAddress) == 0 {\n\t\tmessageBusAddress = \"ws://127.0.0.1:5000/message-bus\"\n\t}\n\tclient := message_bus.NewClientWithResponses(runtimePath, messageBusAddress)\n\treturn client\n}", "CodeBleu_score": 27.568659784126222}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Attempt to retrieve the message bus address using the specified runtime path.\n\taddress, err := config.GetMessageBusAddress(RuntimePath)\n\tif err!= nil {\n\t\t// If the address is not found, set the server to a default error message.\n\t\taddress = \\\"error: message bus address not found\\\"\n\t}\n\n\t// Set the message bus client's server to the retrieved address.\n\tclient.SetServer(address)\n\n\t// Return the initialized message bus client.\n\treturn client\n}", "CodeBleu_score": 30.713787434967966}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\taddress, err := config.GetMessageBusAddress(c.db)\n\tif err!= nil {\n\t\treturn nil\n\t}\n\tclient := message_bus.NewClientWithResponses(address)\n\treturn client\n}", "CodeBleu_score": 26.08034994637999}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\\\"x-forwarded-for\\\")\n\tif ip == \\\"\\\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \\\", \\\")[0]\n\tif ip == \\\"::1\\\" || ip == \\\"::ffff:127.0.0.1\\\" {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 47.74392135453795}, {"code": "func GetIP(request *http.Request) string{\n\tvar ip string\n\tip = request.Header.Get(\\\"X-Forwarded-For\\\")\n\tif len(ip) > 0 {\n\t\tip = strings.Split(ip, \\\",\\\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t\tif len(ip) > 0 {\n\t\t\tip = strings.Split(ip, \\\":\\\")[0]\n\t\t}\n\t}\n\tif ip == \\\"::1\\\" || ip == \\\"::ffff:127.0.0.1\\\" {\n\t\tip = \\\"127.0.0.1\\\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.51501394784482}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\\\"X-Forwarded-For\\\")\n\tif len(ip) > 0 {\n\t\tips := strings.Split(ip, \\\",\\\")\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n\tip = request.RemoteAddr\n\tif len(ip) > 0 {\n\t\tips := strings.Split(ip, \\\":\\\")\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n\treturn \\\"127.0.0.1\\\"\n}", "CodeBleu_score": 29.57947642622748}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\tntryFile := config.AppInfo.ModulesPath + \\\"/entry.json\\\"\n\tmodulesDir := config.AppInfo.ModulesPath + \\\"/modules\\\"\n\n\tif!file.PathExists(modulesDir) {\n\t\tlogger.Error(errors.New(\\\"modules directory does not exist\\\"))\n\t\treturn\n\t}\n\n\tentry := []model.Entry{}\n\tfiles, err := file.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n\n\tfor _, f := range files {\n\t\tif f == \\\"entry.json\\\" {\n\t\t\tcontinue\n\t\t}\n\t\tentryFile := modulesDir + \\\"/\\\" + f + \\\"/entry.json\\\"\n\t\tif!file.PathExists(entryFile) {\n\t\t\tlogger.Error(errors.New(entryFile + \\\" does not exist\\\"))\n\t\t\tcontinue\n\t\t}\n\n\t\tcontent, err := file.ReadFullFile(entryFile)\n\t\tif err!= nil {\n\t\t\tlogger.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar e model.Entry\n\t\terr = json.Unmarshal(content, &e)\n\t\tif err!= nil {\n\t\t\tlogger.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tentry = append(entry, e)\n\t}\n\n\tcontent, err := json.Marshal(entry)\n\tif err!= nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n\terr = file.WriteFile(entryFile, content)\n\tif err!= nil {\n\t\tlogger.Error(err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 41.22108456237158}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tntryFilePath := config.AppInfo.ModulesPath + \\\"/entry.json\\\"\n\tentryFile, err := os.Create(entryFilePath)\n\tif err!= nil {\n\t\tlogger.Error(\\\"Failed to create entry file\\\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\t// Read module directories\n\tmoduleDirectories, err := ioutil.ReadDir(config.AppInfo.ModulesPath)\n\tif err!= nil {\n\t\tlogger.Error(\\\"Failed to read module directories\\\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read entry.json files from each module directory\n\tvar moduleEntries []string\n\tfor _, moduleDirectory := range moduleDirectories {\n\t\tif!moduleDirectory.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tmoduleEntryFilePath := filepath.Join(config.AppInfo.ModulesPath, moduleDirectory.Name(), \\\"entry.json\\\")\n\t\tmoduleEntryFile, err := os.Open(moduleEntryFilePath)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\\\"Failed to open module entry file\\\", zap.String(\\\"module\\\", moduleDirectory.Name()), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer moduleEntryFile.Close()\n\n\t\tmoduleEntryBytes, err := ioutil.ReadAll(moduleEntryFile)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\\\"Failed to read module entry file\\\", zap.String(\\\"module\\\", moduleDirectory.Name()), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tmoduleEntries = append(moduleEntries, string(moduleEntryBytes))\n\t}\n\n\t// Write module entries to entry file\n\tentryBytes, err := json.Marshal(moduleEntries)\n\tif err!= nil {\n\t\tlogger.Error(\\\"Failed to marshal module entries\\\", zap.Error(err))\n\t\treturn\n\t}\n\t_, err = entryFile.Write(entryBytes)\n\tif err!= nil {\n\t\tlogger.Error(\\\"Failed to write module entries to entry file\\\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.99196135321174}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\tnetworks, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, network := range networks {\n\t\t\tif iface.Name == network.Name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \\\"\\\", errors.New(\\\"no matching interface found\\\")\n}", "CodeBleu_score": 56.938579054522506}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\ta list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service.\n\tnetworkNames, err := c.GetNet(false)\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names.\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\t// Get the MAC address of the interface.\n\t\t\t\tmacAddr := iface.HardwareAddr.String()\n\t\t\t\tif macAddr!= \"\" {\n\t\t\t\t\treturn macAddr, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error.\n\treturn \"\", errors.New(\\\"No matching interface found\\\")\n}", "CodeBleu_score": 57.87065269970962}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \\\"\\\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \\\"\\\", err\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tif v.IP.IsLoopback() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif ip4 := v.IP.To4(); ip4!= nil {\n\t\t\t\t\tif ip4.String() == \\\"127.0.0.1\\\" {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase *net.IPAddr:\n\t\t\t\tif v.IP.IsLoopback() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif ip4 := v.IP.To4(); ip4!= nil {\n\t\t\t\t\tif ip4.String() == \\\"127.0.0.1\\\" {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\n\treturn \\\"\\\", errors.New(\\\"no MAC address found\\\")\n}", "CodeBleu_score": 49.68635284544965}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* add a reference to the request object */\n\tif (refAdd(pRequest) < 0) {\n\t\treturn -ENOMEM;\n\t}\n\n\t/* increment the request count for the associated TSC object */\n\tif (atomicInc(&pTscObj->requestCount) < 0) {\n\t\treturn -EOVERFLOW;\n\t}\n\n\t/* update the application's request summary */\n\tif (appInfo.requestCount > 0) {\n\t\tif (atomicAdd(&appInfo.requestCount, 1) < 0) {\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tif (atomicAdd(&appInfo.currentRequestCount, 1) < 0) {\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t}\n\n\t/* log debug information about the new request */\n\tif (tscDbg.debugLevel >= TSC_DBG_DEBUG) {\n\t\tlogMsg(TSC_DBG_DEBUG, \"request %p registered for TSC %p\", pRequest, pTscObj);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 37.9320507556684}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t  rc = 0;\n\tint32_t  ref = 0;\n\tint32_t  reqCount = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Add a reference to the request object and increment the request count for the associated TSC object.\n\t */\n\tref = tscRefAdd(pRequest);\n\tif (ref < 0) {\n\t\treturn -1;\n\t}\n\n\treqCount = tscReqCountAdd(pTscObj);\n\tif (reqCount < 0) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Update the application's request summary, including total and current request counts.\n\t */\n\tif (appInfo.pAppObj!= NULL) {\n\t\tappInfo.pAppObj->reqCount++;\n\t\tappInfo.pAppObj->reqCur++;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tif (tscDbg.debug > 0) {\n\t\tchar *pLogMsg = NULL;\n\t\tint32_t logMsgLen = 0;\n\n\t\tlogMsgLen = asprintf(&pLogMsg, \"registerRequest: request %p: tsc %p, ref %d, reqCount %d\", pRequest, pTscObj, ref, reqCount);\n\t\tif (logMsgLen > 0) {\n\t\t\tlogMsg(pLogMsg, logMsgLen);\n\t\t\tfree(pLogMsg);\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 33.566968698208505}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb!= NULL && strcasecmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\tchar* dot = strchr(db, '.');\n\t\tif (dot!= NULL) {\n\t\t\tdb = dot + 1;\n\t\t}\n\t\tif (strcasecmp(db, exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 69.63365522751499}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\tif (pRequest->dbList!= NULL) {\n\t\tfor (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\t\tchar* dot = strchr(db, '.');\n\t\t\tif (dot!= NULL) {\n\t\t\t\tdb = dot + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 68.91343540538669}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pDb == NULL) {\n\t\treturn false;\n\t}\n\tif (strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\tfor (int32_t i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n\t\tchar* db = taosArrayGet(pRequest->dbList, i);\n\t\tchar* dot = strchr(db, '.');\n\t\tif (dot!= NULL) {\n\t\t\tdb = dot + 1;\n\t\t}\n\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 69.65014641358027}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t#define REDIRECT_MSG_TYPE_LIST_SIZE 10\n  static const tmsg_t redirectMsgType[REDIRECT_MSG_TYPE_LIST_SIZE] = {\n      TMSG_TSC_NODE_REDIRECT, TMSG_TSC_NODE_REDIRECT_V2, TMSG_TSC_NODE_REDIRECT_V3, TMSG_TSC_NODE_REDIRECT_V4,\n      TMSG_TSC_NODE_REDIRECT_V5, TMSG_TSC_NODE_REDIRECT_V6, TMSG_TSC_NODE_REDIRECT_V7, TMSG_TSC_NODE_REDIRECT_V8,\n      TMSG_TSC_NODE_REDIRECT_V9, TMSG_TSC_NODE_REDIRECT_V10};\n\n  if (code == TSDB_CODE_REDIRECT) {\n    for (int i = 0; i < REDIRECT_MSG_TYPE_LIST_SIZE; i++) {\n      if (msgType == redirectMsgType[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 37.97443943330353}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_SUCCESS) {\n\t\treturn false;\n\t}\n\n\tif (msgType == TMSG_REQ_CONNECT) {\n\t\treturn false;\n\t}\n\n\tif (code == TSDB_CODE_CONNECT_TIMEOUT || code == TSDB_CODE_CONNECT_FAIL) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 40.04948275442665}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == TSDB_CODE_NO_MORE_DATA || code == TSDB_CODE_NO_MORE_DATA_AFTER_LIMIT) {\n\t\treturn true;\n\t}\n\n\tif (msgType == TMSG_TYPE_QUERY_RESULT) {\n\t\treturn true;\n\t}\n\n\tif (code == TSDB_CODE_NO_MORE_DATA_AFTER_LIMIT && msgType == TMSG_TYPE_QUERY_RESULT) {\n\t\treturn true;\n\t}\n\n\tif (code == TSDB_CODE_NO_MORE_DATA_AFTER_LIMIT && msgType == TMSG_TYPE_QUERY_RESULT_SET) {\n\t\treturn true;\n\t}\n\n\tif (code == TSDB_CODE_NO_MORE_DATA_AFTER_LIMIT && msgType == TMSG_TYPE_QUERY_RESULT_SET_EX) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 37.840383423844145}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tstopRequest(pRequest);\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 86.66259480226269}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery) {\n\t\t\t\t// todo check if we can stop a query\n\t\t\t\tstopQuery(pRequest);\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 82.50485338373481}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tvoid *pIter = taosHashIterate(pRequests, NULL);\n\twhile (pIter!= NULL) {\n\t\tint64_t *rid = pIter;\n\n\t\tSRequestObj *pRequest = acquireRequest(*rid);\n\t\tif (pRequest) {\n\t\t\tif (pRequest->pQuery!= NULL) {\n\t\t\t\tpRequest->pQuery->killed = true;\n\t\t\t}\n\t\t\treleaseRequest(*rid);\n\t\t}\n\n\t\tpIter = taosHashIterate(pRequests, pIter);\n\t}\n}", "CodeBleu_score": 76.90659002219877}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0)!= 0) {\n\t\ttscInfo(\"crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop!= 0) {\n\t\ttaosMsleep(200);\n\t}\n}", "CodeBleu_score": 62.375363086728896}, {"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tint32_t clientStop = atomic_load_32(&clientStop);\n\tif (clientStop == 0) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n\t\ttscError(\"failed to stop crash report thread since it is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop > 0) {\n\t\ttaosMsleep(200);\n\t}\n}", "CodeBleu_score": 61.95367718850675}, {"code": "void tscStopCrashReport(){\n\t\tif (!tsEnableCrashReport) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n\t\ttscInfo(\"crash report thread already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop > 0) {\n\t\ttaosMsleep(200);\n\t}\n}", "CodeBleu_score": 64.93828391877918}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\tcode = terrno;\n\t\tgoto _return;\n\t}\n\n\tint32_t numOfView = taosArrayGetSize(hbRsp.pViewMetaRsp);\n\tfor (int32_t i = 0; i < numOfView; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pViewMetaRsp, i);\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tif (rsp->pSchemas[0].colId!= PRIMARYKEY_TIMESTAMP_COL_ID) {\n\t\t\t\ttscError(\"invalid colId[%d] for the first column in view meta rsp msg\", rsp->pSchemas[0].colId);\n\t\t\t\ttFreeSViewHbRsp(&hbRsp);\n\t\t\t\treturn TSDB_CODE_TSC_INVALID_VALUE;\n\t\t\t}\n\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pViewMetaRsp);\n\thbRsp.pViewMetaRsp = NULL;\n\n_return:\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn code;\n}", "CodeBleu_score": 68.11516129547384}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\tcode = terrno;\n\t\tgoto _return;\n\t}\n\n\tint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n\tfor (int32_t i = 0; i < numOfMeta; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogAsyncUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pMetaRsp);\n\thbRsp.pMetaRsp = NULL;\n\n_return:\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn code;\n}", "CodeBleu_score": 68.64593687965105}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t code = 0;\n\n\tSViewHbRsp hbRsp = {0};\n\tif (tDeserializeSViewHbRsp(value, valueLen, &hbRsp)!= 0) {\n\t\tterrno = TSDB_CODE_INVALID_MSG;\n\t\tcode = terrno;\n\t\tgoto _return;\n\t}\n\n\tint32_t numOfMeta = taosArrayGetSize(hbRsp.pMetaRsp);\n\tfor (int32_t i = 0; i < numOfMeta; ++i) {\n\t\tSViewMetaRsp *rsp = taosArrayGet(hbRsp.pMetaRsp, i);\n\n\t\tif (rsp->numOfColumns < 0) {\n\t\t\ttscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->viewName, rsp->suid);\n\t\t} else {\n\t\t\ttscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->viewName);\n\t\t\tcatalogUpdateViewMeta(pCatalog, rsp);\n\t\t}\n\t}\n\n\ttaosArrayDestroy(hbRsp.pMetaRsp);\n\thbRsp.pMetaRsp = NULL;\n\n_return:\n\n\ttFreeSViewHbRsp(&hbRsp);\n\treturn code;\n}", "CodeBleu_score": 68.96210250869159}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t/*\n  TS3GetData *data = (TS3GetData *)callbackData;\n  data->content_length = properties->contentLength;\n*/\n  TS3SizeCBD *data = (TS3SizeCBD *)callbackData;\n  data->content_length = properties->contentLength;\n  return S3StatusOK;\n}", "CodeBleu_score": 51.69252446600885}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tTS3GetData *p = (TS3GetData *)callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tp->content_length = properties->contentLength;\n\t} else {\n\t\tp->content_length = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 77.76473099094675}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t//  (void)callbackData;\n\n  if (properties->content_length > 0) {\n    TS3GetData *data = (TS3GetData *)callbackData;\n    data->content_length = properties->content_length;\n  } else {\n    TS3GetData *data = (TS3GetData *)callbackData;\n    data->content_length = 0;\n  }\n\n  return S3StatusOK;\n}", "CodeBleu_score": 66.60707157470614}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tdef WINDOWS\n  if (taosMkDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup directory failed, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#else\n  if (taosMkDir(tsCheckpointBackupDir, 0755)!= 0) {\n    uError(\"[rsync] create checkpoint backup directory failed, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#endif\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) return;\n\n  char command[PATH_MAX * 4] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 4, \"rsync.exe --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n#else\n  snprintf(command, PATH_MAX * 4, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n#endif\n\n  int32_t code = execCommand(command);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed, code:%d,\" ERRNO_ERR_FORMAT, code, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server successful, port:%d\", tsCheckpointBackupPort);\n  }\n}", "CodeBleu_score": 57.05419755897647}, {"code": "void startRsync(){\n\tdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup directory failed, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n  uDebug(\"[rsync] create checkpoint backup directory successful, dir:%s\", tsCheckpointBackupDir);\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate conf file failed\");\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", path, tsCheckpointPort);\n#else\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointPort);\n#endif\n  int32_t code = execCommand(command);\n  if (code!= 0) {\n    uError(\"[rsync] start rsync server failed,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server successful\");\n  }\n}", "CodeBleu_score": 61.60448473536175}, {"code": "void startRsync(){\n\tdef WINDOWS\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#else\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0 && errno!= EEXIST) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#endif\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n#ifdef WINDOWS\n  snprintf(command, PATH_MAX * 2, \"rsync.exe --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n#else\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupPort);\n#endif\n\n  if (execCommand(command)!= 0) {\n    uError(\"[rsync] start rsync server failed,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  uDebug(\"[rsync] start rsync server successful\");\n}", "CodeBleu_score": 52.76684829077212}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher dispatcher = dispatchers.remove(dispatcherId);\nif (dispatcher!= null) {\ndispatcher.shutdown();\n} else {\nthrow new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n}\n}", "CodeBleu_score": 53.49424667218757}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher current = dispatchers.remove(dispatcherId);\nif (current == null) {\nthrow new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n}\ncurrent.shutdown();\n}", "CodeBleu_score": 41.58251123392296}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tispatcher current = dispatchers.get(dispatcherId);\nif (current!= null) {\ncurrent.shutdown();\ndispatchers.remove(dispatcherId);\n} else {\nthrow new RuntimeException(\\\"Dispatcher with id [\\\" + dispatcherId + \\\"] is not registered!\\\");\n}\n}", "CodeBleu_score": 51.126080879530036}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.getOrDefault(parent, Collections.emptySet());\n children.stream()\n.filter(childFilter)\n.forEach(child -> {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox == null) {\n log.warn(\\\"Child actor with id [{}] is not registered!\\\", child);\n return;\n }\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n });\n }", "CodeBleu_score": 43.663885533343965}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.getOrDefault(parent, Collections.emptySet());\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n TbActorMailbox mailbox = actors.get(child);\n if (mailbox == null) {\n log.warn(\\\"Actor with id [{}] is not registered!\\\", child);\n } else {\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n }\n }\n }\n }", "CodeBleu_score": 41.3268509534096}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId> children = parentChildMap.getOrDefault(parent, Collections.emptySet());\n children.stream().filter(childFilter).forEach(id -> {\n TbActorMailbox mailbox = actors.get(id);\n if (mailbox == null) {\n log.warn(\\\"Child actor with id [{}] is not registered!\\\", id);\n } else {\n if (highPriority) {\n mailbox.tellWithHighPriority(msg);\n } else {\n mailbox.tell(msg);\n }\n }\n });\n }", "CodeBleu_score": 44.91410582053333}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (!destroyInProgress.get()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n} else if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\nif (isUnrecoverable(msg.getException())) {\nlog.debug(\\\"[{}] Failed to enqueue message, going to reinitialize actor\\\", selfId, msg.getException());\ndispatcher.getExecutor().execute(() -> tryInit(1));\n} else {\nlog.debug(\\\"[{}] Failed to enqueue message, going to notify the message that the actor has stopped\\\", selfId, msg.getException());\nmsg.onActorStopped(stopReason);\n}\n} else {\nlog.debug(\\\"[{}] Failed to enqueue message, going to notify the message that the actor has stopped\\\", selfId, msg.getException());\nmsg.onActorStopped(stopReason);\n}\n}", "CodeBleu_score": 51.743519032109795}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (!destroyInProgress.get()) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n} else if (msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\nif (actor.onInitFailure(0, null).isRetry()) {\ndispatcher.getExecutor().execute(() -> tryInit(1));\n} else {\nmsg.notifyStop(stopReason);\n}\n} else {\nmsg.notifyStop(stopReason);\n}\n}", "CodeBleu_score": 48.26759850632195}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (destroyInProgress.get()) {\nif (highPriority && msg.getType() == MsgType.RULE_NODE_UPDATED_MSG) {\ndispatcher.getExecutor().execute(() -> tryInit(1));\n} else {\nmsg.onActorStop(this, stopReason);\n}\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue(false);\n}\n}", "CodeBleu_score": 46.37695301374429}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\tle (!destroyInProgress.get()) {\nTbActorMsg msg = null;\nif (!highPriorityMsgs.isEmpty()) {\nmsg = highPriorityMsgs.poll();\n} else if (!normalPriorityMsgs.isEmpty()) {\nmsg = normalPriorityMsgs.poll();\n}\nif (msg!= null) {\ntry {\nactor.process(msg, this);\n} catch (Throwable t) {\nif (t instanceof TbActorException && t.getCause()!= null) {\nt = t.getCause();\n}\nif (t instanceof TbActorError) {\nTbActorError actorError = (TbActorError) t;\nif (actorError.isUnrecoverable()) {\nstopReason = TbActorStopReason.UNRECOVERABLE_ERROR;\ndestroy(t.getCause());\n} else {\nInitFailureStrategy strategy = actor.onProcessFailure(msg, t);\nif (strategy.isStop()) {\nstopReason = TbActorStopReason.PROCESS_FAILED;\ndestroy(t.getCause());\n} else if (strategy.getRetryDelay() > 0) {\nlog.info(\\\"[{}] Failed to process message {}, going to retry in {}ms\\\", selfId, msg, strategy.getRetryDelay());\nlog.debug(\\\"[{}] Error\\\", selfId, t);\nsystem.getScheduler().schedule(() -> dispatcher.getExecutor().execute(this::processMailbox), strategy.getRetryDelay(), TimeUnit.MILLISECONDS);\n} else {\nlog.info(\\\"[{}] Failed to process message {}, going to retry immediately\\\", selfId, msg);\nlog.debug(\\\"[{}] Error\\\", selfId, t);\ndispatcher.getExecutor().execute(this::processMailbox);\n}\n}\n} else {\nlog.error(\\\"[{}] Failed to process message {}, going to stop\\\", selfId, msg, t);\nstopReason = TbActorStopReason.PROCESS_FAILED;\ndestroy(t);\n}\n}\n}\n}\nbusy.set(FREE);\ntryProcessQueue(false);\n}", "CodeBleu_score": 39.51061779695819}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (destroyInProgress.compareAndSet(false, true)) {\n\t\tstopReason = stopReason == null? TbActorStopReason.DESTROYED : stopReason;\n\t\tsystem.getScheduler().schedule(() -> {\n\t\t\ttry {\n\t\t\t\tready.set(NOT_READY);\n\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\"Failed to destroy actor {}: {}\", selfId, t);\n\t\t\t}\n\t\t}, 0, TimeUnit.MILLISECONDS);\n\t}\n}", "CodeBleu_score": 66.95135370558752}, {"code": "public void destroy(Throwable cause){\n\t\tif (destroyInProgress.compareAndSet(false, true)) {\n\t\tstopReason = stopReason == null? TbActorStopReason.DESTROYED : stopReason;\n\t\tlog.debug(\"[{}] Going to destroy actor, cause: {}\", selfId, cause);\n\t\tdispatcher.getExecutor().execute(() -> {\n\t\t\tready.set(NOT_READY);\n\t\t\ttry {\n\t\t\t\tactor.destroy(stopReason, cause);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.warn(\"[{}] Failed to destroy actor, cause: {}\", selfId, cause, t);\n\t\t\t}\n\t\t\tnotifyStop(stopReason, cause);\n\t\t});\n\t}\n}", "CodeBleu_score": 52.47909694321038}, {"code": "public void destroy(Throwable cause){\n\tif (destroyInProgress.compareAndSet(false, true)) {\nstopReason = stopReason == null? TbActorStopReason.UNKNOWN : stopReason;\nready.set(NOT_READY);\ndispatcher.getExecutor().execute(() -> {\ntry {\nactor.destroy(stopReason, cause);\n} catch (Throwable t) {\nlog.warn(\\\"[{}] Failed to destroy actor, stop reason: {}, cause: {}\\\", selfId, stopReason, cause, t);\n}\ntry {\nTbActorMsg msg = null;\nwhile ((msg = highPriorityMsgs.poll())!= null) {\nmsg.onTbActorStopped(stopReason);\n}\nwhile ((msg = normalPriorityMsgs.poll())!= null) {\nmsg.onTbActorStopped(stopReason);\n}\n} catch (Throwable t) {\nlog.warn(\\\"[{}] Failed to notify messages on actor stoppage, stop reason: {}, cause: {}\\\", selfId, stopReason, cause, t);\n}\n});\n}\n}", "CodeBleu_score": 47.61224004264684}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\teLimitKey key = new RateLimitKey(api, tenantId, level);\nTbRateLimits rateLimits = getRateLimits(key);\nif (rateLimits == null) {\nif (ignoreTenantNotFound) {\nreturn true;\n} else {\nthrow new TenantProfileNotFoundException(tenantId);\n}\n}\nreturn checkRateLimit(api, tenantId, level, rateLimits);\n}", "CodeBleu_score": 30.06376572803728}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tantProfile tenantProfile = tenantProfileProvider.getTenantProfile(tenantId);\nif (tenantId.equals(TenantId.SYSTEM_TENANT_ID)) {\nreturn true;\n}\nif (tenantProfile == null) {\nif (ignoreTenantNotFound) {\nreturn true;\n} else {\nthrow new TenantProfileNotFoundException(tenantId);\n}\n}\nTbRateLimits rateLimits = rateLimits.get(new RateLimitKey(tenantId, api, level));\nif (rateLimits == null) {\nreturn true;\n}\nif (rateLimits.isLimited()) {\nnotificationRuleProcessor.processNotificationRules(new RateLimitsTrigger(api, tenantId, level));\nreturn false;\n} else {\nreturn true;\n}\n}", "CodeBleu_score": 46.83777585544265}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\nInetSocketAddress remotePeer = entry.getKey();\nTbCoapDtlsSessionInfo dtlsSessionInfo = entry.getValue();\nif (dtlsSessionInfo.getLastActivityTime() < expirationTime) {\nlog.trace(\\\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\\\", remotePeer, dtlsSessionInfo.getLastActivityTime());\ndtlsSessionsMap.remove(remotePeer);\n}\n}\n}", "CodeBleu_score": 37.91599669692527}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\nInetSocketAddress remotePeer = entry.getKey();\nTbCoapDtlsSessionInfo dtlsSessionInfo = entry.getValue();\nif (dtlsSessionInfo.getLastActivityTime() < expirationTime) {\nlog.trace(\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\", remotePeer, dtlsSessionInfo.getLastActivityTime());\ndtlsSessionsMap.remove(remotePeer);\n}\n}\n}", "CodeBleu_score": 39.44510989211908}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\nlong expirationTime = currentTime - dtlsSessionInactivityTimeout;\nfor (Map.Entry<InetSocketAddress, TbCoapDtlsSessionInfo> entry : dtlsSessionsMap.entrySet()) {\nInetSocketAddress remotePeer = entry.getKey();\nTbCoapDtlsSessionInfo dtlsSessionInfo = entry.getValue();\nif (dtlsSessionInfo.getLastActivityTime() < expirationTime) {\nlog.trace(\\\"DTLS session removed from in-memory store: [{}] timestamp: [{}]\\\", remotePeer, dtlsSessionInfo.getLastActivityTime());\ndtlsSessionsMap.remove(remotePeer);\n}\n}\n}", "CodeBleu_score": 37.91599669692527}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream().map(entry -> {\nString key = entry.getKey();\nList<JsonNode> values = entry.getValue();\nList<TsKvEntry> tsKvEntries = new ArrayList<>();\nfor (JsonNode value : values) {\ntsKvEntries.add(new BasicTsKvEntry(key, parseValue(key, value)));\n}\nreturn tsKvEntries;\n}).flatMap(Collection::stream).collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 48.31599749759086}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream().map(entry -> {\nList<JsonNode> values = entry.getValue();\nif (CollectionUtils.isEmpty(values)) {\nreturn null;\n}\nList<TsKvEntry> entries = new ArrayList<>();\nfor (JsonNode value : values) {\nentries.add(new BasicTsKvEntry(value.get(KEY).asText(), parseValue(value.get(KEY).asText(), value.get(VALUE)), value.get(TS).asLong()));\n}\nreturn entries;\n}).filter(Objects::nonNull).collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 45.90092567684692}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!CollectionUtils.isEmpty(timeseries)) {\nreturn timeseries.entrySet().stream().map(entry -> {\nList<JsonNode> values = entry.getValue();\nreturn new BasicTsKvEntry(entry.getKey(), values.stream().map(value -> parseValue(entry.getKey(), value)).collect(Collectors.toList()));\n}).collect(Collectors.toList());\n} else {\nreturn Collections.emptyList();\n}\n}", "CodeBleu_score": 42.52377772112995}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\\\"refresh_token\\\", refreshToken);\n\ntry {\nResponseEntity<String> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/noauth/refresh\\\", requestMap, String.class);\nString responseBody = response.getBody();\nif (responseBody!= null) {\nJSONObject responseJson = new JSONObject(responseBody);\nmainToken = responseJson.getString(\\\"access_token\\\");\nmainTokenExpTs = System.currentTimeMillis() + responseJson.getLong(\\\"expires_in\\\") * 1000;\nrefreshToken = responseJson.getString(\\\"refresh_token\\\");\nrefreshTokenExpTs = mainTokenExpTs - TimeUnit.SECONDS.toMillis(30);\n}\n} catch (Exception e) {\nlog.error(\\\"Failed to refresh token\\\", e);\n}\n}", "CodeBleu_score": 28.255723391537273}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\\\"refresh_token\\\", refreshToken);\ntry {\nResponseEntity<String> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/noauth/refresh\\\", requestMap, String.class);\nif (response.getStatusCode().is2xxSuccessful()) {\nMap<String, Object> responseBody = JsonUtils.deserialize(response.getBody(), Map.class);\n\nmainToken = (String) responseBody.get(\\\"access_token\\\");\nmainTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis((Integer) responseBody.get(\\\"expires_in\\\"));\nrefreshToken = (String) responseBody.get(\\\"refresh_token\\\");\nrefreshTokenExpTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis((Integer) responseBody.get(\\\"refresh_expires_in\\\"));\n} else {\nthrow new ThingsBoardException(\\\"Failed to refresh token.\\\");\n}\n} catch (HttpStatusCodeException e) {\nthrow new ThingsBoardException(\\\"Failed to refresh token.\\\", e);\n\n}\n}", "CodeBleu_score": 26.10301474765536}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\\\"refreshToken\\\", refreshToken);\ntry {\nResponseEntity<Map<String, String>> response = loginRestTemplate.postForEntity(baseURL + \\\"/api/noauth/refresh\\\", requestMap, Map.class);\nif (response.getStatusCode().is2xxSuccessful()) {\nMap<String, String> body = response.getBody();\nmainToken = body.get(\\\"token\\\");\nmainTokenExpTs = System.currentTimeMillis() + Long.parseLong(body.get(\\\"tokenExpTime\\\"));\nrefreshToken = body.get(\\\"refreshToken\\\");\nrefreshTokenExpTs = System.currentTimeMillis() + Long.parseLong(body.get(\\\"refreshTokenExpTime\\\"));\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}", "CodeBleu_score": 27.33542839474506}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", );\n long ts = System.currentTimeMillis();\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 55.452447270068795}, {"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", );\n long ts = System.currentTimeMillis();\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 55.452447270068795}, {"code": " private void doLogin(){\n\t Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\\\"username\\\", username);\n loginRequest.put(\\\"password\\\", );\n long ts = System.currentTimeMillis();\n ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \\\"/api/auth/login\\\", loginRequest, JsonNode.class);\n setTokenInfo(ts, tokenInfo.getBody());\n }", "CodeBleu_score": 55.452447270068795}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 89.28734550304821}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 89.28734550304821}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\nreturn Optional.ofNullable(device.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 89.28734550304821}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nResponseEntity<Device> response = restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", new Object[] { device, credentials }, Device.class);\nreturn Optional.ofNullable(response.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 65.046267265313}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nResponseEntity<Device> deviceResponse = restTemplate.postForEntity(baseURL + \\\"/api/device-with-credentials\\\", new DeviceWithCredentials(device, credentials), Device.class);\nreturn Optional.ofNullable(deviceResponse.getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 37.302364332110145}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.ofNullable(restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class).getBody());\n} catch (HttpClientErrorException exception) {\nif (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow exception;\n}\n}\n}", "CodeBleu_score": 50.67427630968617}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length < 2) {\nthis.each(function(device) {\nthis.brightness(device, addr);\n});\n} else {\nthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, Math.round(val / 100 * 15));\n}\nreturn this;\n}", "CodeBleu_score": 47.82648621811157}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\nthis.each(function(device) {\nthis.brightness(device, addr);\n});\n} else {\nthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, Math.round(val * 15 / 100));\n}\nreturn this;\n}", "CodeBleu_score": 50.209255499738184}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\nthis.each(function(device) {\nthis.brightness(device, addr);\n});\n} else {\nthis.send(addr, this.OP.INTENSITY || LedControl.OP.INTENSITY, Math.round(val / 100 * 15));\n}\nreturn this;\n}", "CodeBleu_score": 51.30597123085909}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tlet device = {};\n\tlet proto = LedControl.prototype;\n\tlet ownProperties = Object.getOwnPropertyNames(this);\n\n\tfor (let key in proto) {\n\t\tif (proto.hasOwnProperty(key)) {\n\t\t\tdevice[key] = proto[key].bind(this, addr);\n\t\t}\n\t}\n\n\tfor (let i = 0; i < ownProperties.length; i++) {\n\t\tdevice[ownProperties[i]] = this[ownProperties[i]].bind(this, addr);\n\t}\n\n\treturn device;\n}", "CodeBleu_score": 29.52747821276102}, {"code": "device(addr){\n\tlet device = {};\nfor (let key in LedControl.prototype) {\nif (LedControl.prototype.hasOwnProperty(key)) {\ndevice[key] = LedControl.prototype[key].bind(this, addr);\n}\n}\nreturn device;\n}", "CodeBleu_score": 26.068630856895986}, {"code": "device(addr){\n\tconst device = {};\nfor (const key in LedControl.prototype) {\nif (LedControl.prototype.hasOwnProperty(key)) {\ndevice[key] = LedControl.prototype[key].bind(this, addr);\n}\n}\nreturn device;\n}", "CodeBleu_score": 26.506394719793324}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tthods.forEach(method => {\n// Create Inputs wrappers for each method listed.\n// This will allow us control over all Input instances\n// simultaneously.\ntarget[method] = function(...args) {\nconst length = this.length;\nconst promises = [];\n\nfor (let i = 0; i < length; i++) {\npromises.push(this[i][method](...args));\n}\n\nreturn Promise.all(promises);\n};\n});\n}", "CodeBleu_score": 29.62539713671759}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t", "CodeBleu_score": 3.6909120196701934}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tnst noop = () => {};\n\nconst callbacks = {};\n\nfor (const method of methods) {\nconst callbackName = `${method}Callback`;\n\ncallbacks[method] = (duration = 1000, callback = noop) => {\nconst promises = [];\n\nconst length = this.length;\n\nfor (let i = 0; i < length; i++) {\npromises.push(this[i][method]());\n}\n\nPromise.all(promises).then(() => {\ncallback();\n});\n};\n\ncallbacks[callbackName] = callback;\n}\n\nreturn Object.assign(target, callbacks);\n}", "CodeBleu_score": 38.99376992603133}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\nconst state = priv.get(this);\n\n// Initialize an empty input string\nstate.input = \"\";\n\n// Start a read loop on the specified serial port\nthis.io.serialRead(state.portId, (err, data) => {\n\n// Append the data to the input string\nstate.input += data;\n\n// Split the input string into sentences based on the \"\\r\n\" delimiter\nconst sentences = state.input.split(\"\\r\n\");\n\n// Process all complete sentences by calling \"parseNmeaSentence\" for each one\nsentences.forEach(sentence => {\nthis.parseNmeaSentence(sentence);\n});\n\n// Retain any incomplete sentence for the next read\nstate.input = sentences[sentences.length - 1];\n\n// Continue the read loop\nthis.listen();\n\n});\n\n}", "CodeBleu_score": 39.92693867638049}, {"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = \"\";\n\n// Start a read loop on the serial port\nstate.portId.on(\"data\", data => {\n\n// Append data to the input string\ninput += data.toString();\n\n// Split the input string into sentences\nconst sentences = input.split(\"\\r\n\");\n\n// Remove the incomplete sentence from the input string\ninput = sentences.pop();\n\n// Process each complete sentence\nsentences.forEach(sentence => {\nthis.parseNmeaSentence(sentence);\n});\n});\n}", "CodeBleu_score": 43.05615007145139}, {"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = state.input || \\\"\\\";\n\n// Start a read loop\nthis.io.serialRead(state.portId, (error, data) => {\n\n// Append the data to the input string\ninput += data;\n\n// Split the input string into sentences\nconst sentences = input.split(\\\"\\\\r\\\n\\\");\n\n// Loop through the sentences\nfor (let i = 0; i < sentences.length; ++i) {\n\n// Process each sentence\nthis.parseNmeaSentence(sentences[i]);\n\n}\n\n// Retain any incomplete sentence for the next read\nstate.input = sentences[sentences.length - 1];\n\n});\n\n}", "CodeBleu_score": 52.01905968851357}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tsize_t buffer_size;\n\n\t/* Check if the buffer size is sufficient for the number of channels and the size of each data sample. */\n\tbuffer_size = sequence->channels * sizeof(uint16_t);\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"insufficient buffer size: %zu\", buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Calculate the number of active channels and the needed buffer size. */\n\tdata->channels = 0;\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channel_ids[i] < AD559X_PIN_MAX) {\n\t\t\tdata->channels++;\n\t\t}\n\t}\n\tbuffer_size = data->channels * sizeof(uint16_t);\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"insufficient buffer size: %zu\", buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.337145982929215}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size = 0U;\n\tuint32_t channels = 0U;\n\n\t/*\n\t * Calculate the number of active channels based on the ADC configuration.\n\t * The ADC configuration is stored in the \"adc_conf\" variable.\n\t */\n\tfor (uint8_t i = 0U; i < AD559X_PIN_MAX; i++) {\n\t\tif (BIT(i) & data->adc_conf) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the needed buffer size based on the number of active channels and the size of each data sample.\n\t * The size of each data sample is 16 bits, so the buffer size is calculated as (channels * sizeof(uint16_t)).\n\t */\n\tbuffer_size = channels * sizeof(uint16_t);\n\n\t/*\n\t * Check if the provided buffer size is sufficient to hold the data samples.\n\t * If the buffer size is insufficient, return an error code indicating insufficient memory.\n\t */\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERR(\"insufficient memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If the buffer size is sufficient, return 0 indicating success.\n\t */\n\treturn 0;\n}", "CodeBleu_score": 46.60479503503447}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tsize_t buffer_size;\n\tuint8_t num_active_channels;\n\n\t/* Calculate the number of active channels based on the ADC configuration */\n\tnum_active_channels = 0;\n\tfor (uint8_t i = 0; i < AD559X_PIN_MAX; i++) {\n\t\tif (data->adc_conf & BIT(i)) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the buffer size based on the number of active channels and the size of each data sample */\n\tbuffer_size = num_active_channels * sequence->buffer_size * sizeof(uint16_t);\n\n\t/* Check if the provided buffer size is sufficient */\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\\\"insufficient memory for buffer size %zu\\\", buffer_size);\\\n\t\treturn -ENOMEM;\\\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.2703147248445}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tsize_t needed;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"insufficient buffer size %zu\", sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 62.99661756611209}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~data->channels) {\n\t\tLOG_ERR(\"invalid channels 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (adc_validate_buffer_size(dev, sequence) < 0) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 66.82570379484338}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tsize_t needed;\n\tint ret;\n\n\tif (sequence->resolution!= AD559X_ADC_RESOLUTION) {\n\t\tLOG_ERR(\"invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->repeat_buffer = sequence->buffer;\n\n\tadc_context_init(&data->ctx, sequence);\n\tadc_context_start(&data->ctx);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 60.87199900403279}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tuint8_t channels = ctx->channels;\n\tuint8_t i;\n\n\tdata->channels = channels;\n\tdata->repeat_buffer = data->buffer;\n\n\tfor (i = 0; i < channels; i++) {\n\t\tif (channels & BIT(i)) {\n\t\t\tdata->repeat_buffer[i] = data->buffer[i];\n\t\t}\n\t}\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 59.7816602067226}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tdata->channels = find_msb_set(ctx->sequence.channels);\n\tdata->repeat_buffer = data->buffer;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 74.5855412288075}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\tint ret;\n\n\tdata->channels = find_msb_set(ctx->sequence->channels);\n\tdata->repeat_buffer = data->buffer;\n\n\tret = k_sem_take(&data->sem, K_NO_WAIT);\n\tif (ret == 0) {\n\t\tk_sem_give(&data->sem);\n\t\treturn;\n\t}\n\n\tret = k_sem_take(&data->sem, K_FOREVER);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"failed to take semaphore\");\n\t\treturn;\n\t}\n\n\tk_thread_abort(&data->thread);\n\tk_thread_create(&data->thread, data->stack,\n\t\t\tCONFIG_ADC_AD559X_ACQUISITION_THREAD_STACK_SIZE,\n\t\t\tadc_ad559x_acquisition_thread, data, NULL, NULL,\n\t\t\tK_PRIO_COOP(CONFIG_ADC_AD559X_ACQUISITION_THREAD_PRIORITY),\n\t\t\tK_NO_WAIT);\n}", "CodeBleu_score": 54.24257112295474}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = data->repeat_buffer;\n\t} else {\n\t\tctx->buffer = data->buffer;\n\t}\n}", "CodeBleu_score": 73.53414807404835}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t} else {\n\t\tdata->buffer += ctx->sequence.channels;\n\t}\n}", "CodeBleu_score": 76.49538593258522}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\truct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n\n\tif (repeat_sampling) {\n\t\tdata->buffer = data->repeat_buffer;\n\t} else {\n\t\tdata->buffer += ctx->sequence.channels;\n\t}\n}", "CodeBleu_score": 76.49538593258522}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_PIN_MAX; channel++) {\n\t\t\tif (data->channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(dev, channel, &val);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"failed to read channel %d\", channel);\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = val;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_complete(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 52.16962034632617}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint ret;\n\tuint16_t val;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (uint8_t i = 0; i < data->channels; i++) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, i, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", i, ret);\n\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t*data->buffer++ = val;\n\t\t}\n\n\t\tadc_context_complete(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 49.57415286309297}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (uint8_t channel = 0; channel < data->channels; channel++) {\n\t\t\tif (BIT(channel) & data->channels) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, data->buffer);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tadc_context_complete(&data->ctx, -EIO);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer++;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_complete(&data->ctx, 0);\n\t}\n}", "CodeBleu_score": 53.83530820768366}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tint rc = 0;\n\tuint8_t reg;\n\tk_sleep(data->ready_time);\n\twhile ((rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg)) == 0) {\n\t\tif (reg & ADS1112_CONFIG_MASK_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tk_usleep(100);\n\t}\n\treturn rc;\n}", "CodeBleu_score": 41.77629331134036}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t config;\n\tint ret;\n\n\tk_sleep(data->ready_time);\n\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (!(config & ADS1112_CONFIG_MASK_READY)) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(config & ADS1112_CONFIG_MASK_READY)) {\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.221097153394574}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tstruct ads1112_data *data = dev->data;\n\tint ret = 0;\n\tuint8_t reg = 0;\n\tk_sleep(data->ready_time);\n\tdo {\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\t\tif (ret!= 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tk_sleep(K_USEC(100));\n\t} while (!(reg & ADS1112_CONFIG_MASK_READY));\n\treturn ret;\n}", "CodeBleu_score": 44.3363070791009}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = sequence->options & ADC_SEQUENCE_BUFFER_SIZE_MASK;\n\tint required_buffer_size = sequence->options & ADC_SEQUENCE_BUFFER_SIZE_MASK;\n\n\tif (sequence->options & ADC_SEQUENCE_EXTRA_SAMPLING) {\n\t\trequired_buffer_size += sequence->extra_sampling;\n\t}\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size (%d) is less than the required size (%d)\", buffer_size, required_buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.23235113987123}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t buffer_size = sequence->options & ADC_OPT_BUFFER_MASK;\n\tuint16_t required_buffer_size = sequence->buffer_size;\n\tuint16_t extra_samples = sequence->options & ADC_OPT_XFER_EXTRA_SAMPLES_MASK;\n\tuint16_t required_buffer_size_with_extra_samples = required_buffer_size + extra_samples;\n\n\tif (buffer_size < required_buffer_size_with_extra_samples) {\n\t\tLOG_ERR(\"Buffer size (%d) is less than required size (%d) + extra samples (%d)\", buffer_size, required_buffer_size, extra_samples);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.401896149591884}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t required_buffer_size = 0;\n\n\tif (sequence->options & ADC_OPT_PERSISTENT) {\n\t\t/* If the sequence is persistent, the buffer size should be at least 1, since the first sample is always stored in the buffer. */\n\t\trequired_buffer_size = 1;\n\t}\n\n\tif (sequence->options & ADC_OPT_CALIBRATE) {\n\t\t/* If the sequence is calibrate, the buffer size should be at least 1, since the first sample is always stored in the buffer. */\n\t\trequired_buffer_size = 1;\n\t}\n\n\tif (sequence->options & ADC_OPT_ITERS_EN) {\n\t\t/* If the sequence is iterative, the buffer size should be at least the number of iterations specified in the sequence options. */\n\t\trequired_buffer_size += sequence->options & ADC_OPT_ITERS_MASK;\n\t}\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is less than required size. Required buffer size: %d, Buffer size: %d\", required_buffer_size, sequence->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.633277521202245}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (data->buffer) {\n\t\tLOG_ERR(\"ADC already in progress\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tadc_context_update_buffer_pointer(&data->ctx, sequence->options->repeat_buffer);\n\tadc_context_start_sampling(&data->ctx);\n\n\tif (wait) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.642989369110296}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (wait) {\n\t\tret = adc_context_validate_and_lock(&data->ctx, sequence, true);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tadc_context_update_buffer_pointer(&data->ctx, false);\n\t\tadc_context_start_sampling(&data->ctx);\n\n\t\tret = k_sem_take(&data->acq_sem, K_FOREVER);\n\t\tif (ret!= 0) {\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = adc_context_validate_and_lock(&data->ctx, sequence, false);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tadc_context_update_buffer_pointer(&data->ctx, false);\n\t\tadc_context_start_sampling(&data->ctx);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.890841130575694}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\tif (!device_is_ready(dev)) {\n\t\treturn -ENODEV;\n\t}\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tadc_context_update_buffer_pointer(&data->ctx, false);\n\tdata->buffer = sequence->buffer;\n\n\trc = adc_read(&data->ctx);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tif (wait) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 69.13164296903534}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 97.36591047949277}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn audio_codec_apply_property(dev);\n}", "CodeBleu_score": 94.87526410834471}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tconst struct device *dev;\n\n\tdev = device_get_binding(argv[args_indx.device]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Audio Codec device not found\");\n\t\treturn -ENODEV;\n\t}\n\taudio_codec_apply_properties(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 91.63555589788861}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tret = i2s_start(config->comm_master);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"DMIC not active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tret = i2s_stop(config->comm_master);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.48833016732311}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\tint i2s_cmd;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\ti2s_cmd = I2S_CMD_START;\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"DMIC already inactive\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\ti2s_cmd = I2S_CMD_STOP;\n\t\tdata->state = DMIC_STATE_INACTIVE;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid DMIC trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_send_command(config->comm_master, i2s_cmd, K_FOREVER);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"I2S send command failed (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.40609742951544}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint ret;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *const data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tret = i2s_rx_start(config->comm_master, data->pdm_filter[0].pcm_buffer, data->pcm_mem_size);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"start failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"already inactive\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tret = i2s_rx_stop(config->comm_master);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"stop failed (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_INACTIVE;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"unsupported command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.18073640646048}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 85.84301649019132}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 85.77207539828134}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON;\n\t}\n\n\tif (data->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}", "CodeBleu_score": 89.88125287150433}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint rc;\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_take(&data->lock_sem, K_FOREVER);\n#endif\n\n\tif (config->busy_gpio.port == NULL) {\n\t\trc = -ENOTSUP;\n\t} else {\n\t\trc = gpio_pin_get_dt(&config->busy_gpio);\n\t}\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_give(&data->lock_sem);\n#endif\n\n\treturn rc;\n}", "CodeBleu_score": 73.38533880217207}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint rc;\n\n\t/* Check if busy GPIO port is defined */\n\tif (!config->busy_gpio.port) {\n\t\tLOG_ERR(\"Busy GPIO port is not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Get the status of the busy GPIO pin */\n\trc = gpio_pin_get_dt(&config->busy_gpio);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Busy GPIO pin get failed: %d\", rc);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 74.34430872332555}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tstruct auxdisplay_itron_data *data = dev->data;\n\tint rc;\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_take(&data->lock_sem, K_FOREVER);\n#endif\n\n\tif (data->busy_gpio.port == NULL) {\n\t\trc = -ENOTSUP;\n\t} else {\n\t\trc = gpio_pin_get_dt(&data->busy_gpio);\n\t}\n\n#ifdef CONFIG_MULTITHREADING\n\tk_sem_give(&data->lock_sem);\n#endif\n\n\treturn rc;\n}", "CodeBleu_score": 56.90640424163315}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n\n\tint rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\treturn rc;\n}", "CodeBleu_score": 86.02908691071278}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tint ret = 0;\n\n\tif (!data) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > BBRAM_MAX_SIZE) {\n\t\tLOG_ERR(\"Read size %zu exceeds maximum size %zu\", size,\n\t\t\tBBRAM_MAX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_MAX_SIZE) {\n\t\tLOG_ERR(\"Read offset %zu + read size %zu exceeds maximum size %zu\",\n\t\t\toffset, size, BBRAM_MAX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &data->data[offset], size);\n\n\treturn ret;\n}", "CodeBleu_score": 48.95403184267396}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (size > config->size) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Invalid read offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is invalid\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM power failure\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_->data + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 63.25308337544998}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_standby_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a standby power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_power(dev)) {\n\t\tLOG_ERR(\"BBRAM incurred a power failure\");\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > dev->config->size) {\n\t\tLOG_ERR(\"Read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev->config->size) {\n\t\tLOG_ERR(\"Read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &data_->data[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 44.396495574279214}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 98.01744870375246}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Could not get device %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 78.75446296843789}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 80.93914305358474}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 80.68992233781135}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tuint8_t *buf = h4->rx.hdr;\n\tsize_t hdr_len = h4->rx.hdr_len;\n\tsize_t read;\n\n\t/* Read header data */\n\tread = uart_fifo_read(cfg->uart, buf, hdr_len);\n\tif (read!= hdr_len) {\n\t\tLOG_WRN(\"Unable to read H:4 header\");\n\t\th4->rx.type = BT_HCI_H4_NONE;\n\t\treturn;\n\t}\n\n\th4->rx.remaining -= read;\n}", "CodeBleu_score": 58.74331547561311}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\tint bytes_read;\n\n\t/* Read header data from UART */\n\tif (h4->rx.have_hdr) {\n\t\tbytes_read = uart_fifo_read(cfg->uart, h4->rx.hdr, h4->rx.hdr_len - h4->rx.remaining);\n\t} else {\n\t\tbytes_read = uart_fifo_read(cfg->uart, h4->rx.hdr, h4->rx.hdr_len);\n\t}\n\n\tif (bytes_read < 0) {\n\t\tLOG_WRN(\"Unable to read H:4 header\");\n\t\treturn;\n\t}\n\n\th4->rx.remaining -= bytes_read;\n\th4->rx.have_hdr = true;\n}", "CodeBleu_score": 57.42675924837258}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tconst struct h4_config *cfg = dev->config;\n\tstruct h4_data *h4 = dev->data;\n\n\t/* Read header data */\n\tif (uart_fifo_read(cfg->uart, &h4->rx.hdr[h4->rx.hdr_len - h4->rx.remaining], h4->rx.remaining)!= h4->rx.remaining) {\n\t\tLOG_WRN(\"Unable to read H:4 packet header\");\n\t\th4->rx.remaining = 0;\n\t\treturn;\n\t}\n\n\t/* Update remaining bytes count */\n\th4->rx.remaining -= h4->rx.hdr_len - h4->rx.remaining;\n}", "CodeBleu_score": 48.50399569550477}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read = 0;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tsize_t bytes_to_read = MIN(len, sizeof(buf));\n\t\tret = uart_fifo_read(uart, buf, bytes_to_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= ret;\n\t\tbytes_read += ret;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 48.43289807852737}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t bytes_read = 0;\n\tuint8_t buf[33];\n\n\twhile (len > 0) {\n\t\tsize_t read_len = MIN(len, sizeof(buf));\n\t\tint ret = uart_fifo_read(uart, buf, read_len);\n\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= ret;\n\t\tbytes_read += ret;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 47.82118375782321}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read;\n\n\t/* Attempt to read up to 33 bytes into the temporary buffer */\n\tbytes_read = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\n\t/* Log an error if the read operation fails */\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"Unable to read from UART (ret %d)\", bytes_read);\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 59.73945076158036}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *chan_data = (struct zbus_channel_data *)chan->data;\n\tstruct zbus_observer_node *obs_nd, *tmp;\n\tint16_t highest_hop = INT16_MAX;\n\n\tk_mutex_lock(&chan_data->lock, K_FOREVER);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan_data->observers, obs_nd, tmp, node) {\n\t\tconst struct zbus_observer *obs = obs_nd->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->hop < highest_hop) {\n\t\t\thighest_hop = obs->hop;\n\t\t}\n\t}\n\n\tchan_data->highest_hop = highest_hop;\n\tk_mutex_unlock(&chan_data->lock);\n}", "CodeBleu_score": 26.791212734672058}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *data = chan->data;\n\n\tif (data->highest_observer_priority == ZBUS_PRIORITY_MAX) {\n\t\treturn;\n\t}\n\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = data->observers_start_idx, limit = data->observers_end_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (obs->priority < data->highest_observer_priority) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->highest_observer_priority = obs->priority;\n\t}\n}", "CodeBleu_score": 61.05840532062747}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *data = chan->data;\n\n\tk_mutex_lock(&data->mutex, K_FOREVER);\n\n\tint16_t highest_priority = ZBUS_OBSERVER_PRIORITY_HIGHEST;\n\n\tfor (int16_t i = 0; i < data->observers_end_idx; ++i) {\n\t\tstruct zbus_channel_observation *observation;\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (obs->priority < highest_priority && obs->data->enabled) {\n\t\t\thighest_priority = obs->priority;\n\t\t}\n\t}\n\n\tdata->highest_priority = highest_priority;\n\n\tk_mutex_unlock(&data->mutex);\n}", "CodeBleu_score": 42.56947316756513}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tint16_t i;\n\t\tfor (i = 0; i < _zbus_chan_count; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tif (chan->data->highest_observer_priority < obs->data->priority) {\n\t\t\t\tchan_update_hop(chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 16.25346028489493}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channels_end_idx;\n\n\t\tfor (int16_t i = _zbus_channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.10720940694673}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tint16_t i = 0;\n\t\tint16_t limit = _zbus_chan_count;\n\n\t\tfor (; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.39720675997666}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(!k_is_in_isr(), \"cannot attach to an ISR\");\n\t_ZBUS_ASSERT(obs!= NULL, \"obs is required\");\n\n\tint current_thread_priority = k_thread_priority_get(k_current_get());\n\n\tK_SPINLOCK(&obs_slock) {\n\t\tif (obs->data->priority!= current_thread_priority) {\n\t\t\tobs->data->priority = current_thread_priority;\n\n\t\t\tupdate_all_channels_hop(obs);\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.44887549088126}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 75.07046871426598}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\terr = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 86.61781504652494}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan!= NULL, \"chan is required\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint context_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &context_priority);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, context_priority);\n\n\treturn err;\n}", "CodeBleu_score": 75.07046871426598}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n}", "CodeBleu_score": 4.451885662912518}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tuint32_t curDescAddr;\n\tETH_TX_DESC *curDesc;\n\tETH_TX_DESC *ring = (ETH_TX_DESC *)ETH->TDESLA;\n\n\tcurDescAddr = ETH->TDESLA;\n\tcurDesc = (ETH_TX_DESC *)curDescAddr;\n\twhile (curDesc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n\t\tcurDesc = (ETH_TX_DESC *)curDesc->nextDescAddr;\n\t\tif (curDescAddr == (uint32_t)curDesc) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn curDesc;\n}", "CodeBleu_score": 56.89350614457288}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc = (ETH_TX_DESC *)ETH->TDESLA;\n\tuint8_t first = desc->TX_0.TX0_b.FS;\n\tuint8_t last = desc->TX_0.TX0_b.LS;\n\n\tdo {\n\t\tINNER_ETH_TX_DESC *desc = (INNER_ETH_TX_DESC *)desc;\n\n\t\tif (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n\t\t\t// clear all bits\n\t\t\tdesc->TX_0.TX0 = 0;\n\t\t\tdesc->TX_0.TX0_b.FS = first;\n\t\t\tdesc->TX_0.TX0_b.LS = last;\n\t\t\tdesc->TX_0.TX0_b.TCH = TRUE;\n\t\t\tdesc->TX_0.TX0_b.IC = TRUE;\n\t\t\tdesc->TX_0.TX0_b.OWN = ETH_DESC_OWN_BY_SELF;\n\n\t\t\treturn desc;\n\t\t}\n\n\t\tdesc = (ETH_TX_DESC *)desc->nextDescAddr;\n\t} while (desc!= (ETH_TX_DESC *)ETH->TDESLA);\n\n\treturn 0;\n}", "CodeBleu_score": 58.65470823984437}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *ring = (ETH_TX_DESC *)ETH->TDESLA;\n\tETH_TX_DESC *buf = ring;\n\tuint8_t first = buf->TX_0.TX0_b.FS;\n\tuint8_t last = buf->TX_0.TX0_b.LS;\n\n\tdo {\n\t\tINNER_ETH_TX_DESC *desc = (INNER_ETH_TX_DESC *)buf;\n\t\tif (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n\t\t\tdesc->TX_0.TX0 = 0;\n\t\t\tdesc->TX_0.TX0_b.FS = first;\n\t\t\tdesc->TX_0.TX0_b.LS = last;\n\t\t\tdesc->TX_0.TX0_b.TCH = TRUE;\n\t\t\tdesc->TX_0.TX0_b.IC = TRUE;\n\t\t\tdesc->TX_0.TX0_b.OWN = ETH_DESC_OWN_BY_SELF;\n\t\t\treturn buf;\n\t\t}\n\t\tbuf = (ETH_TX_DESC *)buf->nextDescAddr;\n\t} while (buf!= ring);\n\n\treturn NULL;\n}", "CodeBleu_score": 55.93072485868477}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tuint32_t cyp_channel;\n\tcy_rslt_t result;\n\tRT_ASSERT(device!= RT_NULL);\n\tcyhal_dac_t *dac_device;\n\tdac_device = device->parent.user_data;\n\t/* get current dac channel*/\n\tcyp_channel = cyp_dac_get_channel(channel);\n\t/*DAC device init*/\n\tresult = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\t/*DAC free device*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 69.07229027962882}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t", "CodeBleu_score": 14.149251500080561}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trslt_t result;\n\trt_uint32_t cyp_channel;\n\tRT_ASSERT(device!= RT_NULL);\n\tcyhal_dac_t *dac_device;\n\tdac_device = device->parent.user_data;\n\t/* get current dac channel*/\n\tcyp_channel = cyp_dac_get_channel(channel);\n\t/*DAC device init*/\n\tresult = Cy_CSDIDAC_Init(&CSDIDAC_csdidac_config, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"Cy_CSDIDAC_Init fail = %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\t/*DAC free device*/\n\tresult = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC Outputenable failed. Error: %d\n\", result);\n\t\treturn -RT_ENOSYS;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 69.4856180355232}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t page = 0;\n\trt_uint32_t offset = 0;\n\trt_uint32_t bytes_read = 0;\n\n\t/* Check if the address is valid */\n\tif (addr > block_info.end_addr) {\n\t\tLOG_E(\"Invalid address\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Check if the read operation would exceed the flash memory's end address */\n\tif ((addr + size) > block_info.end_addr) {\n\t\tLOG_E(\"Read operation would exceed flash memory's end address\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* Read data from the flash memory */\n\tpage = get_page_32k(addr);\n\toffset = addr - page;\n\n\twhile (size > 0) {\n\t\trt_uint32_t bytes_to_read = IFX_EFLASH_PAGE_SIZE - offset;\n\t\tif (bytes_to_read > size) {\n\t\t\tbytes_to_read = size;\n\t\t}\n\n\t\tcyhal_flash_read(&flash_obj, page, offset, buf, bytes_to_read, 0);\n\n\t\tbytes_read += bytes_to_read;\n\t\tbuf += bytes_to_read;\n\t\tsize -= bytes_to_read;\n\t\toffset = 0;\n\t\tpage += IFX_EFLASH_PAGE_SIZE;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 40.613031730880685}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tifdef RT_USING_FAL\n    rt_uint32_t page = 0;\n    rt_uint32_t page_size = 0;\n    rt_uint32_t page_offset = 0;\n    rt_uint32_t page_addr = 0;\n    rt_uint32_t page_buf[IFX_EFLASH_PAGE_SIZE / 4];\n    rt_uint32_t page_buf_size = 0;\n    rt_uint32_t read_size = 0;\n    rt_uint32_t i = 0;\n    rt_uint32_t j = 0;\n\n    if (addr > block_info.end_addr) {\n        LOG_E(\"Read address is out of range\");\n        return -RT_EINVAL;\n    }\n\n    if (size == 0) {\n        LOG_E(\"Read size is zero\");\n        return -RT_EINVAL;\n    }\n\n    page = get_page_32k(addr);\n    page_size = IFX_EFLASH_PAGE_SIZE;\n    page_offset = addr - page;\n    page_addr = page;\n\n    while (read_size < size) {\n        page_buf_size = page_size - page_offset;\n        if (page_buf_size > (size - read_size)) {\n            page_buf_size = size - read_size;\n        }\n\n        if (cyhal_flash_read_data(&flash_obj, page_addr, page_buf, page_buf_size)!= CY_RSLT_SUCCESS) {\n            LOG_E(\"Read flash data failed\");\n            return -RT_ERROR;\n        }\n\n        for (i = 0; i < page_buf_size; i++) {\n            buf[read_size + i] = (rt_uint8_t)(page_buf[i] & 0xFF);\n        }\n\n        read_size += page_buf_size;\n        page_addr += page_size;\n        page_offset = 0;\n    }\n\n    return read_size;\n#else\n    return -RT_ENOSYS;\n#endif\n}", "CodeBleu_score": 41.84403477031017}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t \"timer_counter_get\" retrieves the current count value of a hardware timer.\nIt first asserts that the provided timer is not null.\nThen, it retrieves the timer object from the timer's user data and reads the current count using the \"cyhal_timer_read\" function.\nFinally, it returns the count value.\n */\nRT_ASSERT(timer!= RT_NULL);\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 56.14701641000151}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tn \"timer_counter_get\" retrieves the current count value of a hardware timer.\nIt first asserts that the provided timer is not null.\nThen, it retrieves the timer object from the timer's user data and reads the current count using the \"cyhal_timer_read\" function.\nFinally, it returns the count value.\n */\ncy_rslt_t result = RT_EOK;\n\ncyhal_timer_t *tim = RT_NULL;\n\ntim = (cyhal_timer_t *)timer->parent.user_data;\n\nreturn cyhal_timer_read(tim);\n}", "CodeBleu_score": 55.271185583661484}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tn \"timer_counter_get\" retrieves the current count value of a hardware timer.\nIt first asserts that the provided timer is not null.\nThen, it retrieves the timer object from the timer's user data and reads the current count using the \"cyhal_timer_read\" function.\nFinally, it returns the count value.\n */\n    RT_ASSERT(timer!= RT_NULL);\n    cyhal_timer_t *tim = RT_NULL;\n    tim = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(tim);\n}", "CodeBleu_score": 56.724739535991155}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\trt_mutex_take(&fslock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.702181827426383}, {"code": "void dfs_lock(void){\n\t}", "CodeBleu_score": 3.1131432122697555}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tt fd;\n\tint index;\n\n\t/* search for an empty slot */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* if no empty slot is found, attempt to expand the fd table */\n\tfd = fd_slot_expand(fdt, startfd);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 38.87512982272167}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tdef RT_USING_SMART\n    int index = 0;\n    int nr;\n    struct dfs_file **fds;\n\n    if (startfd < fdt->maxfd) {\n        for (index = startfd; index < fdt->maxfd; index++) {\n            if (fdt->fds[index] == NULL) {\n                break;\n            }\n        }\n    }\n\n    if (index == fdt->maxfd) {\n        nr = ((startfd + 4) & ~3);\n        if (nr > DFS_FD_MAX) {\n            nr = DFS_FD_MAX;\n        }\n        fds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\n        if (!fds) {\n            return -1;\n        }\n\n        /* clean the new allocated fds */\n        for (index = fdt->maxfd; index < nr; index++) {\n            fds[index] = NULL;\n        }\n        fdt->fds   = fds;\n        fdt->maxfd = nr;\n    }\n\n    return index;\n#else\n    int index = 0;\n    int nr;\n    struct dfs_file **fds;\n\n    if (startfd < fdt->maxfd) {\n        for (index = startfd; index < fdt->maxfd; index++) {\n            if (fdt->fds[index] == NULL) {\n                break;\n            }\n        }\n    }\n\n    if (index == fdt->maxfd) {\n        nr = ((startfd + 4) & ~3);\n        if (nr > DFS_FD_MAX) {\n            nr = DFS_FD_MAX;\n        }\n        fds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\n        if (!fds) {\n            return -1;\n        }\n\n        /* clean the new allocated fds */\n        for (index = fdt->maxfd; index < nr; index++) {\n            fds[index] = NULL;\n        }\n        fdt->fds   = fds;\n        fdt->maxfd = nr;\n    }\n\n    return index;\n#endif\n}", "CodeBleu_score": 44.2747558148632}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tt fd, index;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\t/* search for an empty slot */\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/* no empty slot found, try to expand */\n\tfd = fd_slot_expand(fdt, index);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 36.55504258662776}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t#if defined(RT_USING_FINSH) && defined(FINSH_USING_MSH)\n    extern struct finsh_variable *rt_errno_finsh_var;\n    if (rt_errno_finsh_var!= RT_NULL) {\n        rt_errno_finsh_var->value.i32 = error;\n    }\n#endif\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    int i;\n    for (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++) {\n        if (rt_errno_strs[i].error == error) {\n            return rt_errno_strs[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 69.9793194433312}, {"code": "const char *rt_strerror(rt_err_t error){\n\t", "CodeBleu_score": 3.4236961536175192}, {"code": "const char *rt_strerror(rt_err_t error){\n\t#if defined(RT_USING_SEM)\n    if (error < 0) {\n        error = -error;\n    }\n\n    /* Search for a matching error code in the table. */\n    for (int i = 0; i < sizeof(rt_errno_strs) / sizeof(struct _errno_str_t); i++) {\n        if (rt_errno_strs[i].error == error) {\n            return rt_errno_strs[i].str;\n        }\n    }\n#endif /* RT_USING_SEM */\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 64.45372881590794}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result = RT_EOK;\nrt_base_t level;\n\nif (hook == RT_NULL)\nreturn -RT_ERROR;\n\n/* lock the spinlock */\nlevel = rt_hw_interrupt_disable();\nrt_spinlock_take(&_hook_spinlock, RT_WAITING_FOREVER);\n\n/* iterate through the idle hook list */\nfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n/* check if the slot is empty */\nif (idle_hook_list[i] == RT_NULL) {\nidle_hook_list[i] = hook;\nresult = RT_EOK;\nbreak;\n}\n}\n\n/* release the spinlock */\nrt_spinlock_release(&_hook_spinlock);\nrt_hw_interrupt_enable(level);\n\nreturn result;\n}", "CodeBleu_score": 65.09917208213245}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\t/* lock spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\trt_spin_lock(&_hook_spinlock);\n\n\t/* find empty slot */\n\tfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check result */\n\tif (idle_hook_list[RT_IDLE_HOOK_LIST_SIZE - 1]!= RT_NULL) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* release spinlock */\n\trt_spin_unlock(&_hook_spinlock);\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 60.662282373702034}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t", "CodeBleu_score": 4.801704682804091}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_size_t i;\n\trt_err_t ret = -RT_ENOSYS;\n\trt_base_t level;\n\n\tlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tret = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\n\treturn ret;\n}", "CodeBleu_score": 91.9440969940395}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_size_t i;\nrt_err_t ret = -RT_ENOSYS;\nrt_base_t level;\n\nlevel = rt_spin_lock_irqsave(&_hook_spinlock);\n\nfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\nif (idle_hook_list[i] == hook) {\nidle_hook_list[i] = RT_NULL;\nret = RT_EOK;\nbreak;\n}\n}\n\nrt_spin_unlock_irqrestore(&_hook_spinlock, level);\n\nreturn ret;\n}", "CodeBleu_score": 91.6313043647393}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t", "CodeBleu_score": 4.801704682804091}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.07326881772602}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.07326881772602}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_sched_lock_level_t slvl;\n\trt_thread_t thread;\n\trt_err_t error;\n\n\tRT_SCHED_DEBUG_IS_UNLOCKED;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_sched_lock(&slvl);\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = RT_THREAD_LIST_NODE_ENTRY(susp_list->next);\n\t\terror = rt_sched_thread_ready(thread);\n\n\t\tif (error) {\n\t\t\tLOG_D(\"%s [error:%d] failed to resume thread:%p from suspended list\", __func__, error, thread);\n\n\t\t\tthread = RT_NULL;\n\t\t} else {\n\t\t\t/* thread error should not be a negative value */\n\t\t\tif (thread_error >= 0) {\n\t\t\t\t/* set thread error code to notified resuming thread */\n\t\t\t\tthread->error = thread_error;\n\t\t\t}\n\t\t}\n\t}\n\trt_sched_unlock(slvl);\n\n\tLOG_D(\"resume thread:%s\n\", thread->parent.name);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.07326881772602}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t#ifdef RT_USING_DEVICE\n    rt_device_t old_device = _console_device;\n    rt_device_t new_device = rt_device_find(name);\n    if (new_device!= RT_NULL && new_device!= old_device) {\n        if (old_device!= RT_NULL) {\n            rt_device_close(old_device);\n        }\n        if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n            _console_device = new_device;\n        }\n    }\n    return old_device;\n#else\n    RT_UNUSED(name);\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 65.04289690547016}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t#if defined(RT_USING_DEVICE)\n    rt_device_t old_device = _console_device;\n    rt_device_t new_device = rt_device_find(name);\n\n    if (new_device!= RT_NULL) {\n        if (new_device!= old_device) {\n            if (old_device!= RT_NULL) {\n                rt_device_close(old_device);\n            }\n\n            if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n                _console_device = new_device;\n            } else {\n                _console_device = RT_NULL;\n            }\n        }\n    }\n\n    return old_device;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 64.26469322791536}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t#ifdef RT_USING_DEVICE\n    rt_device_t old_console_device = _console_device;\n\n    if (name!= RT_NULL) {\n        rt_device_t new_console_device = rt_device_find(name);\n\n        if (new_console_device!= RT_NULL) {\n            if (new_console_device!= _console_device) {\n                /* close the current console device */\n                if (_console_device!= RT_NULL) {\n                    rt_device_close(_console_device);\n                }\n\n                /* open the new console device */\n                if (rt_device_open(new_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n                    _console_device = new_console_device;\n                } else {\n                    _console_device = old_console_device;\n                }\n            }\n        } else {\n            _console_device = old_console_device;\n        }\n    } else {\n        _console_device = old_console_device;\n    }\n\n    return old_console_device;\n#else\n    RT_UNUSED(name);\n    return RT_NULL;\n#endif /* RT_USING_DEVICE */\n}", "CodeBleu_score": 54.73647523760441}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\tfor (index = 0; index < RT_Object_Info_Unknown; index ++)\n\t\tif (_object_container[index].type == type) return _object_container[index].length;\n\treturn 0;\n}", "CodeBleu_score": 17.121090804680435}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\tint length = 0;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\tfor (index = 0; index < RT_Object_Info_Unknown; index++) {\n\t\tif (_object_container[index].type == type) {\n\t\t\trt_spinlock_lock(&_object_container[index].lock);\n\t\t\tlength = _object_container[index].length;\n\t\t\trt_spinlock_unlock(&_object_container[index].lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn length;\n}", "CodeBleu_score": 27.149200959848617}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint index;\n\n\ttype = (enum rt_object_class_type)(type & ~RT_Object_Class_Static);\n\n\tfor (index = 0; index < RT_Object_Info_Unknown; index ++)\n\t\tif (_object_container[index].type == type) return _object_container[index].length;\n\n\treturn 0;\n}", "CodeBleu_score": 17.121090804680435}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n\tstruct rt_object_information *information;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* enter critical */\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove object from object list */\n#ifdef RT_USING_MODULE\n\tif (object->module_id) {\n\t\trt_list_remove(&(object->list));\n\t\tobject->module_id = RT_NULL;\n\t} else\n#endif /* RT_USING_MODULE */\n\t{\n\t\trt_list_remove(&(object->list));\n\t}\n\n\t/* leave critical */\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* set object type to zero */\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 73.6085878329831}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call hook function */\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* get object information */\n\tstruct rt_object_information *information = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* remove object from object list */\n\trt_spin_lock(&(information->spinlock));\n\trt_list_remove(&(object->list));\n\trt_spin_unlock(&(information->spinlock));\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 51.378927072987324}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\trt_base_t level;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* call hook function */\n\tRT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\t/* remove object from information object list */\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n#ifdef RT_USING_MODULE\n\tif (object->module_id!= RT_NULL) {\n\t\trt_list_remove(&(object->list));\n\t\tobject->module_id = RT_NULL;\n\t} else\n#endif /* RT_USING_MODULE */\n\t{\n\t\trt_list_remove(&(object->list));\n\t}\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 71.39846172529249}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t/* object check */\nRT_ASSERT(obj!= RT_NULL);\n\n/* check if the object is a custom object */\nRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n/* get the custom object */\nstruct rt_custom_object *cobj = (struct rt_custom_object *)obj;\n\n/* invoke the custom object destroy method */\nrt_err_t result = RT_EOK;\nif (cobj->destroy!= RT_NULL)\n{\nresult = cobj->destroy(cobj->data);\n}\n\n/* delete the custom object */\nrt_object_delete(obj);\n\nreturn result;\n}", "CodeBleu_score": 65.87277176253903}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tstruct rt_custom_object *cobj = RT_NULL;\n\trt_err_t result = RT_EOK;\n\n\t/* parameter check */\n\tRT_ASSERT(obj!= RT_NULL);\n\n\t/* which is invoke in interrupt status */\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tcobj = (struct rt_custom_object *)obj;\n\tRT_ASSERT(cobj->type == RT_Object_Class_Custom);\n\n\t/* check if the object has a destroy method */\n\tif (cobj->destroy) {\n\t\tresult = cobj->destroy(cobj->data);\n\t}\n\n\t/* delete the object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 64.72323984298684}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tstruct rt_custom_object *cobj = RT_NULL;\n\n\t/* parameter check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tcobj = (struct rt_custom_object *)obj;\n\n\t/* check if the object has a destroy method */\n\tif (cobj->destroy) {\n\t\tcobj->destroy(cobj->data);\n\t}\n\n\t/* delete the object */\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 54.69096444879248}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\t/* get current thread */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* check thread */\n\tif (thread == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* verify thread is suspended */\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* set thread error */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&thread->tlist);\n\n\t/* insert thread into ready list */\n\trt_thread_ready(thread);\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\t/* schedule */\n\trt_schedule();\n}", "CodeBleu_score": 48.959129689753375}, {"code": "static void _thread_timeout(void *parameter){\n\tif defined(RT_USING_HOOK) && defined(RT_HOOK_USING_FUNC_PTR)\n    /* check the thread is valid */\n    rt_thread_t thread = (rt_thread_t)parameter;\n\n    if (thread->error!= RT_EOK) {\n        return;\n    }\n#endif\n\n    rt_base_t level;\n    rt_thread_t thread = (rt_thread_t)parameter;\n\n    /* lock scheduler */\n    level = rt_hw_interrupt_disable();\n\n    /* check the thread is valid */\n    if (thread->error!= RT_EOK) {\n        /* unlock scheduler */\n        rt_hw_interrupt_enable(level);\n        return;\n    }\n\n    /* thread is suspended, set error number to timeout */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove the thread from suspend list */\n    rt_list_remove(&thread->tlist);\n\n    /* insert the thread into ready list */\n    rt_thread_ready(thread);\n\n    /* unlock scheduler */\n    rt_hw_interrupt_enable(level);\n\n    /* reschedule */\n    rt_schedule();\n}", "CodeBleu_score": 40.55270341693613}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct rt_thread *thread;\n\trt_base_t critical_level;\n\n\t/* get current thread */\n\tthread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\tcritical_level = rt_enter_critical();\n\n\t/* check the thread is suspended */\n\tif (thread->suspend_flag!= RT_THREAD_SUSPEND) {\n\t\t/* set the thread error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* remove the thread from suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert the thread to ready list */\n\t\trt_thread_ready(thread);\n\t}\n\n\trt_exit_critical_safe(critical_level);\n}", "CodeBleu_score": 50.17649829042615}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tfdef RT_USING_MUTEX\n    rt_base_t level;\n    rt_list_t *wait_list;\n    struct rt_mutex *mutex;\n\n    /* get thread's spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* check if the thread is waiting on a mutex */\n    wait_list = &thread->wait_list;\n    if (!rt_list_isempty(wait_list)) {\n        /* remove the thread from the mutex's waiting list */\n        mutex = rt_list_entry(wait_list, struct rt_mutex, wait_list);\n        rt_list_remove(wait_list);\n\n        /* clear the pending object */\n        mutex->owner = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (!rt_list_isempty(&thread->take_list)) {\n        mutex = rt_list_entry(thread->take_list.next, struct rt_mutex, take_list);\n        rt_list_remove(&mutex->take_list);\n        mutex->owner = RT_NULL;\n    }\n\n    /* restore the spinlock state */\n    rt_hw_interrupt_enable(level);\n#endif /* RT_USING_MUTEX */\n}", "CodeBleu_score": 51.392847224522306}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tfdef RT_USING_MUTEX\n    rt_base_t level;\n    rt_list_t *wait_list;\n    rt_list_t *next;\n    rt_list_t *prev;\n    rt_list_t *node;\n    rt_mutex_t *mutex;\n\n    RT_ASSERT(thread!= RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    /* lock the thread */\n    level = rt_hw_interrupt_disable();\n\n    /* check if the thread is waiting on a mutex */\n    wait_list = &thread->wait_list;\n    node = wait_list->next;\n    while (node!= wait_list) {\n        /* get the mutex from the node */\n        mutex = rt_list_entry(node, struct rt_mutex, wait_list);\n\n        /* remove the node from the mutex's wait list */\n        next = node->next;\n        prev = node->prev;\n        rt_list_remove(node);\n\n        /* clear the pending object */\n        mutex->pending_thread = RT_NULL;\n\n        /* remove the mutex from the thread's taken list */\n        rt_list_remove(&mutex->taken_list);\n\n        /* move to the next node */\n        node = next;\n    }\n\n    /* release all mutexes the thread has taken */\n    node = thread->taken_list.next;\n    while (node!= &thread->taken_list) {\n        /* get the mutex from the node */\n        mutex = rt_list_entry(node, struct rt_mutex, taken_list);\n\n        /* remove the mutex from the thread's taken list */\n        rt_list_remove(node);\n\n        /* release the mutex */\n        rt_mutex_release(mutex);\n\n        /* move to the next node */\n        node = thread->taken_list.next;\n    }\n\n    /* restore the spinlock state */\n    rt_hw_interrupt_enable(level);\n#endif /* RT_USING_MUTEX */\n}", "CodeBleu_score": 46.54942333606729}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\tt_base_t level;\n\trt_list_t *wait_list;\n\trt_list_t *node;\n\trt_list_t *next;\n\trt_mutex_t *mutex;\n\n\t/* get the thread's spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\t/* check if the thread is waiting on a mutex */\n\twait_list = &thread->wait_list;\n\tnode = wait_list->next;\n\twhile (node!= wait_list) {\n\t\t/* get the mutex */\n\t\tmutex = rt_list_entry(node, rt_mutex_t, wait_list);\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(node);\n\t\t/* clear the pending object */\n\t\tmutex->owner = RT_NULL;\n\t\t/* go to the next node */\n\t\tnext = node->next;\n\t\t/* release the mutex */\n\t\trt_mutex_release(mutex);\n\t\t/* go to the next node */\n\t\tnode = next;\n\t}\n\t/* restore the thread's spinlock */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 33.022293728166204}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->parent.flag & RT_OBJECT_FLAG_DEACTIVATED);\n\tRT_ASSERT(thread->parent.flag & RT_OBJECT_FLAG_STATIC);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n\trt_object_hook_call(&thread->parent, RT_Object_Class_Thread, RT_Object_Event_Startup, RT_NULL);\n\n\t/* log thread name and priority */\n\trt_kprintf(\"thread %s start up, priority = %d\n\", thread->parent.name, thread->parent.priority);\n\n\t/* calculate priority attributes */\n\trt_thread_priority_calculate(thread);\n\n\t/* reset thread state to suspended */\n\trt_thread_suspend(thread);\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler if available */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 48.625224549932994}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* thread is not in the initialization state */\n\tif (thread->stat!= RT_THREAD_INIT) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* thread is not of the correct type */\n\tif (thread->type!= RT_Thread_Object) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* thread is already started */\n\tif (thread->stat == RT_THREAD_READY) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* thread is already suspended */\n\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* thread is already running */\n\tif (thread->stat == RT_THREAD_RUNNING) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* log the thread's name and priority */\n\trt_kprintf(\"thread %s priority = %d\n\", thread->name, thread->priority);\n\n\t/* calculate priority attributes */\n\tthread->static_priority = rt_thread_priority_group(thread->priority);\n\tthread->dynamic_priority = thread->static_priority;\n\tthread->current_priority = thread->static_priority;\n\n\t/* reset thread state to suspended */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume the thread and trigger a scheduler if available */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 39.95242763806096}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_list_t *list = timer_list;\n#else\n    rt_list_t *list = timer_list + RT_TIMER_SKIP_LIST_LEVEL - 1;\n#endif\n    rt_tick_t tick;\n\n    if (rt_list_isempty(list)) {\n        return -RT_ERROR;\n    }\n\n    list = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n    tick = list->timeout_tick;\n\n    if (tick < *timeout_tick) {\n        *timeout_tick = tick;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.577363199993236}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\t/* timer object initialization */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize timer object */\n\tresult = _timer_init(timer, timeout, parameter, time, flag);\n\tif (result!= RT_EOK) {\n\t\trt_object_release(timer);\n\t\treturn RT_NULL;\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 73.26622538281356}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t/* parameter check */\nRT_ASSERT(timeout!= RT_NULL);\nRT_ASSERT(time < RT_TICK_MAX / 2);\n\n/* timer object initialization */\nrt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n_timer_init(timer, timeout, parameter, time, flag);\n\nreturn &(timer->parent);\n}", "CodeBleu_score": 54.10554555604954}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer = RT_NULL;\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time < RT_TICK_MAX / 2);\n\n\t/* timer object initialization */\n\ttimer = rt_malloc(sizeof(struct rt_timer));\n\tif (timer!= RT_NULL) {\n\t\tresult = rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\t\tif (result == RT_EOK) {\n\t\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t\t} else {\n\t\t\trt_free(timer);\n\t\t\ttimer = RT_NULL;\n\t\t}\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 66.11312695128773}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t recorder *httptest.ResponseRecorder\n\tfor _, handler := range a.handlers {\n\t\trecorder = httptest.NewRecorder()\n\t\thandler(recorder, req)\n\t\tres.WriteHeader(recorder.Code)\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif recorder.Code == 401 {\n\t\t\tres.Write([]byte(\\\"Not Authorized\\\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 54.06751850127542}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t _, handler := range a.handlers {\n\t\thandler(res, req)\n\t}\n\tif res.Header().Get(\\\"WWW-Authenticate\\\")!= \\\"\\\" {\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(\\\"Not Authorized\\\"))\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 41.868673206201755}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tCreate a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\t// Create a copy of the original response writer\n\toriginal := res\n\t// Create a copy of the original request\n\toriginalReq := req\n\t// Create a copy of the original request body\n\toriginalBody := req.Body\n\n\t// Create a new request with the original request body\n\treq.Body = ioutil.NopCloser(strings.NewReader(originalBody))\n\n\t// Create a new response writer that writes to the recorder\n\tres = httptest.NewRecorder()\n\n\t// Add the recorder's headers to the original response\n\tfor k, v := range recorder.Header() {\n\t\toriginal.Header()[k] = v\n\t}\n\n\t// Call each handler in sequence\n\tfor _, handler := range a.handlers {\n\t\thandler(res, req)\n\t}\n\n\t// If any handler returns a \"401 Unauthorized\" status, send a \"Not Authorized\" error response and stop further processing\n\tif recorder.Code == http.StatusUnauthorized {\n\t\thttp.Error(original, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router\n\ta.router.ServeHTTP(original, originalReq)\n}", "CodeBleu_score": 58.900488138353154}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\th := req.URL.Path\n\tif path == \\\"/\\\" {\n\t\tpath = \\\"/index.html\\\"\n\t}\n\tasset, err := assets.Asset(path)\n\tif err!= nil {\n\t\thttp.Error(res, \\\"Not Found\\\", http.StatusNotFound)\n\t\treturn\n\t}\n\text := strings.Split(path, \\\".\\\")[1]\n\tres.Header().Set(\\\"Content-Type\\\", mime.TypeByExtension(\\\".\\\"+ext))\n\tres.Write(asset)\n}", "CodeBleu_score": 28.234029134351996}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\th := req.URL.Path[1:]\n\tasset, err := Asset(\\\"robeaux/\\\" + path)\n\tif err!= nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\text := strings.Split(path, \\\".\\\")[1]\n\tres.Header().Set(\\\"Content-Type\\\", \\\"text/\\\"+ext)\n\tres.Write(asset)\n}", "CodeBleu_score": 25.484462787194683}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\th := req.URL.Path\n\tif path == \\\"/\\\" {\n\t\tpath = \\\"/index.html\\\"\n\t}\n\tpath = strings.TrimPrefix(path, \\\"/\\\")\n\tif path == \\\"index.html\\\" {\n\t\tpath = \\\"index.html\\\"\n\t}\n\tasset, err := Asset(path)\n\tif err!= nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tres.Header().Set(\\\"Content-Type\\\", http.DetectContentType(asset))\n\tres.Write(asset)\n}", "CodeBleu_score": 29.666475016747828}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tif robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot!= nil {\n\t\tjsonConnections := []*gobot.JSONConnection{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tjsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n\t\t})\n\t\ta.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n\t}\n}", "CodeBleu_score": 92.63029249806758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\"),\n\t\t}, res)\n\t} else {\n\t\ta.writeJSON(map[string]interface{}{\n\t\t\t\"connections\": robot.Connections(),\n\t\t}, res)\n\t}\n}", "CodeBleu_score": 43.936258978738415}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the credentials\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\t// Check if the credentials are valid\n\t\tif len(pair) == 2 && subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) == 1 && subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) == 1 {\n\t\t\treturn\n\t\t}\n\n\t\t// Credentials are invalid\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 51.336823705866166}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the username and password from the Authorization header.\n\t\t// Basic Auth format: \"Basic base64(username:password)\"\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif len(parts)!= 2 || parts[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the username and password from the base64 encoded string.\n\t\tpayload, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the payload into username and password.\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password against the provided credentials.\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) == 1 &&\n\t\t\tsubtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) == 1 {\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 50.75417971269167}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\t// Get the Basic Authentication credentials\n\t\tpayload, err := base64.StdEncoding.DecodeString(r.Header.Get(\"Authorization\")[6:])\n\t\tif err!= nil {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\t// Check credentials\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 || subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username))!= 1 || subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password))!= 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\t// Credentials ok, so return the next handler\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Authorised.\n\"))\n\t}\n}", "CodeBleu_score": 48.45164775835657}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 53.05458504462204}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.86350020740118}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\te := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\treturn int(math.Min(math.Max(slope*input+intercept, toMin), toMax))\n\t}\n}", "CodeBleu_score": 43.914214742468815}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.analogRead == nil {\n\t\treturn -1, -1, errors.New(\\\"AnalogSensorDriver does not support analog reading\\\")\n\t}\n\trawValue, value, err := a.analogRead()\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\treturn rawValue, value, err\n}", "CodeBleu_score": 39.315804055465684}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.sensorCfg.readInterval == 0 {\n\t\t// cyclic reading deactivated\n\t\treturn 0, 0.0, nil\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tif rawValue!= a.lastRawValue && rawValue!= -1 {\n\t\ta.lastRawValue = rawValue\n\t\ta.Publish(a.Event(Data), rawValue)\n\t}\n\tif value!= a.lastValue && value!= -1 {\n\t\ta.lastValue = value\n\t\ta.Publish(a.Event(Value), value)\n\t}\n\n\treturn rawValue, value, err\n}", "CodeBleu_score": 49.54310369730477}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.analogRead == nil {\n\t\treturn -1, -1, fmt.Errorf(\\\"AnalogSensorDriver does not support analog read\\\")\n\t}\n\n\trawValue, value, err := a.analogRead()\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\ta.lastRawValue = rawValue\n\ta.lastValue = value\n\treturn rawValue, value, nil\n}", "CodeBleu_score": 42.699922792242106}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(input int) float64 { return m*float64(input) + n }\n}", "CodeBleu_score": 54.28538463482241}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m*float64(fromMin)\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 55.05993414739924}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(input int) float64 { return m*float64(input) + n }\n}", "CodeBleu_score": 54.28538463482241}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 37.72199434950605}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 37.72199434950605}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t:= GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\n\treturn &d\n}", "CodeBleu_score": 37.72199434950605}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 60000.0 / (d.bpm * hz)\n\ton := int(period * 0.7)\n\toff := int(period * 0.3)\n\tfor i := 0; i < int(duration*1000); i += on + off {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(on) * time.Millisecond)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(off) * time.Millisecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 54.70453786788434}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz < 0 || hz > 20000 {\n\t\treturn fmt.Errorf(\\\"invalid frequency: %f\\\", hz)\n\t}\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\\\"invalid duration: %f\\\", duration)\n\t}\n\tif d.bpm < 0 {\n\t\treturn fmt.Errorf(\\\"invalid bpm: %f\\\", d.bpm)\n\t}\n\t\n\t// calculate the tone period and tempo\n\ttonePeriod := 1000.0 / hz\n\ttempo := 60000.0 / d.bpm\n\t\n\t// calculate the number of times to repeat the tone\n\tnumRepeats := int(duration / tempo)\n\t\n\t// loop through the number of repeats\n\tfor i := 0; i < numRepeats; i++ {\n\t\t// turn the buzzer on for the tone period\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t\t// turn the buzzer off for the tone period\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\t\n\treturn nil\n}", "CodeBleu_score": 50.590909672503315}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm)\n\ttonePeriod := 60000 / (d.bpm * hz)\n\t// calculate the number of times the buzzer should be toggled based on the duration\n\tnumToggles := int(duration / tonePeriod)\n\t// toggle the buzzer on and off at intervals determined by the tone period, repeating this process numToggles times\n\tfor i := 0; i < numToggles; i++ {\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 43.737206956722275}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t// ensure that read and write of variables (direction, stepNum) can not interfere\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// stop any running operation\n\tif err := d.stopIfRunning(); err!= nil {\n\t\treturn err\n\t}\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 70.46287409185419}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\t// we need to wait 1ms after sleeping before doing a step to charge the step pump (according to data sheet)\n\ttime.Sleep(1 * time.Millisecond)\n\n\treturn nil\n}", "CodeBleu_score": 68.70969752036788}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.easyCfg.sleepPin == \"\" {\n\t\treturn fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n\t}\n\n\t_ = d.stopIfRunning() // drop step errors\n\n\t// sleepPin is active low\n\tif err := d.digitalWrite(d.easyCfg.sleepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = false\n\n\t// we need to wait 1ms after sleeping before doing a step to charge the step pump (according to data sheet)\n\ttime.Sleep(1 * time.Millisecond)\n\n\treturn nil\n}", "CodeBleu_score": 86.5683803811283}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\\\"AnalogPinsAdaptor: pins not initialized\\\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 57.49621442844024}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"Analog pins not initialized\\\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 56.085497336790624}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\\\"AnalogPinsAdaptor: pins map is not initialized\\\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, r, w, bufLen, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewAnalogPin(a.sys, path, r, w, bufLen)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 57.75306372994209}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, system.WithPinDirectionOutput())\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.34993274730145}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif!a.connected {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected\")\n\t}\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor has no pins\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif!ok {\n\t\t// translate the ID to obtain chip and line information\n\t\tchip, line, err := a.translatePinID(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// create a new digital pin\n\t\tpin = gobot.NewDigitalPin(a, chip, line)\n\n\t\t// initialize the pin\n\t\tif err := pin.Initialize(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// apply the provided options to the pin\n\t\tfor _, opt := range opts {\n\t\t\tif opt!= nil {\n\t\t\t\topt(pin)\n\t\t\t}\n\t\t}\n\n\t\t// store the pin\n\t\ta.pins[id] = pin\n\t} else {\n\t\t// apply the provided options to the pin\n\t\tfor _, opt := range opts {\n\t\t\tif opt!= nil {\n\t\t\t\topt(pin)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 53.05896365058524}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif!a.IsConnected() {\n\t\treturn nil, errors.New(gobot.ErrNotConnected)\n\t}\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(gobot.ErrNotConnected)\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\tif!opt(pin) {\n\t\t\t\treturn nil, errors.New(gobot.ErrInvalidPin)\n\t\t\t}\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tif a.pinOptions == nil {\n\t\treturn nil, errors.New(gobot.ErrInvalidPin)\n\t}\n\n\tif len(a.pinOptions) == 0 {\n\t\treturn nil, errors.New(gobot.ErrInvalidPin)\n\t}\n\n\tif a.pinOptions[id] == nil {\n\t\treturn nil, errors.New(gobot.ErrInvalidPin)\n\t}\n\n\toptions := a.pinOptions[id]\n\tfor _, opt := range opts {\n\t\tif!opt(options) {\n\t\t\treturn nil, errors.New(gobot.ErrInvalidPin)\n\t\t}\n\t}\n\n\tchip, line, err := a.translatePinId(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := system.NewDigitalPin(a.sys, chip, line, options.direction, options.activeLow, options.pullUp, options.pullDown, options.openDrain, options.openSource, options.debounce, options.eventOnFallingEdge, options.eventOnRisingEdge, options.eventOnBothEdges, options.pollForEdgeDetection, options.pollInterval, options.pollQuitChan)\n\tif err := pin.Initialize(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 47.95765216186193}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif!a.IsConnected() {\n\t\treturn nil, errors.New(\"digital pin adaptor is not connected\")\n\t}\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if pin already exists\n\tif pin, ok := a.pins[id]; ok {\n\t\t// Apply additional options\n\t\tfor _, opt := range opts {\n\t\t\tif!opt(pin) {\n\t\t\t\treturn nil, fmt.Errorf(\"digital pin adaptor option failed for pin %q\", id)\n\t\t\t}\n\t\t}\n\n\t\treturn pin, nil\n\t}\n\n\t// Translate ID to chip and line\n\tchip, line, err := a.translatePinID(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Create new pin\n\tpin := system.NewDigitalPin(chip, line)\n\n\t// Apply additional options\n\tfor _, opt := range opts {\n\t\tif!opt(pin) {\n\t\t\treturn nil, fmt.Errorf(\"digital pin adaptor option failed for pin %q\", id)\n\t\t}\n\t}\n\n\t// Initialize pin\n\tif err := pin.Initialize(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Store pin\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 50.007136591138234}]}
