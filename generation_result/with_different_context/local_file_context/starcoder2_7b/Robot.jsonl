{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\treturn _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_required_files\\\", folder, download);\n}", "CodeBleu_score": 11.090691497954122}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\treturn FileTransfer::GetRequiredFiles(folder, download);\n}", "CodeBleu_score": 19.627157101138238}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\treturn FileTransfer::GetRequiredFiles(folder, download);\n}", "CodeBleu_score": 19.629635170130268}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n// If the attachment type is SpringArm or SpringArmGhost, check the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis and issue a warning if necessary.\nif (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n  if (transform.location.z == 0.0f) {\n    log_warning(LOG_CHANNEL, \"The provided transform for the actor is ill-formed when the attachment type is SpringArm or SpringArmGhost. The translation is only in the 'z' axis. The actor will be spawned without the SpringArm or SpringArmGhost attachment.\");\n  }\n}\n\n// Call the internal function to complete the actor spawning process and return the spawned actor.\nreturn _pimpl->CallAndWait<rpc::Actor>(\"spawn_actor_with_parent\", description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 48.40352939161585}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n/*\n * This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.\nIf the attachment type is SpringArm or SpringArmGhost, it checks the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis and issues a warning if necessary.\nFinally, it calls an internal function to complete the actor spawning process and returns the spawned actor.\n */\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    const auto translation = transform.location;\n    if (translation.x == 0.0f && translation.y == 0.0f && translation.z!= 0.0f) {\n      log_warning(LOG_TAG, \"Actor attachment to parent with SpringArm or SpringArmGhost is not supported when the translation is only in the 'z' axis. The actor will be spawned without the SpringArm or SpringArmGhost attachment.\");\n    }\n  }\n  return _pimpl->CallAndWait<rpc::Actor>(\\\"spawn_actor_with_parent\\\", description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 42.01028424175306}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#if CARLA_SERVER\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n      if (transform.location.z == 0.0f) {\n        log_warning(\"The actor's transform has only translation in the 'z' axis. This may cause ill-formed transformations when the actor is attached to a parent. Consider using a different attachment type.\");\n      }\n    }\n#endif\n    return _pimpl->CallAndWait<rpc::Actor>(\\\"spawn_actor_with_parent\\\", description, transform, parent, attachment_type, socket_name);\n  }", "CodeBleu_score": 36.09324800628132}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t (_walker_navigation == nullptr) {\n\t\t_walker_navigation = std::make_shared<WalkerNavigation>(shared_from_this());\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 28.352727568207065}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t (_walker_navigation == nullptr) {\n\t\t_walker_navigation = std::make_shared<WalkerNavigation>(_client, _actors, _state);\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 27.987327032444902}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\td::shared_ptr<WalkerNavigation> navigation;\n\twhile (!navigation) {\n\t\tnavigation = _walker_navigation.lock();\n\t\tif (!navigation) {\n\t\t\tnavigation = std::make_shared<WalkerNavigation>(_client, _actors, _state->GetMap());\n\t\t\tif (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n\t\t\t\tnavigation.reset();\n\t\t\t}\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 45.75384508843438}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t#if CARLA_USE_TRAFFIC_MANAGER\n  if (episode.GetTrafficManager()) {\n    episode.GetTrafficManager()->Tick();\n  }\n#endif\n\n  while (episode.GetCurrentFrame() < frame) {\n    if (timeout.is_zero()) {\n      return false;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    timeout -= std::chrono::milliseconds(10);\n  }\n\n  return true;\n}", "CodeBleu_score": 32.28819609914832}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t", "CodeBleu_score": 2.6018891845533507}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t", "CodeBleu_score": 2.6018891845533507}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n * The function Simulator::LoadEpisode loads a new episode with a specified map name, reset settings, and map layers.\nIt attempts to connect to the new episode within a certain timeout period, checking repeatedly if the episode ID has changed.\nIf the new episode is successfully loaded, it returns the episode object.\nIf it fails to connect within the allowed attempts, it throws a runtime exception.\n */\n  auto episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  if (episode.IsConnected()) {\n    return EpisodeProxy(std::move(episode), _gc_policy, _light_manager.get());\n  } else {\n    throw std::runtime_error(\"Unable to connect to the new episode.\");\n  }\n}", "CodeBleu_score": 44.97810004799821}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t*\n * The function Simulator::LoadEpisode loads a new episode with a specified map name, reset settings, and map layers.\nIt attempts to connect to the new episode within a certain timeout period, checking repeatedly if the episode ID has changed.\nIf the new episode is successfully loaded, it returns the episode object.\nIf it fails to connect within the allowed attempts, it throws a runtime exception.\n */\n  auto start = std::chrono::system_clock::now();\n  EpisodeProxy episode;\n  while (true) {\n    try {\n      episode = EpisodeProxy(_client.LoadEpisode(map_name, reset_settings, map_layers));\n      break;\n    } catch (const rpc::Exception &e) {\n      if (e.error_code == rpc::ErrorCode::EpisodeIdChanged) {\n        continue;\n      } else {\n        throw e;\n      }\n    }\n    auto end = std::chrono::system_clock::now();\n    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n    if(time_duration(10000) < diff) {\n      throw TimeoutException();\n    }\n  }\n  return episode;\n}", "CodeBleu_score": 42.79317319790952}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n * The function Simulator::LoadEpisode loads a new episode with a specified map name, reset settings, and map layers.\nIt attempts to connect to the new episode within a certain timeout period, checking repeatedly if the episode ID has changed.\nIf the new episode is successfully loaded, it returns the episode object.\nIf it fails to connect within the allowed attempts, it throws a runtime exception.\n */\n  if(map_name.empty()) {\n    throw std::runtime_error(\"Map name cannot be empty\");\n  }\n  if(map_layers.layers.size() > 12) {\n    throw std::runtime_error(\"Map layers cannot be more than 12\");\n  }\n  rpc::EpisodeId episode_id;\n  rpc::EpisodeResetSettings reset_settings_rpc;\n  reset_settings_rpc.reset_settings = reset_settings;\n  reset_settings_rpc.map_name = map_name;\n  reset_settings_rpc.map_layers = map_layers;\n  for (uint32_t i = 0; i < 10; ++i) {\n    try {\n      episode_id = _client.LoadEpisode(reset_settings_rpc);\n      break;\n    } catch (const TimeoutException &e) {\n      log_debug(e.what());\n    }\n  }\n  if (episode_id.id == 0) {\n    throw std::runtime_error(\"Episode ID is 0\");\n  }\n  return EpisodeProxy(_client, episode_id);\n}", "CodeBleu_score": 42.16134282676683}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode!= nullptr);\nDEBUG_ASSERT(controller.GetWalkerId()!= 0);\nDEBUG_ASSERT(controller.GetControllerId()!= 0);\n\nauto nav = _episode->CreateNavigationIfMissing();\n\nauto walker = _episode->GetWalker(controller.GetWalkerId());\nif (!walker) {\nthrow_exception(std::runtime_error(\"cannot find walker with id: \" + std::to_string(controller.GetWalkerId())));\n}\nnav->RegisterController(controller);\n}", "CodeBleu_score": 60.64516396024071}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t/*\n * This function, Simulator::RegisterAIController, registers an AI controller with a walker in the simulation.\nIt retrieves the walker associated with the controller and throws an exception if the walker is not found.\nIt asserts that the episode is not null, creates navigation if it is missing, and registers the walker with the controller's ID.\n */\n  DEBUG_ASSERT(_episode!= nullptr);\n  auto walker = _episode->GetWalker(controller.GetWalkerId());\n  if (!walker) {\n    throw_exception(std::runtime_error(\"failed to register AI controller: walker not found\"));\n  }\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterController(controller);\n}", "CodeBleu_score": 63.10984380065152}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tDEBUG_ASSERT(_episode!= nullptr);\nauto nav = _episode->CreateNavigationIfMissing();\nauto walker = nav->GetWalker(controller.GetWalkerId());\nif (walker == nullptr) {\nthrow_exception(std::runtime_error(\n\"AI controller tried to register with a walker that does not exist.\"));\n}\nnav->RegisterController(controller);\n}", "CodeBleu_score": 64.54062836198543}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t/*\n * This function, Simulator::SpawnActor, spawns an actor in the simulation using a specified blueprint and transform.\nIf a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\nOtherwise, it spawns the actor independently.\nThe function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\nFinally, it returns a shared pointer to the newly created actor.\n */\n  DEBUG_ASSERT(_episode!= nullptr);\n  DEBUG_ASSERT(_episode->IsRunning());\n  DEBUG_ASSERT(_episode->IsPaused() == false);\n  DEBUG_ASSERT(_episode->IsFrozen() == false);\n\n  // get actor definition\n  const auto &def = blueprint.GetDefinition();\n\n  // get actor id\n  const auto id = _client.SendSpawnActor(def, transform, parent, attachment_type, socket_name);\n\n  // create actor\n  auto actor = MakeActor(id, def, transform, parent, attachment_type, socket_name);\n\n  // register actor\n  _episode->RegisterActor(actor, gc);\n\n  // log creation details\n  log_info(\n      \"Spawned actor: {} (type: {}, id: {})\",\n      actor->GetDisplayId(),\n      def.name,\n      id);\n\n  return actor;\n}", "CodeBleu_score": 50.679222682396265}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// spawn actor\n\tconst auto actor = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n\t// register actor\n\t_episode->RegisterActor(actor, gc);\n\n\t// log actor creation\n\tlog_debug(\"Spawned actor '{}' with id {}.\", actor->GetDisplayId(), actor->GetId());\n\n\treturn actor;\n}", "CodeBleu_score": 31.778389531084244}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n/*\n * The function, Simulator::SpawnActor, spawns an actor in the simulation using a specified blueprint and transform.\nIf a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\nOtherwise, it spawns the actor independently.\nThe function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\nFinally, it returns a shared pointer to the newly created actor.\n */\n  // spawn actor in the simulation\n  auto actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  // register actor in the garbage collection policy\n  gc.RegisterActor(actor);\n\n  // log actor creation details\n  log_info(\n      \"Actor created: \" + actor->GetDisplayId() + \" (blueprint: \" + blueprint.id + \")\");\n\n  // return the actor\n  return actor;\n}", "CodeBleu_score": 32.51224136267147}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = _uid;\ndescription.id = _id;\ndescription.attributes.reserve(_attributes.size());\nfor (const auto &attribute : _attributes) {\ndescription.attributes.emplace_back(attribute.second.MakeAttributeDescription());\n}\nreturn description;\n}", "CodeBleu_score": 82.5900873977085}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = _uid;\ndescription.id = _id;\ndescription.attributes.reserve(_attributes.size());\nfor (auto &attribute : _attributes) {\ndescription.attributes.emplace_back(attribute.second.MakeAttributeDescription());\n}\nreturn description;\n}", "CodeBleu_score": 77.80961853783778}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = _uid;\n\tdescription.id = _id;\n\tdescription.attributes.reserve(_attributes.size());\n\tfor (const auto &attribute : _attributes) {\n\t\tdescription.attributes.emplace_back(attribute.second.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 82.00326652081445}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t", "CodeBleu_score": 7.837249333138888}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t", "CodeBleu_score": 7.837249333138888}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\nfor (auto &pair : _blueprints) {\nif (pair.second.HasAttribute(name)) {\nauto attribute = pair.second.GetAttribute(name);\nif (attribute.type == rpc::Attribute::Type::String) {\nif (attribute.string_value == value) {\nresult.emplace(pair);\n}\n} else if (attribute.type == rpc::Attribute::Type::Float) {\nif (attribute.float_value == value) {\nresult.emplace(pair);\n}\n} else if (attribute.type == rpc::Attribute::Type::Int) {\nif (attribute.int_value == value) {\nresult.emplace(pair);\n}\n} else if (attribute.type == rpc::Attribute::Type::Bool) {\nif (attribute.bool_value == value) {\nresult.emplace(pair);\n}\n}\n}\n}\nreturn SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}", "CodeBleu_score": 54.117442621735876}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tifdef _WIN32\n  // Check if the path ends in a slash, add it otherwise\n  if (path[path.size() - 1]!= '\\\\') {\n    path += '\\\\';\n  }\n#else\n  // Check if the path ends in a slash, add it otherwise\n  if (path[path.size() - 1]!= '/') {\n    path += '/';\n  }\n#endif\n\n  // Construct the full file path using a base folder and version information\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Validate the file path\n  if (fullpath.empty()) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::binary);\n\n  // Check if the file was successfully opened\n  if (file.is_open()) {\n    // Write the content to the file\n    file.write(reinterpret_cast<char *>(content.data()), content.size());\n\n    // Close the file\n    file.close();\n\n    // Return true if the file was successfully written\n    return true;\n  }\n\n  // Return false if the file could not be opened\n  return false;\n}", "CodeBleu_score": 50.1327427812574}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tifdef _WIN32\n\tstd::string fullpath = std::string(getenv(\"USERPROFILE\")) + \"/carlaCache/\" + ::carla::version() + \"/\" + path;\n#else\n\tstd::string fullpath = std::string(getenv(\"HOME\")) + \"/carlaCache/\" + ::carla::version() + \"/\" + path;\n#endif\n\n\t// Check if the path ends in a slash, add it otherwise\n\tif (path[path.size() - 1]!= '/' && path[path.size() - 1]!= '\\\\') {\n\t\tfullpath += \"/\";\n\t}\n\n\t// Check if the file already exists\n\tstruct stat buffer;\n\tif (stat(fullpath.c_str(), &buffer) == 0) {\n\t\treturn false;\n\t}\n\n\t// Create the directory if it does not exist\n\tstd::string dir = fullpath.substr(0, fullpath.find_last_of('/'));\n\tif (mkdir(dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH)!= 0) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(fullpath, std::ios::binary);\n\tif (!file) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file and close it\n\tfile.write((char*)content.data(), content.size());\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 47.27043590429647}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t/ Check if the path is valid\nif (path.empty()) return false;\n\n// Check if the file exists or not\nstruct stat buffer;\nstd::string fullpath = _filesBaseFolder;\nfullpath += \"/\";\nfullpath += ::carla::version();\nfullpath += \"/\";\nfullpath += path;\n\nif (stat(fullpath.c_str(), &buffer) == 0) {\nreturn false;\n}\n\n// Create the directory if it doesn't exist\nstd::string dir = fullpath.substr(0, fullpath.find_last_of('/'));\nif (mkdir(dir.c_str(), 0755) == -1) {\nreturn false;\n}\n\n// Open the file in binary mode to truncate its contents\nstd::ofstream file(fullpath, std::ios::binary);\n\nif (!file.is_open()) {\nreturn false;\n}\n\n// Write the content and close the file\nfile.write(reinterpret_cast<const char *>(content.data()), content.size());\nfile.close();\n\nreturn true;\n}", "CodeBleu_score": 42.926899622054236}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t/*\n * The parent's bounding box location is added to the transform's location.\n */\n  const auto location = Rotate(transform.rotation.yaw, transform.location + _parent_bounding_box.location);\n\n/*\n * The extents are rotated based on the yaw angle.\n */\n  const auto extents = Rotate(transform.rotation.yaw, _parent_bounding_box.extents);\n\n/*\n * The four corners are calculated by adding the location to the extents.\n */\n  const auto corners = std::array<geom::Location, 4u>{{\n      location + geom::Location(extents.x, extents.y),\n      location + geom::Location(extents.x, -extents.y),\n      location + geom::Location(-extents.x, -extents.y),\n      location + geom::Location(-extents.x, extents.y)}};\n\n/*\n * The Bounds object is created and returned.\n */\n  return std::make_shared<const Bounds>(Bounds{frame, corners});\n}", "CodeBleu_score": 49.03077322353202}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Query the current state of the lights from the server\nauto lights_state = _client.QueryLightsState();\n\n// Update the local light states\nfor (auto &light_state : lights_state) {\nauto light_id = light_state.first;\nauto light_state = light_state.second;\n\n// Check if the light exists in the local _lights map\nauto it_light = _lights.find(light_id);\nif (it_light == _lights.end()) {\n// Create a new light object if it does not already exist\nLight light;\nlight._id = light_id;\nlight._name = light_state.name;\nlight._type = light_state.type;\nlight._group = light_state.group;\nlight._color = light_state.color;\nlight._intensity = light_state.intensity;\nlight._active = light_state.active;\n\n// Add the new light object to the _lights map\n_lights[light_id] = light;\n} else {\n// Update the existing light object with the new state\nit_light->second._color = light_state.color;\nit_light->second._intensity = light_state.intensity;\nit_light->second._active = light_state.active;\n}\n}\n\n// Update the local _lights_state map with the new light states\n_lights_state = lights_state;\n}", "CodeBleu_score": 36.892520164499444}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n// Query the light states from the server\nstd::vector<LightState> server_lights_state;\nif (!_server.QueryLightsState(server_lights_state)) {\ncarla::log_error(\\\"Failed to query lights state from server\\\");\nreturn;\n}\n\n// Update the local light states\nfor (const LightState& server_light_state : server_lights_state) {\nauto it = _lights_state.find(server_light_state._id);\nif (it == _lights_state.end()) {\n// Create a new light object if it does not exist\nLight light;\nlight._id = server_light_state._id;\nlight._name = server_light_state._name;\nlight._position = server_light_state._position;\nlight._color = server_light_state._color;\nlight._intensity = server_light_state._intensity;\nlight._group = server_light_state._group;\nlight._active = server_light_state._active;\n_lights.insert(std::make_pair(light._id, light));\n}\n\n// Update the local light state\nLightState& local_light_state = it->second;\nlocal_light_state._position = server_light_state._position;\nlocal_light_state._color = server_light_state._color;\nlocal_light_state._intensity = server_light_state._intensity;\nlocal_light_state._group = server_light_state._group;\nlocal_light_state._active = server_light_state._active;\n}\n\n// Remove lights that are no longer present in the server\nfor (auto it = _lights_state.begin(); it!= _lights_state.end();) {\nif (std::find(server_lights_state.begin(), server_lights_state.end(), it->second) == server_lights_state.end()) {\nit = _lights_state.erase(it);\n} else {\n++it;\n}\n}\n\n_dirty = true;\n}", "CodeBleu_score": 41.823104747406724}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t", "CodeBleu_score": 0.895904958250783}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t", "CodeBleu_score": 1.4421612766169787}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif(_dirty) {\n// Create a message with the updated light states\nrpc::EpisodeMessage episode_message;\nepisode_message._type = rpc::EpisodeMessage::Type::LIGHTS_STATE_UPDATE;\nepisode_message._lights_state_update.reserve(_lights_changes.size());\nfor(const auto& it : _lights_changes) {\nepisode_message._lights_state_update.push_back(it.second);\n}\n\n// Send the message to the server\n_episode.Lock()->SendEpisodeMessage(episode_message, discard_client);\n\n// Clear the changes and reset the dirty flag\n_lights_changes.clear();\n_dirty = false;\n}\n}", "CodeBleu_score": 42.00606064888341}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nif (!_dirty) {\nreturn;\n}\n\n// Create message\nrpc::Episode::LightStateUpdate update;\n\n// Add changes\nfor (auto& it : _lights_changes) {\nupdate.light_states.push_back(it.second);\n}\n\n// Clear changes\n_lights_changes.clear();\n\n// Send message\n_episode.Lock()->SendLightStateUpdateToServer(update, discard_client);\n\n// Reset dirty flag\n_dirty = false;\n}", "CodeBleu_score": 34.24272992750405}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\n\t\t\t\"attempting to send a message to a sensor that is not a v2x_custom sensor:\",\n\t\t\tGetDisplayId());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->SendMessageToSensor(*this, message);\n}", "CodeBleu_score": 66.3430757895449}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\tif (GetEpisode().IsValid()) {\n\t\tif (GetSensorId() == \"sensor.other.v2x_custom\") {\n\t\t\tGetEpisode().Lock()->Send(GetSensorId(), message);\n\t\t} else {\n\t\t\tlog_warning(\"attempting to send a message to sensor that is not v2x_custom: \", GetDisplayId());\n\t\t}\n\t} else {\n\t\tlog_warning(\"attempting to send a message to sensor that is not in a valid episode: \", GetDisplayId());\n\t}\n}", "CodeBleu_score": 57.969296350021395}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (GetDisplayId() == \"sensor.other.v2x_custom\") {\n\t\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n\t\tGetEpisode().Lock()->SendToSensor(*this, std::move(message));\n\t} else {\n\t\tlog_warning(\"attempting to send message to sensor but sensor ID is not \\\"sensor.other.v2x_custom\\\":\", GetDisplayId());\n\t}\n}", "CodeBleu_score": 61.87956602444552}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\n/*\n * This function, Vehicle::SetAutopilot, enables or disables the autopilot for a vehicle.\nIt takes a boolean flag and a traffic manager port number as parameters.\nIf the flag is true, it registers the vehicle with the traffic manager.\nIf the flag is false, it unregisters the vehicle from the traffic manager.\n */\nvoid Vehicle::SetAutopilot(bool enabled, uint16_t tm_port) {\n  if (enabled) {\n    _tm_port = tm_port;\n    _tm_id = TM::RegisterVehicle(*this);\n  } else {\n    _tm_id = TM::UnregisterVehicle(*this);\n    _tm_port = 0;\n  }\n}\n\n/*\n * This function, Vehicle::ApplyControl, applies a control to the vehicle.\nIt takes a control as a parameter.\nIt sends the control to the simulator.\n */\nvoid Vehicle::ApplyControl(const carla::rpc::VehicleControl &control) {\n  if (_is_control_sticky) {\n    _control = control;\n  }\n  _simulator->ApplyControlToVehicle(*this, control);\n}\n\n/*\n * This function, Vehicle::GetControl, returns the control of the vehicle.\nIt returns the control of the vehicle as a rpc::VehicleControl.\n */\nrpc::VehicleControl Vehicle::GetControl() const {\n  return _control;\n}\n\n/*\n * This function, Vehicle::GetAutopilot, returns the autopilot status of the vehicle.\nIt returns a boolean value, true if the vehicle has an autopilot enabled, false otherwise.\n */\nbool Vehicle::GetAutopilot() const {\n  return _tm_port!= 0;\n}\n\n/*\n * This function, Vehicle::GetAutopilotPort, returns the traffic manager port number of the vehicle.\nIt returns the traffic manager port number of the vehicle as an integer.\n */\nuint16_t Vehicle::GetAutopilotPort() const {\n  return _tm_port;\n}\n\n/*\n * This function, Vehicle::GetTMId, returns the traffic manager id of the vehicle.\nIt returns the traffic manager id of the vehicle as an integer.\n */\nuint16_t Vehicle::GetTMId() const {\n  return _tm_id;\n}\n\n}", "CodeBleu_score": 39.30616635651784}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\n/*\n * This function, Vehicle::SetAutopilot, enables or disables the autopilot for a vehicle.\nIt takes a boolean flag and a traffic manager port number as parameters.\nIf the flag is true, it registers the vehicle with the traffic manager.\nIf the flag is false, it unregisters the vehicle from the traffic manager.\n */\n  if (enabled) {\n    _tm_port = tm_port;\n    _tm_client.reset(new TM::Client(_simulator->GetClient(), _tm_port));\n    _tm_client->Register(_id);\n  } else {\n    _tm_port = 0;\n    _tm_client.reset();\n  }\n}", "CodeBleu_score": 42.19840593115664}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t", "CodeBleu_score": 1.0949963018106907}, {"code": "void WalkerAIController::Start(){\n\t", "CodeBleu_score": 1.0949963018106907}, {"code": "void WalkerAIController::Start(){\n\t", "CodeBleu_score": 1.0949963018106907}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tv = GetEpisode().Lock()->GetNavigation();\nif (nav!= nullptr) {\nauto walker = GetParent();\nif (walker!= nullptr) {\nif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\nlog_warning(\"NAV: Failed to set max speed for walker \", walker->GetId());\n}\n} else {\nlog_warning(\"NAV: Failed to set max speed for walker \", walker->GetId(), \" (parent does not exist)\");\n}\n}\n}", "CodeBleu_score": 71.64530474644448}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tv = GetEpisode().Lock()->GetNavigation();\nif (nav!= nullptr) {\nauto walker = GetParent();\nif (walker!= nullptr) {\nif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\nlog_warning(\"NAV: Failed to set max speed to \", max_speed);\n}\n} else {\nlog_warning(\"NAV: Failed to set max speed to \", max_speed, \"(parent does not exist)\");\n}\n}\n}", "CodeBleu_score": 71.13867002159436}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tv = GetEpisode().Lock()->GetNavigation();\nif (nav!= nullptr) {\nauto walker = GetParent();\nif (walker!= nullptr) {\nif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\nlog_warning(\"NAV: Failed to set maximum speed to \", max_speed);\n}\n} else {\nlog_warning(\"NAV: Failed to set maximum speed to \", max_speed, \"(parent does not exist)\");\n}\n}\n}", "CodeBleu_score": 69.77140629785508}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\nstd::vector<SharedPtr<Waypoint>> result;\nresult.reserve(waypoints.size());\nfor (auto &waypoint : waypoints) {\nresult.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n}\nreturn result;\n}", "CodeBleu_score": 97.71553977270096}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t", "CodeBleu_score": 7.227538970210187}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::vector<std::pair<std::string, std::string>> signals = GetSignalsInDistance(distance, stop_at_junction);\nstd::set<std::string> unique_signals;\nfor (auto signal : signals) {\n  if (unique_signals.find(signal.first) == unique_signals.end()) {\n    unique_signals.insert(signal.first);\n    SharedPtr<Waypoint> signal_waypoint = _parent->GetMap().GetWaypoint(signal.second);\n    if (signal_waypoint!= nullptr) {\n      result.emplace_back(new Landmark(signal_waypoint));\n    }\n  }\n}\nreturn result;\n}", "CodeBleu_score": 50.06996624446369}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t", "CodeBleu_score": 7.227538970210187}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\treturn _episode.Lock()->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 13.739492062031477}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\treturn _episode.Lock()->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 13.739492062031477}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst Vector2D &a, const Vector2D &b, const Vector2D &p\n}", "CodeBleu_score": 10.73905967875109}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tf (vertices.size() == 0) {\n\t\treturn;\n\t}\n\tDEBUG_ASSERT(vertices.size() >= 3);\n\tsize_t i = GetVerticesNum() + 1;\n\tAddVertices(vertices);\n\tAddIndex(i);\n\twhile (i < GetVerticesNum()) {\n\t\tAddIndex(i);\n\t\tAddIndex(i + 1);\n\t\tAddIndex(i + 2);\n\t\ti += 2;\n\t}\n}", "CodeBleu_score": 65.07781986592191}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t", "CodeBleu_score": 5.712762733113359}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tf (vertices.size() == 0) {\n return;\n }\n DEBUG_ASSERT(vertices.size() >= 3);\n size_t i = GetVerticesNum() + 1;\n AddVertices(vertices);\n AddIndex(i);\n while (i < GetVerticesNum()) {\n AddIndex(i);\n AddIndex(i + 1);\n AddIndex(i + 2);\n i += 2;\n }\n }", "CodeBleu_score": 66.55618927210683}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t#if!defined(CARLA_NO_LOGGING)\n  if (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::Request) {\n    LOG_DEBUG(\"Primary::Write: sending message to server (session %i)\", _session_id);\n  } else {\n    LOG_DEBUG(\"Primary::Write: sending message to server (session %i)\", _session_id);\n  }\n#endif\n\n  // check if the message is valid\n  if (!message->IsValid()) {\n    LOG_ERROR(\"Primary::Write: message is invalid\");\n    return;\n  }\n\n  // check if the socket is open\n  if (!_socket.is_open()) {\n    LOG_ERROR(\"Primary::Write: socket is not open\");\n    return;\n  }\n\n  // set the deadline\n  _deadline.expires_at(boost::asio::deadline_timer::traits_type::now() + _timeout);\n\n  // post a lambda function to the strand\n  _strand.post([this, message]() {\n    // check if the socket is open\n    if (!_socket.is_open()) {\n      LOG_ERROR(\"Primary::Write: socket is not open\");\n      return;\n    }\n\n    // set the deadline\n    _deadline.expires_at(boost::asio::deadline_timer::traits_type::now() + _timeout);\n\n    // initiate an asynchronous write\n    boost::asio::async_write(_socket, message->GetBuffer(), boost::asio::bind_executor(_strand, [this, message](const boost::system::error_code &ec, std::size_t length) {\n      handle_sent(ec, length, message);\n    }));\n  });\n}", "CodeBleu_score": 39.08310848750054}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t#if CARLA_MULTIGPU_DEBUG_MESSAGES\n  std::string message_str = message->ToString();\n  std::cout << \"Primary::Write: \" << message_str << std::endl;\n#endif\n  if (!message->IsValid()) {\n    std::cout << \"Primary::Write: message is not valid\" << std::endl;\n    return;\n  }\n\n  // The write operation needs to be executed in the strand, so we post a lambda to the strand.\n  // The lambda is responsible for checking if the socket is open, setting a timeout, and initiating the write operation.\n  // The handle_sent lambda is responsible for handling the result, logging errors, and closing the connection if needed.\n  boost::asio::post(_strand, [this, message = std::move(message)]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n\n    _deadline.expires_from_now(_timeout);\n\n    boost::asio::async_write(_socket, boost::asio::buffer(message->GetBuffer(), message->GetBuffer().size()),\n                             boost::asio::bind_executor(_strand, [this, message = std::move(message)](auto ec, auto) {\n                               if (ec) {\n                                 std::cout << \"Primary::Write: error sending message: \" << ec.message() << std::endl;\n                                 return;\n                               }\n\n                               _deadline.expires_from_now(_timeout);\n                             }));\n  });\n}", "CodeBleu_score": 41.11317161496757}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t", "CodeBleu_score": 3.648604678563731}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (_deadline.expires_at() <= boost::asio::deadline_timer::traits_type::now()) {\nlog_debug(\\\"session \\\", _session_id, \\\" time out\\\");\n}\n_deadline.cancel();\nif (!_socket.is_open()) {\nreturn;\n}\nif (!ec) {\nboost::system::error_code shutdown_ec;\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, shutdown_ec);\nif (shutdown_ec) {\nlog_error(\\\"session \\\", _session_id, \\\": error shutting down socket: \\\", shutdown_ec.message());\n}\n}\n_socket.close();\n_on_closed(shared_from_this());\nlog_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 48.93566692627651}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (_deadline.expires_at() <= boost::asio::deadline_timer::traits_type::now()) {\nlog_debug(\"session \", _session_id, \" time out\");\n} else {\n_deadline.cancel();\n}\nif (!_socket.is_open()) {\nreturn;\n}\nif (!ec) {\nboost::system::error_code shutdown_ec;\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, shutdown_ec);\nif (shutdown_ec) {\nlog_error(\"session \", _session_id, \": error shutting down socket: \", shutdown_ec.message());\n}\n}\n_socket.close(ec);\nif (ec) {\nlog_error(\"session \", _session_id, \": error closing socket: \", ec.message());\n}\nif (_on_closed) {\n_on_closed(shared_from_this());\n}\nlog_debug(\"session \", _session_id, \" closed\");\n}", "CodeBleu_score": 51.71936221407806}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t#if defined(LIBCARLA_OS_WINDOWS)\n  // Windows needs to be told to shutdown the socket before closing it.\n  if (_socket.is_open()) {\n    boost::system::error_code ec2;\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec2);\n    _socket.close(ec2);\n  }\n#endif\n\n  _deadline.cancel();\n\n  if (_socket.is_open()) {\n    _socket.close();\n  }\n\n  _on_closed(shared_from_this(), ec);\n\n  log_debug(\\\"session \\\", _session_id, \\\" closed\\\");\n}", "CodeBleu_score": 63.766044184768965}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\n#ifdef CARLA_MULTIGPU_DEBUG\n  log_info(\"sending alive command\");\n#endif\n\n  carla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", 15);\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"response: \", response.buffer.data());\n}", "CodeBleu_score": 63.78948418021994}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tlog_info(\"sending alive command\");\n\tcarla::Buffer buf((unsigned char *) \"Are you alive?\", 14);\n\tauto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n\tauto response = fut.get();\n\tlog_info(\"got response: \", response.buffer.data());\n}", "CodeBleu_score": 65.31202439264632}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\n// create a buffer from the message\n  carla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", 15);\n\n// log the sending action\n  log_info(\"sending is alive message\");\n\n// write the buffer to the next router with the command YOU_ALIVE\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n// wait for and log the response from the system\n  auto response = fut.get();\n  log_info(\"got response: \", response.buffer.data());\n}", "CodeBleu_score": 63.638031884009585}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\ncarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\nauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\nauto response = fut.get();\nlog_info(\"got a token: \", response.buffer.data());\n}", "CodeBleu_score": 48.49831330346236}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t", "CodeBleu_score": 2.115550583146295}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\ncarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\nauto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\nauto response = fut.get();\nlog_info(\"got a token: \", response.buffer.data());\n}", "CodeBleu_score": 48.49831330346236}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tsearch if the sensor has been activated in any secondary server\nauto it = _servers.find(sensor_id);\nif (it!= _servers.end()) {\n// the sensor has been activated, return the existing token\ntoken_type token(it->second, sensor_id);\nlog_info(\"found sensor \", sensor_id, \" on server \", it->second);\nreturn token;\n}\n// the sensor has not been activated, enable it\nlog_info(\"enabling sensor \", sensor_id, \" on server \", _router->get_server_id());\nEnableForROS(sensor_id);\n// get the new token\ntoken_type new_token = SendGetToken(sensor_id);\n// update the maps\n_servers[sensor_id] = _router->get_server_id();\n_sensors[_router->get_server_id()] = sensor_id;\nreturn new_token;\n}", "CodeBleu_score": 50.70708970352802}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tsearch if the sensor has been activated in any secondary server\nauto it = _servers.find(sensor_id);\nif (it!= _servers.end()) {\nlog_info(\"sensor already activated\");\nreturn _tokens[sensor_id];\n} else {\nlog_info(\"enabling sensor\");\nEnableForROS(sensor_id);\nreturn GetToken(sensor_id);\n}\n}", "CodeBleu_score": 37.37406004116177}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t_info(\"asking for a token\");\ncarla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\nauto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\nauto response = fut.get();\ntoken_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\nlog_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\nreturn new_token;\n}", "CodeBleu_score": 35.5831494205433}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\n/*\n * This function, Navigation::Load, loads a file specified by the filename.\nIt opens the file in binary mode and reads its entire content into a vector.\nIf the file cannot be opened, it returns false.\nAfter reading, it closes the file and parses the content by calling another Load function with the file data.\n */\n  std::ifstream file(filename, std::ios::binary | std::ios::ate);\n  if (!file.is_open()) {\n    log_error(\"Failed to open file: {}\", filename);\n    return false;\n  }\n\n  const std::streamsize size = file.tellg();\n  file.seekg(0, std::ios::beg);\n\n  std::vector<char> buffer(size);\n  if (!file.read(buffer.data(), size)) {\n    log_error(\"Failed to read file: {}\", filename);\n    return false;\n  }\n\n  file.close();\n\n  return Load(buffer);\n}", "CodeBleu_score": 53.70337363972574}, {"code": "bool Navigation::Load(const std::string &filename){\n\t#if defined(CARLA_USE_NAVIGATION_PRECOMPILED)\n  // TODO: Implement this function\n  log_error(\"Load function not implemented yet\");\n  return false;\n#else\n  std::ifstream file(filename, std::ios::binary | std::ios::ate);\n  if (!file.is_open()) {\n    log_error(\"Could not open file: {}\", filename);\n    return false;\n  }\n\n  size_t size = file.tellg();\n  std::vector<char> buffer(size);\n  file.seekg(0, std::ios::beg);\n  file.read(buffer.data(), size);\n  file.close();\n\n  return Load(buffer);\n#endif\n}", "CodeBleu_score": 47.75228643622455}, {"code": "bool Navigation::Load(const std::string &filename){\n\t", "CodeBleu_score": 4.792014253953123}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t", "CodeBleu_score": 1.060187825043224}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tnamespace cg = carla::geom;\nif (!_ready) {\nreturn false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// check if it is a walker\nauto it = _mapped_walkers_id.find(id);\nif (it!= _mapped_walkers_id.end()) {\n// get the index found\nint index = it->second;\nif (index!= -1) {\n// get the agent\ndtCrowdAgent *agent;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nagent = _crowd->getEditableAgent(index);\n}\nif (agent) {\n// remove from crowd\n_crowd->removeAgent(index);\n}\n\n// update the walker manager\n_walker_manager.RemoveWalker(id);\n\n// remove from the mappings\n_mapped_walkers_id.erase(it);\n_mapped_by_index.erase(index);\n_yaw_walkers.erase(id);\n}\n}\n\n// check if it is a vehicle\nit = _mapped_vehicles_id.find(id);\nif (it!= _mapped_vehicles_id.end()) {\n// get the index found\nint index = it->second;\nif (index!= -1) {\n// get the agent\ndtCrowdAgent *agent;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nagent = _crowd->getEditableAgent(index);\n}\nif (agent) {\n// remove from crowd\n_crowd->removeAgent(index);\n}\n\n// remove from the mappings\n_mapped_vehicles_id.erase(it);\n_mapped_by_index.erase(index);\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 66.59539642310004}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tnamespace cg = carla::geom;\n\n// check if all is ready\nif (!_ready) {\nreturn false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// check if this actor exists\nauto it = _mapped_walkers_id.find(id);\nif (it!= _mapped_walkers_id.end()) {\n// get the index found\nint index = it->second;\nif (index!= -1) {\n// remove the agent from the crowd\nint result;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nresult = _crowd->removeAgent(index);\n}\nif (result == 0) {\n// mark as invalid\ndtCrowdAgent *agent = _crowd->getEditableAgent(index);\nif (agent) {\nagent->state = DT_CROWDAGENT_STATE_INVALID;\n}\n// remove from the walker manager\n_walker_manager.RemoveWalker(id);\n// remove from the mappings\n_mapped_walkers_id.erase(it);\n_mapped_by_index.erase(index);\nreturn true;\n}\n}\n}\n\n// check if this actor exists\nit = _mapped_vehicles_id.find(id);\nif (it!= _mapped_vehicles_id.end()) {\n// get the index found\nint index = it->second;\nif (index!= -1) {\n// remove the agent from the crowd\nint result;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nresult = _crowd->removeAgent(index);\n}\nif (result == 0) {\n// remove from the mappings\n_mapped_vehicles_id.erase(it);\n_mapped_by_index.erase(index);\nreturn true;\n}\n}\n}\n\nreturn false;\n}", "CodeBleu_score": 67.87277283808845}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n// check if all is ready\nif (!_ready) {\nreturn false;\n}\n\n// get the IDs of currently mapped vehicles\nstd::set<ActorId> current_vehicles_ids;\nfor (auto &it : _mapped_vehicles_id) {\ncurrent_vehicles_ids.insert(it.first);\n}\n\n// add/update vehicles\nfor (auto &vehicle : vehicles) {\n// check if the vehicle is already mapped\nauto it = _mapped_vehicles_id.find(vehicle.id);\nif (it!= _mapped_vehicles_id.end()) {\n// update the vehicle\nif (!UpdateVehicle(vehicle)) {\n// failed to update vehicle\nlogging::log(\"Failed to update vehicle\");\nreturn false;\n}\n} else {\n// add the vehicle\nif (!AddVehicle(vehicle)) {\n// failed to add vehicle\nlogging::log(\"Failed to add vehicle\");\nreturn false;\n}\n}\n// mark as updated\ncurrent_vehicles_ids.erase(vehicle.id);\n}\n\n// remove vehicles\nfor (auto &it : current_vehicles_ids) {\nif (!RemoveAgent(it)) {\n// failed to remove vehicle\nlogging::log(\"Failed to remove vehicle\");\nreturn false;\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 52.19837848633018}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n// check if all is ready\nif (!_ready) {\nreturn false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// get the ids of currently mapped vehicles\nstd::set<ActorId> current_vehicles_ids;\nfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\ncurrent_vehicles_ids.insert(it->first);\n}\n\n// add/update vehicles\nfor (auto vehicle : vehicles) {\nif (current_vehicles_ids.find(vehicle.id)!= current_vehicles_ids.end()) {\n// update\nUpdateVehicle(vehicle);\ncurrent_vehicles_ids.erase(vehicle.id);\n} else {\n// add\nAddVehicle(vehicle);\n}\n}\n\n// remove vehicles\nfor (auto id : current_vehicles_ids) {\nRemoveAgent(id);\n}\n\nreturn true;\n}", "CodeBleu_score": 48.82778765445885}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n// check if all is ready\nif (!_ready) {\nreturn false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// get the internal index\nauto it = _mapped_walkers_id.find(id);\nif (it == _mapped_walkers_id.end()) {\nreturn false;\n}\n\n// get the index found\nint index = it->second;\nif (index == -1) {\nreturn false;\n}\n\n// get the walker\nconst dtCrowdAgent *agent;\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nagent = _crowd->getAgent(index);\n}\n\nif (!agent->active) {\nreturn false;\n}\n\n// get the squared distance\nfloat distance2 = distance * distance;\n\n// get the direction\nfloat dir[3];\ndir[0] = direction.x;\ndir[1] = direction.y;\ndir[2] = direction.z;\n\n// check if there is a vehicle nearby\n{\n// critical section, force single thread running this\nstd::lock_guard<std::mutex> lock(_mutex);\nreturn _crowd->queryNearestVehicle(agent, dir, distance2)!= nullptr;\n}\n}", "CodeBleu_score": 60.177963955180815}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current point\n\tWalkerEvent &event = info.route[info.currentIndex].event;\n\n\t// create a visitor with the current context\n\tWalkerEventVisitor visitor(id, info, delta);\n\n\t// execute the event\n\tboost::variant2::visit(visitor, event);\n\n\t// return the result\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 48.38399381386833}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tWalkerEvent &event = info.route[info.currentIndex].event;\n\n\t// create a visitor\n\tWalkerEventVisitor visitor(info, delta);\n\n\t// process the event\n\tboost::variant2::visit(visitor, event);\n\n\t// return the result\n\treturn visitor.GetResult();\n}", "CodeBleu_score": 48.39846697770286}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n// get the current event\nWalkerEvent &event = info.route[info.currentIndex].event;\n\n// create a visitor\nWalkerEventVisitor visitor(id, _simulator, info, delta);\n\n// execute the event\nboost::apply_visitor(visitor, event);\n\n// return the result\nreturn visitor.GetResult();\n}", "CodeBleu_score": 45.350331910906135}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t#ifdef DEBUG_MAP_PARSER\n  std::cout << \"LaneParser::Parse\" << std::endl;\n#endif\n\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\\\"map\\\").children(\\\"road\\\")) {\n    // Get road ID\n    const int road_id = road_node.attribute(\\\"id\\\").as_int();\n    // Create road\n    carla::road::Road *road = map_builder.CreateRoad(road_id);\n    // Process each lane section within the lanes node\n    for (pugi::xml_node lane_node : road_node.child(\\\"lanes\\\").children(\\\"lane\\\")) {\n      // Get lane section ID\n      const int lane_id = lane_node.attribute(\\\"id\\\").as_int();\n      // Get lane section type\n      const std::string lane_type = lane_node.attribute(\\\"type\\\").value();\n      // Get lane section s offset\n      const double s_offset = lane_node.attribute(\\\"sOffset\\\").as_double();\n      // Create lane section\n      carla::road::Lane *lane = map_builder.CreateLane(road, lane_id, lane_type, s_offset);\n      // Parse left lane\n      ParseLanes(lane_node.child(\\\"left\\\"), lane, s_offset, true);\n      // Parse center lane\n      ParseLanes(lane_node.child(\\\"center\\\"), lane, s_offset, false);\n      // Parse right lane\n      ParseLanes(lane_node.child(\\\"right\\\"), lane, s_offset, false);\n    }\n  }\n}", "CodeBleu_score": 43.54590222847193}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\n  for (pugi::xml_node road_node : xml.children(\"map\")) {\n    const int road_id = road_node.attribute(\"id\").as_int();\n\n// Call map builder for Road\n    map_builder.CreateRoad(road_id);\n\n    // Iterate through each lane section\n    for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      const double length = lane_section_node.attribute(\"length\").as_double();\n\n      // Call map builder for LaneSection\n      map_builder.CreateLaneSection(road_id, s, length);\n\n      // Iterate through each lane\n      for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n        const int lane_id = lane_node.attribute(\"id\").as_int();\n        const std::string lane_type = lane_node.attribute(\"type\").value();\n        const double width = lane_node.attribute(\"width\").as_double();\n        const double s_offset = lane_node.attribute(\"sOffset\").as_double();\n        const std::string direction = lane_node.attribute(\"direction\").value();\n        const double speed = lane_node.attribute(\"speed\").as_double();\n\n        // Call map builder for Lane\n        carla::road::Lane *lane = map_builder.CreateLane(road_id, lane_id, lane_type, width, s_offset, direction, speed);\n\n        // Parse Lanes\n        ParseLanes(lane_node, lane, map_builder, s_offset);\n      }\n    }\n  }\n}", "CodeBleu_score": 59.15213601530576}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t#if 0\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\\\"Roads\\\").children(\\\"Road\\\")) {\n    // Extract the road ID\n    const std::string road_id = road_node.attribute(\\\"id\\\").value();\n\n    // Process each lane section within the lanes node\n    for (pugi::xml_node lane_node : road_node.child(\\\"lanes\\\").children(\\\"lane\\\")) {\n      // Retrieve the left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_node.child(\\\"left\\\");\n      pugi::xml_node center_lane_node = lane_node.child(\\\"center\\\");\n      pugi::xml_node right_lane_node = lane_node.child(\\\"right\\\");\n\n      // Parse the lanes\n      ParseLanes(left_lane_node, map_builder);\n      ParseLanes(center_lane_node, map_builder);\n      ParseLanes(right_lane_node, map_builder);\n    }\n  }\n#endif\n}", "CodeBleu_score": 37.58466883287944}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t//  std::cout << \"on_publication_matched: \" << info.current_count << \" \" << info.total_count << std::endl;\n  if (info.current_count_change == 0) {\n    // Invalid count change.\n    std::cerr << \"ERROR: Invalid count change detected. Current count: \" << info.current_count << \" Total count: \" << info.total_count << std::endl;\n  } else {\n    if (info.current_count_change > 0) {\n      // New match.\n      _matched = info.total_count;\n      _first_connected = true;\n    } else {\n      // Match lost.\n      _matched += info.current_count_change;\n    }\n  }\n}", "CodeBleu_score": 71.24012408837558}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n/*\n * If a new match is detected, it sets the matched count and marks the first connection.\n */\n  if (info.current_count_change == 1) {\n    _matched = info.current_count;\n    _first_connected = true;\n    std::cout << \"Connected to \" << _matched << \" carla_ros_bridge nodes.\" << std::endl;\n  }\n\n/*\n * If a match is lost, it updates the matched count.\n */\n  else if (info.current_count_change == -1) {\n    _matched = info.current_count;\n    std::cout << \"Disconnected from \" << _matched << \" carla_ros_bridge nodes.\" << std::endl;\n  }\n\n/*\n * For invalid count changes, it logs an error message.\n */\n  else {\n    std::cerr << \"Error: Invalid count change for publication matched status.\" << std::endl;\n  }\n}", "CodeBleu_score": 66.53729528580823}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\n#if defined(CARLA_PLATFORM_WINDOWS)\n    std::cout << \"CarlaListenerImpl::on_publication_matched\" << std::endl;\n#endif\n\n  if (info.current_count_change == 1) {\n    _matched++;\n    if (!_first_connected) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched--;\n  } else {\n    std::cout << \"CarlaListenerImpl::on_publication_matched: invalid current_count_change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 57.38642832289056}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\n/*\n * The matched_count is updated every time a new subscription is matched or an existing subscription is unmatched.\n * It is used to check if the first subscription was matched.\n */\n_matched = info.total_count;\n\n/*\n * The first_connected flag is set to true if the first subscription is matched.\n * It is used to check if the first subscription is matched, and if the first subscription is matched, it sets the first_connected flag to true.\n */\nif (_matched == 1) {\n_first_connected = true;\n}\n\n/*\n * If the change count is invalid, it logs an error message.\n */\nif (info.current_count < _matched || info.total_count < _matched) {\nstd::cerr << \"Error: invalid subscription matched status: current count \" << info.current_count << \" less than matched count \" << _matched << \" or total count \" << info.total_count << \" was less than matched count \" << _matched << std::endl;\n}\n\n/*\n * If the change count is valid, it destroys the subscriber if there are no remaining matches.\n */\nif (info.current_count == 0) {\nstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: No more matched subscriptions\" << std::endl;\n_owner->destroy_subscriber();\n}\n}", "CodeBleu_score": 60.82919121244004}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t#ifdef FASTDDS_STATISTICS\n  std::cout << \"on_subscription_matched: \" << info.current_count << \" data_available: \" << info.total_count << std::endl;\n#endif\n  if (info.current_count_change == 1) {\n    _matched += info.current_count_change;\n    if (info.current_count == 1) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched += info.current_count_change;\n    if (info.current_count == 0) {\n      _first_connected = false;\n      if (_owner) {\n        _owner->destroy_subscriber();\n      }\n    }\n  } else {\n    std::cerr << \"ERROR: on_subscription_matched: change in status with invalid status: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 63.67346958668707}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\n#if defined(FASTDDS_NEW_API)\n  std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched\" << std::endl;\n#else\n  std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched\" << std::endl;\n#endif\n\n  if (info.current_count_change == 0) {\n    std::cout << \"Error: invalid change count\" << std::endl;\n    return;\n  }\n\n  if (info.current_count_change > 0) {\n    _matched += info.current_count_change;\n    _first_connected = true;\n  } else {\n    _matched += info.current_count_change;\n    if (_matched == 0) {\n      _owner->destroy_subscriber();\n    }\n  }\n}", "CodeBleu_score": 61.24331378584752}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t(!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.reset(new eprosima::fastcdr::CdrMD5());\n\t\tm_md5->update(m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\t\tm_md5->finalize();\n\t\tfor (size_t i = 0; i < m_md5->size(); ++i) {\n\t\t\thandle->value[i] = m_md5->data()[i];\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 78.76637575743344}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE; // Set the correct encapsulation.\n    // Serialize the object.\n    ser.serialize(*p_type);\n    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 67.2574592255465}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS?\n            CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 91.9636501693197}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tifdef FASTCDR_USING_ICU\n    throw \"CarlaEgoVehicleControlPubSubType::serialize() not implemented.\";\n#else\n\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr fastcdr(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = payload->encapsulation == 0? CDR_LE : payload->encapsulation;\n    // Serialize encapsulation\n    if (!fastcdr.serialize_encapsulation()) { // Serialize encapsulation\n        return false;\n    }\n    // Serialize the object.\n    if (!p_type->serialize(fastcdr)) {\n        return false;\n    }\n    // Get the serialized length\n    payload->length = fastbuffer.getSerializedDataLength();\n    return true;\n#endif\n}", "CodeBleu_score": 68.64789065979686}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// return immediately if sysid doesn't match our target sysid\n\tif ((tracker.g.sysid_target!= 0) && (tracker.g.sysid_target!= msg.sysid)) {\n\t\treturn;\n\t}\n\n\t// decode\n\tmavlink_heartbeat_t packet;\n\tmavlink_msg_heartbeat_decode(&msg, &packet);\n\n\t// check if we're tracking this target\n\tif (packet.base_mode & MAV_MODE_FLAG_SAFETY_ARMED) {\n\t\t// if we are tracking this target, exit\n\t\treturn;\n\t}\n\n\t// if the target system ID is not set, set it and request position and air pressure data streams from the target\n\tif (tracker.g.sysid_target == 0) {\n\t\ttracker.g.sysid_target = msg.sysid;\n\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, msg.sysid, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1, 1);\n\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, msg.sysid, MAVLINK_MSG_ID_SCALED_PRESSURE, 1, 1);\n\t}\n\n\t// flag that the target has been set\n\ttracker.g.tracking_target = true;\n}", "CodeBleu_score": 53.44994579890376}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// if the result is MAV_RESULT_ACCEPTED, set a flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\ttracker.g.preflight_calibration_baro = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 62.87004719529212}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\t// if the result is accepted, set the flag\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\ttracker.g.preflight_baro_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 63.28394360309299}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// decode\n\tmavlink_command_long_t packet;\n\tmavlink_msg_command_long_decode(&msg, &packet);\n\n\t// check if this is a preflight calibration command\n\tif (packet.command!= MAV_CMD_PREFLIGHT_CALIBRATION) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\t// if the result is accepted, set a flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\ttracker.altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 59.68850243646951}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 4.769920375128312}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 4.769920375128312}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t#if AP_AHRS_NAVEKF_ENABLED\n    // Check if we are in a position mode\n    if (tracker.ahrs.get_mode() == AHRS::ACRO) {\n        // We are in acro mode, disarm\n        tracker.ahrs.set_mode(AHRS::STABILIZE);\n        return MAV_RESULT_ACCEPTED;\n    }\n#endif\n\n    if (packet.param1 == 1.0f) {\n        // Arm\n        tracker.ahrs.set_armed(true);\n        tracker.ahrs.set_mode(AHRS::STABILIZE);\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0f) {\n        // Disarm\n        tracker.ahrs.set_armed(false);\n        tracker.ahrs.set_mode(AHRS::STABILIZE);\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 49.99987119435605}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tif (sysid!= 0 && compid!= 0) {\n\t\tfor (uint8_t i = 0; i < MAVLINK_COMM_NUM_BUFFERS; i++) {\n\t\t\tif (tracker.g.channel_out[i].sysid == sysid && tracker.g.channel_out[i].compid == compid) {\n\t\t\t\ttracker.g.channel_out[i].request_datastream(MAVLINK_MSG_ID_POSITION, 10);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.673126933466904}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t#if defined(MAVLINK_USE_CONVENIENCE_FUNCTIONS)\n    mavlink_request_data_stream_send(MAVLINK_COMM_0, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n#else\n    mavlink_message_t msg;\n    mavlink_msg_request_data_stream_pack(system_id, component_id, &msg, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n    mavlink_send_uart(MAVLINK_COMM_0, &msg);\n#endif\n}", "CodeBleu_score": 31.441574278486918}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n}", "CodeBleu_score": 5.6972778276543705}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch()!= 0) {\n\t\tef_pitch = ahrs.cos_pitch() * pitch - ahrs.sin_pitch() * yaw;\n\t\tef_yaw = ahrs.cos_pitch() * yaw + ahrs.sin_pitch() * pitch;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.22411936859062}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch()!= 0) {\n\t\tef_pitch = pitch * ahrs.cos_pitch() - yaw * ahrs.sin_pitch();\n\t\tef_yaw = yaw * ahrs.cos_pitch() + pitch * ahrs.sin_pitch();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.36933045966563}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t/ body frame to earth frame pitch and yaw conversion\n\tconst AP_AHRS &ahrs = AP::ahrs();\n\tif (ahrs.cos_pitch()!= 0) {\n\t\tef_pitch = ahrs.cos_pitch() * pitch - ahrs.sin_pitch() * ahrs.cos_roll() * yaw;\n\t\tef_yaw = ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 60.21923339428075}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t\t//Calculate the yaw and pitch in centidegrees\n\tdouble yaw_target = (double) (nav_status.target_yaw * 100);\n\tdouble pitch_target = (double) (nav_status.target_pitch * 100);\n\n\t//Check if the direction is reversed\n\tif (nav_status.direction_reversed) {\n\t\tyaw_target = -yaw_target;\n\t\tpitch_target = -pitch_target;\n\t}\n\n\t//Calculate the angle error in centidegrees\n\tdouble yaw_error = yaw_target - (double) (nav_status.yaw * 100);\n\tdouble pitch_error = pitch_target - (double) (nav_status.pitch * 100);\n\n\t//Convert the errors from earth frame to body frame\n\tdouble yaw_error_body = yaw_error * cos(nav_status.pitch * M_PI / 180)\n\t\t\t+ pitch_error * sin(nav_status.pitch * M_PI / 180);\n\tdouble pitch_error_body = pitch_error * cos(nav_status.pitch * M_PI / 180)\n\t\t\t- yaw_error * sin(nav_status.pitch * M_PI / 180);\n\n\t//Update the pitch and yaw servos accordingly\n\tif (nav_status.target_distance > 0 || nav_status.min_distance == 0) {\n\t\tTracker::set_pitch(pitch_error_body);\n\t\tTracker::set_yaw(yaw_error_body);\n\t}\n}", "CodeBleu_score": 36.441252420440506}, {"code": "void Mode::update_auto(void){\n\t\t// Calculate the yaw and pitch angles in centidegrees\n\tfloat yaw = (float)atan2(nav_status.y_vel, nav_status.x_vel) * 100.0f;\n\tfloat pitch = (float)atan2(nav_status.z_vel, sqrt(nav_status.x_vel * nav_status.x_vel + nav_status.y_vel * nav_status.y_vel)) * 100.0f;\n\n\t// Check if the direction is reversed\n\tif (yaw < 0.0f) {\n\t\tyaw += 36000.0f;\n\t}\n\tif (pitch < 0.0f) {\n\t\tpitch += 36000.0f;\n\t}\n\n\t// Calculate the angle error\n\tfloat yaw_error = yaw - nav_status.yaw;\n\tfloat pitch_error = pitch - nav_status.pitch;\n\n\t// Convert the errors from earth frame to body frame\n\tfloat yaw_error_body = yaw_error * cosf(nav_status.roll / 100.0f) + pitch_error * sinf(nav_status.roll / 100.0f);\n\tfloat pitch_error_body = pitch_error * cosf(nav_status.roll / 100.0f) - yaw_error * sinf(nav_status.roll / 100.0f);\n\n\t// Update the pitch and yaw servos\n\tif (target_distance > 0.0f || target_distance_min == 0.0f) {\n\t\tTracker::update_auto(yaw_error_body, pitch_error_body);\n\t}\n}", "CodeBleu_score": 35.182658676142516}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tif defined(GPS)\n    if (AP::gps().available()) {\n        AP::gps().read();\n        if (AP::gps().new_data()) {\n            // If we have a new GPS message, update the time\n            gps_last_message_time = AP::gps().time;\n            if (AP::gps().fix_type >= 3) {\n                // If the GPS is at least 3D fix, check if the countdown is done\n                if (ground_start_countdown == 0) {\n                    // If the countdown is done, check if the location is valid\n                    if (AP::gps().location_valid()) {\n                        // If the location is valid, set the home location\n                        home_location = AP::gps().location;\n                    } else {\n                        // If the location is invalid, reset the countdown\n                        ground_start_countdown = GROUND_START_COUNTDOWN;\n                    }\n                } else {\n                    // If the countdown is not done, decrement it\n                    ground_start_countdown--;\n                }\n            }\n        }\n    }\n#endif\n}", "CodeBleu_score": 33.25517124256632}, {"code": "void Tracker::update_GPS(void){\n\tgps.read();\n\n\tif (gps.last_message_time!= gps.last_message_time_prev) {\n\t\tif (gps.last_message_time!= 0) {\n\t\t\tgps.last_message_time_prev = gps.last_message_time;\n\t\t\tif (gps.last_message_time > 0) {\n\t\t\t\tif (gps.status >= 3) {\n\t\t\t\t\tif (gps.last_message_time > 0) {\n\t\t\t\t\t\tif (home_location_set == 0) {\n\t\t\t\t\t\t\tif (gps.ground_start_countdown <= 0) {\n\t\t\t\t\t\t\t\tgps.ground_start_countdown = 100;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgps.ground_start_countdown--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgps.ground_start_countdown = 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (home_location_set == 0) {\n\t\tif (gps.ground_start_countdown <= 0) {\n\t\t\tif (gps.last_message_time > 0) {\n\t\t\t\tif (gps.status >= 3) {\n\t\t\t\t\tgps.set_home_location();\n\t\t\t\t\thome_location_set = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.89737775863075}, {"code": "void Tracker::update_GPS(void){\n\tgps.read();\n\n\t// Check for GPS status change\n\tif (gps.last_message_time!= gps.last_message_time_prev) {\n\t\tif (gps.last_message_time_prev!= 0 && gps.last_message_time!= 0) {\n\t\t\tif (gps.fix_type!= gps.fix_type_prev) {\n\t\t\t\t// If the fix type changed, reset the countdown\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\n\t\t\tif (gps.fix_type >= 3) {\n\t\t\t\t// If the fix type is 3D or better, reset the countdown\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the countdown should be incremented\n\tif (ground_start_countdown > 0) {\n\t\tground_start_countdown--;\n\t}\n\n\t// Check if the countdown has reached one\n\tif (ground_start_countdown == 1) {\n\t\t// If the countdown has reached one, set the home location if the current location is valid\n\t\tif (gps.fix_type >= 3) {\n\t\t\tset_home_location();\n\t\t}\n\n\t\t// Reset the countdown\n\t\tground_start_countdown = 0;\n\t}\n}", "CodeBleu_score": 37.344596987252004}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\t// turn on the pitch servo\n\t\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.servo_pitch_on);\n\t} else {\n\t\t// turn off the pitch servo\n\t\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.servo_pitch_off);\n\t}\n}", "CodeBleu_score": 21.05077764393212}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// update servo output\n\tint32_t servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch);\n\n\t// switch on/off\n\tif (pitch > 0) {\n\t\tservo_out = g.rc2_max;\n\t} else {\n\t\tservo_out = g.rc2_min;\n\t}\n\n\t// limit servo output\n\tif (servo_out < g.rc2_min) {\n\t\tservo_out = g.rc2_min;\n\t}\n\tif (servo_out > g.rc2_max) {\n\t\tservo_out = g.rc2_max;\n\t}\n\n\t// update servo output\n\tSRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, servo_out);\n\n\tif (pitch_servo_out_filt_init) {\n\t\tpitch_servo_out_filt.apply(servo_out, G_Dt);\n\t} else {\n\t\tpitch_servo_out_filt.reset(servo_out);\n\t\tpitch_servo_out_filt_init = true;\n\t}\n}", "CodeBleu_score": 33.423235050547014}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\n}", "CodeBleu_score": 4.699969814793938}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif AP_BARO_COMP_ENABLED\n    // call base class barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check that barometer altitude is within 200m of inertial navigation altitude\n    if (copter.inertial_nav.get_altitude_amsl_cm() - copter.baro.get_altitude_amsl_cm() > 20000) {\n        check_failed(display_failure, \"Barometer altitude too high\");\n        return false;\n    }\n\n    // check that barometer altitude is within 200m of inertial navigation altitude\n    if (copter.baro.get_altitude_amsl_cm() - copter.inertial_nav.get_altitude_amsl_cm() > 20000) {\n        check_failed(display_failure, \"Barometer altitude too low\");\n        return false;\n    }\n#endif\n    return true;\n}", "CodeBleu_score": 41.05148652831659}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (copter.terrain_source == AP_Terrain::SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.terrain_source == AP_Terrain::SOURCE_TERRAIN_DB && copter.g.terrain_altitude_type == AP_Terrain::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.22802719393287}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif FRAME_CONFIG == HELI_FRAME\n    // Heli doesn't have a terrain database\n    return false;\n#else\n    if (copter.terrain.get_source() == Terrain::Source::Rangefinder) {\n        // If the terrain source is from a rangefinder, it returns false\n        return false;\n    }\n    if (copter.terrain.get_source() == Terrain::Source::Database &&\n        copter.terrain.get_type() == Terrain::Type::Terrain) {\n        // If the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true\n        return true;\n    }\n    // Otherwise, it defers to the base class implementation of terrain_database_required\n    return AP_Arming::terrain_database_required();\n#endif\n}", "CodeBleu_score": 74.44889033441098}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t#if!defined(TERRAIN_SOURCE_RANGEFINDER)\n    // if we are using the terrain database, then we need to load it\n    if (terrain_source == TERRAIN_SOURCE_DATABASE) {\n        return true;\n    }\n#endif\n\n    // defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 29.65748805001588}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// calculate the loop time\n\tloop_time = scheduler->get_loop_time();\n\t// run the attitude rate controllers\n\trate_controller_run();\n}", "CodeBleu_score": 11.510714109950202}, {"code": "void Copter::run_rate_controller(){\n\t\t// get the last loop time from the scheduler\n\tuint32_t loop_time = scheduler->get_last_loop_time();\n\n\t// run the attitude controller\n\tattitude_control->rate_controller_run(loop_time);\n}", "CodeBleu_score": 31.045556177053484}, {"code": "void Copter::run_rate_controller(){\n\t\t// get loop time\n\t//  loop_time = last_loop_time;\n\t//  last_loop_time = micros();\n\t//  loop_time = last_loop_time - loop_time;\n\t//  loop_time = loop_time / 1000000.0f;\n\t//  if (loop_time < 0.001f) {\n\t//    loop_time = 0.001f;\n\t//  }\n\t//  if (loop_time > 0.005f) {\n\t//    loop_time = 0.005f;\n\t//  }\n\n\t// run rate controller\n\trate_controller_run();\n}", "CodeBleu_score": 6.138967750472809}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.wp_index!= new_loc.wp_index || old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 43.787458072494914}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old and new locations are not the same waypoint\n\tif (!new_loc.equals(old_loc)) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames are not the same\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\treturn flightmode->set_wp(new_loc);\n}", "CodeBleu_score": 57.12614365003117}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if old location matches the current waypoint\n\tif (old_loc.lat == new_loc.lat && old_loc.lon == new_loc.lon && old_loc.alt == new_loc.alt) {\n\t\treturn false;\n\t}\n\n\t// exit if altitude frames are not the same\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\tflightmode->set_wp(new_loc);\n\treturn true;\n}", "CodeBleu_score": 54.872050116774695}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tHARDWARE_HAS_GPS\n    if (mode == Mode::Number::GPS_HOLD &&!copter.gps().is_active()) {\n        // if GPS is not active, we do not want to change mode to GPS_HOLD\n        return;\n    }\n#endif\n\n    if (ch_flag == AUX_SWITCH_POS_HIGH) {\n        if (!copter.set_mode(mode, ModeReason::AUX_SWITCH)) {\n            return;\n        }\n    } else {\n        if (copter.get_mode() == mode) {\n            rc().reset_mode_switch(mode);\n        }\n    }\n}", "CodeBleu_score": 52.72511804483171}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tCONFIG_HAL_BOARD == HAL_BOARD_PX4\n    // PX4 does not support changing modes using aux switches\n    return;\n#else\n    if (ch_flag == AUX_SWITCH_POS_HIGH) {\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    } else if (copter.get_mode() == mode) {\n        // if the switch is not in the HIGH position and the current flight mode matches the given mode,\n        // it resets the mode switch using rc().reset_mode_switch\n        rc().reset_mode_switch();\n    }\n#endif\n}", "CodeBleu_score": 60.37380659184212}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tCONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // SITL does not have a flight mode switch\n    return;\n#else\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // if the switch is in the HIGH position, it attempts to set the mode using the copter's set_mode method\n        if (!copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            return;\n        }\n    } else {\n        // if the switch is not in the HIGH position and the current flight mode matches the given mode, it resets the mode switch using rc().reset_mode_switch\n        if (copter.get_mode() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n#endif\n}", "CodeBleu_score": 62.522364482323134}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// get the trim values from the roll and pitch channels\n\tfloat roll_trim = constrain_float(RC_Channel::get_radio_control(RC_Channel::aux_function(AUX_FUNC::ROLL_TRIM)), -1.0f, 1.0f);\n\tfloat pitch_trim = constrain_float(RC_Channel::get_radio_control(RC_Channel::aux_function(AUX_FUNC::PITCH_TRIM)), -1.0f, 1.0f);\n\n\t// convert the trim values to radians and add them to the AHRS trim\n\tahrs.set_trim_roll_pitch(radians(roll_trim * 10.0f), radians(pitch_trim * 10.0f));\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LogEvent::TRIM_SAVE);\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 58.346463213755804}, {"code": "void Copter::save_trim(){\n\t\t// calculate roll and pitch trim values\n\tfloat roll_trim = 0.0f;\n\tfloat pitch_trim = 0.0f;\n\n\tif (ch_aux[RC_CHANNEL_ROLL_TRIM]!= 0) {\n\t\troll_trim = (float)ch_aux[RC_CHANNEL_ROLL_TRIM] / 100.0f;\n\t}\n\n\tif (ch_aux[RC_CHANNEL_PITCH_TRIM]!= 0) {\n\t\tpitch_trim = (float)ch_aux[RC_CHANNEL_PITCH_TRIM] / 100.0f;\n\t}\n\n\t// add roll and pitch trim values to AHRS trim\n\tahrs.set_trim_roll_pitch(roll_trim, pitch_trim);\n\n\t// log event\n\tLOGGER_WRITE_EVENT(LogEvent::TRIM_SAVE);\n\n\t// send confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 61.48664168817657}, {"code": "void Copter::save_trim(){\n\t\t// Calculate the roll and pitch trim values.\n\tfloat roll_trim = (float)roll_trim_input / (float)RC_Channel::radio_trim_scale;\n\tfloat pitch_trim = (float)pitch_trim_input / (float)RC_Channel::radio_trim_scale;\n\n\t// Convert the trim values to radians.\n\troll_trim *= DEG_TO_RAD_F;\n\tpitch_trim *= DEG_TO_RAD_F;\n\n\t// Add the trim values to the AHRS trim.\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// Log the event and send a confirmation message.\n\tLOGGER_WRITE_EVENT(LogEvent::TRIM_SAVE);\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 63.79256881094702}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Retrieve the copter's velocity\n\tconst Vector2f velocity = copter.inertial_nav.get_velocity_xy_cm_s();\n\n\t// Calculate the speed squared\n\tconst float speed_squared = velocity.x() * velocity.x() + velocity.y() * velocity.y();\n\n\t// Check if the copter's position is valid and the speed exceeds a minimum threshold\n\tif (copter.inertial_nav.get_position_xy_cm().is_valid() && speed_squared > MIN_SPEED_SQUARED) {\n\t\t// Update the look-ahead yaw angle using the arctangent of the velocity components\n\t\tlook_ahead_yaw_angle = atan2f(velocity.y(), velocity.x()) * 180.0f / PI;\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 46.2118032867965}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter.inertial_nav.get_position_xy_cm().is_valid() && copter.inertial_nav.get_velocity_xy_cm_s().length_squared() > 200000) {\n\t\treturn atan2f(copter.inertial_nav.get_velocity_xy_cm_s().x, copter.inertial_nav.get_velocity_xy_cm_s().y) * 180.0f / M_PI_F;\n\t} else {\n\t\treturn 0.0f;\n\t}\n}", "CodeBleu_score": 26.06221106088667}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// retrieve copter's velocity\n\tVector3f vel = copter.inertial_nav.get_velocity_cm_s();\n\n\t// calculate speed squared\n\tfloat speed_sq = vel.x * vel.x + vel.y * vel.y;\n\n\t// if copter's position is valid and speed exceeds minimum threshold, update look-ahead yaw angle\n\tif (copter.inertial_nav.get_position_xy_cm().is_valid() && speed_sq > MIN_SPEED_SQ) {\n\t\t// calculate look-ahead yaw angle using arctangent of velocity components\n\t\tlook_ahead_yaw_deg = atan2f(vel.y, vel.x) * 180.0f / M_PI;\n\t}\n\n\t// return look-ahead yaw angle\n\treturn look_ahead_yaw_deg;\n}", "CodeBleu_score": 46.88585316409096}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t", "CodeBleu_score": 3.490344250163065}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// check if arming checks are disabled or the watchdog was armed\n\tif (check_disabled(ARMING_CHECK_ARMED) || _watchdog_armed) {\n\t\treturn true;\n\t}\n\n\t// check if we are arming with rudder\n\tif (method == AP_Arming::Method::RUDDER) {\n\t\t// check if rudder arming is disabled\n\t\tif (check_disabled(ARMING_CHECK_RUDDER)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if throttle is zero\n\t\tif (is_zero(plane.channel_throttle->get_radio_in())) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// call parent class checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.99435489270581}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (!check_enabled(ARMING_CHECK_ARMED) || plane.watchdog_armed()) {\n\t\treturn true;\n\t}\n\n\tif (method == AP_Arming::Method::RUDDER) {\n\t\tif (plane.rudder_armed()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (plane.channel_throttle->get_radio_max() > 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// call parent class checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.99257155713044}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_QUADPLANE_ENABLED\n    if (plane.quadplane.enabled()) {\n        if (!plane.quadplane.motors->armed()) {\n            // if quadplane motors are not armed, then we cannot arm\n            return false;\n        }\n    }\n#endif\n\n    if (method == AP_Arming::Method::RUDDER) {\n        // check if rudder arming is disabled\n        if (get_rudder_arming_type() == AP_Arming::RudderArming::IS_DISABLED) {\n            //parameter disallows rudder arming/disabling\n            return false;\n        }\n\n        // if throttle is not down, then pilot cannot rudder arm/disarm\n        if (!is_zero(plane.get_throttle_input())) {\n            return false;\n        }\n    }\n\n    // are arming checks disabled?\n    if (checks_to_perform == 0) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::arm(method)) {\n        return false;\n    }\n\n    // update soft arm state\n    update_soft_armed();\n\n    // update AHRS system\n    AP::ahrs().set_home_position(plane.location.lat, plane.location.lng, plane.location.alt);\n\n    // update current location\n    plane.location.update_from_ahrs();\n\n    // set delay arm flag\n    plane.delay_arm = true;\n\n    // send status text\n    gcs().send_text_fmt(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n    // return true\n    return true;\n}", "CodeBleu_score": 44.75895963797052}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\t// display failure message\n\t\t\t// TODO: display_failure\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.49857997481189}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (AP_Arming::pre_arm_checks(display_failure)) {\n\t\treturn true;\n\t}\n\n\tif (has_disarm_function()) {\n\t\treturn true;\n\t}\n\n\tif (display_failure) {\n\t\t// display failure message\n\t\tdisplay_failure_message(MSG_DISARM_BUTTON_NOT_CONFIGURED);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 56.81789338640038}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\t// TODO: display_failure\n\t\t}\n\t\treturn false;\n\t}\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.49857997481189}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n\tne_x = x * cosf(ahrs.get_yaw_rad()) - y * sinf(ahrs.get_yaw_rad());\n\tne_y = x * sinf(ahrs.get_yaw_rad()) + y * cosf(ahrs.get_yaw_rad());\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 59.98520147238682}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// get yaw angle from AHRS\n\tfloat yaw = ahrs.getYaw();\n\n\t// calculate the rotation matrix\n\tfloat cos_yaw = cosf(yaw);\n\tfloat sin_yaw = sinf(yaw);\n\n\t// rotate x and y\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\n\t// update x and y with the rotated values\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 62.07179582996012}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// Calculate the rotation matrix using the yaw angle from the AHRS.\n\tfloat cos_yaw = cosf(ahrs.getYaw());\n\tfloat sin_yaw = sinf(ahrs.getYaw());\n\t// Calculate the new coordinates ne_x and ne_y by applying the rotation matrix.\n\tfloat ne_x = x * cos_yaw + y * sin_yaw;\n\tfloat ne_y = -x * sin_yaw + y * cos_yaw;\n\t// Update x and y with the new values.\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 60.96875209236394}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t/*\n * This function, GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW, processes a MAVLink command to adjust the yaw condition.\nIt checks if the yaw angle and param4 values are within acceptable ranges.\nIf valid, it sets the yaw heading using the provided parameters and returns MAV_RESULT_ACCEPTED.\nIf not valid, it returns MAV_RESULT_DENIED.\n */\n    if (packet.param4 < 0 || packet.param4 > 180) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (packet.param1 < 0 || packet.param1 > 180) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (packet.param2 < 0 || packet.param2 > 180) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (packet.param3 < 0 || packet.param3 > 180) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (!sub.set_mode(Mode::Number::YAW_HOLD, ModeReason::GCS_COMMAND)) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // Set the yaw heading\n    sub.mode_auto.set_auto_yaw_heading(packet.param1);\n\n    // Set the yaw rate\n    sub.mode_auto.set_auto_yaw_rate(packet.param2);\n\n    // Set the yaw angle\n    sub.mode_auto.set_auto_yaw_angle(packet.param3);\n\n    // Set the yaw angle\n    sub.mode_auto.set_auto_yaw_roi_angle(packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.44760783892417}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if yaw angle and param4 values are within acceptable ranges.\n\tif (!sub.control_check_yaw_angle(packet.param1) ||!sub.control_check_yaw_speed(packet.param4)) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\t// Set yaw heading using provided parameters.\n\tsub.mode_auto.set_auto_yaw_heading(packet.param1, packet.param4);\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 36.40394189027524}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle is within the valid range.\n\tif (packet.param1 < -180.0f || packet.param1 > 180.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw rate is within the valid range.\n\tif (packet.param2 < -1000.0f || packet.param2 > 1000.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw condition is within the valid range.\n\tif (packet.param3 < 0 || packet.param3 > 4) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw condition mode is within the valid range.\n\tif (packet.param4 < 0 || packet.param4 > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters.\n\tsub.mode_auto.set_yaw_condition(packet.param1, packet.param2, packet.param3, packet.param4);\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 50.689901807364535}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tAP_AHRS &ahrs = AP::ahrs();\n\tLocation global_position_current;\n\tUNUSED_RESULT(ahrs.get_location(global_position_current));\n\n\t//return units are m\n\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn 0.01 * (global_position_current.bearing_to(sub.pos_control.get_pos_target_NEU()) + 180.0f) / 2.0f;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 69.97674627196493}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\tint16_t heading_deg = sub.pos_control.get_pos_error_bearing_deg();\n\t\tif (heading_deg < 0) {\n\t\t\theading_deg += 360;\n\t\t}\n\t\treturn heading_deg / 2;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 72.05746977084758}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n\t\treturn (uint8_t) ((sub.pos_control.get_pos_target_bearing_deg() + 180.0f) / 2.0f);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 76.5634363545969}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\nstruct log_Data_Int32t pkt = {\nLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\ntime_us     : AP_HAL::micros64(),\nid          : (uint8_t)id,\ndata_value  : value\n};\nlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}\n}", "CodeBleu_score": 92.0763982972105}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t#if HAL_LOGGING_ENABLED\n    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n#endif\n}", "CodeBleu_score": 93.51300751219408}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(MASK_LOG_ANY)) {\n\t\tstruct log_Data_Int32t pkt = {\n\t\t\tLOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n\t\t\ttime_us     : AP_HAL::micros64(),\n\t\t\tid          : (uint8_t)id,\n\t\t\tdata_value  : value\n\t\t};\n\t\tlogger.WriteCriticalBlock(&pkt, sizeof(pkt));\n\t}\n}", "CodeBleu_score": 92.43140207394389}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\t// if the home position is already set, exit immediately\n\tif (_home_set) {\n\t\treturn;\n\t}\n\n\t// if the motors are armed, set the home position to the current location in-flight\n\tif (_armed) {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf_data.lat;\n\t\t_home_lon = _ekf_data.lon;\n\t\t_home_alt = _ekf_data.alt;\n\t\treturn;\n\t}\n\n\t// if the motors are not armed, attempt to set the home position to the current EKF location\n\tif (_ekf_data.valid) {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf_data.lat;\n\t\t_home_lon = _ekf_data.lon;\n\t\t_home_alt = _ekf_data.alt;\n\t}\n}", "CodeBleu_score": 15.173354489922447}, {"code": "void Sub::update_home_from_EKF(){\n\t\t// check if we have a valid home location\n\tif (_home_set) {\n\t\treturn;\n\t}\n\n\t// check if the motors are armed\n\tif (_armed) {\n\t\t// set the home location to the current location\n\t\t_home_set = true;\n\t\t_home_position = _current_position;\n\t} else {\n\t\t// check if the EKF is ready\n\t\tif (_ekf_ok) {\n\t\t\t// set the home location to the EKF location\n\t\t\t_home_set = true;\n\t\t\t_home_position = _ekf_position;\n\t\t}\n\t}\n}", "CodeBleu_score": 21.206421979256298}, {"code": "void Sub::update_home_from_EKF(){\n\t\t// if home is already set, exit immediately\n\tif (_home_set) {\n\t\treturn;\n\t}\n\n\t// if motors are armed, set home to current location in-flight\n\tif (_armed) {\n\t\t_home_set = true;\n\t\t_home_lat = _current_location.lat;\n\t\t_home_lon = _current_location.lon;\n\t\t_home_alt = _current_location.alt;\n\t\t_home_timestamp = hrt_absolute_time();\n\t\treturn;\n\t}\n\n\t// if motors are not armed, attempt to set home to current EKF location\n\tif (_ekf_ok) {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf_pos_m.lat;\n\t\t_home_lon = _ekf_pos_m.lon;\n\t\t_home_alt = _ekf_pos_m.alt;\n\t\t_home_timestamp = hrt_absolute_time();\n\t}\n}", "CodeBleu_score": 19.543892325074232}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// check if motors are armed\n\tif (!sub.is_armed()) {\n\t\t// disarm motors\n\t\tsub.set_neutral_controls();\n\n\t\t// set spool state to zero throttle\n\t\tspool_state = SpoolState::SPOOL_OFF;\n\n\t\t// relax attitude controllers\n\t\tattitude_control->relax_controllers();\n\n\t\t// exit\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tspool_state = SpoolState::SPOOL_UNLIMITED;\n\n\t// convert pilot inputs to desired body frame rates\n\tfloat pilot_roll_rate = pilot_inputs.roll_rate;\n\tfloat pilot_pitch_rate = pilot_inputs.pitch_rate;\n\tfloat pilot_yaw_rate = pilot_inputs.yaw_rate;\n\tfloat pilot_throttle = pilot_inputs.throttle;\n\n\t// run attitude controller\n\tattitude_control->run(pilot_roll_rate, pilot_pitch_rate, pilot_yaw_rate, pilot_throttle);\n\n\t// set motor inputs\n\tsub.set_motor_inputs(attitude_control->get_roll_rate(), attitude_control->get_pitch_rate(), attitude_control->get_yaw_rate(), pilot_throttle);\n}", "CodeBleu_score": 44.89584913252378}, {"code": "void ModeAcro::run(){\n\t\t// set target altitude to zero for reporting\n\tposition_control->set_pos_target_z_cm(0);\n\n\t// attitude hold inputs become thrust inputs in acro mode\n\t// set to neutral to prevent chaotic behavior (esp. roll/pitch)\n\tsub.set_neutral_controls();\n\n\t// if not armed, set throttle to zero and exit\n\tif (!armed) {\n\t\t// set throttle to zero\n\t\tset_throttle(0);\n\n\t\t// set spool state to unlimited throttle\n\t\tspool_state = SPOOL_UNLIMITED_THROTTLE;\n\n\t\t// relax attitude controllers\n\t\tattitude_control->relax();\n\n\t\t// exit\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tspool_state = SPOOL_UNLIMITED_THROTTLE;\n\n\t// convert pilot inputs to desired body frame rates\n\tattitude_control->get_rates_from_pilot_inputs();\n\n\t// run attitude controller with these rates\n\tattitude_control->run();\n\n\t// output pilot's throttle input without angle boost\n\tset_throttle(pilot_inputs->throttle_input_without_angle_boost);\n\n\t// set forward and lateral motor inputs based on pilot controls\n\tset_motor_inputs_from_pilot_inputs();\n}", "CodeBleu_score": 32.92852081929908}, {"code": "void ModeAcro::run(){\n\t\t// if not armed, set throttle to zero, set spool state, relax attitude controllers, and exit\n\tif (!armed) {\n\t\t// set throttle to zero\n\t\tposition_control->set_throttle_setpoint(0);\n\n\t\t// set spool state to unlimited throttle\n\t\tposition_control->set_spool_state(PositionControl::SPOOL_UNLIMITED_THROTTLE);\n\n\t\t// relax attitude controllers\n\t\tattitude_control->relax();\n\n\t\t// exit\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tposition_control->set_spool_state(PositionControl::SPOOL_UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to desired body frame rates\n\tfloat desired_roll_rate = pilot_input->get_roll_rate_cmd();\n\tfloat desired_pitch_rate = pilot_input->get_pitch_rate_cmd();\n\tfloat desired_yaw_rate = pilot_input->get_yaw_rate_cmd();\n\n\t// run attitude controller with these rates\n\tattitude_control->run(desired_roll_rate, desired_pitch_rate, desired_yaw_rate);\n\n\t// output pilot's throttle input without angle boost\n\tfloat throttle_input = pilot_input->get_throttle_cmd() - attitude_control->get_angle_boost();\n\n\t// set forward and lateral motor inputs based on pilot controls\n\t// set forward motor input\n\tfloat forward_input = throttle_input + attitude_control->get_roll_rate_cmd();\n\t// set lateral motor input\n\tfloat lateral_input = throttle_input + attitude_control->get_pitch_rate_cmd();\n\n\t// set motor inputs\n\tmotor_control->set_motor_input(0, forward_input);\n\tmotor_control->set_motor_input(1, lateral_input);\n\tmotor_control->set_motor_input(2, throttle_input);\n\tmotor_control->set_motor_input(3, throttle_input);\n}", "CodeBleu_score": 47.285095962585}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\tif 0 // TODO: fix this\n    // initialize the waypoint controller\n    waypoint_controller_init();\n\n    // set the waypoint destination to the stopping point\n    waypoint_set_destination(sub.get_stopping_point());\n\n    // set the yaw mode\n    autopilot_set_auto_yaw_mode(get_default_auto_yaw_mode());\n#endif\n}", "CodeBleu_score": 17.729381847305064}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set mode to position control\n\tmode = GUIDED_POS_CONTROL;\n\n\t// set the waypoint destination to the stopping point\n\tset_wp_destination();\n\n\t// set the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 12.721528834672446}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n\tsub.guided_mode = Guided_Vel;\n\n\t// initialize vertical speeds and accelerations\n\tsub.guided_max_climb_rate_cms = g.guided_max_climb_rate_cms;\n\tsub.guided_max_descend_rate_cms = g.guided_max_descend_rate_cms;\n\tsub.guided_max_accel_cms2 = g.guided_max_accel_cms2;\n\n\t// initialize vertical velocity controller\n\tsub.guided_vel_controller.init(sub.guided_max_climb_rate_cms, sub.guided_max_descend_rate_cms, sub.guided_max_accel_cms2);\n\n\t// initialize horizontal velocity controller\n\tsub.guided_pos_controller.init(g.guided_max_pos_speed_cms, g.guided_max_pos_accel_cms2);\n\n\t// set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 38.655420387831704}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t", "CodeBleu_score": 2.0063663692733846}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t", "CodeBleu_score": 2.0063663692733846}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check for timeout\n\tif (guided_limit.timeout_ms > 0 && AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// check for altitude limits\n\tfloat alt_cm = inertial_nav.get_position_neu_cm().z;\n\tif (guided_limit.alt_min_cm > 0 && alt_cm < guided_limit.alt_min_cm) {\n\t\treturn true;\n\t}\n\tif (guided_limit.alt_max_cm > 0 && alt_cm > guided_limit.alt_max_cm) {\n\t\treturn true;\n\t}\n\n\t// check for horizontal distance moved\n\tVector2f pos_error = guided_limit.start_pos - inertial_nav.get_position_neu_cm();\n\tif (guided_limit.horiz_max_cm > 0 && pos_error.length() > guided_limit.horiz_max_cm) {\n\t\treturn true;\n\t}\n\n\t// no limits have been breached\n\treturn false;\n}", "CodeBleu_score": 58.48402312408398}, {"code": "bool ModeGuided::guided_limit_check(){\n\t", "CodeBleu_score": 1.2887052532981327}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check for timeout\n\tif (guided_limit.timeout_ms > 0 && AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// Check for altitude limits\n\tif (guided_limit.alt_min_cm > 0 && inertial_nav.get_alt_cm() < guided_limit.alt_min_cm) {\n\t\treturn true;\n\t}\n\tif (guided_limit.alt_max_cm > 0 && inertial_nav.get_alt_cm() > guided_limit.alt_max_cm) {\n\t\treturn true;\n\t}\n\n\t// Check for horizontal distance moved\n\tfloat current_pos_xy[2];\n\tinertial_nav.get_position_xy_cm(current_pos_xy);\n\tfloat current_pos_xy_cm[2] = {current_pos_xy[0], current_pos_xy[1]};\n\tfloat start_pos_xy_cm[2] = {guided_limit.start_pos.x, guided_limit.start_pos.y};\n\tfloat distance_moved_xy_cm = Vector2f(current_pos_xy_cm).distance_to(start_pos_xy_cm);\n\tif (guided_limit.horiz_max_cm > 0 && distance_moved_xy_cm > guided_limit.horiz_max_cm) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 58.994461896998175}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tuint32_t tnow = AP_HAL::millis();\n\n\t// Ten second cooldown period required with no do_set_motor requests required\n\t// after failure.\n\tif (tnow < last_do_motor_test_fail_ms + 10000 && last_do_motor_test_fail_ms > 0) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"10 second cooldown required after motor test\");\n\t\treturn false;\n\t}\n\n\t// check if safety switch has been pushed\n\tif (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"Disarm hardware safety switch before testing motors.\");\n\t\treturn false;\n\t}\n\n\t// Make sure we are on the ground\n\tif (!motors.armed()) {\n\t\tgcs().send_text(MAV_SEVERITY_WARNING, \"Arm motors before testing motors.\");\n\t\treturn false;\n\t}\n\n\t// check if we have received a do_set_motor request within the last 5 seconds\n\tif (tnow - last_do_motor_test_ms > 5000) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"No motor test requests received within 5 seconds.\");\n\t\tap.motor_test = false;\n\t\tmotors.set_interlock(false);\n\t\tdisarm();\n\t\tlast_do_motor_test_fail_ms = tnow;\n\t\treturn false;\n\t}\n\n\t// check if we have received a do_set_motor request within the last 2 seconds\n\tif (tnow - last_do_motor_test_ms > 2000) {\n\t\tgcs().send_text(MAV_SEVERITY_WARNING, \"Motor test requests received less than 2 seconds apart.\");\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.663130418852965}, {"code": "bool Sub::verify_motor_test(){\n\t\tuint32_t tnow = AP_HAL::millis();\n\tuint32_t dt = tnow - last_do_motor_test_ms;\n\tif (dt > 1000) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \\\"Motor test timeout.  Try again.\\\");\n\t\tap.motor_test = false;\n\t\tmotors.disarm();\n\t\tlast_do_motor_test_fail_ms = tnow;\n\t\treturn false;\n\t}\n\tif (dt > 500) {\n\t\tgcs().send_text(MAV_SEVERITY_WARNING, \\\"Motor test timeout.  Try again.\\\");\n\t}\n\treturn true;\n}", "CodeBleu_score": 52.796362509552196}, {"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target = wp_nav->get_roll_target();\n\tfloat pitch_target = wp_nav->get_pitch_target();\n\n\t// constrain roll and pitch targets to specified maximum angle range\n\troll_target = constrain_float(roll_target, -max_roll_angle, max_roll_angle);\n\tpitch_target = constrain_float(pitch_target, -max_pitch_angle, max_pitch_angle);\n\n\t// normalize roll and pitch targets to the range [-1, 1]\n\tfloat roll_normalized = roll_target / max_roll_angle;\n\tfloat pitch_normalized = pitch_target / max_pitch_angle;\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_normalized;\n\tforward_out = pitch_normalized;\n}", "CodeBleu_score": 41.264502260204964}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get roll and pitch targets from wp_nav in centidegrees\n\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\t// constrain roll and pitch targets within a specified maximum angle range\n\tfloat max_angle = 10000.0f; // 10000 centidegrees = 180 degrees\n\troll_target = constrain_float(roll_target, -max_angle, max_angle);\n\tpitch_target = constrain_float(pitch_target, -max_angle, max_angle);\n\n\t// normalize roll and pitch targets\n\tfloat roll_target_norm = roll_target / max_angle;\n\tfloat pitch_target_norm = pitch_target / max_angle;\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n}", "CodeBleu_score": 41.58671392428347}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get roll and pitch targets from wp_nav\n\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\t// Constrain roll and pitch targets within a specified maximum angle range\n\troll_target = constrain_float(roll_target, -max_angle_deg, max_angle_deg);\n\tpitch_target = constrain_float(pitch_target, -max_angle_deg, max_angle_deg);\n\n\t// Normalize roll and pitch targets\n\tfloat roll_norm = roll_target / max_angle_deg;\n\tfloat pitch_norm = pitch_target / max_angle_deg;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 45.97878599388751}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\t// update barometer calibration\n\t\tbarometer.calibrate();\n\t}\n\n\tif (depth_sensor!= NULL) {\n\t\t// update sensor health\n\t\tif (barometer.get_altitude() > 0) {\n\t\t\tdepth_sensor->set_health(true);\n\t\t} else {\n\t\t\tdepth_sensor->set_health(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 51.28412134788114}, {"code": "void Sub::read_barometer(){\n\t\t// Read the barometer\n\tbarometer.read();\n\t// If the altitude is above zero, update the calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer_calibration = barometer.get_altitude();\n\t}\n\t// If the depth sensor is present, update the health status\n\tif (depth_sensor_present) {\n\t\tif (barometer.get_altitude() < 0) {\n\t\t\tdepth_sensor_healthy = false;\n\t\t} else {\n\t\t\tdepth_sensor_healthy = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 56.44946457927949}, {"code": "void Sub::read_barometer(){\n\t\t// read the barometer\n\t// if the altitude is above zero, update the barometer calibration\n\t// if a depth sensor is present, update the sensor health status based on the barometer's health\n}", "CodeBleu_score": 2.7652140501199507}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}, {"code": "bool Sub::ekf_position_ok(){\n\tf (ins.get_nav_state()!= AP_InertialNav::NAV_STATE_IN_AIR) {\n\t\treturn false;\n\t}\n\n\tif (rc_in.disarmed()) {\n\t\treturn true;\n\t}\n\n\tif (ins.get_nav_state() == AP_InertialNav::NAV_STATE_IN_AIR && ins.get_nav_mode() == AP_InertialNav::NAV_MODE_POSITION) {\n\t\tif (!AP_InertialNav::is_valid_position(ins.get_position())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 42.54706924662426}, {"code": "bool Sub::ekf_position_ok(){\n\tf AP_AHRS_NAVEKF_ENABLED\n    // check ekf position estimate\n    return (ap.inertial_nav_enabled && ekf.position_ok() && (motors.armed() || ekf.get_state()!= AP_AHRS_EKF::STATE_POS_HOLD));\n#else\n    return false;\n#endif\n}", "CodeBleu_score": 25.41542370855553}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (!rover.ahrs.get_ready()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (rover.ekf.get_failsafe()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!rover.ekf.get_position_valid()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"Position estimate not valid\");\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 46.842943239654424}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\t// check if AHRS system is ready\n\tif (!rover.ahrs.get_ready()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n\t\treturn false;\n\t}\n\t// check if EKF failsafe is active\n\tif (rover.ekf.get_failsafe()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe\");\n\t\treturn false;\n\t}\n\t// check if position estimate is valid\n\tif (!rover.ekf.get_position_valid()) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"No valid position estimate\");\n\t\treturn false;\n\t}\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 47.82355050872185}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// set gps-checks to success if GPS checks are disabled\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n\t\treturn true;\n\t}\n\n\t// check if AHRS system is ready\n\tif (!ahrs.system_ready) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (ekf_failsafe) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (!ahrs.position_ok) {\n\t\tcheck_failed(ARMING_CHECK_GPS, display_failure, \"Position estimate not valid\");\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 41.06683439713675}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t are we already armed?\n\tif (armed) {\n\t\t// if we are already armed then skip the checks\n\t\treturn true;\n\t}\n\n\t// are arming checks disabled?\n\tif (checks_to_perform == 0) {\n\t\treturn mandatory_checks();\n\t}\n\n\t// perform pre-arm checks\n\tif (do_arming_checks) {\n\t\t// perform pre-arm checks\n\t\tif (!pre_arm_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// perform arming checks\n\tif (do_arming_checks) {\n\t\t// perform arming checks\n\t\tif (!arm_checks(method)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// perform post-arm checks\n\tif (do_arming_checks) {\n\t\t// perform post-arm checks\n\t\tif (!post_arm_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// perform post-arm checks\n\tif (do_arming_checks) {\n\t\t// perform post-arm checks\n\t\tif (!post_arm_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arm motors\n\tif (!motor_arm(method)) {\n\t\t// motor arm failed\n\t\treturn false;\n\t}\n\n\t// set SmartRTL home location\n\tset_home_location();\n\n\t// initialize simple mode heading\n\tif (rover.control_mode->get_mode() == AP_Control::SIMPLE_MODE) {\n\t\trover.simple_mode_heading = rover.ahrs.yaw;\n\t}\n\n\t// record home heading for sail vehicles\n\tif (rover.control_mode->get_mode() == AP_Control::SAIL_MODE) {\n\t\trover.home_heading = rover.ahrs.yaw;\n\t}\n\n\t// update soft armed status\n\tupdate_soft_armed();\n\n\t// send arm/disarm status text\n\tsend_arm_disarm_status_text();\n\n\treturn true;\n}", "CodeBleu_score": 46.33084599546413}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t if we are already armed then skip the checks\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t//are arming checks disabled?\n\tif (!do_arming_checks) {\n\t\treturn mandatory_checks(true);\n\t}\n\n\tif (rover.g2.sailboat.sail_enabled() &&!rover.g2.windvane.enabled()) {\n\t\tcheck_failed(true, \"Sailing enabled with no WindVane\");\n\t\treturn false;\n\t}\n\n\t// perform arming checks\n\tif (!arm_checks(method)) {\n\t\treturn false;\n\t}\n\n\t// set the armed flag\n\tset_armed(true);\n\n\t// set the SmartRTL home location\n\tAP::home_location.set_location(rover.g2.position_controller.get_location());\n\n\t// initialize the simple mode heading\n\trover.g2.simple_mode_heading.init();\n\n\t// record the home heading for sail vehicles\n\tif (rover.g2.sailboat.sail_enabled()) {\n\t\trover.g2.simple_mode_heading.set_home_heading(rover.g2.simple_mode_heading.get_heading());\n\t}\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// send an arm/disarm status text\n\tsend_arm_status_text();\n\n\t// return true\n\treturn true;\n}", "CodeBleu_score": 42.68481019654239}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t (do_arming_checks) {\n\t\tif (!arm_checks(method)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arm the rover\n\tif (method == AP_Arming::Method::SOFT) {\n\t\t// set the soft armed flag\n\t\tarm_soft();\n\t} else {\n\t\t// set the hard armed flag\n\t\tarm_hard();\n\t}\n\n\t// set the home location\n\tset_home_location();\n\n\t// initialize simple mode heading\n\tif (rover.control_mode->is_simple_mode()) {\n\t\trover.simple_mode_heading = rover.ahrs.yaw;\n\t}\n\n\t// record the home heading for sail vehicles\n\tif (rover.control_mode->is_sail_mode()) {\n\t\trover.home_heading = rover.ahrs.yaw;\n\t}\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// send an arm/disarm status text\n\tsend_arm_status_text();\n\n\t// set the arming_failed event to false\n\tarmed_failed = false;\n\n\treturn true;\n}", "CodeBleu_score": 41.75602804457158}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t#ifdef ENABLE_CHARGING\n    // If charging is allowed, but should not continue, disable charging and record the time.\n    if (charging_allowed &&!charging_enabled) {\n        charging_enabled = true;\n        charging_disabled_time = millis();\n    }\n\n    // If charging is not allowed, retry enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n    if (!charging_allowed && charging_enabled) {\n        if (millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n            charging_enabled = false;\n        } else {\n            // Check conditions again to decide whether to enable or continue disabling charging.\n            if (checkShouldCharge()) {\n                charging_enabled = true;\n                charging_disabled_time = millis();\n            }\n        }\n    }\n#endif\n}", "CodeBleu_score": 47.957932908702894}, {"code": "void updateChargingEnabled(){\n\t#ifdef ENABLE_CHARGING\n    if (charging_allowed &&!charging_enabled) {\n        // If charging is not allowed, retry enabling charging after a delay.\n        if (millis() - last_charging_enabled_millis > CHARGING_RETRY_DELAY) {\n            // Check conditions again to decide whether to enable or continue disabling charging.\n            if (checkShouldCharge()) {\n                // If conditions are good, enable charging.\n                charging_enabled = true;\n                last_charging_enabled_millis = millis();\n            }\n        }\n    } else if (!charging_allowed && charging_enabled) {\n        // If charging is allowed but should not continue, disable charging and record the time.\n        charging_enabled = false;\n        last_charging_enabled_millis = millis();\n    }\n#endif\n}", "CodeBleu_score": 41.80103020156813}, {"code": "void updateChargingEnabled(){\n\t#ifdef ENABLE_CHARGING_MODULE\n    // If charging is allowed, but should not continue, disable it and record the time.\n    if (charging_enabled &&!charging_allowed &&!charging_disabled) {\n        charging_disabled = true;\n        charging_disabled_time = millis();\n    }\n\n    // If charging is not allowed, retry enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n    if (!charging_enabled &&!charging_allowed && charging_disabled && (millis() - charging_disabled_time > 5000)) {\n        charging_disabled = false;\n    }\n\n    // If charging is allowed, enable it.\n    if (charging_enabled &&!charging_allowed) {\n        charging_enabled = false;\n    }\n\n    if (charging_allowed &&!charging_enabled &&!charging_disabled) {\n        charging_enabled = true;\n    }\n#endif\n}", "CodeBleu_score": 43.9146405807446}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ENABLE_ROS\n    if (ROS_running && size >= 4) {\n        uint32_t crc = crc32(0, (uint8_t *) message, size - 4);\n        memcpy(message + size - 4, &crc, 4);\n        packetSerial.send((uint8_t *) message, size);\n    }\n#endif\n}", "CodeBleu_score": 45.10957487073668}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ROS_running && size >= 4) {\n\t\t// calculate CRC\n\t\tuint16_t crc = 0;\n\t\tfor (int i = 0; i < size - 2; i++) {\n\t\t\tcrc = _crc_xmodem_update(crc, ((uint8_t*) message)[i]);\n\t\t}\n\t\t((uint8_t*) message)[size - 2] = crc & 0xFF;\n\t\t((uint8_t*) message)[size - 1] = crc >> 8;\n\t\t// send message\n\t\tpacketSerial.send((uint8_t*) message, size);\n\t}\n}", "CodeBleu_score": 56.92230048686966}, {"code": "void sendMessage(void *message, size_t size){\n\t#ifdef ROS_RUNNING\n    if (size < 4) return;\n    uint16_t crc = calcCRC(message, size);\n    memcpy(message + size, &crc, 2);\n    packetSerial.send(message, size + 2);\n#endif\n}", "CodeBleu_score": 34.490999772644166}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t// initialize the serial communication for the sound module\n\tsoundSerial.begin(9600);\n\n\t// clear any existing data in the buffer\n\tsoundSerial.flush();\n\n\t// initialize the sound module and retrieve the number of sound files available on the SD card\n\tmyMP3.begin(soundSerial);\n\tthis->anzSoundfiles = myMP3.readFileCounts();\n\n\t// check if there are any sound files available on the SD card\n\tif (this->anzSoundfiles > 0) {\n\t\t// set the sound_available flag to true, indicating that there are sound files available\n\t\tthis->sound_available = true;\n\t\treturn true;\n\t}\n\telse {\n\t\t// set the sound_available flag to false, indicating that there are no sound files available\n\t\tthis->sound_available = false;\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 55.61305366067242}, {"code": "bool MP3Sound::begin(){\n\t\n//    // initialize the serial communication for the sound module\n//    soundSerial.begin(9600);\n//    soundSerial.clear();\n//\n//    // initialize the sound module\n//    myMP3.begin(soundSerial);\n//    myMP3.volume(30);\n//\n//    // get the number of sound files available on the SD card\n//    this->anzSoundfiles = myMP3.readFileCounts();\n//\n//    // check if there are one or more sound files available\n//    if (this->anzSoundfiles > 0) {\n//        this->sound_available = true;\n//    }\n//\n//    return this->sound_available;\n    return true;\n}", "CodeBleu_score": 2.4518448130960926}, {"code": "bool MP3Sound::begin(){\n\t#ifdef DEBUG\n    Serial.println(F(\"MP3Sound::begin\"));\n#endif\n\n    // initialize the serial port for the sound module\n    soundSerial.begin(9600);\n\n    // clear any existing data in the serial buffer\n    while (soundSerial.available()) {\n        soundSerial.read();\n    }\n\n    // initialize the sound module\n    myMP3.begin(soundSerial);\n\n    // check if the sound module is ready\n    if (!myMP3.begin(soundSerial)) {\n        Serial.println(F(\"MP3 Sound module not found!\"));\n        return false;\n    }\n\n    // retrieve the number of sound files available on the SD card\n    this->anzSoundfiles = myMP3.readFileCounts();\n\n    // check if there are any sound files available\n    if (this->anzSoundfiles == 0) {\n        Serial.println(F(\"No sound files found on the SD card!\"));\n        return false;\n    }\n\n    // the sound module is ready and there are sound files available\n    this->sound_available = true;\n    return true;\n}", "CodeBleu_score": 51.12586209455545}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\t// check if an MP3 is playing\n\tif (myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\n\t// check if there are any active sounds\n\tif (active_sounds.size() == 0) {\n\t\treturn 0;\n\t}\n\n\t// play the last sound from the active sounds list\n\tmyMP3.play(active_sounds.back());\n\tactive_sounds.pop_back();\n\n\treturn active_sounds.size();\n}", "CodeBleu_score": 45.758123995604585}, {"code": "int MP3Sound::processSounds(){\n\t\n//    if(active_sounds.size() == 0) return 0;\n//    if(myMP3.isPlaying()) return active_sounds.size();\n\n    if(active_sounds.size() == 0) return 0;\n    if(myMP3.isPlaying()) return active_sounds.size();\n\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    return active_sounds.size();\n\n}", "CodeBleu_score": 56.26931381106145}, {"code": "int MP3Sound::processSounds(){\n\t\n//    if (this->playing) {\n//        return active_sounds.size();\n//    }\n    if (active_sounds.size() == 0) {\n        return 0;\n    }\n\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n\n    return active_sounds.size();\n}", "CodeBleu_score": 39.5050105582209}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t", "CodeBleu_score": 6.48713104527464}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (c->enable) {\n      request_write_uchar(r, C_SET_SAMPLING_PERIOD);\n      request_write_uint16(r, c->sampling_period);\n      c->enable = false;  // done\n    }\n    return true;\n  }\n#else\n  // memory mapped files\n  AbstractCamera *c = d->pdata;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    // cleanup\n    if (c->enable) {\n      request_write_uchar(r, C_SET_SAMPLING_PERIOD);\n      request_write_uint16(r, c->sampling_period);\n      c->enable = false;  // done\n    }\n    // new\n    int fd = request_read_int32(r);\n    int size = request_read_int32(r);\n    int offset = request_read_int32(r);\n    int prot = request_read_int32(r);\n    int flags = request_read_int32(r);\n    int mode = request_read_int32(r);\n    c->enable = true;\n    c->sampling_period = request_read_uint16(r);\n    c->file_descriptor = fd;\n    c->file_size = size;\n    c->file_offset = offset;\n    c->file_prot = prot;\n    c->file_flags = flags;\n    c->file_mode = mode;\n    return true;\n  }\n#endif\n  return false;\n}", "CodeBleu_score": 43.043055747269776}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t", "CodeBleu_score": 6.48713104527464}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tifdef _WIN32\n  AbstractCamera *c = d->pdata;\n  if (c)\n    return c->height;\n  else\n    return -1;\n#else\n  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *c = d->pdata;\n  if (c)\n    height = c->height;\n  robot_mutex_unlock();\n  return height;\n#endif\n}", "CodeBleu_score": 56.664255524641106}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t*\n * This function, wb_abstract_camera_get_height, retrieves the height of an abstract camera associated with a given device.\nIt locks a mutex, accesses the height from the camera's data if available, unlocks the mutex, and returns the height or -1 if the camera data is not available.\n */\n  int height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 59.6467126339512}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tAbstractCamera *c = d->pdata;\n\tint height = -1;\n\trobot_mutex_lock();\n\tif (c)\n\t\theight = c->height;\n\trobot_mutex_unlock();\n\treturn height;\n}", "CodeBleu_score": 58.52535930249672}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tdef _WIN32\n  // The mutex is not supported on Windows.\n  return 0;\n#else\n  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    result = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n#endif\n}", "CodeBleu_score": 66.48506862809228}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t result = 0;\nrobot_mutex_lock();\nconst Accelerometer *dev = accelerometer_get_struct(tag);\nif (dev)\nresult = dev->sampling_period;\nelse\nfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\nrobot_mutex_unlock();\nreturn result;\n}", "CodeBleu_score": 67.36297258690965}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t * This function, wb_accelerometer_get_sampling_period, retrieves the sampling period of an accelerometer given its device tag.\nIt locks a mutex, gets the accelerometer structure, and if valid, sets the sampling period from the structure.\nIf the device tag is invalid, it prints an error message.\nFinally, it unlocks the mutex and returns the sampling period.\n */\n  int result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 62.20584046468157}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t//  const char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n//  string dms_str = dms;\n//  free((void *) dms);\n//  return dms_str;\n}", "CodeBleu_score": 3.259132699907477}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring dmsString = \"\";\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tif (dms) {\n\t\tdmsString = dms;\n\t\tfree(dms);\n\t}\n\treturn dmsString;\n}", "CodeBleu_score": 45.09832388549095}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t#ifdef _WIN32\n  char *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dms(dmsString);\n  free(dmsString);\n  return dms;\n#else\n  string dms;\n  char buffer[256];\n  if (wb_gps_convert_to_degrees_minutes_seconds(decimalDegree, buffer, sizeof(buffer)) == WB_SUCCESS)\n    dms = buffer;\n  return dms;\n#endif\n}", "CodeBleu_score": 41.93624250828372}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass,\"argument not a box\");\n\tconst dReal *const s = ((dxBox*) g)->side;\n\tdReal p[3];\n\tp[0] = x - ((dxBox*) g)->pos[0];\n\tp[1] = y - ((dxBox*) g)->pos[1];\n\tp[2] = z - ((dxBox*) g)->pos[2];\n\tdReal d = 0;\n\tif (p[0] < -s[0]) {\n\t\td = p[0] + s[0];\n\t\tplane[0] = -1;\n\t} else if (p[0] > s[0]) {\n\t\td = p[0] - s[0];\n\t\tplane[0] = 1;\n\t}\n\tif (p[1] < -s[1]) {\n\t\td = p[1] + s[1];\n\t\tplane[1] = -1;\n\t} else if (p[1] > s[1]) {\n\t\td = p[1] - s[1];\n\t\tplane[1] = 1;\n\t}\n\tif (p[2] < -s[2]) {\n\t\td = p[2] + s[2];\n\t\tplane[2] = -1;\n\t} else if (p[2] > s[2]) {\n\t\td = p[2] - s[2];\n\t\tplane[2] = 1;\n\t}\n\tplane[3] = d;\n}", "CodeBleu_score": 32.57973076151316}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass,\"argument not a box\");\n\n\tdxBox *b = (dxBox *) g;\n\n\tdReal s[3];\n\tdReal d;\n\n\t// compute the relative position of the point to the box center\n\tdVector3 pos;\n\tdGeomBoxPointDepth (g, x, y, z, pos);\n\n\t// compute the distance from the point to the box center\n\td = dVector3Length (pos);\n\n\t// check each axis for proximity to the box's surface\n\ts[0] = d - b->side[0] * 0.5;\n\ts[1] = d - b->side[1] * 0.5;\n\ts[2] = d - b->side[2] * 0.5;\n\n\t// find the closest surface\n\tdReal max = s[0];\n\tdReal max_index = 0;\n\tdReal min = s[1];\n\tdReal min_index = 1;\n\tdReal tmp;\n\tif (s[2] > max) {\n\t\tmax = s[2];\n\t\tmax_index = 2;\n\t}\n\tif (s[2] < min) {\n\t\tmin = s[2];\n\t\tmin_index = 2;\n\t}\n\n\t// set the plane's normal\n\tswitch (max_index) {\n\tcase 0:\n\t\tplane[0] = -1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tbreak;\n\tcase 1:\n\t\tplane[0] = 0;\n\t\tplane[1] = -1;\n\t\tplane[2] = 0;\n\t\tbreak;\n\tcase 2:\n\t\tplane[0] = 0;\n\t\tplane[1] = 0;\n\t\tplane[2] = -1;\n\t\tbreak;\n\t}\n\n\t// set the plane's distance\n\tplane[3] = d - b->side[max_index] * 0.5;\n}", "CodeBleu_score": 37.99191332880662}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\n\tdVector3 rel;\n\tdVector3 side;\n\tdVector3 normal;\n\tdReal dist;\n\tdReal dot;\n\n\tconst dReal *const s = ((dxBox*) g)->side;\n\tconst dReal *const c = ((dxBox*) g)->center;\n\n\trel[0] = x - c[0];\n\trel[1] = y - c[1];\n\trel[2] = z - c[2];\n\n\t// find the closest surface\n\tdVectorSet (normal, 0, 0, 0);\n\tdist = 0;\n\tdot = dFabs (rel[0]);\n\tif (dot > s[0] * 0.5) {\n\t\tdot = s[0] * 0.5 - dot;\n\t\tnormal[0] = rel[0] < 0? -1 : 1;\n\t\tdist = dot;\n\t}\n\tdot = dFabs (rel[1]);\n\tif (dot > s[1] * 0.5) {\n\t\tdot = s[1] * 0.5 - dot;\n\t\tnormal[1] = rel[1] < 0? -1 : 1;\n\t\tdist = dot;\n\t}\n\tdot = dFabs (rel[2]);\n\tif (dot > s[2] * 0.5) {\n\t\tdot = s[2] * 0.5 - dot;\n\t\tnormal[2] = rel[2] < 0? -1 : 1;\n\t\tdist = dot;\n\t}\n\n\t// set the plane\n\tdVectorScale (normal, 1.0 / dSqrt (dVectorDot (normal, normal)), normal);\n\tplane[0] = normal[0];\n\tplane[1] = normal[1];\n\tplane[2] = normal[2];\n\tplane[3] = dist;\n}", "CodeBleu_score": 39.80628147954235}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdIASSERT (box);\ndIASSERT (fluidPlane);\ndIASSERT (flags & ~dxImmersionDisabled);\ndIASSERT (immersion);\nsBoxImmersionData data (box, fluidPlane, flags, immersion);\nreturn data.performImmersionChecking ();\n}", "CodeBleu_score": 54.541437133012494}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdIASSERT (box && fluidPlane && immersion && box->body &&\n          (flags & (dxImmersionNoOutline | dxImmersionNoBuoyancy)) == 0);\nsBoxImmersionData data (box, fluidPlane, flags, immersion);\nreturn data.performImmersionChecking ();\n}", "CodeBleu_score": 57.72565282451288}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdIASSERT (box->body);\ndIASSERT (fluidPlane);\ndIASSERT (immersion);\ndIASSERT (flags >= 0);\ndIASSERT (flags <= dxImmersionOutlineDisabled);\ndIASSERT (flags & dxImmersionCheck);\n\nsBoxImmersionData data (box, fluidPlane, flags, immersion);\nreturn data.performImmersionChecking ();\n}", "CodeBleu_score": 55.11087221918978}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideBoxCapsule(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tdxBox *const box = (dxBox *) o1;\n\tdxCapsule *const capsule = (dxCapsule *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n\treturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 96.15282584244419}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->capsule, \"The first argument of dImmerseBoxCapsule has no body or the second has no capsule\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideBoxCapsule (o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tdxBox *const box = (dxBox *) o1;\n\tdxCapsule *const capsule = (dxCapsule *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane (capsule, fluidPlane);\n\n\treturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 92.9311400612475}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideCapsuleBox (o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tdxBox *const box = (dxBox *) o1;\n\tdxCapsule *const capsule = (dxCapsule *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane (capsule, fluidPlane);\n\n\treturn dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 95.33913015423813}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tstatic const int n = 50;\nstatic const dReal singularityFactor = 0.9;\n\nconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\nconst dReal end = asin(sinTheta1);\nconst dReal singularityStart = singularityFactor * end;\ndReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\nvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\nreturn 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.37044387586516}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.04166660842034}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, end, n, data);\n\treturn 2.0 * m_fRadiusSquare * volume;\n}", "CodeBleu_score": 88.04166660842034}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst dReal singularityStart = singularityFactor * sinTheta1;\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tdReal xBuoyancyCenter = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\txBuoyancyCenter += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\n\treturn xBuoyancyCenter / volume;\n}", "CodeBleu_score": 64.72220937320436}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst dReal singularityStart = singularityFactor * sinTheta1;\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tdReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\tx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, sinTheta1, n, data);\n\treturn x / m_fRadiusSquare - volume;\n}", "CodeBleu_score": 65.09265648920038}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tstatic const int n = 50;\n\tstatic const dReal singularityFactor = 0.9;\n\n\tconst sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n\tconst dReal end = asin(sinTheta1);\n\tconst dReal singularityStart = singularityFactor * end;\n\tdReal x = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(0.0, singularityStart, n, data);\n\tx += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(singularityStart, end, n, data);\n\treturn x * m_fRadiusSquare / volume;\n}", "CodeBleu_score": 65.66685415983609}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideTrimeshCapsule(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n\treturn dImmerseCapsule(capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 85.64520920464062}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideCapsuleTrimesh(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n\treturn dImmerseCapsule(capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 85.6676886340122}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n\n\tdContactGeom c[1];\n\tconst int collision = dCollideTrimeshCapsule(o1, o2, 1, c, sizeof(dContact));\n\tif (collision == 0)\n\t\treturn 0;\n\n\tconst dxCapsule *const capsule = (dxCapsule *) o1;\n\tdxTriMesh *const trimesh = (dxTriMesh *) o2;\n\n\timmersion->g1 = o1;\n\timmersion->g2 = o2;\n\n\tdVector4 fluidPlane;\n\tdGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n\n\treturn dImmerseCapsule(capsule, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 85.64520920464062}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\tif (!getDuration(duration_ms_)) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\ttimer_waiting_ = true;\n\ttimer_.start(duration_ms_, [this](){\n\t\tthis->timer_waiting_ = false;\n\t\tthis->emitSignal(\"wakeup\");\n\t});\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 24.693777032664325}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tauto duration = getInput<int>(\\\"duration\\\");\n\tif (duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\ttimer_waiting_ = true;\n\ttimer_.expires_from_now(boost::posix_time::milliseconds(duration));\n\ttimer_.async_wait(boost::bind(&SleepNode::onTimer, this, boost::asio::placeholders::error));\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 31.77314568947891}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (this->sleep_duration_ms_ <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tthis->timer_waiting_ = true;\n\tthis->timer_.expires_from_now(boost::posix_time::milliseconds(this->sleep_duration_ms_));\n\tthis->timer_.async_wait(boost::bind(&SleepNode::onTimer, this, _1));\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 14.536383988555212}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\n// Retrieve the entry from the blackboard\nauto entry = blackboard_->get<Blackboard::Entry>(entry_key_);\nif (entry == nullptr) {\nreturn NodeStatus::FAILURE;\n}\n\n// Lock the mutex associated with the entry\nstd::lock_guard<std::mutex> lock(entry->mutex);\n\n// Compare the current sequence ID with the stored sequence ID\nif (entry->sequence_id == entry->stored_sequence_id) {\nreturn NodeStatus::FAILURE;\n}\n\n// Update the stored sequence ID\nentry->stored_sequence_id = entry->sequence_id;\n\nreturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 35.678948359830144}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard) {\n\t\tauto entry = blackboard->get<std::string>(entry_key_);\n\t\tif (entry) {\n\t\t\tauto entry_mutex = blackboard->get<std::mutex>(entry_key_ + \\\"_mutex\\\");\n\t\t\tif (entry_mutex) {\n\t\t\t\tstd::lock_guard<std::mutex> lock(*entry_mutex);\n\t\t\t\tauto seq_id = blackboard->get<int>(entry_key_ + \\\"_sequence_id\\\");\n\t\t\t\tif (seq_id!= entry_id_) {\n\t\t\t\t\tentry_id_ = seq_id;\n\t\t\t\t\treturn NodeStatus::SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.894348159772264}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tconst auto& blackboard = blackboard_;\n\tconst auto entry_key = entry_key_;\n\tconst auto entry = blackboard.get(entry_key);\n\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tconst auto mutex = entry->getMutex();\n\tstd::unique_lock<std::mutex> lock(mutex);\n\n\tif (entry->getSequenceID()!= entry->getPreviousSequenceID()) {\n\t\tentry->setPreviousSequenceID(entry->getSequenceID());\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 46.07132243329695}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tccess_threshold_ < 0) {\n\t\treturn std::max(0, success_threshold_ + children_nodes_.size());\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 41.48309815262282}, {"code": "size_t ParallelNode::successThreshold() const{\n\tccess_threshold_ < 0) {\n\t\treturn std::max(size_t(0), children_nodes_.size() + success_threshold_);\n\t} else {\n\t\treturn success_threshold_;\n\t}\n}", "CodeBleu_score": 46.95023079315258}, {"code": "size_t ParallelNode::successThreshold() const{\n\tccess_threshold_ < 0) {\n\t\treturn std::max(size_t(0), children_nodes_.size() + success_threshold_);\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 42.25869686307968}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\tif (_p->heartbeat_last_time.time_since_epoch().count() == 0) {\n\t\t\t// if we have not received a heartbeat yet, skip\n\t\t\tcontinue;\n\t\t}\n\t\t// check if heartbeat is still active\n\t\tif (std::chrono::duration_cast<std::chrono::seconds>(\n\t\t\t\tstd::chrono::system_clock::now().time_since_epoch() - _p->heartbeat_last_time)\n\t\t\t\t.count() > _p->heartbeat_timeout) {\n\t\t\t// if heartbeat is inactive, disable all breakpoints\n\t\t\tenableAllHooks(false);\n\t\t} else {\n\t\t\t// if heartbeat is active, enable all breakpoints\n\t\t\tenableAllHooks(true);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.4819683472258}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\t\tif(_p->heartbeat_status == HeartbeatStatus::ACTIVE) {\n\t\t\tif(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()) - _p->last_heartbeat_time > _p->heartbeat_timeout) {\n\t\t\t\t_p->heartbeat_status = HeartbeatStatus::INACTIVE;\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t} else {\n\t\t\tif(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()) - _p->last_heartbeat_time > _p->heartbeat_timeout) {\n\t\t\t\t_p->heartbeat_status = HeartbeatStatus::ACTIVE;\n\t\t\t\tenableAllHooks(true);\n\t\t\t}\n\t\t}\n\t\tlk.unlock();\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t}\n}", "CodeBleu_score": 36.96695084237285}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\tstd::unique_lock<std::mutex> lk(_p->status_mutex);\n\twhile (_p->heartbeat_active) {\n\t\tauto now = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch());\n\t\tif (now - _p->last_heartbeat_time > std::chrono::seconds(10)) {\n\t\t\t_p->heartbeat_active = false;\n\t\t}\n\t\telse {\n\t\t\t_p->heartbeat_active = true;\n\t\t}\n\t\tlk.unlock();\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tlk.lock();\n\t}\n}", "CodeBleu_score": 42.72075199979713}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Parse the input string of blackboard names\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\t// Create a JSON object to store the blackboard dumps\n\tnlohmann::json bb_dump;\n\n\t// Iterate through the blackboard names\n\tfor (const auto& bb_name : bb_names) {\n\t\t// Find the corresponding subtree\n\t\tauto subtree = _p->blackboard_manager->findSubtree(bb_name);\n\n\t\t// If the subtree is valid, export the blackboard to JSON and add it to the JSON object\n\t\tif (subtree) {\n\t\t\tauto bb_json = subtree->exportBlackboardToJSON();\n\t\t\tbb_dump[bb_name] = bb_json;\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format and return it as a vector of uint8_t\n\treturn nlohmann::json::to_msgpack(bb_dump);\n}", "CodeBleu_score": 48.7098097113136}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Split the input string into a vector of blackboard names\n\tstd::vector<std::string> bb_names;\n\tstd::stringstream ss(bb_list);\n\tstd::string bb_name;\n\twhile (std::getline(ss, bb_name, ',')) {\n\t\tbb_names.push_back(bb_name);\n\t}\n\n\t// Create a JSON object to store the blackboard dumps\n\tnlohmann::json dump_json;\n\n\t// Iterate through the blackboard names and export them to JSON\n\tfor (const auto& bb_name : bb_names) {\n\t\t// Find the blackboard subtree\n\t\tauto subtree = _p->blackboard_tree.find(bb_name);\n\t\tif (subtree == _p->blackboard_tree.end()) {\n\t\t\t// If the subtree is not found, skip it\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Lock the subtree\n\t\tstd::unique_lock<std::mutex> subtree_lock(subtree->second->mutex);\n\n\t\t// Export the blackboard to JSON\n\t\tnlohmann::json bb_json;\n\t\tsubtree->second->exportBlackboard(bb_json);\n\n\t\t// Add the blackboard dump to the JSON object\n\t\tdump_json[bb_name] = bb_json;\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tauto dump_mp = dump_json.dump();\n\n\t// Return the MessagePack dump as a vector of uint8_t\n\treturn std::vector<uint8_t>(dump_mp.begin(), dump_mp.end());\n}", "CodeBleu_score": 48.034175027142055}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Split the input string of blackboard names into a vector of strings\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\n\t// Create a JSON object to store the blackboard dumps\n\tnlohmann::json bb_dump;\n\n\t// Iterate through the blackboard names and generate the dumps\n\tfor (const std::string& bb_name : bb_names) {\n\t\t// Find the blackboard subtree\n\t\tauto subtree = _p->blackboard_tree.find(bb_name);\n\t\tif (subtree == _p->blackboard_tree.end()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Lock the blackboard subtree\n\t\tstd::unique_lock<std::mutex> subtree_lock(subtree->second.mutex);\n\n\t\t// Export the blackboard to JSON\n\t\tnlohmann::json bb_json = subtree->second.blackboard->to_json();\n\n\t\t// Add the blackboard dump to the JSON object\n\t\tbb_dump[bb_name] = bb_json;\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> msgpack_dump = bb_dump.dump();\n\n\treturn msgpack_dump;\n}", "CodeBleu_score": 49.59886770392442}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto it = _p->pre_hooks.find(node_uid);\n\tif (it == _p->pre_hooks.end()) {\n\t\treturn false;\n\t}\n\tstd::shared_ptr<Monitor::Hook> hook = it->second;\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\tif (hook->mode!= Monitor::Hook::Mode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->desired_status = result;\n\thook->remove_when_done = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 50.82874116146597}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t#if BT_HAVE_DEBUG_HOOKS\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto it = _p->pre_hooks.find(node_uid);\n  if (it == _p->pre_hooks.end()) {\n    return false;\n  }\n  auto hook = it->second;\n  std::unique_lock<std::mutex> lk2(hook->mutex);\n  hook->desired_status = result;\n  hook->remove_when_done = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n#endif\n  return true;\n}", "CodeBleu_score": 49.181420983843594}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t#ifdef BT_DEBUG_HOOKS\n  std::cout << \"Groot2Publisher::unlockBreakpoint\" << std::endl;\n#endif\n\n  // search for the node by its UID\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n\n  // lock the weak pointer\n  if (auto node = it->second.lock()) {\n    // lock the mutex\n    std::unique_lock<std::mutex> lk(node->getHook(pos)->mutex);\n\n    // set the desired status and removal flag\n    node->getHook(pos)->desired_status = result;\n    node->getHook(pos)->remove_when_done = remove;\n\n    // mark it as ready\n    node->getHook(pos)->ready = true;\n\n    // notify all waiting threads\n    node->getHook(pos)->wakeup.notify_all();\n  }\n\n  return true;\n}", "CodeBleu_score": 50.515653155130494}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tdeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tresetHaltRequested();\n\n\t\tstd::thread t([this]() {\n\t\t\ttry {\n\t\t\t\ttick();\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cerr << \"Error in ThreadedAction::executeTick: \" << e.what() << std::endl;\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t}\n\t\t});\n\t\tt.detach();\n\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\tif (prev_status == NodeStatus::RUNNING) {\n\t\tif (isHaltRequested()) {\n\t\t\tonHalted();\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t} else {\n\t\t\tprev_status = NodeStatus::RUNNING;\n\t\t}\n\t}\n\n\treturn prev_status;\n}", "CodeBleu_score": 38.513964968715406}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t", "CodeBleu_score": 3.4990226674576395}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tdeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tresetHaltRequested();\n\t\tstd::thread thread(tick_functor_);\n\t\tthread.detach();\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\t//------------------------------------------\n\tif (prev_status == NodeStatus::RUNNING) {\n\t\tNodeStatus new_status = onRunning();\n\t\tif (new_status == NodeStatus::IDLE) {\n\t\t\tthrow LogicError(\"ThreadedAction::onRunning() must not return IDLE\");\n\t\t}\n\t\treturn new_status;\n\t}\n\treturn prev_status;\n}", "CodeBleu_score": 32.767972741308085}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif(!root_node) {\n\t\tthrow LogicError(\"The root node is nullptr\");\n\t}\n\n\tconst std::string separator = \"----------------------------------------\";\n\n\tauto print = [&stream, &separator](const TreeNode* node, int depth) {\n\t\tstd::string indent(depth * 4,'');\n\t\tstream << indent << node->name() << std::endl;\n\n\t\tif(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor(const auto& child : control->children()) {\n\t\t\t\tprint(static_cast<const TreeNode*>(child), depth + 1);\n\t\t\t}\n\t\t} else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprint(decorator->child(), depth + 1);\n\t\t}\n\t};\n\n\tstream << separator << std::endl;\n\tprint(root_node, 0);\n\tstream << separator << std::endl;\n}", "CodeBleu_score": 53.65935917387752}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (!root_node) {\n\t\tthrow LogicError(\"root_node is nullptr\");\n\t}\n\n\tstd::string separator = \"---------------------------------------------------------\";\n\n\tauto print_node = [&](const TreeNode* node) {\n\t\tstd::string indent(node->depth() * 2,'');\n\t\tstream << indent << node->name() << std::endl;\n\n\t\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children()) {\n\t\t\t\tprint_node(static_cast<const TreeNode*>(child));\n\t\t\t}\n\t\t}\n\t\telse if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprint_node(decorator->child());\n\t\t}\n\t};\n\n\tstream << separator << std::endl;\n\tprint_node(root_node);\n\tstream << separator << std::endl;\n}", "CodeBleu_score": 49.92784757344641}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\nstream << \"\u250c\" << std::string(root_node->depth() * 2, '\u2500') << \"\u2510\n\";\nstream << \"\u2502\" << std::string(root_node->depth() * 2,'') << root_node->name() << \"\n\";\n\nauto print_children = [root_node, &stream](const TreeNode* node) {\n\nif(auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor(const auto& child : control->children()) {\nprintTreeRecursively(child, stream);\n}\n}\nelse if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\nprintTreeRecursively(decorator->child(), stream);\n}\n};\n\napplyRecursiveVisitor(root_node, print_children);\n\nstream << \"\u2514\" << std::string(root_node->depth() * 2, '\u2500') << \"\u2518\n\";\n}", "CodeBleu_score": 51.29806052214637}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\nthrow std::runtime_error(\\\"applyRecursiveVisitor: node is null\\\");\n}\nvisitor(node);\nif (node->type() == TreeNodeType::ControlNode) {\nconst ControlNode* control_node = static_cast<const ControlNode*>(node);\nfor (const auto& child : control_node->children()) {\napplyRecursiveVisitor(child, visitor);\n}\n} else if (node->type() == TreeNodeType::DecoratorNode) {\nconst DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\napplyRecursiveVisitor(decorator_node->child(), visitor);\n}\n}", "CodeBleu_score": 57.019059546540205}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t#ifdef BT_USE_ASSERT\n  if (!node) {\n    throw std::logic_error(\n        \"applyRecursiveVisitor() called with a null pointer\");\n  }\n#endif\n\n  visitor(node);\n\n  if (node->type() == TreeNode::Type::ControlNode) {\n    const ControlNode* control_node = dynamic_cast<const ControlNode*>(node);\n    for (const auto& child : control_node->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (node->type() == TreeNode::Type::DecoratorNode) {\n    const DecoratorNode* decorator_node = dynamic_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decorator_node->child().get(), visitor);\n  }\n}", "CodeBleu_score": 58.51264527680038}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t#ifdef BT_USE_ASSERT\n  if (node == nullptr) {\n    throw std::logic_error(\"applyRecursiveVisitor: node is null\");\n  }\n#endif\n\n  visitor(node);\n\n  if (node->isControlNode()) {\n    const ControlNode* controlNode = dynamic_cast<const ControlNode*>(node);\n    for (const TreeNode* child : controlNode->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->isDecoratorNode()) {\n    const DecoratorNode* decoratorNode = dynamic_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decoratorNode->child(), visitor);\n  }\n}", "CodeBleu_score": 59.07090878267047}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\n/*\n * This function, BehaviorTreeFactory::registerBuilder, registers a new node builder with a given manifest.\nIt first checks if the registration ID already exists in the builders map.\nIf the ID is already registered, it throws a BehaviorTreeException.\nIf not, it inserts the builder and manifest into their respective maps using the registration ID.\n */\n  if (_p->builders.count(manifest.ID)) {\n    throw BehaviorTreeException(\n        \"The registration ID [\" + manifest.ID +\n        \"] is already used by a registered node\");\n  }\n\n  _p->builders[manifest.ID] = builder;\n  _p->manifests[manifest.ID] = manifest;\n}", "CodeBleu_score": 45.39392754859717}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t#ifdef USE_BTCPP3_OLD_NAMES\n  if (manifest.registration_ID == \\\"SequenceStar\\\") {\n    throw BehaviorTreeException(\\\"You can not register the old name for SequenceWithMemory\\\");\n  }\n#endif\n\n  if (builtinNodes().count(manifest.registration_ID)) {\n    throw LogicError(\n        \"You can not register the builtin registration ID [\",\n        manifest.registration_ID, \"]\");\n  }\n\n  if (_p->builders.count(manifest.registration_ID)) {\n    throw LogicError(\n        \"You can not register the registration ID [\",\n        manifest.registration_ID,\n        \"] twice. This ID is already registered\");\n  }\n\n  _p->builders[manifest.registration_ID] = builder;\n  _p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 49.736430836442494}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t/*\n * This function, BehaviorTreeFactory::registerBuilder, registers a new node builder with a given manifest.\nIt first checks if the registration ID already exists in the builders map.\nIf the ID is already registered, it throws a BehaviorTreeException.\nIf not, it inserts the builder and manifest into their respective maps using the registration ID.\n */\n  if (_p->builders.count(manifest.registration_ID)) {\n    throw BehaviorTreeException(\"Registration ID [\", manifest.registration_ID,\n                                \"] already exists\");\n  }\n  _p->builders[manifest.registration_ID] = builder;\n  _p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 53.84179601749265}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t*\n * This function, BehaviorTreeFactory::registerSimpleAction, registers a simple action node with a specified ID, tick functor, and ports list.\n * It creates a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n * It then creates a TreeNodeManifest with the action node type, ID, and ports list.\n * Finally, it calls registerBuilder to register the manifest and builder.\n */\n  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 81.03201788171587}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t*\n * This function, BehaviorTreeFactory::registerSimpleAction, registers a simple action node with a specified ID, tick functor, and ports list.\n * It creates a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n * It then creates a TreeNodeManifest with the action node type, ID, and ports list.\n * Finally, it calls registerBuilder to register the manifest and builder.\n */\n  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports), {}};\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 74.73006875567077}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t*\n * This function, BehaviorTreeFactory::registerSimpleAction, registers a simple action node with a specified ID, tick functor, and ports list.\n * It creates a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n * It then creates a TreeNodeManifest with the action node type, ID, and ports list.\n * Finally, it calls registerBuilder to register the manifest and builder.\n */\n  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 81.03201788171587}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t/*\n * This function, BlackboardBackup, creates a backup of the blackboards in a given tree.\nIt initializes a vector of blackboard pointers and reserves space based on the number of subtrees.\nFor each subtree, it creates a new blackboard, clones the contents of the subtree's blackboard into the new blackboard, and adds it to the vector.\nThe function returns the vector of blackboard backups.\n */\n  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (auto& subtree : tree.subtrees) {\n    auto new_blackboard = std::make_shared<Blackboard>();\n    new_blackboard->cloneInto(*(subtree->blackboard));\n    backup.push_back(new_blackboard);\n  }\n  return backup;\n}", "CodeBleu_score": 57.278158274216594}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tbackup.push_back(Blackboard::Ptr(new Blackboard()));\n\t\tsubtree->blackboard->cloneInto(*backup.back());\n\t}\n\treturn backup;\n}", "CodeBleu_score": 63.940593819666525}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t/*\n * This function, BlackboardBackup, creates a backup of the blackboards in a given tree.\nIt initializes a vector of blackboard pointers and reserves space based on the number of subtrees.\nFor each subtree, it creates a new blackboard, clones the contents of the subtree's blackboard into the new blackboard, and adds it to the vector.\nThe function returns the vector of blackboard backups.\n */\n  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (auto& subtree : tree.subtrees) {\n    auto new_blackboard = std::make_shared<Blackboard>();\n    subtree->blackboard->cloneInto(*new_blackboard);\n    backup.push_back(new_blackboard);\n  }\n  return backup;\n}", "CodeBleu_score": 57.40026088558567}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(script);\n\tif (result.has_value()) {\n\t\treturn result.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(result.error());\n\t}\n}", "CodeBleu_score": 66.01586524902739}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (executor.has_value()) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.37918082749243}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t", "CodeBleu_score": 8.428463305663993}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\n// acquire a unique lock on a mutex to ensure thread safety\nstd::unique_lock<std::mutex> lock(_mutex);\n\n// if a library is already loaded, throw a RuntimeError\nif (_handle!= nullptr) {\nthrow RuntimeError(\"Library is already loaded\");\n}\n\n// attempt to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags\n_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n// if the load fails, retrieve the error message and throw a RuntimeError\nif (_handle == nullptr) {\nthrow RuntimeError(std::string(\"dlopen failed: \") + dlerror());\n}\n\n// store the path of the loaded library\n_path = path;\n}", "CodeBleu_score": 52.25988817561029}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_handle!= nullptr) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\t_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (_handle == nullptr) {\n\t\tthrow RuntimeError(std::string(\"Failed to load library: \") + dlerror());\n\t}\n\t_path = path;\n}", "CodeBleu_score": 52.35563932572097}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\nstd::lock_guard<std::mutex> lock(_mutex);\n\nif (_handle) {\nthrow RuntimeError(\"A shared library is already loaded\");\n}\n\n_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\nif (!_handle) {\nthrow RuntimeError(\"dlopen failed: \" + std::string(dlerror()));\n}\n\n_path = path;\n}", "CodeBleu_score": 52.321088567087656}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tauto trimmed = str.trim();\n\tif (trimmed.startsWith('{') && trimmed.endsWith('}')) {\n\t\tif (stripped_pointer) {\n\t\t\t*stripped_pointer = trimmed.substring(1, trimmed.length() - 1);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 22.134321220060656}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tauto stripped_str = str.substr(1, str.length() - 2);\n\tif (stripped_str.empty()) {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped_str;\n\t}\n\treturn true;\n}", "CodeBleu_score": 19.6851552965515}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tauto stripped = str.substr(1, str.size() - 2);\n\tif (stripped.empty()) {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped;\n\t}\n\treturn true;\n}", "CodeBleu_score": 19.648186813678887}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//   double line_cost = 0.0;\n//   LineIterator line_iterator(costmap_, x0, y0, x1, y1, 1, 1, 1);\n\n    //we need to iterate through each point on the line\n    for(unsigned int i = 0; i < line_iterator.size(); ++i){\n      unsigned char point_cost = costmap_.getCost(line_iterator.getX(i), line_iterator.getY(i));\n      if(point_cost == LETHAL_OBSTACLE || point_cost == INSCRIBED_INFLATED_OBSTACLE)\n        return -1.0;\n\n      if(point_cost == NO_INFORMATION)\n        return -2.0;\n\n      if(point_cost > line_cost)\n        line_cost = point_cost;\n    }\n\n    return line_cost;\n  return 0;\n}", "CodeBleu_score": 52.69330847920004}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t", "CodeBleu_score": 4.037265882870389}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t/*\n * This function, CostmapModel::lineCost, calculates the cost of a line between two points (x0, y0) and (x1, y1).\nIt initializes the line cost and iterates through each point on the line using a LineIterator.\nFor each point, it calculates the point cost.\nIf the point cost is negative, it returns the point cost immediately.\nOtherwise, it updates the line cost if the point cost is higher.\nFinally, it returns the total line cost.\n */\n  //initialize the line cost\n  double line_cost = 0.0;\n\n  //create a line iterator\n  LineIterator line_iterator(costmap_, x0, y0, x1, y1, 8, true);\n\n  //iterate through the line\n  for(unsigned int i = 0; i < line_iterator.size(); ++i){\n    //get the point\n    const Point& p = line_iterator.point(i);\n\n    //get the point cost\n    double point_cost = costmap_.getCost(p.x, p.y);\n\n    //if the point is an obstacle, return it immediately\n    if(point_cost < 0)\n      return point_cost;\n\n    //if the point is not an obstacle, update the line cost\n    line_cost = std::max(line_cost, point_cost);\n  }\n\n  //return the line cost\n  return line_cost;\n}", "CodeBleu_score": 48.738231553368685}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t//  if (path.empty()) {\n//    return;\n//  }\n//  nav_msgs::Path path_msg;\n//  path_msg.header.frame_id = path[0].header.frame_id;\n//  path_msg.header.stamp = path[0].header.stamp;\n//  path_msg.poses.resize(path.size());\n//  for (unsigned int i = 0; i < path.size(); ++i) {\n//    path_msg.poses[i] = path[i];\n//  }\n//  pub.publish(path_msg);\n}", "CodeBleu_score": 5.57416675955503}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t/*\n * This function, publishPlan, publishes a given path as a nav_msgs::Path message using a ROS publisher.\nIf the path is empty, it returns without doing anything.\nIt creates a nav_msgs::Path message and initializes its header with the frame_id and timestamp from the first pose in the path.\nThe function then copies each pose from the input path to the path message and publishes it using the provided ROS publisher.\n */\n  if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 85.1189829600958}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\n/*\n * If the path is empty, return without doing anything.\n */\nif (path.empty()) {\nreturn;\n}\n\n/*\n * Create a nav_msgs::Path message and initialize its header with the frame_id and timestamp from the first pose in the path.\n */\nnav_msgs::Path path_msg;\npath_msg.header.frame_id = path[0].header.frame_id;\npath_msg.header.stamp = path[0].header.stamp;\n\n/*\n * Copy each pose from the input path to the path message.\n */\nfor (const auto& pose : path) {\npath_msg.poses.push_back(pose);\n}\n\n/*\n * Publish the path message using the provided ROS publisher.\n */\npub.publish(path_msg);\n}", "CodeBleu_score": 48.97856589057913}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t//  ROS_DEBUG_NAMED(\"move_base\", \\\"Checking if robot has stopped\\\");\n\n  //check for rotation\n  if (fabs(base_odom.twist.twist.angular.z) > rot_stopped_velocity) {\n    //ROS_DEBUG_NAMED(\\\"move_base\\\", \\\"Robot is rotating at %.3f, above threshold of %.3f\\\", base_odom.twist.twist.angular.z, rot_stopped_velocity);\n    return false;\n  }\n\n  //check for translation\n  if (fabs(base_odom.twist.twist.linear.x) > trans_stopped_velocity ||\n      fabs(base_odom.twist.twist.linear.y) > trans_stopped_velocity) {\n    //ROS_DEBUG_NAMED(\\\"move_base\\\", \\\"Robot is moving at (%.3f, %.3f), above thresholds of (%.3f, %.3f)\\\", base_odom.twist.twist.linear.x, base_odom.twist.twist.linear.y, trans_stopped_velocity, trans_stopped_velocity);\n    return false;\n  }\n\n  //ROS_DEBUG_NAMED(\\\"move_base\\\", \\\"Robot has stopped\\\");\n  return true;\n}", "CodeBleu_score": 64.80903275316928}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n// Check if the robot is stopped based on the rotational and translational velocities from the odometry message.\nif (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\nreturn true;\n}\n\nreturn false;\n}", "CodeBleu_score": 64.69254647531619}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n//   ROS_DEBUG(\"rot_stopped_velocity: %f\", rot_stopped_velocity);\n//   ROS_DEBUG(\"trans_stopped_velocity: %f\", trans_stopped_velocity);\n//   ROS_DEBUG(\"base_odom.twist.twist.angular.z: %f\", base_odom.twist.twist.angular.z);\n//   ROS_DEBUG(\"base_odom.twist.twist.linear.x: %f\", base_odom.twist.twist.linear.x);\n\n  if(fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 65.78678550991125}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_) {\nif (restore_defaults) {\nconfig.restoreDefaults();\n}\n} else {\nconfig.setFromConfig(config);\nsetup_ = true;\n}\n\n// Lock the configuration mutex and update the current limits\nboost::unique_lock<boost::mutex> lock(configuration_mutex_);\ncurrent_limits_ = config;\n}", "CodeBleu_score": 47.526141500181424}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_) {\nif (restore_defaults) {\nconfig.restoreDefaults();\n}\n} else {\nconfig.setup(config);\nsetup_ = true;\n}\nboost::unique_lock<boost::mutex> lock(configuration_mutex_);\ncurrent_limits_ = config;\n}", "CodeBleu_score": 47.60255552346985}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_) {\nif (restore_defaults) {\nconfig.restoreDefaults();\n}\nelse {\nconfig.updateFromConfig(config);\n}\n}\nelse {\nconfig.updateFromConfig(config);\nsetup_ = true;\n}\n\n// lock the configuration mutex\nboost::unique_lock<boost::mutex> lock(configuration_mutex_);\ncurrent_limits_ = config;\n}", "CodeBleu_score": 47.03793718748228}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tOS_DEBUG(\"Updating cell (%d, %d)\", current_cell->cx, current_cell->cy);\n  //if the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost\n  if (costmap.getCost(current_cell->cx, current_cell->cy) == costmap_2d::NO_INFORMATION) {\n    current_cell->target_dist = costmap.getCost(current_cell->cx, current_cell->cy);\n    return false;\n  }\n\n  //if the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter\n  float new_target_dist = distToLine(current_cell->cx, current_cell->cy, check_cell->cx, check_cell->cy);\n  if (new_target_dist < current_cell->target_dist) {\n    current_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 47.40209378289423}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\teck the cost of the cell\nunsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n\n//if the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\nif (cost >= costmap_2d::LETHAL_OBSTACLE) {\n  check_cell->target_dist = costmap.getCost(current_cell->cx, current_cell->cy);\n  return false;\n}\n\n//calculate a new target distance and update the cell's target distance if the new distance is shorter\ndouble new_target_dist = sqrt(pow(check_cell->cx - current_cell->cx, 2) + pow(check_cell->cy - current_cell->cy, 2));\nif (new_target_dist < check_cell->target_dist) {\n  check_cell->target_dist = new_target_dist;\n  return true;\n}\n\n//otherwise, return false\nreturn false;\n}", "CodeBleu_score": 65.0355474813142}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t if (current_cell->target_distance == 0) {\n//      current_cell->target_distance = costmap.getCost(current_cell->cx, current_cell->cy);\n//      return true;\n//    }\n//    double check_distance = costmap.getCost(check_cell->cx, check_cell->cy);\n//    if (check_distance == costmap_2d::NO_INFORMATION) {\n//      return false;\n//    }\n//    if (check_distance >= current_cell->target_distance) {\n//      return false;\n//    }\n//    current_cell->target_distance = check_distance;\n//    return true;\n}", "CodeBleu_score": 13.032667162677003}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t/  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  double f_cost = footprintCost(x, y, th, scale, footprint_spec, costmap, world_model);\n\n  if(f_cost < 0){\n    return f_cost;\n  }\n\n  return f_cost;\n}", "CodeBleu_score": 23.181625443558886}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t  ROS_DEBUG(\"footprint_cost\");\n  //check if we're inside the footprint\n  if (!world_model->footprintCost(x, y, th, footprint_spec, scale)) {\n    return -6.0;\n  }\n\n  //check if the footprint is off the map\n  if (!costmap->footprintCost(x, y, footprint_spec, scale)) {\n    return -7.0;\n  }\n\n  //compute the footprint cost at the given position\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec, scale);\n\n  //get the footprint cell cost at the given position\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -8.0;\n  }\n  unsigned char cell_cost = costmap->getCost(mx, my);\n\n  //return the maximum cost\n  return std::max(footprint_cost, (double)cell_cost);\n}", "CodeBleu_score": 50.85301833441065}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic!= odom_topic_) {\nif (odom_topic.empty()) {\nif (odom_sub_) {\nodom_sub_.shutdown();\nodom_sub_.unsubscribe();\n}\n} else {\nodom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n}\nodom_topic_ = odom_topic;\n}\n}", "CodeBleu_score": 35.36870552215514}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic!= odom_topic_) {\nif (odom_topic.empty()) {\nif (sub_) {\nsub_.shutdown();\nsub_.unsubscribe();\n}\n} else {\nsub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n}\nodom_topic_ = odom_topic;\n}\n}", "CodeBleu_score": 34.016403697171505}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_!= odom_topic) {\nif (!odom_topic.empty()) {\nodom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n} else {\nodom_sub_.shutdown();\n}\nodom_topic_ = odom_topic;\n}\n}", "CodeBleu_score": 38.013493963195714}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\ndouble dist_sq = diff.squaredNorm();\ndouble angle = std::abs(std::atan2(diff.y(), diff.x()));\nif (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_ || angle > oscillation_reset_angle_) {\nforward_pos_only_ = false;\nforward_neg_only_ = false;\nstrafe_pos_only_ = false;\nstrafe_neg_only_ = false;\nrot_pos_only_ = false;\nrot_neg_only_ = false;\n}\n}", "CodeBleu_score": 37.64051651424011}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tif (pos.squaredNorm() > oscillation_reset_dist_ * oscillation_reset_dist_) {\nforward_pos_only_ = false;\nforward_neg_only_ = false;\nstrafe_pos_only_ = false;\nstrafe_neg_only_ = false;\nrot_pos_only_ = false;\nrot_neg_only_ = false;\n} else {\ndouble dx = pos(0) - prev(0);\ndouble dy = pos(1) - prev(1);\ndouble d_theta = atan2(dy, dx) - prev(2);\nif (d_theta < 0) {\nd_theta += 2 * M_PI;\n}\nif (d_theta > oscillation_reset_angle_) {\nforward_pos_only_ = false;\nforward_neg_only_ = false;\nstrafe_pos_only_ = false;\nstrafe_neg_only_ = false;\nrot_pos_only_ = false;\nrot_neg_only_ = false;\n}\n}\n}", "CodeBleu_score": 38.144173661281165}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//  if (forward_pos_only_ || forward_neg_only_ || strafe_pos_only_ || strafe_neg_only_ || rot_pos_only_ || rot_neg_only_) {\n//    double dist = (pos - prev).squaredNorm();\n//    double angle = fabs(tf::getYaw(pos) - tf::getYaw(prev));\n//    if (dist > oscillation_reset_dist_ * oscillation_reset_dist_ || angle > oscillation_reset_angle_) {\n//      forward_pos_only_ = false;\n//      forward_neg_only_ = false;\n      strafe_pos_only_ = false;\n      strafe_neg_only_ = false;\n      rot_pos_only_ = false;\n      rot_neg_only_ = false;\n    }\n  }\n}", "CodeBleu_score": 7.678532628343423}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//    printf(\\\"Inserting (%.2f, %.2f)\n\\\", pt.x, pt.y);\n\n    //get the grid coordinates of the point\n    unsigned int gx, gy;\n    if(!gridCoords(pt, gx, gy))\n      return;\n\n    //compute the grid index\n    unsigned int index = gridIndex(gx, gy);\n\n    //check to see if the point is too close to its nearest neighbor\n    unsigned int x_steps = 1;\n    unsigned int y_steps = 1;\n    if(gx > 0)\n      x_steps = 2;\n    if(gy > 0)\n      y_steps = 2;\n    for(unsigned int i = 0; i < y_steps; ++i){\n      for(unsigned int j = 0; j < x_steps; ++j){\n        //if we're not on the current cell, check to see if the point is too close\n        if(i!= 0 || j!= 0){\n          //compute the index of the cell we're checking\n          unsigned int cell_index = index + (i * width_) + j;\n          if(cell_index < cells_.size()){\n            list<geometry_msgs::Point32>& cell = cells_[cell_index];\n            for(list<geometry_msgs::Point32>::iterator it = cell.begin(); it!= cell.end(); ++it){\n              const geometry_msgs::Point32& other_pt = *it;\n              if(ptDistance(pt, other_pt) < resolution_ * 2.0)\n                return;\n            }\n          }\n        }\n      }\n    }\n\n    //if we get here, we can insert the point\n    list<geometry_msgs::Point32>& cell = cells_[index];\n    cell.push_back(pt);\n  }", "CodeBleu_score": 59.896838252015364}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n//  ROS_WARN_NAMED(\"Generator\", \"Sample_Vel %f, %f, %f\", sample_target_vel[0], sample_target_vel[1], sample_target_vel[2]);\n//  ROS_WARN_NAMED(\"Generator\", \"Vel %f, %f, %f\", vel[0], vel[1], vel[2]);\n//  ROS_WARN_NAMED(\"Generator\", \"Acc_Lim %f, %f, %f\", acclimits[0], acclimits[1], acclimits[2]);\n//  ROS_WARN_NAMED(\"Generator\", \"dt %f\", dt);\n\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  // translational velocity\n  if (sample_target_vel[0] > vel[0]) {\n    new_vel[0] = std::min(sample_target_vel[0], vel[0] + acclimits[0] * dt);\n  } else {\n    new_vel[0] = std::max(sample_target_vel[0], vel[0] - acclimits[0] * dt);\n  }\n\n  // rotational velocity\n  if (sample_target_vel[2] > vel[2]) {\n    new_vel[2] = std::min(sample_target_vel[2], vel[2] + acclimits[2] * dt);\n  } else {\n    new_vel[2] = std::max(sample_target_vel[2], vel[2] - acclimits[2] * dt);\n  }\n\n  // rotational velocity\n  if (sample_target_vel[1] > vel[1]) {\n    new_vel[1] = std::min(sample_target_vel[1], vel[1] + acclimits[1] * dt);\n  } else {\n    new_vel[1] = std::max(sample_target_vel[1], vel[1] - acclimits[1] * dt);\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 41.698661776614884}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t//  ROS_WARN_NAMED(\"Generator\", \"Flag: %d, Sample_Vel %f, %f, %f\", continued_acceleration_, sample_target_vel[0], sample_target_vel[1], sample_target_vel[2]);\n//  ROS_WARN_NAMED(\"Generator\", \"Flag: %d, Vel %f, %f, %f\", continued_acceleration_, vel[0], vel[1], vel[2]);\n//  ROS_WARN_NAMED(\"Generator\", \"Flag: %d, Acc_Lim %f, %f, %f\", continued_acceleration_, acclimits[0], acclimits[1], acclimits[2]);\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  // x\n  if (sample_target_vel[0] > vel[0]) {\n    new_vel[0] = std::min(sample_target_vel[0], vel[0] + acclimits[0] * dt);\n  } else {\n    new_vel[0] = std::max(sample_target_vel[0], vel[0] - acclimits[0] * dt);\n  }\n  // y\n  if (sample_target_vel[1] > vel[1]) {\n    new_vel[1] = std::min(sample_target_vel[1], vel[1] + acclimits[1] * dt);\n  } else {\n    new_vel[1] = std::max(sample_target_vel[1], vel[1] - acclimits[1] * dt);\n  }\n  // theta\n  if (sample_target_vel[2] > vel[2]) {\n    new_vel[2] = std::min(sample_target_vel[2], vel[2] + acclimits[2] * dt);\n  } else {\n    new_vel[2] = std::max(sample_target_vel[2], vel[2] - acclimits[2] * dt);\n  }\n//  ROS_WARN_NAMED(\"Generator\", \"Flag: %d, New_Vel %f, %f, %f\", continued_acceleration_, new_vel[0], new_vel[1], new_vel[2]);\n  return new_vel;\n}", "CodeBleu_score": 41.698661776614884}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t// initialize new velocity vector to zero\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n// for each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits\n  new_vel[0] = std::min(std::max(vel[0] + acclimits[0] * dt, sample_target_vel[0]), vel[0]);\n  new_vel[1] = std::min(std::max(vel[1] + acclimits[1] * dt, sample_target_vel[1]), vel[1]);\n  new_vel[2] = std::min(std::max(vel[2] + acclimits[2] * dt, sample_target_vel[2]), vel[2]);\n  return new_vel;\n}", "CodeBleu_score": 44.30406181700109}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//  ROS_DEBUG(\\\"Heading diff between (%d, %d) and (%.2f, %.2f) with heading %.2f\\\", cell_x, cell_y, x, y, heading);\n\n  // start at the goal point and work backwards until we find a clear line of sight to the robot's current cell\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    // check if the goal point has a clear line of sight to the robot's current cell\n    if (lineOfSight(cell_x, cell_y, global_plan_[i].pose.position.x, global_plan_[i].pose.position.y)) {\n      // convert the goal point to world coordinates\n      double goal_x, goal_y;\n      costmap_.mapToWorld(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, goal_x, goal_y);\n\n      // calculate the shortest angular distance between the current heading and the direction to the goal point\n      double heading_diff = fabs(tf2::getYaw(heading) - tf2::getYaw(atan2(goal_y - y, goal_x - x)));\n\n      // return the absolute value of the shortest angular distance\n      return fmod(heading_diff + M_PI, 2 * M_PI) - M_PI;\n    }\n  }\n\n  // if no valid point is found, return DBL_MAX\n  return DBL_MAX;\n}", "CodeBleu_score": 62.08290367888903}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t", "CodeBleu_score": 10.045376955426562}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n//  if (cost >= 0.0) {\n//    return true;\n//  } else {\n//    ROS_WARN(\\\"Trajectory cost: %f, at vx: %.2f, vy: %.2f, vtheta: %.2f\\\", cost, vx_samp, vy_samp, vtheta_samp);\n//    return false;\n//  }\n}", "CodeBleu_score": 10.146685550240573}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n/*\n * This function, TrajectoryPlanner::scoreTrajectory, evaluates a trajectory based on given position, orientation, and velocity parameters.\n * It computes the cost of the trajectory by calling the costmap.\n * If the cost is non-negative, the trajectory is considered valid, and the function returns true.\n * If the cost is negative, it logs a warning with the sample velocities and cost, then returns false.\n */\n  double occ_cost = costmap_.footprintCost(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (occ_cost < 0) {\n    ROS_WARN(\\\"Trajectory cost from %f, %f, %f, %f, %f, %f, %f, %f, %f is: %f\\\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, occ_cost);\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 59.60293370653007}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmap passed to the ClearCostmapRecovery object is NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object is NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"The ClearCostmapRecovery behavior is configured to clear inside an area, but this behavior is configured to clear outside an area. \"\n\t\t\t\t\"This behavior will clear inside an area, and the robot will not be able to move until this behavior is fixed.\");\n\t}\n\n\t//get the current time in seconds\n\tdouble time = ros::Time::now().toSec();\n\n\t//clear the global costmap\n\tif (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tglobal_costmap_->resetMap(reset_distance_, reset_distance_, true);\n\t}\n\n\t//clear the local costmap\n\tif (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tlocal_costmap_->resetMap(reset_distance_, reset_distance_, true);\n\t}\n\n\t//force an update of the costmaps\n\tif (force_updating_) {\n\t\tROS_INFO(\"Forcing costmap update\");\n\t\tglobal_costmap_->forceUpdate();\n\t\tlocal_costmap_->forceUpdate();\n\t}\n\n\t//log the time it took to clear the costmaps\n\tROS_INFO(\"Clear costmaps took %.2f seconds\", ros::Time::now().toSec() - time);\n}", "CodeBleu_score": 53.19990820976728}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t(!initialized_) {\nROS_ERROR(\"This object must be initialized before runBehavior is called\");\nreturn;\n}\n\nif (global_costmap_ == NULL || local_costmap_ == NULL) {\nROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\nreturn;\n}\n\n//get the current position\ngeometry_msgs::PoseStamped current_position;\nif (!global_costmap_->getRobotPose(current_position)) {\nROS_ERROR(\"Could not get robot pose\");\nreturn;\n}\n\n//get the current time\nros::Time start_time = ros::Time::now();\n\n//clear the global costmap\nif (affected_maps_ == \"global\" || affected_maps_ == \"both\") {\nROS_INFO(\"Clearing global costmap\");\nif (force_updating_) {\nglobal_costmap_->forceUpdating();\n}\nglobal_costmap_->resetMap(current_position, reset_distance_);\n}\n\n//clear the local costmap\nif (affected_maps_ == \"local\" || affected_maps_ == \"both\") {\nROS_INFO(\"Clearing local costmap\");\nif (force_updating_) {\nlocal_costmap_->forceUpdating();\n}\nlocal_costmap_->resetMap(current_position, reset_distance_);\n}\n\n//log the time taken\nros::Duration time_taken = ros::Time::now() - start_time;\nROS_INFO(\"Clearing costmaps took %.2f seconds\", time_taken.toSec());\n}", "CodeBleu_score": 59.08635496570403}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t", "CodeBleu_score": 5.034306355366355}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t//    ROS_DEBUG(\"polygonOutlineCells: polygon has %d vertices\", (int)polygon.size());\n//    ROS_DEBUG(\"polygonOutlineCells: polygon_cells has %d vertices\", (int)polygon_cells.size());\n//    ROS_DEBUG(\"polygonOutlineCells: size_x_ = %d, size_y_ = %d\", size_x_, size_y_);\n//    ROS_DEBUG(\"polygonOutlineCells: origin_x_ = %f, origin_y_ = %f\", origin_x_, origin_y_);\n//    ROS_DEBUG(\"polygonOutlineCells: resolution_ = %f\", resolution_);\n//    ROS_DEBUG(\"polygonOutlineCells: costmap_ = %p\", costmap_);\n\n    // initialize the polygon outline cells object\n    PolygonOutlineCells polygon_outline_cells(size_x_, size_y_, origin_x_, origin_y_, resolution_, costmap_);\n\n    // iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n    if (!polygon.empty()) {\n        for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n            polygon_outline_cells.raytraceLine(polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n        }\n\n        // close the polygon by connecting the last point to the first\n        polygon_outline_cells.raytraceLine(polygon[polygon.size() - 1].x, polygon[polygon.size() - 1].y, polygon[0].x, polygon[0].y);\n    }\n\n    // get the outline cells from the object\n    polygon_outline_cells.getPolygonOutlineCells(polygon_cells);\n}", "CodeBleu_score": 67.39447445809341}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t", "CodeBleu_score": 5.034306355366355}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t", "CodeBleu_score": 10.992937465607893}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t/*\n * This function, Costmap2DPublisher::prepareGrid, sets up the grid data for the costmap.\nIt first sets up the grid header.\n */\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n  grid_.info.resolution = costmap_->getResolution();\n  grid_.info.width = xn_;\n  grid_.info.height = yn_;\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(xn_ * yn_);\n/*\n * This function, Costmap2DPublisher::prepareGrid, then sets up the grid data for the costmap.\nIt first sets up the grid data.\nThen, it publishes the prepared grid using the provided publisher.\n */\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 57.93577104687485}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t", "CodeBleu_score": 10.992937465607893}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t//  ROS_INFO(\"preparing grid\");\n  // lock the costmap mutex\n  costmap_->lock();\n\n  // get the resolution\n  double resolution = costmap_->getResolution();\n\n  // set the header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n\n  // set the resolution\n  grid_.info.resolution = resolution;\n\n  // set the width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // set the origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin coordinates\n  x0_ = costmap_->getSizeInCellsX();\n  y0_ = costmap_->getSizeInCellsY();\n  xn_ = costmap_->getOriginX();\n  yn_ = costmap_->getOriginY();\n\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n    grid_.data[i] = cost_translation_table_[costmap_->getCharMap()[i]];\n  }\n\n  // unlock the costmap mutex\n  costmap_->unlock();\n}", "CodeBleu_score": 62.73422371342703}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\n//  ROS_DEBUG(\"Preparing costmap grid for publishing.\");\n\n//  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // get the resolution\n  inscribed_inflation_radius_ = costmap_->getInscribedRadius();\n  footprint_inflation_radius_ = costmap_->getFootprintInflationRadius();\n\n  // set the header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n\n  // set the resolution\n  grid_.info.resolution = costmap_->getResolution();\n\n  // set the width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // set the origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin\n  x0_ = costmap_->getSizeInCellsX();\n  y0_ = costmap_->getSizeInCellsY();\n  xn_ = costmap_->getOriginX();\n  yn_ = costmap_->getOriginY();\n\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data from the costmap's character map\n  for (unsigned int i = 0; i < grid_.info.width; ++i) {\n    for (unsigned int j = 0; j < grid_.info.height; ++j) {\n      grid_.data[i + j * grid_.info.width] = cost_translation_table_[costmap_->getCharMap()[i + j * grid_.info.width]];\n    }\n  }\n}", "CodeBleu_score": 53.031324321382534}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\n// lock the costmap mutex\nboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n// get the resolution\ndouble resolution = costmap_->getResolution();\n\n// set the grid's header\ngrid_.header.stamp = ros::Time::now();\ngrid_.header.frame_id = global_frame_;\n\n// set the grid's resolution\ngrid_.info.resolution = resolution;\n\n// set the grid's width and height\ngrid_.info.width = costmap_->getSizeInCellsX();\ngrid_.info.height = costmap_->getSizeInCellsY();\n\n// set the origin's position and orientation\ngrid_.info.origin.position.x = costmap_->getOriginX();\ngrid_.info.origin.position.y = costmap_->getOriginY();\ngrid_.info.origin.position.z = 0.0;\ngrid_.info.origin.orientation.x = 0.0;\ngrid_.info.origin.orientation.y = 0.0;\ngrid_.info.origin.orientation.z = 0.0;\ngrid_.info.origin.orientation.w = 1.0;\n\n// save the origin coordinates\nx0_ = grid_.info.width;\ny0_ = grid_.info.height;\nxn_ = grid_.info.origin.position.x;\nyn_ = grid_.info.origin.position.y;\n\n// resize the grid data vector\ngrid_.data.resize(grid_.info.width * grid_.info.height);\n\n// populate the grid data from the costmap's character map using a translation table\nfor (unsigned int i = 0; i < grid_.info.width; ++i) {\nfor (unsigned int j = 0; j < grid_.info.height; ++j) {\ngrid_.data[i + j * grid_.info.width] = cost_translation_table_[costmap_->getCost(i, j)];\n}\n}\n\n}", "CodeBleu_score": 63.21521636874562}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n//  if (new_config.footprint.size() == old_config.footprint.size() && new_config.footprint == old_config.footprint) {\n//    return;\n//  }\n\n  // If the footprint is the same, return immediately.\n  if (new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // If the footprint is empty, set the footprint based on the robot radius.\n  if (new_config.footprint.empty()) {\n    setUnpaddedRobotFootprint(unpadded_footprint_);\n    return;\n  }\n\n  // If the footprint is not empty, try to convert it to a footprint.\n  std::vector<geometry_msgs::Point> footprint;\n  if (fromFootprintString(new_config.footprint, footprint)) {\n    setUnpaddedRobotFootprint(footprint);\n  } else {\n    ROS_ERROR(\"The footprint string \\\"%s\\\" is invalid\", new_config.footprint.c_str());\n  }\n}", "CodeBleu_score": 51.3576439164935}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t/*\n * This function, Costmap2DROS::readFootprintFromConfig, updates the robot footprint based on the new configuration.\nIf the footprint and robot radius in the new and old configurations are the same, it returns immediately.\nIf the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\nIf the footprint string is invalid, it logs an error.\nIf no valid footprint string is provided, it sets the footprint based on the robot radius.\n */\n  if (new_config.footprint.size() > 0) {\n    // parse the footprint string\n    if (parseFootprintString(new_config.footprint, robot_radius_, footprint_)) {\n      // if the footprint has changed, re-apply the padding\n      if (footprint_!= old_config.footprint) {\n        setUnpaddedRobotFootprint(unpadded_footprint_);\n      }\n    } else {\n      ROS_ERROR(\"Could not parse footprint string: %s\", new_config.footprint.c_str());\n    }\n  } else {\n    // if the footprint string is empty, set the footprint based on the robot radius\n    footprint_.clear();\n    double radius = new_config.robot_radius;\n    footprint_.push_back(Point(radius, radius));\n    footprint_.push_back(Point(radius, -radius));\n    footprint_.push_back(Point(-radius, -radius));\n    footprint_.push_back(Point(-radius, radius));\n  }\n}", "CodeBleu_score": 48.26471870436677}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t/*\n * This function, Costmap2DROS::readFootprintFromConfig, updates the robot footprint based on the new configuration.\nIf the footprint and robot radius in the new and old configurations are the same, it returns immediately.\nIf the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\nIf the footprint string is invalid, it logs an error.\nIf no valid footprint string is provided, it sets the footprint based on the robot radius.\n */\n  double new_robot_radius = new_config.inflation_radius, old_robot_radius = old_config.inflation_radius;\n  std::vector<geometry_msgs::Point> new_footprint, old_footprint;\n  if (new_robot_radius == old_robot_radius) {\n    return;\n  }\n\n  if (new_config.footprint.size() > 0) {\n    if (!readFootprintFromConfig(new_config.footprint, new_footprint)) {\n      ROS_ERROR(\"Invalid footprint string provided. Using default footprint.\");\n    } else {\n      setUnpaddedRobotFootprint(new_footprint);\n    }\n  } else if (old_config.footprint.size() > 0) {\n    setUnpaddedRobotFootprint(old_footprint);\n  } else {\n    double robot_radius = new_config.inflation_radius;\n    new_footprint = getRobotFootprint(robot_radius);\n    setUnpaddedRobotFootprint(new_footprint);\n  }\n}", "CodeBleu_score": 52.646270567695616}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t/*\n * This function, Costmap2DROS::movementCB, is a callback for handling robot movement events.\nIt attempts to get the robot's current pose and stores it in new_pose.\nIf it fails to retrieve the pose, it logs a warning message and cancels reconfiguration.\n */\n  if (global_frame_id_ == \"\") {\n    ROS_WARN(\"The global frame id is not set.  Global frames are required for the static layer.  You can set the global frame id using the global_frame parameter on the Costmap2DROS constructor.\");\n    return;\n  }\n  try {\n    tf_.lookupTransform(global_frame_id_, robot_base_frame_, ros::Time(0), transform_);\n  } catch (tf::TransformException &ex) {\n    ROS_WARN(\"Received an exception trying to transform a point from \\\"%s\\\" to \\\"%s\\\": %s\", robot_base_frame_.c_str(), global_frame_id_.c_str(), ex.what());\n    return;\n  }\n\n  new_pose_.header.stamp = ros::Time::now();\n  new_pose_.header.frame_id = robot_base_frame_;\n  new_pose_.pose.position.x = transform_.getOrigin().x();\n  new_pose_.pose.position.y = transform_.getOrigin().y();\n  new_pose_.pose.position.z = transform_.getOrigin().z();\n  new_pose_.pose.orientation.x = transform_.getRotation().x();\n  new_pose_.pose.orientation.y = transform_.getRotation().y();\n  new_pose_.pose.orientation.z = transform_.getRotation().z();\n  new_pose_.pose.orientation.w = transform_.getRotation().w();\n\n  // if the robot has moved, update the costmap\n  if (new_pose_.header.stamp > last_update_time_ + ros::Duration(transform_tolerance_)) {\n    last_update_time_ = new_pose_.header.stamp;\n    updateMap();\n  }\n}", "CodeBleu_score": 39.2889264265268}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!getRobotPose(new_pose_)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfiguration.\");\n\t\treconfigure_timer_.stop();\n\t}\n}", "CodeBleu_score": 47.625753909411586}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the current pose of the robot\n\tif (current_pose_subscriber_.getNumPublishers() > 0) {\n\t\t// make sure that the current pose is valid\n\t\tif (current_pose_subscriber_.getTopic() == current_pose_topic_) {\n\t\t\t// get the current pose\n\t\t\tcurrent_pose_subscriber_.getMsg(current_pose_);\n\n\t\t\t// make sure that the current pose is valid\n\t\t\tif (current_pose_.header.stamp.toSec() > last_valid_pose_stamp_.toSec()) {\n\t\t\t\tlast_valid_pose_stamp_ = current_pose_.header.stamp;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if the current pose is valid, reconfigure the costmap\n\tif (last_valid_pose_stamp_.toSec() > last_reconfigure_stamp_.toSec()) {\n\t\treconfigureCB(current_config_, 0);\n\t\tlast_reconfigure_stamp_ = last_valid_pose_stamp_;\n\t}\n}", "CodeBleu_score": 38.154542149758576}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\t// get the list of plugins\n\tstd::vector<boost::shared_ptr<Plugin> > plugins = layered_costmap_->getPlugins();\n\t// check if the costmap is stopped\n\tif (stopped_) {\n\t\t// re-subscribe to topics by activating each plugin\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\tplugins[i]->activate();\n\t\t}\n\t\t// set the stopped flag to false\n\t\tstopped_ = false;\n\t}\n\t// wait until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::isInitialized() ||!initialized_ || map_update_thread_ == NULL) {\n\t\tros::spinOnce();\n\t\t// sleep for 100 milliseconds\n\t\tros::Duration(0.1).sleep();\n\t}\n\t// set stop_updates_ to false\n\tstop_updates_ = false;\n}", "CodeBleu_score": 57.37132559210302}, {"code": "void Costmap2DROS::start(){\n\t\t// get the list of plugins\n\tstd::vector<std::string> plugins;\n\tgetPlugins(plugins);\n\n\t// check if costmap is stopped\n\tbool stopped = false;\n\tif (layered_costmap_->isStopped()) {\n\t\tstopped = true;\n\t}\n\n\t// re-subscribe to topics\n\tif (stopped) {\n\t\t// activate each plugin\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\tactivatePlugin(plugins[i]);\n\t\t}\n\n\t\t// set stopped to false\n\t\tlayered_costmap_->setStopped(false);\n\t}\n\n\t// wait until ROS is running\n\twhile (!ros::ok()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// wait until costmap is initialized\n\twhile (!layered_costmap_->isInitialized()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// wait until map update thread is active\n\twhile (!map_update_thread_shutdown_) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// set stop_updates_ to false\n\tstop_updates_ = false;\n}", "CodeBleu_score": 46.87416577800937}, {"code": "void Costmap2DROS::start(){\n\t\t// get the list of plugins\n\tstd::vector<std::string> plugins;\n\tlayered_costmap_->getPluginNames(plugins);\n\n\t// check if the costmap is stopped\n\tbool stopped = false;\n\tfor (unsigned int i = 0; i < plugins.size(); i++) {\n\t\tif (layered_costmap_->isPlugin(plugins[i], \"static_layer\")) {\n\t\t\tif (layered_costmap_->isPluginStopped(plugins[i], \"static_layer\")) {\n\t\t\t\tstopped = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// re-subscribe to topics\n\tif (stopped) {\n\t\tfor (unsigned int i = 0; i < plugins.size(); i++) {\n\t\t\tif (layered_costmap_->isPlugin(plugins[i], \"static_layer\")) {\n\t\t\t\tlayered_costmap_->activatePlugin(plugins[i], \"static_layer\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// wait for the costmap to be initialized\n\twhile (!layered_costmap_->isInitialized()) {\n\t\tros::spinOnce();\n\t\tros::Duration(0.01).sleep();\n\t}\n\n\t// wait for the map update thread to start\n\twhile (!map_update_thread_->is_running()) {\n\t\tros::spinOnce();\n\t\tros::Duration(0.01).sleep();\n\t}\n\n\t// set the stopped flag to false\n\tstopped = false;\n\tstop_updates_ = false;\n}", "CodeBleu_score": 44.17337915974299}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t// first, we'll make sure that the observation list is not empty\nif (observation_list_.empty()) {\nreturn;\n}\n\n// now we'll iterate through the list and remove any observations that are older than the keep time\nlist<Observation>::iterator obs_it;\nfor (obs_it = observation_list_.begin(); obs_it!= observation_list_.end();) {\n// if the observation is too old, we'll remove it\nif (ros::Time::now() - obs_it->header_.stamp > observation_keep_time_) {\nobs_it = observation_list_.erase(obs_it);\n}\nelse {\n++obs_it;\n}\n}\n}", "CodeBleu_score": 39.04679481617159}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t/*\n * This function, ObservationBuffer::purgeStaleObservations, removes outdated observations from the observation list.\nIf the observation_keep_time_ is zero, it keeps only the most recent observation.\nOtherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n */\n\nif (observation_keep_time_ == 0.0) {\n// keep the most recent observation\nobservation_list_.pop_back();\n} else {\n// iterate through the list and remove observations that are older than the specified keep time\nlist<Observation>::iterator obs_it;\nfor (obs_it = observation_list_.begin(); obs_it!= observation_list_.end(); ++obs_it) {\nif (ros::Time::now() - obs_it->header_.stamp < ros::Duration(observation_keep_time_)) {\nbreak;\n}\n}\n// remove the observations that are older than the specified keep time\nobservation_list_.erase(obs_it, observation_list_.end());\n}\n}", "CodeBleu_score": 39.98607573658676}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\n// keep only the most recent observation\nobservation_list_.pop_back();\n} else {\n// iterate through the list and remove observations that are older than the specified keep time\nlist<Observation>::iterator obs_it;\nfor (obs_it = observation_list_.begin(); obs_it!= observation_list_.end(); ++obs_it) {\nif (ros::Time::now() - obs_it->cloud_->header.stamp < ros::Duration(observation_keep_time_)) {\n// we found a valid observation, so we can stop iterating\nbreak;\n}\n}\n// remove all observations that are older than the specified keep time\nobservation_list_.erase(observation_list_.begin(), obs_it);\n}\n}", "CodeBleu_score": 39.455842443200716}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  double shortest_angle = angles::shortest_angular_distance(start_yaw, end_yaw);\n  double angle_increment = shortest_angle / (end_index - start_index);\n\n  for (int i = start_index + 1; i < end_index; i++) {\n    double new_yaw = start_yaw + (i - start_index) * angle_increment;\n    set_angle(&path[i], new_yaw);\n  }\n}", "CodeBleu_score": 67.99618115802213}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//    ROS_INFO(\"Interpolating path from %d to %d\", start_index, end_index);\n    int n = end_index - start_index;\n    if (n < 2) return;\n\n    double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n    double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n    double diff = angles::shortest_angular_distance(start_angle, end_angle);\n    double increment = diff / n;\n\n    for (int i = start_index + 1; i < end_index; i++) {\n        set_angle(&path[i], start_angle + increment * (i - start_index));\n    }\n}", "CodeBleu_score": 61.93990135787008}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Check if the indices are valid\n\tif (start_index < 0 || start_index >= (int)path.size() || end_index < 0 || end_index >= (int)path.size()) {\n\t\tROS_ERROR(\"OrientationFilter::interpolate: Invalid indices\");\n\t\treturn;\n\t}\n\n\t// Get the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble increment = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i <= end_index; i++) {\n\t\tdouble new_yaw = start_yaw + increment * (i - start_index);\n\t\tset_angle(&path[i], new_yaw);\n\t}\n}", "CodeBleu_score": 65.43881669001914}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the frame_id of the start and goal to \"map\"\nreq.start.header.frame_id = \"map\";\nreq.goal.header.frame_id = \"map\";\n\n// Call makePlan to generate a path\nvector<geometry_msgs::PoseStamped> path;\nmakePlan(req.start, req.goal, path);\n\n// Update the response with the success status and the generated path if a plan is found\nif (path.size() > 0) {\nresp.plan.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); i++) {\nresp.plan.poses[i] = path[i];\n}\nresp.success = true;\n} else {\nresp.success = false;\n}\n\n// Return true to indicate that the service was processed\nreturn true;\n}", "CodeBleu_score": 62.52295501650303}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t/*\n * Set the frame_id of the start and goal to \"map\"\n */\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n/*\n * Call makePlan to generate a path\n */\n    makePlan(req.start, req.goal, resp.plan.poses);\n/*\n * Update the response with the success status and the generated path if a plan is found\n */\n    resp.success =!resp.plan.poses.empty();\n    return true;\n}", "CodeBleu_score": 48.72718891065168}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the frame_id of the start and goal to \"map\"\nreq.start.header.frame_id = req.goal.header.frame_id = \"map\";\n// Call makePlan to generate a path\nmakePlan(req.start, req.goal, resp.plan.poses);\n// Update the response with the success status and the generated path if a plan is found\nresp.success =!resp.plan.poses.empty();\nreturn true;\n}", "CodeBleu_score": 39.949764069191495}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t/*\n * The constructor creates a private node handle, advertises the \"make_plan\" service, and subscribes to the \"goal\" topic.\n */\n    ros::NodeHandle private_nh(\\\"~/\\\");\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\\\n    pose_sub_ = private_nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\\\n}", "CodeBleu_score": 45.32193678742574}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n/*\n * This line of code creates a private ROS node handle and advertises a \"make_plan\" service.\n */\n    ros::NodeHandle private_nh(\\\"~/\\\");\n    make_plan_service_ = private_nh.advertiseService(\\\"make_plan\\\", &PlannerWithCostmap::makePlanService, this);\\\n\n/*\n * This line of code subscribes to the \"goal\" topic and calls the poseCallback function when a message is received.\n */\n    pose_sub_ = private_nh.subscribe(\\\"goal\\\", 1, &PlannerWithCostmap::poseCallback, this);\\\n}", "CodeBleu_score": 45.32193678742574}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t/*\n * This constructor, PlannerWithCostmap::PlannerWithCostmap, initializes a PlannerWithCostmap object with a given name and Costmap2DROS pointer.\nIt calls the base class constructor with the planner name, costmap, and global frame ID.\nIt sets up a private ROS node handle, advertises a \"make_plan\" service, and subscribes to the \"goal\" topic to receive PoseStamped messages for planning purposes.\n */\n}", "CodeBleu_score": 18.654488076502528}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t//    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n//        ROS_WARN(\\\"(wx, wy) = (%f, %f) is outside the costmap bounds.\\\");\n//        return false;\n//    }\n    //calculate the map coords\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n    return true;\n}", "CodeBleu_score": 28.17528721742223}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t//    if (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n    wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY())\n    {\n        ROS_WARN(\\\"The robot's pose is out of the global costmap.\\\");\n        return false;\n    }\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    return true;\n}", "CodeBleu_score": 39.820096287021826}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\t\"Costmap is %f X %f m, and you asked for %f, %f.\n\",\n\t\t\t\tcostmap_->getSizeInMetersX(), costmap_->getSizeInMetersY(), wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\tif (mx < 0 || mx >= (double)costmap_->getSizeInCellsX() || my < 0 || my >= (double)costmap_->getSizeInCellsY()) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\t\"Costmap is %f X %f m, and you asked for %f, %f.\n\",\n\t\t\t\tcostmap_->getSizeInMetersX(), costmap_->getSizeInMetersY(), wx, wy);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.24029726562992}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t", "CodeBleu_score": 4.955710903014349}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t/*\n * This function, GlobalPlanner::publishPlan, publishes a given path as a nav_msgs::Path message.\nIt first checks if the planner is initialized, logging an error and returning if not.\nIt creates a Path message, sets its header with the frame ID and current time, and copies the poses from the input path.\nFinally, it publishes the Path message using the plan_pub_ publisher.\n */\n    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    //set the path's header\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 99.89517835095282}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\t//set the path's header\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t//publish the plan\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.89079784387178}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t/*\n * This function, MoveBase::goalCB, is a callback that processes a new goal in the form of a PoseStamped message.\nIt logs a debug message indicating it is wrapping the goal in an action message.\nThe function creates a MoveBaseActionGoal, sets its timestamp to the current time, assigns the received goal to the target_pose, and publishes the action goal to the action_goal_pub_ topic.\n */\n  ROS_DEBUG_NAMED(\"move_base\",\"In goal callback, wrapping goal of frame %s\",goal->header.frame_id.c_str());\n  boost::shared_ptr<MoveBaseAction> ac;\n  //wrap the goal in an action message\n  ac = boost::make_shared<MoveBaseAction>();\n  ac->action_goal.header.stamp = ros::Time::now();\n  ac->action_goal.goal.target_pose = *goal;\n  ac->action_goal.goal.target_pose.header.stamp = ros::Time::now();\n  ROS_DEBUG_NAMED(\"move_base\",\"Sending goal\");\n  //send the goal to the action server\n  ac->action_goal.header.stamp = ros::Time::now();\n  ac->action_goal.goal.target_pose = *goal;\n  ac->action_goal.goal.target_pose.header.stamp = ros::Time::now();\n  action_goal_pub_.publish(ac->action_goal);\n}", "CodeBleu_score": 46.97880601040103}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t//ROS_INFO(\"goalCB\");\n\t//wrap the PoseStamped in the action message and publish it\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 63.349340798527784}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\",\"In goal callback, wrapping goal in an action message\");\n\t//create a goal message we want to send\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\n\t//set the header\n\tgoal_msg.header.stamp = ros::Time::now();\n\tgoal_msg.header.frame_id = goal->header.frame_id;\n\n\t//set the goal pose for the  action\n\tgoal_msg.goal.target_pose = *goal;\n\n\t//send the goal to the action server; this serves as a trigger to start the planner\n\taction_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 66.28361532680339}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > limited_distance_ * limited_distance_) {\nROS_INFO(\"Move slow and clear recovery behavior has moved far enough.  Removing speed limit.\");\ndistance_check_timer_.stop();\nboost::mutex::scoped_lock l(mutex_);\nremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n}\n}", "CodeBleu_score": 47.218494110318375}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > (limited_distance_ * limited_distance_)) {\nROS_WARN(\"Move slow and clear recovery behavior has moved far enough to clear the space. Removing speed limit.\");\nif (remove_limit_thread_) {\nremove_limit_thread_->join();\ndelete remove_limit_thread_;\n}\nremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\ndistance_check_timer_.stop();\n}\n}", "CodeBleu_score": 75.49561875184375}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tROS_INFO(\"MoveSlowAndClear::distanceCheck\");\n  if (getSqDistance() > limited_distance_ * limited_distance_) {\n    ROS_WARN(\"Move slow and clear recovery behavior has moved far enough to clear the space.\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_!= NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n    remove_limit_thread_->detach();\n  }\n}", "CodeBleu_score": 70.42293100592624}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tPoseStamped global_pose = getRobotPose();\n\tvector<PoseStamped> path;\n\n\tbool success = makePlan(global_pose, *goal, path);\n\n\tif (success) {\n\t\tROS_INFO(\"Path found! Length: %d\", path.size());\n\t} else {\n\t\tROS_INFO(\"Path not found!\");\n\t}\n}", "CodeBleu_score": 52.98308917761182}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t//  ROS_INFO(\"Pose callback\");\n  PoseStamped start = getRobotPose();\n  vector<PoseStamped> path;\n  makePlan(start, *goal, path);\n}", "CodeBleu_score": 54.894670162104816}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t//  ROS_DEBUG(\"Got a pose update. Updating global pose.\");\n  // get the current global pose of the robot\n  rm::PoseStamped global_pose = getRobotPose();\n  // generate a path from the current pose to the goal pose\n  vector<PoseStamped> path;\n  makePlan(global_pose, *goal, path);\n}", "CodeBleu_score": 69.68765768772067}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet set_param;\n\tset_param.request.param_id = param_set.param_id;\n\tset_param.request.value = param_set.value;\n\tthis->param_set_client_.call(set_param);\n}", "CodeBleu_score": 63.14665185700059}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet set_param;\n\tset_param.request.param_id = param_set.param_id;\n\tset_param.request.value = param_set.value;\n\n\tthis->param_set_client_.call(set_param);\n}", "CodeBleu_score": 63.14665185700059}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 62.826747042969785}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t\u5f85\u8fde\u63a5\n\twhile (ros::ok()) {\n\t\tif (this->tcp_server_ == NULL) {\n\t\t\tthis->tcp_server_ = new TcpServer(TCP_PORT);\n\t\t\tthis->tcp_server_->start();\n\t\t}\n\t\tros::Duration(0.1).sleep();\n\t}\n}", "CodeBleu_score": 4.675035715958179}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tstd::cout << \"recvData: \" << uav_cmd.id << std::endl;\n\n    if (this->is_simulation_ == 0) {\n        // \u975e\u4eff\u771f\u6a21\u5f0f\n        if (this->uav_basic_!= NULL) {\n            // \u5355\u673a\u6a21\u5f0f\n            this->uav_basic_->recvData(uav_cmd);\n        }\n    } else {\n        // \u4eff\u771f\u6a21\u5f0f\n        if (this->swarm_control_!= NULL && this->swarm_num_!= 0) {\n            // \u96c6\u7fa4\u6a21\u5f0f\n            this->swarm_control_->recvData(uav_cmd);\n        }\n    }\n}", "CodeBleu_score": 60.93892714335304}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tSIMULATION\n    if (this->swarm_control_simulation_!= NULL && this->swarm_num_!= 0) {\n        // \u878d\u5408\u5230\u6240\u6709\u65e0\u4eba\u673a\u72b6\u6001\u7136\u540e\u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_simulation_->updateAllUAVCommand(uav_cmd);\n        // \u53d1\u5e03\u8bdd\u9898\n        this->swarm_control_simulation_->allUAVCommandPub(this->swarm_control_simulation_->getMultiUAVCommand());\n    }\n#else\n    if (this->uav_basic_!= NULL) {\n        this->uav_basic_->updateUAVCommand(uav_cmd);\n        this->uav_basic_->uavCommandPub(this->uav_basic_->getUAVCommand());\n    }\n#endif\n}", "CodeBleu_score": 40.625934178980735}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t", "CodeBleu_score": 2.601564811867212}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == ModeSelection::REBOOTNX) {\n\t\tstd::string command = \\\"reboot\\\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == ModeSelection::EXITNX) {\n\t\tstd::string command = \\\"exit\\\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == ModeSelection::CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == ModeSelection::DELETEMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 52.92610097202511}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\n}", "CodeBleu_score": 4.650810043155036}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == ModeSelection::REBOOTNX) {\n\t\tstd::cout << \"rebooting\" << std::endl;\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == ModeSelection::EXITNX) {\n\t\tstd::cout << \"exiting\" << std::endl;\n\t\tsystem(\"exit\");\n\t} else if (mode_selection.use_mode == ModeSelection::CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == ModeSelection::DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 65.06524535827751}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \\\"multitrajSubCb\\\" << std::endl;\n\n    // Extract drone ID and trajectory data from message\n    int drone_id = msg->drone_id;\n    std::vector<prometheus_msgs::Bspline> traj_vec = msg->trajectories;\n\n    // Initialize MultiBsplines message\n    prometheus_msgs::MultiBsplines bsplines_msg;\n    bsplines_msg.drone_id = drone_id;\n\n    // Initialize Bspline struct for each trajectory\n    for (int i = 0; i < traj_vec.size(); i++) {\n        prometheus_msgs::Bspline bspline_msg = traj_vec[i];\n\n        // Initialize Bspline struct\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.trajectory_id = i;\n\n        // Populate Bspline struct attributes\n        bspline.knots = bspline_msg.knots;\n        bspline.position_points = bspline_msg.position_points;\n        bspline.yaw_points = bspline_msg.yaw_points;\n\n        // Encode MultiBsplines message\n        bsplines_msg.trajectories.push_back(bspline.encode());\n    }\n\n    // Send MultiBsplines message via TCP\n    communication->sendMultiBsplines(bsplines_msg, tcp_ip_);\n}", "CodeBleu_score": 30.69127081136197}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tstd::cout << \\\"[EGOPlannerSwarm::multitrajSubTcpCb] received MultiBsplines message\\\" << std::endl;\n\n    // Extract the drone ID and trajectory data from the message\n    int drone_id = msg->drone_id;\n    std::vector<prometheus_msgs::Bspline> trajectories = msg->trajectories;\n\n    // Initialize a MultiBsplines message to send to the next drone\n    prometheus_msgs::MultiBsplines multi_bsplines_msg;\n    multi_bsplines_msg.drone_id = drone_id;\n\n    // Encode the MultiBsplines data and send it via TCP\n    for (int i = 0; i < trajectories.size(); i++) {\n        prometheus_msgs::Bspline bspline_msg = trajectories[i];\n        std::vector<double> bspline_data = encodeBspline(bspline_msg);\n        communication->sendTcp(tcp_ip_, bspline_data);\n    }\n}", "CodeBleu_score": 24.050049743996183}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Compress the point cloud using an octree compression technique\n\toctomap::OcTree octree(0.1);\n\toctomap::point3d origin(0, 0, 0);\n\toctomap::point3d point;\n\tfor (size_t i = 0; i < cloud->points.size(); i++) {\n\t\tpoint.x() = cloud->points[i].x;\n\t\tpoint.y() = cloud->points[i].y;\n\t\tpoint.z() = cloud->points[i].z;\n\t\toctree.updateNode(point, true);\n\t}\n\toctree.updateInnerOccupancy();\n\toctree.writeBinary(\"octomap.bt\");\n\n\t// Convert the compressed point cloud to a PointCloud2 message\n\tpcl::toROSMsg(octree, compressed_msg);\n\n\t// Return the compressed PointCloud2 message\n\treturn compressed_msg;\n}", "CodeBleu_score": 37.15891058623865}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Create an Octree object\n\toctomap::OcTree octree(0.05);\n\n\t// Insert points into the octree\n\tfor (const auto& point : cloud->points) {\n\t\toctree.updateNode(octomap::point3d(point.x, point.y, point.z), true);\n\t}\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\toctree.writeBinary(compressed_msg);\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 28.722383156326188}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t/*\n * This function, ReduceTheFrequency::compressed, compresses a PointCloud2 message using an octree compression technique.\nIt converts the input message to a pcl::PointCloud, compresses the point cloud, and stores the compressed data.\nIt then creates a new PointCloud2 message with the compressed data and returns it, ensuring to release dynamically allocated memory.\n */\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create the octree object\n    pcl::octree::OctreePointCloud<pcl::PointXYZ> octree(0.01f);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::toROSMsg(*octree.getPointCloud(), compressed_msg);\n    compressed_msg.header = msg.header;\n\n    return compressed_msg;\n}", "CodeBleu_score": 31.317531176356674}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); ++i) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 88.33821350563984}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); ++i) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 78.99116715478624}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tprometheus_msgs::MultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_num = 0;\n\n\tfor (auto it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); it++) {\n\t\tprometheus_msgs::UGVState ugv_state;\n\t\tugv_state.ugv_id = (*it).ugv_id;\n\t\tugv_state.battery_state = (*it).battery_state;\n\t\tugv_state.battery_percetage = (*it).battery_percetage;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tugv_state.position[i] = (*it).position[i];\n\t\t\tugv_state.velocity[i] = (*it).velocity[i];\n\t\t\tugv_state.attitude[i] = (*it).attitude[i];\n\t\t}\n\t\tugv_state.attitude_q.x = (*it).attitude_q.x;\n\t\tugv_state.attitude_q.y = (*it).attitude_q.y;\n\t\tugv_state.attitude_q.z = (*it).attitude_q.z;\n\t\tugv_state.attitude_q.w = (*it).attitude_q.w;\n\t\tmulti_ugv_state.ugv_num++;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// \u53d1\u5e03\u8bdd\u9898\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 86.37803212885828}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tprometheus_msgs::MultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_num = 0;\n\n\tfor (auto it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); it++) {\n\t\tprometheus_msgs::UGVState ugv_state;\n\t\tugv_state.ugv_id = (*it).ugv_id;\n\t\tugv_state.battery_state = (*it).battery_state;\n\t\tugv_state.battery_percetage = (*it).battery_percetage;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tugv_state.position[i] = (*it).position[i];\n\t\t\tugv_state.velocity[i] = (*it).velocity[i];\n\t\t\tugv_state.attitude[i] = (*it).attitude[i];\n\t\t};\n\t\tugv_state.attitude_q.x = (*it).attitude_q.x;\n\t\tugv_state.attitude_q.y = (*it).attitude_q.y;\n\t\tugv_state.attitude_q.z = (*it).attitude_q.z;\n\t\tugv_state.attitude_q.w = (*it).attitude_q.w;\n\n\t\tmulti_ugv_state.ugv_num++;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// \u53d1\u5e03\u8bdd\u9898\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 87.71676372667258}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n}", "CodeBleu_score": 3.845811572351676}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tint end_idx = q.cols() - order_;\n\tdouble a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n\tfor (auto i = order_; i < end_idx; ++i) {\n\t\tEigen::Vector3d pos_err = cps_.points.col(i) - cps_.base_point[i];\n\t\tEigen::Vector3d vel_vec = cps_.direction[i].col(0);\n\t\tdouble vel_err = vel_vec.norm();\n\t\tdouble pos_err_norm = pos_err.norm();\n\t\tdouble vel_err_norm = vel_vec.norm();\n\t\tdouble pos_err_dot_vel = pos_err.dot(vel_vec);\n\t\tdouble pos_err_cross_vel = pos_err.cross(vel_vec).norm();\n\n\t\tcost += a * inv_a2 * pos_err_dot_vel * pos_err_dot_vel + b * inv_b2 * pos_err_cross_vel * pos_err_cross_vel;\n\t\tgradient.col(i) += -2.0 * a * inv_a2 * pos_err_dot_vel * vel_vec - 2.0 * b * inv_b2 * pos_err_cross_vel * vel_vec.cross(pos_err) / pos_err_norm;\n\t}\n}", "CodeBleu_score": 40.12148561670632}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n/*\n * The fitness cost is calculated by summing the squared dot product and cross product of the positional error and velocity vectors.\n\n * The gradient is computed by multiplying the derivative of the cost function with the velocity vector.\n\n * The constants a2 and b2 are used to scale the cost and gradient.\n */\ncost = 0.0;\nint end_idx = q.cols() - order_;\ndouble a2 = 100.0, b2 = 100.0;\n\nfor (int i = order_; i < end_idx; i++) {\nEigen::Vector3d pos_err = cps_.points.col(i) - cps_.base_point[i];\nEigen::Vector3d vel = (cps_.points.col(i + 1) - cps_.points.col(i - 1)) / 2.0;\ndouble dot_prod = pos_err.dot(vel);\ndouble cross_prod = pos_err.cross(vel).norm();\ncost += a2 * dot_prod * dot_prod + b2 * cross_prod * cross_prod;\ngradient.col(i) += 2.0 * a2 * dot_prod * vel + 2.0 * b2 * cross_prod * vel.cross(pos_err) / cross_prod;\n}\n}", "CodeBleu_score": 40.20108406720813}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tEigen::VectorXd jerk = evaluateDeBoorT(0.0, 3);\n\tEigen::VectorXd u = getKnot();\n\tEigen::MatrixXd P = getCtrlPts();\n\tdouble jerk_value = 0.0;\n\tfor (int i = 0; i < P.cols(); i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tjerk_value += pow(P(j, i), 2) * (u(i + 3) - u(i));\n\t\t}\n\t}\n\treturn jerk_value;\n}", "CodeBleu_score": 45.70060326059866}, {"code": "double UniformBspline::getJerk(){\n\t\n//  cout << \"Jerk: \" << endl;\n//  cout << \"knots: \" << endl << getKnot() << endl;\n//  cout << \"ctrl pts: \" << endl << getCtrlPts() << endl;\n\n  Eigen::VectorXd jerk = evaluateDeBoorT(1.0, 3);\n  Eigen::VectorXd knots = getKnot();\n  Eigen::MatrixXd ctrl_pts = getCtrlPts();\n\n  double jerk_val = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk_val += pow(ctrl_pts(j, i), 2) * (knots(i + 4) - knots(i));\n    }\n  }\n\n  return sqrt(jerk_val);\n}", "CodeBleu_score": 51.861689213633234}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0.0;\n\tEigen::MatrixXd jerk_traj = getThirdDerivative();\n\tEigen::VectorXd knot_times = getKnot();\n\tEigen::MatrixXd ctrl_pts = getCtrlPts();\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += (ctrl_pts(j, i) * ctrl_pts(j, i)) * (knot_times(i + 1) - knot_times(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 54.427221480524366}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_)/fx_*depth;\n\tpos(1) = (v - cy_)/fy_*depth;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 61.68067258088994}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.67477930149333}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\treturn Eigen::Vector4d( (u-cx_)/fx_, (v-cy_)/fy_, depth, 1.0);\n}", "CodeBleu_score": 22.488656231764036}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\tint drone_id;\n\ttry {\n\t\tdrone_id = std::stoi(odom.child_frame_id.substr(odom.child_frame_id.find_last_of('_') + 1));\n\t} catch (const std::exception& e) {\n\t\tROS_WARN(\"Failed to extract drone ID from child_frame_id field of odometry message\");\n\t\treturn;\n\t}\n\trcvDroneOdomCallbackBase(odom, drone_id);\n}", "CodeBleu_score": 40.303254183466414}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\t// Extract the drone ID from the child_frame_id field of the odometry message.\n\tint drone_id = -1;\n\ttry {\n\t\tdrone_id = std::stoi(odom.child_frame_id.substr(6));\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR(\"Exception caught: %s\", e.what());\n\t}\n\n\t// Call rcvDroneOdomCallbackBase with the odometry data and drone ID.\n\trcvDroneOdomCallbackBase(odom, drone_id);\n}", "CodeBleu_score": 53.532803902309645}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id.substr(7));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (const std::exception &e) {\n\t\tROS_WARN(\"Exception caught in rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 54.99221280293385}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t//  ROS_INFO(\\\"DroneDetector::detect\\\");\n  // check if the drone is in the image\n  if (true_pixel(0) < 0 || true_pixel(0) >= img_width_ || true_pixel(1) < 0 || true_pixel(1) >= img_height_)\n    return;\n\n  // get the true pose in cam frame\n  Eigen::Vector4d true_pose_cam = depth2Pos(true_pixel(0), true_pixel(1), depth_img_.at<float>(true_pixel(1), true_pixel(0)));\n\n  // get the pose error\n  Eigen::Vector3d pose_error = true_pose_cam - drone_pose_cam_[drone_id];\n\n  // publish the pose error\n  drone_pose_error_[drone_id] = pose_error;\n  drone_pose_error_pub_[drone_id].publish(drone_pose_error_[drone_id]);\n\n  // update the debug result\n  if (getDist2(true_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n    drone_debug_result_[drone_id] = 1;\n  } else {\n    drone_debug_result_[drone_id] = 0;\n  }\n}", "CodeBleu_score": 43.12307842205375}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr temp = current;\n\tpath.push_back(temp);\n\twhile (temp->cameFrom!= NULL) {\n\t\ttemp = temp->cameFrom;\n\t\tpath.push_back(temp);\n\t}\n\treturn path;\n}", "CodeBleu_score": 57.78029968583499}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr tmp_node = current;\n\tpath.push_back(tmp_node);\n\twhile (tmp_node->cameFrom!= nullptr) {\n\t\ttmp_node = tmp_node->cameFrom;\n\t\tpath.push_back(tmp_node);\n\t}\n\treturn path;\n}", "CodeBleu_score": 56.584764843017155}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert the start and end points to grid indices\n\tif (!grid_map_->worldToMap(start_pt, start_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to convert start point to grid index\");\n\t\treturn false;\n\t}\n\tif (!grid_map_->worldToMap(end_pt, end_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to convert end point to grid index\");\n\t\treturn false;\n\t}\n\n\t// Check if the start or end point is inside an obstacle\n\tif (grid_map_->isInside(start_idx) || grid_map_->isInside(end_idx)) {\n\t\t// Adjust the start and end points until they are no longer inside an obstacle\n\t\twhile (grid_map_->isInside(start_idx) || grid_map_->isInside(end_idx)) {\n\t\t\t// Move the start point away from the end point\n\t\t\tif (grid_map_->isInside(start_idx)) {\n\t\t\t\tstart_idx += (end_idx - start_idx).normalized() * 0.1;\n\t\t\t}\n\t\t\t// Move the end point away from the start point\n\t\t\tif (grid_map_->isInside(end_idx)) {\n\t\t\t\tend_idx += (start_idx - end_idx).normalized() * 0.1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 35.181886725692266}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start and end points to indices\n\tif (!grid_map_->worldToMap(start_pt, start_idx)) {\n\t\tstd::cout << \"Failed to convert start point to index!\" << std::endl;\n\t\treturn false;\n\t}\n\tif (!grid_map_->worldToMap(end_pt, end_idx)) {\n\t\tstd::cout << \"Failed to convert end point to index!\" << std::endl;\n\t\treturn false;\n\t}\n\n\t// Adjust start and end points if they are inside obstacles\n\twhile (grid_map_->isOccupied(start_idx)) {\n\t\tstart_idx += (start_pt - end_pt).normalized();\n\t}\n\twhile (grid_map_->isOccupied(end_idx)) {\n\t\tend_idx += (end_pt - start_pt).normalized();\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 36.97967852581548}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tbool start_ok = grid_map_->worldToMap(start_pt, start_idx);\n\tbool end_ok = grid_map_->worldToMap(end_pt, end_idx);\n\n\tif (start_ok && end_ok) {\n\t\tif (grid_map_->isInside(start_idx) && grid_map_->isInside(end_idx)) {\n\t\t\t// Both points are inside the map, so no need to adjust\n\t\t\treturn true;\n\t\t} else if (grid_map_->isInside(start_idx) &&!grid_map_->isInside(end_idx)) {\n\t\t\t// Start point is inside the map, but end point is not\n\t\t\t// Adjust the end point until it is inside the map\n\t\t\twhile (!grid_map_->isInside(end_idx)) {\n\t\t\t\tend_pt = end_pt + 0.001 * (end_pt - start_pt).normalized();\n\t\t\t\tend_ok = grid_map_->worldToMap(end_pt, end_idx);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (!grid_map_->isInside(start_idx) && grid_map_->isInside(end_idx)) {\n\t\t\t// End point is inside the map, but start point is not\n\t\t\t// Adjust the start point until it is inside the map\n\t\t\twhile (!grid_map_->isInside(start_idx)) {\n\t\t\t\tstart_pt = start_pt + 0.001 * (start_pt - end_pt).normalized();\n\t\t\t\tstart_ok = grid_map_->worldToMap(start_pt, start_idx);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Both points are outside the map, so we cannot find a path\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// Conversion failed\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 45.19065437062001}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3d min_id = (min_pos - mp_.map_origin_) / mp_.resolution_;\n\tEigen::Vector3d max_id = (max_pos - mp_.map_origin_) / mp_.resolution_;\n\n\t// cout << \"min_id: \" << min_id << endl;\n\t// cout << \"max_id: \" << max_id << endl;\n\n\t// \u91cd\u7f6e\u81a8\u80c0\u5730\u56fe\n\tfor (int i = min_id(0); i <= max_id(0); ++i) {\n\t\tfor (int j = min_id(1); j <= max_id(1); ++j) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); ++k) {\n\t\t\t\tint id = i * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) + j * mp_.map_voxel_num_(2) + k;\n\t\t\t\tmd_.occupancy_buffer_inflate_[id] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 51.33929133130264}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t", "CodeBleu_score": 4.296121109088976}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = gridPos2Index(min_pos);\n\tEigen::Vector3i max_id = gridPos2Index(max_pos);\n\n\t// \u91cd\u7f6e\u5730\u56fe\n\tfor (int i = min_id(0); i <= max_id(0); i++) {\n\t\tfor (int j = min_id(1); j <= max_id(1); j++) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); k++) {\n\t\t\t\tmd_.occupancy_buffer_[i * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) + j * mp_.map_voxel_num_(2) + k] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n\t\t\t\tmd_.occupancy_buffer_inflate_[i * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) + j * mp_.map_voxel_num_(2) + k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.11773651250071}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = max(diff(0), 0.0);\n\tdouble max_y = max(diff(1), 0.0);\n\tdouble max_z = max(diff(2), 0.0);\n\tdouble min_x = min(diff(0), 0.0);\n\tdouble min_y = min(diff(1), 0.0);\n\tdouble min_z = min(diff(2), 0.0);\n\n\t// printf(\"max_x:%f,max_y:%f,max_z:%f\n\",max_x,max_y,max_z);\n\t// printf(\"min_x:%f,min_y:%f,min_z:%f\n\",min_x,min_y,min_z);\n\n\tdouble scale_x = 1.0;\n\tdouble scale_y = 1.0;\n\tdouble scale_z = 1.0;\n\n\tif (max_x > 0.0) {\n\t\tscale_x = (md_.local_bound_max_(0) - md_.local_bound_min_(0)) / max_x;\n\t}\n\tif (max_y > 0.0) {\n\t\tscale_y = (md_.local_bound_max_(1) - md_.local_bound_min_(1)) / max_y;\n\t}\n\tif (max_z > 0.0) {\n\t\tscale_z = (md_.local_bound_max_(2) - md_.local_bound_min_(2)) / max_z;\n\t}\n\n\tdouble scale = min(min(min(scale_x, scale_y), scale_z), 1.0);\n\n\t// printf(\"scale:%f\n\",scale);\n\n\treturn camera_pt + diff * scale;\n}", "CodeBleu_score": 36.23248476464001}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_scale, max_scale;\n\tmin_scale << 0, 0, 0;\n\tmax_scale << 0, 0, 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff(i) > 0) {\n\t\t\tmax_scale(i) = (max_x_(i) - pt(i)) / diff(i);\n\t\t} else {\n\t\t\tmin_scale(i) = (pt(i) - min_x_(i)) / diff(i);\n\t\t}\n\t}\n\tdouble scale = 1;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (max_scale(i) < min_scale(i)) {\n\t\t\tscale = max_scale(i);\n\t\t}\n\t}\n\treturn camera_pt + diff * scale;\n}", "CodeBleu_score": 37.17658934195909}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_scale = 1.0, y_scale = 1.0, z_scale = 1.0;\n\n\tif (diff(0) > 0) {\n\t\tx_scale = (mp_.max_x_ - camera_pt(0)) / diff(0);\n\t} else if (diff(0) < 0) {\n\t\tx_scale = (mp_.min_x_ - camera_pt(0)) / diff(0);\n\t}\n\n\tif (diff(1) > 0) {\n\t\ty_scale = (mp_.max_y_ - camera_pt(1)) / diff(1);\n\t} else if (diff(1) < 0) {\n\t\ty_scale = (mp_.min_y_ - camera_pt(1)) / diff(1);\n\t}\n\n\tif (diff(2) > 0) {\n\t\tz_scale = (mp_.max_z_ - camera_pt(2)) / diff(2);\n\t} else if (diff(2) < 0) {\n\t\tz_scale = (mp_.min_z_ - camera_pt(2)) / diff(2);\n\t}\n\n\tdouble scale = 1.0;\n\tif (x_scale < scale) {\n\t\tscale = x_scale;\n\t}\n\tif (y_scale < scale) {\n\t\tscale = y_scale;\n\t}\n\tif (z_scale < scale) {\n\t\tscale = z_scale;\n\t}\n\n\treturn camera_pt + scale * diff;\n}", "CodeBleu_score": 40.660473191553365}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n}", "CodeBleu_score": 3.3775492116118153}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n//  printf(\\\"updateOccupancyCallback\n\\\");\n  // update the last occupancy update time\n  md_.last_update_time_ = ros::Time::now();\n\n  // check if update is needed\n  if (!mp_.update_map_ ||!mp_.update_map_on_new_depth_ ||!mp_.update_map_on_new_odometry_) {\n    return;\n  }\n\n  // check for timeout errors\n  if (md_.last_depth_time_ + mp_.depth_timeout_ < ros::Time::now() &&\n      md_.last_odometry_time_ + mp_.odometry_timeout_ < ros::Time::now()) {\n    ROS_WARN_THROTTLE(1.0, \\\"No depth or odometry data received within timeout. Update will not be performed.\\\");\n    return;\n  }\n\n  // get sensor data\n  sensor_msgs::PointCloud2ConstPtr depth_msg;\n  if (mp_.use_sensor_depth_) {\n    depth_msg = md_.depth_msg_;\n  } else {\n    depth_msg = md_.odometry_msg_->child_frame_cloud;\n  }\n\n  // project depth image into points\n  sensor_msgs::PointCloud2 points_msg;\n  if (!projectDepthImageToPointCloud(depth_msg, points_msg)) {\n    ROS_ERROR_THROTTLE(1.0, \\\"Failed to project depth image into points.\\\");\n    return;\n  }\n\n  // process points with raycasting\n  if (!raycast(points_msg, md_.occupancy_buffer_, md_.occupancy_buffer_inflate_)) {\n    ROS_ERROR_THROTTLE(1.0, \\\"Failed to process points with raycasting.\\\");\n    return;\n  }\n\n  // clear and inflate local map\n  clearAndInflateLocalMap();\n\n  // update local map\n  md_.local_map_updated_ = true;\n}", "CodeBleu_score": 48.422024617649484}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t//   // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\n//   publishMapInflate(true);\n//   // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff08\u4ec5\u9488\u5bf9\u76f8\u673a\u662f\u8f93\u5165\u7684\u60c5\u51b5\uff09\n//   publishMap();\n}", "CodeBleu_score": 3.3775492116118153}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_sum = 0.f;\n\tunsigned n = image_fns.size();\n\n\tfor (unsigned i = 0; i < n; ++i) {\n\t\tstring image_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\n\t\tMat3b img = imread(image_fn, IMREAD_COLOR);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error opening: \" << image_fn << endl;\n\t\t\treturn -1.f;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure_sum += fmeasure;\n\t}\n\n\treturn fmeasure_sum / float(n);\n}", "CodeBleu_score": 48.5197904879875}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure = 0.f;\n\tunsigned n_images = image_fns.size();\n\tfor (unsigned i = 0; i < n_images; ++i) {\n\t\tMat3b img = imread(image_fns[i], IMREAD_COLOR);\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tfmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\treturn fmeasure / n_images;\n}", "CodeBleu_score": 55.131402519567544}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat fmeasure_sum = 0.f;\n\tint image_count = 0;\n\n\tfor (unsigned int i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img = imread(image_fns[i], IMREAD_COLOR);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error reading image: \" << image_fns[i] << endl;\n\t\t\treturn -1.f;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure_sum += fmeasure;\n\t\t++image_count;\n\t}\n\n\treturn fmeasure_sum / float(image_count);\n}", "CodeBleu_score": 54.47978938780555}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t/*\n * check parameters\n */\nif (foci == NULL) {\nfprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null.\n\");\nreturn 0.0;\n}\n\n/*\n * compute angles from point to foci\n */\nfloat a = atan2(y - foci[1], x - foci[0]);\nfloat b = atan2(y - foci[3], x - foci[2]);\n\n/*\n * compute angle difference and adjust to lie in range [-\u03c0, \u03c0]\n */\nfloat angle = angle_diff_signed(a, b);\n\nreturn angle;\n}", "CodeBleu_score": 46.345819733793086}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle, f1, f2;\n\tif (foci == NULL) {\n\t\tfprintf(stderr, \"_ellipse_normal_angle: 'foci' must be non null.\n\");\n\t\treturn 0.0;\n\t}\n\tf1 = sqrt((x - foci[0]) * (x - foci[0]) + (y - foci[1]) * (y - foci[1]));\n\tf2 = sqrt((x - foci[2]) * (x - foci[2]) + (y - foci[3]) * (y - foci[3]));\n\tangle = atan2(foci[1] - y, foci[0] - x) - atan2(foci[3] - y, foci[2] - x);\n\tif (angle > M_PI) angle -= M_2__PI;\n\tif (angle < -M_PI) angle += M_2__PI;\n\treturn angle;\n}", "CodeBleu_score": 50.17005113699875}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t", "CodeBleu_score": 2.6118173022443996}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u > integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 91.985043025344}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u > integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 91.985043025344}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint x_min(4096), x_max(0), y_min(4096), y_max(0);\n\tint integral_u(0), integral_d(0);\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tx_min = MIN(x_min, val.x);\n\t\tx_max = MAX(x_max, val.x);\n\t\ty_min = MIN(y_min, val.y);\n\t\ty_max = MAX(y_max, val.y);\n\t}\n\tfor (int i = start; i <= end; i++) {\n\t\tPoint& val = vp1[i];\n\t\tintegral_u += (val.y - y_min);\n\t\tintegral_d += (y_max - val.y);\n\t}\n\tif (integral_u > integral_d)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 91.985043025344}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (is_detected) {\n\t\t\tellipse_det = msg->detection_info[i];\n\t\t}\n\t}\n}", "CodeBleu_score": 51.485808187894}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tint i = 0;\n\tfor (auto det : msg->detections) {\n\t\tif (det.name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tellipse_det = det;\n\t\tswap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n\t\ti++;\n\t}\n}", "CodeBleu_score": 60.08152502888099}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// Iterate through each detection info\n\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\t// If the object name is \"T\"\n\t\tif (msg->detection_info[i].object_name == \"T\") {\n\t\t\t// Increment num_regain\n\t\t\tnum_regain++;\n\t\t\t// Reset num_lost\n\t\t\tnum_lost = 0;\n\t\t}\n\t\telse {\n\t\t\t// Increment num_lost\n\t\t\tnum_lost++;\n\t\t\t// Reset num_regain\n\t\t\tnum_regain = 0;\n\t\t}\n\t\t// If num_lost exceeds VISION_THRES\n\t\tif (num_lost > VISION_THRES) {\n\t\t\t// Set is_detected to false\n\t\t\tis_detected = false;\n\t\t}\n\t\t// If num_regain exceeds VISION_THRES\n\t\tif (num_regain > VISION_THRES) {\n\t\t\t// Set is_detected to true\n\t\t\tis_detected = true;\n\t\t}\n\t\t// Swap the sight_angle values of ellipse_det\n\t\tswap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n\t}\n}", "CodeBleu_score": 57.57628123478664}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\n/*\n * The function first checks if the position is occupied by any obstacle in the Occupy_map_ptr. If it is occupied, the function returns false to indicate that the position is not safe.\n *\n * The function then checks if the position is within the safe distance from any obstacle in the Occupy_map_ptr. If it is within the safe distance, the function returns false to indicate that the position is not safe.\n *\n * If none of the above conditions are met, the function returns true to indicate that the position is safe.\n */\nbool is_occupy = Occupy_map_ptr->isOccupied(cur_pos);\n\nif (is_occupy) {\nreturn false;\n}\n\nfor (int i = 0; i < 3; ++i) {\nif (cur_pos(i) < safe_distance || cur_pos(i) > Occupy_map_ptr->get_size(i) - safe_distance) {\nreturn false;\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 42.17044761225974}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t", "CodeBleu_score": 10.461696713377352}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t", "CodeBleu_score": 10.461696713377352}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\n/* ---------- retrieve path from end node to start node ---------- */\n  NodePtr cur_node = end_node;\n  while (cur_node->parent!= NULL) {\n    path_nodes_.push_back(cur_node);\n    cur_node = cur_node->parent;\n  }\n  path_nodes_.push_back(cur_node);\n\n/* ---------- reverse path_nodes_ to present path from start to end ---------- */\n  vector<NodePtr> path_nodes_tmp;\n  while (!path_nodes_.empty()) {\n    path_nodes_tmp.push_back(path_nodes_.back());\n    path_nodes_.pop_back();\n  }\n  path_nodes_ = path_nodes_tmp;\n}", "CodeBleu_score": 67.3367308553842}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t//  cout << \\\"Astar: retrieve path\\\" << endl;\n  if (end_node == NULL) {\n    cout << RED << \\\"Astar: [ retrievePath: end_node is NULL ]\\\"  << TAIL <<endl;\n    return;\n  }\n\n  // \u8bb0\u5f55\u8def\u5f84\n  path_nodes_.clear();\n  path_nodes_.push_back(end_node);\n\n  NodePtr cur_node = end_node;\n  while (cur_node->parent!= NULL) {\n    path_nodes_.push_back(cur_node->parent);\n    cur_node = cur_node->parent;\n  }\n\n  // \u8def\u5f84\u53cd\u8f6c\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 69.06828790146695}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr cur_node = end_node;\n\tpath_nodes_.clear();\n\twhile (cur_node!= NULL) {\n\t\tpath_nodes_.push_back(cur_node);\n\t\tcur_node = cur_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.21497239049587}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // \u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    state_nei[id] << odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z;\n    if(sim_mode)\n    {\n        if(sqrt(pow(odom->pose.pose.position.x,2)+pow(odom->pose.pose.position.y,2)) > 5.0)\n        {\n            get_nei_state[id] = false;\n        }\n        else\n        {\n            get_nei_state[id] = true;\n        }\n    }\n    else\n    {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 58.173747130101546}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n//    if(sim_mode)  {\n//        // get distance from start position\n//        double dist = sqrt(pow(odom->pose.pose.position.x, 2) + pow(odom->pose.pose.position.y, 2));\n//        if(dist > 5)  {\n//            get_nei_state[id] = false;\n//        } else {\n//            get_nei_state[id] = true;\n//        }\n//    } else {\n//        get_nei_state[id] = true;\n//    }\n\n    state_nei[id].x() = odom->pose.pose.position.x;\n    state_nei[id].y() = odom->pose.pose.position.y;\n    state_nei[id].z() = odom->pose.pose.position.z;\n}", "CodeBleu_score": 23.398392042849974}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//    if (!odom_ready) {\n//        return;\n//    }\n//    if (!sensor_ready) {\n//        sensor_ready = true;\n//        update_counter = 0;\n//    }\n//    if (update_counter++ == 5) {\n//        update_counter = 0;\n//        Astar_ptr->Occupy_map_ptr->update_map(msg);\n//    }\n}", "CodeBleu_score": 5.524728674891709}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tif (sensor_ready) {\n\t\tupdate_counter++;\n\t} else {\n\t\tsensor_ready = true;\n\t}\n\tif (update_counter >= 5) {\n\t\tupdate_counter = 0;\n\t\tAstar_ptr->Occupy_map_ptr->update_map(msg, ugv_odom);\n\t}\n}", "CodeBleu_score": 48.820653877884254}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//    if (!odom_ready) {\n//        return;\n//    }\n//    sensor_ready = true;\n//    sensor_update_counter++;\n//    if (sensor_update_counter == 5) {\n//        sensor_update_counter = 0;\n//        Astar_ptr->Occupy_map_ptr->update_map(msg, ugv_odom.pose.pose.position.x, ugv_odom.pose.pose.position.y,\n//                                              ugv_odom.pose.pose.position.z);\n//    }\n}", "CodeBleu_score": 5.524728674891709}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\t// \u5168\u5c40\u70b9\u4e91\u6307\u9488\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t// \u8f6c\u6362\u4e3a\u70b9\u4e91\n\tpcl::fromROSMsg(*global_point, *global_point_cloud);\n\t// \u5168\u5c40\u70b9\u4e91\u6307\u9488\n\tglobal_point_cloud_map = global_point_cloud;\n\t// \u5168\u5c40\u5730\u56fe\u70b9\u4e91\u6307\u9488\n\tglobal_ugv_pcl = global_point_cloud;\n\t// \u81a8\u80c0\u70b9\u4e91\u6307\u9488\n\tcloud_inflate_vis_ = global_point_cloud;\n\t// \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n\tinput_point_cloud = global_point_cloud;\n\t// tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n\ttransformed_cloud = global_point_cloud;\n\t// \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n\tpcl_ptr = global_point_cloud;\n\t// \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n\tst_it = 0;\n\t// \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n\tf_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\t// \u5168\u5c40\u5730\u56fe\u66f4\u65b0\u6807\u5fd7\u4f4d\n\tget_gpcl = true;\n\tget_lpcl = false;\n\tget_laser = false;\n\t// \u5730\u56fe\u66f4\u65b0\u51fd\u6570 - \u8f93\u5165\uff1a\u5168\u5c40\u70b9\u4e91\n\tmap_update();\n}", "CodeBleu_score": 43.403388041348265}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\t// \u5168\u5c40\u5730\u56fe\u66f4\u65b0\u6807\u5fd7\u4f4d\n\tif (get_gpcl == false) {\n\t\t// \u5168\u5c40\u5730\u56fe\u66f4\u65b0\u6807\u5fd7\u4f4d\u8bbe\u4e3atrue\n\t\tget_gpcl = true;\n\t\t// \u5168\u5c40\u5730\u56fe\u66f4\u65b0\n\t\tpcl::fromROSMsg(*global_point, *global_point_cloud_map);\n\t\t// \u5168\u5c40\u5730\u56fe\u81a8\u80c0\n\t\tinflate_pcl(global_point_cloud_map, cloud_inflate_vis_, ugv_height);\n\t\t// \u5168\u5c40\u5730\u56fe\u5b58\u50a8\n\t\tglobal_point_cloud_map->points.swap(global_ugv_pcl->points);\n\t\tglobal_ugv_pcl->header.frame_id = global_point->header.frame_id;\n\t\tglobal_ugv_pcl->header.stamp = global_point->header.stamp;\n\t}\n}", "CodeBleu_score": 51.15455700283036}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\n\tpcl::fromROSMsg(*local_point,*input_point_cloud);\n\n\thas_global_point = true;\n\n\tif(sim_mode) {\n\t\tif(queue_size <= 0) { // without slide windows\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *input_point_cloud;\n\t\t} else { // with slide windows\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int,pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor(iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 56.66930726120422}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*local_point, *laser_cloud);\n\n\thas_global_point = true;\n\n\tif (sim_mode) {\n\t\tif (queue_size <= 0) // without slide windows\n\t\t{\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *laser_cloud;\n\t\t} else // with slide windows\n\t\t{\n\t\t\t// slide windows with size: $queue_size\n\n\t\t\tpoint_cloud_pair[st_it] = *laser_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int, pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor (iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++) {\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t} else {\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 55.6612425407159}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// \u7531sensor_msgs::LaserScan \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n\n\tpcl::fromROSMsg(*local_point,*input_point_cloud);\n\thas_global_point = true;\n\n\tif(sim_mode) {\n\t\tif(queue_size <= 0) // without slide windows\n\t\t{\n\t\t\t// map_generator\u751f\u6210\u7684\u70b9\u4e91\u4e3aworld\u5750\u6807\u7cfb\n\t\t\t*global_point_cloud_map += *input_point_cloud;\n\t\t}\n\t\telse // with slide windows\n\t\t{\n\t\t\t// slide windows with size: $queue_size\n\t\t\tpoint_cloud_pair[st_it] = *input_point_cloud; // \u52a0\u5165\u65b0\u70b9\u4e91\u5230\u6ed1\u7a97\n\t\t\tst_it = (st_it + 1) % queue_size; // \u6307\u5411\u4e0b\u4e00\u4e2a\u79fb\u9664\u7684\u70b9\u4e91\u4f4d\u7f6e\n\n\t\t\t// \u7d2f\u8ba1\u5c40\u90e8\u5730\u56fe\uff1a\u9700\u898120\u4e2a\u52a0\u6cd5\uff0cO\uff081\uff09\u5185\u5b58\uff1b\u589e\u91cf\u5f0f\uff1a\u9700\u898119\u4e2a\u52a0\u6cd5\uff0cO\uff081.5\uff09\u5185\u5b58\n\t\t\tglobal_point_cloud_map.reset(new pcl::PointCloud<pcl::PointXYZ>);\n\t\t\tmap<int,pcl::PointCloud<pcl::PointXYZ>>::iterator iter;\n\t\t\tfor(iter = point_cloud_pair.begin(); iter!= point_cloud_pair.end(); iter++)\n\t\t\t{\n\t\t\t\t*global_point_cloud_map += iter->second;\n\t\t\t}\n\t\t}\n\n\t\t// downsample\n\t\t*pcl_ptr = *global_point_cloud_map;\n\t\tvg.setInputCloud(pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f); // \u4e0b\u91c7\u6837\u53f6\u5b50\u8282\u70b9\u5927\u5c0f\uff083D\u5bb9\u5668\uff09\n\t\tvg.filter(*global_point_cloud_map);\n\t\tinflate_point_cloud();\n\t}else\n\t{\n\t\tlocal_map_merge_odom(odom);\n\t}\n}", "CodeBleu_score": 59.81393067955122}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u66f4\u65b0\u9891\u7387\u8f83\u9ad8\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom);\n}", "CodeBleu_score": 94.36716847833098}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u53ea\u66f4\u65b0\u4e00\u6b21\n\tif (!Astar_ptr->Occupy_map_ptr->get_lpcl) {\n\t\t// \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n\t\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n\t}\n}", "CodeBleu_score": 78.7040738011076}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\t// \u56e0\u4e3a\u5c40\u90e8\u70b9\u4e91\u4e00\u822c\u8f83\u5c0f\uff0c\u6bcf\u6b21\u90fd\u66f4\u65b0\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom);\n}", "CodeBleu_score": 93.94223171429516}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif(publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\n\t\tfor(size_t i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i] = foot_contacts[i];\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 63.65579476911869}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.legs.resize(4);\n\n\t\tfor (size_t i = 0; i < 4; ++i) {\n\t\t\tcontacts_msg.legs[i].phase = leg_controller_.phase(i);\n\t\t\tcontacts_msg.legs[i].contact = foot_contacts[i];\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 65.67273727911194}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif(publish_foot_contacts_ &&!in_gazebo_) {\n\t\tchamp_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.contacts.resize(4);\n\t\tfor(size_t i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].phase = leg_controller_.getPhase(i);\n\t\t\tcontacts_msg.contacts[i].contact = foot_contacts[i];\n\t\t}\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 72.1955100168425}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t/*\n * Create a minimal joints message\n */\njoints_msg = Joints()\njoints_msg.header.stamp = rospy.Time.now()\njoints_msg.header.frame_id = 'base_link'\njoints_msg.joints = [0,0,0,0,0,0,0,0,0,0,0,0]\n\n/*\n * Copy the first 12 joint positions from the incoming joints message\n */\nfor i in range(0,12):\njoints_msg.joints[i] = joints.position[i]\n\n/*\n * Publish the minimal joints message\n */\nself.joint_minimal_pub.publish(joints_msg)\n\n/*\n * Construct a joint trajectory message\n */\njoint_trajectory_msg = JointTrajectory()\njoint_trajectory_msg.header.stamp = rospy.Time.now()\njoint_trajectory_msg.header.frame_id = 'base_link'\njoint_trajectory_msg.joint_names = self.joint_names\njoint_trajectory_msg.points = [JointTrajectoryPoint()]\njoint_trajectory_msg.points[0].time_from_start = rospy.Duration(0.5)\njoint_trajectory_msg.points[0].positions = joints_msg.joints\n\n/*\n * Publish the joint trajectory message\n */\nself.joint_trajectory_pub.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 53.34798268651757}, {"code": "def joints_cmd_callback(self, joints){\n\t\n// Create minimal joints message\nJoints joints_msg = Joints()\njoints_msg.header.stamp = rospy.Time.now()\njoints_msg.header.frame_id = \\\"\\\"\njoints_msg.joint_names = self.joint_names\nfor i in range(0, len(joints.position)):\njoints_msg.positions.append(joints.position[i])\n\n// Publish minimal joints message\nself.joint_minimal_pub.publish(joints_msg)\n\n// Create joint trajectory message\nJointTrajectory joint_trajectory_msg = JointTrajectory()\njoint_trajectory_msg.header.stamp = rospy.Time.now()\njoint_trajectory_msg.header.frame_id = \\\"\\\"\njoint_trajectory_msg.joint_names = self.joint_names\njoint_trajectory_msg.points.append(JointTrajectoryPoint())\njoint_trajectory_msg.points[0].time_from_start = rospy.Duration(0.1)\nfor i in range(0, len(joints.position)):\njoint_trajectory_msg.points[0].positions.append(joints.position[i])\n\n// Publish joint trajectory message\nself.joint_trajectory_pub.publish(joint_trajectory_msg)\n\n}", "CodeBleu_score": 51.90590126571672}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t", "CodeBleu_score": 1.3983365370963055}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision_name = _msg->contact(i).collision1();\n\t\tstd::vector<std::string> split_collision_name;\n\t\tboost::split(split_collision_name, collision_name, boost::is_any_of(\\\"/\\\"));\n\t\tif (split_collision_name.size() > 1) {\n\t\t\tcollision_name = split_collision_name[split_collision_name.size() - 1];\n\t\t}\n\t\tif (std::find(foot_links_.begin(), foot_links_.end(), collision_name)!= foot_links_.end()) {\n\t\t\tfoot_contacts_[std::distance(foot_links_.begin(), std::find(foot_links_.begin(), foot_links_.end(), collision_name))] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.003965835828026}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor(int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision_strings;\n\n\t\tboost::split(collision_strings, _msg->contact(i).collision1(), boost::is_any_of(\\\"/\\\"));\n\t\tfor(int j = 0; j < foot_links_.size(); j++) {\n\n/*\n * If the first collision string in the contact matches one of the foot links, set the corresponding foot contact state to true.\n */\nif(collision_strings[0] == foot_links_[j]) {\nfoot_contacts_[j] = true;\n}\n\n/*\n * If the second collision string in the contact matches one of the foot links, set the corresponding foot contact state to true.\n */\nif(collision_strings[1] == foot_links_[j]) {\nfoot_contacts_[j] = true;\n}\n}\n}\n\n/*\n * This function publishes foot contact states to a ROS topic.\n */\nvoid publishFootContacts() {\nchamp_msgs::ContactsStamped foot_contacts_msg;\n\n\tfor(int i = 0; i < foot_links_.size(); i++) {\n\n/*\n * If the foot contact state is true, set the corresponding foot contact state message to true.\n */\nif(foot_contacts_[i]) {\nfoot_contacts_msg.contacts.push_back(true);\n}\n\n/*\n * If the foot contact state is false, set the corresponding foot contact state message to false.\n */\nelse {\nfoot_contacts_msg.contacts.push_back(false);\n}\n}\n\n/*\n * Publish foot contact states to a ROS topic.\n */\ncontacts_publisher_.publish(foot_contacts_msg);\n}\n}", "CodeBleu_score": 53.79778707382826}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t// Check if the controller is active.\nif (!controller_active_) {\n// If not, set all rotor velocities to zero.\nrotor_velocities->setZero();\nreturn;\n}\n\n// Check if the input is valid.\nif (rotor_velocities->size()!= vehicle_parameters_.rotor_configuration_.rotors.size()) {\nROS_ERROR(\"rotor_velocities vector size does not match rotor configuration.\");\nreturn;\n}\n\n// Check if the parameters are valid.\nif (!initialized_params_) {\nROS_ERROR(\"LeePositionController parameters not initialized.\");\nreturn;\n}\n\n// Calculate the desired acceleration and angular acceleration.\nEigen::Vector3d desired_acceleration = CalculateDesiredAcceleration();\nEigen::Vector3d desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n// Project thrust onto the body z-axis.\nEigen::Vector3d thrust_projection = desired_acceleration.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n\n// Combine angular acceleration and thrust into a single vector.\nEigen::Vector4d angular_acceleration_and_thrust = Eigen::Vector4d::Zero();\nangular_acceleration_and_thrust << desired_angular_acceleration, thrust_projection;\n\n// Calculate the rotor velocities.\nEigen::VectorXd angular_acc_to_rotor_velocities_transpose = angular_acc_to_rotor_velocities_.transpose();\n*rotor_velocities = angular_acc_to_rotor_velocities_transpose * angular_acceleration_and_thrust;\nrotor_velocities->array().sqrt().min(0.0).max(1.0);\n}", "CodeBleu_score": 45.30666927027035}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t", "CodeBleu_score": 5.185615338987256}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t/*\n * The position error is computed by subtracting the current position from the commanded position.\n */\n  Eigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position;\n/*\n * The velocity error is computed by subtracting the current velocity from the commanded velocity.\n */\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity_W - odometry_.velocity;\n/*\n * The acceleration error is computed by subtracting the current acceleration from the commanded acceleration.\n */\n  Eigen::Vector3d acceleration_error = command_trajectory_.acceleration_W - odometry_.acceleration;\n/*\n * The desired acceleration is computed by adding the position, velocity, and acceleration errors to the commanded acceleration.\n */\n  *acceleration = command_trajectory_.acceleration_W + position_gain_ * position_error + velocity_gain_ * velocity_error + acceleration_gain_ * acceleration_error;\n/*\n * The desired acceleration is adjusted for vehicle mass, gravity, and the commanded acceleration.\n */\n  *acceleration -= vehicle_parameters_.mass_ * Eigen::Vector3d::UnitZ() + vehicle_parameters_.gravity_ * Eigen::Vector3d::UnitZ() + command_trajectory_.acceleration_W;\n}", "CodeBleu_score": 46.66954390501038}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t//  assert(acceleration);\\\n//  assert(initialized_params_);\n//\n//  // Calculate the position and velocity errors.\n//  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position_W;\n//  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity_W;\n//\n//  // Calculate the desired acceleration.\n//  *acceleration = command_trajectory_.acceleration_W - vehicle_parameters_.gravity_ - normalized_attitude_gain_ * position_error\\\n//      - normalized_angular_rate_gain_ * velocity_error;\n}", "CodeBleu_score": 5.271696618906548}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  if (!initialized_params_) {\n//    std::cerr << \\\"AttitudeControllerSamy::CalculateRotorVelocities: parameters not initialized!\\\" << std::endl;\n\n    return;\n  }\n\n  // Check the input\n  if (rotor_velocities->size()!= amount_rotors_) {\n    std::cerr << \\\"AttitudeControllerSamy::CalculateRotorVelocities: invalid number of rotors!\\\" << std::endl;\n\n    return;\n  }\n\n  // Resize the output\n  rotor_velocities->resize(amount_rotors_);\n\n  // Calculate the desired angular acceleration\n  Eigen::Vector3d desired_angular_acceleration = gain_attitude_ * (reference_attitude_ - attitude_);\n\n  // Combine the desired angular acceleration with the thrust reference\n  Eigen::VectorXd combined_vector = desired_angular_acceleration + angular_acc_to_rotor_velocities_ * thrust_reference_;\n\n  // Compute the rotor velocities\n  for (int i = 0; i < amount_rotors_; i++) {\n    rotor_velocities->coeffRef(i) = std::max(1.0, std::sqrt(combined_vector(i)));\n  }\n}", "CodeBleu_score": 37.91330507871178}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n/*\n * The input parameters are checked for validity.\n */\n  if (!initialized_params_) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: Parameters not initialized!\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities == nullptr) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: Invalid rotor velocities pointer!\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->size()!= amount_rotors_) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: Invalid rotor velocities vector size!\" << std::endl;\n    return;\n  }\n\n/*\n * The desired angular acceleration is calculated by multiplying the desired attitude error with a gain matrix.\n */\n  Eigen::Vector3d desired_angular_acc = gain_attitude_ * attitude_error_;\n\n/*\n * The desired angular acceleration is combined with the thrust reference into a single vector.\n */\n  Eigen::Vector4d desired_angular_acc_and_thrust;\n  desired_angular_acc_and_thrust << desired_angular_acc, thrust_reference_;\n\n/*\n * The rotor velocities are calculated by multiplying the desired angular acceleration and thrust with a predefined matrix.\n */\n  Eigen::Vector4d desired_rotor_velocities = angular_acc_to_rotor_velocities_ * desired_angular_acc_and_thrust;\n\n/*\n * The rotor velocities are clipped to ensure they are at least one.\n */\n  for (int i = 0; i < amount_rotors_; i++) {\n    desired_rotor_velocities(i) = std::max(1.0, desired_rotor_velocities(i));\n  }\n\n/*\n * The rotor velocities are squared and then the square root is taken to get the desired rotor velocities.\n */\n  *rotor_velocities = desired_rotor_velocities.cwiseSqrt();\n}", "CodeBleu_score": 40.06488597178221}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t/*\n * This function, AttitudeControllerSamy::CalculateRotorVelocities, computes the rotor velocities for a vehicle.\nIt ensures the input and parameters are valid, then resizes the rotor velocities vector to match the number of rotors.\nIt calculates the desired angular acceleration and combines it with the thrust reference into a single vector.\nThe rotor velocities are computed by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component.\n */\n  if (!initialized_params_) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: Parameters not initialized.\" << std::endl;\n    return;\n  }\n  if (rotor_velocities->size()!= amount_rotors_) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: Size of rotor_velocities does not match amount_rotors_.\n\" << std::endl;\n    return;\n  }\n  Eigen::VectorXd desired_angular_acceleration(3);\n  desired_angular_acceleration = gain_attitude_ * (*attitude_ref_ - *attitude_);\n  desired_angular_acceleration(2) += gain_angular_rate_ * (*angular_rate_ref_ - *angular_rate_)(2);\n  desired_angular_acceleration(2) += gravity_ / mass_;\n  desired_angular_acceleration(2) = std::min(std::max(desired_angular_acceleration(2), 0.0), 1.0);\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * desired_angular_acceleration;\n  rotor_velocities->array().max(1.0);\n  rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 44.04991571598129}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_idx = numpy.where(self.time >= start_time)[0][0]", "CodeBleu_score": 3.917514804737962}, {"code": "def slice(self, start_time, end_time)\n\t\n    if not self.time.size:\n        return self\n    start_idx = numpy.searchsorted(self.bag_time, start_time)\n    end_idx = numpy.searchsorted(self.bag_time, end_time)\n    if start_idx == end_idx:\n        return None\n    if end_idx > self.bag_time.size:\n        end_idx = self.bag_time.size\n    if start_idx > end_idx:\n        return None\n    new_obj = copy.deepcopy(self)\n    new_obj.time = self.time[start_idx:end_idx]\n    new_obj.bag_time = self.bag_time[start_idx:end_idx]\n    return new_obj\n\n", "CodeBleu_score": 41.185814229261034}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices for the start and end times\n    start_index = numpy.where(self.time >= start_time)[0][0]\n    end_index = numpy.where(self.time <= end_time)[0][-1]\n\n    # Create a deep copy of the object\n    sliced_obj = copy.deepcopy(self)\n\n    # Slice the attributes\n    sliced_obj.time = self.time[start_index:end_index+1]\n    sliced_obj.bag_time = self.bag_time[start_index:end_index+1]\n\n    return sliced_obj\n\n", "CodeBleu_score": 25.296099503069907}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if self.empty:\n        self.empty = False\n    else:\n        # Check if the waypoint is different from the last one.\n        if (waypoint_msg.pose.position.x == self.x[-1] and\n            waypoint_msg.pose.position.y == self.y[-1] and\n            waypoint_msg.pose.position.z == self.z[-1] and\n            waypoint_msg.pose.orientation.w == self.w[-1] and\n            waypoint_msg.pose.orientation.x == self.x[-1] and\n            waypoint_msg.pose.orientation.y == self.y[-1] and\n            waypoint_msg.pose.orientation.z == self.z[-1]):\n            return\n        else:\n            self.append_point(waypoint_msg.pose.position)\n            self.append_quaternion(waypoint_msg.pose.orientation)\n            quat_euler = tf.transformations.euler_from_quaternion(\n                [waypoint_msg.pose.orientation.x,\n                 waypoint_msg.pose.orientation.y,\n                 waypoint_msg.pose.orientation.z,\n                 waypoint_msg.pose.orientation.w])\n            self.yaw = numpy.append(self.yaw, quat_euler[2])\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 32.784595507968525}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Append the position and rotation to the arrays.\n    self.append_point(waypoint_msg.pose.position)\n    self.append_quaternion(waypoint_msg.pose.orientation)\n    # Convert the quaternion to Euler angles.\n    euler = tf.transformations.euler_from_quaternion(\n        [waypoint_msg.pose.orientation.x,\n         waypoint_msg.pose.orientation.y,\n         waypoint_msg.pose.orientation.z,\n         waypoint_msg.pose.orientation.w])\n    # Append the yaw to the array.\n    self.yaw = numpy.append(self.yaw, euler[2])\n    # Append the time to the arrays.\n    self.append_times(msg_time, bag_time)\n    # Check if the current waypoint is different from the last one.\n    if self.empty or self.x[-1]!= waypoint_msg.pose.position.x or self.y[-1]!= waypoint_msg.pose.position.y or self.z[-1]!= waypoint_msg.pose.position.z or self.yaw[-1]!= euler[2]:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays.\n        self.append_point(waypoint_msg.pose.position)\n        self.append_quaternion(waypoint_msg.pose.orientation)\n        self.yaw = numpy.append(self.yaw, euler[2])\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n", "CodeBleu_score": 29.133195851651188}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message.\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles.\n    euler = tf.transformations.euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    # Create a Point object.\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the current waypoint is different from the last one.\n    if self.empty or (point.x!= self.x[-1] or point.y!= self.y[-1] or euler[2]!= self.yaw[-1]):\n        self.append_point(point)\n        self.append_yaw(euler[2])\n        self.append_times(msg_time, bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 27.37283449156941}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        elif \\\"Imu\\\" in str(type(msg)):\\\n            self.acc[index].append_point(msg.linear_acceleration)\n            self.acc[index].append_times(msg_time, bag_time)\n            self.ang_vel[index].append_point(msg.angular_velocity)\n            self.ang_vel[index].append_times(msg_time, bag_time)\n        else:\\\n            print(\\\"Got unknown type: %s\\\" % type(msg))\n", "CodeBleu_score": 46.24737681617403}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\\\n            continue\n        elif \\\"Imu\\\" in str(type(msg)):\\\n            self.acc[index].append_point(msg.linear_acceleration)\\\n            self.acc[index].append_times(msg_time, bag_time)\n            self.ang_vel[index].append_point(msg.angular_velocity)\\\n            self.ang_vel[index].append_times(msg_time, bag_time)\n        else:\\\n            print(\\\"Got unknown type: %s\\\" % type(msg))\n\n", "CodeBleu_score": 45.003169586495204}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic!= imu_topic:\n            continue\n        elif \\\"Imu\\\" in str(type(msg)):\\\n            self.acc[index].append_point(msg.linear_acceleration)\\\n            self.acc[index].append_times(msg_time, bag_time)\\\n        elif \\\"Vector3Stamped\\\" in str(type(msg)):\\\n            self.acc[index].append_point(msg.vector)\\\n            self.acc[index].append_times(msg_time, bag_time)\\\n        elif \\\"Point32Stamped\\\" in str(type(msg)):\\\n            self.acc[index].append_point(msg.point)\\\n            self.acc[index].append_times(msg_time, bag_time)\\\n        else:\\\n            print(\\\"Got unknown type: %s\\\" % type(msg))\n\n\n", "CodeBleu_score": 28.732374925555277}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    if start_time:\n        a_x.axvline(x=start_time, color='c')\n    if end_time:\n        a_x.axvline(x=end_time, color='m')\n    if settling_time:\n        a_x.axvline(x=settling_time, color='k')\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n", "CodeBleu_score": 73.8470648105739}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    if start_time:\n        a_x.axvline(x=start_time, color='c')\n    if end_time:\n        a_x.axvline(x=end_time, color='m')\n    if settling_time:\n        a_x.axvline(x=settling_time, color='k')\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_accelerations' if self.prefix else 'accelerations'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n", "CodeBleu_score": 75.04603495825705}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.pose_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.pose_topics[index])\n\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n\n    if self.save_plots:\n        file_name = self.prefix + '_acceleration' if self.prefix else 'acceleration'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)\n\n    # pyplot.show()\n\n", "CodeBleu_score": 75.78343367382993}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\\\n        raise ValueError('compare_positions requires at least two pose indices')\n    for pose_index in pose_indeces:\\\n        for other_pose_index in pose_indeces[pose_indeces.index(pose_index) + 1:]:\n            self.compare_two_xyz(pose_index, other_pose_index)\n\n", "CodeBleu_score": 25.347441706085583}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        rospy.logerr('Not enough poses to compare')\n        return\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(self.pos[pose_indeces[i]], self.pos[pose_indeces[j]], i, j)\n\n", "CodeBleu_score": 38.8990672779178}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        return\n\n    for index, pose_index in enumerate(pose_indeces):\n        for next_index in pose_indeces[index + 1:]:\n            self.compare_two_xyz(pose_index, next_index)\n\n", "CodeBleu_score": 45.709653291734966}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        if start_time and wrench.time < start_time:\n            continue\n        if end_time and wrench.time > end_time:\n            break\n        if wrench.collision:\n            collision_times.append(wrench.time)\n    return collision_times\n", "CodeBleu_score": 41.78290630227976}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        for collision in wrench.collisions:\n            if start_time and end_time:\n                if collision.time >= start_time and collision.time <= end_time:\n                    collision_times.append(collision.time)\n            elif start_time:\n                if collision.time >= start_time:\n                    collision_times.append(collision.time)\n            elif end_time:\n                if collision.time <= end_time:\n                    collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.27049288662653}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for wrench in self.wrench:\n        if start_time and end_time:\n            if wrench.time >= start_time and wrench.time <= end_time:\n                collision_times.append(wrench.time)\n        elif start_time:\n            if wrench.time >= start_time:\n                collision_times.append(wrench.time)\n        elif end_time:\n            if wrench.time <= end_time:\n                collision_times.append(wrench.time)\n        else:\n            collision_times.append(wrench.time)\n    return collision_times\n\n", "CodeBleu_score": 36.318627681077416}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(start_time=start_time,\n                                        end_time=end_time,\n                                        settling_time=absolute_settling_time,\n                                        x_range=x_range,\n                                        plot_suffix=plot_suffix,\n                                        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 69.40068372186586}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\\\n        start_time=start_time,\\\n        end_time=end_time,\\\n        settling_time=absolute_settling_time,\\\n        x_range=x_range,\\\n        plot_suffix=plot_suffix,\\\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 66.49447345366106}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(start_time=start_time,\n                                        end_time=end_time,\n                                        settling_time=absolute_settling_time,\n                                        x_range=x_range,\n                                        plot_suffix=plot_suffix,\n                                        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 69.40068372186586}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t/*\n * This function, D435DepthNoiseModel::ApplyNoise, applies noise to depth data for a specified image width and height.\nIt first checks if the data pointer is null and returns if it is.\nIt calculates a multiplier based on camera parameters and maps the data to an Eigen vector.\nIt then computes the RMS noise and the noise values.\nFor each pixel, it adds noise if the pixel value is in range, otherwise it sets the pixel to a bad point value.\n */\n  if (!data) {\n    return;\n  }\n  Eigen::Map<Eigen::VectorXf> depth(data, width * height);\n  const float multiplier = std::max(1.0f, this->min_depth / this->max_depth);\n  const float noise_multiplier = multiplier * this->noise_multiplier;\n  const float rms_noise = this->rms_noise * noise_multiplier;\n  const float bad_point_value = this->bad_point_value * multiplier;\n  const float noise_range = this->noise_range * noise_multiplier;\n  for (int i = 0; i < depth.size(); i++) {\n    if (InRange(depth[i])) {\n      depth[i] += rms_noise * (noise_range * static_cast<float>(rand()) / RAND_MAX - 0.5f);\n    } else {\n      depth[i] = bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 48.18172682077564}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t//  if (data == nullptr) {\n//    std::cerr << \"DepthNoiseModel::ApplyNoise: data is null.\" << std::endl;\n//    return;\n//  }\n//\n//  const float multiplier = this->depth_noise_multiplier_ * this->depth_noise_stddev_;\n//\n//  Eigen::Map<Eigen::VectorXf> depth_vector(data, width * height);\n//  depth_vector *= multiplier;\n//\n//  const float rms_noise = depth_vector.norm() / depth_vector.size();\n//  const float noise = std::sqrt(rms_noise);\n//\n//  for (uint32_t i = 0; i < width * height; ++i) {\n//    if (InRange(data[i])) {\n//      data[i] += static_cast<float>(this->random_generator_.Gaussian(noise));\n//    } else {\n//      data[i] = this->bad_point_value_;\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// check if the data pointer is null and return if it is\nif (!data) {\n  return;\n}\n// calculate a multiplier based on camera parameters\nfloat multiplier = this->multiplier * this->depth_scale;\n// map the data to an Eigen vector\nEigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n// compute the RMS noise\nfloat rms = this->rms * multiplier;\n// compute the noise values\nfloat noise_min = -rms;\nfloat noise_max = rms;\n// add noise if the pixel value is in range, otherwise set the pixel to a bad point value\ndepth_data.cwiseMax(noise_min).cwiseMin(noise_max).cwiseMax(this->min_depth)\n   .cwiseMin(this->max_depth).array() += this->min_depth;\n}", "CodeBleu_score": 32.72998264576792}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  common::Time now = world_->SimTime();\n#else\n  common::Time now = world_->GetSimTime();\n#endif\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 85.10734690610326}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t", "CodeBleu_score": 8.432682072468962}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t#ifdef VERBOSE\n  gzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n#endif\n  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \\\"/\\\" + waypoint_topic_, ros_now, trajectory_msg);\n}", "CodeBleu_score": 69.94349682458845}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t//  if (kPrintOnUpdates) {\n//    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n//  }\n\n  // Convert the simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities.\n  mav_msgs::Actuators actuators_msg;\n\n  // Iterate through the motor joints.\n  for (int i = 0; i < motor_joint_names_.size(); ++i) {\n    // Get the motor joint.\n    physics::JointPtr motor_joint =\n        world_->GetPhysicsEngine()->GetJoint(motor_joint_names_[i]);\n\n    // Get the rotational velocity of the motor joint.\n    double rotational_velocity = motor_joint->GetVelocity(0);\n\n    // Slow down the rotational velocity by the slowdown factor.\n    double slowed_down_rotational_velocity =\n        rotational_velocity / motor_slowdown_factors_[i];\n\n    // Assign the slowed down rotational velocity to the message.\n    actuators_msg.angular_velocities.push_back(\n        slowed_down_rotational_velocity);\n  }\n\n  // Set the message timestamp.\n  actuators_msg.header.stamp = ros_now;\n\n  // Write the message to a bag file.\n  writeBag(namespace_ + \"/\" + motor_topic_, ros_now, actuators_msg);\n}", "CodeBleu_score": 56.34488444374829}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t//  gzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n\n  // Convert the simulation time to ROS time.\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Create a message for actuator velocities.\n  mav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators());\n\n  // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\n  for (int i = 0; i < motor_joints_.size(); i++) {\n    // Get the motor joint.\n    physics::JointPtr motor_joint = motor_joints_[i];\n\n    // Get the motor joint's rotational velocity.\n    double motor_joint_rotational_velocity = motor_joint->GetVelocity(0);\n\n    // Get the motor joint's rotational velocity at the given simulation time.\n    double motor_joint_rotational_velocity_at_time = motor_joint->GetVelocity(now);\n\n    // Calculate the slowed-down rotational velocity.\n    double slowed_down_rotational_velocity = motor_joint_rotational_velocity_at_time / motor_joint_rotational_velocity;\n\n    // Assign the slowed-down rotational velocity to the message.\n    actuators_msg->angular_velocities[i] = slowed_down_rotational_velocity;\n  }\n\n  // Set the message timestamp.\n  actuators_msg->header.stamp = ros_now;\n\n  // Write the message to a bag file.\n  writeBag(namespace_ + \\\"/\\\" + motor_topic_, ros_now, actuators_msg);\n}", "CodeBleu_score": 49.61693143730662}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tif (kPrintOnUpdates) {\ngzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n}\n\n// Get the joints that represent the motors.\nstd::vector<physics::JointPtr> joints = GetMotorJoints();\n\n// If there are no motor joints, we can't log the motor velocities.\nif (joints.empty()) {\nreturn;\n}\n\n// Create a message for actuator velocities.\nmav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators());\n\n// Set the timestamp of the message.\nactuators_msg->header.stamp = ros::Time(now.sec, now.nsec);\n\n// Iterate through the motor joints.\nfor (std::vector<physics::JointPtr>::iterator it = joints.begin(); it!= joints.end(); ++it) {\n// Get the motor joint.\nphysics::JointPtr joint = *it;\n\n// Get the rotational velocity of the motor joint.\ndouble motor_rot_vel = joint->GetVelocity(0);\n\n// Get the rotational velocity of the motor joint, slowed down by the gear ratio.\ndouble motor_rot_vel_slowed_down = motor_rot_vel / gear_ratios_[joint->GetName()];\n\n// Assign the slowed-down rotational velocity to the message.\nactuators_msg->angular_velocities.push_back(motor_rot_vel_slowed_down);\n}\n\n// Write the message to the bag file.\nwriteBag(namespace_ + \"/\" + motor_topic_, actuators_msg->header.stamp, actuators_msg);\n}", "CodeBleu_score": 49.07818885170072}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (kPrintOnMsgCallback) {\ngzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n}\n\ndelta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\ndelta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\ndelta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\ndelta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\nthrottle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 73.08014927104125}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT_ON_MSG_CALLBACK\n  gzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n#endif\n\n  delta_aileron_left_ = NormalizedInputToAngle(\n      vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->normalized(\n          vehicle_params_.aileron_left.channel));\n  delta_aileron_right_ = NormalizedInputToAngle(\n      vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->normalized(\n          vehicle_params_.aileron_right.channel));\n  delta_elevator_ = NormalizedInputToAngle(\n      vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->normalized(\n          vehicle_params_.elevator.channel));\n  delta_flap_ = NormalizedInputToAngle(\n      vehicle_params_.flap,\n      roll_pitch_yawrate_thrust_msg->normalized(\n          vehicle_params_.flap.channel));\n  delta_rudder_ = NormalizedInputToAngle(\n      vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->normalized(\n          vehicle_params_.rudder.channel));\n\n  throttle_ = roll_pitch_yawrate_thrust_msg->normalized(\n      vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 48.57094304842936}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (kPrintOnMsgCallback) {\n  gzdbg << __FUNCTION__ << \\\"() called.\\\" << std::endl;\n}\n\ndelta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_left.channel));\ndelta_aileron_right_ = NormalizedInputToAngle(vehicle_params_.aileron_right,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.aileron_right.channel));\ndelta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.elevator.channel));\ndelta_flap_ = NormalizedInputToAngle(vehicle_params_.flap,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.flap.channel));\ndelta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n    roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.rudder.channel));\n\nthrottle_ = roll_pitch_yawrate_thrust_msg->normalized(vehicle_params_.throttle_channel);\n}", "CodeBleu_score": 59.13446715363323}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  // Get the current time\n  common::Time current_time = world_->SimTime();\n#else\n  common::Time current_time = world_->GetSimTime();\n#endif\n\n  // Check if the timeout has elapsed\n  if (_timeoutMs > 0 &&\n      (current_time - last_mavlink_message_time_).Double() * 1000 > _timeoutMs) {\n    return;\n  }\n\n  // Create a timeval structure for the poll operation\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Create a set of file descriptors to poll\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(serial_fd_, &fds);\n\n  // Perform the poll operation\n  int poll_result = select(serial_fd_ + 1, &fds, NULL, NULL, &timeout);\n\n  // Check if data is available\n  if (poll_result > 0) {\n    // Receive the data\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    int bytes_received = read(serial_fd_, buffer, MAVLINK_MAX_PACKET_LEN);\n\n    // Parse the data and handle each message\n    for (int i = 0; i < bytes_received; i += MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n      // Parse the message\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status);\n\n      // Handle the message\n      handleMAVLinkMessage(&msg, current_time);\n    }\n  }\n}", "CodeBleu_score": 49.368319750483124}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef _WIN32\n  // Windows does not have poll\n  return;\n#endif\n  // convert timeout to timeval\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // poll for MAVLink messages\n  int num_fds = 1;\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(serial_port_->fd(), &fds);\n\n  int poll_result = select(num_fds, &fds, NULL, NULL, &timeout);\n  if (poll_result == 0) {\n    // timeout\n    return;\n  }\n\n  if (poll_result < 0) {\n    // error\n    return;\n  }\n\n  // read from serial port\n  uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n  int bytes_read = serial_port_->read(buffer, MAVLINK_MAX_PACKET_LEN);\n  if (bytes_read > 0) {\n    // parse MAVLink messages\n    mavlink_message_t message;\n    mavlink_status_t status;\n    for (int i = 0; i < bytes_read; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message, &status)) {\n        // handle MAVLink message\n        handleMAVLinkMessage(&message);\n      }\n    }\n  }\n}", "CodeBleu_score": 51.04120763984218}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  // Get the world update period\n  double world_update_period = world_->Physics()->GetMaxStepSize();\n#else\n  // Get the world update period\n  double world_update_period = world_->GetPhysicsEngine()->GetMaxStepSize();\n#endif\n\n  // If the world update period is less than the specified timeout, use the world update period\n  if (_dt > world_update_period) {\n    _dt = world_update_period;\n  }\n\n  // Convert the timeout to a timeval structure\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for MAVLink messages\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(mavlink_fd_, &read_fds);\n\n  int result = select(mavlink_fd_ + 1, &read_fds, NULL, NULL, &timeout);\n\n  // If data is available, receive the data and parse MAVLink messages\n  if (result > 0) {\n    uint8_t buffer[2048];\n    int bytes_read = read(mavlink_fd_, buffer, sizeof(buffer));\n    if (bytes_read > 0) {\n      for (int i = 0; i < bytes_read; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &mavlink_message_,\n                               &mavlink_status_)) {\n          // Handle the received MAVLink message\n          handleReceivedMAVLinkMessage(mavlink_message_);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 51.24697683649525}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tif (serial_dev_.is_open())  {\nserial_dev_.close();\ngzdbg << \\\"Closed serial device \\\" << device_ << \\\"\n\\\";\n}\n}", "CodeBleu_score": 47.481898578527215}, {"code": "void GazeboMavlinkInterface::close() {\n\tif (serial_enabled_) {\nserial_dev_.close();\n}\n}", "CodeBleu_score": 29.326404430108923}, {"code": "void GazeboMavlinkInterface::close() {\n\tif (serial_enabled_) {\nserial_dev_.cancel();\nserial_dev_.close();\n}\n}", "CodeBleu_score": 43.85378884169597}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\n}", "CodeBleu_score": 4.3431191429652}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t", "CodeBleu_score": 2.227760700530013}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\tif (this->loop) {\n// Wrap time within the animation length\nthis->timePos = fmod(_time, this->length);\n} else {\n// Clamp time between 0 and the animation length\nthis->timePos = std::min(std::max(_time, 0.0), this->length);\n}\n}", "CodeBleu_score": 40.91836348707173}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode)\n\n\n", "CodeBleu_score": 76.59070283875347}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode)\n\n\n", "CodeBleu_score": 76.59070283875347}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode)\n\n\n", "CodeBleu_score": 76.59070283875347}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode+' failed!')\n            return False\n", "CodeBleu_score": 67.36991203413868}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n\n    if self.flightModeService(self.flight_mode):\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+self.flight_mode+' failed!')\n        return False\n\n", "CodeBleu_score": 67.99858757708974}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode+\\\" failed!\\\")\n            return False\n\n", "CodeBleu_score": 67.36131336533957}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n\n", "CodeBleu_score": 61.7588804953658}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n", "CodeBleu_score": 59.85032220895111}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(x=msg.linear.x, y=msg.linear.y, z=msg.linear.z, yaw=msg.angular.z)\n\n", "CodeBleu_score": 63.730905377206945}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flight_mode_transition('OFFBOARD')\n    elif (self.flight_mode!= 'HOVER' and self.hover_flag == 1):\n        self.hover_flag = 1\n        self.flight_mode_transition('HOVER')\n\n", "CodeBleu_score": 53.37183997849779}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.set_flight_mode('OFFBOARD')\n    elif self.flight_mode!= 'HOVER' and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.set_flight_mode('HOVER')\n        self.hover_action()\n\n", "CodeBleu_score": 59.33269769377494}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_flight_mode('OFFBOARD')\n    elif (self.flight_mode!= 'HOVER' and self.hover_flag == 1):\n        self.hover_flag = 0\n        self.set_flight_mode('HOVER')\n        self.hover_action()\n\n", "CodeBleu_score": 53.234657917960334}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 53.16045874304341}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 53.16045874304341}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": Hovering\\\")\n\n", "CodeBleu_score": 43.7915553303697}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": Hovering\\\")\n", "CodeBleu_score": 43.7915553303697}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = self.construct_target(vx=0, vy=0, vz=0, yaw_rate=0)\n    print(self.vehicle_type + '_' + self.vehicle_id + \\\": Hovering\\\")\n\n", "CodeBleu_score": 43.7915553303697}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode + \\\" failed!\\\"\n                  + \\\" Current flight mode: \\\" + self.current_flight_mode)\n            return False\n\n    def set_target_position(self, x, y, z, yaw, vel_type='ned', hold_x=False, hold_y=False, hold_z=False, hold_yaw=False):\n        \"\"\"This function, set_target_position, sets the target position of a vehicle.\n        It first checks if the hold flags are set and if so, it updates the\n        hold position and yaw accordingly.\n        It then sets the hold flag to True and calls the construct_target method\n        to construct the target motion.\n        Finally, it sets the coordinate frame to 1 and the motion type to 1\n        and publishes the target motion.\"\"\"\n        if vel_type == 'ned':\n            if hold_x and hold_yaw:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                self.motion_type = 1\n                self.target_motion = self.construct_target(x=x, y=y, z=z, yaw=yaw)\n            elif hold_y and hold_yaw:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                self.motion_type = 1\n                self.target_motion = self.construct_target(x=x, y=y, z=z, yaw=yaw)\n            elif hold_z and hold_yaw:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                self.motion_type = 1\n                self.target_motion = self.construct_target(x=x, y=y, z=z,", "CodeBleu_score": 44.06291720414552}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": switching flight mode to \\\" + self.flight_mode + \\\" failed!\\", "CodeBleu_score": 51.76867913438352}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService(self.flight_mode):\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode + \\\": failed!\\\"\n              + \\\" Current flight mode: \\\" + self.flight_mode)\n            return False\n\n    def construct_target(self, x=0.0, y=0.0, z=0.0, yaw=0.0, yaw_rate=0.0):\n        \"\"\"This function, construct_target, constructs a Target object.\n        It takes in the desired position and yaw as arguments.\n        It returns the constructed target object.\"\"\"\n        target = Target()\n        target.position.x = x\n        target.position.y = y\n        target.position.z = z\n        target.yaw = yaw\n        target.yaw_rate = yaw_rate\n        return target\n\n    def set_target(self, target):\n        \"\"\"This function, set_target, sets the target of a vehicle.\n        It takes in a target object as an argument.\n        It sets the target of the vehicle using targetService.\"\"\"\n        if self.targetService(target):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": set target failed!\\\"\n              + \\\" Current target: \\\" + str(target))\n            return False\n\n    def set_hold(self, vel_type, x=0.0, y=0.0, z=0.0, w=0.0):\n        \"\"\"This function, set_hold, sets the hold of a vehicle.\n        It takes in the desired velocity as arguments.\n        It sets the hold of the vehicle using holdService.\"\"\"\n        if vel_type == 'body':\n            if self.hold_x_flag and self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1", "CodeBleu_score": 48.43965286855777}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n\n\n", "CodeBleu_score": 59.237293478588235}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n\n\n", "CodeBleu_score": 59.237293478588235}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\\\n        self.local_pose = msg\n        self.global_pose[i] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z += self.takeoff_height\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z += self.takeoff_height\n        elif self.gcs_cmd == 'AUTO.LAND':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z += self.takeoff_height\n        elif self.gcs_cmd == 'FORM_0':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z += self.takeoff_height\n        elif self.gcs_cmd == 'FORM_1':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z += self.takeoff_height\n        elif self.gcs_cmd == 'FORM_2':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z += self.takeoff_height\n        else:\n            self.gcs_cmd = self.last_gcs_cmd\n\n", "CodeBleu_score": 18.9759508012758}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\\\n        self.local_pose = msg\n        self.global_pose[i] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.pose.position.z += self.takeoff_height\n        elif self.gcs_cmd == 'HOVER':\n            self.hover_target_pose = msg\n        elif self.gcs_cmd == 'AUTO.LAND':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z = 0.05\n        elif self.gcs_cmd == 'FORM_0':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z = 0.05\n        elif self.gcs_cmd == 'FORM_1':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z = 0.05\n        elif self.gcs_cmd == 'FORM_2':\n            self.hover_target_pose = msg\n            self.hover_target_pose.pose.position.z = 0.05\n        else:\n            self.gcs_cmd = self.last_gcs_cmd\n        self.form_flag = 0\n", "CodeBleu_score": 20.15765108660442}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.seq == i:\\\n        self.local_pose = msg\n        self.global_pose[self.uav_id] = msg\n        if self.gcs_cmd == 'TAKEOFF':\n            self.last_gcs_cmd = 'TAKEOFF'\n            self.takeoff_target_pose = self.construct_target(self.takeoff_target_pose.pose.position.x, self.takeoff_target_pose.pose.position.y, self.takeoff_target_pose.pose.position.z, self.current_heading)\n            self.local_target_pub.publish(self.takeoff_target_pose)\n            if self.takeoff_detection():\n                print(self.namespace, \": Takeoff Success!\")\n            else:\n                print(self.namespace, \": Takeoff Failed!!!\")\n            # self.frameService(1)\n\n        elif self.gcs_cmd == 'FORM_0':\n            self.last_gcs_cmd = 'FORM_0'\n            if self.mavros_state!= 'OFFBOARD':\n                self.flight_mode_set(mode='OFFBOARD')\n\n        elif self.gcs_cmd == 'FORM_1':\n            self.last_gcs_cmd = 'FORM_1'\n            if self.form_flag!= 1:\n                self.read_set_file('FORM_1_id','FORM_1_pos')\n            self.form_flag = 1\n            if self.mavros_state!= 'OFFBOARD':\n                self.flight_mode_set(mode='OFFBOARD')\n            self.formation_control()\n            self.twist_target_pub.publish(self.target_vel)\n\n        elif self.gcs_cmd == 'FORM_2':\n            self.last_gcs_cmd = 'FORM_2'\n            if self.form_flag!= 2:\n                self.read_set_file('FORM_2_id','FORM_2_pos')\n            self.form_flag = 2\n            if self.mavros_state!= 'OFFBOARD':\n                self.flight_mode_set(mode='OFFBOARD')\n            self.formation_control()\n            self.twist_target_pub.publish(self.target_vel)\n\n        elif self.gcs_cmd == 'AUTO.LAND':\n           ", "CodeBleu_score": 18.979182527027717}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.global_pose[self.uav_id].pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 72.40427091732786}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n\n", "CodeBleu_score": 80.06315890994992}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 80.06315890994992}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t    dist_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            dist_matrix[i, j] = numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))\n    dist_matrix = 50 - dist_matrix\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 41.38096246598316}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t    adj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            if i == j:\n                adj_matrix[i][j] = 0\n            else:\n                dist = numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j]))\n                adj_matrix[i][j] = 50 - dist\n                adj_matrix[i][j] = int(adj_matrix[i][j])\n    return adj_matrix\n\n", "CodeBleu_score": 41.293750293123}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t    adj_matrix = numpy.zeros((self.uav_num - 1, self.uav_num - 1))\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            if i!= j:\n                adj_matrix[i, j] = int(50 - numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(change_formation[j])))\n    return adj_matrix\n\n    def find_path(self, adj_matrix, label_left, label_right, match_right, visit_left, visit_right, slack_right, changed_id):\n        \"\"\"This function, find_path, is a recursive function that finds a path between two sets of UAVs.\n        It takes the distance matrix, labels for the left and right sets, the match between the right set and the left set,\n        the visit arrays for the left and right sets, and the slack array for the right set.\n        The function starts by finding an unmatched left node, and if it exists, it finds the right node with the smallest slack value.\n        If the right node is unvisited, it sets the visit arrays and the slack array for the right node and calls the function again.\n        If the right node is visited, the function checks if the slack value is greater than 0.\n        If it is, it sets the match between the left and right nodes and calls the function again.\n        If the slack value is 0, it returns the path to the root node.\n        The function returns the path if it finds a path, and None if it does not find a path.\"\"\"\n        unmatched_left = numpy.where(label_left == 0)[0]\n        if len(unmatched_left) > 0:\n            min_slack = numpy.min(slack_right)\n            min_slack_index = numpy.where(slack_right == min_slack)[0][0]\n            if visit_right[min_slack_index] == 0:\n                visit_right[min_slack_index] = 1\n                slack_right[min_slack_index] = 0\n                path = self.find_path", "CodeBleu_score": 33.644803540289395}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t    if self.visit_left[i]:\n        return False\n    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] == 0:\n            continue\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n        if gap == 0:\n            self.match_right[j] = i\n            self.visit_right[j] = 1\n            return True\n        elif self.slack_right[j] > gap:\n            self.slack_right[j] = gap\n    return False\n\n    def KM(self):\n        \"\"\"This function, KM, is used to find the maximum matching for the bipartite graph.\n        It initializes the left and right sets.\n        It then iterates through the left set and attempts to find a path.\n        If a path is found, it updates the labels and the match.\n        If no path is found, it updates the slack values and continues.\n        The function returns the list of changed UAVs.\"\"\"\n        for i in range(self.uav_num - 1):\n            self.label_left[i] = 0\n            self.label_right[i] = 0\n            self.slack_right[i] = 100\n        while True:\n            for i in range(self.uav_num - 1):\n                if self.find_path(i):\n                    break\n            if i == self.uav_num - 1:\n                break\n            for j in range(self.uav_num - 1):\n                if self.visit_right[j]:\n                    self.label_right[j] += self.slack_right[j]\n                    self.visit_right[j] = 0\n            for j in range(self.uav_num - 1):\n                if self.visit_left[j]:\n                    self.label_left[j] -= self.slack_", "CodeBleu_score": 37.761178778944696}, {"code": "def find_path(self, i)\n\t    self.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] > 0 and self.visit_right[j] == 0:\n            if self.match_right[j] == -1 or self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j] < self.slack_right[j]:\n                self.slack_right[j] = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n                if self.slack_right[j] == 0:\n                    if self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        return True\n                    else:\n                        self.visit_right[j] = 0\n        elif self.adj_matrix[i][j] > 0 and self.visit_right[j] == 1:\n            continue\n        elif self.adj_matrix[i][j] == 0 and self.visit_right[j] == 0 and self.match_right[j] == -1:\n            self.visit_right[j] = 1\n            if self.find_path(j):\n                self.match_right[j] = i\n                return True\n            else:\n                self.visit_right[j] = 0\n    return False\n", "CodeBleu_score": 40.96082213606374}, {"code": "def find_path(self, i)\n\t    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] == 0:\n            continue\n        if self.visit_right[j] == 1:\n            continue\n        if self.slack_right[j] == 0:\n            self.match_right[j] = i\n            return True\n        if self.label_left[i] - self.label_right[j] < self.slack_right[j]:\n            self.slack_right[j] = self.label_left[i] - self.label_right[j]\n        if self.label_left[i] - self.label_right[j] == self.slack_right[j]:\n            self.visit_right[j] = 1\n    return False\n\n    def KM(self):\n        \"\"\"This function, KM, is the main function of the KM algorithm.\n        It initializes the label for the left set and calls find_path to find an augmenting path.\n        It returns the changed_id array, which is the list of UAVs that have been changed.\"\"\"\n        for i in range(self.uav_num - 1):\n            self.label_left[i] = 0\n        for i in range(self.uav_num - 1):\n            self.visit_left[i] = 0\n            self.visit_right[i] = 0\n            self.slack_right[i] = 100\n            self.match_right[i] = -1\n        while True:\n            for i in range(self.uav_num - 1):\n                if self.visit_left[i] == 0 and self.find_path(i):\n                    self.visit_left[i] = 1\n                    break\n            if self.visit_left.all():\n                break\n        for i in range(self.uav_num - 1):\n            if self.match_right[i]!= -1:\n                self.label_right[i] = self.label_left[self.match_right[i", "CodeBleu_score": 34.25480110743185}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t    self.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    for i in range(self.uav_num - 1):\\\n        for j in range(self.uav_num - 1):\\\n            self.slack_right[j] = 100\n        while True:\\\n            for j in range(self.uav_num - 1):\\\n                self.visit_right[j] = False\n            if self.find_path(i):\\\n                break\n            else:\\\n                min_slack = min(self.slack_right)\\\n                for j in range(self.uav_num - 1):\\\n                    if self.visit_left[j]:\n                        self.label_left[j] -= min_slack\n                    if self.visit_right[j]:\n                        self.label_right[j] += min_slack\n    return self.match_right\n", "CodeBleu_score": 43.67802929578454}, {"code": "def KM(self)\n\t    self.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    for i in range(self.uav_num - 1):\\\n        self.visit_left[i] = False\n        self.visit_right = numpy.array([False] * (self.uav_num - 1))\n        if not self.find_path(i):\\\n            for j in range(self.uav_num - 1):\\\n                if self.visit_right[j]:\\\n                    self.label_right[j] += self.slack_right[j]\\\n                else:\\\n                    self.label_left[i] += self.slack_right[j]\\\n            self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    return self.match_right\n\n", "CodeBleu_score": 44.0019068072996}, {"code": "def KM(self)\n\t    # Initialize slack variables and visit arrays for each UAV.\n\n    self.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n\n    # Iterate over UAVs, initializing slack variables and resetting visit arrays for each UAV.\n\n    for i in range(self.uav_num - 1):\n\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n\n        self.visit_left[i] = False\n\n        self.visit_right = numpy.array([False] * (self.uav_num - 1))\n\n        # If no path is found, adjust the labels based on the minimum slack value.\n\n        if not self.find_path(i):\n\n            min_slack = numpy.min(self.slack_right)\n\n            for j in range(self.uav_num - 1):\n\n                if self.visit_right[j]:\n\n                    self.label_right[j] -= min_slack\n\n                else:\n\n                    self.label_left[i] -= min_slack\n\n    # Return the match results for the right side of the bipartite graph.\n\n    return self.match_right\n\n", "CodeBleu_score": 51.44543970243496}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([15, 100, 100])\n    upper_yellow = np.array([35, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 26.92253711925257}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 27.09532694324272}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}]}
