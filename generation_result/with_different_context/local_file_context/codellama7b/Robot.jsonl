{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t{\n    return response.Get();\n  }\n\n  static bool Get(carla::rpc::Response<void> &) {\n    return true;\n  }\n\n  // ===========================================================================\n  // -- Client::Pimpl ----------------------------------------------------------\n  // ===========================================================================\n\n  class Client::Pimpl {\n  public:\n\n    Pimpl(const std::string &host, uint16_t port, size_t worker_threads)\n      : endpoint(host + \\\":\\\" + std::to_string(port)),\n        rpc_client(host, port),\n        streaming_client(host) {\n      rpc_client.set_timeout(5000u);\n      streaming_client.AsyncRun(\n          worker_threads > 0u ? worker_threads : std::thread::hardware_concurrency());\n    }\n\n    template <typename ... Args>\n    auto RawCall(const std::string &function, Args && ... args) {\n      try {\n        return rpc_client.call(function, std::forward<Args>(args) ...);\n      } catch (const ::rpc::timeout &) {\n        throw_exception(TimeoutException(endpoint, GetTimeout()));\n      }\n    }\n\n    template <typename T, typename ... Args>\n    auto CallAndWait(const std::string &function, Args && ... args) {\n      auto object = RawCall(function, std::forward<Args>(args) ...);\n      using R = typename carla::rpc::Response<T>;\n      auto response = object.template as<R>();\n      if (response.HasError()) {\n        throw_exception(std::runtime_error(response.GetError().What()));\n      }\n      return Get(response);\n    }\n\n    template <typename ... Args>\n    void AsyncCall(const std::string &function, Args && ... args) {\n      // Discard returned future.\n      rpc_client.async_call(function, std::forward<Args>(args) ...);\n    }\n\n    time_duration GetTimeout() const {\n      auto timeout = rpc_client.get_timeout();\n      DEBUG_ASSERT(timeout.has_value());\n      return time_duration::milliseconds(static_cast<size_t>(*timeout));\n    }\n\n    const std::string endpoint;\n\n    rpc::Client rpc_client;\n\n    streaming::Client streaming_client;\n  };\n\n  // ===========================================================================\n  // -- Client -----------------------------------------------------------------\n  // ===========================================================================\n\n  Client::Client(\n      const std::string &host,\n      const uint16_t port,\n      const size_t worker_threads)\n    : _pimpl(std::make_unique<Pimpl>(host, port, worker_threads)) {}\n\n  bool Client::IsTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<bool>(\\\"is_traffic_manager_running\\\", port);\n  }\n\n  std::pair<std::string, uint16_t> Client::GetTrafficManagerRunning(uint16_t port) const {\n    return _pimpl->CallAndWait<std::pair<std::string, uint16_t>>(\\\"get_traffic_manager_running\\\", port);\n  };\n\n  bool Client::AddTrafficManagerRunning(std::pair<std::string, uint16_t> trafficManagerInfo) const {\n    return _pimpl->CallAndWait<bool>(\\\"add_traffic_manager_running\\\", trafficManagerInfo);\n  };\n\n  void Client::DestroyTrafficManager(uint16_t port) const {\n    _pimpl->AsyncCall(\\\"destroy_traffic_manager\\\", port);\n  }\n\n  Client::~Client() = default;\n\n  void Client::SetTimeout(time_duration timeout) {\n    _pimpl->rpc_client.set_timeout(static_cast<int64_t>(timeout.milliseconds()));\n  }\n\n  time_duration Client::GetTimeout() const {\n    return _pimpl->GetTimeout();\n  }\n\n  const std::string Client::GetEndpoint() const {\n    return _pimpl->endpoint;\n  }\n\n  std::string Client::GetClientVersion() {\n    return ::carla::version();\n  }\n\n  std::string Client::GetServerVersion() {\n    return _pimpl->CallAndWait<std::string>(\\\"version\\\");\n  }\n\n  void Client::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layer) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_new_episode\\\", std::move(map_name), reset_settings, map_layer);\n  }\n\n  void Client::LoadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"load_map_layer\\\", map_layer);\n  }\n\n  void Client::UnloadLevelLayer(rpc::MapLayer map_layer) const {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"unload_map_layer\\\", map_layer);\n  }\n\n  void Client::CopyOpenDriveToServer(std::string opendrive, const rpc::OpendriveGenerationParameters & params) {\n    // Await response, we need to be sure in this one.\n    _pimpl->CallAndWait<void>(\\\"copy_opendrive_to_file\\\", std::move(opendrive), params);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  void Client::ApplyColorTextureToObjects(\n      const std::vector<std::string> &objects_name,\n      const rpc::MaterialParameter& parameter,\n      const rpc::TextureFloatColor& Texture) {\n    _pimpl->CallAndWait<void>(\\\"apply_float_color_texture_to_objects\\\", objects_name, parameter, Texture);\n  }\n\n  std::vector<std::string> Client::GetNamesOfAllObjects() const {\n    return _pimpl->CallAndWait<std::vector<std::string>>(\\\"get_names_of_all_objects\\\");\n  }\n\n  rpc::EpisodeInfo Client::GetEpisodeInfo() {\n    return _pimpl->CallAndWait<rpc::EpisodeInfo>(\\\"get_episode_info\\\");\n  }\n\n  rpc::MapInfo Client::GetMapInfo() {\n    return _pimpl->CallAndWait<rpc::MapInfo>(\\\"get_map_info\\\");\n  }\n\n  std::string Client::GetMapData() const{\n    return _pimpl->CallAndWait<std::string>(\\\"get_map_data\\\");\n  }\n\n  std::vector<uint8_t> Client::GetNavigationMesh() const {\n    return _pimpl->CallAndWait<std::vector<uint8_t>>(\\\"get_navigation_mesh\\\");\n  }\n\n  bool Client::SetFilesBaseFolder(const std::string &path) {\n    return FileTransfer::SetFilesBaseFolder(path);\n  }\n\n\n\n", "CodeBleu_score": 37.97542286697422}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tEpisodeInfo>(\\\"get_episode_info\\\");\n  }", "CodeBleu_score": 8.495909849609031}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\tBonesTransform(rpc::ActorId walker) {\n    auto res = _pimpl->CallAndWait<rpc::WalkerBoneControlOut>(\\\"get_bones_transform\\\", walker);\n    return res;\n  }\n\n  void Client::SetBonesTransform(rpc::ActorId walker, const rpc::WalkerBoneControlIn &bones) {\n    _pimpl->AsyncCall(\\\"set_bones_transform\\\", walker, bones);\n  }\n\n  void Client::BlendPose(rpc::ActorId walker, float blend) {\n    _pimpl->AsyncCall(\\\"blend_pose\\\", walker, blend);\n  }\n\n  void Client::GetPoseFromAnimation(rpc::ActorId walker) {\n    _pimpl->AsyncCall(\\\"get_pose_from_animation\\\", walker);\n  }\n\n  void Client::SetTrafficLightState(\n      rpc::ActorId traffic_light,\n      const rpc::TrafficLightState traffic_light_state) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_state\\\", traffic_light, traffic_light_state);\n  }\n\n  void Client::SetTrafficLightGreenTime(rpc::ActorId traffic_light, float green_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_green_time\\\", traffic_light, green_time);\n  }\n\n  void Client::SetTrafficLightYellowTime(rpc::ActorId traffic_light, float yellow_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_yellow_time\\\", traffic_light, yellow_time);\n  }\n\n  void Client::SetTrafficLightRedTime(rpc::ActorId traffic_light, float red_time) {\n    _pimpl->AsyncCall(\\\"set_traffic_light_red_time\\\", traffic_light, red_time);\n  }\n\n  void Client::FreezeTrafficLight(rpc::ActorId traffic_light, bool freeze) {\n    _pimpl->AsyncCall(\\\"freeze_traffic_light\\\", traffic_light, freeze);\n  }\n\n  void Client::ResetTrafficLightGroup(rpc::ActorId traffic_light) {\n    _pimpl->AsyncCall(\\\"reset_traffic_light_group\\\", traffic_light);\n  }\n\n  void Client::ResetAllTrafficLights() {\n    _pimpl->CallAndWait<void>(\\\"reset_all_traffic_lights\\\");\n  }\n\n  void Client::FreezeAllTrafficLights(bool frozen) {\n    _pimpl->AsyncCall(\\\"freeze_all_traffic_lights\\\", frozen);\n  }\n\n  std::vector<geom::BoundingBox> Client::GetLightBoxes(rpc::ActorId traffic_light) const {\n    using return_t = std::vector<geom::BoundingBox>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_light_boxes\\\", traffic_light);\n  }\n\n  rpc::VehicleLightStateList Client::GetVehiclesLightStates() {\n    return _pimpl->CallAndWait<std::vector<std::pair<carla::ActorId, uint32_t>>>(\\\"get_vehicle_light_states\\\");\n  }\n\n  std::vector<ActorId> Client::GetGroupTrafficLights(rpc::ActorId traffic_light) {\n    using return_t = std::vector<ActorId>;\n    return _pimpl->CallAndWait<return_t>(\\\"get_group_traffic_lights\\\", traffic_light);\n  }\n\n  std::string Client::StartRecorder(std::string name, bool additional_data) {\n    return _pimpl->CallAndWait<std::string>(\\\"start_recorder\\\", name, additional_data);\n  }\n\n  void Client::StopRecorder() {\n    return _pimpl->AsyncCall(\\\"stop_recorder\\\");\n  }\n\n  std::string Client::ShowRecorderFileInfo(std::string name, bool show_all) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_file_info\\\", name, show_all);\n  }\n\n  std::string Client::ShowRecorderCollisions(std::string name, char type1, char type2) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_collisions\\\", name, type1, type2);\n  }\n\n  std::string Client::ShowRecorderActorsBlocked(std::string name, double min_time, double min_distance) {\n    return _pimpl->CallAndWait<std::string>(\\\"show_recorder_actors_blocked\\\", name, min_time, min_distance);\n  }\n\n  std::string Client::ReplayFile(std::string name, double start, double duration,\n      uint32_t follow_id, bool replay_sensors) {\n    return _pimpl->CallAndWait<std::string>(\\\"replay_file\\\", name, start, duration,\n        follow_id, replay_sensors);\n  }\n\n  void Client::StopReplayer(bool keep_actors) {\n    _pimpl->AsyncCall(\\\"stop_replayer\\\", keep_actors);\n  }\n\n  void Client::SetReplayerTimeFactor(double time_factor) {\n    _pimpl->AsyncCall(\\\"set_replayer_time_factor\\\", time_factor);\n  }\n\n  void Client::SetReplayerIgnoreHero(bool ignore_hero) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_hero\\\", ignore_hero);\n  }\n\n  void Client::SetReplayerIgnoreSpectator(bool ignore_spectator) {\n    _pimpl->AsyncCall(\\\"set_replayer_ignore_spectator\\\", ignore_spectator);\n  }\n\n  void Client::SubscribeToStream(\n      const streaming::Token &token,\n      std::function<void(Buffer)> callback) {\n    carla::streaming::detail::token_type thisToken(token);\n    streaming::Token receivedToken = _pimpl->CallAndWait<streaming::Token>(\\\"get_sensor_token\\\", thisToken.get_stream_id());\n    _pimpl->streaming_client.Subscribe(receivedToken, std::move(callback));\n  }\n\n  void Client::UnSubscribeFromStream(const streaming::Token &token) {\n    _pimpl->streaming_client.UnSubscribe(token);\n  }\n\n  void Client::EnableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"enable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::DisableForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    _pimpl->AsyncCall(\\\"disable_sensor_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  bool Client::IsEnabledForROS(const streaming::Token &token) {\n    carla::streaming::detail::token_type thisToken(token);\n    return _pimpl->CallAndWait<bool>(\\\"is_sensor_enabled_for_ros\\\", thisToken.get_stream_id());\n  }\n\n  void Client::Send(rpc::ActorId ActorId, std::string message) {\n    _pimpl->AsyncCall(\\\"send\\\", ActorId, message);\n  }\n\n\n\n", "CodeBleu_score": 36.767306116069534}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation;\n  do {\n    navigation = _walker_navigation.lock();\n    if (!navigation) {\n      navigation = std::make_shared<WalkerNavigation>(_client, _state);\n      _walker_navigation = navigation;\n    }\n  } while (!_walker_navigation.compare_exchange_weak(navigation, navigation));\n  return navigation;\n}", "CodeBleu_score": 50.681765886512295}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = GetWalkerNavigation();\n  if (!navigation) {\n    navigation = std::make_shared<WalkerNavigation>(_client, _token);\n    auto navigation_ptr = navigation.get();\n    if (!_walker_navigation.compare_exchange(navigation_ptr, navigation)) {\n      navigation = _walker_navigation.load();\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 53.79030056522568}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation;\n  do {\n    navigation = _walker_navigation.load();\n    if (navigation == nullptr) {\n      navigation = std::make_shared<WalkerNavigation>(_client, _state);\n      if (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n        continue;\n      }\n    }\n  } while (navigation == nullptr);\n  return navigation;\n}", "CodeBleu_score": 55.53738059194638}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono_literals;\n\n    const auto start_time = std::chrono::system_clock::now();\n    while (episode.GetFrameNumber() < frame) {\n      std::this_thread::sleep_for(1ms);\n      if (std::chrono::system_clock::now() - start_time > timeout) {\n        return false;\n      }\n    }\n    episode.Tick();\n    return true;\n  }", "CodeBleu_score": 39.53320636373685}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start = system_clock::now();\n  while (episode.GetFrameNumber() < frame) {\n    if (duration_cast<milliseconds>(system_clock::now() - start) > timeout) {\n      return false;\n    }\n    episode.idle();\n  }\n  episode.GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 32.762482707853756}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tconst auto start = Clock::now();\n  while (true) {\n    if (episode.GetFrameNumber() >= frame) {\n      return true;\n    }\n    if (Clock::now() - start > timeout) {\n      return false;\n    }\n    episode.GetWorld().GetActorManager().Tick();\n    episode.GetWorld().GetSensorManager().Tick(frame);\n    episode.GetWorld().GetTrafficManager().Tick();\n    episode.GetWorld().GetDebugHelper().Tick();\n    episode.GetWorld().GetEpisodeSettings().Tick(frame);\n    episode.GetWorld().GetActorPool().Tick(frame);\n    episode.GetWorld().GetActorBlueprintLibrary().Tick(frame);\n    episode.GetWorld().GetActorFactory().Tick(frame);\n    episode.GetWorld().GetWalkerNavigation().Tick(frame);\n    episode.GetWorld().GetWalkerAIController().Tick(frame);\n    episode.GetWorld().GetSensorLibrary().Tick(frame);\n    episode.GetWorld().GetSensorDeserializer().Tick(frame);\n    episode.GetWorld().GetFileTransfer().Tick(frame);\n    episode.GetWorld().GetBlueprintLibrary().Tick(frame);\n    episode.GetWorld().GetTrafficManager().Tick(frame);\n    episode.GetWorld().GetActorLibrary().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().Tick(frame);\n    episode.GetWorld().GetActorSnapshotter().", "CodeBleu_score": 28.978932337198227}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\treturn LoadEpisode(map_name, reset_settings, map_layers, 10u);\n}", "CodeBleu_score": 11.962166324245395}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tauto episode = _client.Call<rpc::LoadEpisode>(map_name, reset_settings, map_layers);\n  ValidateVersions(*this);\n  return EpisodeProxy(episode, _client);\n}", "CodeBleu_score": 18.520564280581283}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// -- Create a new episode -----------------------------------------------------\n  //\n  // We need to create a new episode before we can connect to it.\n  auto episode = EpisodeProxy{_client.MakeEpisode(map_name, reset_settings, map_layers)};\n  //\n  // -- Validate versions ---------------------------------------------------------\n  //\n  // We need to validate the versions of the client and the simulator.\n  ValidateVersions(*this);\n  //\n  // -- Connect to the new episode ------------------------------------------------\n  //\n  // We need to connect to the new episode before we can start sending commands to it.\n  //\n  // We need to check if the episode ID has changed.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to check if the episode is still loading.\n  //\n  // We need to", "CodeBleu_score": 13.488214740645551}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tto current episode ----------------------------------------------\n  // ===========================================================================\n\n  void Simulator::GetReadyCurrentEpisode() {\n    if (_episode == nullptr) {\n      ValidateVersions(_client);\n      _episode = std::make_shared<Episode>(_client, std::weak_ptr<Simulator>(shared_from_this()));\n      _episode->Listen();\n      if (!GetEpisodeSettings().synchronous_mode) {\n        WaitForTick(_client.GetTimeout());\n      }\n      _light_manager->SetEpisode(WeakEpisodeProxy{shared_from_this()});\n    }\n  }", "CodeBleu_score": 38.97451016148338}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tfalse) _client.GetRequiredFiles();\n      _open_drive_file = _client.GetMapData();\n      _cached_map = MakeShared<Map>(map_info, _open_drive_file);\n    }", "CodeBleu_score": 15.191378428721519}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t(time_duration timeout) {\n    DEBUG_ASSERT(_episode != nullptr);\n\n    // tick pedestrian navigation\n    NavigationTick();\n\n    // send tick command\n    const auto frame = _client.SendTickCue();\n\n    // waits until new episode is received\n    bool result = SynchronizeFrame(frame, *_episode, timeout);\n    if (!result) {\n      throw_exception(TimeoutException(_client.GetEndpoint(), timeout));\n    }\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- Access to global objects in the episode --------------------------------\n  // ===========================================================================\n\n  SharedPtr<BlueprintLibrary> Simulator::GetBlueprintLibrary() {\n    auto defs = _client.GetActorDefinitions();\n    return MakeShared<BlueprintLibrary>(std::move(defs));\n  }\n\n  rpc::VehicleLightStateList Simulator::GetVehiclesLightStates() {\n    return _client.GetVehiclesLightStates();\n  }\n\n  SharedPtr<Actor> Simulator::GetSpectator() {\n    return MakeActor(_client.GetSpectator());\n  }\n\n  uint64_t Simulator::SetEpisodeSettings(const rpc::EpisodeSettings &settings) {\n    if (settings.synchronous_mode && !settings.fixed_delta_seconds) {\n      log_warning(\n          \\\"synchronous mode enabled with variable delta seconds. It is highly \\\"\n          \\\"recommended to set 'fixed_delta_seconds' when running on synchronous mode.\\\");\n    }\n    else if (settings.synchronous_mode && settings.substepping) {\n      if(settings.max_substeps < 1 || settings.max_substeps > 16) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the number of substeps is not valid. \\\"\n            \\\"Please be aware that this value needs to be in the range [1-16].\\\");\n      }\n      double n_substeps = settings.fixed_delta_seconds.get() / settings.max_substep_delta_time;\n\n      if (n_substeps > static_cast<double>(settings.max_substeps)) {\n        log_warning(\n            \\\"synchronous mode and substepping are enabled but the values for the simulation are not valid. \\\"\n            \\\"The values should fulfil fixed_delta_seconds <= max_substep_delta_time * max_substeps. \\\"\n            \\\"Be very careful about that, the time deltas are not guaranteed.\\\");\n      }\n    }\n    const auto frame = _client.SetEpisodeSettings(settings);\n\n    using namespace std::literals::chrono_literals;\n    SynchronizeFrame(frame, *_episode, 1s);\n\n    return frame;\n  }\n\n  // ===========================================================================\n  // -- AI ---------------------------------------------------------------------\n  // ===========================================================================\n\n  std::shared_ptr<WalkerNavigation> Simulator::GetNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav;\n  }\n\n  // tick pedestrian navigation\n  void Simulator::NavigationTick() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->Tick(_episode);\n  }\n\n  void Simulator::RegisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->RegisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  void Simulator::UnregisterAIController(const WalkerAIController &controller) {\n    auto walker = controller.GetParent();\n    if (walker == nullptr) {\n      throw_exception(std::runtime_error(controller.GetDisplayId() + \\\": not attached to walker\\\"));\n      return;\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->UnregisterWalker(walker->GetId(), controller.GetId());\n  }\n\n  boost::optional<geom::Location> Simulator::GetRandomLocationFromNavigation() {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    return nav->GetRandomLocation();\n  }\n\n  void Simulator::SetPedestriansCrossFactor(float percentage) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansCrossFactor(percentage);\n  }\n\n  void Simulator::SetPedestriansSeed(unsigned int seed) {\n    DEBUG_ASSERT(_episode != nullptr);\n    auto nav = _episode->CreateNavigationIfMissing();\n    nav->SetPedestriansSeed(seed);\n  }\n\n  // ===========================================================================\n  // -- General operations with actors -----------------------------------------\n  // ===========================================================================\n\n    SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n    rpc::Actor actor;\n    if (parent != nullptr) {\n      actor = _client.SpawnActorWithParent(\n          blueprint.MakeActorDescription(),\n          transform,\n          parent->GetId(),\n          attachment_type,\n          socket_name);\n    } else {\n      actor = _client.SpawnActor(\n          blueprint.MakeActorDescription(),\n          transform);\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    _episode->RegisterActor(actor);\n    const auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\n    auto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\n    log_debug(\n        result->GetDisplayId(),\n        \\\"created\\\",\n        gca == GarbageCollectionPolicy::Enabled ? \\\"with\\\" : \\\"without\\\",\n        \\\"garbage collection\\\");\n    return result;\n  }\n\n  bool Simulator::DestroyActor(Actor &actor) {\n    bool success = true;\n    success = _client.DestroyActor(actor.GetId());\n    if (success) {\n      // Remove it's persistent state so it cannot access the client anymore.\n      actor.GetEpisode().Clear();\n      log_debug(actor.GetDisplayId(), \\\"destroyed.\\\");\n    } else {\n      log_debug(\\\"failed to destroy\\\", actor.GetDisplayId());\n    }\n    return success;\n  }\n\n  // ===========================================================================\n  // -- Operations with sensors ------------------------------------------------\n  // ===========================================================================\n\n\n\n", "CodeBleu_score": 41.20398897441957}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// Load current walkers.\n  _nav.Update(_simulator.lock()->GetEpisodeState());\n  if (_nav.GetWalkers().empty()) {\n    return;\n  }\n\n  // Remove dead walkers.\n  auto walkers = _nav.GetWalkers();\n  for (auto &walker : walkers) {\n    if (walker.second.Dead) {\n      _nav.RemoveWalker(walker.first);\n      _simulator.lock()->DestroyActor(walker.second.Controller);\n    }\n  }\n\n  // Update crowd.\n  _nav.UpdateCrowd();\n\n  // Update walkers.\n  auto walker_list = episode->GetWalkerList();\n  for (auto &walker : walkers) {\n    auto it = walker_list.find(walker.first);\n    if (it != walker_list.end()) {\n      auto &walker_data = it->second;\n      auto &walker_state = walker.second;\n\n      // Update transform and speed.\n      walker_state.Transform = walker_data.GetTransform();\n      walker_state.Speed = walker_data.GetSpeed();\n\n      // Apply transform and speed to walker.\n      walker_state.Controller->ApplyControl(walker_state.Transform, walker_state.Speed);\n    }\n  }\n\n  // Check if any walker has been killed.\n  for (auto &walker : walkers) {\n    auto &walker_state = walker.second;\n    if (walker_state.Dead) {\n      _nav.RemoveWalker(walker.first);\n      _simulator.lock()->DestroyActor(walker_state.Controller);\n    }\n  }\n}", "CodeBleu_score": 45.438917582869934}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tif (!_walkers.empty()) {\n    // Load walkers.\n    episode->Lock();\n    std::vector<Walker> walkers = episode->GetWalkers();\n    episode->Unlock();\n\n    if (walkers.empty()) {\n      return;\n    }\n\n    // Check for walkers that have been removed.\n    for (auto it = _walkers.begin(); it != _walkers.end();) {\n      if (std::find_if(walkers.begin(), walkers.end(), [&](auto &walker) {\n        return walker.id == it->first;\n      }) == walkers.end()) {\n        _nav.RemoveWalker(it->second.actor_id);\n        it = _walkers.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    // Update the crowd.\n    for (auto &walker : walkers) {\n      auto it = _walkers.find(walker.id);\n      if (it == _walkers.end()) {\n        _nav.AddWalker(walker.actor_id, walker.transform);\n        _walkers[walker.id] = {walker.id, walker.actor_id, walker.transform, walker.speed};\n      } else {\n        _nav.UpdateWalker(walker.actor_id, walker.transform);\n        it->second.transform = walker.transform;\n        it->second.speed = walker.speed;\n      }\n    }\n\n    // Send the batched commands.\n    auto commands = _nav.GetCommands();\n    episode->Lock();\n    episode->ApplyBatch(commands);\n    episode->Unlock();\n\n    // Check for walkers that have been killed.\n    for (auto it = _walkers.begin(); it != _walkers.end();) {\n      auto walker = episode->GetWalker(it->second.actor_id);\n      if (walker && walker->GetHealth() <= 0) {\n        _nav.RemoveWalker(it->second.actor_id);\n        it = _", "CodeBleu_score": 39.30749578631865}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// Load the current walkers.\n  if (episode->GetWalkerCount() == 0) {\n    return;\n  }\n  // Retrieve the current state of the episode.\n  auto state = episode->GetState();\n  // Remove any walkers that no longer exist.\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    if (state.GetActor(it->first) == nullptr) {\n      _nav.RemoveWalker(it->second);\n      it = _walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  // Update the vehicles in the crowd and the crowd itself in the navigation module.\n  _nav.Update(_simulator.lock()->GetElapsedTime());\n  // Get the transforms and speeds of the walkers.\n  std::vector<rpc::Transform> transforms;\n  std::vector<float> speeds;\n  for (const auto &walker : _walkers) {\n    auto walker_state = state.GetActor(walker.first);\n    if (walker_state == nullptr) {\n      continue;\n    }\n    transforms.emplace_back(walker_state->GetTransform());\n    speeds.emplace_back(walker_state->GetSpeed());\n  }\n  // Apply these states in a batch to the simulator.\n  std::vector<rpc::Command> commands;\n  commands.reserve(transforms.size());\n  for (size_t i = 0; i < transforms.size(); ++i) {\n    commands.emplace_back(\n        rpc::Command::ApplyWalkerTransform(transforms[i], speeds[i]));\n  }\n  episode->ApplyCommands(commands);\n  // Check if any walker has been killed, handling their removal from the crowd\n  // and destroying their controller if they are dead.\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    auto walker_state = state.GetActor(it->first);\n    if (walker_", "CodeBleu_score": 48.12175103866967}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description(_uid, _id);\n  description.reserve(_attributes.size());\n  for (auto &item : _attributes) {\n    description.emplace_back(item.second);\n  }\n  return description;\n}", "CodeBleu_score": 49.7463330187294}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.id = _id;\n  description.uid = _uid;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.MakeAttribute());\n  }\n  return description;\n}", "CodeBleu_score": 71.46448645685119}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.emplace_back(attribute.second.Get());\n  }\n  return description;\n}", "CodeBleu_score": 80.59056792512665}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.MatchAttribute(name, value)) {\n        result.emplace(pair);\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 32.69952273688036}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.MatchAttribute(name, value)) {\n        result.emplace(pair);\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 32.69952273688036}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tmap_type result;\n    for (auto &pair : _blueprints) {\n      if (pair.second.MatchAttribute(name, value)) {\n        result.emplace(pair);\n      }\n    }\n    return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n  }", "CodeBleu_score": 32.69952273688036}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Check if the file exists or not\n  struct stat buffer;\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  if (stat(fullpath.c_str(), &buffer) == 0) {\n    // File exists, overwrite it\n    std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n      file.write(reinterpret_cast<const char*>(content.data()), content.size());\n      file.close();\n      return true;\n    }\n  } else {\n    // File does not exist, create it\n    std::ofstream file(fullpath, std::ios::binary | std::ios::out);\n    if (file.is_open()) {\n      file.write(reinterpret_cast<const char*>(content.data()), content.size());\n      file.close();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 48.32466614426458}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Construct the full file path\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  // Validate the file path\n  if (path.empty() || fullpath.empty()) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::binary | std::ios::trunc);\n\n  // If the file is successfully opened, write the content and close the file\n  if (file.is_open()) {\n    file.write((const char*)content.data(), content.size());\n    file.close();\n    return true;\n  }\n\n  // If the file cannot be opened, return false\n  return false;\n}", "CodeBleu_score": 58.66601014065935}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t// Check if the file exists or not\n  struct stat buffer;\n  std::string fullpath = _filesBaseFolder;\n  fullpath += \"/\";\n  fullpath += ::carla::version();\n  fullpath += \"/\";\n  fullpath += path;\n\n  if (stat(fullpath.c_str(), &buffer) == 0) {\n    // File exists, delete it\n    remove(fullpath.c_str());\n  }\n\n  // Check that the path ends in a slash, add it otherwise\n  if (path[path.size() - 1] != '/' && path[path.size() - 1] != '\\\\') {\n    fullpath += \"/\";\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(fullpath, std::ios::out | std::ios::binary);\n\n  // Write the content\n  if (file.is_open()) {\n    file.write((char*)content.data(), content.size());\n    file.close();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 50.61498575731365}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tauto result = std::make_shared<Bounds>();\n    result->frame = frame;\n    result->corners[0u] = Rotate(transform.rotation.yaw, _parent_bounding_box.location) + transform.location;\n    result->corners[1u] = Rotate(transform.rotation.yaw, _parent_bounding_box.location + _parent_bounding_box.extent) + transform.location;\n    result->corners[2u] = Rotate(transform.rotation.yaw, _parent_bounding_box.location + geom::Vector3D(_parent_bounding_box.extent.x, 0.0f, 0.0f)) + transform.location;\n    result->corners[3u] = Rotate(transform.rotation.yaw, _parent_bounding_box.location + _parent_bounding_box.extent) + transform.location;\n    return result;\n  }", "CodeBleu_score": 41.77538780953586}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = transform.location + _parent_bounding_box.location;\n    const auto rotation = transform.rotation;\n    const auto yaw = rotation.yaw * geom::Math::Pi<float>() / 180.0f;\n    const auto c = std::cos(yaw);\n    const auto s = std::sin(yaw);\n    return std::make_shared<Bounds>(\n        Bounds{\n            frame,\n            std::array<geom::Location, 4u>{\n                Rotate(yaw, _parent_bounding_box.extent.x * c + _parent_bounding_box.extent.y * s + location),\n                Rotate(yaw, _parent_bounding_box.extent.x * c - _parent_bounding_box.extent.y * s + location),\n                Rotate(yaw, -_parent_bounding_box.extent.x * c - _parent_bounding_box.extent.y * s + location),\n                Rotate(yaw, -_parent_bounding_box.extent.x * c + _parent_bounding_box.extent.y * s + location)}});\n  }", "CodeBleu_score": 54.20592895579791}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tauto location = transform.location + _parent_bounding_box.location;\n    auto corners = std::array<geom::Location, 4u>{\n      Rotate(transform.rotation.yaw, _parent_bounding_box.extent.x),\n      Rotate(transform.rotation.yaw, -_parent_bounding_box.extent.x),\n      Rotate(transform.rotation.yaw, -_parent_bounding_box.extent.y),\n      Rotate(transform.rotation.yaw, _parent_bounding_box.extent.y)};\n    return std::make_shared<Bounds>(Bounds{\n      frame,\n      std::move(corners)});\n  }", "CodeBleu_score": 45.71759024933924}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tn      auto it_light = _lights.find(lights_state.first);\n      result.push_back(it_light->second);\n    }", "CodeBleu_score": 8.337152287528179}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::vector<Color>& colors) {\n  size_t lights_to_update = (lights.size() < colors.size()) ? lights.size() : colors.size();\n  for(size_t i = 0; i < lights_to_update; i++) {\n    SetColor(lights[i]._id, colors[i]);\n  }\n}\n", "CodeBleu_score": 17.45531418065077}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling sensor Send() \", GetDisplayId());\n  if (GetDisplayId() == \"sensor.other.v2x_custom\") {\n    log_warning(\"attempting to send message to sensor that is not a v2x sensor: \", GetDisplayId());\n    return;\n  }\n  GetEpisode().Lock()->SendSensorData(*this, message);\n}", "CodeBleu_score": 67.94654104253878}, {"code": "void ServerSideSensor::Send(std::string message){\n\tlog_debug(\"calling ServerSideSensor::Send()\");\n  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"attempting to send message to sensor that is not a v2x_custom sensor: \", GetId());\n    return;\n  }\n  GetEpisode().Lock()->SendV2XCustomMessage(GetContext(), message);\n}", "CodeBleu_score": 60.49200872354218}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (GetId() != \"sensor.other.v2x_custom\") {\n    log_debug(\"Sensor\", GetId(), \"is not a custom sensor, not sending message\");\n    return;\n  }\n  log_debug(\"Sending message to sensor\", GetId());\n  GetEpisode().Lock()->SendCustomMessage(GetId(), message);\n}", "CodeBleu_score": 56.34939370219328}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t// Check if the vehicle is already registered with the traffic manager\n  if (enabled) {\n    // Check if the vehicle is already registered with the traffic manager\n    if (!_is_registered) {\n      // Register the vehicle with the traffic manager\n      _traffic_manager_port = tm_port;\n      _traffic_manager_ptr = std::make_shared<TM>(_traffic_manager_port);\n      _traffic_manager_ptr->RegisterVehicle(*this);\n      _is_registered = true;\n    }\n  } else {\n    // Unregister the vehicle from the traffic manager\n    if (_is_registered) {\n      _traffic_manager_ptr->UnregisterVehicle(*this);\n      _is_registered = false;\n    }\n  }\n}", "CodeBleu_score": 37.991819339014654}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    if (tm_port == 0) {\n      _client.SendCommand(*this, commands::EnableAutopilot{});\n    } else {\n      _client.SendCommand(*this, commands::EnableAutopilot{tm_port});\n    }\n  } else {\n    _client.SendCommand(*this, commands::DisableAutopilot{});\n  }\n}", "CodeBleu_score": 41.44491483256336}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    TM::RegisterVehicle(*this, tm_port);\n  } else {\n    TM::UnregisterVehicle(*this);\n  }\n}", "CodeBleu_score": 34.49593761607547}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\tauto walker = boost::static_pointer_cast<Walker>(GetActor());\n  walker->SetSimulatePhysics(false);\n  walker->SetEnableGravity(false);\n  walker->SetAutopilot(true);\n  walker->SetWalkerState(WalkerState::Walking);\n  walker->SetWalkerBrakingDeceleration(0.0f);\n  walker->SetWalkerMaxSpeed(100.0f);\n  walker->SetWalkerMaxAcceleration(100.0f);\n  walker->SetWalkerJumpZ(0.0f);\n  walker->SetWalkerJumpHeight(0.0f);\n  walker->SetWalkerRadius(0.0f);\n  walker->SetWalkerHeight(0.0f);\n  walker->SetWalkerStepOffset(0.0f);\n  walker->SetWalkerSlopeMaxAngle(0.0f);\n  walker->SetWalkerStiffnessZ(0.0f);\n  walker->SetWalkerStiffnessXY(0.0f);\n  walker->SetWalkerStiffnessYaw(0.0f);\n  walker->SetWalkerStiffnessLat(0.0f);\n  walker->SetWalkerStiffnessLong(0.0f);\n  walker->SetWalkerStiffnessVert(0.0f);\n  walker->SetWalkerStiffnessHor(0.0f);\n  walker->SetWalkerStiffnessPitch(0.0f);\n  walker->SetWalkerStiffnessRoll(0.0f);\n  walker->SetWalkerStiffnessPitchLat(0.0f);\n  walker->SetWalkerStiffnessRollLat(0.0f);\n  walker->SetWalkerStiffnessRollVert(0.0f);\n  walker->SetWalkerStiffnessRollHor(0.0f);\n  walker->SetWalk", "CodeBleu_score": 21.095710369296178}, {"code": "void WalkerAIController::Start(){\n\tif (GetEpisode() == nullptr) {\n    throw_exception(std::logic_error(\"this actor is not attached to an episode\"));\n  }\n\n  // Get the walker actor and its current location.\n  auto walker = boost::static_pointer_cast<Walker>(GetActor());\n  auto walker_location = walker->GetTransform().location;\n\n  // Add the walker to the navigation system with its current location.\n  GetEpisode()->GetWalkerNavigation().RegisterWalker(walker, walker_location);\n\n  // Disable the physics simulation and collisions for the walker actor.\n  walker->SetSimulatePhysics(false);\n  walker->SetEnableGravity(false);\n}", "CodeBleu_score": 46.86306965925568}, {"code": "void WalkerAIController::Start(){\n\tauto walker = boost::static_pointer_cast<Walker>(GetActor());\n  if (walker != nullptr) {\n    auto episode = GetEpisode();\n    episode->RegisterActor(walker);\n    episode->GetWalkerNavigation().RegisterWalker(walker);\n    walker->DisableCollisions();\n    walker->DisablePhysicsEngine();\n  }\n}", "CodeBleu_score": 43.90069642828253}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \" for \", walker->GetId());\n      }\n    } else {\n      log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \" (parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 81.44657328162056}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set request to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \"(parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 82.08999417555408}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: Failed to set request to set max speed to \", max_speed);\n      }\n    } else {\n      log_warning(\"NAV: Failed to set request to set max speed to \", max_speed, \"(parent does not exist)\");\n    }\n  }\n}", "CodeBleu_score": 82.08999417555408}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.64635326140892}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.64635326140892}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tauto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}", "CodeBleu_score": 99.64635326140892}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t) const {\n    auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n    std::vector<SharedPtr<Waypoint>> result;\n    result.reserve(waypoints.size());\n    for (auto &waypoint : waypoints) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n    }\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetNextUntilLaneEnd(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> next = GetNext(distance);\n\n    while (next.size() == 1 && next.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(next.front());\n      next = result.back()->GetNext(distance);\n    }\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetNext(remaining_length).front());\n    } else {\n      result.emplace_back(GetNext(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  std::vector<SharedPtr<Waypoint>> Waypoint::GetPreviousUntilLaneStart(double distance) const {\n    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = GetPrevious(distance);\n\n    while (prev.size() == 1 && prev.front()->GetRoadId() == GetRoadId()) {\n      result.emplace_back(prev.front());\n      prev = result.back()->GetPrevious(distance);\n    }\n\n    double current_s = GetDistance();\n    if(result.size()) {\n      current_s = result.back()->GetDistance();\n    }\n\n    double remaining_length;\n    double road_length = _parent->GetMap().GetLane(_waypoint).GetRoad()->GetLength();\n    if(_waypoint.lane_id < 0) {\n      remaining_length = road_length - current_s;\n    } else {\n      remaining_length = current_s;\n    }\n    remaining_length -= std::numeric_limits<double>::epsilon();\n    if(result.size()) {\n      result.emplace_back(result.back()->GetPrevious(remaining_length).front());\n    } else {\n      result.emplace_back(GetPrevious(remaining_length).front());\n    }\n\n    return result;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetRight() const {\n    auto right_lane_waypoint =\n        _parent->GetMap().GetRight(_waypoint);\n    if (right_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*right_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  SharedPtr<Waypoint> Waypoint::GetLeft() const {\n    auto left_lane_waypoint =\n        _parent->GetMap().GetLeft(_waypoint);\n    if (left_lane_waypoint.has_value()) {\n      return SharedPtr<Waypoint>(new Waypoint(_parent, std::move(*left_lane_waypoint)));\n    }\n    return nullptr;\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetRightLaneMarking() const {\n    if (_mark_record.first != nullptr) {\n      return road::element::LaneMarking(*_mark_record.first);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  boost::optional<road::element::LaneMarking> Waypoint::GetLeftLaneMarking() const {\n    if (_mark_record.second != nullptr) {\n      return road::element::LaneMarking(*_mark_record.second);\n    }\n    return boost::optional<road::element::LaneMarking>{};\n  }\n\n  template <typename EnumT>\n  static EnumT operator&(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) &\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  template <typename EnumT>\n  static EnumT operator|(EnumT lhs, EnumT rhs) {\n    return static_cast<EnumT>(\n        static_cast<typename std::underlying_type<EnumT>::type>(lhs) |\n        static_cast<typename std::underlying_type<EnumT>::type>(rhs));\n  }\n\n  road::element::LaneMarking::LaneChange Waypoint::GetLaneChange() const {\n    using lane_change_type = road::element::LaneMarking::LaneChange;\n\n    const auto lane_change_right_info = _mark_record.first;\n    lane_change_type c_right;\n    if (lane_change_right_info != nullptr) {\n      const auto lane_change_right = lane_change_right_info->GetLaneChange();\n      c_right = static_cast<lane_change_type>(lane_change_right);\n    } else {\n      c_right = lane_change_type::Both;\n    }\n\n    const auto lane_change_left_info = _mark_record.second;\n    lane_change_type c_left;\n    if (lane_change_left_info != nullptr) {\n      const auto lane_change_left = lane_change_left_info->GetLaneChange();\n      c_left = static_cast<lane_change_type>(lane_change_left);\n    } else {\n      c_left = lane_change_type::Both;\n    }\n\n    if (_waypoint.lane_id > 0) {\n      // if road goes backward\n      if (c_right == lane_change_type::Right) {\n        c_right = lane_change_type::Left;\n      } else if (c_right == lane_change_type::Left) {\n        c_right = lane_change_type::Right;\n      }\n    }\n\n    if (((_waypoint.lane_id > 0) ? _waypoint.lane_id - 1 : _waypoint.lane_id + 1) > 0) {\n      // if road goes backward\n      if (c_left == lane_change_type::Right) {\n        c_left = lane_change_type::Left;\n      } else if (c_left == lane_change_type::Left) {\n        c_left = lane_change_type::Right;\n      }\n    }\n\n    return (c_right & lane_change_type::Right) | (c_left & lane_change_type::Left);\n  }\n\n\n\n", "CodeBleu_score": 42.693745015385616}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tauto episode = _episode.Lock();\n  if (!episode) {\n    return 0u;\n  }\n\n  // Apply the settings.\n  uint64_t settings_id = episode->ApplySettings(settings, timeout);\n\n  // If the settings include a fixed delta time, verify its accuracy.\n  if (settings.fixed_delta_seconds != 0.0f) {\n    constexpr size_t kMaxTicks = 10u;\n    constexpr float kMaxDeltaError = 0.001f;\n    constexpr float kMaxDelta = 0.0001f;\n    constexpr float kMaxTime = 1.0f;\n    constexpr float kMinTime = 0.0f;\n\n    // Run a series of ticks to verify the accuracy of the fixed delta time.\n    for (size_t i = 0u; i < kMaxTicks; ++i) {\n      auto start = Clock::now();\n      episode->Tick(kMaxDelta);\n      auto end = Clock::now();\n      auto delta = std::chrono::duration_cast<time_duration>(end - start);\n      if (delta.count() > kMaxDelta) {\n        log_warning(\"fixed delta time setting is inaccurate\");\n        break;\n      }\n      if (delta.count() < kMinTime) {\n        log_warning(\"fixed delta time setting is too small\");\n        break;\n      }\n      if (delta.count() > kMaxTime) {\n        log_warning(\"fixed delta time setting is too large\");\n        break;\n      }\n    }\n\n    // If the delta time is too inaccurate, log a warning.\n    if (settings.fixed_delta_seconds != episode->GetFixedDeltaSeconds()) {\n      log_warning(\"fixed delta time setting is inaccurate\");\n    }\n  }\n\n  // Return the identifier of the applied settings.\n  return settings_id;\n}", "CodeBleu_score": 46.59252386661126}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// Set the local timeout.\n  timeout = std::max(timeout, _episode.Lock()->GetNetworkingTimeout());\n  // Apply the settings.\n  uint64_t result = _episode.Lock()->ApplySettings(settings, timeout);\n  // Verify the accuracy of the delta time setting.\n  if (settings.has_fixed_delta_seconds() && settings.fixed_delta_seconds() > 0.0f) {\n    const auto start = Clock::now();\n    const auto end = start + time_duration(settings.fixed_delta_seconds() * 1000);\n    const auto delta = settings.fixed_delta_seconds() * 1000.0f;\n    while (Clock::now() < end) {\n      const auto start_tick = Clock::now();\n      _episode.Lock()->Tick(delta);\n      const auto end_tick = Clock::now();\n      const auto elapsed = end_tick - start_tick;\n      if (elapsed > delta) {\n        log_warning(\"The delta time setting is not accurate. \"\n                    \"Elapsed time: \", elapsed.count(), \"ms. \"\n                    \"Expected time: \", delta, \"ms.\");\n        break;\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 48.19529087302217}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tif (settings.synchronous_mode()) {\n    ApplySettings(settings, timeout, 0u);\n  } else {\n    ApplySettings(settings, timeout, _settings_id);\n  }\n  return _settings_id;\n}", "CodeBleu_score": 17.213102573698873}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat dist_sq = 0.0f;\n  float dist = 0.0f;\n  float t = 0.0f;\n  float t_clamped = 0.0f;\n  float length_sq = 0.0f;\n  float length = 0.0f;\n  float dx = 0.0f;\n  float dy = 0.0f;\n  float dx_sq = 0.0f;\n  float dy_sq = 0.0f;\n  float dx_sq_length = 0.0f;\n  float dy_sq_length = 0.0f;\n  float dx_length = 0.0f;\n  float dy_length = 0.0f;\n  float dx_clamped = 0.0f;\n  float dy_clamped = 0.0f;\n  float dx_clamped_sq = 0.0f;\n  float dy_clamped_sq = 0.0f;\n  float dx_clamped_length = 0.0f;\n  float dy_clamped_length = 0.0f;\n  float dx_clamped_sq_length = 0.0f;\n  float dy_clamped_sq_length = 0.0f;\n  float dx_clamped_length_sq = 0.0f;\n  float dy_clamped_length_sq = 0.0f;\n  float dx_clamped_length_sq_sq = 0.0f;\n  float dy_clamped_length_sq_sq = 0.0f;\n  float dx_clamped_length_sq_length = 0.0f;\n  float dy_clamped_length_sq_length = 0.0f;\n  float dx_clamped_length_sq_length_sq = 0.0f;\n  float dy_clamped_length_sq_length_sq = 0.0f;\n  float dx_clamped_length_sq_length_length = 0.0f;\n  float dy_clamped", "CodeBleu_score": 7.64776537171379}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat a_x = segment.p[0].x;\n    float a_y = segment.p[0].y;\n    float b_x = segment.p[1].x;\n    float b_y = segment.p[1].y;\n    float p_x = point.x;\n    float p_y = point.y;\n\n    float l2 = (b_x - a_x) * (b_x - a_x) + (b_y - a_y) * (b_y - a_y);\n    if (l2 == 0.0f) {\n        return std::make_pair(0.0f, std::sqrt(std::pow(p_x - a_x, 2) + std::pow(p_y - a_y, 2)));\n    }\n    float t = ((p_x - a_x) * (b_x - a_x) + (p_y - a_y) * (b_y - a_y)) / l2;\n    t = std::clamp(t, 0.0f, 1.0f);\n    float proj_x = a_x + t * (b_x - a_x);\n    float proj_y = a_y + t * (b_y - a_y);\n    return std::make_pair(std::sqrt(std::pow(p_x - proj_x, 2) + std::pow(p_y - proj_y, 2)), std::sqrt(std::pow(p_x - a_x, 2) + std::pow(p_y - a_y, 2)));\n}", "CodeBleu_score": 41.292256647821766}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat s = 0.0f;\n  float t = 0.0f;\n  float l = 0.0f;\n  float d = 0.0f;\n  float d_sq = 0.0f;\n  float d_sq_min = 0.0f;\n  float d_sq_max = 0.0f;\n  float d_sq_seg = 0.0f;\n  float d_sq_pt = 0.0f;\n  float d_sq_seg_pt = 0.0f;\n  float d_sq_seg_pt_proj = 0.0f;\n  float d_sq_seg_pt_proj_clamp = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_sq = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_seg_sq = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_seg_sq_sq = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_seg_sq_sq_sq = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_seg_sq_sq_sq_sq = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_seg_sq_sq_sq_sq_sq = 0.0f;\n  float d_sq_seg_pt_proj_clamp_seg_seg_seg_seg_sq_sq_sq_sq_sq_sq = 0.0f;\n  float d_sq_seg", "CodeBleu_score": 8.28469582315526}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() < 3) {\n    return;\n  }\n  DEBUG_ASSERT(vertices.size() >= 3);\n  size_t i = GetVerticesNum() + 2;\n  AddVertices(vertices);\n  bool index_clockwise = true;\n  while (i < GetVerticesNum()) {\n    index_clockwise = !index_clockwise;\n    if (index_clockwise) {\n      AddIndex(i + 1);\n      AddIndex(i);\n      AddIndex(i - 1);\n    } else {\n      AddIndex(i - 1);\n      AddIndex(i);\n      AddIndex(i + 1);\n    }\n    ++i;\n  }\n}", "CodeBleu_score": 68.52572797572711}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n      return;\n    }\n    DEBUG_ASSERT(vertices.size() >= 3);\n    size_t i = GetVerticesNum() + 2;\n    AddVertices(vertices);\n    while (i < GetVerticesNum()) {\n      AddIndex(i - 1);\n      AddIndex(i);\n      AddIndex(i + 1);\n      ++i;\n    }\n  }", "CodeBleu_score": 71.72480758656747}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tif (vertices.size() == 0) {\n    return;\n  }\n  DEBUG_ASSERT(vertices.size() >= 3);\n  size_t i = GetVerticesNum();\n  AddVertices(vertices);\n  bool index_clockwise = true;\n  while (i < GetVerticesNum()) {\n    index_clockwise = !index_clockwise;\n    if (index_clockwise) {\n      AddIndex(i + 1);\n      AddIndex(i);\n      AddIndex(i - 1);\n    } else {\n      AddIndex(i - 1);\n      AddIndex(i);\n      AddIndex(i + 1);\n    }\n    ++i;\n  }\n}", "CodeBleu_score": 62.14970412884845}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\n  DEBUG_ASSERT(message->IsValid());\n  DEBUG_ASSERT(_socket.is_open());\n  DEBUG_ASSERT(_on_response);\n  DEBUG_ASSERT(_deadline.expires_at() == _deadline.expires_at());\n  DEBUG_ASSERT(_strand.running_in_this_thread());\n\n  // This forces not using Nagle's algorithm.\n  // Improves the sync mode velocity on Linux by a factor of ~3.\n  const boost::asio::ip::tcp::no_delay option(true);\n  _socket.set_option(option);\n\n  // callbacks\n  auto on_sent = [this](const boost::system::error_code &ec) {\n    if (ec) {\n      carla::LogError(\"tcp multigpu server session \", _session_id, \" write failed: \", ec.message());\n      Close();\n    } else {\n      ReadData();\n    }\n  };\n\n  if (_socket.is_open()) {\n    _deadline.expires_at(std::chrono::steady_clock::time_point::max());\n    _strand.post([this, message, on_sent]() {\n      if (_socket.is_open()) {\n        _deadline.expires_from_now(_timeout);\n        _deadline.async_wait(\n            _strand.wrap(\n                [this, message, on_sent](const boost::system::error_code &ec) {\n                  if (ec) {\n                    carla::LogError(\"tcp multigpu server session \", _session_id, \" deadline expired: \", ec.message());\n                    Close();\n                  } else {\n                    _socket.async_write_some(\n                        boost::asio::buffer(message->data(), message->size()),\n                        _strand.wrap(on_sent));\n                  }\n                }));\n      }\n    });\n  }\n}", "CodeBleu_score": 42.13913290211546}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\n  if (message->IsValid()) {\n    _strand.post([this, message]() {\n      if (_socket.is_open()) {\n        _deadline.expires_from_now(_timeout);\n        _deadline.async_wait(\n            [this](const boost::system::error_code &error) {\n              if (error != boost::asio::error::operation_aborted) {\n                CARLA_LOG_ERROR(\"tcp multigpu server session\", _session_id, \"write timeout\");\n                Close();\n              }\n            });\n        boost::asio::async_write(\n            _socket,\n            boost::asio::buffer(message->Data(), message->Size()),\n            boost::asio::bind_executor(_strand,\n              [this](const boost::system::error_code &error, std::size_t bytes_transferred) {\n                if (error) {\n                  CARLA_LOG_ERROR(\"tcp multigpu server session\", _session_id, \"write error: \", error.message());\n                  Close();\n                } else {\n                  DEBUG_ASSERT(bytes_transferred == message->Size());\n                }\n              }));\n      } else {\n        CARLA_LOG_ERROR(\"tcp multigpu server session\", _session_id, \"write error: socket closed\");\n      }\n    });\n  } else {\n    CARLA_LOG_ERROR(\"tcp multigpu server session\", _session_id, \"write error: invalid message\");\n  }\n}", "CodeBleu_score": 38.36841118051508}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\n  if (!_socket.is_open()) {\n    return;\n  }\n  if (message->size() > 1024 * 1024) {\n    log_warning(\"tcp\", \"Message too large: \", message->size(), \" bytes\");\n    return;\n  }\n  // Check if the message is valid.\n  if (!message->IsValid()) {\n    log_warning(\"tcp\", \"Invalid message: \", message->size(), \" bytes\");\n    return;\n  }\n  // Post a lambda to the strand.\n  _strand.post([this, message]() {\n    // Check if the socket is open.\n    if (!_socket.is_open()) {\n      return;\n    }\n    // Set a timeout.\n    _deadline.expires_from_now(_timeout);\n    _deadline.async_wait(\n        boost::asio::bind_executor(_strand,\n          [this](const boost::system::error_code &ec) {\n            if (ec) {\n              log_warning(\"tcp\", \"Timeout: \", ec.message());\n              return;\n            }\n            // Check if the socket is open.\n            if (!_socket.is_open()) {\n              return;\n            }\n            // Initiate an asynchronous write.\n            _socket.async_write_some(\n                boost::asio::buffer(message->data(), message->size()),\n                boost::asio::bind_executor(_strand,\n                  [this](const boost::system::error_code &ec, size_t bytes_transferred) {\n                    if (ec) {\n                      log_warning(\"tcp\", \"Write: \", ec.message());\n                      return;\n                    }\n                    // Check if the socket is open.\n                    if (!_socket.is_open()) {\n                      return;\n                    }\n                    // Check if the message is valid.\n                    if (!message->IsValid()) {\n                      log_warning(\"tcp\", \"Invalid message: \", message->size(), \" bytes\");\n                      return;\n                    }\n                    // Check if the message was sent completely", "CodeBleu_score": 39.76441874073533}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_COUNTER{0u};\n\n  Primary::Primary(\n      boost::asio::io_context &io_context,\n      const time_duration timeout,\n      Listener &server)\n    : LIBCARLA_INITIALIZE_LIFETIME_PROFILER(\n          std::string(\\\"tcp multigpu server session \\\") + std::to_string(SESSION_COUNTER)),\n      _server(server),\n      _session_id(SESSION_COUNTER++),\n      _socket(io_context),\n      _timeout(timeout),\n      _deadline(io_context),\n      _strand(io_context),\n      _buffer_pool(std::make_shared<BufferPool>()) {}\n\n  Primary::~Primary() {\n    if (_socket.is_open()) {\n      boost::system::error_code ec;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec);\n      _socket.close();\n    }\n  }\n\n  void Primary::Open(\n      Listener::callback_function_type on_opened,\n      Listener::callback_function_type on_closed,\n      Listener::callback_function_type_response on_response) {\n    DEBUG_ASSERT(on_opened && on_closed);\n\n    // This forces not using Nagle's algorithm.\n    // Improves the sync mode velocity on Linux by a factor of ~3.\n    const boost::asio::ip::tcp::no_delay option(true);\n    _socket.set_option(option);\n\n    // callbacks\n    _on_closed = std::move(on_closed);\n    _on_response = std::move(on_response);\n    on_opened(shared_from_this());\n\n    ReadData();\n  }\n\n  void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (ec) {\n          log_error(\\\"session \\\", self->_session_id, \\\": error sending data: \\\", ec.message());\n          self->CloseNow(ec);\n        } else {\n          // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n        }\n      };\n\n      self->_deadline.expires_from_now(self->_timeout);\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(self->_strand, handle_sent));\n    });\n  }\n\n  void Primary::Write(std::string text) {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [=]() {\n      auto self = weak.lock();\n      if (!self) return;\n      if (!self->_socket.is_open()) {\n        return;\n      }\n\n      // sent first size buffer\n      self->_deadline.expires_from_now(self->_timeout);\n      int this_size = text.size();\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(&this_size, sizeof(this_size)),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n      // send characters\n      boost::asio::async_write(\n          self->_socket,\n          boost::asio::buffer(text.c_str(), text.size()),\n          boost::asio::bind_executor(self->_strand, [](const boost::system::error_code &, size_t){ }));\n    });\n  }\n\n  void Primary::ReadData() {\n    std::weak_ptr<Primary> weak = shared_from_this();\n    boost::asio::post(_strand, [weak]() {\n      auto self = weak.lock();\n      if (!self) return;\n\n      auto message = std::make_shared<IncomingMessage>(self->_buffer_pool->Pop());\n\n      auto handle_read_data = [weak, message](boost::system::error_code ec, size_t DEBUG_ONLY(bytes)) {\n        auto self = weak.lock();\n        if (!self) return;\n        if (!ec) {\n          DEBUG_ASSERT_EQ(bytes, message->size());\n          DEBUG_ASSERT_NE(bytes, 0u);\n          // Move the buffer to the callback function and start reading the next\n          // piece of data.\n          self->_on_response(self, message->pop());\n          std::cout << \\\"Getting data on listener", "CodeBleu_score": 55.05616949491107}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 16);\n  log_info(\"sending is alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"got a response: \", response.buffer.data());\n}", "CodeBleu_score": 67.65172714213499}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::streaming::detail::tcp::Message msg = carla::streaming::detail::tcp::Message::Alive();\n  carla::Buffer buf((carla::Buffer::value_type *) msg.data(), (size_t) msg.size());\n  log_info(\"sending alive message\");\n  _router->Write(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = _router->Read().get();\n  log_info(\"got response: \", response.command, \" \", response.buffer.size());\n}", "CodeBleu_score": 60.39744594133937}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tcarla::Buffer buf((carla::Buffer::value_type *) \"Are you alive?\", (size_t) 17);\n  log_info(\"sending alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n\n  auto response = fut.get();\n  log_info(\"got a response: \", response.buffer.data());\n}", "CodeBleu_score": 65.78199319483313}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  if (response.buffer.size() == 0) {\n    log_error(\"no response from the server\");\n  }\n  log_info(\"response from enable ros command: \", response.buffer.data());\n}", "CodeBleu_score": 54.194568461915026}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  log_info(\"response from alive command: \", response.buffer.data());\n}", "CodeBleu_score": 51.337358442920134}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::ENABLE_ROS, std::move(buf));\n  auto response = fut.get();\n  log_info(\"response from alive command: \", response.buffer.data());\n}", "CodeBleu_score": 49.94009563789588}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // if the sensor has been activated, return the existing token\n    log_info(\"sensor\", sensor_id, \" already activated\");\n    return _tokens[sensor_id];\n  } else {\n    // if the sensor has not been activated, enable it on a secondary server, retrieve a new token, update the maps, log the action, and return the new token\n    log_info(\"sensor\", sensor_id, \" not activated, enabling it\");\n    // enable the sensor on a secondary server\n    EnableSensor(sensor_id);\n    // retrieve a new token\n    token_type new_token = SendGetToken(sensor_id);\n    // update the maps\n    _servers[sensor_id] = new_token.get_port();\n    _tokens[sensor_id] = new_token;\n    log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n    return new_token;\n  }\n}", "CodeBleu_score": 60.584972545102545}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // if it has been activated, return the token\n    token_type new_token = it->second;\n    log_info(\"retrieving token for sensor\", sensor_id, \" (\", new_token.get_stream_id(), \", \", new_token.get_port(), \")\");\n    return new_token;\n  } else {\n    // if it has not been activated, enable the sensor and retrieve a new token\n    log_info(\"activating sensor\", sensor_id, \" and retrieving token\");\n    // send to know if a connection is alive\n    SendIsAlive();\n    // send to who the router wants the request for a token\n    token_type new_token = SendGetToken(sensor_id);\n    // save the token in the map\n    _servers.insert(std::make_pair(sensor_id, new_token));\n    log_info(\"sensor\", sensor_id, \" activated and token retrieved\");\n    return new_token;\n  }\n}", "CodeBleu_score": 50.09576170055805}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // log_info(\"sensor \", sensor_id, \" already activated\");\n    return it->second;\n  } else {\n    // log_info(\"activating sensor \", sensor_id);\n    // enable the sensor on a secondary server\n    Enable(sensor_id);\n    // retrieve a new token\n    token_type new_token = SendGetToken(sensor_id);\n    // update the maps\n    _servers.insert(std::pair<stream_id, token_type>(sensor_id, new_token));\n    _ports.insert(std::pair<stream_id, uint16_t>(sensor_id, new_token.get_port()));\n    return new_token;\n  }\n}", "CodeBleu_score": 46.75858903272766}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t// open the file\n  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // get the file size\n  file.seekg(0, file.end);\n  std::streamoff size = file.tellg();\n  file.seekg(0, file.beg);\n\n  // read the file content into a vector\n  std::vector<char> data(size);\n  file.read(data.data(), size);\n  file.close();\n\n  // parse the file content\n  return Load(data);\n}", "CodeBleu_score": 55.80513309531454}, {"code": "bool Navigation::Load(const std::string &filename){\n\t// open file\n  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  // get file size\n  file.seekg(0, std::ios::end);\n  std::streampos file_size = file.tellg();\n  file.seekg(0, std::ios::beg);\n  // read file content into vector\n  std::vector<unsigned char> file_data(file_size);\n  file.read((char *)&file_data[0], file_size);\n  file.close();\n  // parse file data\n  return Load(file_data);\n}", "CodeBleu_score": 50.84948860798833}, {"code": "bool Navigation::Load(const std::string &filename){\n\t// open file\n  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  // get file size\n  file.seekg(0, file.end);\n  std::streamoff file_size = file.tellg();\n  file.seekg(0, file.beg);\n  // read file content into vector\n  std::vector<char> file_data(file_size);\n  file.read(file_data.data(), file_size);\n  file.close();\n  // parse file content\n  return Load(file_data);\n}", "CodeBleu_score": 54.53164076480219}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\twalker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        return false;\n      }\n    }\n\n    // save the id\n    _mapped_walkers_id[id] = index;\n    _mapped_by_index[index] = id;\n\n    // init yaw\n    _yaw_walkers[id] = 0.0f;\n\n    // add walker for the route planning\n    _walker_manager.AddWalker(id);\n\n    return true;\n  }", "CodeBleu_score": 30.319217944433063}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\\\"Vehicle agent not added to the crowd by some problem!\\\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 38.971640180892145}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tvel[2], agent->vel[0]) * (180.0f / static_cast<float>(M_PI));\n      speed = sqrtf(agent->vel[0] * agent->vel[0] + agent->vel[1] * agent->vel[1] + agent->vel[2] * agent->vel[2]);\n    }", "CodeBleu_score": 15.697219358190125}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tfalse;\n        _walkers.erase(it);\n\n        return true;\n    }", "CodeBleu_score": 14.65765175405028}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\tane_node.children(\\\"border\\\")) {\n        const double s_offset = lane_border_node.attribute(\\\"sOffset\\\").as_double();\n        const double a = lane_border_node.attribute(\\\"a\\\").as_double();\n        const double b = lane_border_node.attribute(\\\"b\\\").as_double();\n        const double c = lane_border_node.attribute(\\\"c\\\").as_double();\n        const double d = lane_border_node.attribute(\\\"d\\\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\\\"roadMark\\\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\\\"sOffset\\\").as_double();\n          const std::string type = lane_road_mark.attribute(\\\"type\\\").value();\n          const std::string weight = lane_road_mark.attribute(\\\"weight\\\").value();\n          const std::string color = lane_road_mark.attribute(\\\"color\\\").value();\n          const std::string material = lane_road_mark.attribute(\\\"material\\\").value();\n          const double width = lane_road_mark.attribute(\\\"width\\\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\\\"laneChange\\\").value();\n          const double height = lane_road_mark.attribute(\\\"height\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \\\"\\\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\\\"type\\\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\\\"name\\\").value();\n            type_width = road_mark_type.attribute(\\\"width\\\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\\\"line\\\")) {\n\n          const double length = road_mark_type_line_node.attribute(\\\"length\\\").as_double();\n          const double space = road_mark_type_line_node.attribute(\\\"space\\\").as_double();\n          const double t = road_mark_type_line_node.attribute(\\\"tOffset\\\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\\\"sOffset\\\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\\\"rule\\\").value();\n          const double width = road_mark_type_line_node.attribute(\\\"width\\\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\\\"material\\\")) {\n\n        const double s_offset = lane_material_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string surface = lane_material_node.attribute(\\\"surface\\\").value();\n        const double friction = lane_material_node.attribute(\\\"friction\\\").as_double();\n        const double roughness = lane_material_node.attribute(\\\"roughness\\\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\\\"visibility\\\")) {\n        const double s_offset = lane_visibility_node.attribute(\\\"sOffset\\\").as_double();\n        const double forward = lane_visibility_node.attribute(\\\"forward\\\").as_double();\n        const double back = lane_visibility_node.attribute(\\\"back\\\").as_double();\n        const double left = lane_visibility_node.attribute(\\\"left\\\").as_double();\n        const double right = lane_visibility_node.attribute(\\\"right\\\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\\\"speed\\\")) {\n        const double s_offset = lane_speed_node.attribute(\\\"sOffset\\\").as_double();\n        const double max = lane_speed_node.attribute(\\\"max\\\").as_double();\n        std::string unit = lane_speed_node.attribute(\\\"unit\\\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\\\"access\\\")) {\n        const double s_offset = lane_access_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string restriction = lane_access_node.attribute(\\\"restriction\\\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\\\"height\\\")) {\n        const double s_offset = lane_height_node.attribute(\\\"sOffset\\\").as_double();\n        const double inner = lane_height_node.attribute(\\\"inner\\\").as_double();\n        const double outer = lane_height_node.attribute(\\\"outer\\\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\\\"rule\\\")) {\n        const double s_offset = lane_rule_node.attribute(\\\"sOffset\\\").as_double();\n        const std::string value = lane_rule_node.attribute(\\\"value\\\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }", "CodeBleu_score": 32.68661112926285}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    if (info.total_count == 0) {\n      std::cout << \"No subscribers detected.\" << std::endl;\n    } else {\n      _matched = info.total_count;\n      if (!_first_connected) {\n        std::cout << \"First connection detected.\" << std::endl;\n        _first_connected = true;\n      } else {\n        std::cout << \"New subscriber detected.\" << std::endl;\n      }\n    }\n  } else if (info.current_count_change == -1) {\n    if (info.total_count == 0) {\n      std::cout << \"Last subscriber lost.\" << std::endl;\n    } else {\n      _matched = info.total_count;\n      std::cout << \"Subscriber lost.\" << std::endl;\n    }\n  } else {\n    std::cout << \"Invalid publication matching change: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 64.58707539703423}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    if (info.current_count == 1) {\n      _matched = 1;\n      _first_connected = true;\n    } else {\n      std::cerr << \"CarlaListenerImpl: Invalid publication count change, current count is \" << info.current_count << std::endl;\n    }\n  } else if (info.current_count_change == -1) {\n    if (info.current_count == 0) {\n      _matched = 0;\n    } else {\n      std::cerr << \"CarlaListenerImpl: Invalid publication count change, current count is \" << info.current_count << std::endl;\n    }\n  } else {\n    std::cerr << \"CarlaListenerImpl: Invalid publication count change, current count is \" << info.current_count << std::endl;\n  }\n}", "CodeBleu_score": 63.846501225184646}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change > 0) {\n    if (info.current_count_change > 1) {\n      std::cerr << \"CarlaListenerImpl::on_publication_matched: \"\n                << \"Publication matched count change greater than 1: \"\n                << info.current_count_change << std::endl;\n    }\n    if (info.current_count_change > 1) {\n      std::cerr << \"CarlaListenerImpl::on_publication_matched: \"\n                << \"Publication matched count change greater than 1: \"\n                << info.current_count_change << std::endl;\n    }\n    _matched = info.current_count;\n    if (!_first_connected) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change < 0) {\n    if (info.current_count_change < -1) {\n      std::cerr << \"CarlaListenerImpl::on_publication_matched: \"\n                << \"Publication matched count change less than -1: \"\n                << info.current_count_change << std::endl;\n    }\n    _matched += info.current_count_change;\n  } else {\n    std::cerr << \"CarlaListenerImpl::on_publication_matched: \"\n              << \"Publication matched count change is zero: \"\n              << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 56.18265726391601}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    _matched++;\n    if (info.total_count == _matched) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched--;\n    if (_matched == 0) {\n      delete this;\n    }\n  } else {\n    std::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 66.170367318056}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    if (info.last_publication_handle == efd::HANDLE_NIL) {\n      _matched++;\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched--;\n    if (_matched == 0) {\n      delete _owner;\n      _owner = nullptr;\n    }\n  } else {\n    std::cerr << \"ERROR: CarlaSubscriberListenerImpl::on_subscription_matched: Invalid count change \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 65.75591439059647}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    _matched++;\n    if (_matched == 1) {\n      _first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    _matched--;\n    if (_matched == 0) {\n      _owner->Destroy();\n    }\n  } else {\n    std::cerr << \"Invalid subscription change count: \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 64.91683865454057}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)\n    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i)\n        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else\n    {\n        memcpy(handle->value, m_keyBuffer, 16);\n    }\n    return true;\n}", "CodeBleu_score": 77.2023236793357}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 86.69419977745447}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer, CarlaCollisionEvent::getKeyMaxCdrSerializedSize() * 2);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        memcpy(handle->value, m_keyBuffer, 16);\n    }\n    return true;\n}", "CodeBleu_score": 76.38348767357301}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.\n    Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); //Set endianness\n    try\n    {\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 66.21284427787118}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    FastBuffer fastbuffer((char*)payload->data, payload->max_size); // Object that manages the raw buffer.\n    Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); //Set encapsulation.\n    payload->length = 0; //Set the length of the payload (0 -> payload size is not defined yet).\n    try\n    {\n        // Serialize encapsulation\n        ser.serializeEncapsulation();\n        payload->encapsulation = ser.endianness(); //Endianness of the encapsulation.\n        // Serialize the object:\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length.\n    return true;\n}", "CodeBleu_score": 62.19048159098628}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.\n    Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); //Set encapsulation.\n    try\n    {\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 69.08557181178932}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tParam: EXTRA1\n    // @DisplayName: Extra data type 1 stream rate to ground station\n    // @Description: Extra data type 1 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA1\\\",   5, GCS_MAVLINK_Parameters, streamRates[5],  1),\n\n    // @Param: EXTRA2\n    // @DisplayName: Extra data type 2 stream rate to ground station\n    // @Description: Extra data type 2 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA2\\\",   6, GCS_MAVLINK_Parameters, streamRates[6],  1),\n\n    // @Param: EXTRA3\n    // @DisplayName: Extra data type 3 stream rate to ground station\n    // @Description: Extra data type 3 stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"EXTRA3\\\",   7, GCS_MAVLINK_Parameters, streamRates[7],  1),\n\n    // @Param: PARAMS\n    // @DisplayName: Parameter stream rate to ground station\n    // @Description: Parameter stream rate to ground station\n    // @Units: Hz\n    // @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 12.012772212221384}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t// @Range: 0 50\n    // @Increment: 1\n    // @RebootRequired: True\n    // @User: Advanced\n    AP_GROUPINFO(\\\"PARAMS\\\",   8, GCS_MAVLINK_Parameters, streamRates[8],  10),\n    AP_GROUPEND\n}", "CodeBleu_score": 10.231082339933758}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t,\n    MSG_SCALED_PRESSURE2,\n    MSG_SCALED_PRESSURE3,\n}", "CodeBleu_score": 5.132093141527607}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < MAX_CHANNELS; i++) {\n        if (channels[i].payload_available()) {\n            channels[i].send_datastream_position(sysid, compid);\n            break;\n        }\n    }\n}", "CodeBleu_score": 41.152679256052956}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n        if (tracker.g.sysid_this_mav != sysid && tracker.g.sysid_this_mav != 0) {\n            continue;\n        }\n        if (tracker.g.channels[i].available_payload_space() > 0) {\n            tracker.g.channels[i].send_request_datastream_position(sysid, compid);\n        }\n    }\n}", "CodeBleu_score": 47.28972538061241}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tfor (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n        if (tracker.g.gcs[i].available_payload_space() > 0) {\n            tracker.g.gcs[i].request_datastream_position(sysid, compid);\n        }\n    }\n}", "CodeBleu_score": 34.22765829603988}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    if (ahrs.cos_pitch == 0) {\n        return false;\n    }\n    ef_pitch = ahrs.cos_pitch() * pitch - ahrs.sin_pitch() * ahrs.sin_roll() * yaw;\n    ef_yaw = ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n    return true;\n}", "CodeBleu_score": 77.86679028118765}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    if (ahrs.cos_pitch() != 0) {\n        ef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n        ef_yaw = -ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 79.49200999440039}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tconst AP_AHRS &ahrs = AP::ahrs();\n    if (ahrs.cos_pitch != 0) {\n        ef_pitch = ahrs.cos_pitch() * pitch - ahrs.sin_pitch() * ahrs.sin_roll() * yaw;\n        ef_yaw = ahrs.sin_pitch() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 75.72985748671636}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// Get the current yaw and pitch in centidegrees\n    int16_t yaw_cd = Tracker::get_yaw_cd();\n    int16_t pitch_cd = Tracker::get_pitch_cd();\n\n    // Get the current distance in centimeters\n    int16_t distance_cm = Tracker::get_distance_cm();\n\n    // Get the current yaw and pitch in centidegrees\n    int16_t yaw_cd_target = Tracker::get_yaw_cd_target();\n    int16_t pitch_cd_target = Tracker::get_pitch_cd_target();\n\n    // Get the current distance in centimeters\n    int16_t distance_cm_target = Tracker::get_distance_cm_target();\n\n    // Get the current distance in centimeters\n    int16_t distance_cm_min = Tracker::get_distance_cm_min();\n\n    // Get the current distance in centimeters\n    int16_t distance_cm_max = Tracker::get_distance_cm_max();\n\n    // Get the current yaw and pitch in centidegrees\n    int16_t yaw_cd_min = Tracker::get_yaw_cd_min();\n    int16_t pitch_cd_min = Tracker::get_pitch_cd_min();\n\n    // Get the current yaw and pitch in centidegrees\n    int16_t yaw_cd_max = Tracker::get_yaw_cd_max();\n    int16_t pitch_cd_max = Tracker::get_pitch_cd_max();\n\n    // Get the current yaw and pitch in centidegrees\n    int16_t yaw_cd_reverse = Tracker::get_yaw_cd_reverse();\n    int16_t pitch_cd_reverse = Tracker::get_pitch_cd_reverse();\n\n    // Get the current yaw and pitch in centidegrees\n    int16_t yaw_cd_reverse_target = Tracker::get_yaw_cd_reverse_target();", "CodeBleu_score": 9.578718098141048}, {"code": "void Mode::update_auto(void){\n\t// Calculate the target yaw and pitch in centidegrees\n    int16_t target_yaw = (int16_t)(((float)nav_status.target_bearing * 100.0f) / 360.0f);\n    int16_t target_pitch = (int16_t)(((float)nav_status.target_altitude * 100.0f) / 100.0f);\n\n    // Check if the direction is reversed\n    if (nav_status.target_bearing > 180) {\n        target_yaw = -target_yaw;\n    }\n\n    // Check if the target distance is valid or no minimum distance is set\n    if (nav_status.target_distance < 0 || nav_status.target_distance > 0 && nav_status.target_distance >= min_distance) {\n        // Compute the angle error\n        int16_t yaw_error = target_yaw - nav_status.yaw;\n        int16_t pitch_error = target_pitch - nav_status.pitch;\n\n        // Convert the errors from earth frame to body frame\n        if (nav_status.roll > 0) {\n            yaw_error -= nav_status.roll;\n            pitch_error -= nav_status.roll;\n        } else {\n            yaw_error += nav_status.roll;\n            pitch_error += nav_status.roll;\n        }\n\n        // Update the yaw and pitch servos accordingly\n        if (abs(yaw_error) <= 180) {\n            yaw_servo.set_target(yaw_error);\n        } else {\n            yaw_servo.set_target(yaw_error - (yaw_error / abs(yaw_error)) * 360);\n        }\n        if (abs(pitch_error) <= 180) {\n            pitch_servo.set_target(pitch_error);\n        } else {\n            pitch_servo.set_target(pitch_error - (pitch_error / abs(", "CodeBleu_score": 36.289447528862404}, {"code": "void Mode::update_auto(void){\n\t// Get the current position\n\tfloat current_lat = gps.location.lat();\n\tfloat current_lon = gps.location.lng();\n\tfloat current_alt = gps.altitude;\n\tfloat current_yaw = gps.yaw;\n\tfloat current_pitch = gps.pitch;\n\n\t// Get the target position\n\tfloat target_lat = config.latitude;\n\tfloat target_lon = config.longitude;\n\tfloat target_alt = config.altitude;\n\n\t// Get the current direction\n\tfloat current_direction = gps.course_over_ground_true;\n\tfloat current_direction_error = current_direction - config.direction;\n\tfloat current_direction_error_abs = fabs(current_direction_error);\n\n\t// Get the target direction\n\tfloat target_direction = config.direction;\n\tfloat target_direction_error = target_direction - current_direction;\n\tfloat target_direction_error_abs = fabs(target_direction_error);\n\n\t// Check if the direction is reversed\n\tbool direction_reversed = false;\n\tif (current_direction_error_abs > 180) {\n\t\tdirection_reversed = true;\n\t\tcurrent_direction_error = current_direction_error - 360;\n\t\ttarget_direction_error = target_direction_error - 360;\n\t}\n\n\t// Calculate the distance to the target\n\tfloat target_distance = get_distance(current_lat, current_lon, target_lat, target_lon);\n\tfloat current_distance = get_distance(current_lat, current_lon, current_lat, current_lon);\n\n\t// Calculate the yaw and pitch errors\n\tfloat yaw_error = get_angle_error(current_yaw, target_direction, current_direction, target_direction_error, current_direction_error);\n\tfloat pitch_error = get_angle_error(current_pitch, target_alt, current_alt, target_alt, current_alt);\n\n\t// Convert the errors to body frame\n\tyaw_error = convert_angle_to_body_frame(yaw", "CodeBleu_score": 33.203202270635416}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tgps.update();\n\n    // Check if the last message time has changed\n    if (gps.last_message_time_ms != last_gps_message_time_ms) {\n        // Check if the GPS status is at least 3D fix\n        if (gps.status >= AP_GPS::GPS_OK_FIX_3D) {\n            // Check if the current location is valid\n            if (gps.location_valid()) {\n                // Check if the countdown has reached one\n                if (ground_start_countdown == 1) {\n                    // Set the home location\n                    home.init(gps.location());\n                    ground_start_countdown = 0;\n                } else {\n                    // Reset the countdown\n                    ground_start_countdown = 1;\n                }\n            }\n        }\n        last_gps_message_time_ms = gps.last_message_time_ms;\n    }\n}", "CodeBleu_score": 41.725859241258476}, {"code": "void Tracker::update_GPS(void){\n\tif (gps.available()) {\n        gps.read();\n        if (gps.last_message_time_ms() != gps_last_message_time_ms) {\n            if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n                if (gps_home_countdown == 0) {\n                    if (gps.location().valid.position()) {\n                        gps_home_countdown = GPS_HOME_COUNTDOWN_INIT;\n                        gps_home_location = gps.location();\n                        gps_home_altitude = gps.altitude_m();\n                        gps_home_altitude_amsl = gps.altitude_amsl_m();\n                        gps_home_eph = gps.hdop();\n                        gps_home_epv = gps.vdop();\n                        gps_home_time = gps.time_epoch_ms();\n                        gps_home_last_update_ms = gps_last_message_time_ms;\n                        gps_home_set = true;\n                        gps_home_reset_countdown = false;\n                    }\n                } else if (gps_home_countdown > 0) {\n                    gps_home_countdown--;\n                }\n            } else {\n                gps_home_countdown = GPS_HOME_COUNTDOWN_INIT;\n                gps_home_reset_countdown = true;\n            }\n        }\n        gps_last_message_time_ms = gps.last_message_time_ms();\n    }\n}", "CodeBleu_score": 45.397305387228485}, {"code": "void Tracker::update_GPS(void){\n\tGPS_fix fix;\n    bool valid_fix = false;\n    bool home_set = false;\n\n    // update the GPS\n    if (GPS::status() == AP_GPS::GPS_OK_FIX_3D) {\n        valid_fix = true;\n        fix = GPS::position();\n    }\n\n    // check if we have a valid fix\n    if (valid_fix) {\n        // check if we have a home location\n        if (home.get_location() == AP_Math::Vector3()) {\n            // set home location\n            home.set_location(fix.location);\n            // set home altitude\n            home.set_alt(fix.alt);\n            // set home course\n            home.set_course(fix.course);\n            // set home time\n            home.set_time(hal.scheduler->millis());\n            // set home_set flag\n            home_set = true;\n        }\n    }\n\n    // check if we have a valid fix and a home location\n    if (valid_fix && home_set) {\n        // check if we have a valid home location\n        if (home.get_location() != AP_Math::Vector3()) {\n            // check if we have a valid home altitude\n            if (home.get_alt() != 0) {\n                // check if we have a valid home course\n                if (home.get_course() != 0) {\n                    // check if we have a valid home time\n                    if (home.get_time() != 0) {\n                        // check if we have a valid home location time\n                        if (home.get_location_time() != 0) {\n                            // check if we have a valid home altitude time\n                            if (home.get_alt_time() != 0) {\n                                // check if we have a valid home course time\n                                if (home.get_course_time() != 0) {\n                                    // check if we have a valid home location time\n                                    if (home.get_location_time() != 0) {\n                                        // check if we have a valid home altitude time", "CodeBleu_score": 39.055748337081795}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// Need to configure your servo so that increasing servo_out causes increase in pitch/elevation (ie pointing higher into the sky, above the horizon. On my antenna tracker this requires the pitch/elevation servo to be reversed param set RC2_REV -1\n    //\n    // The pitch servo (RC channel 2) is configured for servo_out of -9000-0-9000 servo_out, which will drive the servo from RC2_MIN to RC2_MAX usec pulse width. Therefore, you must set RC2_MIN and RC2_MAX so that your servo drives the antenna altitude between -90 to 90 exactly\n    // To drive my HS-645MG servos through their full 180 degrees of rotational range, I have to set:\n    // param set RC2_MAX 2540\n    // param set RC2_MIN 640\n    //\n    // You will also need to tune the pitch PID to suit your antenna and servos. I use:\n    // PITCH2SRV_P      0.100000\n    // PITCH2SRV_I      0.020000\n    // PITCH2SRV_D      0.000000\n    // PITCH2SRV_IMAX   4000.000000\n\n    // calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= g.pitch_min*100) {\n        new_servo_out = g.pitch_min*100;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= g.pitch_max*100) {\n        new_servo_out =", "CodeBleu_score": 23.3526008473031}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// update pitch servo\n    if (g.servo_pitch_type == SERVO_TYPE_ONOFF) {\n        // If we are in a position where the pitch is less than the minimum pitch, turn the servo on\n        if (pitch < g.pitch_min) {\n            SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.pitch_min);\n        } else {\n            SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 0);\n        }\n    }\n}", "CodeBleu_score": 31.37690328494645}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// calculate new servo position\n    float new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.update_error(nav_status.angle_error_pitch, G_Dt);\n\n    // position limit pitch servo\n    if (new_servo_out <= -g.pitch_min*100) {\n        new_servo_out = -g.pitch_min*100;\n        g.pidPitch2Srv.reset_I();\n    }\n    if (new_servo_out >= g.pitch_max*100) {\n        new_servo_out = g.pitch_max*100;\n        g.pidPitch2Srv.reset_I();\n    }\n    // rate limit pitch servo\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);\n\n    if (pitch_servo_out_filt_init) {\n        pitch_servo_out_filt.apply(new_servo_out, G_Dt);\n    } else {\n        pitch_servo_out_filt.reset(new_servo_out);\n        pitch_servo_out_filt_init = true;\n    }\n}", "CodeBleu_score": 40.38972954521203}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call the base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check if barometer checks are enabled\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    // check the barometer reference\n    if (!barometer_reference_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer altitude\n    if (copter.barometer->get_altitude() > copter.g.baro_alt_max) {\n        check_failed(display_failure, \"Barometer altitude above max\");\n        return false;\n    }\n\n    // check barometer altitude\n    if (copter.barometer->get_altitude() < copter.g.baro_alt_min) {\n        check_failed(display_failure, \"Barometer altitude below min\");\n        return false;\n    }\n\n    // check barometer altitude against inertial navigation altitude\n    if (copter.barometer->get_altitude() > copter.g.inertial_nav_alt_max) {\n        check_failed(display_failure, \"Barometer altitude above inertial navigation altitude\");\n        return false;\n    }\n\n    // check barometer altitude against inertial navigation altitude\n    if (copter.barometer->get_altitude() < copter.g.inertial_nav_alt_min) {\n        check_failed(display_failure, \"Barometer altitude below inertial navigation altitude\");\n        return false;\n    }\n\n    // check barometer altitude against inertial navigation altitude\n    if (copter.barometer->get_altitude() > copter.g.inertial_nav_alt_max + copter.g.baro_alt_max_above_inertial_nav_alt) {\n        check_failed(display_failure, \"Barometer altitude above inertial navigation altitude + %d\", cop", "CodeBleu_score": 39.33332563665466}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call base class function first\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if barometer checks are disabled return true\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    // check barometer reference\n    if (copter.barometer->get_baro_reference_altitude() == 0) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Barometer reference not set\");\n        return false;\n    }\n\n    // check barometer altitude\n    const float baro_alt = copter.barometer->get_altitude();\n    const float baro_alt_error = fabsf(baro_alt - copter.altitude_sensor->get_altitude());\n    if (baro_alt_error > copter.g.baro_alt_error_threshold) {\n        check_failed(ARMING_CHECK_BARO, display_failure, \"Barometer altitude error: %d cm\", (int16_t)baro_alt_error);\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 55.51504295215659}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call the base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check if barometer checks are enabled\n    if (!check_enabled(ARMING_CHECK_BARO)) {\n        // this check has been disabled\n        return true;\n    }\n\n    // check barometer reference\n    if (!copter.barometer->check_reference()) {\n        check_failed(display_failure, \"Barometer Reference\");\n        return false;\n    }\n\n    // check if barometer altitude is within limits\n    if (abs(copter.barometer->get_altitude_ref() - copter.barometer->get_altitude()) > copter.g.baro_alt_threshold) {\n        check_failed(display_failure, \"Barometer Altitude\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 43.65751822788128}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t_pre_arm_checks(display_failure);\n    set_pre_arm_check(passed);\n    return passed;\n}", "CodeBleu_score": 15.389793755880305}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// set the loop time for attitude, position, and motor controllers using the last loop time from the scheduler\n    attitude_control.set_dt(scheduler.get_loop_time());\n    position_control.set_dt(scheduler.get_loop_time());\n    motor_control.set_dt(scheduler.get_loop_time());\n\n    // run the low-level rate controllers that require only IMU data\n    attitude_control.rate_controller_run();\n\n    // run the low-level rate controllers that require IMU and barometer data\n    attitude_control.rate_controller_run_baro();\n\n    // run the low-level rate controllers that require IMU, barometer and GPS data\n    attitude_control.rate_controller_run_gps();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and optical flow data\n    attitude_control.rate_controller_run_optflow();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and range finder data\n    attitude_control.rate_controller_run_rangefinder();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and airspeed data\n    attitude_control.rate_controller_run_airspeed();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and vision data\n    attitude_control.rate_controller_run_vision();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and distance sensor data\n    attitude_control.rate_controller_run_distancesensor();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and magnetometer data\n    attitude_control.rate_controller_run_mag();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and magnetometer data\n    attitude_control.rate_controller_run_mag_3d();\n\n    // run the low-level rate controllers that require IMU, barometer, GPS and magnetometer data\n    attitude_control.rate_controller_run_mag_hdg();\n\n    // run the low-", "CodeBleu_score": 41.52896785207429}, {"code": "void Copter::run_rate_controller(){\n\t// run attitude controllers\n    attitude_control.rate_controller_run(ahrs.roll_sensor, ahrs.pitch_sensor, ahrs.yaw_sensor, ahrs.roll_rate, ahrs.pitch_rate, ahrs.yaw_rate, ahrs.update_rate, armed.armed, armed.vtol_armed, armed.landed);\n\n    // run position controllers\n    position_control.run_position_controller();\n\n    // run altitude controllers\n    altitude_control.run_altitude_controller();\n\n    // run navigation controller\n    navigation_control.run_navigation_controller();\n\n    // run failsafe\n    failsafe.run_failsafe();\n\n    // run landing gear\n    landing_gear.run_landing_gear();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger\n    camera_trigger.run_camera_trigger();\n\n    // run camera trigger", "CodeBleu_score": 38.65613634774009}, {"code": "void Copter::run_rate_controller(){\n\t// we need to know if we are in failsafe mode, so we can disable motors if required\n    bool failsafe_event = false;\n    if (failsafe.state == FAILSAFE_ON) {\n        failsafe_event = true;\n    }\n\n    // check if we have new IMU data\n    if (ahrs.new_imu_data()) {\n        // run the rate controllers\n        rate_controller_run(ahrs.get_deltatime());\n\n        // update the altitude controller\n        if (control_mode == AUTO) {\n            altitude_control_run();\n        }\n\n        // update the loiter controller\n        if (control_mode == LOITER) {\n            loiter_run();\n        }\n\n        // update the navigation controller\n        if (control_mode == AUTO || control_mode == RTL) {\n            navigation_run();\n        }\n\n        // update the failsafe\n        failsafe.update(failsafe_event);\n    }\n\n    // update the attitude controller\n    attitude_control_run();\n\n    // update the position controller\n    if (control_mode == AUTO) {\n        position_control_run();\n    }\n\n    // update the motor controllers\n    if (control_mode != MANUAL) {\n        motor_control_run();\n    }\n\n    // update the motor output\n    motors.update();\n\n    // update the LEDs\n    leds.update();\n\n    // update the GCS\n    gcs_update();\n\n    // update the telemetry\n    telemetry_update();\n\n    // update the attitude estimator\n    attitude_estimator_update();\n\n    // update the barometer\n    barometer.update();\n\n    // update the battery monitor\n    battery.update();\n\n    // update the GPS\n    gps.update();\n\n    // update the airspeed sensor\n    airspeed.update();\n\n    // update the compass\n    compass.update();\n\n    // update the EKF\n    ekf_update();\n\n    // update the flight mode\n    flight_mode", "CodeBleu_score": 42.81559719736254}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tvehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}", "CodeBleu_score": 41.55060787028528}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tVarInfo header defines the parameter information common to all vehicle types", "CodeBleu_score": 7.079264527034946}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}, {"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}, {"code": "void Copter::save_trim(){\n\t:\n            do_aux_function_change_mode(Mode::Number::ACRO, ch_flag);\n            break;\n#endif\n\n#if MODE_FLOWHOLD_ENABLED\n        case AUX_FUNC::FLOWHOLD:\n            do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag);\n            break;\n#endif\n\n#if MODE_CIRCLE_ENABLED == ENABLED\n        case AUX_FUNC::CIRCLE:\n            do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag);\n            break;\n#endif\n\n#if MODE_DRIFT_ENABLED == ENABLED\n        case AUX_FUNC::DRIFT:\n            do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::STANDBY: {\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.standby_active = true;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_ENABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Enabled\\\");\n                    break;\n                default:\n                    copter.standby_active = false;\n                    LOGGER_WRITE_EVENT(LogEvent::STANDBY_DISABLE);\n                    gcs().send_text(MAV_SEVERITY_INFO, \\\"Stand By Disabled\\\");\n                    break;\n                }\n            break;\n        }\n\n#if AP_RANGEFINDER_ENABLED\n        case AUX_FUNC::SURFACE_TRACKING:\n            switch (ch_flag) {\n            case AuxSwitchPos::LOW:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE);\n                break;\n            case AuxSwitchPos::HIGH:\n                copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING);\n                break;\n            }\n            break;\n#endif\n\n        case AUX_FUNC::FLIGHTMODE_PAUSE:\n            switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    if (!copter.flightmode->pause()) {\n                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, \\\"Flight Mode Pause failed\\\");\n                    }\n                    break;\n                case AuxSwitchPos::MIDDLE:\n                    break;\n                case AuxSwitchPos::LOW:\n                    copter.flightmode->resume();\n                    break;\n            }\n            break;\n\n#if MODE_ZIGZAG_ENABLED == ENABLED\n        case AUX_FUNC::ZIGZAG_Auto:\n            if (copter.flightmode == &copter.mode_zigzag) {\n                switch (ch_flag) {\n                case AuxSwitchPos::HIGH:\n                    copter.mode_zigzag.run_auto();\n                    break;\n                default:\n                    copter.mode_zigzag.suspend_auto();\n                    break;\n                }\n            }\n            break;\n#endif\n\n        case AUX_FUNC::AIRMODE:\n            do_aux_function_change_air_mode(ch_flag);\n#if MODE_ACRO_ENABLED == ENABLED && FRAME_CONFIG != HELI_FRAME\n            copter.mode_acro.air_mode_aux_changed();\n#endif\n            break;\n\n        case AUX_FUNC::FORCEFLYING:\n            do_aux_function_change_force_flying(ch_flag);\n            break;\n\n#if MODE_AUTO_ENABLED == ENABLED\n        case AUX_FUNC::AUTO_RTL:\n            do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag);\n            break;\n#endif\n\n#if MODE_TURTLE_ENABLED == ENABLED\n        case AUX_FUNC::TURTLE:\n            do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag);\n            break;\n#endif\n\n        case AUX_FUNC::SIMPLE_HEADING_RESET:\n            if (ch_flag == AuxSwitchPos::HIGH) {\n                copter.init_simple_bearing();\n                gcs().send_text(MAV_SEVERITY_INFO, \\\"Simple heading reset\\\");\n            }\n            break;\n\n        case AUX_FUNC::ARMDISARM_AIRMODE:\n            RC_Channel::do_aux_function_armdisarm(ch_flag);\n            if (copter.arming.is_armed()) {\n                copter.ap.armed_with_airmode_switch = true;\n            }\n            break;\n\n#if AC_CUSTOMCONTROL_MULTI_ENABLED == ENABLED\n        case AUX_FUNC::CUSTOM_CONTROLLER:\n            copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH);\n            break;\n#endif\n\n#if WEATHERVANE_ENABLED == ENABLED\n    case AUX_FUNC::WEATHER_VANE_ENABLE: {\n        switch (ch_flag) {\n            case AuxSwitchPos::HIGH:\n                copter.g2.weathervane.allow_weathervaning(true);\n                break;\n            case AuxSwitchPos::MIDDLE:\n                break;\n            case AuxSwitchPos::LOW:\n                copter.g2.weathervane.allow_weathervaning(false);\n                break;\n        }\n        break;\n    }\n#endif\n\n    default:\n        return RC_Channel::do_aux_function(ch_option, ch_flag);\n    }", "CodeBleu_score": 37.30052796690011}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// retrieve copter velocity\n    Vector3f velocity = copter.inertial_nav.get_velocity_cm_per_s();\n\n    // check if velocity is valid\n    if (velocity.is_valid()) {\n        // calculate speed squared\n        float speed_sq = velocity.length_sq();\n\n        // check if speed is valid\n        if (speed_sq > 0) {\n            // calculate look-ahead yaw angle\n            float look_ahead_yaw = atan2f(velocity.x, velocity.y) * RAD_TO_DEG;\n\n            // check if look-ahead yaw is valid\n            if (look_ahead_yaw > 0) {\n                // update look-ahead yaw angle\n                set_look_ahead_yaw(look_ahead_yaw);\n            }\n        }\n    }\n\n    // return look-ahead yaw angle\n    return get_look_ahead_yaw();\n}", "CodeBleu_score": 40.936715675612646}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// If the copter's position is valid and the speed exceeds a minimum threshold,\n    // update the look-ahead yaw angle using the arctangent of the velocity components.\n    if (copter.inertial_nav.is_valid() && copter.inertial_nav.get_speed_xy_cm() > 1000) {\n        float look_ahead_yaw = atan2f(copter.inertial_nav.get_velocity_y_cm_s(), copter.inertial_nav.get_velocity_x_cm_s());\n        if (look_ahead_yaw < 0) {\n            look_ahead_yaw += 2 * M_PI;\n        }\n        return look_ahead_yaw;\n    }\n    return 0;\n}", "CodeBleu_score": 33.979886712924475}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tif (copter.inertial_nav.is_valid_position() && copter.inertial_nav.get_velocity_xy_cm() > LOOK_AHEAD_MIN_SPEED) {\n        return (atan2f(copter.inertial_nav.get_velocity_y_cm(), copter.inertial_nav.get_velocity_x_cm()) * 180.0f / M_PI);\n    }\n    return 0.0f;\n}", "CodeBleu_score": 27.862216233792182}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tlow (%i < %i)\\\", plane.aparm.airspeed_min.get(), MIN_AIRSPEED_MIN);\n        ret = false;\n    }", "CodeBleu_score": 10.844964075197296}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\ts %s\\\", plane.control_mode->name(), failure_msg);\n        return false;\n    }", "CodeBleu_score": 11.305322940405363}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed()) {\n        return true;\n    }\n\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_text_P(MAV_SEVERITY_WARNING, PSTR(\"No disarm function assigned\"));\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.56583703087614}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// make sure the craft has a disarm button assigned before it is armed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            // display a message if we're not already armed\n            if (!armed) {\n                display_arm_failure();\n            }\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.1938438099873}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// make sure the craft has a disarm button assigned before it is armed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            display_arm_failure(arm_failure_reason_t::DISARM_BUTTON_NOT_CONFIGURED);\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.02646477895857}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n    float yaw_angle_rad = get_yaw_cd() * (M_PI/18000.0f);\n    float cos_yaw = cosf(yaw_angle_rad);\n    float sin_yaw = sinf(yaw_angle_rad);\n\n    ne_x = x * cos_yaw + y * sin_yaw;\n    ne_y = -x * sin_yaw + y * cos_yaw;\n\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 52.9687903514279}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cosf(ahrs.get_yaw_rad()) - y * sinf(ahrs.get_yaw_rad());\n    float ne_y = x * sinf(ahrs.get_yaw_rad()) + y * cosf(ahrs.get_yaw_rad());\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 64.35636596965111}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// get yaw angle\n    float yaw = ahrs.get_yaw_cd();\n    // rotate vector to NE frame\n    float cos_yaw = cosf(yaw * M_DEG_TO_RAD);\n    float sin_yaw = sinf(yaw * M_DEG_TO_RAD);\n    // rotate vector\n    float ne_x = x * cos_yaw - y * sin_yaw;\n    float ne_y = x * sin_yaw + y * cos_yaw;\n    // update x and y with new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 61.40689291564308}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMSG_LOCAL_POSITION\n}", "CodeBleu_score": 3.7009557331633305}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tn\n        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes\n        if ((sub.control_mode != Mode::Number::GUIDED)\n            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)\n            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {\n            break;\n        }\n\n        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;\n        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;\n        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;\n        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;\n\n        /*\n         * for future use:\n         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;\n         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;\n         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;\n         */\n\n        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD\n            sub.pos_control.set_pos_target_z_cm(packet.alt*100);\n            break;\n        }\n\n        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters\n\n        if (!pos_ignore) {\n            // sanity check location\n            if (!check_latlng(packet.lat_int, packet.lon_int)) {\n                break;\n            }\n            Location::AltFrame frame;\n            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {\n                // unknown coordinate frame\n                break;\n            }\n            const Location loc{\n                packet.lat_int,\n                packet.lon_int,\n                int32_t(packet.alt*100),\n                frame,\n            };\n            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {\n                break;\n            }\n        }\n\n        if (!pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (pos_ignore && !vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));\n        } else if (!pos_ignore && vel_ignore && acc_ignore) {\n            sub.mode_guided.guided_set_destination(pos_neu_cm);\n        }\n\n        break;\n    }", "CodeBleu_score": 40.42646938579492}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us     : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 99.66565231854233}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (home.is_set()) {\n\t\treturn;\n\t}\n\n\tif (status.condition_landed.landed) {\n\t\thome.set(ekf.get_position());\n\n\t} else {\n\t\t// set home to current position\n\t\thome.set(ekf.get_position());\n\t}\n\n\thome.set_alt(ekf.get_altitude());\n\thome.set_yaw(ekf.get_yaw());\n\n\thome_pub.publish(home.get());\n}", "CodeBleu_score": 24.699720858087954}, {"code": "void Sub::update_home_from_EKF(){\n\tif (home_init) return;\n\tif (status.condition_landed) return;\n\tif (status.condition_landing_gear_deployed) return;\n\tif (status.condition_armed) {\n\t\thome_init = true;\n\t\thome_set(home);\n\t\treturn;\n\t}\n\thome_init = true;\n\thome_set(ekf.get_position());\n}", "CodeBleu_score": 16.119958280243306}, {"code": "void Sub::update_home_from_EKF(){\n\t// check if we have a valid home location\n    if (home.valid()) {\n        return;\n    }\n\n    // check if we have a valid EKF location\n    if (!ekf_home_position_valid()) {\n        return;\n    }\n\n    // check if we are armed\n    if (armed) {\n        // set home to current position\n        home.set(ekf_home_position_lat(), ekf_home_position_lon(), ekf_home_position_alt());\n    } else {\n        // set home to EKF location\n        home.set(ekf_home_position_lat(), ekf_home_position_lon(), ekf_home_position_alt());\n    }\n\n}", "CodeBleu_score": 30.55127132272122}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t// if not armed, set throttle to zero and exit\n    if (!sub.get_armed()) {\n        sub.set_throttle_control(0);\n        sub.set_motor_spool_state(MOTOR_SPOOL_STATE_UNLIMITED_THROTTLE);\n        sub.relax_attitude_control();\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    sub.set_motor_spool_state(MOTOR_SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // convert pilot inputs to desired body rates\n    float roll_rate = sub.get_pilot_roll_input();\n    float pitch_rate = sub.get_pilot_pitch_input();\n    float yaw_rate = sub.get_pilot_yaw_input();\n\n    // convert pilot inputs to desired body rates\n    float roll_rate = sub.get_pilot_roll_input();\n    float pitch_rate = sub.get_pilot_pitch_input();\n    float yaw_rate = sub.get_pilot_yaw_input();\n\n    // output pilot's throttle input without angle boost\n    sub.set_throttle_control(sub.get_pilot_throttle_input());\n\n    // set forward and lateral motor inputs based on pilot controls\n    sub.set_forward_motor_input(roll_rate);\n    sub.set_lateral_motor_input(pitch_rate);\n    sub.set_vertical_motor_input(yaw_rate);\n\n    // run attitude controller with pilot inputs\n    attitude_controller.update(roll_rate, pitch_rate, yaw_rate);\n}", "CodeBleu_score": 50.81157229238986}, {"code": "void ModeAcro::run(){\n\t// if motors are not armed, set throttle to zero and return\n    if (!sub.armed()) {\n        sub.set_throttle_input(0);\n        sub.set_spool_state(SpoolState::THROTTLE_ZERO);\n        sub.relax_attitude_controller();\n        return;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 18.869658902866778}, {"code": "void ModeAcro::run(){\n\tif (!sub.armed()) {\n        sub.set_throttle_out(0, false);\n        sub.set_spool_state(SpoolState::UNLIMITED_THROTTLE);\n        sub.relax_attitude_controller();\n        return;\n    }\n\n\n    // set spool state to unlimited throttle\n    sub.set_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\n    // convert pilot inputs to desired body frame rates\n    float roll_rate = sub.get_pilot_roll_input();\n    float pitch_rate = sub.get_pilot_pitch_input();\n    float yaw_rate = sub.get_pilot_yaw_input();\n\n    // run attitude controller with these rates\n    attitude_controller.run(roll_rate, pitch_rate, yaw_rate);\n\n    // output pilot's throttle input without angle boost\n    sub.set_throttle_out(sub.get_pilot_throttle_input(), false);\n\n    // set forward and lateral motor inputs based on pilot controls\n    sub.set_motor_inputs(sub.get_pilot_roll_input(), sub.get_pilot_pitch_input(), sub.get_pilot_yaw_input());\n}", "CodeBleu_score": 43.34901345082701}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// set to position control mode\n    control_mode = MANUAL_POSITION;\n\n    // initialise waypoint controller\n    wp_nav.init_waypoint_controller();\n\n    // set default yaw mode\n    auto_yaw_mode = get_default_auto_yaw_mode(false);\n\n    // set default yaw target\n    yaw_target = nav_yaw_deg;\n\n    // set default altitude target\n    alt_target = nav_alt_m;\n\n    // set default horizontal target\n    pos_target.x = nav_pos_m.x;\n    pos_target.y = nav_pos_m.y;\n\n    // set default climb rate\n    climb_rate_target = 0.0f;\n\n    // set default speed\n    speed_target = 0.0f;\n\n    // set default speed target\n    speed_target_z = 0.0f;\n\n    // set default throttle\n    throttle_target = 0.0f;\n\n    // set default altitude mode\n    alt_mode = ALT_HOLD;\n\n    // set default horizontal mode\n    horiz_mode = HORIZ_HOLD;\n\n    // set default climb mode\n    climb_mode = CLIMB_HOLD;\n\n    // set default speed mode\n    speed_mode = SPEED_HOLD;\n\n    // set default throttle mode\n    throttle_mode = THROTTLE_HOLD;\n\n    // set default yaw mode\n    yaw_mode = YAW_HOLD;\n\n    // set default yaw rate\n    yaw_rate_target = 0.0f;\n\n    // set default yaw rate mode\n    yaw_rate_mode = YAW_RATE_HOLD;\n\n    // set default altitude mode\n    alt_mode = ALT_HOLD;\n\n    // set default horizontal mode\n    horiz_mode = HORIZ_HOLD;\n\n    // set default climb mode\n    climb_mode = CLIMB_HOLD;\n\n    // set", "CodeBleu_score": 27.652647998914855}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set to position control mode\n    guided_set_mode(GUIDED_POSITION);\n\n    // initialise waypoint controller\n    guided_wp_init();\n\n    // set auto yaw mode\n    guided_auto_yaw_set(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 14.207233677613557}, {"code": "void ModeGuided::guided_pos_control_start(){\n\tif (guided_limit.timeout_ms == 0) {\n        guided_limit.timeout_ms = GUIDED_POSVEL_TIMEOUT_MS;\n    }\n    if (guided_limit.alt_min_cm == 0) {\n        guided_limit.alt_min_cm = -100000;\n    }\n    if (guided_limit.alt_max_cm == 0) {\n        guided_limit.alt_max_cm = 100000;\n    }\n    if (guided_limit.horiz_max_cm == 0) {\n        guided_limit.horiz_max_cm = 100000;\n    }\n    guided_limit.start_time = 0;\n    guided_limit.start_pos.zero();\n    guided_limit.update_time_ms = 0;\n    guided_limit.climb_rate_cms = 0.0f;\n    guided_angle_state.update_time_ms = 0;\n    guided_angle_state.roll_cd = 0.0f;\n    guided_angle_state.pitch_cd = 0.0f;\n    guided_angle_state.yaw_cd = 0.0f;\n    guided_angle_state.climb_rate_cms = 0.0f;\n    posvel_pos_target_cm = sub.get_position();\n    posvel_vel_target_cms.zero();\n    if (sub.get_position_valid()) {\n        posvel_pos_target_cm.z = sub.get_home_position().z;\n    }\n    guided_wp_controller.init(posvel_pos_target_cm, posvel_vel_target_cms, guided_limit.timeout_ms, guided_limit.horiz_max_cm);\n    guided_wp_controller.set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n    guided_wp_controller.set_target_altitude(posvel_pos_target", "CodeBleu_score": 43.83737565079365}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical maximum speeds and acceleration using pilot-defined parameters\n    sub.velocity_horiz_max_cm = g.velocity_horiz_max_cm;\n    sub.velocity_vert_max_cm = g.velocity_vert_max_cm;\n    sub.acceleration_horiz_max_cm_s2 = g.acceleration_horiz_max_cm_s2;\n    sub.acceleration_vert_max_cm_s2 = g.acceleration_vert_max_cm_s2;\n\n    // initialise vertical and horizontal velocity controllers\n    sub.velocity_controller_init();\n\n    // initialise yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 47.419424803156495}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialise vertical maximum speeds and acceleration using pilot-defined parameters\n    sub.guided_vel_max_up_cm = g.vel_max_up_cm;\n    sub.guided_vel_max_down_cm = g.vel_max_down_cm;\n    sub.guided_vel_accel_up_cms = g.vel_accel_up_cms;\n    sub.guided_vel_accel_down_cms = g.vel_accel_down_cms;\n\n    // initialise vertical and horizontal velocity controllers\n    sub.guided_vel_control_init();\n\n    // set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 46.54489422475102}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set to velocity control mode\n    sub.guided_mode = Guided_Vel;\n\n    // initialize vertical maximum speeds and acceleration using pilot-defined parameters\n    sub.guided_vel.vz_max = (float)g.velocity_z_max;\n    sub.guided_vel.vz_cruise = (float)g.velocity_z_cruise;\n    sub.guided_vel.vz_max_up = (float)g.velocity_z_max_up;\n    sub.guided_vel.vz_max_down = (float)g.velocity_z_max_down;\n    sub.guided_vel.vz_accel_up = (float)g.acceleration_z_max_up;\n    sub.guided_vel.vz_accel_down = (float)g.acceleration_z_max_down;\n\n    // initialize horizontal maximum speeds and acceleration using pilot-defined parameters\n    sub.guided_vel.vxy_max = (float)g.velocity_xy_max;\n    sub.guided_vel.vxy_cruise = (float)g.velocity_xy_cruise;\n    sub.guided_vel.vxy_max_forward = (float)g.velocity_xy_max_forward;\n    sub.guided_vel.vxy_max_backward = (float)g.velocity_xy_max_backward;\n    sub.guided_vel.vxy_max_left = (float)g.velocity_xy_max_left;\n    sub.guided_vel.vxy_max_right = (float)g.velocity_xy_max_right;\n    sub.guided_vel.vxy_accel_forward = (float)g.acceleration_xy_max_forward;\n    sub.guided_vel.vxy_accel_backward = (float)g.acceleration_xy_max_backward;\n    sub.guided_vel.vxy_accel_left = (float)g.acceleration_xy_max", "CodeBleu_score": 31.561461495921073}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}, {"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}, {"code": "bool ModeGuided::guided_limit_check(){\n\t-sub.wp_nav.get_default_speed_down(), sub.wp_nav.get_default_speed_up());\n\n    // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds\n    uint32_t tnow = AP_HAL::millis();\n    if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {\n        roll_in = 0.0f;\n        pitch_in = 0.0f;\n        climb_rate_cms = 0.0f;\n    }\n\n    // set motors to full range\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true);\n\n    // call position controller\n    position_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms);\n    position_control->update_z_controller();\n}", "CodeBleu_score": 27.41870375806834}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n    if (tnow > last_do_motor_test_ms + 500) {\n        // check if we have received a request within the last 2 Hz\n        if (tnow > last_do_motor_test_ms + 500) {\n            // we have not received a request within the last 2 Hz, so fail the test\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test failed. Request a new motor test.\");\n            pass_motor_test = false;\n            ap.motor_test = false;\n            motors.set_armed(false);\n            last_do_motor_test_fail_ms = tnow;\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 62.85621172224596}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = hal.scheduler->millis();\n    if (tnow - last_do_motor_test_ms > 500) {\n        gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n        ap.motor_test = false;\n        motors.set_interlock(false);\n        motors.armed(false);\n        last_do_motor_test_fail_ms = tnow;\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 55.615740842616404}, {"code": "bool Sub::verify_motor_test(){\n\tuint32_t tnow = AP_HAL::millis();\n    if (tnow - last_do_motor_test_ms > 500) {\n        if (tnow - last_do_motor_test_ms > 1000) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout. 1 second cooldown required before motor test.\");\n            last_do_motor_test_fail_ms = tnow;\n            ap.motor_test = false;\n            motors.set_interlock(false);\n            motors.armed(false);\n            return false;\n        }\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout. 2 Hz minimum motor test requests required.\");\n        last_do_motor_test_fail_ms = tnow;\n        ap.motor_test = false;\n        motors.set_interlock(false);\n        motors.armed(false);\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 54.16909492815496}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get roll and pitch targets\n    float roll_target = wp_nav.get_roll_target();\n    float pitch_target = wp_nav.get_pitch_target();\n\n    // constrain roll and pitch targets to max angle\n    roll_target = constrain_float(roll_target, -wp_nav.get_max_roll_cd(), wp_nav.get_max_roll_cd());\n    pitch_target = constrain_float(pitch_target, -wp_nav.get_max_pitch_cd(), wp_nav.get_max_pitch_cd());\n\n    // normalize roll and pitch targets\n    float roll_norm = constrain_float(roll_target / wp_nav.get_max_roll_cd(), -1.0f, 1.0f);\n    float pitch_norm = constrain_float(pitch_target / wp_nav.get_max_pitch_cd(), -1.0f, 1.0f);\n\n    // assign normalized roll and pitch targets to lateral and forward outputs\n    lateral_out = roll_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 40.30786744165991}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get roll and pitch targets\n    float roll_cd = wp_nav.get_roll_cd();\n    float pitch_cd = wp_nav.get_pitch_cd();\n\n    // constrain roll and pitch targets within a specified maximum angle range\n    float max_angle_cd = 1000.0f;\n    roll_cd = constrain_float(roll_cd, -max_angle_cd, max_angle_cd);\n    pitch_cd = constrain_float(pitch_cd, -max_angle_cd, max_angle_cd);\n\n    // normalize roll and pitch targets\n    float roll_norm = constrain_float(roll_cd / max_angle_cd, -1.0f, 1.0f);\n    float pitch_norm = constrain_float(pitch_cd / max_angle_cd, -1.0f, 1.0f);\n\n    // assign normalized roll and pitch targets to lateral_out and forward_out\n    lateral_out = roll_norm;\n    forward_out = pitch_norm;\n}", "CodeBleu_score": 44.186488842205684}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// get roll and pitch targets from wp_nav\n    float wp_roll_cd = wp_nav.get_roll_cd();\n    float wp_pitch_cd = wp_nav.get_pitch_cd();\n\n    // constrain roll and pitch targets to a maximum angle range\n    wp_roll_cd = constrain_float(wp_roll_cd, -wp_nav_max_cd, wp_nav_max_cd);\n    wp_pitch_cd = constrain_float(wp_pitch_cd, -wp_nav_max_cd, wp_nav_max_cd);\n\n    // normalize roll and pitch targets to a range of -1 to 1\n    float wp_roll_norm = wp_roll_cd / wp_nav_max_cd;\n    float wp_pitch_norm = wp_pitch_cd / wp_nav_max_cd;\n\n    // assign normalized roll and pitch targets to lateral_out and forward_out\n    lateral_out = wp_roll_norm;\n    forward_out = wp_pitch_norm;\n}", "CodeBleu_score": 46.38853496929754}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t// If the barometer is present, update its data and calibration.\n\tif (barometer.is_present()) {\n\t\tbarometer.update();\n\t\tif (barometer.get_altitude() > 0) {\n\t\t\tbarometer_calibration = barometer.get_altitude();\n\t\t}\n\t}\n\t// If a depth sensor is present, update its health status based on the barometer's health.\n\tif (depth_sensor.is_present()) {\n\t\tdepth_sensor.update_health(barometer.get_health());\n\t}\n}", "CodeBleu_score": 57.60238108066081}, {"code": "void Sub::read_barometer(){\n\tif (barometer.healthy()) {\n        barometer.update();\n        if (barometer.altitude() > 0) {\n            barometer_calibration = barometer.altitude();\n        }\n        if (depth_sensor != nullptr) {\n            depth_sensor->update_health(barometer.healthy());\n        }\n    }\n}", "CodeBleu_score": 58.81837723331497}, {"code": "void Sub::read_barometer(){\n\tif (barometer_sub.read()) {\n        barometer_data.altitude = barometer_sub.get_altitude();\n        barometer_data.temperature = barometer_sub.get_temperature();\n        barometer_data.pressure = barometer_sub.get_pressure();\n        barometer_data.depth_sensor_health = barometer_sub.get_depth_sensor_health();\n        if (barometer_data.altitude > 0) {\n            barometer_calibration.update_calibration(barometer_data.altitude);\n        }\n        if (depth_sensor_sub.read()) {\n            depth_sensor_data.health = depth_sensor_sub.get_health();\n        }\n    }\n}", "CodeBleu_score": 47.84675108761795}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}, {"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}, {"code": "bool Sub::ekf_position_ok(){\n\tinit();\n\n    // initialise battery monitor\n    battery.init();\n\n    barometer.init();\n\n#if AP_FEATURE_BOARD_DETECT\n    // Detection won't work until after BoardConfig.init()\n    switch (AP_BoardConfig::get_board_type()) {\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 0);\n        break;\n    case AP_BoardConfig::PX4_BOARD_PIXHAWK:\n        AP_Param::set_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    default:\n        AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n        break;\n    }\n#elif CONFIG_HAL_BOARD != HAL_BOARD_LINUX\n    AP_Param::set_default_by_name(\\\"BARO_EXT_BUS\\\", 1);\n#endif\n\n#if AP_TEMPERATURE_SENSOR_ENABLED\n    // In order to preserve Sub's previous AP_TemperatureSensor Behavior we set the Default I2C Bus Here\n    AP_Param::set_default_by_name(\\\"TEMP1_BUS\\\", barometer.external_bus());\n#endif\n\n    // setup telem slots with serial ports\n    gcs().setup_uarts();\n\n    // initialise rc channels including setting mode\n    rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM);\n    rc().init();\n\n\n    init_rc_in();               // sets up rc channels from radio\n    init_rc_out();              // sets up motors and output to escs\n    init_joystick();            // joystick initialization\n\n#if AP_RELAY_ENABLED\n    relay.init();\n#endif\n\n    /*\n     *  setup the 'main loop is dead' check. Note that this relies on\n     *  the RC library being initialised.\n     */\n    hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000);\n\n    // Do GPS init\n    gps.set_log_gps_bit(MASK_LOG_GPS);\n    gps.init();\n\n    AP::compass().set_log_bit(MASK_LOG_COMPASS);\n    AP::compass().init();\n\n#if AP_AIRSPEED_ENABLED\n    airspeed.set_log_bit(MASK_LOG_IMU);\n#endif\n\n#if AP_OPTICALFLOW_ENABLED\n    // initialise optical flow sensor\n    optflow.init(MASK_LOG_OPTFLOW);\n#endif\n\n#if HAL_MOUNT_ENABLED\n    // initialise camera mount\n    camera_mount.init();\n    // This step is necessary so that the servo is properly initialized\n    camera_mount.set_angle_target(0, 0, 0, false);\n    // for some reason the call to set_angle_targets changes the mode to mavlink targeting!\n    camera_mount.set_mode(MAV_MOUNT_MODE_RC_TARGETING);\n#endif\n\n#if AP_CAMERA_ENABLED\n    // initialise camera\n    camera.init();\n#endif\n\n#ifdef USERHOOK_INIT\n    USERHOOK_INIT\n#endif\n\n    // Init baro and determine if we have external (depth) pressure sensor\n    barometer.set_log_baro_bit(MASK_LOG_IMU);\n    barometer.calibrate(false);\n    barometer.update();\n\n    for (uint8_t i = 0; i < barometer.num_instances(); i++) {\n        if (barometer.get_type(i) == AP_Baro::BARO_TYPE_WATER) {\n            barometer.set_primary_baro(i);\n            depth_sensor_idx = i;\n            ap.depth_sensor_present = true;\n            sensor_health.depth = barometer.healthy(depth_sensor_idx); // initialize health flag\n            break; // Go with the first one we find\n        }\n    }\n\n    if (!ap.depth_sensor_present) {\n        // We only have onboard baro\n        // No external underwater depth sensor detected\n        barometer.set_primary_baro(0);\n        ahrs.set_alt_measurement_noise(10.0f);  // Readings won't correspond with rest of INS\n    } else {\n        ahrs.set_alt_measurement_noise(0.1f);\n    }\n\n    leak_detector.init();\n\n    last_pilot_heading = ahrs.yaw_sensor;\n\n    // initialise rangefinder\n#if AP_RANGEFINDER_ENABLED\n    init_rangefinder();\n#endif\n\n    // initialise AP_RPM library\n#if AP_RPM_ENABLED\n    rpm_sensor.init();\n#endif\n\n    // initialise mission library\n    mission.init();\n\n    // initialise AP_Logger library\n#if HAL_LOGGING_ENABLED\n    logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&sub, &Sub::Log_Write_Vehicle_Startup_Messages, void));\n#endif\n\n    startup_INS_ground();\n\n    // enable CPU failsafe\n    mainloop_failsafe_enable();\n\n    ins.set_log_raw_bit(MASK_LOG_IMU_RAW);\n\n    // flag that initialisation has completed\n    ap.initialised = true;\n}", "CodeBleu_score": 38.99580738070462}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we're not in a position or velocity control mode, return true\n    if (!rover.control_mode.is_position_control() && !rover.control_mode.is_velocity_control()) {\n        return true;\n    }\n\n    // call parent class's gps_checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS is ready\n    if (!rover.ahrs.get_initialised()) {\n        check_failed(ARMING_CHECK_AHRS, display_failure, \"AHRS not ready\");\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (rover.ekf.failsafe_status() == EKF_FAILSAFE_ENABLED) {\n        check_failed(ARMING_CHECK_EKF, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!rover.ekf.local_position_is_valid()) {\n        check_failed(ARMING_CHECK_EKF, display_failure, \"EKF position estimate invalid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 59.78316361848518}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!check_enabled(ARMING_CHECK_GPS)) {\n        return true;\n    }\n\n    // check if AHRS system is ready\n    if (!rover.ahrs.get_initialised()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not initialised\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (rover.ekf.failsafe()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!rover.ekf.local_position_is_valid()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF position estimate invalid\");\n        return false;\n    }\n\n    return AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 51.47210474027592}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if we don't need position or velocity, return true\n    if (rover.control_mode == ROVER_CONTROL_MANUAL) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS is ready\n    if (!rover.ahrs.is_ready()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"AHRS not ready\");\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (rover.ekf.failsafe()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF failsafe\");\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!rover.ekf.position_valid()) {\n        check_failed(ARMING_CHECK_GPS, display_failure, \"EKF position not valid\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 59.04977860897249}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (armed) {\n        // if we are already armed then skip the checks\n        return true;\n    }\n    // are arming checks disabled?\n    if (checks_to_perform == 0) {\n        return mandatory_checks(true) && motor_checks(true) && parameter_checks(true) && mode_checks(true);\n    }\n    // check for arming conditions\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n    // record the home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.record_home_heading();\n    }\n    // update the soft armed status\n    update_soft_armed();\n    // send an arm/disarm status text\n    send_arm_status_text();\n    return true;\n}", "CodeBleu_score": 59.553962594322286}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// If we are already armed then skip the checks\n    if (armed) {\n        return true;\n    }\n\n    // are arming checks disabled?\n    if (checks_to_perform == 0) {\n        return mandatory_checks(false);\n    }\n\n    // call parent arm\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // set the home location\n    if (rover.control_mode->requires_position()) {\n        rover.set_home_to_current_location();\n    }\n\n    // initialize simple mode heading\n    if (rover.control_mode->requires_simple_mode()) {\n        rover.simple_mode_heading = rover.ahrs.yaw;\n    }\n\n    // record home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.set_home_heading(rover.ahrs.yaw);\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    hal.util->send_text_P(PSTR(\"Armed\"));\n\n    return true;\n}", "CodeBleu_score": 59.78374365267361}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks && !pre_arm_checks(true)) {\n        return false;\n    }\n\n    // check if we are already armed\n    if (armed) {\n        return true;\n    }\n\n    // set arming state to armed\n    armed = true;\n\n    // set the home location\n    if (method == AP_Arming::ARMING_METHOD_SMART_RTL) {\n        rover.set_home(rover.get_position());\n    }\n\n    // set the simple mode heading\n    if (rover.control_mode->requires_heading()) {\n        rover.simple_mode_heading = rover.get_heading();\n    }\n\n    // record the home heading for sail vehicles\n    if (rover.g2.sailboat.sail_enabled()) {\n        rover.g2.sailboat.home_heading = rover.get_heading();\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_status_text(true);\n\n    // arm motors\n    rover.armed = true;\n\n    // clear arming failed event\n    clear_arming_failed_event();\n\n    return true;\n}", "CodeBleu_score": 53.76292667894067}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}, {"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}, {"code": "void updateChargingEnabled(){\n\t_sound.setvolume(100);\n        my_sound.playSoundAdHoc(1);\n        p.neoPixelSetValue(0, 255, 255, 0, true);\n    }", "CodeBleu_score": 1.1308643228129316}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}, {"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}, {"code": "void sendMessage(void *message, size_t size){\n\t               digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            }", "CodeBleu_score": 6.059679407904604}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t// Initialize the serial communication for the sound module and clear any existing data in the buffer.\n    soundSerial.begin(9600);\n    soundSerial.clear();\n\n    // Initialize the sound module and retrieve the number of sound files available on the SD card.\n    myMP3.begin(soundSerial);\n    anzSoundfiles = myMP3.readFileCounts();\n\n    // Return true if there are one or more sound files available, indicating successful initialization.\n    return (anzSoundfiles > 0);\n}", "CodeBleu_score": 46.458452980394924}, {"code": "bool MP3Sound::begin(){\n\tsoundSerial.begin(9600);\n    soundSerial.clear();\n\n    if (myMP3.begin(soundSerial) == false) {\n        Serial.println(\"Error initializing DFPlayer!\");\n        return false;\n    }\n\n    myMP3.volume(10);\n    myMP3.setTimeOut(500);\n    myMP3.reset();\n    myMP3.setEQ(DFPLAYER_EQ_NORMAL);\n\n    //myMP3.setVolume(10);\n    //myMP3.setVolume(20);\n    //myMP3.setVolume(30);\n    //myMP3.setVolume(40);\n    //myMP3.setVolume(50);\n    //myMP3.setVolume(60);\n    //myMP3.setVolume(70);\n    //myMP3.setVolume(80);\n    //myMP3.setVolume(90);\n    //myMP3.setVolume(100);\n\n    myMP3.play(1);\n    myMP3.pause();\n\n    if (myMP3.available()) {\n        myMP3.readType();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();\n        myMP3.read();", "CodeBleu_score": 40.54050930441471}, {"code": "bool MP3Sound::begin(){\n\t// initialize serial communication with sound module\n    soundSerial.begin(9600);\n    soundSerial.flush();\n\n    // initialize sound module\n    myMP3.begin(soundSerial);\n    myMP3.setVolume(10);\n    myMP3.setTimeOut(500);\n\n    // retrieve number of sound files available\n    anzSoundfiles = myMP3.getFilesNum();\n\n    // return true if there are one or more sound files available\n    return (anzSoundfiles > 0);\n}", "CodeBleu_score": 49.966518328323026}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif(active_sounds.size() == 0) return 0;\n    if(myMP3.isPlaying()) return active_sounds.size();\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    return active_sounds.size();\n}", "CodeBleu_score": 55.752267473962334}, {"code": "int MP3Sound::processSounds(){\n\tif ((active_sounds.size() == 0) || myMP3.isPlaying()) return active_sounds.size();\n  int soundNr = active_sounds.back();\n  active_sounds.pop_back();\n  myMP3.play(soundNr);\n  return active_sounds.size();\n}", "CodeBleu_score": 52.92123596851512}, {"code": "int MP3Sound::processSounds(){\n\tif (active_sounds.size() == 0) return 0;\n    if (myMP3.available()) return active_sounds.size();\n    int soundNr = active_sounds.back();\n    active_sounds.pop_back();\n    myMP3.play(soundNr);\n    return active_sounds.size();\n}", "CodeBleu_score": 55.47159928468567}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      // cleanup any existing memory-mapped file\n      if (c->image->memory_mapped_file)\n        image_cleanup(c->image);\n      // set up a new memory-mapped file\n      image_setup_memory_mapped_file(c->image, r);\n      break;\n    default:\n      command_handled = false;\n      break;\n  }\n  return command_handled;\n}", "CodeBleu_score": 80.9921543436175}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      wb_abstract_camera_cleanup(d);\n      unsigned int id = request_read_uint32(r);\n      int w = request_read_uint16(r);\n      int h = request_read_uint16(r);\n      double fov = request_read_double(r);\n      double camnear = request_read_double(r);\n      bool planar = request_read_uchar(r);\n      wb_abstract_camera_new(d, id, w, h, fov, camnear, planar);\n      return true;\n    }\n    default:\n      d->command_handled = false;\n      return false;\n  }\n}", "CodeBleu_score": 52.24453486735536}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      image_cleanup(c->image);\n      c->image = image_new();\n      image_set_memory_mapped_file(c->image, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 59.888450922698475}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.40953841609917}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.40953841609917}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint height = -1;\n  robot_mutex_lock();\n  AbstractCamera *ac = d->pdata;\n  if (ac)\n    height = ac->height;\n  robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 71.40953841609917}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  robot_mutex_lock();\n  const Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    sampling_period = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 77.23671577445985}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint result = 0;\n  robot_mutex_lock();\n  const Accelerometer *dev = accelerometer_get_struct(tag);\n  if (dev)\n    result = dev->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 59.91061486520122}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint result = 0;\n  robot_mutex_lock();\n  const Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    result = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 66.79311076923591}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *c_str = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(c_str);\n  free(c_str);\n  return result;\n}", "CodeBleu_score": 39.804853170448325}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = dms;\n  free(dms);\n  return result;\n}", "CodeBleu_score": 42.83744263926962}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *cString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(cString);\n  free(cString);\n  return result;\n}", "CodeBleu_score": 41.21792058925187}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\n  dxBox *box = (dxBox*) g;\n  dVector3 relPos;\n  dSubtractVectors3 (relPos, box->final_posr->pos, box->final_posr->R->v[0], x, y, z);\n\n  dVector3 normal;\n  dReal dist = 0.0;\n\n  if (fabs (relPos[0]) < box->side[0]) {\n    dSetZero (normal, 4);\n    normal[0] = -relPos[0] / box->side[0];\n    dist = fabs (normal[0]) * box->side[0];\n  }\n  else if (fabs (relPos[1]) < box->side[1]) {\n    dSetZero (normal, 4);\n    normal[1] = -relPos[1] / box->side[1];\n    dist = fabs (normal[1]) * box->side[1];\n  }\n  else if (fabs (relPos[2]) < box->side[2]) {\n    dSetZero (normal, 4);\n    normal[2] = -relPos[2] / box->side[2];\n    dist = fabs (normal[2]) * box->side[2];\n  }\n  else {\n    dSetZero (normal, 4);\n    dist = 0.0;\n  }\n\n  dSetZero (plane, 4);\n  plane[0] = normal[0];\n  plane[1] = normal[1];\n  plane[2] = normal[2];\n  plane[3] = dist;\n}", "CodeBleu_score": 37.11779799779272}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n    const dReal *const s = ((dxBox*) g)->side;\n    const dReal *const R = ((dxBox*) g)->R;\n    const dReal *const T = ((dxBox*) g)->T;\n    const dReal *const pos = ((dxBox*) g)->final_posr->pos;\n    const dReal *const R_abs = ((dxBox*) g)->final_posr->R;\n    const dReal *const T_abs = ((dxBox*) g)->final_posr->R;\n    const dReal *const side = ((dxBox*) g)->side;\n    const dReal *const rot = ((dxBox*) g)->rot;\n    const dReal *const pos_abs = ((dxBox*) g)->final_posr->pos;\n\n    // compute relative position of point to box center\n    const dReal dx = x - pos_abs[0];\n    const dReal dy = y - pos_abs[1];\n    const dReal dz = z - pos_abs[2];\n\n    // check each axis for proximity to box surface\n    dVector4 normal;\n    dReal dist;\n    if (dx < -side[0]) {\n        normal[0] = -1;\n        normal[1] = 0;\n        normal[2] = 0;\n        normal[3] = 0;\n        dist = dx + side[0];\n    } else if (dx > side[0]) {\n        normal[0] = 1;\n        normal[1] = 0;\n        normal[2] = 0;\n        normal[3] = 0;\n        dist = dx - side[0];\n    } else if (dy < -side[1]) {\n        normal[0] = 0;\n        normal[1] = -1;\n        normal[2] = 0;\n        normal[3] = 0;\n        dist = dy + side[1];\n    } else if (dy > side[1]) {\n        normal[0] = 0;\n        normal[1] = 1;\n        normal[2]", "CodeBleu_score": 42.84345970013177}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass,\"argument not a box\");\n  const dReal *const s = ((dxBox*) g)->side;\n  dVector3 p;\n  dReal dx, dy, dz;\n  dReal d;\n  dReal dist;\n  dReal min_dist = dInfinity;\n  dVectorSet(p,x,y,z);\n  dVectorSubtract(p,g->final_posr->pos,p);\n  dx = p[0];\n  dy = p[1];\n  dz = p[2];\n  d = dx;\n  if (d < 0) d = -d;\n  if (d < min_dist) {\n    dist = d;\n    min_dist = dist;\n    dVectorSet(plane,1,0,0);\n  }\n  d = dy;\n  if (d < 0) d = -d;\n  if (d < min_dist) {\n    dist = d;\n    min_dist = dist;\n    dVectorSet(plane,0,1,0);\n  }\n  d = dz;\n  if (d < 0) d = -d;\n  if (d < min_dist) {\n    dist = d;\n    min_dist = dist;\n    dVectorSet(plane,0,0,1);\n  }\n  d = dx - s[0];\n  if (d > 0) d = -d;\n  if (d < min_dist) {\n    dist = d;\n    min_dist = dist;\n    dVectorSet(plane,-1,0,0);\n  }\n  d = dy - s[1];\n  if (d > 0) d = -d;\n  if (d < min_dist) {\n    dist = d;\n    min_dist = dist;\n    dVectorSet(plane,0,-1,0);\n  }\n  d = dz - s[2];\n  if (d > 0) d = -d;\n  if (d < min_dist) {\n    dist = d;\n    min_dist = dist;\n    dVectorSet(", "CodeBleu_score": 45.15138154638396}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tswap(c[1], c[2]);\n\n    const dReal nFace = m_vN[faceIndex];\n    const dReal a[4] = { c[0]->depth / nFace, c[1]->depth / nFace, c[2]->depth / nFace, c[3]->depth / nFace };\n    const dReal hPrime = m_vSide[aIndex];\n    const dReal h = m_vSide[bIndex];\n\n    const dReal sum = a[0] + a[1] + a[2] + a[3];\n    m_gImmersion->volume = 0.25 * h * hPrime * sum;\n    const dReal sum3 = 3.0 * sum;\n    m_vBuoyancyCenter[aIndex] = c[2]->pos[aIndex] * (m_vHalfSide[aIndex] - hPrime * (sum + a[1] + a[3]) / sum3 );\n    m_vBuoyancyCenter[bIndex] = c[2]->pos[bIndex] * (m_vHalfSide[bIndex] - h * (sum + a[0] + a[1]) / sum3);\n    m_vBuoyancyCenter[faceIndex] = c[2]->pos[faceIndex] * (m_vHalfSide[faceIndex] - 2.0 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[0] * a[1] + a[2] * a[3] + a[1] * a[3]  + a[0] * a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 35.758582690713254}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t* a[2] + 0.5 *\n       (a[1] * a[2] + a[0] * a[3])) / (3.0 * sum3));\n\n    m_gImmersion->projectedAreas[faceIndex] = hPrime * h;\n    m_gImmersion->projectedAreas[aIndex] = 0.5 * h * sum;\n    m_gImmersion->projectedAreas[bIndex] = 0.5 * hPrime * sum;\n\n    // water outline\n    if (m_gImmersion->outline && (m_nFlags & ~dxImmersionOutlineDisabled)) {\n      dVector3 d[4];\n      for (int i = 0; i < 4; ++i) {\n        const dReal *const pos = c[i]->pos;\n        for (int j = 0; j < 3; ++j)\n          d[i][j] = pos[j] * m_vHalfSide[j];\n\n        d[i][faceIndex] -= a[i] * pos[faceIndex];\n      }\n\n      transformVectors3(d, 4, m_mRotation, m_vCenter); // turns to absolute coordinates\n\n      dStraightEdge se[4];\n      for (int i = 0; i < 2; ++i) {\n        dCopyVector3(se[i].origin, d[0]);\n        dCopyVector3(se[i].end, d[i + 1]);\n      }\n\n      int k = 1;\n      for (int i = 2; i < 4; ++i) {\n        dCopyVector3(se[i].origin, d[3]);\n        dCopyVector3(se[i].end, d[k]);\n        k = 2;\n      }\n\n      dImmersionOutlineID outline = m_gImmersion->outline;\n      for (int i = 0; i < 4; ++i)\n        outline->appendStraightEdge(se[i]);\n    }\n  }", "CodeBleu_score": 36.63567870897732}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tANY WARRANTY; without even the implied warranty of        *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *\n * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *\n *                                                                       *\n *************************************************************************/\n", "CodeBleu_score": 13.575585631974974}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\\\"../collision_kernel.h\\\"", "CodeBleu_score": 8.456754260487843}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tphericalCapImmersion = lowerHemisphereIsPartiallyImmersed && !lowerHemisphereIsFullyImmersed && (m_bLowerDiskIsFullyImmersed || !m_bLowerDiskIsPartiallyImmersed);\n  const bool upperSphericalCapImmersion = upperHemisphereIsPartiallyImmersed && !upperHemisphereIsFullyImmersed && (m_bUpperDiskIsFullyImmersed || !m_bUpperDiskIsPartiallyImmersed);\n\n  if (lowerHemisphereIsFullyImmersed || upperHemisphereIsFullyImmersed)\n    result += oneFullyImmersedHemisphere(lowerHemisphereIsFullyImmersed ? -1.0 : 1.0);\n\n  if (lowerSphericalCapImmersion || upperSphericalCapImmersion)\n    result += oneImmersedSphericalCap(lowerSphericalCapImmersion ? -1.0 : 1.0);\n\n  if (m_bLowerDiskIsPartiallyImmersed && !m_bLowerDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(-1.0);\n\n  if (m_bUpperDiskIsPartiallyImmersed && !m_bUpperDiskIsFullyImmersed)\n    result += onePartiallyImmersedHemisphereDisk(1.0);\n\n  return result > 0 ? 1 : 0;\n}", "CodeBleu_score": 25.493275398946647}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\tconst auto& duration = getInput<std::chrono::milliseconds>(\"duration\");\n  if (!duration)\n  {\n    return NodeStatus::SUCCESS;\n  }\n  if (duration->count() <= 0)\n  {\n    return NodeStatus::SUCCESS;\n  }\n  timer_waiting_ = true;\n  setStatus(NodeStatus::RUNNING);\n  startTimer(duration->count(), [this]() {\n    timer_waiting_ = false;\n    emitStatus(NodeStatus::SUCCESS);\n  });\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 54.23876730795295}, {"code": "NodeStatus SleepNode::onStart(){\n\tconst double duration = getInput<double>(\"duration\");\n  if (duration <= 0.0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  timer_waiting_ = true;\n  timer_ = std::make_shared<Timer>(duration);\n  timer_->onExpired([this]() {\n    timer_waiting_ = false;\n    this->setStatus(NodeStatus::SUCCESS);\n  });\n  timer_->start();\n  setStatus(NodeStatus::RUNNING);\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 48.551581544836786}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the duration from the input\n    const double duration = getInput<double>(\"duration\");\n    if (duration <= 0.0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n\n    // Start the timer\n    timer_waiting_ = true;\n    timer_ = getNode()->getTimer(duration);\n    timer_->setCallback([this]() {\n        if (timer_waiting_) {\n            timer_waiting_ = false;\n            emitWakeUpSignal();\n        }\n    });\n    timer_->start();\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 54.34753390954259}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// This function, EntryUpdatedAction::tick, checks if an entry in the blackboard has been updated.\n  // It retrieves the entry and locks its mutex.\n  // It compares the current sequence ID with the previously stored sequence ID.\n  // If the IDs differ, it updates the stored sequence ID and returns NodeStatus::SUCCESS.\n  // If the IDs are the same or the entry is not found, it returns NodeStatus::FAILURE.\n\n  // This function, EntryUpdatedAction::tick, checks if an entry in the blackboard has been updated.\n  // It retrieves the entry and locks its mutex.\n  // It compares the current sequence ID with the previously stored sequence ID.\n  // If the IDs differ, it updates the stored sequence ID and returns NodeStatus::SUCCESS.\n  // If the IDs are the same or the entry is not found, it returns NodeStatus::FAILURE.\n\n  // This function, EntryUpdatedAction::tick, checks if an entry in the blackboard has been updated.\n  // It retrieves the entry and locks its mutex.\n  // It compares the current sequence ID with the previously stored sequence ID.\n  // If the IDs differ, it updates the stored sequence ID and returns NodeStatus::SUCCESS.\n  // If the IDs are the same or the entry is not found, it returns NodeStatus::FAILURE.\n\n  // This function, EntryUpdatedAction::tick, checks if an entry in the blackboard has been updated.\n  // It retrieves the entry and locks its mutex.\n  // It compares the current sequence ID with the previously stored sequence ID.\n  // If the IDs differ, it updates the stored sequence ID and returns NodeStatus::SUCCESS.\n  // If the IDs are the same or the entry is not found, it returns NodeStatus::FAILURE.\n\n  // This function, EntryUpdatedAction::tick, checks if an entry in the blackboard has been updated.\n  // It retrieves the entry and locks its mutex.\n  // It compares the current sequence ID with the previously stored sequence ID.\n  // If the IDs differ, it updates the stored sequence ID and returns NodeStatus::SUCCESS.\n  // If the IDs are the same or the entry is not found, it returns Node", "CodeBleu_score": 3.8091016469873855}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tstd::lock_guard<std::mutex> guard(mutex_);\n  auto it = blackboard_->find(entry_key_);\n  if (it == blackboard_->end()) {\n    return NodeStatus::FAILURE;\n  }\n  const auto& entry = it->second;\n  if (entry.sequence_id == sequence_id_) {\n    return NodeStatus::FAILURE;\n  }\n  sequence_id_ = entry.sequence_id;\n  return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 50.69329922038555}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tauto& bb = getContext()->blackboard;\n  auto entry = bb.getEntry(entry_key_);\n  if (entry) {\n    std::lock_guard<std::mutex> lock(entry->mutex);\n    if (entry->sequence_id != sequence_id_) {\n      entry->sequence_id = sequence_id_;\n      return NodeStatus::SUCCESS;\n    }\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.78231631912516}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif(success_threshold_ < 0) {\n    return static_cast<size_t>(std::max(0, static_cast<int>(children_nodes_.size()) + success_threshold_));\n  }\n  return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 60.52541947699738}, {"code": "size_t ParallelNode::successThreshold() const{\n\tconst size_t children_count = children_nodes_.size();\n\n  if (success_threshold_ < 0) {\n    return std::max(static_cast<size_t>(0), children_count + success_threshold_);\n  }\n\n  return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 45.5938916040129}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\n    return static_cast<size_t>(std::max(1, children_nodes_.size() + success_threshold_));\n  }\n  return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 57.21128052570297}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t>(json[\\\"position\\\"].get<int>());\n\n          if(auto hook = getHook(pos, node_uid))\n          {\n            std::unique_lock<std::mutex> lk(hook->mutex);\n            bool was_interactive = (hook->mode == Monitor::Hook::Mode::BREAKPOINT);\n            BT::Monitor::from_json(json, *hook);\n\n            // if it WAS interactive and it is not anymore, unlock it\n            if(was_interactive && (hook->mode == Monitor::Hook::Mode::REPLACE))\n            {\n              hook->ready = true;\n              lk.unlock();\n              hook->wakeup.notify_all();\n            }\n          }\n          else  // if not found, create a new one\n          {\n            auto new_hook = std::make_shared<Monitor::Hook>();\n            BT::Monitor::from_json(json, *new_hook);\n            insertHook(new_hook);\n          }\n        }", "CodeBleu_score": 34.02864960103808}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t(json, *new_hook);\n            insertHook(new_hook);\n          }", "CodeBleu_score": 9.238592533299846}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tout.push_back(*breakpoint);\n        }", "CodeBleu_score": 5.386022400300098}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::thread(&BT::ThreadedAction::tickImpl, this);\n    return NodeStatus::RUNNING;\n  }\n\n  if(prev_status == NodeStatus::RUNNING) {\n    if(halt_requested_.load()) {\n      halt();\n      return NodeStatus::IDLE;\n    }\n    return prev_status;\n  }\n\n  return prev_status;\n}", "CodeBleu_score": 29.0444120175103}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tconst NodeStatus prev_status = status();\n    if (prev_status == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        thread_ = std::thread([this]() {\n            try {\n                tick();\n            } catch (const std::exception& ex) {\n                setStatus(NodeStatus::IDLE);\n                halt_requested_.store(true);\n                std::cerr << \"Exception in thread: \" << ex.what() << std::endl;\n            }\n        });\n    }\n    //------------------------------------------\n    if (prev_status == NodeStatus::RUNNING) {\n        NodeStatus new_status = tick();\n        if (new_status == NodeStatus::IDLE) {\n            throw LogicError(\"ThreadedAction::tick() must not return IDLE\");\n        }\n        return new_status;\n    }\n    return prev_status;\n}", "CodeBleu_score": 46.97656028784028}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tconst NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    std::thread thread(&BT::ThreadedAction::tickImpl, this);\n    thread.detach();\n    return prev_status;\n  }\n  //------------------------------------------\n  if (prev_status == NodeStatus::RUNNING) {\n    NodeStatus new_status = onRunning();\n    if (new_status == NodeStatus::IDLE) {\n      throw LogicError(\"ThreadedAction::onRunning() must not return IDLE\");\n    }\n    return new_status;\n  }\n  return prev_status;\n}", "CodeBleu_score": 32.7383426084282}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif (root_node == nullptr) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n  std::function<void(const TreeNode*)> print_node = [&stream, &print_node](const TreeNode* node) {\n    for (int i = 0; i < node->depth(); ++i) {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n    if (auto control = dynamic_cast<const ControlNode*>(node)) {\n      for (const auto& child : control->children()) {\n        print_node(static_cast<const TreeNode*>(child));\n      }\n    } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n      print_node(decorator->child());\n    }\n  };\n  stream << \"*******************************************************************************\" << std::endl;\n  print_node(root_node);\n  stream << \"*******************************************************************************\" << std::endl;\n}", "CodeBleu_score": 54.5491469440885}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tauto print_node = [&stream](const TreeNode* node) {\n        stream << std::string(node->depth(), ' ') << node->name() << std::endl;\n    };\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    applyRecursiveVisitor(root_node, print_node);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 27.003996824349453}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tauto print_node = [&](const TreeNode* node) {\n        std::string indent(node->depth() * 2, ' ');\n        stream << indent << node->name() << std::endl;\n    };\n\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    applyRecursiveVisitor(root_node, print_node);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 27.89915534094971}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: node is nullptr\");\n    }\n\n    visitor(node);\n\n    if (node->type() == NodeType::CONTROL_NODE) {\n        const ControlNode* control_node = static_cast<const ControlNode*>(node);\n        for (const TreeNode* child : control_node->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->type() == NodeType::DECORATOR_NODE) {\n        const DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child(), visitor);\n    }\n}", "CodeBleu_score": 59.652902958301205}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: nullptr node\");\n  }\n  visitor(node);\n  if (node->type() == NodeType::CONTROL_NODE) {\n    const ControlNode* cn = static_cast<const ControlNode*>(node);\n    for (auto& child : cn->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (node->type() == NodeType::DECORATOR_NODE) {\n    const DecoratorNode* dn = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(dn->child().get(), visitor);\n  }\n}", "CodeBleu_score": 60.8137686732539}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (node->type() == NodeType::CONTROL_NODE) {\n    const ControlNode* controlNode = static_cast<const ControlNode*>(node);\n    for (const TreeNode* child : controlNode->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->type() == NodeType::DECORATOR_NODE) {\n    const DecoratorNode* decoratorNode = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decoratorNode->child(), visitor);\n  }\n}", "CodeBleu_score": 60.88562607908432}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.count(manifest.registration_ID)) {\n    throw BehaviorTreeException(\n        \"You can not register a new builder with ID [\" + manifest.registration_ID +\n        \"]. The ID is already registered\");\n  }\n  _p->builders.insert(std::make_pair(manifest.registration_ID, builder));\n  _p->manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 53.108526624219806}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.count(manifest.registration_ID)) {\n    throw LogicError(\n        \"You can not register the same ID [\\\", manifest.registration_ID, \\\"] \"\n        \"twice\");\n  }\n  _p->builders.insert(std::make_pair(manifest.registration_ID, builder));\n  _p->manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 50.29742347784046}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (_p->builders.count(manifest.getRegistrationID())) {\n    throw BehaviorTreeException(\"You can not register a node builder with the same ID [\\\"\" + manifest.getRegistrationID() + \"\\\"]\");\n  }\n  _p->builders.insert(std::make_pair(manifest.getRegistrationID(), builder));\n  _p->manifests.insert(std::make_pair(manifest.getRegistrationID(), manifest));\n}", "CodeBleu_score": 48.87944638610223}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tIM, DAMAGES OR OTHER LIABILITY,", "CodeBleu_score": 10.79060886137392}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t }", "CodeBleu_score": 8.679192544743607}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto result = ParseScript(script);\n  if(result) {\n    try {\n      return result.value()(env);\n    }\n    catch(RuntimeError& err) {\n      throw RuntimeError(StrCat(\"Error in script [\", script, \"]\n\", err.what()));\n    }\n  }\n  else {\n    return nonstd::make_unexpected(result.error());\n  }\n}", "CodeBleu_score": 66.57720830307888}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = BT::ParseScript(script);\n  if (executor) {\n    return executor(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 77.10382036218897}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto func = ParseScript(script);\n  if(func) {\n    return func(env);\n  }\n  return nonstd::make_unexpected(func.error());\n}", "CodeBleu_score": 57.20347589426312}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  if (_handle) {\n    throw RuntimeError(\"A library is already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!_handle) {\n    std::string error_msg = dlerror();\n    throw RuntimeError(error_msg);\n  }\n  _path = path;\n}", "CodeBleu_score": 59.449270945744324}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(_mutex);\n  if (_handle != nullptr) {\n    throw RuntimeError(\"A library is already loaded.\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (_handle == nullptr) {\n    std::string error_msg = dlerror();\n    throw RuntimeError(error_msg);\n  }\n  _path = path;\n}", "CodeBleu_score": 58.43366440796994}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(SharedLibrary::_mutex);\n  if (_handle != nullptr) {\n    throw RuntimeError(\"A shared library is already loaded\");\n  }\n  _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (_handle == nullptr) {\n    const char* error = dlerror();\n    if (error == nullptr) {\n      error = \"Unknown error\";\n    }\n    throw RuntimeError(\"Failed to load library: \" + std::string(error));\n  }\n  _path = path;\n}", "CodeBleu_score": 61.009295567464875}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t_HALTED)];\n  if(parse_executor)\n  {\n    Ast::Environment env = { config().blackboard, config().enums };\n    parse_executor(env);\n  }\n}", "CodeBleu_score": 7.58785052025238}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//used to put things into grid coordinates\n  unsigned int cell_x, cell_y;\n\n  //get the cell coord of the center point of the robot\n  if(!costmap_.worldToMap(x0, y0, cell_x, cell_y))\n    return -3.0;\n\n  //if number of points in the footprint is less than 3, we'll just assume a circular robot\n  if(footprint_spec_.size() < 3){\n    unsigned char cost = costmap_.getCost(cell_x, cell_y);\n    if(cost == NO_INFORMATION)\n      return -2.0;\n    if(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n      return -1.0;\n    return cost;\n  }\n\n  //now we really have to lay down the footprint in the costmap grid\n  unsigned int x0_int, x1_int, y0_int, y1_int;\n  double line_cost = 0.0;\n  double footprint_cost = 0.0;\n\n  //we need to rasterize each line in the footprint\n  for(unsigned int i = 0; i < footprint_spec_.size() - 1; ++i){\n    //get the cell coord of the first point\n    if(!costmap_.worldToMap(footprint_spec_[i].x, footprint_spec_[i].y, x0_int, y0_int))\n      return -3.0;\n\n    //get the cell coord of the second point\n    if(!costmap_.worldToMap(footprint_spec_[i + 1].x, footprint_spec_[i + 1].y, x1_int, y1_int))\n      return -3.0;\n\n    line_cost = lineCost(x0_int, x1_int, y0_int, y1_int);\n    footprint_cost = std::max(line_cost, footprint_cost);\n\n    //if there is an obstacle that hits the line... we know that we can return false right away", "CodeBleu_score": 34.6037472097182}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//used to put things into grid coordinates\n    unsigned int cell_x, cell_y;\n\n    //get the cell coord of the center point of the robot\n    if(!costmap_.worldToMap(x0, y0, cell_x, cell_y))\n      return -3.0;\n\n    //if number of points in the footprint is less than 3, we'll just assume a circular robot\n    if(abs(x0 - x1) < 0.01 && abs(y0 - y1) < 0.01){\n      unsigned char cost = costmap_.getCost(cell_x, cell_y);\n      if(cost == NO_INFORMATION)\n        return -2.0;\n      if(cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE)\n        return -1.0;\n      return cost;\n    }\n\n    //now we really have to lay down the footprint in the costmap grid\n    unsigned int x0_temp, x1_temp, y0_temp, y1_temp;\n    double line_cost = 0.0;\n    double footprint_cost = 0.0;\n\n    //we need to rasterize each line in the footprint\n    for(unsigned int i = 0; i < footprint.size() - 1; ++i){\n      //get the cell coord of the first point\n      if(!costmap_.worldToMap(footprint[i].x, footprint[i].y, x0_temp, y0_temp))\n        return -3.0;\n\n      //get the cell coord of the second point\n      if(!costmap_.worldToMap(footprint[i + 1].x, footprint[i + 1].y, x1_temp, y1_temp))\n        return -3.0;\n\n      line_cost = lineCost(x0_temp, x1_temp, y0_temp, y1_temp);\n      footprint_cost = std::max(line_cost, footprint_cost);\n\n      //if there is an obstacle that hits the line... we know that we", "CodeBleu_score": 35.964810363682574}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//used to put things into grid coordinates\n  unsigned int cell_x, cell_y;\n\n  //get the cell coord of the center point of the robot\n  if(!costmap_.worldToMap(x0, y0, cell_x, cell_y))\n    return -3.0;\n\n  //get the cell coord of the second point\n  if(!costmap_.worldToMap(x1, y1, cell_x, cell_y))\n    return -3.0;\n\n  //used to store the cost of each point in the line\n  double point_cost;\n\n  //used to store the total cost of the line\n  double line_cost = 0.0;\n\n  //used to store the current point in the line\n  int x, y;\n\n  //used to store the current angle of the line\n  double angle;\n\n  //used to store the current distance along the line\n  double distance;\n\n  //used to store the current distance along the line\n  double distance_remaining;\n\n  //used to store the current distance along the line\n  double distance_to_travel;\n\n  //used to store the current distance along the line\n  double distance_to_next_point;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_remaining;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_travel;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_remaining_travel;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_remaining_travel_squared;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_remaining_travel_squared_squared;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_remaining_travel_squared_squared_squared;\n\n  //used to store the current distance along the line\n  double distance_to_next_point_remaining_travel_squared_squared", "CodeBleu_score": 25.626069424646523}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header = path.front().header;\n  gui_path.header.frame_id = \"map\";\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 68.8393469544612}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    ROS_WARN(\"Path is empty, not publishing\");\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header = path.front().header;\n  gui_path.header.frame_id = \"map\";\n  gui_path.poses = path;\n  pub.publish(gui_path);\n}", "CodeBleu_score": 42.284851732605695}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())\n    return;\n  nav_msgs::Path gui_path;\n  gui_path.header = path.front().header;\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); i++)\n    gui_path.poses[i] = path[i].pose;\n  pub.publish(gui_path);\n}", "CodeBleu_score": 60.69676040959452}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t     const geometry_msgs::PoseStamped& global_pose,\n      const costmap_2d::Costmap2D& costmap,\n      const std::string& global_frame,\n      std::vector<geometry_msgs::PoseStamped>& transformed_plan){\n    transformed_plan.clear();\n\n    if (global_plan.empty()) {\n      ROS_ERROR(\\\"Received plan with zero length\\\");\n      return false;\n    }\n\n    const geometry_msgs::PoseStamped& plan_pose = global_plan[0];\n    try {\n      // get plan_to_global_transform from plan frame to global_frame\n      geometry_msgs::TransformStamped plan_to_global_transform = tf.lookupTransform(global_frame, ros::Time(),\n          plan_pose.header.frame_id, plan_pose.header.stamp, plan_pose.header.frame_id, ros::Duration(0.5));\n\n      //let's get the pose of the robot in the frame of the plan\n      geometry_msgs::PoseStamped robot_pose;\n      tf.transform(global_pose, robot_pose, plan_pose.header.frame_id);\n\n      //we'll discard points on the plan that are outside the local costmap\n      double dist_threshold = std::max(costmap.getSizeInCellsX() * costmap.getResolution() / 2.0,\n                                       costmap.getSizeInCellsY() * costmap.getResolution() / 2.0);\n\n      unsigned int i = 0;\n      double sq_dist_threshold = dist_threshold * dist_threshold;\n      double sq_dist = 0;\n\n      //we need to loop to a point on the plan that is within a certain distance of the robot\n      while(i < (unsigned int)global_plan.size()) {\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n        if (sq_dist <= sq_dist_threshold) {\n          break;\n        }\n        ++i;\n      }\n\n      geometry_msgs::PoseStamped newer_pose;\n\n      //now we'll transform until points are outside of our distance threshold\n      while(i < (unsigned int)global_plan.size() && sq_dist <= sq_dist_threshold) {\n        const geometry_msgs::PoseStamped& pose = global_plan[i];\n        tf2::doTransform(pose, newer_pose, plan_to_global_transform);\n\n        transformed_plan.push_back(newer_pose);\n\n        double x_diff = robot_pose.pose.position.x - global_plan[i].pose.position.x;\n        double y_diff = robot_pose.pose.position.y - global_plan[i].pose.position.y;\n        sq_dist = x_diff * x_diff + y_diff * y_diff;\n\n        ++i;\n      }\n    }\n    catch(tf2::LookupException& ex) {\n      ROS_ERROR(\\\"No Transform available Error: %s", "CodeBleu_score": 35.79358784350667}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t// If we haven't set up the limits yet, initialize them with the provided values\n  if(!initialized_) {\n    if(restore_defaults) {\n      config.min_turning_radius = 0.5;\n      config.max_turning_radius = 100.0;\n      config.min_linear_velocity = 0.0;\n      config.max_linear_velocity = 1.0;\n      config.min_angular_velocity = 0.0;\n      config.max_angular_velocity = 1.0;\n      config.min_translation_increment = 0.01;\n      config.max_translation_increment = 0.5;\n      config.min_rotation_increment = 0.01;\n      config.max_rotation_increment = 0.5;\n      config.min_translation_scaling = 0.0;\n      config.max_translation_scaling = 1.0;\n      config.min_rotation_scaling = 0.0;\n      config.max_rotation_scaling = 1.0;\n      config.min_velocity_scaling = 0.0;\n      config.max_velocity_scaling = 1.0;\n      config.min_angular_scaling = 0.0;\n      config.max_angular_scaling = 1.0;\n      config.min_linear_scaling = 0.0;\n      config.max_linear_scaling = 1.0;\n      config.min_translation_increment_scaling = 0.0;\n      config.max_translation_increment_scaling = 1.0;\n      config.min_rotation_increment_scaling = 0.0;\n      config.max_rotation_increment_scaling = 1.0;\n      config.min_angular_velocity_scaling = 0.0;\n      config.max_angular_velocity_scaling = 1.0;\n      config.min_linear_velocity_scaling = 0.0;\n      config.max_linear_velocity_", "CodeBleu_score": 22.223771820569628}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif(!initialized_) {\n    if(restore_defaults) {\n      // Initialize the default limits with the provided configuration\n      default_limits_.min_turning_radius = config.min_turning_radius;\n      default_limits_.max_vel_x = config.max_vel_x;\n      default_limits_.max_vel_y = config.max_vel_y;\n      default_limits_.max_vel_theta = config.max_vel_theta;\n      default_limits_.max_vel_x_backwards = config.max_vel_x_backwards;\n      default_limits_.max_vel_y_backwards = config.max_vel_y_backwards;\n      default_limits_.max_vel_theta_backwards = config.max_vel_theta_backwards;\n      default_limits_.max_vel_x_stopped = config.max_vel_x_stopped;\n      default_limits_.max_vel_y_stopped = config.max_vel_y_stopped;\n      default_limits_.max_vel_theta_stopped = config.max_vel_theta_stopped;\n      default_limits_.min_vel_x = config.min_vel_x;\n      default_limits_.min_vel_y = config.min_vel_y;\n      default_limits_.min_vel_theta = config.min_vel_theta;\n      default_limits_.min_vel_x_backwards = config.min_vel_x_backwards;\n      default_limits_.min_vel_y_backwards = config.min_vel_y_backwards;\n      default_limits_.min_vel_theta_backwards = config.min_vel_theta_backwards;\n      default_limits_.min_vel_x_stopped = config.min_vel_x_stopped;\n      default_limits_.min_vel_y_stopped = config.min_vel_y_stopped;\n      default_limits_.min_vel_theta_stopped = config.min_vel_theta_stopped;\n      default_limits_.max_vel_x_for_steering = config.max_vel_x_for_steering", "CodeBleu_score": 29.35921924020587}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (!initialized_) {\n    if (restore_defaults) {\n      ROS_WARN(\"Local Planner Utils not initialized, cannot restore default limits.\");\n      return;\n    }\n    initializeLimits(config);\n    initialized_ = true;\n  }\n\n  if (restore_defaults) {\n    initializeLimits(config);\n  } else {\n    updateLimits(config);\n  }\n\n  limits_mutex_.lock();\n  current_limits_ = limits_;\n  limits_mutex_.unlock();\n}", "CodeBleu_score": 46.68625553479019}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tif (check_cell->isObstacle()) {\n      //if the cell is an obstacle, set the target distance to the maximum obstacle cost\n      check_cell->target_distance = std::numeric_limits<unsigned int>::max();\n      return false;\n    }\n    else {\n      //if the cell is not an obstacle, update the target distance\n      unsigned int new_distance = current_cell->target_distance + 1;\n      if (new_distance < check_cell->target_distance) {\n        check_cell->target_distance = new_distance;\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n  }", "CodeBleu_score": 38.99261777138619}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tif (costmap.isCostmapFresh() == false) {\n    ROS_WARN(\"Costmap is not fresh, cannot update path cell.\");\n    return false;\n  }\n\n  //check the cost of the cell\n  if (costmap.getCost(check_cell->cx, check_cell->cy) == costmap_2d::NO_INFORMATION) {\n    //no information, set to max cost\n    check_cell->td = costmap_2d::NO_INFORMATION;\n    return false;\n  }\n  else if (costmap.getCost(check_cell->cx, check_cell->cy) == costmap_2d::LETHAL_OBSTACLE) {\n    //obstacle, set to max cost\n    check_cell->td = costmap_2d::LETHAL_OBSTACLE;\n    return false;\n  }\n\n  //calculate the new target distance\n  double new_td = sqrt(pow(check_cell->cx - current_cell->cx, 2) + pow(check_cell->cy - current_cell->cy, 2));\n\n  //update the target distance if it is shorter\n  if (new_td < check_cell->td) {\n    check_cell->td = new_td;\n    return true;\n  }\n\n  //if not shorter, return false\n  return false;\n}", "CodeBleu_score": 51.62666854428968}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned int index = check_cell->index;\n  unsigned int cx = check_cell->cx;\n  unsigned int cy = check_cell->cy;\n  unsigned int cost = costmap.getCost(cx, cy);\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE || costmap.getCost(cx, cy) == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = std::numeric_limits<unsigned int>::max();\n    return false;\n  }\n  unsigned int new_target_distance = current_cell->target_distance + (check_cell->cx - current_cell->cx) + (check_cell->cy - current_cell->cy);\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n  }\n  return true;\n}", "CodeBleu_score": 56.40767929024907}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t// TODO: move this to prepare if possible\n  double max_trans_vel = max_trans_vel_;\n  double max_scaling_factor = max_scaling_factor_;\n  double scaling_speed = scaling_speed_;\n  if (costmap_ == NULL) {\n    ROS_ERROR(\"ObstacleCostFunction: costmap not initialized\");\n    return -9;\n  }\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction: footprint not initialized\");\n    return -9;\n  }\n  if (max_trans_vel <= 0) {\n    ROS_ERROR(\"ObstacleCostFunction: max_trans_vel <= 0\");\n    return -9;\n  }\n  if (max_scaling_factor <= 0) {\n    ROS_ERROR(\"ObstacleCostFunction: max_scaling_factor <= 0\");\n    return -9;\n  }\n  if (scaling_speed <= 0) {\n    ROS_ERROR(\"ObstacleCostFunction: scaling_speed <= 0\");\n    return -9;\n  }\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (traj.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction: trajectory is empty\");\n    return -9;\n  }\n  double vel = traj.getVelocity();\n  if (vel > max_trans_vel) {\n    ROS_ERROR(\"ObstacleCostFunction: vel > max_trans_vel\");\n    return -9;\n  }\n  double dt = traj.getTimeResolution();\n  if (dt <= 0) {\n    ROS_ERROR(\"ObstacleCostFunction: dt <= 0\");\n    return -9;\n  }\n  double scaling_factor_inc = (max_scaling_factor - 1.0) / max_trans_vel;\n  scaling_factor = 1.0 + scaling_factor_inc * vel;\n  if (scaling_factor > max_scaling_", "CodeBleu_score": 39.135001340935375}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tif (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified for obstacle cost function\");\n    return -9;\n  }\n\n  // initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double trans_vel = traj.getMaxTransVelocity();\n  if (trans_vel > max_trans_vel_) {\n    scaling_factor = max_scaling_factor_ * pow(trans_vel / max_trans_vel_, scaling_speed_);\n  }\n\n  // calculate the footprint cost for each point in the trajectory\n  for (size_t i = 0; i < traj.getWaypointCount(); i++) {\n    double footprint_cost = 0.0;\n    for (size_t j = 0; j < footprint_spec_.size(); j++) {\n      footprint_cost += world_model_->footprintCost(traj.getWaypoint(i) + footprint_spec_[j]);\n    }\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    // either sum the scores or take the maximum score\n    if (sum_scores_) {\n      cost += scaling_factor * footprint_cost;\n    } else {\n      cost = std::max(cost, scaling_factor * footprint_cost);\n    }\n  }\n\n  // return the total cost\n  return cost;\n}", "CodeBleu_score": 53.174141698994426}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tif (footprint_spec_.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: footprint specification is empty\");\n    return -9;\n  }\n\n  // initialize cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double max_cost = 0.0;\n\n  if (traj.size() == 0) {\n    return -9;\n  }\n\n  if (traj.size() == 1) {\n    if (traj[0].twist.linear.x > max_trans_vel_) {\n      scaling_factor = traj[0].twist.linear.x / max_trans_vel_;\n    }\n  } else {\n    double delta_x = traj[1].pose.position.x - traj[0].pose.position.x;\n    double delta_y = traj[1].pose.position.y - traj[0].pose.position.y;\n    double delta_yaw = tf::getYaw(traj[1].pose.orientation) - tf::getYaw(traj[0].pose.orientation);\n    double speed = sqrt(delta_x * delta_x + delta_y * delta_y) / (traj[1].header.stamp - traj[0].header.stamp).toSec();\n    if (speed > max_trans_vel_) {\n      scaling_factor = speed / max_trans_vel_;\n    }\n    if (fabs(delta_yaw) > M_PI_2) {\n      scaling_factor *= 0.5;\n    }\n  }\n\n  if (scaling_factor > max_scaling_factor_) {\n    scaling_factor = max_scaling_factor_;\n  }\n\n  // calculate cost for each point in the trajectory\n  for (unsigned int i = 0; i < traj.size(); ++i) {\n    double cost_i = 0.0;\n    double footprint_cost_i = 0.0;\n\n    if (world_model_ == NULL) {", "CodeBleu_score": 47.36487300012928}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// check if the position is off the map\n  if (!world_model->isWithinMapBounds(x, y)) {\n    return -7.0;\n  }\n\n  // transform the footprint into the global frame\n  std::vector<geometry_msgs::Point> transformed_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    double x_tmp = footprint_spec[i].x * scale;\n    double y_tmp = footprint_spec[i].y * scale;\n    double th_tmp = th + footprint_spec[i].z;\n    transformed_footprint.push_back(world_model->toGlobal(x_tmp, y_tmp, th_tmp));\n  }\n\n  // get the cost of the transformed footprint\n  double footprint_cost = world_model->footprintCost(transformed_footprint, x, y, th, costmap);\n\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // get the cost of the cell at the position\n  double cell_cost = costmap->getCost(costmap->worldToMap(x, y));\n\n  // return the maximum cost\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 65.7618841835951}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\tif (world_model == NULL) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost: world_model is NULL\");\n    return -9.0;\n  }\n  if (costmap == NULL) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost: costmap is NULL\");\n    return -9.0;\n  }\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost: footprint_spec is empty, maybe missing call to setFootprint?\");\n    return -9.0;\n  }\n  if (!world_model->isFootprintValid(x, y, th, footprint_spec)) {\n    return -7.0;\n  }\n\n  double footprint_cost = world_model->footprintCost(x, y, th, scale, footprint_spec, costmap);\n  double cell_cost = costmap->getCost(x, y);\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 47.229268874383855}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\tif (world_model == NULL) {\n    ROS_ERROR(\"World model is NULL, maybe missing call to setWorldModel?\");\n    return -6.0;\n  }\n  // check if the position is off the map\n  if (!costmap->worldToMap(x, y, i_, j_)) {\n    ROS_ERROR(\"Position is off the map, maybe missing call to setCostmap?\");\n    return -7.0;\n  }\n  // scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    double x_scaled = scale * footprint_spec[i].x;\n    double y_scaled = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(geometry_msgs::Point(x_scaled, y_scaled, 0));\n  }\n  // compute the cost\n  double cost = world_model->footprintCost(scaled_footprint, i_, j_, th, costmap);\n  if (cost < 0) {\n    return -6.0;\n  }\n  return cost;\n}", "CodeBleu_score": 62.698843407149006}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic_ != odom_topic) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 51.89868135327782}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic_ != odom_topic) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 51.89868135327782}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic == odom_topic_)\n    return;\n  odom_topic_ = odom_topic;\n  if (odom_topic_.empty()) {\n    if (odom_sub_) {\n      odom_sub_.shutdown();\n      odom_sub_.reset();\n    }\n  } else {\n    if (!odom_sub_) {\n      odom_sub_ = odom_nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n      odom_sub_.reset();\n      odom_sub_ = odom_nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 48.52924115435625}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t//if we've got restrictions... check if we can reset any oscillation flags\n  if(forward_pos_only_ || forward_neg_only_\n      || strafe_pos_only_ || strafe_neg_only_\n      || rot_pos_only_ || rot_neg_only_) {\n    //calculate the squared distance and the angular difference\n    float squared_dist = (pos - prev).squaredNorm();\n    float ang_diff = std::abs(std::atan2(pos.y() - prev.y(), pos.x() - prev.x()) - std::atan2(prev.y(), prev.x()));\n    //if the squared distance exceeds a threshold or the angular difference is greater than a set angle, it resets the oscillation flags\n    if(squared_dist > oscillation_reset_dist_ || ang_diff > oscillation_reset_angle_) {\n      forward_pos_only_ = false;\n      forward_neg_only_ = false;\n      strafe_pos_only_ = false;\n      strafe_neg_only_ = false;\n      rot_pos_only_ = false;\n      rot_neg_only_ = false;\n    }\n  }\n}", "CodeBleu_score": 38.111724403537075}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tdouble dist_sq = (pos - prev).squaredNorm();\n  double angle = std::abs(std::atan2(pos.y() - prev.y(), pos.x() - prev.x()) - std::atan2(pos.z() - prev.z(), pos.x() - prev.x()));\n  if (dist_sq > oscillation_reset_dist_ * oscillation_reset_dist_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n  if (angle > oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 38.64979571346079}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tdouble dist = (pos - prev).norm();\n  double angle = std::acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n  if (dist > oscillation_reset_dist_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n  if (angle > oscillation_reset_angle_) {\n    forward_pos_only_ = false;\n    forward_neg_only_ = false;\n    strafe_pos_only_ = false;\n    strafe_neg_only_ = false;\n    rot_pos_only_ = false;\n    rot_neg_only_ = false;\n  }\n}", "CodeBleu_score": 38.28513277562752}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tcribed sqaure of the robot is equal to the circumscribed radius\n    double outer_square_radius = circumscribed_radius;\n\n    //get all the points inside the circumscribed square of the robot footprint\n    geometry_msgs::Point c_lower_left, c_upper_right;\n    c_lower_left.x = position.x - outer_square_radius;\n    c_lower_left.y = position.y - outer_square_radius;\n\n    c_upper_right.x = position.x + outer_square_radius;\n    c_upper_right.y = position.y + outer_square_radius;\n\n    //This may return points that are still outside of the cirumscribed square because it returns the cells\n    //contained by the range\n    getPointsInRange(c_lower_left, c_upper_right, points_);\n\n    //if there are no points in the circumscribed square... we don't have to check against the footprint\n    if(points_.empty())\n      return 1.0;\n\n    //compute the half-width of the inner square from the inscribed radius of the robot\n    double inner_square_radius = sqrt((inscribed_radius * inscribed_radius) / 2.0);\n\n    //we'll also check against the inscribed square\n    geometry_msgs::Point i_lower_left, i_upper_right;\n    i_lower_left.x = position.x - inner_square_radius;\n    i_lower_left.y = position.y - inner_square_radius;\n\n    i_upper_right.x = position.x + inner_square_radius;\n    i_upper_right.y = position.y + inner_square_radius;\n\n    //if there are points, we have to do a more expensive check\n    for(unsigned int i = 0; i < points_.size(); ++i){\n      list<geometry_msgs::Point32>* cell_points = points_[i];\n      if(cell_points != NULL){\n        for(list<geometry_msgs::Point32>::iterator it = cell_points->begin(); it != cell_points->end(); ++it){\n          const geometry_msgs::Point32& pt = *it;\n          //first, we'll check to make sure we're in the outer square\n          //printf(\\\"(%.2f, %.2f) ... l(%.2f, %.2f) ... u(%.2f, %.2f)\n\\\", pt.x, pt.y, c_lower_left.x, c_lower_left.y, c_upper_right.x, c_upper_right.y);\n          if(pt.x > c_lower_left.x && pt.x < c_upper_right.x && pt.y > c_lower_left.y && pt.y < c_upper_right.y){\n            //do a quick check to see if the point lies in the inner square of the robot\n            if(pt.x > i_lower_left.x && pt.x < i_upper_right.x && pt.y > i_lower_left.y && pt.y < i_upper_right.y)\n              return -1.0;\n\n            //now we really have to do a full footprint check on the point\n            if(ptInPolygon(pt, footprint))\n              return -1.0;\n          }\n        }\n      }\n    }\n\n    //if we get through all the points and none of them are in the footprint it's legal\n    return 1.0;\n  }", "CodeBleu_score": 35.54831349763502}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tvel[2], max_vel[2], vsamples[2]);\n    for(; !x_it.isFinished(); x_it++) {\n      vel_samp[0] = x_it.getVelocity();\n      for(; !y_it.isFinished(); y_it++) {\n        vel_samp[1] = y_it.getVelocity();\n        for(; !th_it.isFinished(); th_it++) {\n          vel_samp[2] = th_it.getVelocity();\n          //ROS_DEBUG(\\\"Sample %f, %f, %f\\\", vel_samp[0], vel_samp[1], vel_samp[2]);\n          sample_params_.push_back(vel_samp);\n        }\n        th_it.reset();\n      }\n      y_it.reset();\n    }\n  }", "CodeBleu_score": 26.291455637465145}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tangular_sim_granularity_) + 0.5);\n    }", "CodeBleu_score": 3.7833112943824334}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t_i, vx_i, vy_i, theta_i, dt);\n      y_i = computeNewYPosition(y_i, vx_i, vy_i, theta_i, dt);\n      theta_i = computeNewThetaPosition(theta_i, vtheta_i, dt);\n\n      //increment time\n      time += dt;\n    }", "CodeBleu_score": 26.744939076207547}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"You should not call runBehavior before initialize; doing nothing\");\n    return;\n  }\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"You should not call runBehavior before initialize; doing nothing\");\n    return;\n  }\n  //check if we're in an area that is safe to clear\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing costmaps inside the specified area\");\n  } else {\n    ROS_WARN(\"Clearing costmaps outside the specified area\");\n  }\n  //clear the costmaps\n  ros::Time start_time = ros::Time::now();\n  if (affected_maps_ == \"both\" || affected_maps_ == \"global\") {\n    ROS_INFO(\"Clearing global costmap\");\n    global_costmap_->getCostmap()->resetLayers(clearable_layers_);\n    if (force_updating_) {\n      global_costmap_->getCostmap()->updateOrigin(global_costmap_->getCostmap()->getOriginX(), global_costmap_->getCostmap()->getOriginY());\n      global_costmap_->getCostmap()->update();\n    }\n  }\n  if (affected_maps_ == \"both\" || affected_maps_ == \"local\") {\n    ROS_INFO(\"Clearing local costmap\");\n    local_costmap_->getCostmap()->resetLayers(clearable_layers_);\n    if (force_updating_) {\n      local_costmap_->getCostmap()->updateOrigin(local_costmap_->getCostmap()->getOriginX(), local_costmap_->getCostmap()->getOriginY());\n      local_costmap_->getCostmap()->update();\n    }\n  }\n  ros::Time end_time = ros::Time::now();\n  ROS_INFO(\"Clearing costmaps took %f seconds\", (end_time - start_time).toSec());\n}", "CodeBleu_score": 53.62216435006049}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(initialized_ && global_costmap_ && local_costmap_){\n    ros::WallTime start = ros::WallTime::now();\n    ROS_INFO(\\\"Clearing costmaps\\\");\n    if(invert_area_to_clear_){\n      ROS_WARN(\\\"Clearing inside the specified area\\\");\n    }else{\n      ROS_WARN(\\\"Clearing outside the specified area\\\");\n    }\n    if(affected_maps_ == \\\"both\\\" || affected_maps_ == \\\"global\\\"){\n      ROS_INFO(\\\"Clearing global costmap\\\");\n      global_costmap_->getCostmap()->clearNonIntersectingArea(invert_area_to_clear_);\n      if(force_updating_){\n        global_costmap_->getCostmap()->updateOrigin(global_costmap_->getCostmap()->getOriginX(), global_costmap_->getCostmap()->getOriginY());\n      }\n    }\n    if(affected_maps_ == \\\"both\\\" || affected_maps_ == \\\"local\\\"){\n      ROS_INFO(\\\"Clearing local costmap\\\");\n      local_costmap_->getCostmap()->clearNonIntersectingArea(invert_area_to_clear_);\n      if(force_updating_){\n        local_costmap_->getCostmap()->updateOrigin(local_costmap_->getCostmap()->getOriginX(), local_costmap_->getCostmap()->getOriginY());\n      }\n    }\n    ros::WallTime end = ros::WallTime::now();\n    ROS_INFO(\\\"Clearing costmaps took %lf seconds\\\", (end - start).toSec());\n  }else{\n    if(!initialized_){\n      ROS_ERROR(\\\"This object has not been initialized, please call initialize() before running this behavior\\\");\n    }else{\n      if(!global_costmap_){\n        ROS_ERROR(\\\"Global costmap is NULL\\\");\n      }\n      if(!local_costmap_){\n        ROS_ERROR(\\\"Local costmap is NULL\\\");\n      }\n    }\n  }\n}", "CodeBleu_score": 42.2478608167876}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_) {\n    ROS_ERROR(\"You must call initialize before runBehavior\");\n    return;\n  }\n  if(!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"You must call initialize with non-NULL costmaps\");\n    return;\n  }\n  //check if we're inside the area to clear\n  geometry_msgs::PointStamped p;\n  p.header.frame_id = global_costmap_->getGlobalFrameID();\n  p.header.stamp = ros::Time::now();\n  p.point.x = global_costmap_->getSizeInMetersX()/2;\n  p.point.y = global_costmap_->getSizeInMetersY()/2;\n  bool inside = false;\n  try {\n    tf_->transform(p, p, \"map\");\n    inside = true;\n  } catch (tf2::TransformException &ex) {\n    ROS_WARN(\"Could not transform point from %s to map: %s\", p.header.frame_id.c_str(), ex.what());\n  }\n  if(invert_area_to_clear_) {\n    if(inside) {\n      ROS_WARN(\"ClearCostmapRecovery is configured to clear outside the robot's footprint, but it is currently inside the footprint.\");\n    }\n  } else {\n    if(!inside) {\n      ROS_WARN(\"ClearCostmapRecovery is configured to clear inside the robot's footprint, but it is currently outside the footprint.\");\n    }\n  }\n  //clear the global and/or local costmap\n  ros::Time start = ros::Time::now();\n  if(affected_maps_ == \"both\" || affected_maps_ == \"global\") {\n    ROS_INFO(\"Clearing the global costmap\");\n    if(force_updating_) {\n      global_costmap_->updateOrigin(p.point.x, p.point.y);\n    }\n    for(std::set<std::string>::iterator it = clearable_layers_.begin(); it != clearable_layers_.end(); it++) {\n      global_", "CodeBleu_score": 47.14471724483127}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t_y_(0), resolution_(0.0), origin_x_(0.0), origin_y_(0.0), costmap_(NULL)", "CodeBleu_score": 5.152083374572571}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  costmap_pub_.publish(grid_);\n  costmap_update_pub_.publish(update_);\n}", "CodeBleu_score": 35.024092717694025}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  costmap_pub_.publish(grid_);\n  costmap_update_pub_.publish(update_);\n}", "CodeBleu_score": 35.024092717694025}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t// lock the costmap mutex\n  costmap_->lock();\n  // get the costmap resolution\n  double resolution = costmap_->getResolution();\n  // set the grid's header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n  // set the grid's resolution\n  grid_.info.resolution = resolution;\n  // set the grid's width and height\n  grid_.info.width = x0_;\n  grid_.info.height = y0_;\n  // set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // save the origin coordinates\n  xn_ = grid_.info.width;\n  yn_ = grid_.info.height;\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // populate the grid data from the costmap's character map using a translation table\n  for (int y = 0; y < y0_; y++) {\n    for (int x = 0; x < x0_; x++) {\n      grid_.data[y * x0_ + x] = cost_translation_table_[costmap_->getCharMap()[y * x0_ + x]];\n    }\n  }\n  // unlock the costmap mutex\n  costmap_->unlock();\n}", "CodeBleu_score": 59.65838224984733}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// lock the mutex and get the resolution\n  costmap_->lockRead();\n  double resolution = costmap_->getResolution();\n  costmap_->unlockRead();\n\n  // set the grid's header\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n\n  // set the grid's resolution\n  grid_.info.resolution = resolution;\n\n  // set the grid's width and height\n  grid_.info.width = x0_;\n  grid_.info.height = y0_;\n\n  // set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data from the costmap's character map using a translation table\n  for (unsigned int y = 0; y < y0_; ++y) {\n    for (unsigned int x = 0; x < x0_; ++x) {\n      grid_.data[y * x0_ + x] = cost_translation_table_[costmap_->getCharMap()[y * x0_ + x]];\n    }\n  }\n}", "CodeBleu_score": 63.38865357516362}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// lock the costmap mutex\n  costmap_->lock();\n  // get the costmap's resolution\n  double resolution = costmap_->getResolution();\n  // set the grid's header\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  // set the grid's resolution\n  grid_.info.resolution = resolution;\n  // set the grid's width and height\n  grid_.info.width = x0_;\n  grid_.info.height = y0_;\n  // set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // save the origin coordinates\n  xn_ = x0_;\n  yn_ = y0_;\n  // resize the grid data vector\n  grid_.data.resize(x0_ * y0_, -1);\n  // populate the grid data from the costmap's character map using a translation table\n  for (int y = 0; y < y0_; y++) {\n    for (int x = 0; x < x0_; x++) {\n      grid_.data[y * x0_ + x] = cost_translation_table_[costmap_->getCharMap()[y * x0_ + x]];\n    }\n  }\n  // unlock the costmap mutex\n  costmap_->unlock();\n}", "CodeBleu_score": 61.6995320853191}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\td::VoxelLayer\\\");\n    super_map.setStruct(&map);\n    plugins.push_back(super_map);\n\n    move_parameter(nh, obstacles, \\\"origin_z\\\");\n    move_parameter(nh, obstacles, \\\"z_resolution\\\");\n    move_parameter(nh, obstacles, \\\"z_voxels\\\");\n    move_parameter(nh, obstacles, \\\"mark_threshold\\\");\n    move_parameter(nh, obstacles, \\\"unknown_threshold\\\");\n    move_parameter(nh, obstacles, \\\"publish_voxel_map\\\");\n  }", "CodeBleu_score": 28.051014471875487}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tss(s);\n  std::string source;\n  while (ss >> source)\n  {\n    move_parameter(nh, obstacles, source);\n  }\n  move_parameter(nh, obstacles, \\\"observation_sources\\\");\n\n  ros::NodeHandle inflation(nh, \\\"inflation_layer\\\");\n  move_parameter(nh, inflation, \\\"cost_scaling_factor\\\");\n  move_parameter(nh, inflation, \\\"inflation_radius\\\");\n  map[\\\"name\\\"] = XmlRpc::XmlRpcValue(\\\"inflation_layer\\\");\n  map[\\\"type\\\"] = XmlRpc::XmlRpcValue(\\\"costmap_2d::InflationLayer\\\");\n  super_map.setStruct(&map);\n  plugins.push_back(super_map);\n\n  super_array.setArray(&plugins);\n  nh.setParam(\\\"plugins\\\", super_array);\n}", "CodeBleu_score": 39.94630043357119}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}, {"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}, {"code": "void Costmap2DROS::start(){\n\ts\\\\\" unused since \\\\\"plugins\\\\\" is provided\\\", name_.c_str(), param_name.c_str());\n  }", "CodeBleu_score": 1.709062828543442}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t_frame), sensor_frame_(sensor_frame), topic_name_(topic_name),\n    min_obstacle_height_(min_obstacle_height), max_obstacle_height_(max_obstacle_height),\n    obstacle_range_(obstacle_range), raytrace_range_(raytrace_range), tf_tolerance_(tf_tolerance)", "CodeBleu_score": 2.592737283442111}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tint n = end_index - start_index + 1;\n  if (n <= 1) return;\n\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  double shortest_angle = angles::shortest_angular_distance(start_angle, end_angle);\n  double incremental_angle = shortest_angle / (double)(n - 1);\n\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = angles::normalize_angle(start_angle + (i - start_index) * incremental_angle);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 60.668792757473774}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tint n = end_index - start_index + 1;\n  if (n < 2) return;\n\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double yaw_diff = angles::shortest_angular_distance(end_yaw, start_yaw);\n  double yaw_increment = yaw_diff / (n - 1);\n\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + yaw_increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 62.671428411310956}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tint n = end_index - start_index + 1;\n    if (n <= 1) return;\n\n    double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n    double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n    double delta_angle = angles::shortest_angular_distance(start_angle, end_angle);\n\n    double d_angle = delta_angle / (double)n;\n    for (int i=start_index+1; i<=end_index; i++) {\n        double angle = angles::normalize_angle(start_angle + (i-start_index)*d_angle);\n        set_angle(&path[i], angle);\n    }\n}", "CodeBleu_score": 60.85924351552041}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    // Call makePlan to generate a path\n    vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(req.start, req.goal, path);\n    // Update the response with the success status and the generated path\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses = path;\n    resp.plan.header.stamp = ros::Time::now();\n    return true;\n}", "CodeBleu_score": 63.82934394739662}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    // Call makePlan to generate a path\n    vector<PoseStamped> path;\n    bool success = makePlan(req.start, req.goal, path);\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses = path;\n    resp.plan_found = success;\n    return true;\n}", "CodeBleu_score": 75.87166136970035}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\treq.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    if (makePlan(req.start, req.goal, resp.plan.header.seq, resp.plan.header.stamp, resp.plan.header.frame_id)) {\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        resp.plan.header.seq = resp.plan.header.seq + 1;\n        resp.plan.poses.resize(resp.plan.poses.size() + 1);\n        resp.plan.poses.back() = req.goal;\n        resp.plan.header.seq = resp.plan.header.seq + 1;\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        resp.plan.poses.resize(resp.plan.poses.size() + 1);\n        resp.plan.poses.back() = req.start;\n        resp.plan.header.seq = resp.plan.header.seq + 1;\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        resp.plan.poses.resize(resp.plan.poses.size() + 1);\n        resp.plan.poses.back() = req.start;\n        resp.plan.header.seq = resp.plan.header.seq + 1;\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        resp.plan.poses.resize(resp.plan.poses.size() + 1);\n        resp.plan.poses.back() = req.goal;\n        resp.plan.header.seq = resp.plan.header.seq + 1;\n        resp.plan.header.stamp = ros::Time::now();\n        resp.plan.header.frame_id = \"map\";\n        resp.plan.poses.resize(resp.plan.poses.size() + 1);\n        resp.plan", "CodeBleu_score": 42.81233228878436}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    make_plan_service_ = private_nh_.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = cmap_->getROSNode()->subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 69.92860290101594}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tcmap_ = cmap;\n    ros::NodeHandle nh(\"~/\" + name);\n    make_plan_service_ = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 71.86516677416091}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~\");\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}", "CodeBleu_score": 75.58739555988726}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t_CLASS(global_planner::GlobalPlanner, nav_core::BaseGlobalPlanner)\n", "CodeBleu_score": 4.027928015243258}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t_ERROR(\n                \\\"This planner has not been initialized yet, but it is being used, please call initialize() before use\\\");\n        return;\n    }", "CodeBleu_score": 15.133067833666413}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tn      exit(1);\n    }", "CodeBleu_score": 7.34337686415986}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tcore::RecoveryBehavior)\n", "CodeBleu_score": 5.845367489674067}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tvector<PoseStamped> path;\n\n  // Get the current global pose of the robot.\n  PoseStamped current_pose = cmap_->getRobotPose();\n\n  // Make a path from the current pose to the goal pose.\n  makePlan(current_pose, *goal, path);\n\n  // Publish the path.\n  if (path.size() > 0) {\n    navfn_ros::Path path_msg;\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.header.frame_id = \"map\";\n    path_msg.poses = path;\n    path_pub_.publish(path_msg);\n  }\n}", "CodeBleu_score": 57.20922409050333}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tvector<PoseStamped> path;\n  PoseStamped current_pose = cmap_->getRobotPose();\n  makePlan(current_pose, *goal, path);\n}", "CodeBleu_score": 58.691023627896875}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tvector<PoseStamped> path;\n\n  rm::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.pose = getRobotPose();\n\n  makePlan(start, *goal, path);\n}", "CodeBleu_score": 58.974477603521116}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value = param_set.value;\n\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 63.83348131051778}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value = param_set.value;\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 63.83348131051778}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tmavros_msgs::ParamSet param_set_srv;\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value = param_set.value;\n    param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 59.61299728193635}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// \u521b\u5efasocket\n    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (socket_fd < 0) {\n        std::cout << \"create socket error\" << std::endl;\n        return;\n    }\n\n    // \u8bbe\u7f6esocket\u5730\u5740\n    struct sockaddr_in socket_addr;\n    memset(&socket_addr, 0, sizeof(socket_addr));\n    socket_addr.sin_family = AF_INET;\n    socket_addr.sin_port = htons(TCP_PORT);\n    socket_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    // \u7ed1\u5b9a\u5730\u5740\n    int bind_result = bind(socket_fd, (struct sockaddr *)&socket_addr, sizeof(socket_addr));\n    if (bind_result < 0) {\n        std::cout << \"bind error\" << std::endl;\n        return;\n    }\n\n    // \u76d1\u542c\n    int listen_result = listen(socket_fd, 10);\n    if (listen_result < 0) {\n        std::cout << \"listen error\" << std::endl;\n        return;\n    }\n\n    // \u63a5\u53d7\u8fde\u63a5\n    int connection_fd = accept(socket_fd, (struct sockaddr *)&socket_addr, (socklen_t *)&socket_addr);\n    if (connection_fd < 0) {\n        std::cout << \"accept error\" << std::endl;\n        return;\n    }\n\n    // \u63a5\u6536\u6570\u636e\n    char buffer[BUFFER_SIZE];\n    int length = 0;\n    while (true) {\n        // \u63a5\u6536\u6570\u636e\n        length = recv(connection_fd, buffer, BUFFER_SIZE, 0);\n        if (length <= 0) {\n            std::cout << \"recv error\" << std::endl;\n            break;\n        }\n\n        // \u89e3\u7801\u6570\u636e\n        std::string message = buffer;\n        std::cout << \"recv message: \" << message << std::", "CodeBleu_score": 48.31856601719268}, {"code": "void CommunicationBridge::serverFun(){\n\t// 1. wait for a connection from the ground station on a specified port\n    // 2. enter a loop to accept incoming connections, receive data, and process it\n    // 3. if data is received successfully, it decodes the message and publishes it\n    // 4. if the received message length is zero or less, it logs an error and closes the socket\n    // 5. the loop continues to handle further connections\n    // 1. wait for a connection from the ground station on a specified port\n    // 2. enter a loop to accept incoming connections, receive data, and process it\n    // 3. if data is received successfully, it decodes the message and publishes it\n    // 4. if the received message length is zero or less, it logs an error and closes the socket\n    // 5. the loop continues to handle further connections\n    // 1. wait for a connection from the ground station on a specified port\n    // 2. enter a loop to accept incoming connections, receive data, and process it\n    // 3. if data is received successfully, it decodes the message and publishes it\n    // 4. if the received message length is zero or less, it logs an error and closes the socket\n    // 5. the loop continues to handle further connections\n    // 1. wait for a connection from the ground station on a specified port\n    // 2. enter a loop to accept incoming connections, receive data, and process it\n    // 3. if data is received successfully, it decodes the message and publishes it\n    // 4. if the received message length is zero or less, it logs an error and closes the socket\n    // 5. the loop continues to handle further connections\n    // 1. wait for a connection from the ground station on a specified port\n    // 2. enter a loop to accept incoming connections, receive data, and process it\n    // 3. if data is received successfully, it decodes the message and publishes it\n    // 4. if the received message length is zero or less, it logs an error and closes the socket\n    // 5. the loop continues to handle further connections\n    // 1. wait for a connection from the ground station on a specified port\n    // 2. enter a loop to", "CodeBleu_score": 1.9967459379653174}, {"code": "void CommunicationBridge::serverFun(){\n\t// TCP\u670d\u52a1\u7aef\n    int sockfd;\n    struct sockaddr_in serv_addr;\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len;\n    char buf[BUFFER_SIZE];\n    int n;\n    char recv_buf[BUFFER_SIZE];\n    int recv_len;\n    char send_buf[BUFFER_SIZE];\n    int send_len;\n    int ret;\n    int i;\n    int j;\n    int k;\n    int m;\n    int nn;\n    int count;\n    int count_tmp;\n    int count_tmp2;\n    int count_tmp3;\n    int count_tmp4;\n    int count_tmp5;\n    int count_tmp6;\n    int count_tmp7;\n    int count_tmp8;\n    int count_tmp9;\n    int count_tmp10;\n    int count_tmp11;\n    int count_tmp12;\n    int count_tmp13;\n    int count_tmp14;\n    int count_tmp15;\n    int count_tmp16;\n    int count_tmp17;\n    int count_tmp18;\n    int count_tmp19;\n    int count_tmp20;\n    int count_tmp21;\n    int count_tmp22;\n    int count_tmp23;\n    int count_tmp24;\n    int count_tmp25;\n    int count_tmp26;\n    int count_tmp27;\n    int count_tmp28;\n    int count_tmp29;\n    int count_tmp30;\n    int count_tmp31;\n    int count_tmp32;\n    int count_tmp33;\n    int count_tmp34;\n    int count_tmp35;\n    int count_tmp36;\n    int count_tmp37;\n    int count_tmp38;\n    int count_tmp39;\n    int count_tmp40;\n    int count_tmp41;\n    int count_tmp42;", "CodeBleu_score": 12.4536874178277}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tnh) : Communication()", "CodeBleu_score": 3.1986184325318328}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tUBLE)\n        {\n            double value = stod(param_settings.params[i].param_value.c_str());\n            // this->nh_.setParam(param_settings.params[i].param_name,value);\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].STRING)\n        {\n            // this->nh_.setParam(param_settings.params[i].param_name,param_settings.params[i].param_value);\n            is = setParam(param_settings.params[i].param_name, param_settings.params[i].param_value);\n        }\n        else if (param_settings.params[i].type == param_settings.params[i].BOOLEAN)\n        {\n            bool value = param_settings.params[i].param_value == \\\"true\\\" ? true : false;\n            is = setParam(param_settings.params[i].param_name, value);\n        }\n        // \u53cd\u9988\u6d88\u606f \u8868\u793a\u3001\u8bbe\u7f6e\u6210\u529f\u4e0e\u5426 textinfo\n        std::string info = is ? \\\"param settings success!\\\" : \\\"param settings failed!\\\";\n        sendTextInfo(is ? TextInfo::MessageTypeGrade::MTG_INFO : TextInfo::MessageTypeGrade::MTG_ERROR, info);\n    }", "CodeBleu_score": 31.81956867309863}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t   }", "CodeBleu_score": 2.869315723259979}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tstd::cout << \"------------------------------------------------------------------------------------------------------\" << std::endl;\n    std::cout << \"Received a MultiBsplines message from drone \" << msg->drone_id << \".\" << std::endl;\n    std::cout << \"------------------------------------------------------------------------------------------------------\" << std::endl;\n    std::cout << \"------------------------------------------------------------------------------------------------------\" << std::endl;\n\n    // Create a MultiBsplines message.\n    prometheus_msgs::MultiBsplines multitraj_msg;\n\n    // Copy the drone ID.\n    multitraj_msg.drone_id = msg->drone_id;\n\n    // Copy the number of trajectories.\n    multitraj_msg.trajectory_num = msg->trajectory_num;\n\n    // Copy the trajectories.\n    multitraj_msg.trajectories.resize(msg->trajectory_num);\n    for (int i = 0; i < msg->trajectory_num; ++i) {\n        multitraj_msg.trajectories[i].knots.resize(msg->trajectories[i].knots.size());\n        multitraj_msg.trajectories[i].points.resize(msg->trajectories[i].points.size());\n        multitraj_msg.trajectories[i].yaw_points.resize(msg->trajectories[i].yaw_points.size());\n\n        for (int j = 0; j < msg->trajectories[i].knots.size(); ++j) {\n            multitraj_msg.trajectories[i].knots[j].resize(msg->trajectories[i].knots[j].size());\n            for (int k = 0; k < msg->trajectories[i].knots[j].size(); ++k) {\n                multitraj_msg.trajectories[i].knots[j][k] = msg->trajectories[i].knots[j][k];\n            }\n        }\n\n        for (int j = 0; j < msg->trajectories[i].points.size();", "CodeBleu_score": 52.48292812928747}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \"Received multitraj message\" << std::endl;\n    // std::cout << \"drone_id_: \" << drone_id_ << std::endl;\n    // std::cout << \"msg->drone_id_: \" << msg->drone_id_ << std::endl;\n    // std::cout << \"msg->bspline_num: \" << msg->bspline_num << std::endl;\n    // std::cout << \"msg->bspline_list.size(): \" << msg->bspline_list.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].knots.size(): \" << msg->bspline_list[0].knots.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].position_points.size(): \" << msg->bspline_list[0].position_points.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].yaw_points.size(): \" << msg->bspline_list[0].yaw_points.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].curvature_points.size(): \" << msg->bspline_list[0].curvature_points.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].yaw_points.size(): \" << msg->bspline_list[0].yaw_points.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].yaw_points.size(): \" << msg->bspline_list[0].yaw_points.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].yaw_points.size(): \" << msg->bspline_list[0].yaw_points.size() << std::endl;\n    // std::cout << \"msg->bspline_list[0].yaw_points.size(): \" << msg->bspline", "CodeBleu_score": 1.25337711360621}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// std::cout << \"Received multitraj TCP message\" << std::endl;\n    // std::cout << \"drone ID: \" << msg->drone_id << std::endl;\n    // std::cout << \"number of trajectories: \" << msg->trajectory_list.size() << std::endl;\n\n    // int drone_id = msg->drone_id;\n    // std::vector<prometheus_msgs::Bspline> bspline_list;\n\n    // for (int i = 0; i < msg->trajectory_list.size(); i++)\n    // {\n    //     prometheus_msgs::Bspline bspline;\n    //     bspline.header = msg->trajectory_list[i].header;\n    //     bspline.knots = msg->trajectory_list[i].knots;\n    //     bspline.position_points = msg->trajectory_list[i].position_points;\n    //     bspline.yaw_points = msg->trajectory_list[i].yaw_points;\n    //     bspline_list.push_back(bspline);\n    // }\n\n    // communication->send_multitraj_tcp(msg->drone_id, bspline_list);\n\n    // std::cout << \"Sent multitraj TCP message\" << std::endl;\n}", "CodeBleu_score": 1.2915073360288183}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t_ready)\n    {\n        scan_filtered_pub_.publish(scan_filtered);\n        scan_filtered_ready = false;\n    }\n    usleep(100000);\n    if(ugv_point_cloud_ready)\n    {\n        ugv_compressed_point_cloud = compressed(ugv_point_cloud);\n        ugv_point_cloud_pub_.publish(ugv_compressed_point_cloud);\n        ugv_point_cloud_ready = false;\n    }\n}", "CodeBleu_score": 13.117347133196022}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_pub_ = nh.advertise<prometheus_msgs::SwarmCommand>(\\\"/prometheus/swarm_command\\\", 1000);\n        // \u3010\u8ba2\u9605\u3011\u96c6\u7fa4\u63a7\u5236\u6307\u4ee4\n        this->swarm_command_sub_ = nh.subscribe(\\\"/prometheus/swarm_command\\\", 10, &SwarmControl::swarmCmdCb, this);\n        // \u3010\u53d1\u5e03\u3011\u6240\u6709\u65e0\u4eba\u8f66\u72b6\u6001\n        this->all_ugv_state_pub_ = nh.advertise<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1000);\n    }", "CodeBleu_score": 23.163552044305412}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t0;\n        this->multi_ugv_state_.ugv_state_all.push_back(ugv_state);\n    }", "CodeBleu_score": 1.910173697148736}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t[i][last_Astar_id]) *\n                 (ctrl_pts_law.dot(middle_point - a_star_pathes[i][Astar_id]) / ctrl_pts_law.dot(a_star_pathes[i][Astar_id] - a_star_pathes[i][last_Astar_id])) // = t\n                );\n\n            if ((intersection_point - middle_point).norm() > 0.01) // 1cm.\n            {\n              cps_.flag_temp[segment_ids[i].first] = true;\n              cps_.base_point[segment_ids[i].first].push_back(init_points.col(segment_ids[i].first));\n              cps_.direction[segment_ids[i].first].push_back((intersection_point - middle_point).normalized());\n\n              got_intersection_id = segment_ids[i].first;\n            }\n            break;\n          }", "CodeBleu_score": 25.57430898610189}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tBsplineOptimizer::calcSwarmCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_ - (double)(q.cols() - 2 * order_) * 1.0 / 3.0; // Only check the first 2/3 points\n    const double CLEARANCE = swarm_clearance_ * 2;\n    double t_now = ros::Time::now().toSec();\n    constexpr double a = 2.0, b = 1.0, inv_a2 = 1 / a / a, inv_b2 = 1 / b / b;\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double glb_time = t_now + ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (size_t id = 0; id < swarm_trajs_->size(); id++)\n      {\n        if ((swarm_trajs_->at(id).drone_id != (int)id) || swarm_trajs_->at(id).drone_id == drone_id_)\n        {\n          continue;\n        }\n\n        double traj_i_satrt_time = swarm_trajs_->at(id).start_time_.toSec();\n        if (glb_time < traj_i_satrt_time + swarm_trajs_->at(id).duration_ - 0.1)\n        {\n          /* def cost=(c-sqrt([Q-O]'D[Q-O]))^2, D=[1/b^2,0,0;0,1/b^2,0;0,0,1/a^2] */\n          Eigen::Vector3d swarm_prid = swarm_trajs_->at(id).position_traj_.evaluateDeBoorT(glb_time - traj_i_satrt_time);\n          Eigen::Vector3d dist_vec = cps_.points.col(i) - swarm_prid;\n          double ellip_dist = sqrt(dist_vec(2) * dist_vec(2) * inv_a2 + (dist_vec(0) * dist_vec(0) + dist_vec(1) * dist_vec(1)) * inv_b2);\n          double dist_err = CLEARANCE - ellip_dist;\n\n          Eigen::Vector3d dist_grad = cps_.points.col(i) - swarm_prid;\n          Eigen::Vector3d Coeff;\n          Coeff(0) = -2 * (CLEARANCE / ellip_dist - 1) * inv_b2;\n          Coeff(1) = Coeff(0);\n          Coeff(2) = -2 * (CLEARANCE / ellip_dist - 1) * inv_a2;\n\n          if (dist_err < 0)\n          {\n            /* do nothing */\n          }\n          else\n          {\n            cost += pow(dist_err, 2);\n            gradient.col(i) += (Coeff.array() * dist_grad.array()).matrix();\n          }\n\n          if (min_ellip_dist_ > dist_err)\n          {\n            min_ellip_dist_ = dist_err;\n          }\n        }\n      }\n    }\n  }\n\n  void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    constexpr double CLEARANCE = 1.5;\n    double t_now = ros::Time::now().toSec();\n\n    for (int i = order_; i < end_idx; i++)\n    {\n      double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n\n      for (int id = 0; id < moving_objs_->getObjNums(); id++)\n      {\n        Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        //cout /*<< \\\"cps_.points.col(i)=\\\" << cps_.points.col(i).transpose()*/ << \\\" moving_objs_=\\\" << obj_prid.transpose() << \\\" dist=\\\" << dist << endl;\n        double dist_err = CLEARANCE - dist;\n        Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else\n        {\n          cost += pow(dist_err, 2);\n          gradient.col(i) += -2.0 * dist_err * dist_grad;\n        }\n      }\n      // cout << \\\"time=\\\" << time << \\\" i=\\\" << i << \\\" order_=\\\" << order_ << \\\" end_idx=\\\" << end_idx << endl;\n      // cout << \\\"--\\\" << endl;\n    }\n    // cout << \\\"---------------\\\" << endl;\n  }\n\n  void BsplineOptimizer::calcDistanceCostRebound(const Eigen::MatrixXd &q, double &cost,\n                                                 Eigen::MatrixXd &gradient, int iter_num, double smoothness_cost)\n  {\n    cost = 0.0;\n    int end_idx = q.cols() - order_;\n    double demarcation = cps_.clearance;\n    double a = 3 * demarcation, b = -3 * pow(demarcation, 2), c = pow(demarcation, 3);\n\n    force_stop_type_ = DONT_STOP;\n    if (iter_num > 3 && smoothness_cost / (cps_.size - 2 * order_) < 0.1) // 0.1 is an experimental value that indicates the trajectory is smooth enough.\n    {\n      check_collision_and_rebound();\n    }\n\n    /*** calculate distance cost and gradient ***/\n    for (auto i = order_; i < end_idx; ++i)\n    {\n      for (size_t j = 0; j < cps_.direction[i].size(); ++j)\n      {\n        double dist = (cps_.points.col(i) - cps_.base_point[i][j]).dot(cps_.direction[i][j]);\n        double dist_err = cps_.clearance - dist;\n        Eigen::Vector3d dist_grad = cps_.direction[i][j];\n\n        if (dist_err < 0)\n        {\n          /* do nothing */\n        }\n        else if (dist_err < demarcation)\n        {\n          cost += pow(dist_err, 3);\n          gradient.col(i) += -3.0 * dist_err * dist_err * dist_grad;\n        }\n        else\n        {\n          cost += a * dist_err * dist_err + b * dist_err + c;\n          gradient.col(i) += -(2.0 * a * dist_err + b) * dist_grad;\n        }\n      }\n    }\n  }\n\n\n\n", "CodeBleu_score": 39.581439270896524}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}, {"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}, {"code": "double UniformBspline::getJerk(){\n\tlim ||\n          fabs(vel(2)) > enlarged_vel_lim)\n      {\n\n        if (show)\n          cout << \\\"[Check]: Infeasible vel \\\" << i << \\\" :\\\" << vel.transpose() << endl;\n        fea = false;\n\n        for (int j = 0; j < dimension; ++j)\n        {\n          max_vel = max(max_vel, fabs(vel(j)));\n        }\n      }\n    }", "CodeBleu_score": 23.10206307573023}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.07034331015703}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.07034331015703}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}", "CodeBleu_score": 78.07034331015703}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t::TransformBroadcaster br;\n  // tf::Transform transform;\n  // transform.setOrigin( tf::Vector3(cam2world(0,3), cam2world(1,3), cam2world(2,3) ));\n  // transform.setRotation(tf::Quaternion(cam2world_quat.x(), cam2world_quat.y(), cam2world_quat.z(), cam2world_quat.w()));\n  // br.sendTransform(tf::StampedTransform(transform, my_last_odom_stamp, \\\"world\\\", \\\"camera\\\"));\n  //publish transform from world frame to quadrotor frame.\n}", "CodeBleu_score": 9.140428526622236}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t_[drone_id](0) + search_radius;\n  searchbox_rd_[drone_id].y = drone_ref_pixel_[drone_id](1) + search_radius;\n  // check the tmp_p around ref_pixel\n  for(int i = -search_radius; i <= search_radius; i++)\n    for(int j = -search_radius; j <= search_radius; j++)\n    {\n      tmp_pixel(0) = drone_ref_pixel_[drone_id](0) + j;\n      tmp_pixel(1) = drone_ref_pixel_[drone_id](1) + i;\n      if(tmp_pixel(0) < 0 || tmp_pixel(0) >= img_width_ || tmp_pixel(1) < 0 || tmp_pixel(1) >= img_height_)\n        continue;\n      // depth = depth_img_.at<float>(tmp_pixel(1), tmp_pixel(0));\n      uint16_t *row_ptr;\n      row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n      depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n      // ROS_WARN(\\\"depth = %lf\\\", depth);\n      // get tmp_pose in cam frame\n      tmp_pose_cam = depth2Pos(tmp_pixel(0), tmp_pixel(1), depth);\n      double dist2 = getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]);\n      // ROS_WARN(\\\"dist2 = %lf\\\", dist2);\n      if (dist2 < max_pose_error2_) {\n        valid_pixel_cnt_[drone_id]++;\n        hit_pixels_[drone_id].push_back(tmp_pixel);\n        boundingbox_lu_[drone_id].x = tmp_pixel(0) < boundingbox_lu_[drone_id].x ? tmp_pixel(0) : boundingbox_lu_[drone_id].x;\n        boundingbox_lu_[drone_id].y = tmp_pixel(1) < boundingbox_lu_[drone_id].y ? tmp_pixel(1) : boundingbox_lu_[drone_id].y;\n        boundingbox_rd_[drone_id].x = tmp_pixel(0) > boundingbox_rd_[drone_id].x ? tmp_pixel(0) : boundingbox_rd_[drone_id].x;\n        boundingbox_rd_[drone_id].y = tmp_pixel(1) > boundingbox_rd_[drone_id].y ? tmp_pixel(1) : boundingbox_rd_[drone_id].y;\n      }\n    }\n  pixel_threshold_ = (drone_width_*fx_/drone_pose_cam_[drone_id](2)) * (drone_height_*fy_/drone_pose_cam_[drone_id](2))*pixel_ratio_;\n  if (valid_pixel_cnt_[drone_id] > pixel_threshold_) {\n    int step = 1, size = (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) < (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x) ? (boundingbox_rd_[drone_id].y-boundingbox_lu_[drone_id].y) : (boundingbox_rd_[drone_id].x-boundingbox_lu_[drone_id].x);\n    int init_x = (boundingbox_lu_[drone_id].x+boundingbox_rd_[drone_id].x)/2, init_y = (boundingbox_lu_[drone_id].y+boundingbox_rd_[drone_id].y)/2;\n    int x_flag = 1, y_flag = 1;\n    int x_idx = 0, y_idx = 0;\n    uint16_t *row_ptr;\n    row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n    depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n    tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n    if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n      true_pixel(0) = init_x;\n      true_pixel(1) = init_y;\n      true_pose_cam = tmp_pose_cam;\n      return true;\n    }\n    while(step<size) {\n        while(x_idx<step){\n            init_x = init_x+x_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_) {\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            x_idx++;\n        }\n        x_idx = 0;\n        x_flag = -x_flag;\n        while(y_idx<step){\n            init_y = init_y+y_flag;\n            uint16_t *row_ptr;\n            row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n            depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n            tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n            if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n              true_pixel(0) = init_x;\n              true_pixel(1) = init_y;\n              true_pose_cam = tmp_pose_cam;\n              return true;\n            }\n            y_idx++;\n        }\n        y_idx = 0;\n        y_flag = -y_flag;\n        step++;\n    }\n    while(x_idx<step-1){\n        init_x = init_x+x_flag;\n        uint16_t *row_ptr;\n        row_ptr = depth_img_.ptr<uint16_t>(tmp_pixel(1));\n        depth = (*(row_ptr+tmp_pixel(0))) / 1000.0;\n        tmp_pose_cam = depth2Pos(init_x, init_y, depth);\n        if (getDist2(tmp_pose_cam, drone_pose_cam_[drone_id]) < max_pose_error2_){\n          true_pixel(0) = init_x;\n          true_pixel(1) = init_y;\n          true_pose_cam = tmp_pose_cam;\n          return true;\n        }\n        x_idx++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 36.056929281097204}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.490496894465}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.490496894465}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 84.34171284473177}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tstart_idx = ConvertToIndex(start_pt);\n    end_idx = ConvertToIndex(end_pt);\n\n    // Check if start point is inside an obstacle\n    if (grid_map_->GetValue(start_idx) == 1) {\n        // Iteratively adjust the start point until it is not inside an obstacle\n        while (grid_map_->GetValue(start_idx) == 1) {\n            // Adjust the start point by moving it away from the end point\n            start_idx(0) = start_idx(0) + (end_idx(0) - start_idx(0)) / 2;\n            start_idx(1) = start_idx(1) + (end_idx(1) - start_idx(1)) / 2;\n            start_idx(2) = start_idx(2) + (end_idx(2) - start_idx(2)) / 2;\n        }\n        // If the start point is still inside an obstacle, return false\n        if (grid_map_->GetValue(start_idx) == 1) {\n            return false;\n        }\n    }\n\n    // Check if end point is inside an obstacle\n    if (grid_map_->GetValue(end_idx) == 1) {\n        // Iteratively adjust the end point until it is not inside an obstacle\n        while (grid_map_->GetValue(end_idx) == 1) {\n            // Adjust the end point by moving it away from the start point\n            end_idx(0) = end_idx(0) + (start_idx(0) - end_idx(0)) / 2;\n            end_idx(1) = end_idx(1) + (start_idx(1) - end_idx(1)) / 2;\n            end_idx(2) = end_idx(2) + (start_idx(2) - end_idx(2)) / 2;\n        }\n        // If the end point is still inside an obstacle, return false\n        if (grid_map_->GetValue(end_idx) == 1) {\n            return false;\n        }\n    }", "CodeBleu_score": 32.04514902692264}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start and end points to grid indices.\n    start_idx = grid_map_->GetGridIndexFromPoint(start_pt);\n    end_idx = grid_map_->GetGridIndexFromPoint(end_pt);\n\n    // If the start or end point is inside an obstacle, adjust it.\n    if (grid_map_->IsInsideObstacle(start_idx)) {\n        // Attempt to adjust the start point.\n        if (!AdjustStartPoint(start_idx)) {\n            ROS_WARN(\"Failed to adjust start point.\");\n            return false;\n        }\n    }\n\n    if (grid_map_->IsInsideObstacle(end_idx)) {\n        // Attempt to adjust the end point.\n        if (!AdjustEndPoint(end_idx)) {\n            ROS_WARN(\"Failed to adjust end point.\");\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 30.984060494070043}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start and end points to grid indices\n    start_idx = grid_map_->GetGridIndexFrom3DPoint(start_pt);\n    end_idx = grid_map_->GetGridIndexFrom3DPoint(end_pt);\n\n    // Check if start or end point is inside an obstacle\n    if (grid_map_->IsInObstacle(start_idx)) {\n        // If start point is inside an obstacle, adjust it by moving it away from the end point\n        start_idx = AdjustPointInObstacle(start_idx, end_idx);\n        if (start_idx == Vector3i::Zero()) {\n            // If start point is still inside an obstacle, return false\n            return false;\n        }\n    }\n    if (grid_map_->IsInObstacle(end_idx)) {\n        // If end point is inside an obstacle, adjust it by moving it away from the start point\n        end_idx = AdjustPointInObstacle(end_idx, start_idx);\n        if (end_idx == Vector3i::Zero()) {\n            // If end point is still inside an obstacle, return false\n            return false;\n        }\n    }\n\n    // Return true if both start and end points are not inside an obstacle\n    return true;\n}", "CodeBleu_score": 35.92132385526241}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tmp_.unknown_flag_ = 0.01;\n\n  // cout << \\\"hit: \\\" << mp_.prob_hit_log_ << endl;\n  // cout << \\\"miss: \\\" << mp_.prob_miss_log_ << endl;\n  // cout << \\\"min log: \\\" << mp_.clamp_min_log_ << endl;\n  // cout << \\\"max: \\\" << mp_.clamp_max_log_ << endl;\n  // cout << \\\"thresh log: \\\" << mp_.min_occupancy_log_ << endl;\n\n  for (int i = 0; i < 3; ++i)\n    mp_.map_voxel_num_(i) = ceil(mp_.map_size_(i) / mp_.resolution_);\n\n  // z\u8f74\u4e0a\uff0c\u5730\u9762\u9ad8\u5ea6\u4e3a\u6700\u5c0f\u503c\n  mp_.map_min_boundary_ = mp_.map_origin_;\n  mp_.map_max_boundary_ = mp_.map_origin_ + mp_.map_size_;\n\n  // initialize data buffers\n  int buffer_size = mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2);\n\n  md_.occupancy_buffer_ = vector<double>(buffer_size, mp_.clamp_min_log_ - mp_.unknown_flag_);\n  md_.occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n\n  md_.count_hit_and_miss_ = vector<short>(buffer_size, 0);\n  md_.count_hit_ = vector<short>(buffer_size, 0);\n  md_.flag_rayend_ = vector<char>(buffer_size, -1);\n  md_.flag_traverse_ = vector<char>(buffer_size, -1);\n\n  md_.raycast_num_ = 0;\n\n  md_.proj_points_.resize(640 * 480 / mp_.skip_pixel_ / mp_.skip_pixel_);\n  md_.proj_points_cnt = 0;\n\n  // \u76f8\u673a\u5916\u53c2\u6570\n  md_.cam2body_ << 0.0, 0.0, 1.0, 0.0,\n                  -1.0, 0.0, 0.0, 0.0,\n                  0.0, -1.0, 0.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0;\n\n  // \u8ba2\u9605 \u6df1\u5ea6\u76f8\u673a\n  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, \\\"grid_map/depth\\\", 50));\n  // \u76f8\u673a\u5916\u53c2\n  extrinsic_sub_ = node_.subscribe<nav_msgs::Odometry>(\\\"/vins_estimator/extrinsic\\\", 10, &GridMap::extrinsicCallback, this); //sub\n\n  // \u8ba2\u9605\u65e0\u4eba\u673a\u5b9a\u4f4d\u4fe1\u606f\n  if (mp_.pose_type_ == POSE_STAMPED)\n  {\n    pose_sub_.reset(\n        new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, \\\"grid_map/pose\\\", 25));\n\n    sync_image_pose_.reset(new message_filters::Synchronizer<SyncPolicyImagePose>(\n        SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));\n    sync_image_pose_->registerCallback(boost::bind(&GridMap::depthPoseCallback, this, _1, _2));\n  }\n  else if (mp_.pose_type_ == ODOMETRY)\n  {\n    odom_sub_.reset(new message_filters::Subscriber<nav_msgs::Odometry>(node_, \\\"grid_map/odom\\\", 100, ros::TransportHints().tcpNoDelay()));\n\n    sync_image_odom_.reset(new message_filters::Synchronizer<SyncPolicyImageOdom>(\n        SyncPolicyImageOdom(100), *depth_sub_, *odom_sub_));\n    sync_image_odom_->registerCallback(boost::bind(&GridMap::depthOdomCallback, this, _1, _2));\n  }\n\n  // use odometry and point cloud or scan\n  // \u8ba2\u9605\u70b9\u4e91\u6570\u636e\n  // \u6ce8\u610f\uff1a\u6b64\u5904\u70b9\u4e91\u6570\u636e\u4f4d\u4e8e\u60ef\u6027\u7cfb\n  indep_cloud_sub_ =\n      node_.subscribe<sensor_msgs::PointCloud2>(\\\"grid_map/cloud\\\", 10, &GridMap::cloudCallback, this);\n\n  // \u8ba2\u9605odom\u6570\u636e\n  indep_odom_sub_ =\n      node_.subscribe<nav_msgs::Odometry>(\\\"grid_map/odom\\\", 10, &GridMap::odomCallback, this);\n\n  // \u8ba2\u9605\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\uff0c\u6682\u65f6\u5f03\u7528\uff0c\u6548\u679c\u4e0d\u5982\u4f7f\u7528octomap\n  scan_sub_ =\n      node_.subscribe<sensor_msgs::LaserScan>(\\\"grid_map/scan\\\", 10, &GridMap::scanCallback, this);\n\n  // \u5360\u636e\u56fe\u66f4\u65b0timer\uff0c\u4ec5\u7528\u4e8e\u6df1\u5ea6\u56fe\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  occ_timer_ = node_.createTimer(ros::Duration(0.05), &GridMap::updateOccupancyCallback, this);\n  // rviz\u663e\u793atimer\uff0c\u53d1\u5e03\u7684\u56fe\n  vis_timer_ = node_.createTimer(ros::Duration(0.11), &GridMap::visCallback, this);\n\n  // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy\\\", 10);\n  // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\uff0c\u4ec5\u9488\u5bf9\u4f7f\u7528\u76f8\u673a\u4e3a\u8f93\u5165\u7684\u60c5\u51b5\n  map_inf_pub_ = node_.advertise<sensor_msgs::PointCloud2>(\\\"grid_map/occupancy_inflate\\\", 10);\n\n  md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n  md_.has_first_depth_ = false;\n  md_.has_odom_ = false;\n  md_.has_cloud_ = false;\n  md_.image_cnt_ = 0;\n  md_.last_occ_update_time_.fromSec(0);\n\n  md_.fuse_time_ = 0.0;\n  md_.update_num_ = 0;\n  md_.max_fuse_time_ = 0.0;\n\n  md_.flag_depth_odom_timeout_ = false;\n  md_.flag_use_depth_fusion = false;\n}", "CodeBleu_score": 39.265502112499014}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t   pt_w = md_.proj_points_[i];\n\n    // set flag for projected point\n\n    if (!isInMap(pt_w))\n    {\n      pt_w = closetPointInMap(pt_w, md_.camera_pos_);\n\n      length = (pt_w - md_.camera_pos_).norm();\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n      }\n      vox_idx = setCacheOccupancy(pt_w, 0);\n    }\n    else\n    {\n      length = (pt_w - md_.camera_pos_).norm();\n\n      if (length > mp_.max_ray_length_)\n      {\n        pt_w = (pt_w - md_.camera_pos_) / length * mp_.max_ray_length_ + md_.camera_pos_;\n        vox_idx = setCacheOccupancy(pt_w, 0);\n      }\n      else\n      {\n        vox_idx = setCacheOccupancy(pt_w, 1);\n      }\n    }\n\n    max_x = max(max_x, pt_w(0));\n    max_y = max(max_y, pt_w(1));\n    max_z = max(max_z, pt_w(2));\n\n    min_x = min(min_x, pt_w(0));\n    min_y = min(min_y, pt_w(1));\n    min_z = min(min_z, pt_w(2));\n\n    // raycasting between camera center and point\n\n    if (vox_idx != INVALID_IDX)\n    {\n      if (md_.flag_rayend_[vox_idx] == md_.raycast_num_)\n      {\n        continue;\n      }\n      else\n      {\n        md_.flag_rayend_[vox_idx] = md_.raycast_num_;\n      }\n    }\n\n    raycaster.setInput(pt_w / mp_.resolution_, md_.camera_pos_ / mp_.resolution_);\n\n    while (raycaster.step(ray_pt))\n    {\n      Eigen::Vector3d tmp = (ray_pt + half) * mp_.resolution_;\n      length = (tmp - md_.camera_pos_).norm();\n\n      // if (length < mp_.min_ray_length_) break;\n\n      vox_idx = setCacheOccupancy(tmp, 0);\n\n      if (vox_idx != INVALID_IDX)\n      {\n        if (md_.flag_traverse_[vox_idx] == md_.raycast_num_)\n        {\n          break;\n        }\n        else\n        {\n          md_.flag_traverse_[vox_idx] = md_.raycast_num_;\n        }\n      }\n    }\n  }", "CodeBleu_score": 30.472491074621665}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t_bound_max_(1),md_.local_bound_max_(2));\n  Eigen::Vector3i max_cut = md_.local_bound_max_ +\n                            Eigen::Vector3i(mp_.local_map_margin_, mp_.local_map_margin_, mp_.local_map_margin_);\n  boundIndex(min_cut);\n  // printf(\\\"min_cut:[%d,%d,%d]\n\\\",min_cut(0),min_cut(1),min_cut(2));\n  boundIndex(max_cut);\n  // printf(\\\"max_cut:[%d,%d,%d]\n\\\",max_cut(0),max_cut(1),max_cut(2));\n\n  Eigen::Vector3i min_cut_m = min_cut - Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  Eigen::Vector3i max_cut_m = max_cut + Eigen::Vector3i(vec_margin, vec_margin, vec_margin);\n  boundIndex(min_cut_m);\n  // printf(\\\"min_cut_m:[%d,%d,%d]\n\\\",min_cut_m(0),min_cut_m(1),min_cut_m(2));\n  boundIndex(max_cut_m);\n  // printf(\\\"max_cut_m:[%d,%d,%d]\n\n\\\",max_cut_m(0),max_cut_m(1),max_cut_m(2));\n\n  // clear data outside the local range\n\n  for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    {\n\n      for (int z = min_cut_m(2); z < min_cut(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int z = max_cut(2) + 1; z <= max_cut_m(2); ++z)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    for (int x = min_cut_m(0); x <= max_cut_m(0); ++x)\n    {\n\n      for (int y = min_cut_m(1); y < min_cut(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int y = max_cut(1) + 1; y <= max_cut_m(1); ++y)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  for (int y = min_cut_m(1); y <= max_cut_m(1); ++y)\n    for (int z = min_cut_m(2); z <= max_cut_m(2); ++z)\n    {\n\n      for (int x = min_cut_m(0); x < min_cut(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n\n      for (int x = max_cut(0) + 1; x <= max_cut_m(0); ++x)\n      {\n        int idx = toAddress(x, y, z);\n        md_.occupancy_buffer_[idx] = mp_.clamp_min_log_ - mp_.unknown_flag_;\n      }\n    }\n\n  // inflate occupied voxels to compensate robot size\n\n  int inf_step = ceil(mp_.obstacles_inflation_ / mp_.resolution_);\n  // int inf_step_z = 1;\n  vector<Eigen::Vector3i> inf_pts(pow(2 * inf_step + 1, 3));\n  // inf_pts.resize(4 * inf_step + 3);\n  Eigen::Vector3i inf_pt;\n\n  // clear outdated data\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n\n  // inflate obstacles\n  for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n    for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y)\n      for (int z = md_.local_bound_min_(2); z <= md_.local_bound_max_(2); ++z)\n      {\n\n        if (md_.occupancy_buffer_[toAddress(x, y, z)] > mp_.min_occupancy_log_)\n        {\n          inflatePoint(Eigen::Vector3i(x, y, z), inf_step, inf_pts);\n\n          for (int k = 0; k < (int)inf_pts.size(); ++k)\n          {\n            inf_pt = inf_pts[k];\n            int idx_inf = toAddress(inf_pt);\n            if (idx_inf < 0 ||\n                idx_inf >= mp_.map_voxel_num_(0) * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2))\n            {\n              continue;\n            }\n            md_.occupancy_buffer_inflate_[idx_inf] = 1;\n          }\n        }\n      }\n\n  // add virtual ceiling to limit flight height\n  if (mp_.virtual_ceil_height_ > -0.5) {\n    int ceil_id = floor((mp_.virtual_ceil_height_ - mp_.map_origin_(2)) * mp_.resolution_inv_) - 1;\n    for (int x = md_.local_bound_min_(0); x <= md_.local_bound_max_(0); ++x)\n      for (int y = md_.local_bound_min_(1); y <= md_.local_bound_max_(1); ++y) {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, ceil_id)] = 1;\n      }\n  }\n}", "CodeBleu_score": 37.50579441086829}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }", "CodeBleu_score": 21.59369501770349}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n\n        int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n\n    }", "CodeBleu_score": 10.658260266414706}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tM34.x)) * invDen;\n    data.ta = q2;\n    data.tb = q4;\n    data.Ma = M12;\n    data.Mb = M34;\n}", "CodeBleu_score": 7.2806868149763355}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t// \u68c0\u67e5\u662f\u5426\u68c0\u6d4b\u5230\u76ee\u6807\n    for (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].label == \"T\") {\n            ellipse_det = msg->detections[i];\n            num_regain++;\n            num_lost = 0;\n            is_detected = true;\n        }\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    // \u68c0\u67e5\u662f\u5426\u68c0\u6d4b\u5230\u76ee\u6807\n    if (is_detected) {\n        // \u66f4\u65b0\u76ee\u6807\u4f4d\u7f6e\n        ellipse_det.position[0] = msg->detections[0].position[0];\n        ellipse_det.position[1] = msg->detections[0].position[1];\n        ellipse_det.position[2] = msg->detections[0].position[2];\n        // \u66f4\u65b0\u76ee\u6807\u5c3a\u5bf8\n        ellipse_det.major_axis = msg->detections[0].major_axis;\n        ellipse_det.minor_axis = msg->detections[0].minor_axis;\n        // \u66f4\u65b0\u76ee\u6807\u89d2\u5ea6\n        ellipse_det.sight_angle[0] = msg->detections[0].sight_angle[0];\n        ellipse_det.sight_angle[1] = msg->detections[0].sight_angle[1];\n        ellipse_det.sight_angle[2] = msg->detections[0].sight_angle[2];\n    }\n    else {\n        // \u66f4\u65b0\u76ee\u6807\u4f4d\u7f6e\n        ellipse_det.position[0] = 0;\n        ellipse_det.position[1] = 0;\n        ellipse_det.position[2] = 0;\n        // \u66f4\u65b0\u76ee\u6807\u5c3a\u5bf8\n        ellipse_", "CodeBleu_score": 57.71330443124616}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n    if (msg->detections[i].id == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n  }\n\n  if (num_lost >= VISION_THRES) {\n    is_detected = false;\n  } else if (num_regain >= VISION_THRES) {\n    is_detected = true;\n  }\n\n  for (int i = 0; i < msg->detections.size(); i++) {\n    if (msg->detections[i].id == \"T\") {\n      ellipse_det.sight_angle = msg->detections[i].sight_angle;\n      ellipse_det.sight_angle_rate = msg->detections[i].sight_angle_rate;\n      ellipse_det.ellipse_info.center[0] = msg->detections[i].ellipse_info.center[0];\n      ellipse_det.ellipse_info.center[1] = msg->detections[i].ellipse_info.center[1];\n      ellipse_det.ellipse_info.major_axis = msg->detections[i].ellipse_info.major_axis;\n      ellipse_det.ellipse_info.minor_axis = msg->detections[i].ellipse_info.minor_axis;\n      ellipse_det.ellipse_info.angle = msg->detections[i].ellipse_info.angle;\n      ellipse_det.ellipse_info.angle_rate = msg->detections[i].ellipse_info.angle_rate;\n      ellipse_det.ellipse_info.center_rate[0] = msg->detections[i].ellipse_info.center_rate[0];\n      ellipse_det.ellipse_info.center_rate[1] = msg->detections[i].ellipse_info.center_rate[1];", "CodeBleu_score": 56.59499725243005}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t// \u904d\u5386\u6bcf\u4e00\u4e2a\u76ee\u6807\n    for (int i = 0; i < msg->detection_info_array.size(); i++) {\n        // \u5982\u679c\u68c0\u6d4b\u5230\u76ee\u6807\uff0c\u5219\u66f4\u65b0ellipse_det\n        if (msg->detection_info_array[i].label == \"T\") {\n            ellipse_det = msg->detection_info_array[i];\n            num_regain++;\n            num_lost = 0;\n            is_detected = true;\n        } else {\n            num_regain = 0;\n            num_lost++;\n            is_detected = false;\n        }\n    }\n    // \u5982\u679c\u68c0\u6d4b\u5230\u76ee\u6807\uff0c\u5219\u66f4\u65b0ellipse_det\n    if (is_detected) {\n        ellipse_det.sight_angle[0] = 0;\n        ellipse_det.sight_angle[1] = 0;\n        ellipse_det.sight_angle[2] = 0;\n    }\n}", "CodeBleu_score": 57.19997001502111}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tNULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }", "CodeBleu_score": 38.45552623537056}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tVector3i end_index = posToIndex(end_pt);\n\n  // \u521d\u59cb\u5316,\u5c06\u8d77\u59cb\u70b9\u8bbe\u4e3a\u7b2c\u4e00\u4e2a\u8def\u5f84\u70b9\n  NodePtr cur_node = path_node_pool_[0];\n  cur_node->parent = NULL;\n  cur_node->position = start_pt;\n  cur_node->index = posToIndex(start_pt);\n  cur_node->g_score = 0.0;\n  cur_node->f_score = lambda_heu_ * getEuclHeu(cur_node->position, end_pt);\n  cur_node->node_state = IN_OPEN_SET;\n\n  // \u5c06\u5f53\u524d\u70b9\u63a8\u5165open set\n  open_set_.push(cur_node);\n  // \u8fed\u4ee3\u6b21\u6570+1\n  use_node_num_ += 1;\n  // \u8bb0\u5f55\u5f53\u524d\u4e3a\u5df2\u6269\u5c55\n  expanded_nodes_.insert(cur_node->index, cur_node);\n\n  NodePtr terminate_node = NULL;\n\n  // \u641c\u7d22\u4e3b\u5faa\u73af\n  while (!open_set_.empty())\n  {\n    // \u83b7\u53d6f_score\u6700\u4f4e\u7684\u70b9\n    cur_node = open_set_.top();\n\n    // \u5224\u65ad\u7ec8\u6b62\u6761\u4ef6\n    bool reach_end = abs(cur_node->index(0) - end_index(0)) <= 1 &&\n                     abs(cur_node->index(1) - end_index(1)) <= 1 &&\n                     abs(cur_node->index(2) - end_index(2)) <= 1;\n\n    if (reach_end)\n    {\n      // \u5c06\u5f53\u524d\u70b9\u8bbe\u4e3a\u7ec8\u6b62\u70b9\uff0c\u5e76\u5f80\u56de\u5f62\u6210\u8def\u5f84\n      terminate_node = cur_node;\n      retrievePath(terminate_node);\n\n      return REACH_END;\n    }\n\n    /* ---------- pop node and add to close set ---------- */\n    open_set_.pop();\n    // \u5c06\u5f53\u524d\u70b9\u63a8\u5165close set\n    cur_node->node_state = IN_CLOSE_SET;  // in expand set\n    iter_num_ += 1;\n\n    /* ---------- init neighbor expansion ---------- */\n    Eigen::Vector3d cur_pos = cur_node->position;\n    Eigen::Vector3d expand_node_pos;\n\n    vector<Eigen::Vector3d> inputs;\n    Eigen::Vector3d d_pos;\n\n    /* ---------- expansion loop ---------- */\n    // \u6269\u5c55\uff1a 3*3*3 - 1 = 26\u79cd\u53ef\u80fd\n    for (double dx = -resolution_; dx <= resolution_ + 1e-3; dx += resolution_)\n    {\n      for (double dy = -resolution_; dy <= resolution_ + 1e-3; dy += resolution_)\n      {\n        // \u5c0f\u8f66\u662f\u4e8c\u7ef4\u89c4\u5212\uff0c\u56e0\u6b64Z\u8f74\u4e0d\u6269\u5c55\n        double dz = 0.0;\n\n        d_pos << dx, dy, dz;\n\n        // \u8df3\u8fc7\u81ea\u5df1\u90a3\u4e2a\u683c\u5b50\n        if (d_pos.norm() < 1e-3)\n        {\n          continue;\n        }\n\n        // \u6269\u5c55\u8282\u70b9\u7684\u4f4d\u7f6e\n        expand_node_pos = cur_pos + d_pos;\n\n        // \u786e\u8ba4\u8be5\u70b9\u5728\u5730\u56fe\u8303\u56f4\u5185\n        if(!Occupy_map_ptr->isInMap(expand_node_pos))\n        {\n          continue;\n        }\n\n        // \u8ba1\u7b97\u6269\u5c55\u8282\u70b9\u7684index\n        Eigen::Vector3i d_pos_id;\n        d_pos_id << int(dx/resolution_), int(dy/resolution_), int(dz/resolution_);\n        Eigen::Vector3i expand_node_id = d_pos_id + cur_node->index;\n\n        //\u68c0\u67e5\u5f53\u524d\u6269\u5c55\u7684\u70b9\u662f\u5426\u5728close set\u4e2d\uff0c\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        NodePtr expand_node = expanded_nodes_.find(expand_node_id);\n        if (expand_node != NULL && expand_node->node_state == IN_CLOSE_SET)\n        {\n          continue;\n        }\n\n        // \u68c0\u67e5\u5f53\u524d\u6269\u5c55\u70b9\u662f\u5426\u88ab\u5360\u636e,\u5982\u679c\u662f\u5219\u8df3\u8fc7\n        bool is_occupy = Occupy_map_ptr->getOccupancy(expand_node_pos);\n        if (is_occupy)\n        {\n          continue;\n        }\n\n        // \u5982\u679c\u80fd\u901a\u8fc7\u4e0a\u8ff0\u68c0\u67e5\u5219\n        double tmp_g_score, tmp_f_score;\n        tmp_g_score = d_pos.squaredNorm() + cur_node->g_score;\n        tmp_f_score = tmp_g_score + lambda_heu_ * getEuclHeu(expand_node_pos, end_pt) + lambda_cost_* Occupy_map_ptr->getCost(expand_node_pos);\n\n        // \u5982\u679c\u6269\u5c55\u7684\u5f53\u524d\u8282\u70b9\u4e3aNULL\uff0c\u5373\u672a\u6269\u5c55\u8fc7\n        if (expand_node == NULL)\n        {\n          expand_node = path_node_pool_[use_node_num_];\n          expand_node->index = expand_node_id;\n          expand_node->position = expand_node_pos;\n          expand_node->f_score = tmp_f_score;\n          expand_node->g_score = tmp_g_score;\n          expand_node->parent = cur_node;\n          expand_node->node_state = IN_OPEN_SET;\n\n          open_set_.push(expand_node);\n          expanded_nodes_.insert(expand_node_id, expand_node);\n\n          use_node_num_ += 1;\n          // \u8d85\u8fc7\u6700\u5927\u641c\u7d22\u6b21\u6570\n          if (use_node_num_ == max_search_num)\n          {\n            cout << RED << \\\"Astar search: [ Astar can't find path: reach the max_search_num ]\\\"  << TAIL <<endl;\n            return NO_PATH;\n          }\n        }\n        // \u5982\u679c\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6269\u5c55\u8fc7\uff0c\u5219\u66f4\u65b0\u5176\u72b6\u6001\n        else if (expand_node->node_state == IN_OPEN_SET)\n        {\n          if (tmp_g_score < expand_node->g_score)\n          {\n            // expand_node->index = expand_node_id;\n            expand_node->position = expand_node_pos;\n            expand_node->f_score = tmp_f_score;\n            expand_node->g_score = tmp_g_score;\n            expand_node->parent = cur_node;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // \u641c\u7d22\u5b8c\u6240\u6709\u53ef\u884c\u70b9\uff0c\u5373\u4f7f\u6ca1\u8fbe\u5230\u6700\u5927\u641c\u7d22\u6b21\u6570\uff0c\u4e5f\u6ca1\u6709\u627e\u5230\u8def\u5f84\n  // \u8fd9\u79cd\u4e00\u822c\u662f\u56e0\u4e3a\u65e0\u4eba\u673a\u5468\u56f4\u88ab\u5360\u636e\uff0c\u6216\u8005\u65e0\u4eba\u673a\u4e0e\u76ee\u6807\u70b9\u4e4b\u95f4\u65e0\u53ef\u901a\u884c\u8def\u5f84\u9020\u6210\u7684\n  cout << RED << \\\"Astar search: [ Astar can't find path: max_search_num: open set empty ]\\\"  << TAIL <<endl;\n  return NO_PATH;\n}", "CodeBleu_score": 35.77634888197579}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\u4ee3\u8868\u5168\u5c40\u70b9\u4e91\uff0c1\u4ee3\u8868\u5c40\u90e8\u70b9\u4e91\uff0c2\u4ee3\u8868\u6fc0\u5149\u96f7\u8fbescan\u6570\u636e\n    nh.param(\\\"global_planner_ugv/map_input_source\\\", map_input_source, 2);\n    //\u3010\u8ba2\u9605\u3011 \u6839\u636emap_input\u9009\u62e9\u5730\u56fe\u66f4\u65b0\u65b9\u5f0f\n    if(map_input_source == 0)\n    {\n        cout << GREEN << \\\"Global pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/global_pcl\\\" << TAIL <<endl;\n        Gpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/global_pcl\\\", 1, &GlobalPlannerUGV::Gpointcloud_cb, this);\n    }else if(map_input_source == 1)\n    {\n        cout << GREEN << \\\"Local pcl mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/local_pcl\\\" << TAIL <<endl;\n        Lpointcloud_sub = nh.subscribe<sensor_msgs::PointCloud2>(ugv_name + \\\"/prometheus/global_planner_ugv/local_pcl\\\", 1, &GlobalPlannerUGV::Lpointcloud_cb, this);\n    }else if(map_input_source == 2)\n    {\n        cout << GREEN << \\\"Laser scan mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/laser_scan\\\" << TAIL <<endl;\n        laserscan_sub = nh.subscribe<sensor_msgs::LaserScan>(ugv_name + \\\"/prometheus/global_planner_ugv/laser_scan\\\", 1, &GlobalPlannerUGV::laser_cb, this);\n    }\n\n    if(manual_mode)\n    {\n        cout << GREEN << \\\"Manual goal mode, subscirbe to \\\"<< ugv_name << \\\"/prometheus/global_planner_ugv/goal\\\" << TAIL <<endl;\n        // \u3010\u8ba2\u9605\u3011\u624b\u52a8\u7ed9\u5b9a\u76ee\u6807\u70b9\u6a21\u5f0f \u624b\u52a8\u76ee\u6807\u70b9\n        goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(ugv_name + \\\"/prometheus/global_planner_ugv/goal\\\", 1, &GlobalPlannerUGV::goal_cb, this);\n    }\n\n    // \u3010\u8ba2\u9605\u3011\u65e0\u4eba\u8f66\u72b6\u6001\n    ugv_state_sub = nh.subscribe<prometheus_msgs::UGVState>(ugv_name + \\\"/prometheus/ugv_state\\\", 10, &GlobalPlannerUGV::ugv_state_cb, this);\n\n    // \u3010\u8ba2\u9605\u3011\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    // for(int i = 1; i <= swarm_num_ugv; i++)\n    // {\n    //     if(i == ugv_id)\n    //     {\n    //         continue;\n    //     }\n    //     get_nei_odom[i] = false;\n    //     odom_nei[i] << 99.9,99.9,99.9;\n    //     nei_odom_sub[i] = nh.subscribe<nav_msgs::Odometry>(\\\"/ugv\\\"+std::to_string(i)+\\\"/prometheus/ugv_odom\\\", 10, boost::bind(&GlobalPlannerUGV::nei_odom_cb,this,_1,i));\n    // }\n\n    all_ugv_state_sub_ = nh.subscribe<prometheus_msgs::MultiUGVState>(\\\"/prometheus/all_ugv_state\\\", 1, &GlobalPlannerUGV::allUGVStateCb, this);\n    // \u3010\u5730\u9762\u7ad9\u4ea4\u4e92\u3011\u5730\u9762\u7ad9\u63a7\u5236\u6307\u4ee4\n    station_cmd_sub = nh.subscribe<prometheus_msgs::StationCommand>(ugv_name + \\\"/ground_station/ugv_cmd\\\", 1, &GlobalPlannerUGV::cmd_cb, this);\n\n\n    // \u3010\u53d1\u5e03\u3011 \u8def\u5f84\u6307\u4ee4 \uff08\u53d1\u9001\u81f3swarm_controller.cpp\uff09\n    command_pub = nh.advertise<prometheus_msgs::UGVCommand>(ugv_name + \\\"/prometheus/ugv_command\\\", 1);\n    // \u3010\u53d1\u5e03\u3011\u8def\u5f84\u7528\u4e8e\u663e\u793a\uff08rviz\u663e\u793a\uff09\n    path_cmd_pub   = nh.advertise<nav_msgs::Path>(ugv_name + \\\"/prometheus/global_planner_ugv/path_cmd\\\",  1);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u4e3b\u5faa\u73af\u6267\u884c\n    mainloop_timer = nh.createTimer(ros::Duration(0.1), &GlobalPlannerUGV::mainloop_cb, this);\n    // \u3010\u5b9a\u65f6\u5668\u3011\u8def\u5f84\u8ffd\u8e2a\n    track_path_timer = nh.createTimer(ros::Duration(track_frequency), &GlobalPlannerUGV::track_path_cb, this);\n\n    // \u3010\u5b9a\u65f6\u5668\u3011\u66f4\u65b0\u5176\u4ed6\u65e0\u4eba\u8f66\u4f4d\u7f6e\n    send_nei_odom_timer = nh.createTimer(ros::Duration(0.02), &GlobalPlannerUGV::send_nei_odom_cb, this);\n\n    // Astar algorithm\n    Astar_ptr.reset(new Astar);\n    Astar_ptr->init(nh);\n\n    // \u89c4\u5212\u5668\u72b6\u6001\u53c2\u6570\u521d\u59cb\u5316\n    exec_state = EXEC_STATE::INIT;\n    odom_ready = false;\n    ugv_ready = false;\n    get_goal = false;\n    station_ready = false;\n    sensor_ready = false;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 24.76814857949195}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t;\n    path_ok = false;\n    in_return_mode = false;\n    rotate_in_place = false;\n    start_move = false;\n    get_target_pos = false;\n    counter_search = 0;\n    yaw_ref = 0.0;\n\n    // \u624b\u52a8\u76ee\u6807\u70b9\u60c5\u51b5\uff0c\u4e0d\u9700\u8981\u5730\u9762\u7ad9\u6307\u4ee4\n    if(manual_mode)\n    {\n        station_ready = true;\n    }\n\n    // \u521d\u59cb\u5316\u53d1\u5e03\u7684\u6307\u4ee4\n    Command_Now.header.stamp = ros::Time::now();\n    Command_Now.Mode  = prometheus_msgs::UGVCommand::Hold;\n    Command_Now.Command_ID = 0;\n}", "CodeBleu_score": 31.00546324024495}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tvis_.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u4f20\u5165\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    input_point_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // tf\u53d8\u6362\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    transformed_cloud.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u8fc7\u6ee4\u540e\u70b9\u4e91\u6307\u9488\uff08\u4e34\u65f6\u6307\u9488\uff09\n    pcl_ptr.reset(new pcl::PointCloud<pcl::PointXYZ>);\n    // \u5c40\u90e8\u5730\u56fe\u6ed1\u7a97\u6307\u793a\u5668\n    st_it = 0;\n    // \u5b58\u50a8\u7684\u4e0a\u4e00\u5e27odom\n    f_x = f_y = f_z = f_pitch = f_yaw = f_roll = 0.0;\n\n    this->inv_resolution_ = 1.0 / resolution_;\n    for (int i = 0; i < 3; ++i)\n    {\n        // \u5360\u636e\u56fe\u5c3a\u5bf8 = \u5730\u56fe\u5c3a\u5bf8 / \u5206\u8fa8\u7387\n        grid_size_(i) = ceil(map_size_3d_(i) / resolution_);\n    }\n\n    // \u5360\u636e\u5bb9\u5668\u7684\u5927\u5c0f = \u5360\u636e\u56fe\u5c3a\u5bf8 x*y*z\n    occupancy_buffer_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    cost_map_.resize(grid_size_(0) * grid_size_(1) * grid_size_(2));\n    fill(occupancy_buffer_.begin(), occupancy_buffer_.end(), 0.0);\n    fill(cost_map_.begin(), cost_map_.end(), 0.0);\n\n    min_range_ = origin_;\n    max_range_ = origin_ + map_size_3d_;\n\n    min_range_(2) = ugv_height - 2*resolution_;\n    max_range_(2) = ugv_height + 2*resolution_;\n    get_gpcl = false;\n    get_lpcl = false;\n    get_laser = false;\n    // \u751f\u6210\u5730\u56fe\u8fb9\u754c\uff1a\u70b9\u4e91\u5f62\u5f0f\n\tdouble dist = 0.1; //\u6bcf\u591a\u5c11\u8ddd\u79bb\u4e00\u4e2a\u70b9\n\tint numdist_x = (max_range_(0)-min_range_(0))/dist; //x\u7684\u70b9\u6570\n\tint numdist_y = (max_range_(1)-min_range_(1))/dist; //y\u7684\u70b9\u6570\n\tint numdist = 2*(numdist_x+numdist_y); //\u603b\u70b9\u6570\n\tborder.width = numdist;\n    border.height = 1;\n    border.points.resize(numdist);\n\n    inflate_index_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 36.54603034164546}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tindex_ugv = 0;\n    ifn = ceil(odom_inflate_ * inv_resolution_);\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    for(int x = -ifn-1; x <= ifn+1; x++)\n        for(int y = -ifn-1; y <= ifn+1;)\n        {\n            enum_p_ugv[inflate_index_ugv++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn-1 || x == ifn+1) y++;\n            else y += 2*ifn+2;\n        }\n\n    // \u81a8\u80c0\u683c\u5b50\u6570 = \u81a8\u80c0\u8ddd\u79bb/\u5206\u8fa8\u7387\n    // ceil\u8fd4\u56de\u5927\u4e8e\u6216\u8005\u7b49\u4e8e\u6307\u5b9a\u8868\u8fbe\u5f0f\u7684\u6700\u5c0f\u6574\u6570\n    ifn = ceil(inflate_ * inv_resolution_);\n\n    inflate_index = 0;\n    for(int x = -ifn; x <= ifn; x++)\n        for(int y = -ifn; y <= ifn;)\n        {\n            enum_p[inflate_index++] << x*resolution_, y*resolution_, 0.0;\n            if(x == -ifn || x == ifn) y++;\n            else y += 2*ifn;\n        }\n\n    cost_index = 0;\n    // for(int x = -cost_inflate; x <= cost_inflate; x++)\n    //     for(int y = -cost_inflate; y <= cost_inflate; y++)\n    //     {\n    //         int tmp_dis = x*x + y*y;\n    //         if(tmp_dis <= cost_inflate*cost_inflate)\n    //         {\n    //             enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n    //         }\n\n    //     }\n    for(int x = -ifn-cost_inflate; x <= ifn+cost_inflate; x++)\n        for(int y = -ifn-cost_inflate; y <= ifn+cost_inflate;)\n        {\n            int tmp_dis = x*x + y*y;\n            if(tmp_dis <= (ifn+cost_inflate)*(ifn+cost_inflate))\n            {\n                enum_p_cost[cost_index++] << x*resolution_, y*resolution_, tmp_dis;\n            }\n            if(x == -ifn-cost_inflate || x == ifn+cost_inflate) y++;\n            else y += 2*ifn+2*cost_inflate;\n        }\n    printf(\\\"cost map %d %d\n\\\",cost_inflate,cost_index);\n\n    for(int i=0 ; i<numdist_x; i++) //x\u8fb9\u754c\n    {\n        border.points[i].x = min_range_(0)+i*dist;\n        border.points[i].y = min_range_(1);\n        border.points[i].z = min_range_(2);\n\n        border.points[i+numdist_x].x = min_range_(0)+i*dist;\n        border.points[i+numdist_x].y = max_range_(1);\n        border.points[i+numdist_x].z = min_range_(2);\n\t}\n\n    for(int i=0 ; i<numdist_y; i++) //y\u8fb9\u754c\n    {\n        border.points[i+2*numdist_x].x = min_range_(0);\n        border.points[i+2*numdist_x].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x].z = min_range_(2);\n\n        border.points[i+2*numdist_x+numdist_y].x = max_range_(0);\n        border.points[i+2*numdist_x+numdist_y].y = min_range_(1)+i*dist;\n        border.points[i+2*numdist_x+numdist_y].z = min_range_(2);\n    }\n}", "CodeBleu_score": 39.602508252452886}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tj = 0; j < inflate_index_ugv; j++)\n            {\n                pt.x = input_ugv_odom[i][0] + enum_p_ugv[j](0);\n                pt.y = input_ugv_odom[i][1] + enum_p_ugv[j](1);\n                pt.z = input_ugv_odom[i][2] + enum_p_ugv[j](2);\n\n                global_ugv_pcl->points.push_back(pt);\n            }\n    }", "CodeBleu_score": 41.37703754763237}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t:\n        path_ok = false;\n\n        // \u4fdd\u6301\u5230\u6307\u5b9a\u9ad8\u5ea6\n        if (abs(fly_height - uav_pos[2]) > MIN_DIS)\n        {\n            uav_command.header.stamp = ros::Time::now();\n            uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Move;\n            uav_command.Move_mode = prometheus_msgs::UAVCommand::XYZ_POS;\n            uav_command.position_ref[0] = uav_pos[0];\n            uav_command.position_ref[1] = uav_pos[1];\n            uav_command.position_ref[2] = fly_height;\n            uav_command.yaw_ref = 0;\n            uav_command.Command_ID = uav_command.Command_ID + 1;\n            uav_cmd_pub.publish(uav_command);\n        }\n        else if (goal_ready)\n        {\n            // \u83b7\u53d6\u5230\u76ee\u6807\u70b9\u540e\uff0c\u751f\u6210\u65b0\u8f68\u8ff9\n            exec_state = EXEC_STATE::PLANNING;\n            goal_ready = false;\n        }\n\n        break;\n    case EXEC_STATE::PLANNING:\n        // \u91cd\u7f6e\u89c4\u5212\u5668\n        Astar_ptr->reset();\n        // \u4f7f\u7528\u89c4\u5212\u5668\u6267\u884c\u641c\u7d22\uff0c\u8fd4\u56de\u641c\u7d22\u7ed3\u679c\n        int astar_state;\n        astar_state = Astar_ptr->search(uav_pos, goal_pos);\n\n        // \u672a\u5bfb\u627e\u5230\u8def\u5f84\n        if (astar_state == Astar::NO_PATH)\n        {\n            path_ok = false;\n            exec_state = EXEC_STATE::WAIT_GOAL;\n            cout << RED << NODE_NAME << \\\" Planner can't find path!\\\" << TAIL << endl;\n        }\n        else\n        {\n            path_ok = true;\n            is_new_path = true;\n            path_cmd = Astar_ptr->get_ros_path();\n            Num_total_wp = path_cmd.poses.size();\n            start_point_index = get_start_point_id();\n            cur_id = start_point_index;\n            last_replan_time = ros::Time::now();\n            exec_state = EXEC_STATE::TRACKING;\n            path_cmd_pub.publish(path_cmd);\n            cout << GREEN << NODE_NAME << \\\" Get a new path!\\\" << TAIL << endl;\n        }\n\n        break;\n\n    case EXEC_STATE::TRACKING:\n    {\n        if ( (ros::Time::now()-last_replan_time).toSec() >= replan_time)\n        {\n            exec_state = EXEC_STATE::PLANNING;\n        }\n\n        break;\n    }\n    case EXEC_STATE::LANDING:\n    {\n        uav_command.header.stamp = ros::Time::now();\n        uav_command.Agent_CMD = prometheus_msgs::UAVCommand::Land;\n        uav_command.Command_ID = uav_command.Command_ID + 1;\n\n        uav_cmd_pub.publish(uav_command);\n        break;\n    }\n    }", "CodeBleu_score": 41.80897343091505}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Calculate target foot positions\n  base_.setPose(req_pose_);\n  base_.setVelocity(req_vel_);\n  base_.setAcceleration(req_acc_);\n  base_.setJointTorques(req_torques_);\n  base_.setGravity(req_gravity_);\n  base_.setMass(req_mass_);\n  base_.setMomentOfInertia(req_moment_of_inertia_);\n  base_.setJointDamping(req_damping_);\n  base_.setJointLimit(req_joint_limit_);\n  base_.setGaitConfig(gait_config_);\n  base_.setContact(req_contact_);\n  base_.setContactForce(req_contact_force_);\n  base_.setContactStiffness(req_contact_stiffness_);\n  base_.setContactDamping(req_contact_damping_);\n  base_.setContactRestitution(req_contact_restitution_);\n  base_.setContactMu(req_contact_mu_);\n  base_.setContactFrictions(req_contact_frictions_);\n  base_.setContactStates(req_contact_states_);\n  base_.setContactMu(req_contact_mu_);\n  base_.setContactFrictions(req_contact_frictions_);\n  base_.setContactStates(req_contact_states_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(req_contact_forces_);\n  base_.setContactForces(", "CodeBleu_score": 31.45329348969027}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n    ros::Time now = ros::Time::now();\n    // Compute the time since the last control loop\n    ros::Duration dt = now - last_control_loop_;\n    // Update the body controller\n    body_controller_.update(dt);\n    // Compute the target foot positions\n    base_.computeTargetFootPositions(req_pose_, dt);\n    // Compute the leg commands\n    leg_controller_.computeLegCommands(base_.target_foot_positions_, dt);\n    // Compute the joint positions\n    kinematics_.computeJointPositions(base_.target_foot_positions_, dt);\n    // Publish foot contact information\n    if(publish_foot_contacts_ && !in_gazebo_)\n    {\n        champ_msgs::ContactsStamped contacts;\n        contacts.header.stamp = now;\n        contacts.contacts = base_.foot_contacts_;\n        foot_contacts_publisher_.publish(contacts);\n    }\n\n    // Publish joint states\n    if(publish_joint_states_ && !in_gazebo_)\n    {\n        sensor_msgs::JointState joint_state;\n        joint_state.header.stamp = now;\n        joint_state.name = joint_names_;\n        joint_state.position = kinematics_.joint_positions_;\n        joint_states_publisher_.publish(joint_state);\n    }\n\n    // Publish joint commands\n    if(publish_joint_control_)\n    {\n        trajectory_msgs::JointTrajectory joint_command;\n        joint_command.header.stamp = now;\n        joint_command.joint_names = joint_names_;\n        joint_command.points.resize(1);\n        joint_command.points[0].positions = kinematics_.joint_positions_;\n        joint_command.points[0].velocities.resize(kinematics_.joint_positions_.size(), 0.0);\n        joint_command.points[0].time_from_start = ros::Duration(0.0);\n        joint_", "CodeBleu_score": 45.61972982961664}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the time since the last control loop\n    double dt = event.current_real.toSec() - event.last_real.toSec();\n    // Get the current time\n    champ::PhaseGenerator::Time t = rosTimeToChampTime(ros::Time::now());\n    // Get the current robot pose\n    champ::Quadruped::Pose pose = kinematics_.getPose(t);\n    // Get the current robot velocity\n    champ::Quadruped::Velocity velocity = kinematics_.getVelocity(t);\n    // Get the current robot foot positions\n    std::vector<champ::Quadruped::FootPose> foot_positions = kinematics_.getFootPositions(t);\n    // Get the current robot joint positions\n    std::vector<double> joint_positions = kinematics_.getJointPositions(t);\n    // Get the current robot foot velocities\n    std::vector<champ::Quadruped::FootVelocity> foot_velocities = kinematics_.getFootVelocities(t);\n    // Get the current robot joint velocities\n    std::vector<double> joint_velocities = kinematics_.getJointVelocities(t);\n    // Get the current robot foot accelerations\n    std::vector<champ::Quadruped::FootAcceleration> foot_accelerations = kinematics_.getFootAccelerations(t);\n    // Get the current robot joint accelerations\n    std::vector<double> joint_accelerations = kinematics_.getJointAccelerations(t);\n    // Get the current robot foot wrenches\n    std::vector<champ::Quadruped::FootWrench> foot_wrenches = kinematics_.getFootWrenches(t);\n    // Get the current robot joint wrenches\n    std::vector<double> joint_wrenches = kinematics_.getJointWrenches(t);\n    // Get the current robot contact information\n    std::vector<bool> contact_information = kinematics_.getContactInformation(t);\n    // Get the current robot leg contact information\n    std::vector<champ", "CodeBleu_score": 42.76060770274572}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t/ 1000ul;\n}", "CodeBleu_score": 3.2687518763694046}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\tjoints_cmd = Joints()\n    joints_cmd.header.stamp = rospy.Time.now()\n    joints_cmd.header.frame_id = 'base_link'\n    joints_cmd.name = self.joint_names\n    joints_cmd.position = joints.position[:12]\n    self.joint_minimal_pub.publish(joints_cmd)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header.stamp = rospy.Time.now()\n    joint_trajectory.header.frame_id = 'base_link'\n    joint_trajectory.joint_names = self.joint_names\n\n    joint_trajectory_point = JointTrajectoryPoint()\n    joint_trajectory_point.positions = joints.position[:12]\n    joint_trajectory_point.time_from_start = rospy.Duration(1.0)\n    joint_trajectory.points.append(joint_trajectory_point)\n\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 50.40248249593036}, {"code": "def joints_cmd_callback(self, joints){\n\tjoints_cmd = Joints()\n    joints_cmd.header.stamp = rospy.get_rostime()\n    joints_cmd.header.frame_id = \"base_link\"\n    joints_cmd.names = self.joint_names\n    joints_cmd.positions = joints.position[0:12]\n    self.joint_minimal_pub.publish(joints_cmd)\n\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header.stamp = rospy.get_rostime()\n    joint_trajectory.header.frame_id = \"base_link\"\n    joint_trajectory.joint_names = self.joint_names\n    joint_trajectory.points = [JointTrajectoryPoint()]\n    joint_trajectory.points[0].positions = joints.position[0:12]\n    joint_trajectory.points[0].time_from_start = rospy.Duration(1.0)\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 45.313869554181856}, {"code": "def joints_cmd_callback(self, joints){\n\trospy.loginfo(\"joints_cmd_callback\")\n    joints_cmd = Joints()\n    joints_cmd.header.stamp = rospy.Time.now()\n    joints_cmd.header.frame_id = \"base_link\"\n    joints_cmd.joints = joints.position[:12]\n    self.joint_minimal_pub.publish(joints_cmd)\n    joints_traj = JointTrajectory()\n    joints_traj.header.stamp = rospy.Time.now()\n    joints_traj.header.frame_id = \"base_link\"\n    joints_traj.joint_names = self.joint_names\n    joints_traj.points.append(JointTrajectoryPoint())\n    joints_traj.points[0].positions = joints.position[:12]\n    joints_traj.points[0].time_from_start = rospy.Duration(1.0)\n    self.joint_trajectory_pub.publish(joints_traj)\n}", "CodeBleu_score": 48.93839308555986}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision_name = _msg->contact(i).collision2();\n\t\tstd::vector<std::string> parts;\n\t\tboost::split(parts, collision_name, boost::is_any_of(\"/\"));\n\t\tstd::string link_name = parts[parts.size() - 1];\n\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (link_name == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 55.72791031509061}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor(int i=0; i<_msg->contact_size(); i++) {\n\t\tstd::string collision_name = _msg->contact(i).collision2();\n\t\tstd::vector<std::string> collision_names;\n\t\tboost::split(collision_names, collision_name, boost::is_any_of(\"::\"));\n\t\tif(collision_names.size() != 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tstd::string collision_link = collision_names[1];\n\t\tfor(int j=0; j<4; j++) {\n\t\t\tif(collision_link == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.38209305693477}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor(int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> contact_strs;\n\t\tboost::split(contact_strs, _msg->contact(i).collision2(), boost::is_any_of(\"_\"));\n\t\tstd::string contact_link = contact_strs[0];\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(contact_link == foot_links_[j]) {\n\t\t\t\tfoot_contacts_[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.816382961861535}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: controller parameters not initialized.\");\n    return;\n  }\n  if (!initialized_input_) {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: input not initialized.\");\n    return;\n  }\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n  // Calculate desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration = normalized_attitude_gain_ * (desired_attitude_ - attitude_);\n  Eigen::Vector3d desired_angular_acceleration = normalized_angular_rate_gain_ * (desired_angular_rate_ - angular_rate_);\n  // Calculate thrust and angular acceleration in body frame.\n  Eigen::Vector3d thrust = normalized_attitude_gain_ * (desired_thrust_ - thrust_);\n  Eigen::Vector3d angular_acceleration = normalized_angular_rate_gain_ * (desired_angular_rate_ - angular_rate_);\n  // Project thrust onto the body z-axis.\n  thrust.z() = 0;\n  angular_acceleration.z() = 0;\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector4d angular_acc_thrust;\n  angular_acc_thrust << angular_acceleration, thrust;\n  // Calculate the rotor velocities.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acc_thrust;\n  // Take the square root of each component.\n  for (int i = 0; i < rotor_velocities->size(); ++i) {\n    (*rotor_velocities)(i) = sqrt((*rotor_velocities)(i));\n  }\n  // Make sure the rotor velocities are non-negative.\n  for (int i = 0; i < rotor_velocities->size();", "CodeBleu_score": 47.003301025867664}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t// Check if the controller is active and if the input is valid.\n  if (!controller_active_ || !initialized_params_) {\n    rotor_velocities->setZero(vehicle_parameters_.rotor_configuration_.rotors.size());\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration, desired_angular_acceleration;\n  CalculateDesiredAccelerationAndAngularAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  // Project thrust onto the body z-axis and combine angular acceleration and thrust into a single vector.\n  Eigen::Vector4d desired_acceleration_and_angular_acceleration;\n  desired_acceleration_and_angular_acceleration.head<3>() = desired_acceleration;\n  desired_acceleration_and_angular_acceleration.tail<1>() = desired_angular_acceleration.norm();\n\n  // Compute the rotor velocities by multiplying with a predefined matrix.\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * desired_acceleration_and_angular_acceleration;\n\n  // Ensure non-negative values.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)(i) < 0) {\n      (*rotor_velocities)(i) = 0;\n    }\n  }\n\n  // Take the square root of each component.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    (*rotor_velocities)(i) = std::sqrt((*rotor_velocities)(i));\n  }\n}", "CodeBleu_score": 47.82257018348673}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: Controller not initialized.\");\n    return;\n  }\n  if (!controller_active_) {\n    for (int i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); i++) {\n      (*rotor_velocities)(i) = 0;\n    }\n    return;\n  }\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  Eigen::Vector3d desired_thrust;\n  Eigen::Vector3d desired_torque;\n  Eigen::Vector3d desired_rotor_velocities;\n\n  // Calculate the desired acceleration and angular acceleration.\n  if (vehicle_parameters_.rotor_configuration_.rotors.size() == 4) {\n    desired_acceleration = -normalized_attitude_gain_ * attitude_error_;\n    desired_angular_acceleration = -normalized_angular_rate_gain_ * angular_rate_error_;\n  } else if (vehicle_parameters_.rotor_configuration_.rotors.size() == 6) {\n    desired_acceleration = -normalized_attitude_gain_ * attitude_error_;\n    desired_angular_acceleration = -normalized_angular_rate_gain_ * angular_rate_error_;\n  } else {\n    ROS_ERROR(\"LeePositionController::CalculateRotorVelocities: Invalid number of rotors.\");\n    return;\n  }\n\n  // Calculate the desired thrust and torque.\n  desired_thrust = -controller_parameters_.thrust_gain_ * (desired_acceleration - vehicle_parameters_.gravity_);\n  desired_torque = -controller_parameters_.torque_gain_ * angular_rate_error_;\n\n  // Calculate the desired rotor velocities.\n  desired_rotor_velocities = angular_acc_to_rotor_velocities_ * (desired_angular_acceleration +", "CodeBleu_score": 40.031345558968326}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n  assert(controller_active_);\n\n  // Transform the commanded velocity to the world frame.\n  Eigen::Vector3d commanded_velocity_world_frame =\n      odometry_.orientation.toRotationMatrix() * command_trajectory_.velocity;\n\n  // Compute the position error.\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Compute the velocity error.\n  Eigen::Vector3d velocity_error = commanded_velocity_world_frame - odometry_.velocity;\n\n  // Compute the desired acceleration.\n  *acceleration = (controller_parameters_.position_gain_ * position_error)\n      + (controller_parameters_.velocity_gain_ * velocity_error)\n      + (controller_parameters_.mass_ * vehicle_parameters_.gravity_)\n      + command_trajectory_.acceleration;\n}", "CodeBleu_score": 51.83368124826252}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n\n  // Transform the commanded velocity to the world frame.\n  Eigen::Vector3d commanded_velocity_world = odometry_.orientation.toRotationMatrix() * command_trajectory_.velocity;\n\n  // Compute the position error.\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Compute the velocity error.\n  Eigen::Vector3d velocity_error = commanded_velocity_world - odometry_.velocity;\n\n  // Compute the desired acceleration.\n  *acceleration = (position_error.cwiseProduct(controller_parameters_.position_gain_)).cwiseProduct(vehicle_parameters_.mass_) +\n                  (velocity_error.cwiseProduct(controller_parameters_.velocity_gain_)).cwiseProduct(vehicle_parameters_.mass_) +\n                  (command_trajectory_.acceleration.cwiseProduct(controller_parameters_.acceleration_gain_));\n}", "CodeBleu_score": 54.247063945884975}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n  assert(initialized_params_);\n  // Return 0 acceleration on all axes, until the first command is received.\n  if (!controller_active_) {\n    *acceleration = Eigen::Vector3d::Zero();\n    return;\n  }\n\n  // Transform the commanded velocity to the world frame.\n  Eigen::Vector3d commanded_velocity_world;\n  Eigen::Quaterniond orientation_quat(odometry_.orientation.w, odometry_.orientation.x, odometry_.orientation.y, odometry_.orientation.z);\n  commanded_velocity_world = orientation_quat * command_trajectory_.velocity;\n\n  // Compute the position error.\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Compute the velocity error.\n  Eigen::Vector3d velocity_error = commanded_velocity_world - odometry_.velocity;\n\n  // Compute the desired acceleration.\n  *acceleration = normalized_attitude_gain_ * position_error + normalized_angular_rate_gain_ * velocity_error;\n}", "CodeBleu_score": 49.440681959684596}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: not initialized\" << std::endl;\n    return;\n  }\n  if (rotor_velocities == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: null pointer\" << std::endl;\n    return;\n  }\n  if (rotor_velocities->size() != amount_rotors_) {\n    rotor_velocities->resize(amount_rotors_);\n  }\n  rotor_velocities->setZero();\n\n  // Calculate desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  angular_acceleration.setZero();\n  angular_acceleration = angular_acc_to_rotor_velocities_ * thrust_reference_;\n\n  // Calculate rotor velocities\n  for (int i = 0; i < amount_rotors_; i++) {\n    (*rotor_velocities)(i) = sqrt(std::max(1.0, angular_acceleration.dot(angular_velocities_[i])));\n  }\n}", "CodeBleu_score": 45.39127365798249}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (rotor_velocities == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is a nullptr\" << std::endl;\n    return;\n  }\n  if (!initialized_params_) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: parameters are not initialized\" << std::endl;\n    return;\n  }\n  if (rotor_velocities->size() != amount_rotors_) {\n    rotor_velocities->resize(amount_rotors_);\n  }\n  if (thrust_reference_ == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference is a nullptr\" << std::endl;\n    return;\n  }\n  if (attitude_reference_ == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: attitude_reference is a nullptr\" << std::endl;\n    return;\n  }\n  if (angular_rate_reference_ == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: angular_rate_reference is a nullptr\" << std::endl;\n    return;\n  }\n  if (angular_acceleration_reference_ == nullptr) {\n    std::cout << \"AttitudeControllerSamy::CalculateRotorVelocities: angular_acceleration_reference is a nullptr\" << std::endl;\n    return;\n  }\n  if (rotor_velocities->size() != amount_rotors_) {\n    rotor_velocities->resize(amount_rotors_);\n  }\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * (thrust_reference_->cwiseProduct(*attitude_reference_) + angular_acceleration_reference_->cwiseProduct(*angular_rate_reference_));\n  rotor_velocities->array() = rotor_velocities->array().max(1);", "CodeBleu_score": 46.57721198277933}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!initialized_params_) {\n    ROS_ERROR(\"AttitudeControllerSamy::CalculateRotorVelocities: The parameters have not been initialized.\");\n    return;\n  }\n  if (rotor_velocities == nullptr) {\n    ROS_ERROR(\"AttitudeControllerSamy::CalculateRotorVelocities: The rotor velocities vector is a nullptr.\");\n    return;\n  }\n  if (rotor_velocities->size() != amount_rotors_) {\n    ROS_ERROR_STREAM(\"AttitudeControllerSamy::CalculateRotorVelocities: The rotor velocities vector has the wrong size. Expected \" << amount_rotors_ << \", got \" << rotor_velocities->size());\n    return;\n  }\n\n  Eigen::Vector4d angular_acc;\n  angular_acc.setZero();\n\n  angular_acc = angular_acc_to_rotor_velocities_ * (thrust_reference_ - gravity_ * mass_);\n\n  // TODO: Check if this is correct\n  for (int i = 0; i < amount_rotors_; i++) {\n    rotor_velocities->coeffRef(i) = std::max(angular_acc.coeff(i), 0.0);\n  }\n}", "CodeBleu_score": 41.78541234838217}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\tstart_index = numpy.where(self.bag_time >= start_time)[0][0]\n    end_index = numpy.where(self.bag_time >= end_time)[0][0]\n    if end_index > len(self.bag_time):\n        end_index = len(self.bag_time)\n    copy_object = copy.deepcopy(self)\n    copy_object.time = self.time[start_index:end_index]\n    copy_object.bag_time = self.bag_time[start_index:end_index]\n    return copy_object\n\n", "CodeBleu_score": 48.29580697459488}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.bag_time.searchsorted(start_time)\n    end_index = self.bag_time.searchsorted(end_time)\n    if start_index == len(self.bag_time) or start_index == 0:\n        print(\"Warning: start_time is not in bag_time.\")\n        return\n    if end_index == len(self.bag_time) or end_index == 0:\n        print(\"Warning: end_time is not in bag_time.\")\n        return\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.bag_time = self.bag_time[start_index:end_index]\n    return sliced_object\n\n", "CodeBleu_score": 42.561727519768525}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = numpy.searchsorted(self.bag_time, start_time)\n    end_index = numpy.searchsorted(self.bag_time, end_time)\n    if end_index > len(self.bag_time):\n        end_index = len(self.bag_time)\n    if start_index == 0:\n        start_index = 1\n    if end_index == 0:\n        end_index = 1\n    if start_index > end_index:\n        start_index = end_index\n    copy = copy.deepcopy(self)\n    copy.time = copy.time[start_index:end_index]\n    copy.bag_time = copy.bag_time[start_index:end_index]\n    return copy\n\n", "CodeBleu_score": 44.80399094489494}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tif not self.empty:\n        if (waypoint_msg.pose.position.x == self.x[-1]) and (waypoint_msg.pose.position.y == self.y[-1]) and (waypoint_msg.pose.position.z == self.z[-1]) and (waypoint_msg.pose.orientation.w == self.yaw[-1]):\n            return\n    self.append_point(waypoint_msg.pose.position)\n    quat = Quaternion()\n    quat.x = waypoint_msg.pose.orientation.x\n    quat.y = waypoint_msg.pose.orientation.y\n    quat.z = waypoint_msg.pose.orientation.z\n    quat.w = waypoint_msg.pose.orientation.w\n    euler = tf.transformations.euler_from_quaternion(quat)\n    self.append_yaw(euler[2])\n    self.append_times(msg_time, bag_time)\n    self.empty = False\n\n", "CodeBleu_score": 31.9541524614415}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Convert the rotation to Euler angles.\n    euler_angles = tf.transformations.euler_from_quaternion(\n        [waypoint_msg.pose.orientation.x, waypoint_msg.pose.orientation.y, waypoint_msg.pose.orientation.z, waypoint_msg.pose.orientation.w])\n    # Create a Point object for the position.\n    point = Point()\n    point.x = waypoint_msg.pose.position.x\n    point.y = waypoint_msg.pose.position.y\n    point.z = waypoint_msg.pose.position.z\n    # Check if the waypoint is different from the last one.\n    if not self.empty:\n        if not (self.point.x == point.x and self.point.y == point.y and self.point.z == point.z and self.yaw == euler_angles[2]):\n            # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays.\n            self.point.append_point(point)\n            self.yaw.append(euler_angles[2])\n            self.time.append(msg_time)\n            self.bag_time.append(bag_time)\n    else:\n        # If the waypoint is the first one, append the point and yaw to their respective arrays.\n        self.point.append_point(point)\n        self.yaw.append(euler_angles[2])\n        self.time.append(msg_time)\n        self.bag_time.append(bag_time)\n        self.empty = False\n\n", "CodeBleu_score": 26.470229814624545}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tif self.empty:\n        self.empty = False\n        self.append_point(waypoint_msg.pose.position)\n        self.append_yaw(waypoint_msg.pose.orientation)\n        self.append_times(msg_time, bag_time)\n    else:\n        if waypoint_msg.pose.position.x != self.x[-1] or waypoint_msg.pose.position.y != self.y[-1] or waypoint_msg.pose.position.z != self.z[-1] or waypoint_msg.pose.orientation.z != self.yaw[-1]:\n            self.append_point(waypoint_msg.pose.position)\n            self.append_yaw(waypoint_msg.pose.orientation)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 24.46462976276755}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t= numpy.append(self.yaw, yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 4.762547370354892}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t, settling_radius, 'settling radius',\n                        color='r')\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('position error [m]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 51.13789280240392}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 24.627178874169726}, {"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 24.627178874169726}, {"code": "def compare_positions(self, pose_indeces)\n\t.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_pos_error' if self.prefix else 'pos_error'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n\n\n", "CodeBleu_score": 24.627178874169726}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 19.71800647003772}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 19.71800647003772}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_angular_velocities(self, start_time=None, end_time=None,\n                                settling_time=None, x_range=None, y_range=None,\n                                plot_suffix=None):\n        \\\"\\\"\\\"Plot all angular_velocity lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Angular Velocity\\\")\n        a_x = fig.add_subplot(111)\n        for index, pqr in enumerate(self.pqr):\n            a_x.plot(pqr.time, pqr.x, 'b', label='x')\n            a_x.plot(pqr.time, pqr.y, 'r', label='y')\n            a_x.plot(pqr.time, pqr.z, 'g', label='z')\n\n        if not y_range:\n            y_max = max([max(pqr.x), max(pqr.y), max(pqr.z)])\n            y_min = min([min(pqr.x), min(pqr.y), min(pqr.z)])\n        else:\n            y_max = y_range[1]\n            y_min = y_range[0]\n        y_center = (y_max + y_min)/2.0\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n            pyplot.text(start_time, y_center, 'start evaluation', rotation=90,\n                        color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n            pyplot.text(end_time, y_max, 'end evaluation', rotation=90,\n                        color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n            pyplot.text(settling_time, y_max, 'settled, start RMS eval',\n                        rotation=90, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angular velocity [rad/s]')\n        # Shrink current axis's height by 10% on the bottom\n        box = a_x.get_position()\n        a_x.set_position([box.x0, box.y0 + box.height * 0.2,\n                         box.width, box.height * 0.8])\n\n        # Put a legend below current axis\n        a_x.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),\n                   fancybox=True, shadow=True, ncol=5)\n        pyplot.xlim(x_range)\n        pyplot.ylim(y_range)\n        pyplot.grid(b=True, which='both')\n\n        if self.save_plots:\n            file_name = self.prefix + '_angular_velocity' if self.prefix else 'angular_velocity'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_3d_trajectories(self):\n        fig = pyplot.figure()\n        a_x = fig.add_subplot(111, projection='3d')\n        for index, pos in enumerate(self.pos):\n            a_x.plot(pos.x, pos.y, pos.z, label=self.pose_topics[index])\n        # pyplot.show()\n\n    def plot_rpys(self, start_time=None, end_time=None, settling_time=None,\n                  plot_suffix=None):\n        \\\"\\\"\\\"Plot rpy lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"RPY\\\")\n        a_x = fig.add_subplot(111)\n        for index, rpy in enumerate(self.rpy):\n            a_x.plot(rpy.time, rpy.roll, 'b',\n                     label='roll' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.pitch, 'r',\n                     label='pitch' + self.pose_topics[index])\n            a_x.plot(rpy.time, rpy.yaw, 'g',\n                     label='yaw' + self.pose_topics[index])\n\n        if start_time:\n            a_x.axvline(x=start_time, color='c')\n        if end_time:\n            a_x.axvline(x=end_time, color='m')\n        if settling_time:\n            a_x.axvline(x=settling_time, color='k')\n\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('angle [deg]')\n        pyplot.legend()\n\n        if self.save_plots:\n            file_name = self.prefix + '_rpy' if self.prefix else 'rpy'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n\n        # pyplot.show()\n\n    def plot_accelerations(self, plot_suffix=None):\n        \\\"\\\"\\\"Plot all acceleration lists.\\\"\\\"\\\"\n        fig = pyplot.figure()\n        fig.suptitle(\\\"Accelerations\\\")\n        a_x = fig.add_subplot(111)\n        for index, acc in enumerate(self.acc):\n            a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n            a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n        pyplot.xlabel('time [s]')\n        pyplot.ylabel('acceleration [m/s^2]')\n        pyplot.legend()\n        if self.save_plots:\n            file_name = self.prefix + '_acc' if self.prefix else 'acc'\n            if plot_suffix:\n                file_name += '_' + str(plot_suffix)\n            file_name += '.png'\n            pyplot.savefig(file_name)\n        # pyplot.show()\n\n    def compare_positions(self, pose_indeces):\n        \\\"\\\"\\\"\n        Compare the position lists of pose_topics.\n\n        Args:\n           pose_indeces (list): Indeces of pose_topics for comparison.\n        \\\"\\\"\\\"\n        if len(pose_indeces) < 2:\n            print(\\\"At least two pose_indeces need to be provided to make a \\\"\n                  \\\"comparison\\\")\n        for index, pose_index in enumerate(pose_indeces):\n            for pose_index_cmp in pose_indeces[index+1:]:\n                compare_two_xyz(self.pos[pose_index],\n                                self.pos[pose_index_cmp])\n\n\n\n", "CodeBleu_score": 19.71800647003772}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\tocity topic that you want to extract from the bag \\\"\n             \\\"file.\\\")\n    parser.add_option(\n        \\\"-w\\\", \\\"--waypoint_topic\\\",\n        dest=\\\"waypoint_topic\\\",\n        default=default_waypoint_topic,\n        type=\\\"string\\\",\n        help=\\\"The waypoint topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-W\\\", \\\"--wrench_topic\\\",\n        dest=\\\"wrench_topic\\\",\n        default=default_wrench_topic,\n        type=\\\"string\\\",\n        help=\\\"The wrench topic that you want to extract from the bag file.\\\")\n    parser.add_option(\n        \\\"-D\\\", \\\"--delay_first_evaluation\\\",\n        dest=\\\"first_waypoint_delay\\\",\n        default=default_first_waypoint_delay,\n        type=\\\"float\\\",\n        help=\\\"The time when the evaluation should start after the first \\\"\n             \\\"waypoint got published.\\\")\n    parser.add_option(\n        \\\"-n\\\", \\\"--mav_name\\\",\n        dest=\\\"mav_name\\\",\n        default=default_mav_name,\n        type=\\\"string\\\",\n        help=\\\"The name of your MAV (should correspond to the namespace).\\\")\n\n    (options, args) = parser.parse_args()\n    if not options.bagfile:\n        parser.error('Bagfile not given.')\n    mav_name = options.mav_name\n    topic_prefix = mav_name\n    save_plots = options.save_plots\n    prefix = options.prefix\n    bagfile = options.bagfile\n    pose_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.pose_topic)\n    twist_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.twist_topic)\n    motor_velocity_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.motor_velocity_topic)\n    waypoint_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.waypoint_topic)\n    wrench_topics = analyze_bag.create_topic_list(\n        topic_prefix + options.wrench_topic)\n    plot = True if (options.plot and options.plot.lower() == 'true') else False\n    if save_plots:\n        plot = True\n    begin_time = options.begin\n    total_end_time = options.end\n    rms_calc_time = options.rms_calc_time\n    settling_radius = options.settling_radius\n    min_settled_time = options.min_settled_time\n    first_waypoint_evaluation_delay = options.first_waypoint_delay\n\n    # Create a new Analyze bag object, to do the evaluation on.\n    ab = analyze_bag.AnalyzeBag(bag_path_name=bagfile, save_plots=save_plots,\n                                prefix=prefix)\n\n    # Add all the topics of the different message types.\n    for pose_topic in pose_topics:\n        ab.add_pose_topic(pose_topic)\n    for twist_topic in twist_topics:\n        ab.add_twist_topic(twist_topic)\n    for motor_velocity_topic in motor_velocity_topics:\n        ab.add_motor_velocity_topic(motor_velocity_topic)\n    for waypoint_topic in waypoint_topics:\n        ab.add_waypoint_topic(waypoint_topic)\n    for wrench_topic in wrench_topics:\n        ab.add_wrench_topic(wrench_topic)\n    if len(ab.topics):\n        ab.extract_messages()\n\n    return [ab, plot, begin_time, total_end_time, rms_calc_time,\n            settling_radius, min_settled_time, first_waypoint_evaluation_delay]\n\n", "CodeBleu_score": 27.46298957836728}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier\n  const float multiplier = this->GetMultiplier(width, height);\n\n  // Map to Eigen vector\n  Eigen::Map<Eigen::VectorXf> depth_map(data, width * height);\n\n  // Compute RMS noise\n  const float rms_noise = this->ComputeRMSNoise(depth_map);\n\n  // Compute noise values\n  Eigen::VectorXf noise_values = this->ComputeNoiseValues(rms_noise, multiplier);\n\n  // Add noise\n  for (size_t i = 0; i < depth_map.size(); ++i) {\n    if (this->InRange(depth_map[i])) {\n      depth_map[i] += noise_values[i];\n    } else {\n      depth_map[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 48.54456390892612}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier\n  float multiplier = this->noise_multiplier * (this->max_depth - this->min_depth) /\n                     (this->max_depth_noise - this->min_depth_noise);\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::MatrixXf> depth_map(data, width, height);\n  // Calculate RMS noise\n  float rms_noise = this->GetRMSNoise(depth_map);\n  // Compute noise values\n  Eigen::VectorXf noise_values =\n      this->GetNoiseValues(rms_noise, multiplier, depth_map);\n  // Add noise to data\n  for (int i = 0; i < width * height; ++i) {\n    if (InRange(depth_map(i))) {\n      depth_map(i) += noise_values(i);\n    } else {\n      depth_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 46.34115743094861}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n\n  // Calculate multiplier\n  const float multiplier =\n      static_cast<float>(this->noise_sigma) /\n      static_cast<float>(sqrt(width * height));\n\n  // Map to Eigen vector\n  Eigen::Map<Eigen::MatrixXf> depth_map(data, width, height);\n\n  // Compute RMS noise\n  const float rms_noise =\n      static_cast<float>(this->noise_sigma) /\n      static_cast<float>(sqrt(width * height));\n\n  // Compute noise values\n  const float noise_min = rms_noise * (1.0 - this->noise_range);\n  const float noise_max = rms_noise * (1.0 + this->noise_range);\n\n  // Apply noise\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(depth_map(i))) {\n      depth_map(i) +=\n          static_cast<float>(rand()) / static_cast<float>(RAND_MAX) *\n              (noise_max - noise_min) +\n          noise_min;\n    } else {\n      depth_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 47.04605403814003}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t0; i < child_links_.size(); i++) {\n    std::string link_name = child_links_[i]->GetScopedName();\n\n    // Check if the link contains rotor_ in its name.\n    int pos = link_name.find(\\\"rotor_\\\");\n    if (pos != link_name.npos) {\n      std::string motor_number_str = link_name.substr(pos + 6);\n      unsigned int motor_number = std::stoi(motor_number_str);\n      std::string joint_name = child_links_[i]->GetName() + \\\"_joint\\\";\n      physics::JointPtr joint = model_->GetJoint(joint_name);\n      motor_joints_.insert(MotorNumberToJointPair(motor_number, joint));\n    }\n  }\n\n  // Get the contact manager.\n  std::vector<std::string> collisions;\n  contact_mgr_ = world_->Physics()->GetContactManager();\n  for (unsigned int i = 0; i < link_->GetCollisions().size(); ++i) {\n    physics::CollisionPtr collision = link_->GetCollision(i);\n    collisions.push_back(collision->GetScopedName());\n  }\n  for (unsigned int j = 0; j < child_links_.size(); ++j) {\n    unsigned int zero = 0;\n    for (unsigned int i = 0; i < child_links_[j]->GetCollisions().size(); ++i) {\n      collisions.push_back(child_links_[j]->GetCollision(i)->GetScopedName());\n    }\n  }\n\n  if (!collisions.empty()) {\n    contact_mgr_->CreateFilter(link_->GetName(), collisions);\n  }\n\n  // If we do not need to wait for user command, we start recording right away\n  if (!wait_to_record_) StartRecording();\n}", "CodeBleu_score": 39.25842715635311}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t time(&rawtime);\n  timeinfo = localtime(&rawtime);\n\n  strftime(buffer, 80, \\\"%Y-%m-%d-%H-%M-%S\\\", timeinfo);\n  std::string date_time_str(buffer);\n\n  std::string key(\\\".bag\\\");\n  size_t pos = bag_filename_.rfind(key);\n  if (pos != std::string::npos) {\n    bag_filename_.erase(pos, key.length());\n  }\n  std::string full_bag_filename = bag_filename_ + \\\"_\\\" + date_time_str + \\\".bag\\\";\n\n  // Open a bag file and store it in ~/.ros/<full_bag_filename>.\n  bag_.open(full_bag_filename, rosbag::bagmode::Write);\n\n  // Subscriber to IMU sensor_msgs::Imu Message.\n  imu_sub_ = node_handle_->subscribe(imu_topic_, 10,\n                                     &GazeboBagPlugin::ImuCallback, this);\n\n  // Subscriber to External Force WrenchStamped Message.\n  external_force_sub_ = node_handle_->subscribe(external_force_topic_, 10,\n      &GazeboBagPlugin::ExternalForceCallback, this);\n\n  // Subscriber to Waypoint MultiDOFJointTrajectory Message.\n  waypoint_sub_ = node_handle_->subscribe(\n      waypoint_topic_, 10, &GazeboBagPlugin::WaypointCallback, this);\n\n  // Subscriber to PoseStamped pose command message.\n  command_pose_sub_ = node_handle_->subscribe(\n      command_pose_topic_, 10, &GazeboBagPlugin::CommandPoseCallback, this);\n\n  // Subscriber to Control Attitude Thrust Message.\n  control_attitude_thrust_sub_ =\n      node_handle_->subscribe(control_attitude_thrust_topic_, 10,\n                              &GazeboBagPlugin::AttitudeThrustCallback, this);\n\n  // Subscriber to Control Motor Speed Message.\n  control_motor_speed_sub_ =\n      node_handle_->subscribe(control_motor_speed_topic_, 10,\n                              &GazeboBagPlugin::ActuatorsCallback, this);\n\n  // Subscriber to Control Rate Thrust Message.\n  control_rate_thrust_sub_ =\n      node_handle_->subscribe(control_rate_thrust_topic_, 10,\n                              &GazeboBagPlugin::RateThrustCallback, this);\n\n  // Subscriber to Wind Speed Message.\n  wind_speed_sub_ =\n      node_handle_->subscribe(wind_speed_topic_, 10,\n                              &GazeboBagPlugin::WindSpeedCallback, this);\n\n  // Listen to the update event. This event is broadcast every\n  // simulation iteration.\n  update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&GazeboBagPlugin::OnUpdate, this, _1));\n\n  // Set the flag that we are actively recording.\n  is_recording_ = true;\n\n  ROS_INFO(\\\"GazeboBagPlugin START recording bagfile %s\\\",\n           full_bag_filename.c_str());\n}", "CodeBleu_score": 29.796136573983812}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tn  const Eigen::Vector3d forces_B = R_Wind_B_t * forces_Wind + force_thrust_B;\n  const Eigen::Vector3d moments_B = R_Wind_B_t * moments_Wind;\n\n  // Once again account for the difference between our body frame orientation\n  // and the traditional aerodynamics frame.\n  const ignition::math::Vector3d forces =\n      ignition::math::Vector3d (forces_B[0], -forces_B[1], -forces_B[2]);\n  const ignition::math::Vector3d moments =\n      ignition::math::Vector3d (moments_B[0], -moments_B[1], -moments_B[2]);\n\n  // Apply the calculated forced and moments to the main body link.\n  link_->AddRelativeForce(forces);\n  link_->AddRelativeTorque(moments);\n}", "CodeBleu_score": 31.34817646842655}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t_pressure = 0.005f * rho * vel_b.X() * vel_b.X();\n\n    // calculate temperature in Celsius\n    sensor_msg.temperature = temperature_local - 273.0f;\n\n    sensor_msg.fields_updated = 4095;\n\n    // accumulate gyro measurements that are needed for the optical flow message\n    static uint32_t last_dt_us = sensor_msg.time_usec;\n    uint32_t dt_us = sensor_msg.time_usec - last_dt_us;\n    if (dt_us > 1000) {\n      optflow_gyro_ += gyro_b * (dt_us / 1000000.0f);\n      last_dt_us = sensor_msg.time_usec;\n    }\n\n    mavlink_message_t msg;\n    mavlink_msg_hil_sensor_encode_chan(\n        1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n    if (hil_mode_) {\n      if (!hil_state_level_) {\n        send_mavlink_message(&msg);\n      }\n    }\n\n    else {\n      send_mavlink_message(&msg);\n    }\n    last_imu_time_ = current_time;\n  }", "CodeBleu_score": 36.833037970477136}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}, {"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}, {"code": "void GazeboMavlinkInterface::close() {\n\t_distance_;\n\n  // reset gyro integral\n  optflow_gyro_.Set();\n\n  mavlink_message_t msg;\n  mavlink_msg_hil_optical_flow_encode_chan(\n      1, 200, MAVLINK_COMM_0, &msg, &sensor_msg);\n  send_mavlink_message(&msg);\n}", "CodeBleu_score": 32.330448211990124}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tinterpolation_points[i] = min_x_ + res_x_ * idx_x[2u * (i - n_points_interp_z)];\n        }", "CodeBleu_score": 10.486903341869633}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (_time < 0)\n    _time = 0;\n  else if (_time > this->length)\n    _time = this->length;\n\n  if (_time != this->timePos)\n    this->timePos = _time;\n\n  if (this->loop)\n    this->timePos = fmod(this->timePos, this->length);\n}", "CodeBleu_score": 52.60661033595083}, {"code": "void Animation::SetTime(double _time){\n\tif (_time != this->timePos) {\n    if (this->loop) {\n      if (_time < 0) {\n        this->timePos = _time - std::floor(_time/this->length)*this->length;\n      }\n      else if (_time > this->length) {\n        this->timePos = _time - std::floor(_time/this->length)*this->length;\n      }\n      else {\n        this->timePos = _time;\n      }\n    }\n    else {\n      if (_time < 0) {\n        this->timePos = 0;\n      }\n      else if (_time > this->length) {\n        this->timePos = this->length;\n      }\n      else {\n        this->timePos = _time;\n      }\n    }\n    this->UpdateTimePos();\n  }\n}", "CodeBleu_score": 60.405387179520844}, {"code": "void Animation::SetTime(double _time){\n\tif (_time < 0) {\n    gzwarn << \"Animation time cannot be negative.\n\";\n    return;\n  }\n\n  if (_time > this->length) {\n    gzwarn << \"Animation time cannot be greater than the animation length.\n\";\n    return;\n  }\n\n  if (_time != this->timePos) {\n    this->timePos = _time;\n    if (this->loop) {\n      this->timePos = fmod(this->timePos, this->length);\n      if (this->timePos < 0)\n        this->timePos += this->length;\n    }\n    else {\n      this->timePos = std::min(std::max(this->timePos, 0.0), this->length);\n    }\n  }\n}", "CodeBleu_score": 71.79425638513948}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}, {"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}, {"code": "def hover(self)\n\t):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 38.22877550688841}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}, {"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}, {"code": "def flight_mode_switch(self)\n\t_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x,y=msg.position.y,z=msg.position.z,yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x,vy=msg.linear.y,vz=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(ax=msg.linear.x,ay=msg.linear.y,az=msg.linear.z,yaw_rate=msg.angular.z)\n\n    def hover_state_transition(self,x,y,z,w):\n        if abs(x) > 0.02 or abs(y)  > 0.02 or abs(z)  > 0.02 or abs(w)  > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \\\"HOVER\\\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state =self.arm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": Armed \\\"+str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": \\\"+msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\\\":\\\"+self.flight_mode)\n\n\n\n", "CodeBleu_score": 32.73026284982217}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t/cmd_pose_flu\\\", Pose, self.cmd_pose_flu_callback,\n            queue_size=1)\n        self.cmd_pose_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_pose_enu\\\", Pose, self.cmd_pose_enu_callback,\n            queue_size=1)\n        self.cmd_vel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_flu\\\", Twist, self.cmd_vel_flu_callback,\n            queue_size=1)\n        self.cmd_vel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_vel_enu\\\", Twist, self.cmd_vel_enu_callback,\n            queue_size=1)\n        self.cmd_accel_flu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_flu\\\", Twist,\n            self.cmd_accel_flu_callback, queue_size=1)\n        self.cmd_accel_enu_sub = rospy.Subscriber(\n            \\\"/xtdrone/\\\" + self.vehicle_type + '_' + self.vehicle_id + \\\"/cmd_accel_enu\\\", Twist,\n            self.cmd_accel_enu_callback, queue_size=1)\n\n        '''\n        ros publishers\n        '''\n        self.target_motion_pub = rospy.Publisher(\n            self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/setpoint_raw/local\\\", PositionTarget, queue_size=1)\n\n        '''\n        ros services\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 58.82625730345009}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n        '''\n        self.armService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/cmd/arming\\\",\n                                             CommandBool)\n        self.flightModeService = rospy.ServiceProxy(self.vehicle_type + '_' + self.vehicle_id + \\\"/mavros/set_mode\\\",\n                                                    SetMode)\n\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + \\\"communication initialized\\\")\n\n    def start(self):\n        '''\n        main ROS thread\n        '''\n        while not rospy.is_shutdown():\n            self.target_motion_pub.publish(self.target_motion)\n            rate.sleep()\n\n    def local_pose_callback(self, msg):\n        self.current_position = msg.pose.position\n        self.current_yaw = self.q2yaw(msg.pose.orientation)\n\n    def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose\n\n    def cmd_pose_flu_callback(self, msg):\n        self.coordinate_frame = 9\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_pose_enu_callback(self, msg):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        yaw = self.q2yaw(msg.orientation)\n        self.target_motion = self.construct_target(x=msg.position.x, y=msg.position.y, z=msg.position.z, yaw=yaw)\n\n    def cmd_vel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'flu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_vel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hover_flag == 0 and self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_flu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 8\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n    def cmd_accel_enu_callback(self, msg):\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n        if self.hover_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 2\n            self.target_motion = self.construct_target(afx=msg.linear.x, afy=msg.linear.y, afz=msg.linear.z,\n                                                       yaw_rate=msg.angular.z)\n\n\n\n", "CodeBleu_score": 8.256573929023133}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}, {"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}, {"code": "def q2yaw(self, q)\n\t:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n\n\n", "CodeBleu_score": 19.55701576561561}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}, {"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}, {"code": "def hover(self)\n\tn                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n\n\n", "CodeBleu_score": 41.66743175705557}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}, {"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}, {"code": "def flight_mode_switch(self)\n\tx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0\n\n    def cmd_callback(self, msg):\n        if msg.data == self.last_cmd or msg.data == '' or msg.data == 'stop controlling':\n            return\n\n        elif msg.data == 'ARM':\n            self.arm_state = self.arm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data == 'DISARM':\n            self.arm_state = not self.disarm()\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": Armed \\\" + str(self.arm_state))\n\n        elif msg.data[:-1] == \\\"mission\\\" and not msg.data == self.mission:\n            self.mission = msg.data\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": \\\" + msg.data)\n\n        else:\n            self.flight_mode = msg.data\n            self.flight_mode_switch()\n\n        self.last_cmd = msg.data\n\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \\\": disarming failed!\\\")\n            return False\n\n    def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \\\":\\\" + self.flight_mode)\n\n\n\n", "CodeBleu_score": 42.97151894091971}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 54.11073136365558}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 54.11073136365558}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualized:\n        self.visualize()\n\n", "CodeBleu_score": 54.11073136365558}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}, {"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}, {"code": "def local_pose_callback(self, msg, i)\n\tcs_cmd = 'FORM_1'\n                if self.form_flag != 1:\n                    self.read_set_file('FORM_1_id','FORM_1_pos')\n                self.form_flag = 1\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'FORM_2':\n                self.last_gcs_cmd = 'FORM_2'\n                if self.form_flag != 2:\n                    self.read_set_file('FORM_2_id','FORM_2_pos')\n                self.form_flag = 2\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                self.formation_control()\n                self.twist_target_pub.publish(self.target_vel)\n\n            elif self.gcs_cmd == 'AUTO.LAND':\n                self.last_gcs_cmd = 'AUTO.LAND'\n                self.form_flag = 0\n                if self.mavros_state != \\\"AUTO.LAND\\\":\n                    self.flight_mode_set(mode='AUTO.LAND')\n                if (self.mavros_state == 'AUTO.LAND') and (self.local_pose.pose.position.z < 0.05):\n                    if self.arm_state:\n                        self.disarm()\n                    print(self.namespace, \\\": Land Success!\\\")\n            elif self.gcs_cmd == 'HOVER':\n                self.last_gcs_cmd = 'HOVER'\n                self.form_flag = 0\n                if self.mavros_state != 'OFFBOARD':\n                    self.flight_mode_set(mode='OFFBOARD')\n                if not self.arm_state:\n                    self.arm()\n\n                self.target_pose = self.construct_target(self.hover_target_pose.pose.position.x,\n                                                         self.hover_target_pose.pose.position.y, self.hover_target_pose.pose.position.z,\n                                                         self.current_heading)\n                self.local_target_pub.publish(self.target_pose)\n            else:\n                self.gcs_cmd = self.last_gcs_cmd\n                self.form_flag = 0\n\n            rate.sleep()\n\n    def formation_control(self):\n        print('formation control here')\n        neighbor_num = len(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n\n\n", "CodeBleu_score": 22.485075672995237}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}, {"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}, {"code": "def takeoff_detection(self)\n\t(self.neighbor_id)\n        self.target_vel.twist.linear.x = 0\n        self.target_vel.twist.linear.y = 0\n        self.target_vel.twist.linear.z = 0\n        self.target_vel.twist.angular.x = 0\n        self.target_vel.twist.angular.y = 0\n        self.target_vel.twist.angular.z = self.Kpw*(self.target_yaw-self.current_heading)\n        # print(\\\"neighbor_num\\\",neighbor_num)\n        for i in range(neighbor_num):\n            self.target_vel.twist.linear.x += self.global_pose[self.neighbor_id[i]].pose.position.x - self.global_pose[self.uav_id].pose.position.x - \\\n                                                self.all_desired_position[self.neighbor_id[i]][0] + self.all_desired_position[self.uav_id][0]\n            self.target_vel.twist.linear.y += self.global_pose[self.neighbor_id[i]].pose.position.y - self.global_pose[self.uav_id].pose.position.y - \\\n                                                self.all_desired_position[self.neighbor_id[i]][1] + self.all_desired_position[self.uav_id][1]\n            self.target_vel.twist.linear.z += self.global_pose[self.neighbor_id[i]].pose.position.z - self.global_pose[self.uav_id].pose.position.z - \\\n                                                self.all_desired_position[self.neighbor_id[i]][2] + self.all_desired_position[self.uav_id][2]\n\n        self.target_vel.twist.linear.x = self.limit(self.target_vel.twist.linear.x * self.Kpx, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.y = self.limit(self.target_vel.twist.linear.y * self.Kpy, -self.velxy_max, self.velxy_max)\n        self.target_vel.twist.linear.z = self.limit(self.target_vel.twist.linear.z * self.Kpz, -self.velz_max, self.velz_max)\n        self.target_vel.twist.angular.z = self.limit(self.target_vel.twist.angular.z * self.Kpw, -self.w_max, self.w_max)\n\n    def limit(self, data, min, max):\n        if data <= min:\n            data = min\n        elif data >= max:\n            data = max\n        return data\n\n    def read_set_file(self,txt_id,txt_pos):\n        self.neighbor_id =[]\n        id_path='txt/'+txt_id+'.txt'\n        pos_path='txt/'+txt_pos+'.txt'\n        txt_uav_neighbor_num = np.loadtxt(id_path,dtype=int)\n        self.all_desired_position = np.loadtxt(pos_path)\n        for i in range(0, len(txt_uav_neighbor_num[:, 0])):\n                if txt_uav_neighbor_num[i, 0] == self.uav_id:\n                   self.neighbor_id.append(txt_uav_neighbor_num[i, 1])\n        print(self.neighbor_id)\n\n    def construct_target(self, x, y, z, yaw):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.header.stamp = rospy.Time.now()\n\n        target_raw_pose.coordinate_frame = 7\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n        target_raw_pose.yaw = yaw\n\n        target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                    + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                    + PositionTarget.IGNORE_YAW + PositionTarget.IGNORE_YAW_RATE \\\n                                    + PositionTarget.FORCE\n        return target_raw_pose\n\n    '''\n    Callback Function\n    '''\n    def gcs_cmd_callback(self, msg):\n        self.gcs_cmd = msg.data\n\n    def local_pose_callback(self, msg, i):\n        if i == uav_id:\n            self.local_pose = copy.deepcopy(msg)\n        if self.gcs_cmd != 'TAKEOFF':\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.gcs_cmd !='HOVER':\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n        self.global_pose[i] = copy.deepcopy(msg)\n        self.global_pose[i].pose.position.x += uav_bias[i][0]\n        self.global_pose[i].pose.position.y += uav_bias[i][1]\n        self.global_pose[i].pose.position.z += uav_bias[i][2]\n    #\n    # def local_vel_callback(self):\n    #\n    def mavros_state_callback(self, msg):\n        self.mavros_state = msg.mode\n        self.arm_state = msg.armed\n\n    def imu_callback(self, msg):\n        self.imu = msg\n        self.current_heading = self.q2yaw(self.imu.orientation)\n\n    def gps_callback(self, msg):\n        self.gps = msg\n\n    '''\n    return yaw from current IMU\n    '''\n    def q2yaw(self, q):\n        if isinstance(q, Quaternion):\n            rotate_z_rad = q.yaw_pitch_roll[0]\n        else:\n            q_ = Quaternion(q.w, q.x, q.y, q.z)\n            rotate_z_rad = q_.yaw_pitch_roll[0]\n\n        return rotate_z_rad\n\n    def arm(self):\n        if self.armService(True):\n            return True\n        else:\n            print(\\\"Vehicle arming failed!\\\")\n            return False\n\n    def disarm(self):\n        if self.armService(False):\n            return True\n        else:\n            print(\\\"Vehicle disarming failed!\\\")\n            return False\n\n    def flight_mode_set(self, mode):\n        \\\"\\\"\\\" mode selectable\n        MANUAL, ACRO, ALTCTL, POSCTL, OFFBOARD, STABILIZED, RATTITUDE\n        AUTO.MISSION, AUTO.LOITER, AUTO.RTL, AUTO.LAND, AUTO.RTGS, AUTO.READY, AUTO.TAKEOFF\n        \\\"\\\"\\\"\n        if self.flightModeService(custom_mode=mode):\n            return True\n        else:\n            print(self.namespace + mode + \\\"Failed\\\")\n\n\n\n", "CodeBleu_score": 41.80925571548085}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\tself.adj_matrix = numpy.zeros((self.uav_num, self.uav_num))\n    for i in range(self.uav_num):\n        for j in range(self.uav_num):\n            if i == j:\n                self.adj_matrix[i][j] = 0\n            else:\n                self.adj_matrix[i][j] = numpy.linalg.norm(orig_formation[i] - change_formation[j]) - 50\n                self.adj_matrix[i][j] = int(self.adj_matrix[i][j])\n    return self.adj_matrix\n\n", "CodeBleu_score": 27.01282109210098}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# The number of UAVs in the original formation\n    uav_num = len(orig_formation)\n    # The number of UAVs in the changed formation\n    uav_num_new = len(change_formation)\n    # The distance matrix\n    adj_matrix = numpy.zeros((uav_num, uav_num_new))\n    # The formation pattern of the original formation\n    formation_pattern_orig = numpy.zeros((uav_num, 3))\n    # The formation pattern of the changed formation\n    formation_pattern_new = numpy.zeros((uav_num_new, 3))\n    # The formation pattern of the original formation\n    formation_pattern_orig[:, 0] = numpy.array([uav.x for uav in orig_formation])\n    formation_pattern_orig[:, 1] = numpy.array([uav.y for uav in orig_formation])\n    formation_pattern_orig[:, 2] = numpy.array([uav.z for uav in orig_formation])\n    # The formation pattern of the changed formation\n    formation_pattern_new[:, 0] = numpy.array([uav.x for uav in change_formation])\n    formation_pattern_new[:, 1] = numpy.array([uav.y for uav in change_formation])\n    formation_pattern_new[:, 2] = numpy.array([uav.z for uav in change_formation])\n    # The distance matrix\n    for i in range(uav_num):\n        for j in range(uav_num_new):\n            adj_matrix[i, j] = numpy.round(numpy.linalg.norm(\n                formation_pattern_orig[i, :] - formation_pattern_new[j, :]) - 50)\n    return adj_matrix\n\n", "CodeBleu_score": 22.353308878166658}, {"code": "def build_graph(self, orig_formation, change_formation)\n\tadj_matrix = numpy.zeros((self.uav_num, self.uav_num))\n    for i in range(self.uav_num):\n        for j in range(self.uav_num):\n            if i == j:\n                adj_matrix[i][j] = 0\n            else:\n                adj_matrix[i][j] = numpy.round(numpy.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return adj_matrix\n\n", "CodeBleu_score": 30.512304212889564}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] > 0:\n            if self.visit_right[j] == 0:\n                if self.label_left[i] == self.label_right[j]:\n                    self.visit_right[j] = 1\n                    if self.find_path(j) == True:\n                        return True\n                    else:\n                        self.label_left[i] = self.label_left[i] + 1\n                else:\n                    if self.label_left[i] > self.label_right[j]:\n                        gap = self.label_left[i] - self.label_right[j]\n                    else:\n                        gap = self.label_right[j] - self.label_left[i]\n                    if gap < self.slack_right[j]:\n                        self.slack_right[j] = gap\n    return False\n\n", "CodeBleu_score": 29.645143582993267}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.visit_right[j] == 0:\n            gap = self.label_left[i] - self.label_right[j]\n            if gap == 0:\n                if self.find_path(j):\n                    return True\n                else:\n                    self.match_right[j] = -1\n                    self.slack_right[j] = 100\n            elif gap < 0:\n                if self.slack_right[j] > gap:\n                    self.slack_right[j] = gap\n            elif gap > 0:\n                if self.slack_right[j] > 0:\n                    self.slack_right[j] = 0\n    self.visit_left[i] = 0\n    return False\n\n", "CodeBleu_score": 34.88726696300077}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = 1\n    for j in range(self.uav_num - 1):\n        if self.adj_matrix[i][j] == 0:\n            continue\n        if self.visit_right[j] == 0:\n            self.match_right[j] = i\n            self.visit_right[j] = 1\n            if self.find_path(j):\n                return True\n            self.match_right[j] = -1\n            self.visit_right[j] = 0\n            self.slack_right[j] = min(self.slack_right[j], self.label_left[i] - self.label_right[j])\n        elif self.slack_right[j] > self.label_left[i] - self.label_right[j]:\n            self.slack_right[j] = min(self.slack_right[j], self.label_left[i] - self.label_right[j])\n    return False\n\n", "CodeBleu_score": 35.686341501942834}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t# These variables are determined for KM algorithm\n    self.adj_matrix = self.build_graph(self.origin_formation, formation_dict[self.formation_config])\n    self.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    self.changed_id = []\n    for i in range(self.uav_num - 1):\n        if not self.find_path(i):\n            self.label_left[i] = self.label_left[i] - self.slack_right[self.slack_right == numpy.min(self.slack_right)]\n            self.label_right = numpy.array([0] * (self.uav_num - 1))\n            self.match_right = numpy.array([-1] * (self.uav_num - 1))\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    return self.match_right\n\n", "CodeBleu_score": 39.64043828392445}, {"code": "def KM(self)\n\tself.label_left = numpy.max(self.adj_matrix, axis=1)  # init label for the left set\n    self.label_right = numpy.array([0] * (self.uav_num - 1))  # init label for the right set\n    self.match_right = numpy.array([-1] * (self.uav_num - 1))\n    self.visit_left = numpy.array([0] * (self.uav_num - 1))\n    self.visit_right = numpy.array([0] * (self.uav_num - 1))\n    self.slack_right = numpy.array([100] * (self.uav_num - 1))\n    while True:\n        for i in range(self.uav_num - 1):\n            if self.visit_left[i]:\n                continue\n            self.visit_left[i] = True\n            for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n                if self.visit_right[j]:\n                    continue\n                gap = self.label_left[i] + self.label_right[j] - match_weight\n                if gap == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        return self.match_right\n                else:\n                    self.slack_right[j] = min(gap, self.slack_right[j])\n        self.label_left += self.slack_right\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.visit_left = numpy.array([0] * (self.uav_num - 1))\n\n", "CodeBleu_score": 44.13809670617662}, {"code": "def KM(self)\n\tfor i in range(self.uav_num - 1):\n        self.visit_left[i] = False\n        self.visit_right = False\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        self.label_left = numpy.array([0] * (self.uav_num - 1))\n        self.label_right = numpy.array([0] * (self.uav_num - 1))\n        self.match_right = numpy.array([-1] * (self.uav_num - 1))\n        while not self.find_path(i):\n            min_slack = numpy.min(self.slack_right)\n            for j, slack in enumerate(self.slack_right, start=0):\n                if slack == min_slack:\n                    self.label_left[i] = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n                    self.label_right[j] = self.label_left[i] - self.label_right[j]\n                    self.slack_right[j] = 100\n    return self.match_right\n\n", "CodeBleu_score": 48.31407149477079}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t# HSV color space\n    # Lower and upper bounds for yellow color\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Apply mask to original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 28.255510940616023}, {"code": "def yellow_dectection(image)\n\t# Converting to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Defining lower and upper bounds for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Defining lower and upper bounds of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # Creating a mask of yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\\\"]; // tag id\n    // Tag size (square, side length in meters)\n    double size = (double)tag_description[\\\"size\\\"];\n\n    // Custom frame name, if such a field exists for this tag\n    std::string frame_name;\n    if(tag_description.hasMember(\\\"name\\\"))\n    {\n      // Assert type of field \\\"name\\\" is a string\n      ROS_ASSERT(tag_description[\\\"name\\\"].getType() ==\n                 XmlRpc::XmlRpcValue::TypeString);\n      frame_name = (std::string)tag_description[\\\"name\\\"];\n    }\n    else\n    {\n      std::stringstream frame_name_stream;\n      frame_name_stream << \\\"tag_\\\" << id;\n      frame_name = frame_name_stream.str();\n    }\n\n    StandaloneTagDescription description(id, size, frame_name);\n    ROS_INFO_STREAM(\\\"Loaded tag config: \\\" << id << \\\", size: \\\" <<\n                    size << \\\", frame_name: \\\" << frame_name.c_str());\n    // Add this tag's description to map of descriptions\n    descriptions.insert(std::make_pair(id, description));\n  }", "CodeBleu_score": 38.20623882101661}]}
