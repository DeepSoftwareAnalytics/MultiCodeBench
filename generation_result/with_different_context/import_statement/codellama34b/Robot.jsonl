{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n    std::vector<std::string> files;\n    std::string path = \"./\" + folder;\n    std::string cache_path = \"./cache\";\n    std::string cache_file = cache_path + \"/\" + folder + \".txt\";\n    std::ifstream cache_file_stream;\n    std::string line;\n\n    // Check if the cache file exists\n    cache_file_stream.open(cache_file);\n    if (cache_file_stream.is_open()) {\n        // Cache file exists, read the list of files from the cache file\n        while (getline(cache_file_stream, line)) {\n            required_files.push_back(line);\n        }\n        cache_file_stream.close();\n    } else {\n        // Cache file does not exist, create the cache file\n        std::ofstream outfile(cache_file);\n        outfile.close();\n    }\n\n    // Check if the folder exists\n    DIR *dir;\n    struct dirent *ent;\n    if ((dir = opendir(path.c_str())) != NULL) {\n        // Folder exists, read the list of files from the folder\n        while ((ent = readdir(dir)) != NULL) {\n            if (ent->d_type == DT_REG) {\n                files.push_back(ent->d_name);\n            }\n        }\n        closedir(dir);\n    } else {\n        // Folder does not exist, throw an exception\n        throw carla::Exception(\"The folder \" + path + \" does not exist.\");\n    }\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        for (const auto &file : required_files) {\n            if (std::find(files.begin(), files.end(), file) == files.end()) {\n                // File not found, request the file and log the download action\n                std::cout << \"Downloading \" << file << \" from \" << folder << std::endl;\n                FileTransfer::Download(file, folder);\n                std::cout << \"Downloaded \" << file <<", "CodeBleu_score": 46.439225956036445}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t  std::vector<std::string> files;\n  std::vector<std::string> required_files;\n\n  // Get the list of files in the specified folder.\n  files = GetFilesInFolder(folder);\n\n  // Check if each file exists locally.\n  for (const auto &file : files) {\n    // If the file does not exist, request the file and log the download action.\n    if (!FileExists(file)) {\n      // Request the file.\n      if (download) {\n        RequestFile(file);\n        // Log the download action.\n        log_debug(\"Downloaded file:\", file);\n      }\n      // Add the file to the list of required files.\n      required_files.push_back(file);\n    }\n    // Otherwise, log that the file is found in the cache.\n    else {\n      log_debug(\"Found file in cache:\", file);\n    }\n  }\n\n  return required_files;\n}", "CodeBleu_score": 55.8972158121005}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n    std::string file_path = \"./\" + folder;\n    std::string file_name;\n    std::string file_extension;\n    std::string file_full_path;\n    std::ifstream file_stream;\n    std::string line;\n    std::string file_name_with_extension;\n    std::string file_name_with_extension_and_path;\n    std::string file_name_with_path;\n    std::string file_name_with_extension_and_path_and_folder;\n    std::string file_name_with_path_and_folder;\n    std::string file_name_with_extension_and_path_and_folder_and_carla_folder;\n    std::string file_name_with_path_and_folder_and_carla_folder;\n    std::string file_name_with_extension_and_path_and_folder_and_carla_folder_and_carla_folder;\n    std::string file_name_with_path_and_folder_and_carla_folder_and_carla_folder;\n    std::string file_name_with_extension_and_path_and_folder_and_carla_folder_and_carla_folder_and_carla_folder;\n    std::string file_name_with_path_and_folder_and_carla_folder_and_carla_folder_and_carla_folder;\n\n    // Open the file\n    file_stream.open(file_path);\n\n    // Read the file line by line\n    while (std::getline(file_stream, line)) {\n        // Split the line into tokens\n        std::istringstream iss(line);\n        std::vector<std::string> tokens{std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{}};\n\n        // Get the file name\n        file_name = tokens[0];\n\n        // Get the file extension\n        file_extension = tokens[1];\n\n        // Get the file full path\n        file_full_path = tokens[2];", "CodeBleu_score": 32.10836155852621}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0 && transform.location.y == 0) {\n      std::cout << \"Warning: SpringArm or SpringArmGhost attachment type was specified, but the translation is only in the 'z' axis. This will result in an ill-formed transformation.\n\";\n    }\n  }\n\n  return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 42.723996319210144}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n    // Check for ill-formed spring arm attachment.\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        if (transform.location.x == 0.0f && transform.location.y == 0.0f) {\n            log_warning(\"SpringArm or SpringArmGhost attachment with only 'z' translation!\");\n        }\n    }\n\n    return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 39.747598672926365}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n\n    if (transform.location.x == 0 && transform.location.y == 0 && transform.location.z == 0) {\n      log_warning(\"A SpringArm or SpringArmGhost attachment was spawned with a transform with no translation in the X or Y axes. This is likely to cause the attachment to be ill-formed.\");\n    }\n\n    if (transform.rotation.pitch != 0 || transform.rotation.yaw != 0 || transform.rotation.roll != 0) {\n      log_warning(\"A SpringArm or SpringArmGhost attachment was spawned with a transform with a non-zero pitch, yaw, or roll. This is likely to cause the attachment to be ill-formed.\");\n    }\n  }\n\n  return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 46.35041136067522}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t    rpc::Response<std::string> response = GetEpisode().GetGBufferToken(ActorId, GBufferId);\n    std::string token = response.Get();\n    streaming_client.Subscribe(token, callback);\n}", "CodeBleu_score": 36.90212577151972}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  rpc::Response<std::string> response = _client.GetGbufferToken(ActorId, GBufferId);\n  if (response.error().has_value()) {\n    throw_exception(response.error().value());\n  }\n  std::string token = response.value();\n\n  streaming_client.Subscribe(token, callback);\n}", "CodeBleu_score": 40.87417921580886}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  // Create a token for the G-buffer.\n  rpc::token_type token = _client.request_gbuffer_token(ActorId, GBufferId);\n\n  // Copy the token data.\n  std::string token_data = token.data();\n\n  // Subscribe to the streaming client.\n  _streaming_client->Subscribe(token_data, callback);\n}", "CodeBleu_score": 38.89383893212121}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = GetWalkerNavigation();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    SetWalkerNavigation(navigation);\n  }\n  return navigation;\n}", "CodeBleu_score": 40.0989963742044}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(GetClient());\n    SetNavigation(navigation);\n  }\n  return navigation;\n}", "CodeBleu_score": 39.6159561474378}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> nav = GetNavigation();\n  if (nav == nullptr) {\n    nav = std::make_shared<WalkerNavigation>();\n    SetNavigation(nav);\n  }\n  return nav;\n}", "CodeBleu_score": 42.68681273022158}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const time_point start = steady_clock::now();\n  while (episode.GetState()->GetTimestamp() < frame) {\n    std::this_thread::yield();\n    if ((steady_clock::now() - start) > timeout) {\n      return false;\n    }\n  }\n  episode.GetState()->GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 34.04815785416987}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto end = steady_clock::now() + timeout;\n  while (steady_clock::now() < end) {\n    if (episode.GetState()->GetTimestamp().frame >= frame) {\n      episode.Lock()->GetWorld()->TickTrafficManager(frame);\n      return true;\n    }\n    std::this_thread::yield();\n  }\n  return false;\n}", "CodeBleu_score": 37.22910267068019}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto end = steady_clock::now() + timeout;\n  while (steady_clock::now() < end) {\n    if (episode.GetState()->GetTimestamp().frame_count >= frame) {\n      episode.Lock()->GetWorld()->Tick();\n      return true;\n    }\n    std::this_thread::yield();\n  }\n  return false;\n}", "CodeBleu_score": 35.01000277397809}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n  auto episode = _episode;\n\n  // load a new episode\n  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // wait for the new episode to be ready\n  const double TIMEOUT = 10.0;\n  const double INTERVAL = 0.1;\n  double waited = 0.0;\n  while (true) {\n    auto episode_id = _client.GetCurrentEpisodeId();\n    if (episode_id.has_value()) {\n      if (episode_id.get() != episode) {\n        log_info(\"new episode loaded:\", episode_id.get());\n        return episode_id.get();\n      }\n      log_info(\"episode not changed:\", episode_id.get());\n    }\n    waited += INTERVAL;\n    if (waited > TIMEOUT) {\n      log_error(\"timeout while loading a new episode\");\n      throw_exception(std::runtime_error(\"timeout while loading a new episode\"));\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(INTERVAL * 1000.0)));\n  }\n}", "CodeBleu_score": 49.28668877320457}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  std::stringstream error_stream;\n  error_stream << \"Failed to connect to episode with id \" << _episode.GetId() << \" after \" << _connection_attempts << \" attempts.\";\n  std::string error_message = error_stream.str();\n\n  for (auto i = 0; i < _connection_attempts; ++i) {\n    try {\n      auto episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n      _episode = episode;\n      return episode;\n    } catch (const std::exception &e) {\n      if (i == _connection_attempts - 1) {\n        throw_exception(std::runtime_error(error_message));\n      }\n    }\n  }\n  throw_exception(std::runtime_error(error_message));\n}", "CodeBleu_score": 54.06229916330022}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  auto map_name_hash = MapHashString(map_name);\n  auto map_name_hash_str = MapHashStringToHex(map_name_hash);\n  log_debug(\"LoadEpisode: map_name =\", map_name, \", map_name_hash =\", map_name_hash_str);\n  std::stringstream ss;\n  ss << \"Loading episode \" << map_name_hash_str;\n  SetTimeout(ss.str());\n\n  // Load the episode.\n  auto result = _client.LoadEpisode(map_name, map_layers);\n  log_debug(\"LoadEpisode: result =\", result);\n\n  // Wait for the episode to be loaded.\n  auto timeout = Timeout();\n  while (timeout-- > 0u) {\n    if (_client.GetEpisodeSettings().map_name == map_name_hash_str) {\n      break;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n  if (timeout <= 0u) {\n    throw_exception(TimeoutException(ss.str()));\n  }\n\n  // Reset the episode if requested.\n  if (reset_settings) {\n    _client.ResetEpisode();\n  }\n\n  // Return the episode proxy.\n  return EpisodeProxy{_client};\n}", "CodeBleu_score": 46.53221605097365}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\n  const auto walker = GetWalker(controller.GetParent());\n\n  if (!walker) {\n    throw_exception(std::runtime_error(\"unable to find walker for controller \" + controller.GetParent()));\n  }\n\n  if (!_episode) {\n    throw_exception(std::runtime_error(\"invalid episode\"));\n  }\n\n  if (!_navigation) {\n    _navigation = std::make_shared<WalkerNavigation>(*this);\n  }\n\n  _navigation->RegisterWalker(controller.GetParent(), walker->GetId());\n}", "CodeBleu_score": 53.027525392739385}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  const auto controller_id = controller.GetId();\n  const auto walker = GetWalker(controller_id);\n  if (!walker) {\n    throw_exception(std::runtime_error(\"no walker found with id \" + std::to_string(controller_id)));\n  }\n  if (!_episode) {\n    throw_exception(std::runtime_error(\"episode not found\"));\n  }\n  if (!_navigation) {\n    _navigation = std::make_unique<WalkerNavigation>(_episode.get());\n  }\n  _navigation->RegisterWalker(controller_id, walker->GetId());\n}", "CodeBleu_score": 47.163838869045435}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  const auto id = controller.GetId();\n  auto *walker = GetWalker(id);\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(\"unable to find walker for controller \" + std::to_string(id)));\n  }\n  if (_episode == nullptr) {\n    throw_exception(std::runtime_error(\"invalid episode\"));\n  }\n  if (_navigation == nullptr) {\n    _navigation = std::make_shared<WalkerNavigation>(_episode->GetClient());\n  }\n  _navigation->RegisterWalker(*walker, controller);\n}", "CodeBleu_score": 55.301850071996114}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  return SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name, \"\");\n}", "CodeBleu_score": 18.115106553392383}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  const auto id = _episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  auto description = _episode->GetActorById(id);\n  auto actor = ActorFactory::MakeActor(description, _episode);\n  _episode->RegisterActor(actor, gc);\n  return actor;\n}", "CodeBleu_score": 33.010701103124674}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  return SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name, \"\");\n}", "CodeBleu_score": 18.115106553392383}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n    // check if the episode is valid\n    if (!IsEpisodeValid()) {\n        log_error(\"invalid episode\");\n        return;\n    }\n\n    // subscribe to the sensor's data stream\n    _client.SubscribeToStream(\n        sensor.GetEpisode().GetId(),\n        sensor.GetId(),\n        [cb=std::move(callback), episode=WeakEpisodeProxy(sensor.GetEpisode())](auto buffer) {\n            auto episode_ptr = episode.Lock();\n            if (episode_ptr != nullptr) {\n                auto data = sensor::Deserializer::Deserialize(std::move(buffer));\n                data->SetEpisode(*episode_ptr);\n                cb(std::move(data));\n            }\n        });\n}", "CodeBleu_score": 63.255418963668575}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  SubscribeToSensor(sensor.GetId(), std::move(callback));\n}", "CodeBleu_score": 20.79084396070005}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t    using namespace std::placeholders;\n    SubscribeToStream(\n        sensor.GetEpisode(),\n        sensor.GetToken(),\n        std::bind(&sensor::Deserializer::Deserialize, _1, _2, _3, _4, callback));\n}", "CodeBleu_score": 26.86802478880981}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // Retrieve the current walkers.\n  const std::vector<carla::rpc::Actor> current_walkers = episode->GetActorsById(walkers);\n  if (current_walkers.empty()) {\n    return;\n  }\n\n  // Retrieve the current state of the episode.\n  const auto episode_state = episode->GetState();\n\n  // Remove any walkers that no longer exist.\n  walkers.erase(std::remove_if(walkers.begin(), walkers.end(), [&episode_state](const WalkerId &id) {\n    return !episode_state.HasActor(id);\n  }), walkers.end());\n\n  // Update the vehicles in the crowd and the crowd itself in the navigation module.\n  crowd->Update(current_walkers);\n\n  // For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n  for (const auto &walker : current_walkers) {\n    const auto transform = episode_state.GetActorTransform(walker.id);\n    const auto speed = episode_state.GetActorVelocity(walker.id);\n    commands.push_back(carla::rpc::Command::ApplyWalkerState(walker.id, transform, speed));\n  }\n\n  // Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n  for (auto it = walkers.begin(); it != walkers.end();) {\n    const auto &walker = episode_state.GetActorState(*it);\n    if (walker.health <= 0.0f) {\n      crowd->Remove(walker.id);\n      commands.push_back(carla::rpc::Command::DestroyActor(walker.id));\n      it = walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}", "CodeBleu_score": 46.896214789608365}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n  // Retrieve the list of walkers.\n  auto walkers = episode->GetActorsById(walkers_);\n\n  // If there are no walkers, return.\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Retrieve the current state of the episode.\n  auto episode_state = episode->GetState();\n\n  // Remove any walkers that no longer exist.\n  for (auto it = walkers_.begin(); it != walkers_.end();) {\n    if (episode_state.find(*it) == episode_state.end()) {\n      it = walkers_.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the vehicles in the crowd.\n  for (auto walker : walkers) {\n    crowd_.SetVehicle(*walker, walker->GetVelocity());\n  }\n\n  // Update the crowd.\n  crowd_.Update();\n\n  // For each walker, get their transform and speed.\n  std::vector<crowd::Vehicle*> vehicles;\n  std::vector<carla::geom::Transform> transforms;\n  std::vector<carla::geom::Vector3D> speeds;\n  for (auto walker : walkers) {\n    vehicles.push_back(crowd_.GetVehicle(*walker));\n    transforms.push_back(walker->GetTransform());\n    speeds.push_back(walker->GetVelocity());\n  }\n\n  // Apply these states in a batch to the simulator.\n  episode->Lock()->ApplyBatch(\n      [&](auto& simulator) {\n        for (auto i = 0u; i < vehicles.size(); ++i) {\n          simulator.ApplyWalkerTransform(vehicles[i], transforms[i]);\n          simulator.ApplyWalkerSpeed(vehicles[i], speeds[i]);\n        }\n      },\n      \"WalkerNavigation::Tick\");\n\n  // Check if any walker has been killed.\n  for (auto walker : walkers) {\n   ", "CodeBleu_score": 47.741393477243044}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n    // Get the current walkers and check if the list is empty, returning if so.\n    std::vector<std::shared_ptr<Actor>> walkers = episode->GetActorsById(walker_ids);\n    if (walkers.empty()) {\n        return;\n    }\n\n    // Retrieve the current state of the episode and remove any walkers that no longer exist.\n    std::shared_ptr<EpisodeState> state = episode->Lock()->GetCurrentState();\n    for (auto it = walker_ids.begin(); it != walker_ids.end();) {\n        if (state->GetActorById(*it) == nullptr) {\n            it = walker_ids.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Update the vehicles in the crowd and the crowd itself in the navigation module.\n    crowd.Update(walkers);\n    nav.UpdateCrowd(crowd);\n\n    // For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n    std::vector<rpc::Command> commands;\n    for (auto &walker : walkers) {\n        const auto transform = walker->GetTransform();\n        const auto speed = walker->GetVelocity();\n        commands.push_back(rpc::Command::ApplyVehicleControl(walker->GetId(), rpc::VehicleControl(speed, 0.0f, 0.0f, 0.0f, 0.0f)));\n        commands.push_back(rpc::Command::ApplyActorTransform(walker->GetId(), transform));\n    }\n    episode->Lock()->ApplyBatch(std::move(commands), true);\n\n    // Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n    for (auto it = walker_ids.begin(); it != walker_ids.end();) {\n        if (state->GetActorById(*it)->IsAlive()) {\n            ++it;\n        } else {\n            crowd.Remove(*it);\n            nav.UpdateCrowd(", "CodeBleu_score": 45.02557143922413}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  std::transform(_attributes.begin(), _attributes.end(), std::back_inserter(description.attributes), [](auto &attribute) {\n    return attribute.MakeActorAttributeValue();\n  });\n  return description;\n}", "CodeBleu_score": 71.97603456530956}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = Uid;\n  description.id = Id;\n  description.attributes.reserve(Attributes.size());\n  std::for_each(\n      Attributes.begin(),\n      Attributes.end(),\n      [&description](const auto &attribute) {\n        description.attributes.emplace_back(attribute.Get());\n      });\n  return description;\n}", "CodeBleu_score": 66.49547474595032}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = Uid;\n  description.id = Id;\n  description.attributes.reserve(Attributes.size());\n  for (const auto &attribute : Attributes) {\n    description.attributes.emplace_back(attribute.Get());\n  }\n  return description;\n}", "CodeBleu_score": 77.38037228728578}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n  SharedPtr<BlueprintLibrary> filtered_blueprints = MakeShared<BlueprintLibrary>();\n\n  for (const auto &blueprint : _blueprints) {\n    if (blueprint.second.GetAttributes().count(name) == 0) {\n      continue;\n    }\n    const auto& attribute = blueprint.second.GetAttributes().at(name);\n    if (attribute.GetValue().compare(value) == 0) {\n      filtered_blueprints->AddBlueprint(blueprint.second);\n    }\n    else if (attribute.GetRecommendedValues().count(value) != 0) {\n      filtered_blueprints->AddBlueprint(blueprint.second);\n    }\n  }\n\n  return filtered_blueprints;\n}", "CodeBleu_score": 46.47329140168667}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &blueprint : _blueprints) {\n    const auto &attributes = blueprint.GetAttributes();\n    const auto it = attributes.find(name);\n    if (it != attributes.end()) {\n      if (it->second.GetValue().empty()) {\n        if (std::find(it->second.GetRecommendedValues().begin(), it->second.GetRecommendedValues().end(), value) != it->second.GetRecommendedValues().end()) {\n          result->_blueprints.push_back(blueprint);\n        }\n      } else if (it->second.GetValue() == value) {\n        result->_blueprints.push_back(blueprint);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 53.37067079048904}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  std::vector<SharedPtr<ActorBlueprint>> result;\n  for (const auto &blueprint : _blueprints) {\n    if (blueprint->ContainsAttribute(name)) {\n      if (blueprint->GetAttribute(name).GetValue().GetString() == value) {\n        result.push_back(blueprint);\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>(new BlueprintLibrary(std::move(result)));\n}", "CodeBleu_score": 35.39753695596855}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = path + \"/\" + carla::version::get().str() + \"/\" + carla::version::get().str() + \".bin\";\n    std::ofstream outfile(fullPath, std::ios::binary);\n    if (outfile.is_open()) {\n        outfile.write((char*)content.data(), content.size());\n        outfile.close();\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 42.09696017444959}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\n\t// Construct file path\n\tstd::string filePath = path + \"/\" + carla::version::get().str() + \".json\";\n\n\t// Validate file path\n\tif (!ValidateFilePath(filePath)) {\n\t\treturn false;\n\t}\n\n\t// Open file in binary mode to truncate contents\n\tstd::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n\n\t// Check if file was successfully opened\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write content to file\n\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n\t// Close file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 45.5865776613871}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path\n\tstd::string filePath = path + \"/\" + carla::version::GetId() + \".json\";\n\n\t// Validate the file path\n\tif (!ValidateFilePath(filePath)) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Write the content to the file\n\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\n\t// Close the file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 45.48456706720171}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  // The location of the bounding box is the location of the parent plus the location of the transform.\n  const geom::Location location = _parent_bounding_box->location + transform.location;\n\n  // The extents of the bounding box are the same as the parent's extents.\n  const geom::Vector3D extents = _parent_bounding_box->extents;\n\n  // The yaw angle of the bounding box is the yaw angle of the transform.\n  const float yaw = transform.rotation.yaw;\n\n  // The four corners of the bounding box are the location plus the rotated extents.\n  const geom::Vector3D corners[] = {\n    geom::Vector3D(location + geom::RotateVector(extents.x, extents.y, yaw)),\n    geom::Vector3D(location + geom::RotateVector(-extents.x, extents.y, yaw)),\n    geom::Vector3D(location + geom::RotateVector(-extents.x, -extents.y, yaw)),\n    geom::Vector3D(location + geom::RotateVector(extents.x, -extents.y, yaw))\n  };\n\n  // Return a shared pointer to a Bounds object containing the frame number and the corners.\n  return std::make_shared<const Bounds>(frame, corners);\n}", "CodeBleu_score": 45.82506630423248}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &bounds = _parent->GetBoundingBox();\n  const auto &extents = bounds.extent;\n  const auto location = bounds.location + transform.location;\n  const auto yaw = transform.rotation.yaw;\n  const auto cos_yaw = std::cos(yaw);\n  const auto sin_yaw = std::sin(yaw);\n  const auto cos_minus_yaw = std::cos(-yaw);\n  const auto sin_minus_yaw = std::sin(-yaw);\n  const auto x_min = -extents.x * cos_yaw - extents.y * sin_yaw;\n  const auto x_max = extents.x * cos_yaw - extents.y * sin_yaw;\n  const auto y_min = -extents.x * sin_yaw - extents.y * cos_yaw;\n  const auto y_max = extents.x * sin_yaw - extents.y * cos_yaw;\n  const auto z_min = -extents.z;\n  const auto z_max = extents.z;\n  return std::make_shared<Bounds>(frame,\n      geom::Location(location.x + x_min, location.y + y_min, location.z + z_min),\n      geom::Location(location.x + x_max, location.y + y_max, location.z + z_max),\n      geom::Location(location.x + x_min, location.y + y_min, location.z + z_max),\n      geom::Location(location.x + x_min, location.y + y_max, location.z + z_min),\n      geom::Location(location.x + x_max, location.y + y_min, location.z + z_min),\n      geom::Location(location.x + x_max, location.y + y_max, location.z + z_max),\n      geom::Location(location.x + x_max, location.y + y_min, location.z + z_max),\n      geom::Location(location.x + x_min, location.y + y_max, location.", "CodeBleu_score": 46.497680392218385}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  const geom::Location location = parent_bounds->location + transform.location;\n  const geom::Vector3D extents = parent_bounds->extents;\n  const float yaw = transform.rotation.yaw;\n\n  const geom::Vector3D right_extent(extents.x * geom::Math::Cos(yaw) - extents.y * geom::Math::Sin(yaw),\n                                    extents.x * geom::Math::Sin(yaw) + extents.y * geom::Math::Cos(yaw),\n                                    extents.z);\n  const geom::Vector3D left_extent(-right_extent.x, right_extent.y, right_extent.z);\n\n  const geom::Vector3D back_extent(extents.x * geom::Math::Cos(yaw + geom::Math::PiHalf) - extents.y * geom::Math::Sin(yaw + geom::Math::PiHalf),\n                                   extents.x * geom::Math::Sin(yaw + geom::Math::PiHalf) + extents.y * geom::Math::Cos(yaw + geom::Math::PiHalf),\n                                   extents.z);\n  const geom::Vector3D front_extent(-back_extent.x, back_extent.y, back_extent.z);\n\n  return std::make_shared<const Bounds>(frame,\n                                        location + right_extent,\n                                        location + left_extent,\n                                        location + back_extent,\n                                        location + front_extent);\n}", "CodeBleu_score": 40.38357320130509}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Get the current state of lights from the server.\n  const std::vector<carla::rpc::LightState> light_states = _episode.Lock()->GetAllLightStates();\n\n  // Update the local light states.\n  for (const auto& light_state : light_states) {\n\n    // If the light is not in the _lights map, create a new light object and add it to the map.\n    if (_lights.find(light_state.id) == _lights.end()) {\n      _lights.insert(std::make_pair(light_state.id, Light(light_state)));\n    }\n\n    // Update the local light state.\n    _lights[light_state.id].SetState(light_state);\n  }\n}", "CodeBleu_score": 35.495561743035466}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\n    // Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Retrieve the light states from the server\n    std::vector<carla::rpc::LightState> light_states = _episode.Lock()->GetLightStates();\n\n    // For each light state returned by the server\n    for (auto light_state : light_states) {\n\n        // Check if the light exists in the _lights map\n        if (_lights.find(light_state.id) == _lights.end()) {\n            // If not, create a new light object and add it to the _lights map\n            _lights.insert(std::make_pair(light_state.id, Light(light_state)));\n        }\n        else {\n            // If it does, update the light state\n            _lights.at(light_state.id).SetLightState(light_state);\n        }\n    }\n}", "CodeBleu_score": 35.82822113895772}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Get the current light states from the server\n  std::vector<carla::rpc::LightState> light_states = _episode.Lock()->GetAllLightStates();\n\n  // Update the local light states and create new light objects if they do not already exist in the _lights map\n  for (auto& light_state : light_states) {\n\n    // Check if the light is already in the _lights map\n    auto it = _lights.find(light_state.id);\n\n    // If the light is not in the _lights map, create a new light object and add it to the map\n    if (it == _lights.end()) {\n\n      // Create a new light object\n      auto light = Light(light_state.id, _episode);\n\n      // Add the light to the _lights map\n      _lights.insert(std::pair<int, Light>(light_state.id, light));\n\n      // Update the light's state\n      light.SetState(light_state);\n\n    } else {\n\n      // Update the light's state\n      it->second.SetState(light_state);\n    }\n  }\n}", "CodeBleu_score": 46.36957191304975}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (!_dirty) {\n    return;\n  }\n  std::vector<carla::rpc::LightState> lights_state;\n  for (auto& light : _lights) {\n    if (discard_client) {\n      light.second.discard_client_changes = true;\n    }\n    lights_state.push_back(light.second.GetLightState());\n  }\n  _episode.Lock()->UpdateLightStates(lights_state);\n  _dirty = false;\n}", "CodeBleu_score": 35.32964629157952}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\n  // Lock the mutex to ensure thread safety.\n  std::lock_guard<std::mutex> guard(mutex);\n\n  // Check if there are any changes.\n  if (changes.empty()) {\n    return;\n  }\n\n  // Create a message to update the server.\n  carla::rpc::UpdateLightStates update_message;\n\n  // Check if the client should discard its state.\n  if (discard_client) {\n    // Discard the client state.\n    for (auto &change : changes) {\n      // Get the light state.\n      auto light_state = change.second;\n      // Check if the light state is valid.\n      if (light_state != nullptr) {\n        // Set the state to off.\n        light_state->state = false;\n      }\n    }\n  }\n\n  // Add the light states to the message.\n  for (auto &change : changes) {\n    // Get the light state.\n    auto light_state = change.second;\n    // Check if the light state is valid.\n    if (light_state != nullptr) {\n      // Add the light state to the message.\n      update_message.light_states.push_back(*light_state);\n    }\n  }\n\n  // Send the message to the server.\n  simulator->SendLightState(update_message);\n\n  // Clear the changes.\n  changes.clear();\n\n  // Reset the dirty flag.\n  dirty = false;\n}", "CodeBleu_score": 44.32986031301671}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    // Lock the mutex to ensure thread safety.\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Check if there are any changes.\n    if (_dirty) {\n        // Create a message containing the updated light states.\n        std::vector<carla::rpc::LightState> light_states;\n        for (auto& light : _lights) {\n            light_states.push_back(light.second.GetLightState());\n        }\n        // Send the message to the server.\n        _episode.Lock()->UpdateServerLightsState(light_states, discard_client);\n\n        // Clear the changes.\n        for (auto& light : _lights) {\n            light.second.ClearChanges();\n        }\n\n        // Reset the dirty flag.\n        _dirty = false;\n    }\n}", "CodeBleu_score": 45.14013174006462}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (m_sensor_id != \"sensor.other.v2x_custom\") {\n    log_debug(\"Sensor ID is not \\\"sensor.other.v2x_custom\\\"\");\n    return;\n  }\n  log_debug(\"Sensor ID is \\\"sensor.other.v2x_custom\\\"\");\n  try {\n    m_episode.Lock()->SendV2XMessage(m_context, message);\n  } catch (std::exception &e) {\n    log_error(e.what());\n  }\n}", "CodeBleu_score": 48.980942379273905}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_debug(\"Sensor ID: \" + GetId());\n        return;\n    }\n\n    log_debug(\"Sending message to episode: \" + message);\n    GetEpisode().Lock()->SendSensorMessage(GetId(), message);\n}", "CodeBleu_score": 52.34625862310466}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    //Log a debug message when called\n    log_debug(\"Sending message to server: \" + message);\n\n    //Check if the sensor's ID is \"sensor.other.v2x_custom\" and log a warning if it is not, then return\n    if (GetDescription().GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not \\\"sensor.other.v2x_custom\\\"!\");\n        return;\n    }\n\n    //Send a message to the episode using the sensor's context\n    GetEpisode().Lock()->SendSensorMessage(GetId(), message);\n}", "CodeBleu_score": 43.94092855448988}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->SetVehicleAutopilot(*this, enabled, tm_port);\n}", "CodeBleu_score": 25.200853385691786}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  GetEpisode().Lock()->SetVehicleAutopilot(*this, enabled, tm_port);\n}", "CodeBleu_score": 25.200853385691786}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    GetEpisode().Lock()->RegisterVehicle(shared_from_this(), tm_port);\n  } else {\n    GetEpisode().Lock()->UnregisterVehicle(shared_from_this());\n  }\n}", "CodeBleu_score": 51.27626089696194}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t  _walker = GetParent();\n  if (!_walker.IsValid()) {\n    throw_exception(std::runtime_error(\"failed to retrieve walker actor\"));\n  }\n  GetEpisode().Lock()->RegisterActor(_walker);\n  _navigation = GetEpisode().GetNavigation();\n  _navigation->AddWalker(_walker);\n  _walker.SetSimulatePhysics(false);\n  _walker.SetActorEnableCollision(false);\n}", "CodeBleu_score": 43.0460474462663}, {"code": "void WalkerAIController::Start(){\n\t  _walker = GetParent();\n  _navigation = _episode.Lock()->GetCurrentMap().GetWalkerNavigation();\n  _navigation->Add(_walker, _walker->GetLocation());\n  _walker->SetSimulatePhysics(false);\n  _walker->SetEnableGravity(false);\n  _walker->SetActorTickEnabled(true);\n}", "CodeBleu_score": 30.608566718198137}, {"code": "void WalkerAIController::Start(){\n\t  _walker = GetParent();\n  if (!_walker.IsValid()) {\n    throw_exception(std::runtime_error(\"failed to retrieve walker actor\"));\n  }\n  _navigation = _episode.Lock()->GetCurrentNavmesh();\n  if (!_navigation) {\n    throw_exception(std::runtime_error(\"no navigation mesh present in the map\"));\n  }\n  _navigation->RegisterWalker(_walker, _walker->GetLocation());\n  _walker->SetSimulatePhysics(false);\n  _walker->SetCollisionEnabled(false);\n}", "CodeBleu_score": 37.8934620655451}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().GetWalkerNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      nav->SetWalkerMaxSpeed(walker, max_speed);\n    } else {\n      log_warning(\"Parent walker not found for walker AI controller\");\n    }\n  } else {\n    log_warning(\"Navigation not found for walker AI controller\");\n  }\n}", "CodeBleu_score": 70.6071718453322}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  const auto navigation = GetEpisode().GetWalkerNavigation();\n  if (navigation == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation is not valid.\"));\n    return;\n  }\n  const auto controller = GetParentActor();\n  if (controller == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Controller is not valid.\"));\n    return;\n  }\n  const auto walker = controller->GetParentActor();\n  if (walker == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Walker is not valid.\"));\n    return;\n  }\n  if (!navigation->SetMaxSpeed(walker, max_speed)) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Failed to set walker's maximum speed.\"));\n  }\n}", "CodeBleu_score": 48.79846295082948}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto navigation = GetNavigation();\n  if (navigation == nullptr) {\n    carla::logging::log(\"WalkerAIController: Unable to retrieve navigation instance from current episode.\", carla::logging::LogLevel::Warning);\n    return;\n  }\n  auto walker = GetParent();\n  if (walker == nullptr) {\n    carla::logging::log(\"WalkerAIController: Unable to retrieve parent walker.\", carla::logging::LogLevel::Warning);\n    return;\n  }\n  if (!navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n    carla::logging::log(\"WalkerAIController: Unable to set maximum speed for walker.\", carla::logging::LogLevel::Warning);\n  }\n}", "CodeBleu_score": 51.38501258011535}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<SharedPtr<Waypoint>> waypoints = _parent.GetWaypointsInDistance(GetTransform().location, -1.0, distance);\n  for (auto& waypoint : waypoints) {\n    if (waypoint->GetRoadId() == GetRoadId()) {\n      if (waypoint->GetWaypointId() < GetWaypointId()) {\n        result.push_back(waypoint);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 48.70081499908915}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  auto waypoints = _parent.GetWaypointsInDistance(_transform, -distance);\n  for (auto& waypoint : waypoints) {\n    if (waypoint.get() != this) {\n      result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, waypoint)));\n    }\n  }\n  return result;\n}", "CodeBleu_score": 60.80258215722449}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  auto reference_waypoint = GetWaypoint();\n  auto previous_waypoints = _parent.GetPrevious(reference_waypoint, distance);\n  for (auto &waypoint : previous_waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, waypoint)));\n  }\n  return result;\n}", "CodeBleu_score": 64.72309078102715}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n    std::vector<SharedPtr<Landmark>> result;\n    std::unordered_set<SharedPtr<Landmark>> unique_landmarks;\n\n    auto signals = GetSignalsInDistance(distance, stop_at_junction);\n    for (auto &signal : signals) {\n        if (unique_landmarks.find(signal) == unique_landmarks.end()) {\n            SharedPtr<Waypoint> waypoint = GetMap()->GetWaypoint(signal->GetTransform().location);\n            result.push_back(signal);\n            unique_landmarks.insert(signal);\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 44.550194224711895}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Landmark>> landmarks;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto &signal : signals) {\n    if (landmarks.find(signal->GetWaypoint().GetLandmark()) == landmarks.end()) {\n      result.push_back(signal->GetWaypoint().GetLandmark());\n      landmarks.insert(signal->GetWaypoint().GetLandmark());\n    }\n  }\n  return result;\n}", "CodeBleu_score": 41.11535451993845}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\n    std::vector<SharedPtr<Landmark>> result;\n\n    // Get all signals within the distance\n    auto signals = GetSignalsInDistance(distance, stop_at_junction);\n\n    // Create a set to store the unique signals\n    std::unordered_set<SharedPtr<Signal>> unique_signals;\n\n    // Iterate over the signals\n    for (auto& signal : signals) {\n        // If the signal is not in the set, add it to the set and to the result\n        if (unique_signals.find(signal) == unique_signals.end()) {\n            unique_signals.insert(signal);\n            result.push_back(SharedPtr<Landmark>(new Landmark(SharedPtr<Waypoint>(new Waypoint(GetTransform(), GetRoadId(), GetLaneId(), GetSectionId(), GetLaneChange(), GetMap())) , signal)));\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 49.89002614249872}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  uint64_t id = _episode->SetEpisodeSettings(settings);\n  if (settings.fixed_delta_seconds > 0.0) {\n    const auto delta = settings.fixed_delta_seconds;\n    for (auto i = 0u; i < 10u; ++i) {\n      auto tick = _episode->WaitForTick(timeout);\n      if (tick.delta_seconds == delta) {\n        break;\n      }\n    }\n    log_warning(\"fixed delta seconds of\", delta, \"was not correctly applied after\", 10u, \"attempts\");\n  }\n  return id;\n}", "CodeBleu_score": 31.539757357452352}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  if (timeout == time_duration::max()) {\n    timeout = GetEpisode().GetNetworkingTimeout();\n  }\n  uint64_t id = GetEpisode().SetEpisodeSettings(settings);\n  if (settings.fixed_delta_seconds > 0.0) {\n    const double expected_time = 1000u * settings.fixed_delta_seconds;\n    const double acceptable_error = 0.01 * expected_time;\n    double total_error = 0.0;\n    for (int i = 0; i < 10; ++i) {\n      auto start = std::chrono::high_resolution_clock::now();\n      GetEpisode().Tick(timeout);\n      auto end = std::chrono::high_resolution_clock::now();\n      std::chrono::duration<double> diff = end - start;\n      double error = std::abs(diff.count() * 1000.0 - expected_time);\n      total_error += error;\n      if (error > acceptable_error) {\n        log_warning(\"Fixed delta time setting is not being correctly applied\");\n        break;\n      }\n    }\n    if (total_error > acceptable_error) {\n      log_warning(\"Fixed delta time setting is not being correctly applied\");\n    }\n  }\n  return id;\n}", "CodeBleu_score": 52.81011846762831}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  const auto id = _episode.SetEpisodeSettings(settings, timeout);\n  if (settings.fixed_delta_seconds > 0.0f) {\n    const auto delta = 1.0f / settings.fixed_delta_seconds;\n    for (auto i = 0u; i < 10u; ++i) {\n      if (Tick(delta) == delta) {\n        break;\n      }\n    }\n    log_warning(\"could not set fixed delta seconds to\", settings.fixed_delta_seconds);\n  }\n  return id;\n}", "CodeBleu_score": 27.517613747495133}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const auto &segment = *this;\n  const auto &point = p;\n\n  const auto segment_length_squared = segment.LengthSquared();\n  const auto segment_length = std::sqrt(segment_length_squared);\n  if (segment_length == 0.0f) {\n    return {0.0f, segment.StartPoint.Distance(point)};\n  }\n\n  const auto t = std::clamp(\n      (point - segment.StartPoint).Dot(segment.Vector()) / segment_length_squared,\n      0.0f,\n      1.0f);\n\n  const auto projection = segment.StartPoint + t * segment.Vector();\n  return {t * segment_length, projection.Distance(point)};\n}", "CodeBleu_score": 37.373084178034425}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const float segment_length_squared = (segment_end - segment_start).LengthSquared();\n  const float segment_length = std::sqrt(segment_length_squared);\n\n  if (segment_length == 0.0f) {\n    return {0.0f, (point - segment_start).Length()};\n  }\n\n  const float projection_factor = (point - segment_start).Dot(segment_end - segment_start) / segment_length_squared;\n\n  const float projection_clamped = std::clamp(projection_factor, 0.0f, 1.0f);\n\n  const float projection = segment_start + projection_clamped * (segment_end - segment_start);\n\n  return {projection_clamped * segment_length, (point - projection).Length()};\n}", "CodeBleu_score": 39.66838516322605}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const float segment_length_squared = (segment_end - segment_start).LengthSquared();\n  const float segment_length = std::sqrt(segment_length_squared);\n  if (segment_length < 0.0000001f) {\n    return std::make_pair(0.0f, (point - segment_start).Length());\n  }\n  const float t = (point - segment_start).Dot(segment_end - segment_start) / segment_length_squared;\n  if (t < 0.0f) {\n    return std::make_pair(0.0f, (point - segment_start).Length());\n  }\n  if (t > 1.0f) {\n    return std::make_pair(1.0f, (point - segment_end).Length());\n  }\n  const float projection = segment_start + t * (segment_end - segment_start);\n  return std::make_pair(t, (point - projection).Length());\n}", "CodeBleu_score": 40.92805001705323}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\n  assert(vertices.size() >= 3u);\n\n  const size_t initial_index = _vertices.size();\n\n  _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n\n  for (size_t i = 1u; i < vertices.size() - 1u; ++i) {\n\n    _indices.emplace_back(initial_index);\n\n    _indices.emplace_back(initial_index + i);\n\n    _indices.emplace_back(initial_index + i + 1u);\n\n  }\n\n}", "CodeBleu_score": 51.78601554729316}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\n  assert(vertices.size() >= 3u);\n\n  const auto first_index = _vertices.size();\n\n  for (const auto &vertex : vertices) {\n\n    _vertices.push_back(vertex);\n\n  }\n\n  for (auto i = decltype(vertices.size()){1u}; i < vertices.size() - 1u; ++i) {\n\n    _indices.push_back(first_index);\n\n    _indices.push_back(first_index + i);\n\n    _indices.push_back(first_index + i + 1u);\n\n  }\n\n}", "CodeBleu_score": 41.61221108576814}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  assert(vertices.size() >= 3u);\n  const auto initial_index = _vertices.size();\n  _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n  for (size_t i = 1u; i < vertices.size() - 1u; ++i) {\n    _indices.push_back(initial_index);\n    _indices.push_back(initial_index + i);\n    _indices.push_back(initial_index + i + 1u);\n  }\n}", "CodeBleu_score": 49.33695623626393}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n  if (!message) {\n    log_error(\"invalid message\");\n    return;\n  }\n\n  _strand.post([this, message]() {\n    if (!_socket.is_open()) {\n      log_error(\"socket is not open\");\n      return;\n    }\n    _socket.expires_after(std::chrono::seconds(5));\n    boost::asio::async_write(_socket,\n        boost::asio::buffer(message->data(), message->size()),\n        boost::asio::bind_executor(_strand,\n            std::bind(&Primary::HandleSent,\n                shared_from_this(),\n                std::placeholders::_1,\n                std::placeholders::_2,\n                message)));\n  });\n}", "CodeBleu_score": 33.214848496084635}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    if (!message->Valid()) {\n        log_error(\"Invalid message\");\n        return;\n    }\n    boost::asio::post(_strand, [this, message]() {\n        if (_socket.is_open()) {\n            _socket.expires_after(boost::posix_time::seconds(10));\n            boost::asio::async_write(_socket, boost::asio::buffer(message->data(), message->size()),\n                boost::asio::bind_executor(_strand, std::bind(&Primary::HandleSent, shared_from_this(), std::placeholders::_1, std::placeholders::_2)));\n        }\n    });\n}", "CodeBleu_score": 29.28037922909803}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (!message) {\n    return;\n  }\n  boost::asio::post(\n      _strand,\n      boost::asio::bind_executor(\n          _strand,\n          [this, message]() {\n            if (!_socket.is_open()) {\n              return;\n            }\n            boost::asio::steady_timer timer(_io_context);\n            timer.expires_after(std::chrono::seconds(5));\n            timer.async_wait(\n                boost::asio::bind_executor(\n                    _strand,\n                    [this](const boost::system::error_code &ec) {\n                      if (ec) {\n                        log_error(\"timer error:\", ec.message());\n                        return;\n                      }\n                      log_error(\"timeout\");\n                      Close();\n                    }));\n            boost::asio::async_write(\n                _socket,\n                boost::asio::buffer(message->data(), message->size()),\n                boost::asio::bind_executor(\n                    _strand,\n                    [this, message, &timer](const boost::system::error_code &ec, std::size_t) {\n                      timer.cancel();\n                      if (ec) {\n                        log_error(\"write error:\", ec.message());\n                        Close();\n                      }\n                    }));\n          }));\n}", "CodeBleu_score": 41.85388008055511}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\n  if (!ec) {\n\n    // The socket is open.\n\n    if (_socket.is_open()) {\n\n      // Initiate graceful connection closure.\n\n      _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n    }\n\n  }\n\n  // Notify caller that connection has been closed.\n\n  if (_on_closed) {\n\n    _on_closed(ec);\n\n  }\n\n  // Log the closure.\n\n  if (ec) {\n\n    log_error(\"primary: connection closed:\", ec.message());\n\n  } else {\n\n    log_debug(\"primary: connection closed\");\n\n  }\n\n}", "CodeBleu_score": 59.366864345431495}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (ec) {\n    if (ec == boost::asio::error::operation_aborted) {\n      return;\n    }\n  }\n  if (!socket.is_open()) {\n    return;\n  }\n  socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n  socket.close(ec);\n  if (ec) {\n    log_error(\"Primary::CloseNow:\", ec.message());\n  }\n  log_debug(\"Primary::CloseNow:\", \"Session closed.\");\n  boost::asio::post(strand, [this, self = shared_from_this()]() {\n    if (on_closed) {\n      on_closed();\n    }\n  });\n}", "CodeBleu_score": 51.26007363710294}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (!ec) {\n    // no error, just close.\n    if (socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      socket.close();\n    }\n  }\n\n  // trigger the on_closed callback.\n  if (on_closed) {\n    on_closed(ec);\n  }\n\n  // log that the session has been closed.\n  if (ec) {\n    log_error(\"session closed: %s\", ec.message().c_str());\n  } else {\n    log_debug(\"session closed\");\n  }\n}", "CodeBleu_score": 61.24421487158009}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t  // Create a buffer from the message\n  auto buffer = streaming::detail::tcp::MakeMessage(streaming::detail::MessageType::IsAlive);\n  // Log the sending action\n  Log(\"Sending message IsAlive to the next router.\");\n  // Write the buffer to the next router with the command YOU_ALIVE\n  Write(buffer, Command::YOU_ALIVE);\n  // Wait for and log the response from the system\n  Log(\"Waiting for response from the system.\");\n  // Read the response\n  Read(buffer);\n  // Log the response\n  Log(\"Response received.\");\n}", "CodeBleu_score": 28.333561659746646}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  // create buffer from message\n  carla::streaming::detail::tcp::Message message;\n  message.write_message(\"Are you alive?\");\n  auto buffer = message.MakeBuffer();\n\n  // log sending action\n  log_debug(\"sending message \\\"Are you alive?\\\"\");\n\n  // write buffer to next router with command YOU_ALIVE\n  auto next_router = _router->GetNext();\n  next_router->Write(buffer, Commands::YOU_ALIVE);\n\n  // wait for and log response\n  log_debug(\"waiting for response\");\n  auto response = next_router->Read();\n  log_debug(\"received response \\\"\" + response.message() + \"\\\"\");\n}", "CodeBleu_score": 51.27763946928706}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  // Create a buffer from the message\n  const auto buffer = streaming::detail::tcp::MakeMessage(streaming::detail::MessageType::IsAlive);\n  // Log the sending action\n  LOG_INFO(\"sending: \" << buffer);\n  // Write the buffer to the next router with the command YOU_ALIVE\n  Write(buffer, Command::YOU_ALIVE);\n  // Wait for and log the response from the system\n  LOG_INFO(\"received: \" << Read());\n}", "CodeBleu_score": 24.220407192492168}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n    // Check if sensor is found on any secondary server.\n    auto it = _secondary_servers.find(sensor_id);\n    if (it == _secondary_servers.end()) {\n        std::cerr << \"ERROR: Sensor \" << sensor_id << \" not found on any secondary server.\" << std::endl;\n        return;\n    }\n\n    // Create buffer with sensor ID.\n    std::vector<uint8_t> buffer(sizeof(sensor_id));\n    memcpy(buffer.data(), &sensor_id, sizeof(sensor_id));\n\n    // Send ENABLE_ROS command to server.\n    _router.Send(it->second.server_address, it->second.server_port, ENABLE_ROS, buffer);\n\n    // Wait for and process server's response.\n    auto response = _router.Receive();\n    if (response.command == ENABLE_ROS_SUCCESS) {\n        // Do nothing.\n    } else if (response.command == ENABLE_ROS_FAILURE) {\n        std::cerr << \"ERROR: Could not enable ROS for sensor \" << sensor_id << \".\" << std::endl;\n    } else {\n        std::cerr << \"ERROR: Received unexpected response from server.\" << std::endl;\n    }\n\n}", "CodeBleu_score": 53.49517534466618}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n    // Check if the sensor is active on any secondary server.\n    bool sensor_active = false;\n    for (auto& secondary : _secondaries) {\n        if (secondary->IsSensorActive(sensor_id)) {\n            sensor_active = true;\n            break;\n        }\n    }\n\n    // If the sensor is not active on any secondary server, log an error message.\n    if (!sensor_active) {\n        std::stringstream ss;\n        ss << \"Sensor \" << sensor_id << \" is not active on any secondary server.\";\n        _primary->LogError(ss.str());\n        return;\n    }\n\n    // Create a buffer with the sensor ID.\n    std::vector<char> buffer;\n    buffer.resize(sizeof(stream_id));\n    memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n\n    // Send an ENABLE_ROS command to the server using the router.\n    _router->Send(Commands::ENABLE_ROS, buffer);\n\n    // Wait for and process the server's response.\n    auto response = _router->Receive();\n    if (response.command() == Commands::ENABLE_ROS) {\n        if (response.buffer().size() == sizeof(stream_id)) {\n            stream_id response_id;\n            memcpy(&response_id, response.buffer().data(), sizeof(stream_id));\n            if (response_id == sensor_id) {\n                _primary->LogInfo(\"Sensor \" + std::to_string(sensor_id) + \" enabled for ROS.\");\n            } else {\n                std::stringstream ss;\n                ss << \"Sensor \" << sensor_id << \" is not active on any secondary server.\";\n                _primary->LogError(ss.str());\n            }\n        } else {\n            std::stringstream ss;\n            ss << \"Invalid response from server. Expected \" << sizeof(stream_id) << \" bytes, got \" << response.buffer().size() << \" bytes.\";\n            _primary->LogError(ss.str());\n        }\n    } else {\n        std::stringstream ss;\n        ss <<", "CodeBleu_score": 43.59492344132365}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n  // Check if sensor is activated on any secondary server\n  bool sensor_found = false;\n  for (auto& secondary : _secondaries) {\n    if (secondary->IsSensorActivated(sensor_id)) {\n      sensor_found = true;\n      break;\n    }\n  }\n\n  if (sensor_found) {\n\n    // Create buffer with sensor ID\n    std::vector<char> buffer;\n    buffer.resize(sizeof(sensor_id));\n    memcpy(buffer.data(), &sensor_id, sizeof(sensor_id));\n\n    // Send ENABLE_ROS command to router\n    _router->Send(Commands::ENABLE_ROS, buffer);\n\n    // Wait for response from router\n    auto response = _router->WaitForResponse();\n\n    // Process response\n    if (response.type == Commands::ENABLE_ROS_SUCCESS) {\n      // Log success message\n      std::cout << \"Sensor \" << sensor_id << \" enabled for ROS\" << std::endl;\n    } else if (response.type == Commands::ENABLE_ROS_FAILURE) {\n      // Log failure message\n      std::cout << \"Failed to enable sensor \" << sensor_id << \" for ROS\" << std::endl;\n    }\n\n  } else {\n\n    // Log error message\n    std::cout << \"Sensor \" << sensor_id << \" not activated on any secondary server\" << std::endl;\n\n  }\n\n}", "CodeBleu_score": 46.51818946381984}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  std::unique_lock<std::mutex> lock(mutex);\n\n  // Check if sensor is already activated\n  if (token_to_sensor.find(sensor_id) != token_to_sensor.end()) {\n    // If sensor is already activated, return the existing token\n    LOG_INFO(\"Sensor \" << sensor_id << \" already activated\");\n    return token_to_sensor.at(sensor_id);\n  }\n\n  // If sensor is not activated, enable sensor on a secondary server\n  LOG_INFO(\"Sensor \" << sensor_id << \" not activated\");\n\n  // Get a new token\n  token_type token = token_manager.Get();\n\n  // Get a secondary server\n  auto server = router.GetServer();\n\n  // Enable sensor on secondary server\n  server->EnableSensor(sensor_id);\n\n  // Update maps\n  token_to_sensor.insert(std::make_pair(token, sensor_id));\n  sensor_to_server.insert(std::make_pair(sensor_id, server));\n\n  // Return new token\n  LOG_INFO(\"Sensor \" << sensor_id << \" activated\");\n  return token;\n}", "CodeBleu_score": 46.3188838996132}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n  // Check if the sensor is already activated.\n  auto it = _sensor_to_token.find(sensor_id);\n  if (it != _sensor_to_token.end()) {\n    _logger->info(\"Sensor {} already activated.\", sensor_id);\n    return it->second;\n  }\n\n  // Retrieve the server that the sensor is connected to.\n  auto it2 = _sensor_to_server.find(sensor_id);\n  if (it2 == _sensor_to_server.end()) {\n    _logger->error(\"Sensor {} not found.\", sensor_id);\n    return -1;\n  }\n\n  // Enable the sensor on the secondary server.\n  _logger->info(\"Enabling sensor {} on server {}.\", sensor_id, it2->second);\n  auto server = _servers.find(it2->second);\n  if (server == _servers.end()) {\n    _logger->error(\"Server {} not found.\", it2->second);\n    return -1;\n  }\n  auto token = server->second->EnableSensor(sensor_id);\n  if (token == -1) {\n    _logger->error(\"Failed to enable sensor {} on server {}.\", sensor_id, it2->second);\n    return -1;\n  }\n\n  // Update the maps.\n  _sensor_to_token.insert({sensor_id, token});\n  _token_to_sensor.insert({token, sensor_id});\n\n  // Log the action.\n  _logger->info(\"Sensor {} activated on server {} with token {}.\", sensor_id, it2->second, token);\n\n  return token;\n}", "CodeBleu_score": 46.79760344391768}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    // Check if the sensor is already activated.\n    auto it = _sensor_to_token.find(sensor_id);\n    if (it != _sensor_to_token.end()) {\n        // If the sensor is already activated, return the existing token.\n        log_debug(\"Sensor\", sensor_id, \"is already activated, returning token\", it->second);\n        return it->second;\n    }\n\n    // If the sensor is not activated, enable the sensor on a secondary server.\n    log_debug(\"Sensor\", sensor_id, \"is not activated, enabling sensor on secondary server\");\n    auto token = _router.EnableSensor(sensor_id);\n\n    // Update the maps.\n    _sensor_to_token[sensor_id] = token;\n    _token_to_sensor[token] = sensor_id;\n\n    // Log the action.\n    log_debug(\"Sensor\", sensor_id, \"is now activated, returning token\", token);\n\n    // Return the new token.\n    return token;\n}", "CodeBleu_score": 54.36739972479128}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<char> buffer(std::istreambuf_iterator<char>(file), {});\n  file.close();\n  return Load(buffer.data(), buffer.size());\n}", "CodeBleu_score": 54.942565025819555}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n\n  file.seekg(0, std::ios::end);\n  const auto file_size = file.tellg();\n  file.seekg(0, std::ios::beg);\n\n  std::vector<char> buffer(file_size);\n  file.read(buffer.data(), file_size);\n\n  file.close();\n\n  return Load(buffer);\n}", "CodeBleu_score": 55.32242746281453}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<char> data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n  file.close();\n  return Load(data);\n}", "CodeBleu_score": 58.01693090315525}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  if (!_ready) {\n    return false;\n  }\n  if (_crowd == nullptr) {\n    return false;\n  }\n  if (_walker_manager.RemoveAgent(id)) {\n    return true;\n  }\n  if (_vehicle_manager.RemoveAgent(id)) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 31.860784285415512}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\n  if (!_ready) {\n    return false;\n  }\n\n  //assert(_crowd != nullptr);\n\n  // Search for the agent id in the walker and vehicle mappings.\n  auto it_walker = _walker_map.find(id);\n  auto it_vehicle = _vehicle_map.find(id);\n\n  // If the agent is a walker, enter a critical section to safely remove the agent from the crowd.\n  if (it_walker != _walker_map.end()) {\n\n    // Enter a critical section to safely remove the agent from the crowd.\n    std::lock_guard<std::mutex> lock(_crowd_mutex);\n\n    // Remove the agent from the crowd.\n    dtcrowdRemoveAgent(_crowd, it_walker->second);\n\n    // Update the walker manager.\n    _walker_manager->RemoveWalker(id);\n\n    // Remove the agent id from the walker mapping.\n    _walker_map.erase(it_walker);\n\n    return true;\n  }\n\n  // If the agent is a vehicle, enter a critical section to safely remove the agent from the crowd.\n  if (it_vehicle != _vehicle_map.end()) {\n\n    // Enter a critical section to safely remove the agent from the crowd.\n    std::lock_guard<std::mutex> lock(_crowd_mutex);\n\n    // Remove the agent from the crowd.\n    dtcrowdRemoveAgent(_crowd, it_vehicle->second);\n\n    // Update the vehicle manager.\n    _vehicle_manager->RemoveVehicle(id);\n\n    // Remove the agent id from the vehicle mapping.\n    _vehicle_map.erase(it_vehicle);\n\n    return true;\n  }\n\n  // The agent id is not in the navigation system.\n  return false;\n}", "CodeBleu_score": 59.48119080188672}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!ready) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  auto it = _walkers.find(id);\n  if (it != _walkers.end()) {\n    auto& walker = it->second;\n    crowd->removeAgent(walker.agent_id);\n    _walker_manager->RemoveWalker(id);\n    _walkers.erase(it);\n    return true;\n  }\n\n  it = _vehicles.find(id);\n  if (it != _vehicles.end()) {\n    auto& vehicle = it->second;\n    crowd->removeAgent(vehicle.agent_id);\n    _vehicle_manager->RemoveVehicle(id);\n    _vehicles.erase(it);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 61.230504381309736}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  // Collect the IDs of currently mapped vehicles into a set.\n  std::set<int> vehicle_ids;\n  for (auto it = vehicle_map.begin(); it != vehicle_map.end(); ++it) {\n    vehicle_ids.insert(it->first);\n  }\n\n  // Add or update vehicles from the provided list, marking them as updated.\n  for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n    vehicle_map[it->vehicle_id] = *it;\n    vehicle_ids.erase(it->vehicle_id);\n  }\n\n  // Remove vehicles not marked as updated, indicating they do not exist in the current frame.\n  for (auto it = vehicle_ids.begin(); it != vehicle_ids.end(); ++it) {\n    vehicle_map.erase(*it);\n  }\n\n  return true;\n\n}", "CodeBleu_score": 51.41301798933793}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  std::set<uint32_t> current_vehicle_ids;\n\n  for (auto& vehicle : vehicles) {\n    current_vehicle_ids.insert(vehicle.id);\n    if (vehicles_.find(vehicle.id) != vehicles_.end()) {\n      vehicles_[vehicle.id] = vehicle;\n      vehicles_[vehicle.id].updated = true;\n    } else {\n      vehicles_.insert({vehicle.id, vehicle});\n    }\n  }\n\n  for (auto& vehicle : vehicles_) {\n    if (!vehicle.second.updated) {\n      vehicles_.erase(vehicle.first);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 47.63269960052373}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> current_vehicle_ids;\n    for (auto& v : vehicles) {\n        current_vehicle_ids.insert(v.id);\n    }\n\n    for (auto& v : vehicles) {\n        auto it = _vehicles.find(v.id);\n        if (it != _vehicles.end()) {\n            it->second.Update(v);\n        } else {\n            _vehicles.insert(std::make_pair(v.id, Vehicle(v)));\n        }\n    }\n\n    for (auto it = _vehicles.begin(); it != _vehicles.end();) {\n        if (current_vehicle_ids.find(it->first) == current_vehicle_ids.end()) {\n            it = _vehicles.erase(it);\n        } else {\n            it++;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 53.090304432514365}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    auto it = _walkers.find(id);\n    if (it != _walkers.end()) {\n        return _crowd_system->HasVehicleNear(it->second, distance, direction);\n    }\n\n    it = _vehicles.find(id);\n    if (it != _vehicles.end()) {\n        return _crowd_system->HasVehicleNear(it->second, distance, direction);\n    }\n\n    return false;\n}", "CodeBleu_score": 56.420371619441426}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n    std::lock_guard<std::mutex> lock(mutex);\n\n    auto it = actors.find(id);\n    if (it != actors.end()) {\n        auto actor = it->second;\n        if (actor != nullptr) {\n            auto loc = actor->GetLocation();\n            auto squared_distance = loc.DistanceSquared(direction);\n            if (squared_distance < distance * distance) {\n                return crowd_system->IsVehicleNear(loc, squared_distance);\n            }\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 51.171495173512206}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_critical_section);\n\n  auto it = _walkers.find(id);\n  if (it != _walkers.end()) {\n    const WalkerData& data = it->second;\n    const float squared_distance = (data.location - direction).SquaredLength();\n    return data.crowd_system->IsVehicleNear(data.location, squared_distance);\n  }\n\n  it = _vehicles.find(id);\n  if (it != _vehicles.end()) {\n    const VehicleData& data = it->second;\n    const float squared_distance = (data.location - direction).SquaredLength();\n    return data.crowd_system->IsVehicleNear(data.location, squared_distance);\n  }\n\n  return false;\n}", "CodeBleu_score": 49.86982338185699}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\n    // Retrieve the current route point for the walker.\n    RoutePoint *route_point = info.route_point;\n\n    // Create a WalkerEventVisitor with the current context.\n    WalkerEventVisitor visitor(info, delta);\n\n    // Process the event at the current route point using boost::variant2::visit.\n    return boost::variant2::visit(visitor, route_point->event);\n}", "CodeBleu_score": 52.45583835366061}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  if (info.route.empty()) {\n    return EventResult::NO_ROUTE;\n  }\n\n  const RoutePoint &route_point = info.route.front();\n\n  WalkerEventVisitor visitor(info, route_point, delta);\n\n  return boost::apply_visitor(visitor, route_point.event);\n}", "CodeBleu_score": 39.53648465749225}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  EventResult result;\n  if (info.route.size() > 0) {\n    auto waypoint = info.route.front();\n    auto event = waypoint.GetEvent();\n    if (event != nullptr) {\n      WalkerEventVisitor visitor(info, delta);\n      result = event->Accept(visitor);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 46.24889102465387}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    std::string id = road_node.attribute(\"id\").value();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      ParseLanes(lane_section_node, map_builder, id);\n    }\n  }\n}", "CodeBleu_score": 28.216302234248413}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const std::string road_id = road_node.attribute(\"id\").value();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      ParseLanes(lane_section_node, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 28.372135993626358}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const std::string road_id = road_node.attribute(\"id\").value();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      ParseLanes(lane_section_node, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 28.372135993626358}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    if (info.current_count_change == 1) {\n        m_matched = info.total_count;\n        m_firstConnected = true;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        m_matched = info.total_count;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 78.15383544152112}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::cout << \"CarlaListenerImpl::on_publication_matched\" << std::endl;\n    if (info.current_count_change == 1) {\n        std::cout << \"Matched\" << std::endl;\n        matched_ = info.current_count;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Unmatched\" << std::endl;\n        matched_ = info.current_count;\n    } else {\n        std::cout << \"ERROR: Unexpected change in matched count: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 65.80326075780198}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n\n    if (info.current_count_change == 1) {\n        matched_ = info.current_count;\n        first_connected_ = true;\n        std::cout << \"First connection\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_ = info.current_count;\n        std::cout << \"Lost connection\" << std::endl;\n    } else {\n        std::cout << \"Error in connection\" << std::endl;\n    }\n\n    cv_.notify_one();\n}", "CodeBleu_score": 60.32960944345918}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n        ++matched_;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        --matched_;\n        if (matched_ == 0) {\n            first_connected_ = false;\n        }\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 66.144889677052}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\n    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n        std::cout << \"Subscription matched\" << std::endl;\n        std::cout << \"  total count: \" << info.total_count << std::endl;\n        std::cout << \"  current count: \" << info.current_count << std::endl;\n        std::cout << \"  status: \" << (info.last_publication_handle.is_valid() ? \"ALIVE\" : \"NOT_ALIVE_DISPOSED\") << std::endl;\n        std::cout << \"  handle: \" << info.last_publication_handle << std::endl;\n        std::cout << \"  guid: \" << info.last_publication_handle.guid() << std::endl;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        std::cout << \"Subscription unmatched\" << std::endl;\n        std::cout << \"  total count: \" << info.total_count << std::endl;\n        std::cout << \"  current count: \" << info.current_count << std::endl;\n        std::cout << \"  status: \" << (info.last_publication_handle.is_valid() ? \"ALIVE\" : \"NOT_ALIVE_DISPOSED\") << std::endl;\n        std::cout << \"  handle: \" << info.last_publication_handle << std::endl;\n        std::cout << \"  guid: \" << info.last_publication_handle.guid() << std::endl;\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 59.37256110448601}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t  std::unique_lock<std::mutex> lock(m_mutex);\n\n  if (info.current_count_change == 1) {\n    ++m_matched_count;\n    if (m_matched_count == 1) {\n      m_first_connected = true;\n    }\n  } else if (info.current_count_change == -1) {\n    --m_matched_count;\n    if (m_matched_count == 0) {\n      m_first_connected = false;\n    }\n  } else {\n    std::cerr << \"error: unexpected subscription status change: \" << info.current_count_change << std::endl;\n  }\n\n  lock.unlock();\n  m_cv.notify_one();\n}", "CodeBleu_score": 57.52198215242452}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Objects with different serialized size may have keys of different sizes\n    if(force_md5 ||\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16)\n    {\n        m_md5.init();\n        if(p_type->serializeKey(&m_md5))\n        {\n            m_md5.finalize();\n            m_md5.getDigest(reinterpret_cast<unsigned char*>(&handle->value[0]));\n        }\n    }\n    else\n    {\n        if(p_type->serializeKey(&m_no_md5))\n        {\n            for(uint8_t i = 0;i<16;++i)\n            {\n                handle->value[i] = m_no_md5.m_no_md5.value[i];\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 45.76192853330758}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Serialization.\n    FastBuffer buffer;\n    buffer.add_cdr_message(*p_type);\n\n    // Key definition.\n    if(!this->m_isGetKeyDefined)\n    {\n        return false;\n    }\n\n    // Key.\n    InstanceHandle_t ihandle;\n\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16)\n    {\n        MD5 m;\n        ihandle = m.generate(buffer.getBuffer(), buffer.getBufferLen());\n    }\n    else\n    {\n        memcpy(&ihandle, buffer.getBuffer(), CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    }\n\n    *handle = ihandle;\n    return true;\n}", "CodeBleu_score": 37.57850582619402}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!m_isGetKeyDefined)\n        return false;\n\n    eprosima::fastcdr::FastBuffer buffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(buffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16)\n    {\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->id);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->type);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->actor1);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->actor2);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->normalImpulse);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->normalImpulseAux);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->tangentImpulse);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->tangentImpulseAux);\n        compute_md5(m_keyBuffer, static_cast<uint32_t>(ser.getSerializedDataLength()), handle);\n    }\n    else\n    {\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->id);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->type);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->actor1);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->actor2);\n        ser.serialize(reinterpret_cast<CarlaCollisionEvent*>(data)->normalImpulse);\n        ser.serialize", "CodeBleu_score": 33.969231036754444}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl *p_type = (CarlaEgoVehicleControl *) data;\n        ser << p_type->throttle;\n        ser << p_type->steer;\n        ser << p_type->brake;\n        ser << p_type->hand_brake;\n        ser << p_type->reverse;\n        ser << p_type->manual_gear_shift;\n        ser << p_type->gear;\n        ser << p_type->manual_first_gear;\n        ser << p_type->manual_gear_shift_up;\n        ser << p_type->manual_gear_shift_down;\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 63.149167321370435}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl *p_type = (CarlaEgoVehicleControl *) data;\n        ser << p_type->throttle;\n        ser << p_type->steer;\n        ser << p_type->brake;\n        ser << p_type->hand_brake;\n        ser << p_type->reverse;\n        ser << p_type->manual_gear_shift;\n        ser << p_type->gear;\n        ser << p_type->manual_brake;\n        ser << p_type->manual_steering;\n        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n        return true;\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n}", "CodeBleu_score": 62.29391398462181}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl *p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 75.81309683260356}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\n  if (target_set) {\n    return;\n  }\n\n  switch (msg.msgid) {\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n      mavlink_global_position_int_t pos;\n      mavlink_msg_global_position_int_decode(&msg, &pos);\n      target_sysid = pos.sysid;\n      target_set = true;\n      break;\n    }\n    case MAVLINK_MSG_ID_ATTITUDE: {\n      mavlink_attitude_t att;\n      mavlink_msg_attitude_decode(&msg, &att);\n      target_sysid = att.sysid;\n      target_set = true;\n      break;\n    }\n    case MAVLINK_MSG_ID_GPS_RAW_INT: {\n      mavlink_gps_raw_int_t gps;\n      mavlink_msg_gps_raw_int_decode(&msg, &gps);\n      target_sysid = gps.sysid;\n      target_set = true;\n      break;\n    }\n    case MAVLINK_MSG_ID_SYS_STATUS: {\n      mavlink_sys_status_t status;\n      mavlink_msg_sys_status_decode(&msg, &status);\n      target_sysid = status.sysid;\n      target_set = true;\n      break;\n    }\n    case MAVLINK_MSG_ID_SCALED_PRESSURE: {\n      mavlink_scaled_pressure_t pressure;\n      mavlink_msg_scaled_pressure_decode(&msg, &pressure);\n      target_sysid = pressure.sysid;\n      target_set = true;\n      break;\n    }\n    case MAVLINK_MSG_ID_SCALED_PRESSURE2: {\n      mavlink_scaled_pressure2_t pressure2;\n      mavlink_msg_scaled_pressure2_decode(&msg, &pressure2);\n      target_", "CodeBleu_score": 39.39305292320916}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_set) {\n        return;\n    }\n\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT && msg.msgid != MAVLINK_MSG_ID_SYS_STATUS && msg.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid != MAVLINK_MSG_ID_VFR_HUD && msg.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid != MAVLINK_MSG_ID_GPS_STATUS && msg.msgid != MAVLINK_MSG_ID_VFR_HUD && msg.msgid != MAVLINK_MSG_ID_SYS_STATUS && msg.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid != MAVLINK_MSG_ID_GPS_STATUS && msg.msgid != MAVLINK_MSG_ID_VFR_HUD && msg.msgid != MAVLINK_MSG_ID_SYS_STATUS && msg.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid != MAVLINK_MSG_ID_GPS_STATUS && msg.msgid != MAVLINK_MSG_ID_VFR_HUD && msg.msgid != MAVLINK_MSG_ID_SYS_STATUS && msg.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid != MAVLINK_MSG_ID_GPS_STATUS && msg.msgid != MAVLINK_MSG_ID_VFR_HUD && msg.msgid != MAVLINK_MSG_ID_SYS_STATUS && msg.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid != MAVLINK_MSG_ID_GPS_STATUS && msg.msgid != MAVLINK_MSG_ID_VFR_HUD && msg.msgid != MAVLIN", "CodeBleu_score": 38.23820613700557}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t  if (target_set) {\n    return;\n  }\n  switch (msg.msgid) {\n  case MAVLINK_MSG_ID_GPS_RAW_INT:\n    if (target_sysid == 0) {\n      target_sysid = msg.sysid;\n      request_stream(MAVLINK_MSG_ID_GPS_RAW_INT, 1);\n      request_stream(MAVLINK_MSG_ID_SCALED_PRESSURE, 1);\n    }\n    break;\n  case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n    if (target_sysid == 0) {\n      target_sysid = msg.sysid;\n      request_stream(MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1);\n      request_stream(MAVLINK_MSG_ID_SCALED_PRESSURE, 1);\n    }\n    break;\n  case MAVLINK_MSG_ID_SCALED_PRESSURE:\n    if (target_sysid == 0) {\n      target_sysid = msg.sysid;\n      request_stream(MAVLINK_MSG_ID_SCALED_PRESSURE, 1);\n    }\n    break;\n  case MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n    if (target_sysid == 0) {\n      target_sysid = msg.sysid;\n      request_stream(MAVLINK_MSG_ID_LOCAL_POSITION_NED, 1);\n      request_stream(MAVLINK_MSG_ID_SCALED_PRESSURE, 1);\n    }\n    break;\n  default:\n    return;\n  }\n  target_set = true;\n}", "CodeBleu_score": 31.794059914303908}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibrate_altitude = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.2448439217719}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _altitude_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 69.13981398489717}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = MAV_RESULT_DENIED;\n\n    // call the base class handler\n    result = GCS_MAVLINK::handle_message(msg);\n\n    // if the command was accepted, set the flag to indicate that we need to calibrate altitude on the next baro update\n    if (result == MAV_RESULT_ACCEPTED) {\n        _state->baro_calibration_needed = true;\n    }\n\n    // return the result of the base class handler\n    return result;\n}", "CodeBleu_score": 51.87783627045259}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t  if (packet.param1 == 1.0) {\n    Tracker::instance->arm_servos();\n    return MAV_RESULT_ACCEPTED;\n  }\n  else if (packet.param1 == 0) {\n    Tracker::instance->disarm_servos();\n    return MAV_RESULT_ACCEPTED;\n  }\n  else {\n    return MAV_RESULT_UNSUPPORTED;\n  }\n}", "CodeBleu_score": 59.304489805813745}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tif (tracker.arm()) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else if (packet.param1 == 0.0) {\n\t\tif (tracker.disarm()) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_FAILED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 54.3820454973165}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t  if (packet.param1 == 1.0) {\n    Tracker::instance->arm_servos();\n    return MAV_RESULT_ACCEPTED;\n  } else if (packet.param1 == 0) {\n    Tracker::instance->disarm_servos();\n    return MAV_RESULT_ACCEPTED;\n  } else {\n    return MAV_RESULT_UNSUPPORTED;\n  }\n}", "CodeBleu_score": 59.12924557865308}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n    // Check if the system and component ID are already being tracked.\n    if (is_tracking(sysid, compid)) {\n        // If so, do nothing.\n        return;\n    }\n\n    // Check if there is available payload space on any of the GCS channels.\n    for (uint8_t i = 0; i < GCS_NUM_CHANNELS; i++) {\n        if (gcs_channels[i].available_payload_space() >= sizeof(mavlink_global_position_int_t)) {\n            // If so, start a data stream with the specified update rate.\n            gcs_channels[i].start_datastream_position(sysid, compid, update_rate);\n            // Add the system and component ID to the list of tracked systems.\n            tracked_systems.push_back(sysid);\n            tracked_components.push_back(compid);\n            // Exit the for loop.\n            break;\n        }\n    }\n}", "CodeBleu_score": 48.55791019980849}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n    // Iterate over all GCS channels\n    for (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n\n        // Check if the payload space is available\n        if (gcs_payload_space[i] >= 10) {\n\n            // Send a request to start the data stream\n            gcs[i]->send_request_datastream_position(sysid, compid, 10);\n\n            // Decrease the available payload space\n            gcs_payload_space[i] -= 10;\n\n            // Break the loop\n            break;\n\n        }\n\n    }\n\n}", "CodeBleu_score": 42.271295759706476}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    // Check if the system and component ID are already tracked\n    if (tracked_systems.find(sysid) != tracked_systems.end()) {\n        if (tracked_systems[sysid].find(compid) != tracked_systems[sysid].end()) {\n            // The system and component ID are already tracked, so return\n            return;\n        }\n    }\n\n    // Check if the system and component ID are already tracked\n    if (tracked_systems.find(sysid) != tracked_systems.end()) {\n        if (tracked_systems[sysid].find(compid) != tracked_systems[sysid].end()) {\n            // The system and component ID are already tracked, so return\n            return;\n        }\n    }\n\n    // Iterate over the available GCS channels\n    for (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n        // Check if there is enough payload space to send the request\n        if (gcs_channels[i].get_payload_space() >= 12) {\n            // Send the request to start the data stream\n            gcs_channels[i].request_datastream_position(sysid, compid);\n            // Add the system and component ID to the tracked systems\n            tracked_systems[sysid][compid] = i;\n            // Return\n            return;\n        }\n    }\n}", "CodeBleu_score": 45.86957432027739}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\n    // Retrieve the AHRS instance\n    AHRS* ahrs = Tracker::ahrs;\n\n    // Check for zero pitch cosine\n    if (ahrs->getPitchRadians() == 0) {\n        return false;\n    }\n\n    // Calculate the earth frame pitch and yaw\n    ef_pitch = atan2(sin(pitch), cos(pitch) * cos(yaw));\n    ef_yaw = atan2(sin(yaw) * cos(pitch), cos(yaw));\n\n    return true;\n\n}", "CodeBleu_score": 49.09017798707583}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AHRS* ahrs = Tracker::ahrs();\n    float pitch_cos = ahrs->pitch_cos();\n    if (pitch_cos == 0) {\n        return false;\n    }\n    ef_pitch = -atan2(pitch, pitch_cos);\n    ef_yaw = yaw + ahrs->yaw();\n    return true;\n}", "CodeBleu_score": 49.659330108476865}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  if (ahrs->getPitchCos() != 0) {\n    ef_pitch = ahrs->getPitch() + atan2(sin(pitch), cos(pitch) * cos(ahrs->getPitch()));\n    ef_yaw = ahrs->getYaw() + atan2(sin(yaw), cos(yaw) * cos(ahrs->getPitch()));\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 48.485490843979626}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\n  // Calculate the target yaw and pitch in centidegrees\n  target_yaw = (int) (100 * (yaw_kp * (nav_status.yaw_error) + yaw_ki * (nav_status.yaw_error_i)));\n  target_pitch = (int) (100 * (pitch_kp * (nav_status.pitch_error) + pitch_ki * (nav_status.pitch_error_i)));\n\n  // Check if the direction is reversed\n  if (nav_status.direction_reversed) {\n    target_yaw = -target_yaw;\n    target_pitch = -target_pitch;\n  }\n\n  // Compute the angle error in centidegrees\n  nav_status.angle_error = (int) (100 * (nav_status.pitch_error + nav_status.yaw_error));\n\n  // Convert the errors from earth frame to body frame\n  nav_status.angle_error_earth = nav_status.angle_error;\n  nav_status.angle_error = (int) (100 * (nav_status.angle_error_earth * cos(nav_status.yaw_error * M_PI / 18000) + nav_status.yaw_error * sin(nav_status.yaw_error * M_PI / 18000)));\n  nav_status.angle_error_i_earth = nav_status.angle_error_i;\n  nav_status.angle_error_i = (int) (100 * (nav_status.angle_error_i_earth * cos(nav_status.yaw_error_i * M_PI / 18000) + nav_status.yaw_error_i * sin(nav_status.yaw_error_i * M_PI / 18000)));\n\n  // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n  if (nav_status.target_distance_valid || !min_distance_enabled) {\n    tracker.set_", "CodeBleu_score": 30.338619709448455}, {"code": "void Mode::update_auto(void){\n\t  // Get the current yaw and pitch\n  int16_t yaw_earth = Tracker::get_yaw();\n  int16_t pitch_earth = Tracker::get_pitch();\n\n  // Calculate the target yaw and pitch\n  int16_t yaw_target = Tracker::get_target_yaw();\n  int16_t pitch_target = Tracker::get_target_pitch();\n\n  // Check if the direction is reversed\n  bool direction_reversed = Tracker::get_direction_reversed();\n\n  // Calculate the angle error\n  int16_t yaw_error = yaw_target - yaw_earth;\n  int16_t pitch_error = pitch_target - pitch_earth;\n\n  // Convert the errors from earth frame to body frame\n  if (direction_reversed) {\n    yaw_error = -yaw_error;\n    pitch_error = -pitch_error;\n  }\n\n  // Update the servos if the target distance is valid or no minimum distance is set\n  if (Tracker::get_target_distance_valid() || Tracker::get_min_distance() == 0) {\n    Tracker::set_pitch_servo(pitch_error);\n    Tracker::set_yaw_servo(yaw_error);\n  }\n}", "CodeBleu_score": 24.437929558227072}, {"code": "void Mode::update_auto(void){\n\t  float yaw, pitch, yaw_error, pitch_error, yaw_error_c, pitch_error_c;\n  float yaw_error_b, pitch_error_b;\n  float yaw_error_b_c, pitch_error_b_c;\n  float yaw_error_b_c_s, pitch_error_b_c_s;\n  float yaw_error_b_c_s_i, pitch_error_b_c_s_i;\n  float yaw_error_b_c_s_i_d, pitch_error_b_c_s_i_d;\n  float yaw_error_b_c_s_i_d_max;\n  float yaw_error_b_c_s_i_d_max_rev;\n  float yaw_error_b_c_s_i_d_min;\n  float yaw_error_b_c_s_i_d_min_rev;\n  float yaw_error_b_c_s_i_d_min_rev_abs;\n  float yaw_error_b_c_s_i_d_max_rev_abs;\n  float yaw_error_b_c_s_i_d_min_rev_abs_s;\n  float yaw_error_b_c_s_i_d_max_rev_abs_s;\n  float yaw_error_b_c_s_i_d_min_rev_abs_s_i;\n  float yaw_error_b_c_s_i_d_max_rev_abs_s_i;\n  float yaw_error_b_c_s_i_d_min_rev_abs_s_i_d;\n  float yaw_error_b_c_s_i_d_max_rev_abs_s_i_d;\n  float yaw_error_b_c_s_i_d_min_rev_abs_s_i_d_max;\n  float yaw_error_b_c_s_i_d_max_rev_abs_s_i_d_max", "CodeBleu_score": 7.308681373097045}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS\n\tgps_data.update();\n\n\t// Check if GPS status has changed\n\tif (gps_data.get_status() != gps_status) {\n\t\tgps_status = gps_data.get_status();\n\t\tif (gps_status == 3) {\n\t\t\tSerial.println(\"GPS has 3D fix\");\n\t\t}\n\t}\n\n\t// Check if GPS location has changed\n\tif (gps_data.get_location() != gps_location) {\n\t\tgps_location = gps_data.get_location();\n\t\tif (gps_location.is_valid()) {\n\t\t\tSerial.println(\"GPS location is valid\");\n\t\t\tif (gps_countdown > 0) {\n\t\t\t\tgps_countdown--;\n\t\t\t\tif (gps_countdown == 0) {\n\t\t\t\t\tgps_home_location = gps_location;\n\t\t\t\t\tSerial.println(\"GPS home location set\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgps_countdown = GPS_COUNTDOWN;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.0367165147368}, {"code": "void Tracker::update_GPS(void){\n\t    // GPS\n    gps.read();\n\n    if (gps.last_message_time() != last_message_time) {\n        last_message_time = gps.last_message_time();\n\n        if (gps.status() >= 3) {\n            // If the GPS status is at least 3D fix, update the location\n            location.latitude = gps.location.lat();\n            location.longitude = gps.location.lng();\n            location.altitude = gps.altitude.meters();\n            location.speed = gps.speed.kmph();\n            location.heading = gps.heading.deg();\n\n            // If the location is valid, update the home location if needed\n            if (location.is_valid()) {\n                if (ground_start_countdown > 0) {\n                    ground_start_countdown--;\n                }\n\n                if (ground_start_countdown == 1) {\n                    home_location.latitude = location.latitude;\n                    home_location.longitude = location.longitude;\n                    home_location.altitude = location.altitude;\n                    home_location.speed = location.speed;\n                    home_location.heading = location.heading;\n                    ground_start_countdown = 0;\n                }\n            } else {\n                // If the location is invalid, reset the countdown\n                ground_start_countdown = ground_start_countdown_max;\n            }\n        }\n    }\n}", "CodeBleu_score": 53.78543181057314}, {"code": "void Tracker::update_GPS(void){\n\t    //Update GPS data\n    gps_data = gps.read();\n\n    //Check if GPS status has changed\n    if (gps_data.status != gps_status) {\n        gps_status = gps_data.status;\n        if (gps_status == 3) {\n            Serial.println(\"GPS has 3D fix\");\n        }\n    }\n\n    //Check if the last message time has changed\n    if (gps_data.time != gps_time) {\n        gps_time = gps_data.time;\n\n        //If the gps has a 3D fix, start the ground start countdown\n        if (gps_status == 3) {\n            ground_start_countdown--;\n            if (ground_start_countdown <= 0) {\n                //Set the home location if the current location is valid\n                if (gps_data.location.isValid()) {\n                    home_location = gps_data.location;\n                    Serial.println(\"Home location set\");\n                    Serial.println(home_location.lat(), 6);\n                    Serial.println(home_location.lng(), 6);\n                    Serial.println(home_location.alt(), 2);\n                    Serial.println(gps_data.satellites.value());\n                    Serial.println(gps_data.hdop.value());\n                    Serial.println(gps_data.pdop.value());\n                    Serial.println(gps_data.vdop.value());\n                    Serial.println(gps_data.location.age());\n                    Serial.println(gps_data.speed.mps());\n                    Serial.println(gps_data.course.deg());\n                    Serial.println(gps_data.altitude.meters());\n                    Serial.println(gps_data.charsProcessed());\n                    Serial.println(gps_data.sentencesWithFix());\n                    Serial.println(gps_data.failedChecksum());\n                    Serial.println(gps_data.passedChecksum());\n                }\n                else {\n                   ", "CodeBleu_score": 41.63467289006856}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // 1100 is the pulse width for the pitch servo when it is at 0 degrees\n    // 1900 is the pulse width for the pitch servo when it is at 90 degrees\n    // 1500 is the pulse width for the pitch servo when it is at 45 degrees\n    // 1700 is the pulse width for the pitch servo when it is at 60 degrees\n    // 1300 is the pulse width for the pitch servo when it is at 30 degrees\n    // 1000 is the pulse width for the pitch servo when it is at 15 degrees\n    // 1600 is the pulse width for the pitch servo when it is at 40 degrees\n    // 1400 is the pulse width for the pitch servo when it is at 20 degrees\n    // 1800 is the pulse width for the pitch servo when it is at 50 degrees\n    // 1200 is the pulse width for the pitch servo when it is at 25 degrees\n    // 2000 is the pulse width for the pitch servo when it is at 70 degrees\n    // 1900 is the pulse width for the pitch servo when it is at 80 degrees\n    // 1100 is the pulse width for the pitch servo when it is at 0 degrees\n    // 1900 is the pulse width for the pitch servo when it is at 90 degrees\n    // 1500 is the pulse width for the pitch servo when it is at 45 degrees\n    // 1700 is the pulse width for the pitch servo when it is at 60 degrees\n    // 1300 is the pulse width for the pitch servo when it is at 30 degrees\n    // 1000 is the pulse width for the pitch servo when it is at 15 degrees\n    // 1600 is the pulse width for the pitch servo when it is at 40 degrees\n    // 1400 is the pulse width for the pitch servo when it is", "CodeBleu_score": 4.623232010724218}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // Update the pitch servo position\n    pitch_onoff_servo.write(pitch);\n}", "CodeBleu_score": 9.580934038231852}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch < 0) {\n\t\tpitch = 0;\n\t}\n\telse if (pitch > 180) {\n\t\tpitch = 180;\n\t}\n\telse {\n\t\tpitch = 180 - pitch;\n\t}\n\tpitch_onoff_servo.write(pitch);\n}", "CodeBleu_score": 13.135317425255245}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\n    // call base class\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro altitude\n    if (arming_checks_enabled(ARMING_CHECK_BARO)) {\n        if (abs(ahrs.get_barometer().get_altitude() - ahrs.get_home().alt) > 50) {\n            if (display_failure) {\n                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"Baro ref failure\");\n            }\n            return false;\n        }\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 36.2425977672651}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call the base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro altitude\n    if (arming_checks_enabled(ARMING_CHECK_BARO)) {\n        float baro_altitude = _barometer.get_altitude();\n        float inav_altitude = _inertial_nav.get_altitude();\n        if (fabsf(baro_altitude - inav_altitude) > _baro_alt_max_displacement) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro alt diff too high\"));\n            }\n            return false;\n        }\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 42.21160222283407}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\n    // call parent class to perform standard checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // if we get this far, we have a good barometer\n\n    // check baro altitude\n    if (arming_checks_enabled(ARMING_CHECK_BARO)) {\n        if (abs(ahrs.get_altitude() - barometer.get_altitude()) > 100) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro alt differs too much from GPS alt\"));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 33.15597144800487}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (_terrain_source == Terrain_Source::Rangefinder) {\n        return false;\n    }\n    if (_terrain_source == Terrain_Source::Terrain_Database && _rtl_alt_type == AP_Arming::RTL_Alt_Type::Terrain) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 57.081558683481504}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (aparm.rtl_alt_type == AP_RTL::RTL_ALT_TERRAIN) {\n        if (aparm.terrain_source == AP_Terrain::TerrainSourceRangeFinder) {\n            return false;\n        }\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 52.65151502414081}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (_terrain_source == TerrainSourceRangefinder) {\n        return false;\n    }\n    if (_terrain_source == TerrainSourceTerrainDB && _rtl_alt_type == AP_Rally::RTL_AltitudeTerrain) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 54.371974339118424}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\n\t// get last loop time from scheduler\n\tuint32_t last_loop_time_us = scheduler.get_last_loop_time_micros();\n\n\t// set loop time for attitude, position, and motor controllers\n\tattitude_control.set_dt(last_loop_time_us);\n\tposition_control.set_dt(last_loop_time_us);\n\tmotor_control.set_dt(last_loop_time_us);\n\n\t// run attitude controllers\n\tattitude_control.rate_controller_run();\n\n\t// run position controllers\n\tposition_control.rate_controller_run();\n\n\t// run motor controllers\n\tmotor_control.rate_controller_run();\n\n}", "CodeBleu_score": 57.340999492936284}, {"code": "void Copter::run_rate_controller(){\n\t  // get time since last loop\n  uint32_t loop_time = scheduler.micros() - last_run_time_us;\n  last_run_time_us = scheduler.micros();\n\n  // set loop time for attitude, position, and motor controllers\n  attitude_control.set_dt(loop_time);\n  position_control.set_dt(loop_time);\n  motor_control.set_dt(loop_time);\n\n  // run attitude rate controller\n  attitude_control.rate_controller_run();\n}", "CodeBleu_score": 59.177771063221996}, {"code": "void Copter::run_rate_controller(){\n\t\n\t// get the loop time\n\tfloat dt = scheduler.last_loop_time_micros() * 1.0e-6f;\n\n\t// run the attitude controller\n\tattitude_control.rate_controller_run(dt);\n\n\t// run the position controller\n\tposition_control.rate_controller_run(dt);\n\n\t// run the motor controllers\n\tmotor_control.motor_run();\n}", "CodeBleu_score": 39.71779879156991}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.alt_frame != new_loc.alt_frame) {\n        return false;\n    }\n\n    if (old_loc.latitude != new_loc.latitude || old_loc.longitude != new_loc.longitude) {\n        return false;\n    }\n\n    target_location = new_loc;\n    return true;\n}", "CodeBleu_score": 47.06808439795685}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (old_loc.get_waypoint() != new_loc.get_waypoint() || old_loc.get_altitude_frame() != new_loc.get_altitude_frame()) {\n        target_location = new_loc;\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 47.46555255878935}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (new_loc.latitude == old_loc.latitude && new_loc.longitude == old_loc.longitude && new_loc.altitude_frame == old_loc.altitude_frame) {\n        return false;\n    }\n    target_location = new_loc;\n    return true;\n}", "CodeBleu_score": 44.92319964021677}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t  if (rc().get_aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n    copter().set_mode(mode);\n  } else if (copter().get_mode() == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 54.897718061328106}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t  if (rc().aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n    copter().set_mode(mode);\n  } else if (copter().mode() == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 54.54609621139195}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t  if (ch_flag == AuxSwitchPos::HIGH) {\n    copter.set_mode(mode);\n  } else if (copter.get_mode() == mode) {\n    copter.rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 46.636686555933196}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t/* Saving trim */\n\tfloat trim_roll = 0.0f;\n\tfloat trim_pitch = 0.0f;\n\tif (g.rc_1.control_in > 0) {\n\t\ttrim_roll = g.rc_1.control_in * g.rc_1.trim;\n\t} else if (g.rc_1.control_in < 0) {\n\t\ttrim_roll = g.rc_1.control_in * g.rc_1.trim;\n\t}\n\tif (g.rc_2.control_in > 0) {\n\t\ttrim_pitch = g.rc_2.control_in * g.rc_2.trim;\n\t} else if (g.rc_2.control_in < 0) {\n\t\ttrim_pitch = g.rc_2.control_in * g.rc_2.trim;\n\t}\n\tahrs.set_trim(ToRad(trim_roll), ToRad(trim_pitch));\n\tLog_Write_Event(DATA_SAVE_TRIM);\n\tmavlink_and_console_log_info(dataFlash, \"Saved trim\");\n}", "CodeBleu_score": 37.37796920576205}, {"code": "void Copter::save_trim(){\n\t    float trim_roll = 0.0f;\n    float trim_pitch = 0.0f;\n    float trim_yaw = 0.0f;\n\n    // get trim values\n    trim_roll = pwm_input->get_control_in(rc_channel_roll->get_channel()-1) * 0.01f;\n    trim_pitch = pwm_input->get_control_in(rc_channel_pitch->get_channel()-1) * 0.01f;\n    trim_yaw = pwm_input->get_control_in(rc_channel_yaw->get_channel()-1) * 0.01f;\n\n    // convert to radians\n    trim_roll = radians(trim_roll);\n    trim_pitch = radians(trim_pitch);\n    trim_yaw = radians(trim_yaw);\n\n    // add to ahrs trim\n    ahrs->set_trim(trim_roll, trim_pitch, trim_yaw);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send trim values\n    mavlink_and_console_log_info(dataFlash, \"Trim Saved: Roll=%3.2f Pitch=%3.2f Yaw=%3.2f\", trim_roll, trim_pitch, trim_yaw);\n}", "CodeBleu_score": 40.54222836967097}, {"code": "void Copter::save_trim(){\n\t  float roll_trim = 0.0f;\n  float pitch_trim = 0.0f;\n  // get roll and pitch trim values\n  roll_trim = (float)(roll_control_input - rc.radio.get_control_in(ROLL));\n  pitch_trim = (float)(pitch_control_input - rc.radio.get_control_in(PITCH));\n  // convert to radians\n  roll_trim = ToRad(roll_trim);\n  pitch_trim = ToRad(pitch_trim);\n  // add to ahrs trim\n  ahrs.set_trim(roll_trim, pitch_trim);\n  // log event\n  Log_Write_Event(DATA_SAVE_TRIM);\n  // send message\n  gcs_send_text_P(SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 51.99172804513259}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float speed_squared = 0;\n    float look_ahead_yaw = 0;\n    float look_ahead_yaw_degrees = 0;\n\n    // Retrieve the copter's velocity.\n    float velocity[3];\n    Copter::copter.get_velocity(velocity);\n\n    // Calculate the speed squared.\n    for (uint8_t i = 0; i < 3; i++) {\n        speed_squared += velocity[i] * velocity[i];\n    }\n\n    // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components.\n    if (Copter::copter.get_position_valid() && speed_squared > LOOK_AHEAD_MIN_SPEED_SQUARED) {\n        look_ahead_yaw = atan2(velocity[1], velocity[0]);\n    }\n\n    // Convert the look-ahead yaw angle to degrees and return it.\n    look_ahead_yaw_degrees = look_ahead_yaw * 180 / M_PI;\n    return look_ahead_yaw_degrees;\n}", "CodeBleu_score": 40.44064995146345}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\n  // Get the copter's velocity\n  float vel[2] = {copter.velocity[0], copter.velocity[1]};\n\n  // Calculate the speed squared\n  float speed_sq = sq(vel[0]) + sq(vel[1]);\n\n  // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n  if (copter.position_is_valid && speed_sq > sq(look_ahead_speed_min)) {\n    look_ahead_yaw_angle = atan2f(vel[1], vel[0]);\n  }\n\n  // Return the computed look-ahead yaw angle\n  return look_ahead_yaw_angle;\n}", "CodeBleu_score": 43.46913203002779}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\n  // Retrieve the copter's velocity\n  float vel[3];\n  Copter::copter.get_velocity(vel);\n\n  // Calculate the speed squared\n  float speed_squared = vel[0] * vel[0] + vel[1] * vel[1];\n\n  // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n  if (Copter::copter.position_ok() && speed_squared > MIN_SPEED_SQUARED) {\n    look_ahead_yaw_angle = atan2f(vel[1], vel[0]);\n  }\n\n  // Return the computed look-ahead yaw angle\n  return look_ahead_yaw_angle;\n}", "CodeBleu_score": 39.676778039158414}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == RUDDER) {\n        if (plane.rudder_arming_disabled || plane.channel_throttle->control_in != 0) {\n            return false;\n        }\n    }\n\n    if (!plane.arming.arming_checks_enabled || plane.auto_state.is_flying_wing) {\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 46.61251795278524}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        if (plane.rudder_disable.get() || plane.channel_throttle->control_in != 0) {\n            return false;\n        }\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Autotune Running\"));\n        return false;\n    }\n\n    if (plane.autotune.running) {\n        plane.gcs_send_text_P(MAV_SE", "CodeBleu_score": 46.53600511891496}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == RUDDER) {\n        if (plane.rudder_arming_disabled || plane.channel_steer.control_in != 0) {\n            return false;\n        }\n    }\n\n    if (plane.auto_throttle_mode == AUTO_THROTTLE_DISABLED) {\n        return false;\n    }\n\n    if (plane.g.armed_by_timer && !plane.autotune_state.running) {\n        return false;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.993022703319134}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if we are already armed\n    if (_armed) {\n        return true;\n    }\n\n    // do pre-arm checks\n    if (do_arming_checks && !pre_arm_checks(method)) {\n        return false;\n    }\n\n    // do pre-arm checks\n    if (do_arming_checks && !pre_arm_checks(method)) {\n        return false;\n    }\n\n    // set home location\n    _plane.ahrs.set_home(_plane.gps.location());\n\n    // update current location\n    _plane.ahrs.set_current_location(_plane.gps.location());\n\n    // change arm state\n    _armed = true;\n\n    // set delay arming flag\n    _delay_arming = true;\n\n    // send status message\n    _plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Arming throttle\"));\n\n    return true;\n}", "CodeBleu_score": 53.478118147356945}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // perform arming checks\n    if (do_arming_checks && !_pre_arm_checks()) {\n        return false;\n    }\n\n    // perform arming method specific checks\n    switch (method) {\n    case AP_Arming::MANUAL:\n        // check if we have a GCS lock\n        if (g.gcs_out_req == 1 && !gcs_is_connected()) {\n            gcs_send_text_P(SEVERITY_HIGH,PSTR(\"GCS not connected\"));\n            return false;\n        }\n        break;\n    case AP_Arming::AUTO:\n        // check if we have a GCS lock\n        if (g.gcs_out_req == 1 && !gcs_is_connected()) {\n            gcs_send_text_P(SEVERITY_HIGH,PSTR(\"GCS not connected\"));\n            return false;\n        }\n        // check if we have a barometer\n        if (g.barometer_type == AP_BAROMETER_TYPE_NONE) {\n            gcs_send_text_P(SEVERITY_HIGH,PSTR(\"No barometer\"));\n            return false;\n        }\n        // check if we have a compass\n        if (g.compass_enabled == 0) {\n            gcs_send_text_P(SEVERITY_HIGH,PSTR(\"No compass\"));\n            return false;\n        }\n        // check if we have a GPS\n        if (g.gps_type == AP_GPS_TYPE_NONE) {\n            gcs_send_text_P(SEVERITY_HIGH,PSTR(\"No GPS\"));\n            return false;\n        }\n        // check if we have a valid GPS position\n        if (!gps.status(0)->status) {\n            gcs_send_text_P(SEVERITY_HIGH,PSTR(\"GPS not fixed\"));\n            return false;\n        }\n        break;\n    case AP_Arming::SAFETY:\n        // check if we have a GCS lock\n        if (g.gcs", "CodeBleu_score": 41.55614140287701}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // perform arming checks\n    if (do_arming_checks && !pre_arm_checks(method)) {\n        return false;\n    }\n\n    // perform the actual arming\n    if (!arm_motors(method)) {\n        return false;\n    }\n\n    // update home location\n    if (method == AP_Arming::ARM_GPS || method == AP_Arming::ARM_INS) {\n        plane.ahrs.set_home(plane.gps.location());\n    }\n\n    // update current location\n    plane.ahrs.set_current_position(plane.gps.location().lat, plane.gps.location().lng);\n\n    // change arm state\n    plane.arming.set_armed(true);\n\n    // set delay arming flag\n    plane.delay_arming = true;\n\n    // send status text\n    plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Throttle armed\"));\n\n    // log arming event\n    DataFlash.Log_Write_Arming();\n\n    return true;\n}", "CodeBleu_score": 47.39753397350802}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (_vehicle->armed()) {\n        return true;\n    }\n\n    if (_vehicle->disarm_button_pressed()) {\n        return AP_Arming::pre_arm_checks(display_failure);\n    }\n\n    if (display_failure) {\n        _vehicle->mavlink_log_critical(\"Disarm button not pressed\");\n    }\n\n    return false;\n}", "CodeBleu_score": 62.23922855858554}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\n    // if already armed, return true\n    if (_armed) {\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (!_sub_arming.disarm_switch_channel_set()) {\n        if (display_failure) {\n            _sub_arming.set_msg(ARMING_DISABLED_MSG);\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.8467851935808}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // check if we have a disarm button\n    if (!disarm_button_assigned()) {\n        // no disarm button assigned, display error and return false\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"No disarm button assigned\");\n        }\n        return false;\n    }\n\n    // standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 72.59920864772735}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x*cos(ahrs.get_yaw()) - y*sin(ahrs.get_yaw());\n    float ne_y = y*cos(ahrs.get_yaw()) + x*sin(ahrs.get_yaw());\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.11722945059427}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(ahrs.getYaw()) - y * sin(ahrs.getYaw());\n    float ne_y = y * cos(ahrs.getYaw()) + x * sin(ahrs.getYaw());\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 66.0239393829319}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x, ne_y;\n    ne_x = x*cos(ahrs.getYaw()) - y*sin(ahrs.getYaw());\n    ne_y = x*sin(ahrs.getYaw()) + y*cos(ahrs.getYaw());\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 64.24751917315332}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    const float yaw_angle = packet.param1;\n    const float yaw_speed = packet.param2;\n    const float yaw_direction = packet.param3;\n    const float relative_offset = packet.param4;\n\n    if (yaw_angle < 0 || yaw_angle > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (yaw_speed < 0 || yaw_speed > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (yaw_direction < 0 || yaw_direction > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (relative_offset < 0 || relative_offset > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (relative_offset == 1) {\n        gcs_set_yaw_heading(yaw_angle, yaw_speed, yaw_direction);\n    } else {\n        gcs_set_yaw_heading_relative(yaw_angle, yaw_speed);\n    }\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 33.65342604763851}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // check the target heading\n    float target_heading = packet.param1;\n    if (target_heading < 0 || target_heading > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check the yaw speed\n    float yaw_speed = packet.param4;\n    if (yaw_speed < 0 || yaw_speed > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading\n    set_yaw_heading(target_heading, yaw_speed);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 31.910985533277653}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    MAV_RESULT res = MAV_RESULT_DENIED;\n\n    if (packet.param1 > 0 && packet.param1 < 360) {\n        if (packet.param4 == 0 || packet.param4 == 1) {\n            // set yaw heading\n            if (packet.param4 == 0) {\n                // absolute yaw\n                set_yaw_heading(packet.param1);\n            } else {\n                // relative yaw\n                set_yaw_heading(get_yaw_heading() + packet.param1);\n            }\n\n            // set yaw speed\n            set_yaw_speed(packet.param2);\n\n            // set yaw direction\n            if (packet.param3 == 0) {\n                // clockwise\n                set_yaw_direction(YAW_DIRECTION_CW);\n            } else {\n                // counter-clockwise\n                set_yaw_direction(YAW_DIRECTION_CCW);\n            }\n\n            res = MAV_RESULT_ACCEPTED;\n        }\n    }\n\n    return res;\n}", "CodeBleu_score": 48.808390213191814}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == MAV_MODE_FLAG_AUTO_ENABLED || control_mode == MAV_MODE_FLAG_GUIDED_ENABLED) {\n        return (uint8_t)(((int16_t)high_latency2.wp_bearing + 18000) / 2);\n    }\n    return 0;\n}", "CodeBleu_score": 44.115570956786044}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t ret = 0;\n    switch (control_mode) {\n    case MAV_MODE_GUIDED_ARMED:\n    case MAV_MODE_GUIDED_DISARMED:\n    case MAV_MODE_AUTO:\n        ret = (uint8_t)(((float)wp_bearing/2.0f) + 0.5f);\n        break;\n    default:\n        break;\n    }\n    return ret;\n}", "CodeBleu_score": 38.97419282754245}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode() == MAV_MODE_FLAG_AUTO_ENABLED || control_mode() == MAV_MODE_FLAG_GUIDED_ENABLED) {\n        return (uint8_t)(((int32_t)high_latency_tgt_wp_bearing() + 18000) / 2);\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 38.30324290270396}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (logging_enabled) {\n        LogPacket packet;\n        packet.time = micros();\n        packet.id = id;\n        packet.value = value;\n        packet.value_type = 0;\n        log_queue.push(packet);\n    }\n}", "CodeBleu_score": 40.3648414655722}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (Logging_Enabled) {\n\t\tLogPacket log_packet;\n\t\tlog_packet.time = HAL_GetTick();\n\t\tlog_packet.id = id;\n\t\tlog_packet.value = value;\n\t\tosMutexWait(log_mutex, osWaitForever);\n\t\tlog_queue.push(log_packet);\n\t\tosMutexRelease(log_mutex);\n\t}\n}", "CodeBleu_score": 37.64002904054974}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (logger != nullptr) {\n        LogPacket packet;\n        packet.time = HAL_GetTick();\n        packet.id = id;\n        packet.value = value;\n        logger->Log_Critical_Block(packet);\n    }\n}", "CodeBleu_score": 37.01464063708624}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t  // If the home is already set, exit immediately\n  if (home_is_set) {\n    return;\n  }\n\n  // If the motors are armed, set the home to the current location in-flight\n  if (motors_armed) {\n    set_home_to_current_location();\n    return;\n  }\n\n  // If the motors are not armed, attempt to set the home to the current EKF location and ignore any failure in this attempt\n  set_home_to_current_EKF_location();\n}", "CodeBleu_score": 26.405730598892283}, {"code": "void Sub::update_home_from_EKF(){\n\t  if (home_is_set) {\n    return;\n  }\n  if (motors_armed) {\n    set_home_to_current_location();\n  } else {\n    set_home_to_current_EKF_location();\n  }\n}", "CodeBleu_score": 29.739887606288352}, {"code": "void Sub::update_home_from_EKF(){\n\t\n\t// If the home is already set, exit immediately\n\tif (home_set) {\n\t\treturn;\n\t}\n\n\t// If the motors are armed, set the home to the current location in-flight\n\tif (motors_armed) {\n\t\thome_set = true;\n\t\thome_lat = gps_lat;\n\t\thome_lon = gps_lon;\n\t\treturn;\n\t}\n\n\t// Attempt to set the home to the current EKF location and ignore any failure in this attempt\n\thome_set = set_home_EKF();\n}", "CodeBleu_score": 18.299709512944347}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\n\tif (!motors->armed) {\n\t\tmotors->throttle = 0;\n\t\tmotors->setSpoolState(Motors::SpoolState::UNLIMITED);\n\t\tattitudeController->relax();\n\t\treturn;\n\t}\n\n\tmotors->setSpoolState(Motors::SpoolState::UNLIMITED);\n\n\tattitudeController->setDesiredRates(\n\t\t\tpilot->sticks[0] * attitudeController->maxRates[0],\n\t\t\tpilot->sticks[1] * attitudeController->maxRates[1],\n\t\t\tpilot->sticks[2] * attitudeController->maxRates[2]);\n\n\tattitudeController->run();\n\n\tmotors->setM1(pilot->sticks[3] + pilot->sticks[1]);\n\tmotors->setM2(pilot->sticks[3] - pilot->sticks[1]);\n\tmotors->setM3(pilot->sticks[3] + pilot->sticks[0]);\n\tmotors->setM4(pilot->sticks[3] - pilot->sticks[0]);\n\n}", "CodeBleu_score": 43.75196171628469}, {"code": "void ModeAcro::run(){\n\t\n\t// If motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!motors.armed) {\n\t\tmotors.throttle = 0.0f;\n\t\tmotors.adjust_spool_state(Motors::SpoolState::UNLIMITED);\n\t\tattitude_controller.relax_controllers();\n\t\treturn;\n\t}\n\n\t// If motors are armed, set spool state to unlimited throttle\n\tmotors.adjust_spool_state(Motors::SpoolState::UNLIMITED);\n\n\t// Convert pilot inputs to desired body frame rates\n\tfloat roll_rate = pilot_input.sticks.axis[Sticks::ROLL] * params.acro_rate;\n\tfloat pitch_rate = pilot_input.sticks.axis[Sticks::PITCH] * params.acro_rate;\n\tfloat yaw_rate = pilot_input.sticks.axis[Sticks::YAW] * params.acro_rate;\n\n\t// Run attitude controller with desired body frame rates\n\tattitude_controller.run(roll_rate, pitch_rate, yaw_rate);\n\n\t// Output pilot's throttle input without angle boost\n\tmotors.throttle = pilot_input.sticks.axis[Sticks::THROTTLE];\n\n\t// Set forward and lateral motor inputs based on pilot controls\n\tmotors.set_motor_command(Motors::MotorLabel::MOTOR_1, motors.throttle + pilot_input.sticks.axis[Sticks::ROLL] + pilot_input.sticks.axis[Sticks::PITCH]);\n\tmotors.set_motor_command(Motors::MotorLabel::MOTOR_2, motors.throttle - pilot_input.sticks.axis[Sticks::ROLL] + pilot_input.sticks.axis[Sticks::PITCH]);\n\tmotors.set_motor_command(Motors::MotorLabel::MOTOR_3, motors.throttle - pilot_input", "CodeBleu_score": 42.934284133533595}, {"code": "void ModeAcro::run(){\n\t\n    if (!motors->getArmed()) {\n        motors->setThrottle(0);\n        motors->setSpoolState(Motor::SpoolState::Unlimited);\n        attitudeController->relax();\n        return;\n    }\n\n    motors->setSpoolState(Motor::SpoolState::Unlimited);\n\n    // Convert pilot inputs to desired body frame rates\n    float rollRate = 0;\n    float pitchRate = 0;\n    float yawRate = 0;\n    if (pilot->getRollControlType() == Pilot::RollControlType::Angular) {\n        rollRate = pilot->getRoll() * attitudeController->getMaxRollRate();\n    }\n    if (pilot->getPitchControlType() == Pilot::PitchControlType::Angular) {\n        pitchRate = pilot->getPitch() * attitudeController->getMaxPitchRate();\n    }\n    if (pilot->getYawControlType() == Pilot::YawControlType::Angular) {\n        yawRate = pilot->getYaw() * attitudeController->getMaxYawRate();\n    }\n\n    // Run attitude controller\n    attitudeController->run(rollRate, pitchRate, yawRate);\n\n    // Output pilot's throttle input without angle boost\n    motors->setThrottle(pilot->getThrottle());\n\n    // Set forward and lateral motor inputs based on pilot controls\n    float forward = pilot->getPitch();\n    float lateral = pilot->getRoll();\n    motors->setForward(forward);\n    motors->setLateral(lateral);\n\n}", "CodeBleu_score": 52.064560090610016}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialize guided position control mode\n    pos_control_mode = POS_CONTROL_MODE::POS_CONTROL_MODE_POSITION;\n\n    // retrieve the stopping point\n    guided_pos_control_retrieve_stopping_point();\n\n    // set the waypoint destination\n    waypoint_controller.set_destination(stopping_point);\n\n    // initialize the yaw\n    guided_pos_control_initialize_yaw();\n}", "CodeBleu_score": 17.729414229123222}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t  // initialize the waypoint controller\n  waypoint_controller.init();\n\n  // set the waypoint destination to the stopping point\n  waypoint_controller.set_waypoint(stopping_point);\n\n  // initialize the yaw\n  waypoint_controller.set_heading(default_auto_yaw_mode);\n\n  // set the mode to position control\n  set_mode(POSITION_CONTROL);\n}", "CodeBleu_score": 26.220217440826833}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t  // Initialize position controller\n  pos_control.init();\n  pos_control.set_destination(guided_pos_control_setpoint.pos);\n  pos_control.set_yaw_mode(guided_pos_control_setpoint.yaw_mode);\n}", "CodeBleu_score": 31.133352488076525}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\n\t// Set the guided mode to velocity controller\n\tguided_mode = GUIDED_VEL_CONTROL;\n\n\t// Initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\tvertical_max_speed = (float)Pilot.get_vertical_max_speed() / 100.0f;\n\tvertical_max_acceleration = (float)Pilot.get_vertical_max_acceleration() / 100.0f;\n\n\t// Initialize the vertical and horizontal velocity controllers\n\tvertical_vel_controller.init(vertical_max_speed, vertical_max_acceleration);\n\thorizontal_vel_controller.init(HORIZONTAL_MAX_SPEED, HORIZONTAL_MAX_ACCELERATION);\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tyaw_control_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 36.62396048702239}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration\n\t_vel_params.max_vz_up = _params.max_vz_up;\n\t_vel_params.max_vz_down = _params.max_vz_down;\n\t_vel_params.max_z_acc_up = _params.max_z_acc_up;\n\t_vel_params.max_z_acc_down = _params.max_z_acc_down;\n\n\t// initialize velocity controller\n\t_vel_params.vel_xy_p = _params.vel_xy_p;\n\t_vel_params.vel_xy_i = _params.vel_xy_i;\n\t_vel_params.vel_xy_max = _params.vel_xy_max;\n\t_vel_params.vel_z_p = _params.vel_z_p;\n\t_vel_params.vel_z_i = _params.vel_z_i;\n\t_vel_params.vel_z_max_up = _params.vel_z_max_up;\n\t_vel_params.vel_z_max_down = _params.vel_z_max_down;\n\t_vel_params.vel_z_ff = _params.vel_z_ff;\n\t_vel_params.vel_z_ff_min = _params.vel_z_ff_min;\n\t_vel_params.vel_z_ff_max = _params.vel_z_ff_max;\n\t_vel_params.vel_z_ff_vel_max = _params.vel_z_ff_vel_max;\n\t_vel_params.vel_z_ff_rc_scale = _params.vel_z_ff_rc_scale;\n\t_vel_params.vel_z_ff_rc_expo = _params.vel_z_ff_rc_expo;\n\n\t_vel_ctrl.init(_vel_params);\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\t_att_ctrl.set_yaw_control_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 28.332894043398056}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical speeds and acceleration\n\tvel_control.set_max_vertical_speed(params.max_vel_z_up, params.max_vel_z_down);\n\tvel_control.set_vertical_acceleration(params.max_acc_z);\n\n\t// initialize horizontal velocity controller\n\tvel_control.set_horizontal_acceleration(params.max_acc_xy);\n\n\t// initialize yaw control\n\tyaw_control.set_yaw_control_mode(YawControl::YAW_CONTROL_AUTO);\n}", "CodeBleu_score": 31.920311256775214}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (timeout_check(guided_time)) {\n\t\treturn true;\n\t}\n\n\tif (guided_alt < MIN_ALTITUDE) {\n\t\treturn true;\n\t}\n\n\tif (guided_alt > MAX_ALTITUDE) {\n\t\treturn true;\n\t}\n\n\tif (guided_distance > MAX_DISTANCE) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 14.97159748911968}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\n\t// check timeout\n\tif ((current_time - guided_start_time) > guided_timeout) {\n\t\treturn true;\n\t}\n\n\t// check altitude\n\tif (current_loc.alt < guided_min_alt) {\n\t\treturn true;\n\t}\n\n\tif (current_loc.alt > guided_max_alt) {\n\t\treturn true;\n\t}\n\n\t// check distance\n\tif (get_distance_meters(guided_start_loc, current_loc) > guided_max_dist) {\n\t\treturn true;\n\t}\n\n\t// if we get here, all checks have been passed\n\treturn false;\n}", "CodeBleu_score": 23.551037604244243}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\n\t// If guided mode has been running for too long, return true\n\tif (guided_mode_time > GUIDED_MODE_TIMEOUT) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is too low, return true\n\tif (current_altitude < MIN_ALTITUDE) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is too high, return true\n\tif (current_altitude > MAX_ALTITUDE) {\n\t\treturn true;\n\t}\n\n\t// If the horizontal distance moved is too great, return true\n\tif (guided_distance > MAX_GUIDED_DISTANCE) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 15.416448237880969}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_timeout_timer.elapsed_time() > 2000) {\n\t\tmotor_test_timeout_timer.stop();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tif (motor_test_pass) {\n\t\t\tmotor_test_pass = false;\n\t\t\tmotor_test_timeout_timer.stop();\n\t\t\tmotor_test_timeout_timer.reset();\n\t\t\tmotor_test_timeout_timer.start();\n\t\t\tmotor_test_timer.stop();\n\t\t\tmotor_test_timer.reset();\n\t\t\tmotor_test_timer.start();\n\t\t\tmotor_test_pass_timer.stop();\n\t\t\tmotor_test_pass_timer.reset();\n\t\t\tmotor_test_pass_timer.start();\n\t\t\tmotor_test_failure_time = motor_test_timer.elapsed_time();\n\t\t\tstd::cout << \"Motor test timeout. Failure time: \" << motor_test_failure_time << \" ms\" << std::endl;\n\t\t\tstd::cout << \"Disabling motor test\" << std::endl;\n\t\t\tsend_motor_test_timeout();\n\t\t\tsend_motor_test_disable();\n\t\t\tsend_arm_disable();\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tmotor_test_pass = true;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.36032843401322}, {"code": "bool Sub::verify_motor_test(){\n\t  // Verify motor test\n  if (motor_test_request_time == 0) {\n    motor_test_request_time = millis();\n  }\n  else {\n    if (millis() - motor_test_request_time > 2000) {\n      motor_test_request_time = 0;\n      Serial.println(\"Motor test timeout\");\n      pass = false;\n      motor_test_enabled = false;\n      arm_state = false;\n      fail_time = millis();\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 52.899207590749555}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_timeout_timer.checkTimer() && motor_test_timeout_timer.getDuration() > 2000000) {\n\t\tmotor_test_timeout_timer.stop();\n\t\tmotor_test_timeout_timer.reset();\n\t\tmotor_test_timeout_timer.start();\n\t\tif (pass) {\n\t\t\tpass = false;\n\t\t\t//Send a timeout message\n\t\t\tsend_message(motor_test_timeout_message);\n\t\t\t//Disable motor test\n\t\t\tmotor_test_message.motor_test_enable = 0;\n\t\t\tsend_message(motor_test_message);\n\t\t\t//Disarm the system\n\t\t\tarm_message.arm = 0;\n\t\t\tsend_message(arm_message);\n\t\t\t//Record the failure time\n\t\t\tmotor_test_failure_time = get_time_in_micros();\n\t\t\t//Return false\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.00283427360889}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\n  // Get the roll and pitch targets from wp_nav\n  float roll_target = wp_nav.get_roll_target();\n  float pitch_target = wp_nav.get_pitch_target();\n\n  // Constrain the targets within a specified maximum angle range\n  roll_target = constrain(roll_target, -wp_nav_max_angle, wp_nav_max_angle);\n  pitch_target = constrain(pitch_target, -wp_nav_max_angle, wp_nav_max_angle);\n\n  // Normalize the targets\n  float roll_target_norm = roll_target / wp_nav_max_angle;\n  float pitch_target_norm = pitch_target / wp_nav_max_angle;\n\n  // Assign the normalized targets to lateral_out and forward_out\n  lateral_out = roll_target_norm * 100;\n  forward_out = pitch_target_norm * 100;\n}", "CodeBleu_score": 45.7327124216489}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\n  // Retrieve roll and pitch targets from wp_nav in centidegrees\n  float roll_target = wp_nav.get_roll_target();\n  float pitch_target = wp_nav.get_pitch_target();\n\n  // Constrain targets within a specified maximum angle range\n  roll_target = constrain(roll_target, -max_roll_pitch_target, max_roll_pitch_target);\n  pitch_target = constrain(pitch_target, -max_roll_pitch_target, max_roll_pitch_target);\n\n  // Normalize targets\n  float roll_norm = (roll_target / max_roll_pitch_target);\n  float pitch_norm = (pitch_target / max_roll_pitch_target);\n\n  // Assign normalized targets to lateral_out and forward_out\n  lateral_out = roll_norm;\n  forward_out = pitch_norm;\n}", "CodeBleu_score": 44.55341535615489}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  // Retrieve roll and pitch targets from wp_nav in centidegrees\n  float roll_target = wp_nav.get_roll_target() * 100.0;\n  float pitch_target = wp_nav.get_pitch_target() * 100.0;\n\n  // Constrain targets within a specified maximum angle range\n  roll_target = constrain(roll_target, -MAX_ROLL_ANGLE, MAX_ROLL_ANGLE);\n  pitch_target = constrain(pitch_target, -MAX_PITCH_ANGLE, MAX_PITCH_ANGLE);\n\n  // Normalize targets\n  float roll_normalized = map(roll_target, -MAX_ROLL_ANGLE, MAX_ROLL_ANGLE, -100, 100);\n  float pitch_normalized = map(pitch_target, -MAX_PITCH_ANGLE, MAX_PITCH_ANGLE, -100, 100);\n\n  // Assign normalized values to lateral_out and forward_out\n  lateral_out = roll_normalized;\n  forward_out = pitch_normalized;\n}", "CodeBleu_score": 40.07432908662831}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    // Read the barometer\n    baro.update();\n\n    // If the altitude is above zero, update the barometer calibration\n    if (baro.get_altitude() > 0) {\n        baro.calibrate();\n    }\n\n    // If a depth sensor is present, update the sensor health status based on the barometer's health\n    if (depth_sensor_present) {\n        if (baro.get_health() == 0) {\n            sensor_health.depth_sensor_health = 0;\n        }\n        else {\n            sensor_health.depth_sensor_health = 1;\n        }\n    }\n}", "CodeBleu_score": 58.670537563387995}, {"code": "void Sub::read_barometer(){\n\t\t// Read the barometer\n\tbaro_sensor.read();\n\n\t// Update the altitude\n\taltitude = baro_sensor.getAltitude();\n\n\t// Update the barometer calibration\n\tif (altitude > 0) {\n\t\tbaro_sensor.calibrate();\n\t}\n\n\t// Update the sensor health status\n\tif (depth_sensor_present) {\n\t\tif (altitude > 0) {\n\t\t\tsensor_health.set_barometer_health(true);\n\t\t} else {\n\t\t\tsensor_health.set_barometer_health(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.7350382017333}, {"code": "void Sub::read_barometer(){\n\t    if (barometer.read()) {\n        if (barometer.get_altitude() > 0) {\n            barometer.calibrate();\n        }\n        if (depth_sensor.present()) {\n            depth_sensor.set_health(barometer.get_health());\n        }\n    }\n}", "CodeBleu_score": 61.7700850687839}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.get_inertial_nav_enabled()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (!ahrs.get_have_inertial_nav()) {\n        return false;\n    }\n    if (ahrs.get_ekf_status().flags.relying_on_gps) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 47.805633195697716}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.get_have_inertial_nav()) {\n        return false;\n    }\n\n    if (!motors.armed()) {\n        return ahrs.get_ekf().get_position_ok_for_nav(true);\n    }\n\n    return ahrs.get_ekf().get_position_ok_for_nav(false);\n}", "CodeBleu_score": 45.34247626649992}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.get_have_inertial_nav()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return ahrs.get_ekf().pred_position_ok();\n    }\n    return ahrs.get_ekf().position_ok() && !ahrs.get_ekf().get_constant_pos_mode();\n}", "CodeBleu_score": 51.452067926497136}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!_rover->control_mode.require_GPS()) {\n        return true;\n    }\n\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    if (!_rover->ahrs.get_position_estimate(gps_origin)) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS position not available\"));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 36.24490582464321}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    if (!_rover->control_mode.require_GPS()) {\n        return true;\n    }\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    if (!_rover->ahrs.get_position_estimate(gps_position)) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS position not available\"));\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 36.4407297560956}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't need position or velocity, we are good\n    if (!_rover->control_mode.require_GPS()) {\n        return true;\n    }\n\n    // check for GPS\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check for AHRS system being ready\n    if (!_rover->ahrs.healthy()) {\n        if (display_failure) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: Compass not healthy\"));\n        }\n        return false;\n    }\n\n    // check for EKF failsafe\n    if (_rover->ekf_status.failsafe) {\n        if (display_failure) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: EKF failsafe\"));\n        }\n        return false;\n    }\n\n    // check for valid position estimate\n    if (!_rover->position_ok()) {\n        if (display_failure) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: No position\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 57.43109672313078}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // if we are already armed then disarm first\n    if (armed()) {\n        disarm();\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks) {\n        // perform checks\n        if (!arming_checks()) {\n            // arming checks failed\n            return false;\n        }\n    }\n\n    // record the time we were armed\n    armed_time_ms = millis();\n\n    // set armed flag\n    armed = true;\n\n    // set the armed flag in the Rover\n    rover.set_armed(true);\n\n    // initialise the simple mode heading\n    rover.simple_mode_init();\n\n    // record the home heading for sail vehicles\n    rover.record_home_heading();\n\n    // send status text\n    AP_Notify::events.notify(AP_NOTIFY_ARMED);\n\n    // set soft armed flag\n    soft_armed = true;\n\n    // record the armed location\n    armed_loc = rover.current_loc;\n\n    // record the armed heading\n    armed_heading = rover.current_heading;\n\n    // record the armed altitude\n    armed_alt = rover.current_loc.alt;\n\n    // record the armed throttle\n    armed_throttle = rover.channel_throttle->control_in;\n\n    // record the armed rudder\n    armed_rudder = rover.channel_rudder->control_in;\n\n    // record the armed speed\n    armed_speed = rover.ground_speed;\n\n    // record the armed airspeed\n    armed_airspeed = rover.airspeed.get_airspeed();\n\n    // record the armed navigation mode\n    armed_nav_mode = rover.nav_controller->get_mode();\n\n    // record the armed loiter radius\n    armed_loiter_radius = rover.loiter.get_loiter_radius();\n\n    // record the armed takeoff alt\n    armed_takeoff_alt = rover.takeoff_alt;\n\n    // record the armed land speed\n    armed_land_speed =", "CodeBleu_score": 39.14079305523923}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // first check if we are already armed\n    if (AP_Arming::is_armed()) {\n        return true;\n    }\n\n    // first check if we are in a vehicle class that does not support arming\n    if (rover.control_mode == ROVER_MODE_LAND) {\n        return false;\n    }\n\n    // perform arming checks\n    if (do_arming_checks) {\n        // check if we have a good GPS fix\n        if (rover.gps.status() != AP_GPS::GPS_OK) {\n            set_arming_state(AP_Arming::PreArm);\n            set_arming_error(AP_Arming::GPS_Unhealthy);\n            return false;\n        }\n    }\n\n    // set soft armed status\n    AP_Arming::set_soft_armed(true);\n\n    // set armed status\n    AP_Arming::set_armed(true);\n\n    // set home location\n    rover.set_home_to_current_location();\n\n    // initialise simple mode heading\n    rover.init_simple_mode();\n\n    // record the home heading for sail vehicles\n    if (rover.control_mode == ROVER_MODE_SAIL) {\n        rover.set_sail_home_heading(rover.ahrs.yaw_sensor);\n    }\n\n    // send status text\n    AP_Arming::send_armed_message(true);\n\n    // return success\n    return true;\n}", "CodeBleu_score": 34.686321747678505}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\n    if (do_arming_checks) {\n        // check if we are already armed\n        if (_rover->armed()) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Already armed\"));\n            return false;\n        }\n\n        // check if we are on the ground\n        if (!_rover->on_ground()) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Cannot arm while in air\"));\n            return false;\n        }\n\n        // check if we have a valid GPS fix\n        if (!_rover->gps.status().status) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No GPS lock\"));\n            return false;\n        }\n\n        // check if we are moving\n        if (_rover->gps.ground_speed() > AP_ARMING_MAX_GROUND_SPEED) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Too fast to arm\"));\n            return false;\n        }\n\n        // check if we have a barometer\n        if (!_rover->barometer.healthy()) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No barometer\"));\n            return false;\n        }\n\n        // check if we have a compass\n        if (!_rover->compass.healthy(0)) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No compass\"));\n            return false;\n        }\n\n        // check if we have a pilot\n        if (!_rover->channel_throttle->control_in) {\n            _rover->gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No pilot\"));\n            return false;\n        }\n\n        // check if we have a command\n        if (_rover", "CodeBleu_score": 43.22989042002645}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  static bool charging_enabled = false;\n  static unsigned long last_charging_disable_time = 0;\n  static unsigned long last_charging_enable_attempt_time = 0;\n  static bool charging_enable_attempt_in_progress = false;\n\n  if (charging_allowed) {\n    // If charging is allowed, enable it if it is not already enabled\n    if (!charging_enabled) {\n      // If charging is not already enabled, enable it\n      digitalWrite(CHARGING_ENABLE_PIN, HIGH);\n      charging_enabled = true;\n      last_charging_enable_attempt_time = millis();\n      charging_enable_attempt_in_progress = true;\n    }\n  } else {\n    // If charging is not allowed, disable it if it is not already disabled\n    if (charging_enabled) {\n      // If charging is enabled, disable it\n      digitalWrite(CHARGING_ENABLE_PIN, LOW);\n      charging_enabled = false;\n      last_charging_disable_time = millis();\n    } else if (charging_enable_attempt_in_progress) {\n      // If charging is not enabled but an attempt to enable it is in progress, check whether the attempt has timed out\n      if (millis() - last_charging_enable_attempt_time > CHARGING_ENABLE_ATTEMPT_TIMEOUT) {\n        // If the attempt has timed out, disable charging and record the time\n        digitalWrite(CHARGING_ENABLE_PIN, LOW);\n        charging_enabled = false;\n        last_charging_disable_time = millis();\n        charging_enable_attempt_in_progress = false;\n      }\n    } else {\n      // If charging is not enabled and no attempt to enable it is in progress, check whether it has been disabled for long enough to retry enabling it\n      if (millis() - last_charging_disable_time > CHARGING_DISABLE_TIME) {\n        // If it has been disabled for long enough, enable charging and record the time\n       ", "CodeBleu_score": 61.97441554165448}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed && !charging_enabled) {\n    charging_enabled = true;\n    charging_start_time = millis();\n  }\n  else if (!charging_allowed && charging_enabled) {\n    charging_enabled = false;\n    charging_start_time = millis();\n  }\n  else if (!charging_allowed && !charging_enabled && (millis() - charging_start_time) > 1000) {\n    charging_enabled = true;\n    charging_start_time = millis();\n  }\n  else if (charging_allowed && charging_enabled && (millis() - charging_start_time) > 1000) {\n    charging_enabled = false;\n    charging_start_time = millis();\n  }\n}", "CodeBleu_score": 41.62554709893433}, {"code": "void updateChargingEnabled(){\n\t    static unsigned long last_charging_disabled = 0;\n    static bool charging_disabled = false;\n    static bool charging_enabled = false;\n    static bool charging_allowed = true;\n    static bool charging_enabled_last = false;\n\n    // If the charging_allowed flag is false, disable charging\n    if (!charging_allowed) {\n        // If charging was enabled last time this function was called, disable charging and record the time\n        if (charging_enabled_last) {\n            digitalWrite(PIN_CHARGING_ENABLE, LOW);\n            charging_disabled = true;\n            last_charging_disabled = millis();\n        }\n        // If charging was already disabled last time this function was called, continue disabling charging\n        else {\n            digitalWrite(PIN_CHARGING_ENABLE, LOW);\n            charging_disabled = true;\n        }\n    }\n    // If the charging_allowed flag is true, enable charging\n    else {\n        // If charging was disabled last time this function was called, enable charging\n        if (charging_disabled) {\n            digitalWrite(PIN_CHARGING_ENABLE, HIGH);\n            charging_disabled = false;\n            charging_enabled = true;\n        }\n        // If charging was already enabled last time this function was called, continue enabling charging\n        else {\n            digitalWrite(PIN_CHARGING_ENABLE, HIGH);\n            charging_enabled = true;\n        }\n    }\n\n    // If charging was enabled this time this function was called, record that charging was enabled\n    if (charging_enabled) {\n        charging_enabled_last = true;\n    }\n    // If charging was disabled this time this function was called, record that charging was disabled\n    else {\n        charging_enabled_last = false;\n    }\n\n    // Reset the charging_enabled flag\n    charging_enabled = false;\n}", "CodeBleu_score": 56.5930383274027}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (rosRunning) {\n    if (size >= 4) {\n      uint16_t crc = FastCRC16(message, size - 2);\n      uint8_t *messageBytes = (uint8_t *)message;\n      messageBytes[size - 2] = (crc >> 8) & 0xFF;\n      messageBytes[size - 1] = crc & 0xFF;\n      packetSerial.send(messageBytes, size);\n    }\n  }\n}", "CodeBleu_score": 64.28560772749337}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (rosRunning && size >= 4) {\n    // Calculate CRC\n    uint32_t crc = FastCRC32().crc32((const void *) message, size);\n    // Append CRC to message\n    memcpy((uint8_t *) message + size, &crc, 4);\n    size += 4;\n    // Send message\n    packetSerial.send(message, size);\n  }\n}", "CodeBleu_score": 39.66254914102103}, {"code": "void sendMessage(void *message, size_t size){\n\t\n  if (rosRunning) {\n\n    if (size > 4) {\n\n      uint32_t crc = FastCRC32().crc32((uint8_t *)message, size);\n\n      memcpy((uint8_t *)message + size, &crc, 4);\n\n      size += 4;\n\n      packetSerial.send(message, size);\n\n    }\n\n  }\n\n}", "CodeBleu_score": 42.24373026480948}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t    Serial.begin(9600);\n    while (Serial.available() > 0) {\n        Serial.read();\n    }\n    Serial.write(0x7E);\n    Serial.write(0xFF);\n    Serial.write(0x06);\n    Serial.write(0x0F);\n    Serial.write(0x01);\n    Serial.write(0x00);\n    Serial.write(0x01);\n    Serial.write(0xEF);\n    delay(200);\n    if (Serial.available() > 0) {\n        Serial.read();\n    }\n    Serial.write(0x7E);\n    Serial.write(0xFF);\n    Serial.write(0x06);\n    Serial.write(0x09);\n    Serial.write(0x01);\n    Serial.write(0x00);\n    Serial.write(0x01);\n    Serial.write(0xEF);\n    delay(200);\n    if (Serial.available() > 0) {\n        Serial.read();\n    }\n    Serial.write(0x7E);\n    Serial.write(0xFF);\n    Serial.write(0x06);\n    Serial.write(0x3F);\n    Serial.write(0x01);\n    Serial.write(0x00);\n    Serial.write(0x01);\n    Serial.write(0xEF);\n    delay(200);\n    if (Serial.available() > 0) {\n        Serial.read();\n    }\n    Serial.write(0x7E);\n    Serial.write(0xFF);\n    Serial.write(0x06);\n    Serial.write(0x0E);\n    Serial.write(0x01);\n    Serial.write(0x00);\n    Serial.write(0x01);\n    Serial.write(0xEF);\n    delay(200);\n    if (Serial.available() > 0) {\n        Serial.read();\n    }\n    Serial.write(0x7E);\n    Serial.write", "CodeBleu_score": 40.71559724629042}, {"code": "bool MP3Sound::begin(){\n\t  // Initialize serial communication\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // Clear the buffer\n  while (Serial.available()) {\n    Serial.read();\n  }\n\n  // Initialize the sound module\n  Serial.write(0x7E); // Start byte\n  Serial.write(0xFF); // Version\n  Serial.write(0x06); // Length\n  Serial.write(0x01); // Command\n  Serial.write(0x00); // Feedback\n  Serial.write(0x00); // Space\n  Serial.write(0x00); // Space\n  Serial.write(0xEF); // End byte\n\n  // Read the number of sound files available\n  while (Serial.available() < 8) {\n    ;\n  }\n  byte response[8];\n  for (int i = 0; i < 8; i++) {\n    response[i] = Serial.read();\n  }\n\n  // Check if the number of sound files is greater than 0\n  if (response[5] > 0) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}", "CodeBleu_score": 44.66116315849128}, {"code": "bool MP3Sound::begin(){\n\t\t// Initialize serial communication\n\tSerial.begin(9600);\n\t// Clear the serial buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\t// Initialize the sound module\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x0F);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\t// Wait for the response\n\twhile (Serial.available() == 0);\n\t// Read the response\n\tif (Serial.read() == 0x7E) {\n\t\t// Read the next byte\n\t\twhile (Serial.available() == 0);\n\t\tif (Serial.read() == 0xFF) {\n\t\t\t// Read the next byte\n\t\t\twhile (Serial.available() == 0);\n\t\t\tif (Serial.read() == 0x06) {\n\t\t\t\t// Read the next byte\n\t\t\t\twhile (Serial.available() == 0);\n\t\t\t\tif (Serial.read() == 0x0F) {\n\t\t\t\t\t// Read the next byte\n\t\t\t\t\twhile (Serial.available() == 0);\n\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t// Read the next byte\n\t\t\t\t\t\twhile (Serial.available() == 0);\n\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t// Read the next byte\n\t\t\t\t\t\t\twhile (Serial.available() == 0);\n\t\t\t\t\t\t\tif (Serial.read() == 0x00) {\n\t\t\t\t\t\t\t\t// Read the next byte\n\t\t\t\t\t\t\t\twhile (Serial.available() == 0);\n\t\t\t\t\t\t\t\tif (Serial.read() == 0xEF", "CodeBleu_score": 36.45384970186484}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tint activeSounds = 0;\n\t\n\t// Check if there are any active sounds\n\tif (activeSoundsList.size() == 0) {\n\t\treturn activeSounds;\n\t}\n\t\n\t// Check if an MP3 is currently playing\n\tif (mp3_playing) {\n\t\treturn activeSounds;\n\t}\n\t\n\t// Retrieve and play the last sound from the active sounds list\n\tSound* sound = activeSoundsList.back();\n\tactiveSoundsList.pop_back();\n\tsound->play();\n\t\n\t// Return the updated number of active sounds\n\treturn activeSoundsList.size();\n}", "CodeBleu_score": 44.36098236839934}, {"code": "int MP3Sound::processSounds(){\n\t\n\tif (activeSounds.size() == 0 || mp3Playing) {\n\t\treturn activeSounds.size();\n\t}\n\telse {\n\t\tMP3Sound* sound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tsound->play();\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 38.07106671174459}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0 || mp3->isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\telse {\n\t\tSound *sound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tsound->play();\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 38.5087434827873}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  bool command_handled = true;\n  AbstractCamera *ac = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      ac->memory_mapped_file = wb_request_read_string(r);\n      ac->memory_mapped_file_size = wb_request_read_uint64(r);\n      ac->memory_mapped_file_requested = true;\n      break;\n    }\n    default:\n      command_handled = false;\n      break;\n  }\n  return command_handled;\n}", "CodeBleu_score": 71.59636470514307}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  AbstractCamera *ac = d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      ac->memory_mapped_file = wb_request_read_string(r);\n      ac->memory_mapped_file_size = wb_request_read_uint32(r);\n      ac->memory_mapped_file_requested = true;\n      break;\n    }\n    default:\n      command_handled = false;\n      break;\n  }\n  return command_handled;\n}", "CodeBleu_score": 68.3711470267142}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      wb_abstract_camera_cleanup_memory_mapped_file(d);\n      wb_abstract_camera_setup_memory_mapped_file(d, r);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 36.24512909690304}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (!robot_check_device(d, WB_NODE_CAMERA, NULL, NULL, NULL, \"wb_abstract_camera_get_height\"))\n    return -1;\n\n  robot_mutex_lock_step();\n  int height = d->camera_height;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 47.22248521437844}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (!d->pdata)\n    return -1;\n  int height = 0;\n  robot_mutex_lock_step();\n  height = d->pdata->camera_height;\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 53.323812964893435}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  if (!d || d->type != WB_NODE_ABSTRACT_CAMERA) {\n    fprintf(stderr, \"Error: %s() called with wrong device type, please use wb_camera_get_height() instead.\n\", __FUNCTION__);\n    return -1;\n  }\n\n  WbAbstractCamera *ac = d->pdata;\n  if (!ac) {\n    fprintf(stderr, \"Error: %s() called on a NULL device.\n\", __FUNCTION__);\n    return -1;\n  }\n\n  robot_mutex_lock_step();\n  int result = ac->height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 50.298610020174316}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n\n  robot_mutex_lock_step();\n\n  WbDevice *accelerometer = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, true);\n\n  if (!accelerometer) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    robot_mutex_unlock_step();\n    return -1;\n  }\n\n  sampling_period = accelerometer->accelerometer->sampling_period;\n\n  robot_mutex_unlock_step();\n\n  return sampling_period;\n}", "CodeBleu_score": 60.11956565065928}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (!accelerometer) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    robot_mutex_unlock_step();\n    return -1;\n  }\n  sampling_period = accelerometer->sampling_period;\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 67.47922027083914}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (!accelerometer) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    robot_mutex_unlock_step();\n    return -1;\n  }\n  sampling_period = accelerometer->sampling_period;\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 67.47922027083914}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\n  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString(dms);\n  free(dms);\n  return dmsString;\n}", "CodeBleu_score": 40.583169746538196}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\n\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 37.88782813192387}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *c_string = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = c_string;\n    free(c_string);\n    return result;\n}", "CodeBleu_score": 45.538780614852485}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n\n    dVector3 p, q, v;\n    dGeomBoxGetLengths(g, p);\n    dGeomBoxGetQuaternion(g, q);\n    dGeomBoxGetPosition(g, v);\n\n    dVector3 r;\n    r[0] = x - v[0];\n    r[1] = y - v[1];\n    r[2] = z - v[2];\n\n    dQuaternion qinv;\n    dQuaternionInv(qinv, q);\n    dVector3 v2;\n    dQMultiply1(v2, qinv, r);\n\n    dReal sign;\n    plane[0] = 0;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = 0;\n\n    if (dFabs(v2[0]) > dFabs(v2[1])) {\n        if (dFabs(v2[0]) > dFabs(v2[2])) {\n            sign = (v2[0] < 0) ? REAL(-1.0) : REAL(1.0);\n            plane[0] = sign * p[0];\n            plane[3] = sign * (v2[0] + p[0] * REAL(0.5));\n        }\n        else {\n            sign = (v2[2] < 0) ? REAL(-1.0) : REAL(1.0);\n            plane[2] = sign * p[2];\n            plane[3] = sign * (v2[2] + p[2] * REAL(0.5));\n        }\n    }\n    else {\n        if (dFabs(v2[1]) > dFabs(v2[2])) {\n            sign = (v2[1] < 0) ? REAL(-1.0) : REAL(1.0);\n            plane[1] = sign * p[1];\n            plane[3] = sign * (v2[1] + p[1", "CodeBleu_score": 41.4298184964098}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\n  dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  dUASSERT (plane, \"argument not a plane\");\n\n  const dReal* const R = g->R;\n  const dReal* const pos = g->pos;\n  const dReal* const sides = g->side;\n\n  dVector3 point;\n  point[0] = x - pos[0];\n  point[1] = y - pos[1];\n  point[2] = z - pos[2];\n\n  dVector3 normal;\n  normal[0] = 0.0f;\n  normal[1] = 0.0f;\n  normal[2] = 0.0f;\n\n  dReal distance = 0.0f;\n\n  // Check each axis for proximity to the box's surface.\n  for (int i = 0; i < 3; ++i) {\n    dReal value = dCalcVectorDot3(point, R + i * 4);\n    if (dFabs(value) < sides[i]) {\n      normal[i] = dSign(value);\n      distance = sides[i];\n    }\n  }\n\n  // If no axis is proximate to the box's surface, the point is inside the box.\n  if (normal[0] == 0.0f && normal[1] == 0.0f && normal[2] == 0.0f) {\n    normal[2] = 1.0f;\n    distance = -dCalcVectorDot3(point, R + 2 * 4);\n  }\n\n  // Compute the plane's normal in global coordinates.\n  dMultiply0_331(plane, R, normal);\n\n  // Set the plane's distance.\n  plane[3] = -distance;\n}", "CodeBleu_score": 48.34327103384987}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n  dGeomBoxGetTangentPlane((dxBox*)g, x, y, z, plane);\n}", "CodeBleu_score": 9.65623207438569}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  // Check that the box has a body\n  assert (box->body);\n\n  // Check that the flags are valid\n  assert ((flags & NUMI_MASK_BOX_AXES) != 0);\n\n  // Initialize the box immersion data\n  sBoxImmersionData boxData;\n  boxData.m_box = box;\n  boxData.m_fluidPlane = fluidPlane;\n  boxData.m_flags = flags;\n\n  // Perform the immersion checking\n  return dImmerseBox(&boxData, immersion);\n}", "CodeBleu_score": 50.31277630702225}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dUASSERT(box, \"The box is null\");\n\n  dUASSERT(box->body, \"The box has no body\");\n\n  dUASSERT(dImmersionOutline::isValid(flags), \"The flags are invalid\");\n\n  dUASSERT(immersion, \"The immersion structure is null\");\n\n  dUASSERT(fluidPlane, \"The fluid plane is null\");\n\n  dUASSERT(dGeomIsEnabled(box), \"The box is not enabled\");\n\n  dUASSERT(dGeomIsEnabled(box->body), \"The body of the box is not enabled\");\n\n  dUASSERT(dGeomGetBody(box) == box->body, \"The body of the box is not correct\");\n\n  dUASSERT(dGeomGetClass(box->body) == dBodyClass, \"The body of the box is not a body\");\n\n  dUASSERT(dGeomGetClass(box) == dBoxClass, \"The object is not a box\");\n\n  dUASSERT(dGeomGetSpace(box->body) == dGeomGetSpace(box), \"The body and the box are not in the same space\");\n\n  dUASSERT(dGeomGetSpace(box->body) == dGeomGetSpace(immersion), \"The body and the immersion structure are not in the same space\");\n\n  dUASSERT(dGeomGetSpace(box) == dGeomGetSpace(immersion), \"The box and the immersion structure are not in the same space\");\n\n  dUASSERT(dGeomGetSpace(box) == fluidPlaneSpace, \"The box and the fluid plane are not in the same space\");\n\n  dUASSERT(dGeomGetSpace(immersion) == fluidPlaneSpace, \"The immersion structure and the fluid plane are not in the same space\");\n\n  dUASSERT(dGeomGetSpace(box->body) == fluidPlaneSpace, \"The body and the fluid plane are not in the same space\");\n\n  dUASSERT(dGeomGetSpace(fluidPlane) == fluidPlaneSpace, \"The fluid plane is not in", "CodeBleu_score": 40.22731433727889}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  // Make sure the box has a body\n  dUASSERT (box->body, \"The box must have a body\");\n\n  // Make sure the flags are valid\n  dUASSERT (!(flags & NUMI_MASK), \"Invalid flags\");\n\n  // Initialize the immersion data\n  sBoxImmersionData data;\n  data.Init (box, fluidPlane, flags);\n\n  // Perform the immersion checking\n  dImmerseBox (&data, immersion);\n\n  // Return the result\n  return data.result;\n}", "CodeBleu_score": 53.595664028838854}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT (o1 && o2 && immersion, \"The arguments are null\");\n\n  dUASSERT (o1->type == dBoxClass, \"The first argument is not a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"The second argument is not a capsule\");\n\n  dReal *sides = (dReal *)(o1->aabb);\n  dReal *radius = (dReal *)(o2->aabb);\n\n  dVector3 center;\n  dGeomBoxGetLengths (o1, center);\n  for (int i = 0; i < 3; i++) center[i] /= 2.0f;\n\n  dGeomCapsuleGetParams (o2, center + 3, center + 4);\n  center[3] += radius[0];\n\n  dVector3 diff;\n  dSubtractVectors3(diff, center, o2->final_posr->pos);\n\n  dReal distance = dCalcVectorDot3(diff, o2->final_posr->R[2]);\n  if (distance < 0.0f) distance = 0.0f;\n\n  dReal depth = radius[0] - distance;\n  if (depth < 0.0f) return 0;\n\n  dGeomBoxGetSide (o1, 2, immersion->g1BoxSide);\n\n  dReal *normal = immersion->g1BoxSide;\n  dReal *point = immersion->g1BoxPoint;\n  dReal *buoyancy_center = immersion->buoyancy_center;\n\n  dReal sign = dCalcVectorDot3(o2->final_posr->R[2], normal);\n  if (sign < 0.0f) dNegateVector3(normal);\n\n  dVector3 vertex;\n  dMultiply0_331(vertex, o2->final_posr->R, center);\n  dAddVectors3(vertex, vertex, o2->final_posr->pos);\n\n  dVector3 r;\n  dSubtractVectors3", "CodeBleu_score": 40.606284934216156}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1 && o2 && immersion, \"The arguments are not valid\");\n\n  dAASSERT(o1->type == dBoxClass);\n  dAASSERT(o2->type == dCapsuleClass);\n\n  dxBox *Box = (dxBox *) o1;\n  dxCapsule *Capsule = (dxCapsule *) o2;\n\n  // check if the box is in the capsule\n  if (dBoxTouchesCapsule(Box, Capsule)) {\n    // set the immersion parameters\n    immersion->g1 = o1;\n    immersion->g2 = o2;\n\n    // compute the immersion plane for the capsule\n    dReal sign = dDOT(Capsule->final_posr->R[2], Box->final_posr->R[2]) > 0 ? 1.0 : -1.0;\n    immersion->plane.p[0] = Capsule->final_posr->pos[0] + sign * Capsule->final_posr->R[2][0] * Capsule->radius;\n    immersion->plane.p[1] = Capsule->final_posr->pos[1] + sign * Capsule->final_posr->R[2][1] * Capsule->radius;\n    immersion->plane.p[2] = Capsule->final_posr->pos[2] + sign * Capsule->final_posr->R[2][2] * Capsule->radius;\n    immersion->plane.p[3] = Capsule->final_posr->R[2][3];\n\n    // call dImmerseBox to process the immersion of the box in the fluid\n    return dImmerseBox(o1, immersion, flags);\n  }\n\n  return 0;\n}", "CodeBleu_score": 46.10368056369144}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxBox *Box = (dxBox*) o1;\n  dxCapsule *Capsule = (dxCapsule*) o2;\n\n  // get parameters\n  dVector3 Box_pos;\n  dMatrix3 Box_R;\n  Box->computeAABB();\n  Box->getAABB (Box_pos,Box_R);\n\n  dVector3 Capsule_pos;\n  dMatrix3 Capsule_R;\n  Capsule->getAABB (Capsule_pos,Capsule_R);\n\n  // get capsule axis\n  dVector3 v;\n  dMultiply0_331 (v,Capsule_R,Capsule->final_posr->R);\n\n  // get capsule radius\n  dReal radius = Capsule->radius;\n\n  // get box half size\n  dVector3 size;\n  dMultiply1_331 (size,Box_R,Box->side);\n\n  // get capsule position\n  dVector3 pos;\n  pos[0] = Capsule_pos[0] - Box_pos[0];\n  pos[1] = Capsule_pos[1] - Box_pos[1];\n  pos[2] = Capsule_pos[2] - Box_pos[2];\n\n  // get capsule position projected on the box\n  dVector3 p;\n  p[0] = pos[0] - v[0] * (v[0] > 0.0 ? size[0] : -size[0]);\n  p[1] = pos[1] - v[1] * (v[1] > 0.0 ? size[1] : -size[1]);\n  p[2] = pos[2] - v[2] * (v[2] > 0.0 ? size[2] : -size[2]);\n\n  // compute distance between capsule and box", "CodeBleu_score": 38.81785092301686}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal result = 0.0;\n\n    dReal sinTheta0 = tanTheta0 / dSqrt(dFabs(1.0 + tanTheta0 * tanTheta0));\n    dReal sinTheta1 = sinTheta1;\n    dReal cosTheta0 = dSqrt(dFabs(1.0 - sinTheta0 * sinTheta0));\n    dReal cosTheta1 = dSqrt(dFabs(1.0 - sinTheta1 * sinTheta1));\n\n    // Integrate from theta0 to theta1\n    dReal theta = (sinTheta0 + sinTheta1) / 2.0;\n    dReal thetaNext = theta;\n    dReal thetaNextNext = theta;\n    dReal thetaNextNextNext = theta;\n    dReal thetaNextNextNextNext = theta;\n\n    dReal sinTheta = (sinTheta0 + sinTheta1) / 2.0;\n    dReal sinThetaNext = sinTheta;\n    dReal sinThetaNextNext = sinTheta;\n    dReal sinThetaNextNextNext = sinTheta;\n    dReal sinThetaNextNextNextNext = sinTheta;\n\n    dReal cosTheta = (cosTheta0 + cosTheta1) / 2.0;\n    dReal cosThetaNext = cosTheta;\n    dReal cosThetaNextNext = cosTheta;\n    dReal cosThetaNextNextNext = cosTheta;\n    dReal cosThetaNextNextNextNext = cosTheta;\n\n    dReal z = (zIOverR * sinTheta0 + zIOverR * sinTheta1) / 2.0;\n    dReal zNext = z;\n    dReal zNextNext = z;\n    dReal zNextNextNext = z;\n    dReal zNextNextNextNext = z;\n\n    dReal dz = (zIOverR * cosTheta0 + zIOverR * cosTheta1) / 2.0;\n    dReal dzNext = dz;\n    dReal dzNextNext = dz;\n    dReal dzNextNextNext = dz;\n    dReal dzNextNextNextNext = dz;\n\n    dReal term = 0.0;\n    dReal termNext", "CodeBleu_score": 36.818746655469056}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal result = 0.0;\n\n    // First part of the integration\n    {\n        dReal tanTheta = tanTheta0;\n\n        dReal zIOverR_tanTheta = zIOverR * tanTheta;\n\n        dReal sinTheta = sqrt(1.0 - zIOverR_tanTheta * zIOverR_tanTheta);\n\n        dReal cosTheta = sqrt(1.0 - sinTheta * sinTheta);\n\n        dReal dSinTheta = sinTheta1 - sinTheta;\n\n        dReal dCosTheta = cosTheta1 - cosTheta;\n\n        dReal dTanTheta = dSinTheta / dCosTheta;\n\n        dReal dZIOverR_tanTheta = dZIOverR * tanTheta + zIOverR * dTanTheta;\n\n        dReal dVolume = 0.5 * (dZIOverR_tanTheta + zIOverR_tanTheta) * dSinTheta;\n\n        result += dVolume;\n    }\n\n    // Second part of the integration\n    {\n        dReal tanTheta = tanTheta1;\n\n        dReal zIOverR_tanTheta = zIOverR * tanTheta;\n\n        dReal sinTheta = sqrt(1.0 - zIOverR_tanTheta * zIOverR_tanTheta);\n\n        dReal cosTheta = sqrt(1.0 - sinTheta * sinTheta);\n\n        dReal dSinTheta = sinTheta - sinTheta0;\n\n        dReal dCosTheta = cosTheta - cosTheta0;\n\n        dReal dTanTheta = dSinTheta / dCosTheta;\n\n        dReal dZIOverR_tanTheta = dZIOverR * tanTheta + zIOverR * dTanTheta;\n\n        dReal dVolume = 0.5 * (dZIOverR_tanTheta + zIOverR_tanTheta) * dSinTheta;\n\n        result += dVolume;\n    }\n\n    return result;\n}", "CodeBleu_score": 37.81711182422782}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    const dReal tanTheta1 = tanTheta0 * tanTheta0 / (1.0 - zIOverR * zIOverR);\n\n    const dReal sinTheta0 = tanTheta0 / sqrt(1.0 + tanTheta0 * tanTheta0);\n    const dReal sinTheta2 = tanTheta1 / sqrt(1.0 + tanTheta1 * tanTheta1);\n\n    const dReal theta0 = asin(sinTheta0);\n    const dReal theta1 = asin(sinTheta1);\n    const dReal theta2 = asin(sinTheta2);\n\n    const dReal k1 = (theta1 - theta0) / 6.0;\n    const dReal k2 = (theta2 - theta1) / 6.0;\n\n    const dReal k3 = (theta1 - theta0) / 3.0;\n    const dReal k4 = (theta2 - theta1) / 3.0;\n\n    const dReal k5 = (theta2 - theta0) / 3.0;\n\n    const dReal k6 = (theta2 - theta0) / 6.0;\n\n    const dReal k7 = (theta2 - theta1) / 6.0;\n\n    const dReal k8 = (theta2 - theta0) / 6.0;\n\n    const dReal k9 = (theta2 - theta1) / 3.0;\n\n    const dReal k10 = (theta2 - theta0) / 3.0;\n\n    const dReal k11 = (theta2 - theta1) / 3.0;\n\n    const dReal k12 = (theta2 - theta0) / 3.0;\n\n    const dReal k13 = (theta2 - theta1) / 3.0;\n\n    const dReal k14 = (theta2 - theta0) / 3.0;\n\n    const dReal k15 = (theta2 - theta1) / 3.0;\n\n    const dReal k16 = (theta2 - theta0) / 3.0;\n\n", "CodeBleu_score": 33.51933701133458}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    const dReal zIOverR2 = zIOverR * zIOverR;\n    const dReal zIOverR3 = zIOverR2 * zIOverR;\n    const dReal zIOverR4 = zIOverR3 * zIOverR;\n    const dReal zIOverR5 = zIOverR4 * zIOverR;\n    const dReal zIOverR6 = zIOverR5 * zIOverR;\n    const dReal zIOverR7 = zIOverR6 * zIOverR;\n    const dReal zIOverR8 = zIOverR7 * zIOverR;\n    const dReal zIOverR9 = zIOverR8 * zIOverR;\n    const dReal zIOverR10 = zIOverR9 * zIOverR;\n    const dReal zIOverR11 = zIOverR10 * zIOverR;\n    const dReal zIOverR12 = zIOverR11 * zIOverR;\n    const dReal zIOverR13 = zIOverR12 * zIOverR;\n    const dReal zIOverR14 = zIOverR13 * zIOverR;\n    const dReal zIOverR15 = zIOverR14 * zIOverR;\n    const dReal zIOverR16 = zIOverR15 * zIOverR;\n    const dReal zIOverR17 = zIOverR16 * zIOverR;\n    const dReal zIOverR18 = zIOverR17 * zIOverR;\n    const dReal zIOverR19 = zIOverR18 * zIOverR;\n    const dReal zIOverR20 = zIOverR19 * zIOverR;\n    const dReal zIOverR21 = zIOverR20 * zIOverR;\n    const dReal zIOverR22 = zIOverR21 * zIOverR;\n    const dReal zIOverR23 = zIOverR22 * zIOverR;\n    const", "CodeBleu_score": 35.23177508633676}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // The buoyancy center is calculated using Simpson's rule for numerical integration over the hemisphere's surface.\n    // The integral is evaluated as:\n    //\n    //    I = 1/3 * (f(x0) + 4*f(x1) + 2*f(x2) + 4*f(x3) + ... + 2*f(xn-2) + 4*f(xn-1) + f(xn)) * dx\n    //\n    // where:\n    //\n    //    dx = (xn - x0) / n\n    //\n    // and:\n    //\n    //    f(x) = x * cos(theta) * sin(theta) * sqrt(1 - x^2)\n    //\n    // The buoyancy center is calculated as:\n    //\n    //    xB = 1/I * (f(x0) + 4*f(x1) + 2*f(x2) + 4*f(x3) + ... + 2*f(xn-2) + 4*f(xn-1) + f(xn)) * dx\n    //\n    // The function returns the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.\n\n    const dReal x0 = -tanTheta0;\n    const dReal xn = sinTheta1;\n    const dReal dx = (xn - x0) / (dReal)SIMPSON_RULE_NUM_OF_POINTS;\n    const dReal cosTheta0 = sqrt(1.0 - x0 * x0);\n    const dReal cosTheta1 = sqrt(1.0 - xn * xn);\n\n    dReal integral = 0.0;\n    dReal x = x0;\n    for (unsigned int i = 0; i < SIMPSON_RULE_NUM_OF_POINTS; ++i) {\n        const dReal cosTheta = sqrt(1.0 - x * x);\n        const dReal f = x * cosTheta * sin(acos(cosTheta));\n        if (i % 2", "CodeBleu_score": 40.60222292158196}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    dReal xBuoyancyCenter;\n\n    if (zIOverR < 1.0) {\n        dReal cosTheta0 = sqrt(1.0 - tanTheta0 * tanTheta0);\n        dReal cosTheta1 = sqrt(1.0 - sinTheta1 * sinTheta1);\n\n        dReal xBuoyancyCenter0 = 0.0;\n        dReal xBuoyancyCenter1 = 0.0;\n\n        dReal xBuoyancyCenter2 = 0.0;\n        dReal xBuoyancyCenter3 = 0.0;\n\n        dReal xBuoyancyCenter4 = 0.0;\n        dReal xBuoyancyCenter5 = 0.0;\n\n        dReal xBuoyancyCenter6 = 0.0;\n        dReal xBuoyancyCenter7 = 0.0;\n\n        dReal xBuoyancyCenter8 = 0.0;\n        dReal xBuoyancyCenter9 = 0.0;\n\n        dReal xBuoyancyCenter10 = 0.0;\n        dReal xBuoyancyCenter11 = 0.0;\n\n        dReal xBuoyancyCenter12 = 0.0;\n        dReal xBuoyancyCenter13 = 0.0;\n\n        dReal xBuoyancyCenter14 = 0.0;\n        dReal xBuoyancyCenter15 = 0.0;\n\n        dReal xBuoyancyCenter16 = 0.0;\n        dReal xBuoyancyCenter17 = 0.0;\n\n        dReal xBuoyancyCenter18 = 0.0;\n        dReal xBuoyancyCenter19 = 0.0;\n\n        dReal xBuoyancyCenter20 = 0.0;\n        dReal xBuoyancyCenter21 = 0.0;\n\n        dReal xBuoyancyCenter22 = 0.0;\n        dReal xBuoyancyCenter23 = 0.0;\n\n        dReal xBuoyancyCenter24 = 0.0;\n        dReal xBuoyancyCenter25 = ", "CodeBleu_score": 25.4350512251861}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  const dReal radius = REAL(0.5) * dGeomCapsuleGetRadius(o1);\n  const dReal halfHeight = REAL(0.5) * dGeomCapsuleGetLength(o1);\n  const dReal *const R = dGeomGetRotation(o1);\n  const dReal *const p = dGeomGetPosition(o1);\n  const dReal *const normal = dGeomTriMeshGetRotation(o2);\n  const dReal *const position = dGeomTriMeshGetPosition(o2);\n  const dReal *const side = dGeomTriMeshGetSideLengths(o2);\n  const dReal *const v = dGeomTriMeshGetVelocity(o2);\n  const dReal *const w = dGeomTriMeshGetAngularVelocity(o2);\n  const dReal *const center = dGeomTriMeshGetPoint(o2, 0);\n  const int numOfTriangles = dGeomTriMeshGetTriangleCount(o2);\n  const int *const indices = (int *) dGeomTriMeshGetIndices(o2);\n  const int *const adjacency = (int *) dGeomTriMeshGetAdjacency(o2);\n\n  const dReal tolerance = 1e-5;\n  const dReal threshold = 1e-12;\n  const dReal epsilon = 1e-6;\n\n  const dReal cosAngle = dGeomCapsuleGetParams(o1);\n  const dReal sinAngle = dSqrt(dFabs(REAL(1.0) - cosAngle * cosAngle));\n  const dReal volume = REAL(2.0) * dPi * radius * radius * halfHeight * sinAngle;\n\n  const dReal cosAngle2 = cosAngle * cosAngle;\n  const dReal sinAngle2 = sinAngle * sinAngle;\n\n  const dReal cosAngle3 = cosAngle * cosAngle2;\n  const dReal sinAngle3 = sinAngle * sinAngle2;\n\n  const dReal cosAngle4 = cosAngle * cosAngle3;\n  const", "CodeBleu_score": 33.97058654744462}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  dIASSERT(o1->type == dCapsuleClass);\n  dIASSERT(o2->type == dTriMeshClass);\n  dIASSERT(o1->body);\n\n  dxCapsule *capsule = (dxCapsule *) o1;\n  dxTriMesh *mesh = (dxTriMesh *) o2;\n\n  dReal radius = REAL(0.5) * capsule->radius;\n  dReal halfLength = REAL(0.5) * capsule->lz;\n  dVector3 center;\n  dGeomCopyPosition(o1, center);\n\n  // get the vertices\n  int TriMeshPointStride = mesh->data->stride;\n  dReal *TriMeshVertices = mesh->data->vertices;\n\n  // get the triangles\n  int TriMeshTriStride = mesh->data->stride;\n  dTriIndex *TriMeshIndices = mesh->data->indices;\n\n  // get the point of the capsule that is closest to the trimesh\n  dVector3 closestPoint;\n  dReal depth;\n  dGeomClosestPoint(o1, o2, closestPoint, &depth);\n\n  // get the normal at the closest point\n  dVector3 normal;\n  dGeomGetNormal(o2, closestPoint, normal);\n\n  // get the direction of the capsule's axis\n  dVector3 axis;\n  dGeomCapsuleGetAxis(o1, axis);\n\n  // get the rotation matrix\n  dMatrix3 R;\n  dGeomGetRotation(o1, R);\n\n  // get the rotation matrix inverse\n  dMatrix3 R_I;\n  dRSetIdentity(R_I);\n  dRFromAxisAndAngle(R_I, axis[0], axis[1], axis[2], -dGeomGetAngle(o1));\n\n  // get the rotation matrix inverse and transpose\n  dMatrix3 R_IT;\n  dRSetIdentity(R_IT);\n  dRFromAxisAndAngle(R_IT, axis[0], axis[1], axis[2], -", "CodeBleu_score": 37.45459735625707}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n\n  dxCapsule *c = (dxCapsule*) CAPSULE_GEOM (o1);\n  dxTriMesh *m = (dxTriMesh*) TRIMESH_GEOM (o2);\n\n  const dReal radius = c->radius;\n  const dReal halfLength = REAL(0.5) * c->lz;\n\n  const dReal *const R = c->final_posr->R;\n  const dReal *const pos = c->final_posr->pos;\n\n  const dReal *const p = m->final_posr->pos;\n  const dReal *const R_ = m->final_posr->R;\n\n  const dReal *const vertex = m->mesh_positions;\n  const int *const index = m->mesh_indices;\n  const int *const tri = m->mesh_tri;\n\n  const int stride = m->mesh_strides;\n  const int *const adjacency = m->mesh_adjacency;\n\n  int i;\n\n  dVector3 n, p1, p2, q1, q2, v, w;\n  dReal depth, length, volume;\n\n  sCapsuleImmersionData data;\n  dImmersionOutline outline;\n\n  dSetZero (immersion, sizeof (dImmersionGeom));\n\n  immersion->g1 = o1;\n  immersion->g2 = o2;\n\n  immersion->slipping = 1;\n\n  immersion->volume = 0;\n\n  dSetZero (immersion->projectedAreas, sizeof (immersion->projectedAreas));\n\n  dSetZero (immersion->projectedMasses, sizeof (immersion->projectedMasses));\n\n  immersion->buoyancyCenter[0] = 0;\n  immersion->buoyancyCenter[1] = 0;\n  immersion->buoyancyCenter[2] = 0;\n\n", "CodeBleu_score": 38.51926491945592}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\n    // Retrieve the sleep duration in milliseconds from the input\n    int milliseconds = 0;\n    if (!getInput<int>(\"milliseconds\", milliseconds)) {\n        // If the duration is missing or non-positive, return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n\n    // Start a timer\n    timer_waiting_ = true;\n    timer_ = std::make_shared<boost::asio::deadline_timer>(\n        io_service_,\n        boost::posix_time::milliseconds(milliseconds));\n\n    // Set a callback to emit a wake-up signal when the timer expires\n    timer_->async_wait(boost::bind(&SleepNode::wakeUp, this));\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 48.30587640786239}, {"code": "NodeStatus SleepNode::onStart(){\n\t    NodeStatus status;\n\n    int sleep_duration = getInput<int>(\"sleep_duration\", status);\n    if (!status.success()) {\n        return status;\n    }\n\n    if (sleep_duration <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    timer_waiting_ = true;\n    setStatus(NodeStatus::RUNNING);\n    timer_.start(sleep_duration, [this]() {\n        timer_waiting_ = false;\n        setStatus(NodeStatus::SUCCESS);\n    });\n\n    return status;\n}", "CodeBleu_score": 52.72645523318783}, {"code": "NodeStatus SleepNode::onStart(){\n\t    // Retrieve sleep duration from input.\n    int sleep_duration_ms = 0;\n    if (!getInput(\"milliseconds\", sleep_duration_ms)) {\n        return NodeStatus::SUCCESS;\n    }\n\n    // If sleep duration is non-positive, return success.\n    if (sleep_duration_ms <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    // Set node status to RUNNING, start timer, and set callback to emit wake-up signal when timer expires.\n    setStatus(NodeStatus::RUNNING);\n    timer_waiting_ = true;\n    timer_ = std::make_unique<ros::WallTimer>(ros::WallDuration(sleep_duration_ms / 1000.0), &SleepNode::wakeUp, this);\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 48.50830919614712}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n    }\n\n    const std::string& entry_name = getInput<std::string>(\"entry_name\");\n    const auto& entry = blackboard_->getEntry(entry_name);\n    if (!entry) {\n        throw BehaviorTreeException(\"EntryUpdatedAction: entry not found\");\n    }\n\n    std::unique_lock<std::mutex> lock(entry->mutex_);\n\n    if (entry->sequence_ != last_sequence_) {\n        last_sequence_ = entry->sequence_;\n        return NodeStatus::SUCCESS;\n    }\n\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 40.6506358252121}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    std::string entry_name;\n    getInput(\"entry_name\", entry_name);\n    auto entry = blackboard_->getEntry(entry_name);\n    if (entry) {\n        auto mutex = entry->getMutex();\n        std::unique_lock<std::mutex> lock(*mutex);\n        auto sequence_id = entry->sequence_id;\n        if (sequence_id != last_sequence_id_) {\n            last_sequence_id_ = sequence_id;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 50.25848983331619}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Get the entry\n    std::string entry_name;\n    getInput(\"entry_name\", entry_name);\n\n    // Get the entry\n    auto entry = blackboard_->getEntry<int>(entry_name);\n\n    // If the entry is not found, return FAILURE\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the mutex\n    std::unique_lock<std::mutex> lock(entry->mutex);\n\n    // Compare the current sequence ID with the previously stored sequence ID\n    if (entry->sequence_ID != sequence_ID_) {\n        // Update the stored sequence ID\n        sequence_ID_ = entry->sequence_ID;\n        return NodeStatus::SUCCESS;\n    }\n\n    // Return FAILURE\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 47.81699251794896}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    return std::max(static_cast<int>(children_nodes_.size()) + success_threshold_, 0);\n  }\n  return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 58.24858796165022}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        // Negative success threshold means success threshold is calculated based on the number of children\n        // (e.g. success threshold of -1 means all children must succeed, -2 means 1 less than the number of children must succeed, etc.)\n        return std::max(static_cast<size_t>(0), static_cast<size_t>(success_threshold_ + children_nodes_.size()));\n    }\n    else {\n        // Non-negative success threshold means the success threshold is calculated based on the number of children\n        // (e.g. success threshold of 1 means 1 child must succeed, 2 means 2 children must succeed, etc.)\n        return static_cast<size_t>(success_threshold_);\n    }\n}", "CodeBleu_score": 58.496453490881116}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return static_cast<size_t>(std::max(1, children_nodes_.size() + success_threshold_));\n    }\n    return static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 57.16741847021157}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lock(heartbeat_mutex_);\n    if (heartbeat_status_) {\n      if (std::chrono::system_clock::now() - last_heartbeat_ > std::chrono::seconds(1)) {\n        heartbeat_status_ = false;\n        publisher_.send(Groot2Protocol::heartbeat(false));\n        if (debug_mode_) {\n          std::cout << \"Groot2Publisher: Heartbeat lost, disabling breakpoints\" << std::endl;\n        }\n        breakpoints_.clear();\n      }\n    } else {\n      if (std::chrono::system_clock::now() - last_heartbeat_ < std::chrono::seconds(1)) {\n        heartbeat_status_ = true;\n        publisher_.send(Groot2Protocol::heartbeat(true));\n        if (debug_mode_) {\n          std::cout << \"Groot2Publisher: Heartbeat regained, enabling breakpoints\" << std::endl;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 37.51084483862762}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::lock_guard<std::mutex> lk(heartbeat_mutex_);\n        if (heartbeat_active_) {\n            if (std::chrono::steady_clock::now() - last_heartbeat_ > std::chrono::milliseconds(HEARTBEAT_TIMEOUT_MS)) {\n                heartbeat_active_ = false;\n                if (verbose_) {\n                    std::cout << \"Groot2Publisher: heartbeat timeout, disabling breakpoints\" << std::endl;\n                }\n                for (auto& bp : breakpoints_) {\n                    bp->disable();\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 34.27401976004195}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (heartbeat_active_) {\n            if (std::chrono::steady_clock::now() - heartbeat_timestamp_ > std::chrono::milliseconds(1000)) {\n                heartbeat_active_ = false;\n                if (debug_mode_) {\n                    std::cout << \"Heartbeat lost, disabling breakpoints\" << std::endl;\n                }\n                for (auto& breakpoint : breakpoints_) {\n                    breakpoint.second = false;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 33.32316681184376}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> output;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    if (bb_name.empty()) continue;\n    auto subtree = tree_->root_->findSubtree(bb_name);\n    if (!subtree) continue;\n    std::lock_guard<std::mutex> lk(subtree->mtx_);\n    if (!subtree->root_node_) continue;\n    auto bb = subtree->root_node_->blackboard();\n    if (!bb) continue;\n    nlohmann::json bb_json;\n    bb->saveToJSON(bb_json);\n    output.insert(output.end(), bb_json.dump().begin(), bb_json.dump().end());\n  }\n  return output;\n}", "CodeBleu_score": 44.279833682952976}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> msgpack_data;\n\n    // Split the input string of blackboard names\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n\n    // Iterate through the blackboard names\n    for (const std::string& bb_name : bb_names) {\n        // Find the corresponding subtree\n        auto subtree_it = std::find_if(subtrees_.begin(), subtrees_.end(), [bb_name](const SubtreeData& subtree) {\n            return subtree.blackboard_name == bb_name;\n        });\n\n        // If the subtree is valid, export the blackboard to JSON and add it to the JSON object\n        if (subtree_it != subtrees_.end()) {\n            std::lock_guard<std::mutex> lock(subtree_it->mutex);\n\n            nlohmann::json bb_json = subtree_it->subtree->root_node->blackboard->toJSON();\n            msgpack_data.insert(msgpack_data.end(), bb_json.dump().begin(), bb_json.dump().end());\n        }\n    }\n\n    // Convert the JSON object to MessagePack format and return it as a vector of uint8_t\n    msgpack::sbuffer sbuf;\n    msgpack::pack(sbuf, msgpack_data);\n    return std::vector<uint8_t>(sbuf.data(), sbuf.data() + sbuf.size());\n}", "CodeBleu_score": 45.70796935187613}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> result;\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n    for(std::string bb_name: bb_names) {\n        BehaviorTree* subtree = tree_->findSubtree(bb_name);\n        if(subtree) {\n            subtree->lock();\n            std::string json_bb = subtree->root_node_->blackboard_->toJSON();\n            result.insert(result.end(), json_bb.begin(), json_bb.end());\n            subtree->unlock();\n        }\n    }\n    return result;\n}", "CodeBleu_score": 44.05069101364341}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook_it = hooks_.find(node_uid);\n  if (hook_it == hooks_.end()) {\n    return false;\n  }\n\n  auto& hook = hook_it->second;\n\n  std::unique_lock<std::mutex> lock(hook.mutex);\n\n  if (hook.status != NodeStatus::BREAKPOINT) {\n    return false;\n  }\n\n  hook.status = result;\n  hook.remove = remove;\n  hook.ready = true;\n\n  hook.cond.notify_all();\n\n  return true;\n}", "CodeBleu_score": 43.06019606843093}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t    auto node_it = nodes_.find(node_uid);\n    if (node_it == nodes_.end()) {\n        std::cout << \"Node \" << node_uid << \" not found\" << std::endl;\n        return false;\n    }\n    auto node = node_it->second;\n    if (!node) {\n        std::cout << \"Node \" << node_uid << \" is null\" << std::endl;\n        return false;\n    }\n    auto hook_it = hooks_.find(node);\n    if (hook_it == hooks_.end()) {\n        std::cout << \"Hook for node \" << node_uid << \" not found\" << std::endl;\n        return false;\n    }\n    auto hook = hook_it->second;\n    if (!hook) {\n        std::cout << \"Hook for node \" << node_uid << \" is null\" << std::endl;\n        return false;\n    }\n    std::unique_lock<std::mutex> lk(hook->mutex);\n    if (hook->mode != HookMode::BREAKPOINT) {\n        std::cout << \"Hook for node \" << node_uid << \" is not in BREAKPOINT mode\" << std::endl;\n        return false;\n    }\n    hook->mode = HookMode::READY;\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cond.notify_all();\n    return true;\n}", "CodeBleu_score": 51.145699085829776}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto it = nodes_.find(node_uid);\n  if (it == nodes_.end()) {\n    return false;\n  }\n\n  auto& node = it->second;\n\n  auto hook_it = node.hooks.find(pos);\n  if (hook_it == node.hooks.end()) {\n    return false;\n  }\n\n  auto& hook = hook_it->second;\n\n  std::unique_lock<std::mutex> lock(hook.mutex);\n  if (hook.status != BREAKPOINT) {\n    return false;\n  }\n\n  hook.status = result;\n  hook.remove = remove;\n  hook.ready = true;\n  hook.cv.notify_all();\n  return true;\n}", "CodeBleu_score": 58.69527319507315}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\n    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n\n        std::thread([this]() {\n            try {\n                setStatus(tick());\n            } catch (std::exception& e) {\n                std::cerr << \"Exception caught in ThreadedAction: \" << e.what() << std::endl;\n                setStatus(NodeStatus::IDLE);\n            } catch (...) {\n                std::cerr << \"Unknown exception caught in ThreadedAction\" << std::endl;\n                setStatus(NodeStatus::IDLE);\n            }\n        }).detach();\n\n        return NodeStatus::RUNNING;\n    }\n\n    if (status() == NodeStatus::RUNNING) {\n        if (halt_requested_) {\n            halt();\n            halt_requested_ = false;\n        }\n    }\n\n    if (status() == NodeStatus::SUCCESS || status() == NodeStatus::FAILURE) {\n        halt();\n    }\n\n    return status();\n}", "CodeBleu_score": 52.09382034520856}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n        // Start the asynchronous tick function\n        auto future = std::async(std::launch::async, [this]() {\n            try {\n                // Call the tick function\n                NodeStatus tick_status = tick();\n                // If halt was not requested, set the status\n                if (!halt_requested_) {\n                    setStatus(tick_status);\n                }\n            } catch (std::exception& ex) {\n                // If an exception occurs, log an error and set the status to IDLE\n                std::cerr << \"[BT::ThreadedAction::executeTick] \"\n                          << \"Exception caught from tick function: \" << ex.what()\n                          << std::endl;\n                setStatus(NodeStatus::IDLE);\n            }\n        });\n        // Store the future so that we can check for exceptions\n        futures_.push_back(std::move(future));\n    }\n    // Check for any stored exceptions\n    for (auto it = futures_.begin(); it != futures_.end();) {\n        // If the future is ready, check for exceptions\n        if (it->wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n            // If an exception occurred, rethrow it\n            it->get();\n            // Remove the future from the list\n            it = futures_.erase(it);\n        } else {\n            // If no exception occurred, move to the next future\n            ++it;\n        }\n    }\n    // Return the current status\n    return status();\n}", "CodeBleu_score": 52.31663431167964}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    std::unique_lock<std::mutex> lk(m_);\n    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_ = false;\n        lk.unlock();\n        std::thread([this]() {\n            try {\n                setOutput(\"halt_requested\", false);\n                tick();\n                setStatus(NodeStatus::SUCCESS);\n            }\n            catch (std::exception& e) {\n                setStatus(NodeStatus::IDLE);\n                std::cerr << \"Exception in ThreadedAction: \" << e.what() << std::endl;\n            }\n            catch (...) {\n                setStatus(NodeStatus::IDLE);\n                std::cerr << \"Exception in ThreadedAction\" << std::endl;\n            }\n        }).detach();\n    }\n    else if (status() == NodeStatus::RUNNING) {\n        if (halt_requested_) {\n            setStatus(NodeStatus::IDLE);\n            halt_requested_ = false;\n        }\n    }\n    return status();\n}", "CodeBleu_score": 52.77408003483386}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    const auto print_node = [&stream](const TreeNode* node, int depth) {\n        stream << std::string(depth, '\\t') << node->name() << '\n';\n        if (node->children_nodes_.empty()) {\n            return;\n        }\n        for (auto child : node->children_nodes_) {\n            print_node(child, depth + 1);\n        }\n    };\n\n    stream << \"Behavior Tree:\n\";\n    print_node(root_node, 0);\n    stream << \"----------------\n\";\n}", "CodeBleu_score": 29.77475401002566}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_node = [&](const TreeNode* node, int depth) {\n        if (node) {\n            stream << std::string(depth, ' ') << node->name() << std::endl;\n            if (node->type() == NodeType::CONTROL) {\n                for (const auto& child : static_cast<const ControlNode*>(node)->children()) {\n                    print_node(child.get(), depth + 1);\n                }\n            } else if (node->type() == NodeType::DECORATOR) {\n                print_node(static_cast<const DecoratorNode*>(node)->child(), depth + 1);\n            }\n        }\n    };\n    stream << \"-------------------------------------------------\" << std::endl;\n    print_node(root_node, 0);\n    stream << \"-------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 43.98165220122836}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_node = [&stream](const TreeNode* node, int depth) {\n        stream << std::string(depth * 2, ' ');\n        stream << node->name() << std::endl;\n        if (node->type() == NodeType::CONTROL) {\n            auto control_node = dynamic_cast<const BT::ControlNode*>(node);\n            for (auto& child : control_node->children()) {\n                print_node(child.get(), depth + 1);\n            }\n        } else if (node->type() == NodeType::DECORATOR) {\n            auto decorator_node = dynamic_cast<const BT::DecoratorNode*>(node);\n            print_node(decorator_node->child(), depth + 1);\n        }\n    };\n    stream << \"---------TREE BEGIN---------\" << std::endl;\n    print_node(root_node, 0);\n    stream << \"---------TREE END---------\" << std::endl;\n}", "CodeBleu_score": 51.987781187836624}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (!node) {\n        throw LogicError(\"applyRecursiveVisitor: node is null\");\n    }\n    visitor(node);\n    if (node->isControlNode()) {\n        auto* control_node = static_cast<const ControlNode*>(node);\n        for (auto* child : control_node->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    }\n    else if (node->isDecoratorNode()) {\n        auto* decorator_node = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator_node->child(), visitor);\n    }\n}", "CodeBleu_score": 62.190776469676564}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: nullptr\");\n  }\n  visitor(node);\n  if (node->isControlNode()) {\n    auto control_node = dynamic_cast<const ControlNode*>(node);\n    for (auto child : control_node->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->isDecoratorNode()) {\n    auto decorator_node = dynamic_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decorator_node->child(), visitor);\n  }\n}", "CodeBleu_score": 63.50249976390082}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (node->isControlNode()) {\n    for (auto child : node->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->isDecoratorNode()) {\n    applyRecursiveVisitor(node->children[0], visitor);\n  }\n}", "CodeBleu_score": 45.47374066891467}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    std::string registration_id = manifest.registration_ID;\n\n    if (builders_.find(registration_id) != builders_.end()) {\n        throw BehaviorTreeException(\"Error when registering \" + registration_id +\n                                    \": ID already registered\");\n    }\n\n    builders_[registration_id] = builder;\n    manifests_[registration_id] = manifest;\n}", "CodeBleu_score": 43.35718438543985}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders_.find(manifest.registration_ID) != builders_.end()) {\n    throw BehaviorTreeException(\"Error when registering \" +\n                                manifest.registration_ID +\n                                \" : ID already registered\");\n  }\n  builders_[manifest.registration_ID] = builder;\n  manifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 46.252806033380104}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders_.find(manifest.registration_ID) != builders_.end()) {\n    throw BehaviorTreeException(\"Manifest ID: \" + manifest.registration_ID +\n                                \" already registered\");\n  }\n\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 51.41104697460782}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t    NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                                const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, config, tick_functor, ports);\n    };\n    TreeNodeManifest manifest(ID, Action, ports);\n    registerBuilder(manifest, builder);\n}", "CodeBleu_score": 67.22998962787064}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor](const std::string& name,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n  TreeNodeManifest manifest(NodeType::ACTION, ID, std::move(ports));\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 68.65911875383841}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                              const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, ports, config);\n  };\n  TreeNodeManifest manifest(ID, ActionNode::getTypeStatic(), ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 68.90413778562805}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> bb_backup;\n  bb_backup.reserve(tree.subtrees.size());\n  for (auto& subtree : tree.subtrees) {\n    Blackboard::Ptr bb_clone = Blackboard::create();\n    bb_clone->setMemory(subtree->root_node->blackboard->getMemory());\n    bb_backup.push_back(bb_clone);\n  }\n  return bb_backup;\n}", "CodeBleu_score": 57.16121482191716}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.root_node->children.size());\n  for (auto& child : tree.root_node->children) {\n    Blackboard::Ptr blackboard_backup = Blackboard::create();\n    blackboard_backup->setRoot(tree.root_node->blackboard);\n    blackboard_backup->setParent(tree.root_node->blackboard);\n    blackboard_backup->clear();\n    blackboard_backup->mergeFrom(*child->blackboard);\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}", "CodeBleu_score": 47.45127833288583}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.root_node->children.size());\n    for (auto& child : tree.root_node->children) {\n        Blackboard::Ptr new_blackboard = Blackboard::create();\n        new_blackboard->setParent(tree.root_node->blackboard);\n        new_blackboard->clear();\n        new_blackboard->mergeFrom(*child->blackboard);\n        blackboard_backups.push_back(new_blackboard);\n    }\n    return blackboard_backups;\n}", "CodeBleu_score": 48.132949481416674}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor->execute(env);\n}", "CodeBleu_score": 73.29052456777674}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return (*executor)(env);\n}", "CodeBleu_score": 72.9768072344042}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto script_executor = ParseScript(script);\n    if (!script_executor) {\n        return nonstd::make_unexpected(script_executor.error());\n    }\n\n    return script_executor.value()->Execute(env);\n}", "CodeBleu_score": 63.975927108892975}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n\n    if (handle_) {\n        throw BehaviorTreeException(\"SharedLibrary already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!handle_) {\n        throw BehaviorTreeException(std::string(\"Failed to load library: \") + dlerror());\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 51.63036664848193}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (handle_ != nullptr) {\n        throw RuntimeError(\"SharedLibrary::load: library already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        throw RuntimeError(\"SharedLibrary::load: \" + std::string(dlerror()));\n    }\n    path_ = path;\n}", "CodeBleu_score": 50.96355020573794}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n\n    if (handle_) {\n        throw BehaviorTreeException(\"Library already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!handle_) {\n        throw BehaviorTreeException(std::string(\"Failed to load library: \") + dlerror());\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 51.658479900191466}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    auto first = str.find_first_not_of(' ');\n    auto last = str.find_last_not_of(' ');\n\n    if (first == StringView::npos || last == StringView::npos) {\n        return false;\n    }\n\n    str = str.substr(first, (last - first) + 1);\n\n    if (str.size() < 3) {\n        return false;\n    }\n\n    if (str.front() == '{' && str.back() == '}') {\n        if (stripped_pointer) {\n            *stripped_pointer = str.substr(1, str.size() - 2);\n        }\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 40.76734174078264}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    const char* begin = str.data();\n    const char* end = str.data() + str.size();\n\n    // strip leading spaces\n    while (begin != end && std::isspace(*begin)) {\n        begin++;\n    }\n\n    // strip trailing spaces\n    while (begin != end && std::isspace(*(end - 1))) {\n        end--;\n    }\n\n    if (end - begin < 3) {\n        return false;\n    }\n\n    if (*begin != '{' || *(end - 1) != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = StringView(begin + 1, end - begin - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 45.450714291417206}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n    StringView trimmed = str.trimmed();\n    if (trimmed.size() < 3) {\n        return false;\n    }\n    if (trimmed[0] != '{' || trimmed[trimmed.size() - 1] != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 29.153837843409203}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double line_cost = 0.0;\n  LineIterator line(x0, y0, x1, y1);\n\n  for (; !line.done(); line.advance()) {\n    double point_cost = pointCost(line.x(), line.y());\n\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n\n    if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 69.09693628738319}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double cost = 0;\n  LineIterator line(x0, y0, x1, y1);\n  for (; !line.done(); ++line) {\n    double point_cost = pointCost(line.x, line.y);\n    if (point_cost < 0) {\n      return point_cost;\n    }\n    if (point_cost > cost) {\n      cost = point_cost;\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 59.84943409507564}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\n  //initialize the line cost to be the maximum possible cost\n  double line_cost = std::numeric_limits<double>::infinity();\n\n  //iterate through each point on the line\n  LineIterator line(x0, y0, x1, y1);\n  for(; !line.done(); ++line) {\n    //calculate the cost of the current point\n    double point_cost = pointCost(line.getX(), line.getY());\n\n    //if the cost is negative, return immediately\n    if(point_cost < 0)\n      return point_cost;\n\n    //update the line cost if the current point is more expensive\n    if(point_cost > line_cost)\n      line_cost = point_cost;\n  }\n\n  //return the line cost\n  return line_cost;\n}", "CodeBleu_score": 69.98919785214439}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (!path.empty()) {\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n\n    for (unsigned int i = 0; i < path.size(); i++) {\n      gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n  }\n}", "CodeBleu_score": 84.4293386986186}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if(path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Copy the plan\n  for(unsigned int i = 0; i < path.size(); i++){\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 96.7470126783279}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if(path.empty())\n    return;\n\n  //create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for(unsigned int i=0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 96.88653725565996}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n    return (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) && (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) && (fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}", "CodeBleu_score": 69.89300112091632}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // check if the base is stopped\n  if (sqrt(pow(base_odom.twist.twist.linear.x, 2) + pow(base_odom.twist.twist.linear.y, 2)) <= trans_stopped_velocity\n      && fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 63.63006622237395}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // Check if the robot is rotating\n  if (abs(base_odom.twist.twist.angular.z) > rot_stopped_velocity) {\n    return false;\n  }\n\n  // Check if the robot is translating\n  if (abs(base_odom.twist.twist.linear.x) > trans_stopped_velocity) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 56.56483522037568}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    if (setup_) {\n        if (restore_defaults) {\n            config = default_limits_;\n        }\n    } else {\n        default_limits_ = config;\n        setup_ = true;\n    }\n    boost::mutex::scoped_lock lock(config_mutex_);\n    current_limits_ = config;\n}", "CodeBleu_score": 68.61444792236205}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_) {\n    if (restore_defaults) {\n      config = default_limits_;\n    }\n    config.lock();\n    current_limits_ = config;\n    config.unlock();\n  } else {\n    default_limits_ = config;\n    setup_ = true;\n  }\n}", "CodeBleu_score": 61.0121016277972}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    if (setup_) {\n        if (restore_defaults) {\n            config = default_limits_;\n        }\n\n        boost::mutex::scoped_lock l(configuration_mutex_);\n        current_limits_ = config;\n    } else {\n        default_limits_ = config;\n        setup_ = true;\n    }\n}", "CodeBleu_score": 67.76229265441785}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n  // Check if the cell is an obstacle or has no information\n  if (check_cell->is_obstacle || check_cell->is_unknown) {\n    // Set the cell's target distance to the maximum obstacle cost\n    current_cell->target_distance = costmap.getSizeInCellsX() + costmap.getSizeInCellsY();\n    // Return false\n    return false;\n  }\n\n  // Calculate the new target distance\n  int new_target_distance = current_cell->target_distance + 1;\n\n  // Update the cell's target distance if the new distance is shorter\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n  }\n\n  // Return true\n  return true;\n}", "CodeBleu_score": 45.504473249961826}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  //check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::NO_INFORMATION || cost == costmap_2d::LETHAL_OBSTACLE) {\n    //if the cell is an obstacle or has no information, we'll set the target distance to the maximum obstacle cost\n    current_cell->target_dist = costmap.getSizeInCellsX() + costmap.getSizeInCellsY();\n    return false;\n  }\n  else {\n    //if the cell isn't an obstacle, we'll calculate a new target distance\n    unsigned int new_target_dist = current_cell->target_dist + 1;\n    if (new_target_dist < check_cell->target_dist) {\n      check_cell->target_dist = new_target_dist;\n      check_cell->parent = current_cell;\n    }\n    return true;\n  }\n}", "CodeBleu_score": 69.63944056740709}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n  //check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  //calculate the distance to the cell\n  double dist = hypot(check_cell->x - current_cell->x, check_cell->y - current_cell->y);\n\n  //update the distance if it is lower\n  if(dist < check_cell->target_dist) {\n    check_cell->target_dist = dist;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 66.28336123048359}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  // initialize the cost and scaling factor\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if( !initialized_ ) {\n    initialize();\n  }\n  if( !footprint_spec_ || footprint_spec_->polygons.empty() ) {\n    ROS_ERROR_NAMED(\"trajectory_planner\", \"No footprint specification was given to the ObstacleCostFunction\");\n    return -9;\n  }\n  // if the footprint is not being used, return 0\n  if( !use_footprint_ ) {\n    return 0;\n  }\n\n  // check the size of the trajectory\n  if( traj.sizePoses() < 2 ) {\n    return 0;\n  }\n\n  // check the size of the footprint\n  if( footprint_spec_->polygons.front().points.size() < 3 ) {\n    ROS_ERROR_NAMED(\"trajectory_planner\", \"The footprint must have at least 3 points\");\n    return -9;\n  }\n\n  // get the trajectory point distance\n  double point_dist = traj.getPose(1).position.x - traj.getPose(0).position.x;\n\n  // get the trajectory point distance\n  double point_dist = traj.getPose(1).position.x - traj.getPose(0).position.x;\n\n  // check if the trajectory is going backwards\n  bool going_backwards = false;\n  if( point_dist < 0 ) {\n    going_backwards = true;\n  }\n\n  // iterate over the trajectory\n  for( unsigned int i = 0; i < traj.sizePoses(); ++i ) {\n    // get the pose of the robot\n    const PoseSE2& robot_pose = traj.getPose(i);\n\n    // check if the footprint is outside the bounds of the costmap\n    if( !costmap_->getRobotFootprint(robot_pose, *footprint_spec_, footprint_) ) {\n      ROS_ERROR_NAMED(\"", "CodeBleu_score": 40.18086583322314}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t    // initialize the cost and scaling factor\n    double cost = 0.0;\n    double scaling_factor = 1.0;\n    initCost(traj, cost, scaling_factor);\n\n    // if the footprint is empty, log an error and return -9\n    if (footprint_spec_.footprint.empty()) {\n        ROS_ERROR(\"The footprint is empty, please check the footprint specification.\");\n        return -9;\n    }\n\n    // for each point in the trajectory, calculate the footprint cost\n    for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n        double footprint_cost = calculateFootprintCost(traj, i);\n\n        // if the footprint cost is negative, return the cost immediately\n        if (footprint_cost < 0) {\n            return footprint_cost;\n        }\n\n        // otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n        if (sum_scores_) {\n            cost += footprint_cost;\n        } else {\n            cost = std::max(cost, footprint_cost);\n        }\n    }\n\n    // return the total cost\n    return cost;\n}", "CodeBleu_score": 54.85193768417359}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  // initialize cost and scaling factor\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double max_cost = 0.0;\n  double max_scaling_factor = 1.0;\n  double min_cost = std::numeric_limits<double>::max();\n  double min_scaling_factor = 1.0;\n\n  // check if the footprint is empty\n  if (footprint_spec_.polygon.points.empty()) {\n    ROS_ERROR(\"The footprint is empty, cannot score trajectory\");\n    return -9;\n  }\n\n  // calculate the cost for each point in the trajectory\n  for (size_t i = 0; i < traj.getPointsSize(); ++i) {\n    // get the cost and scaling factor for the footprint\n    double cost_i, scaling_factor_i;\n    footprintCost(traj.getPoint(i), cost_i, scaling_factor_i);\n\n    // if the cost is negative, we can return immediately\n    if (cost_i < 0) {\n      return cost_i;\n    }\n\n    // otherwise, we sum the costs and scaling factors\n    if (sum_scores_) {\n      cost += cost_i;\n      scaling_factor += scaling_factor_i;\n    } else {\n      if (cost_i > max_cost) {\n        max_cost = cost_i;\n        max_scaling_factor = scaling_factor_i;\n      }\n      if (cost_i < min_cost) {\n        min_cost = cost_i;\n        min_scaling_factor = scaling_factor_i;\n      }\n    }\n  }\n\n  // if we're summing the scores, we can return the sum\n  if (sum_scores_) {\n    return cost / scaling_factor;\n  }\n\n  // otherwise, we return the max cost\n  return max_cost / max_scaling_factor;\n}", "CodeBleu_score": 53.18723043413098}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t    // scale the footprint\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        footprint_spec[i].x *= scale;\n        footprint_spec[i].y *= scale;\n    }\n\n    // check if the footprint is legal\n    if (!world_model->footprintCost(x, y, th, footprint_spec, costmap)) {\n        ROS_DEBUG_NAMED(\"ObstacleCostFunction\", \"Footprint at (%.2f, %.2f) is illegal\", x, y);\n        return -6.0;\n    }\n\n    // check if the footprint is outside the costmap bounds\n    if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n        ROS_DEBUG_NAMED(\"ObstacleCostFunction\", \"Footprint at (%.2f, %.2f) is outside the costmap\", x, y);\n        return -7.0;\n    }\n\n    // get the footprint cost\n    double footprint_cost = 0.0;\n    world_model->footprintCost(x, y, th, footprint_spec, costmap, footprint_cost);\n\n    // get the cost of the cell the robot is in\n    unsigned char cost = costmap->getCost(cell_x, cell_y);\n\n    // return the maximum cost\n    return std::max(footprint_cost, cost);\n}", "CodeBleu_score": 57.38117909780138}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // scale the footprint\n    for (unsigned int i=0; i<footprint_spec.size(); ++i) {\n        footprint_spec[i].x *= scale;\n        footprint_spec[i].y *= scale;\n    }\n\n    // rotate the footprint into the frame of the costmap\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    for (unsigned int i=0; i<footprint_spec.size(); ++i) {\n        geometry_msgs::Point pt;\n        pt.x = x + (footprint_spec[i].x * cos(th) - footprint_spec[i].y * sin(th));\n        pt.y = y + (footprint_spec[i].x * sin(th) + footprint_spec[i].y * cos(th));\n        oriented_footprint.push_back(pt);\n    }\n\n    // check if any of the points are off the map\n    for (unsigned int i=0; i<oriented_footprint.size(); ++i) {\n        unsigned int mx, my;\n        if (!costmap->worldToMap(oriented_footprint[i].x, oriented_footprint[i].y, mx, my)) {\n            return -7.0;\n        }\n    }\n\n    // get the cost of the footprint\n    double footprint_cost = world_model->footprintCost(oriented_footprint, costmap);\n\n    // get the cost of the cell\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0;\n    }\n    unsigned char cost = costmap->getCost(mx, my);\n\n    // return the cost\n    if (footprint_cost < 0) {\n        return -6.0;\n    } else {\n        return std::max(cost, footprint_cost);\n    }\n}", "CodeBleu_score": 60.870385010993914}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    // Check if the footprint is outside the costmap\n    if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n        ROS_WARN_STREAM(\"Robot footprint is off the costmap\");\n        return -7.0;\n    }\n\n    // Scale the footprint\n    for (size_t i = 0; i < footprint_spec.size(); i++) {\n        footprint_spec[i].x *= scale;\n        footprint_spec[i].y *= scale;\n    }\n\n    // Calculate the footprint cost\n    double footprint_cost = world_model->footprintCost(\n        x, y, th, footprint_spec, costmap);\n\n    // If the footprint cost is negative, return -6.0\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    }\n\n    // Get the cost at the given position\n    unsigned char cost = costmap->getCost(cell_x, cell_y);\n\n    // If the cost is unknown, return -1.0\n    if (cost == costmap_2d::NO_INFORMATION) {\n        return -1.0;\n    }\n\n    // Return the maximum cost between the footprint cost and the cell cost\n    return std::max(footprint_cost, static_cast<double>(cost));\n}", "CodeBleu_score": 59.52588410480878}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic_ != odom_topic) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.90579232493761}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if(odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if(!odom_topic.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 46.94669441839411}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.90579232493761}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float x_diff = pos[0] - prev[0];\n  float y_diff = pos[1] - prev[1];\n  float dist_sq = x_diff*x_diff + y_diff*y_diff;\n  float angle_diff = std::atan2(y_diff, x_diff) - prev_angle_;\n\n  //reset oscillation flags if we're far enough from the last position or the angle is large enough\n  if(dist_sq > oscillation_reset_dist_squared_ || std::fabs(angle_diff) > oscillation_reset_angle_) {\n    oscillating_ = false;\n    oscillation_reset_counter_ = 0;\n  }\n}", "CodeBleu_score": 60.036356882420215}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float dist_sq = (pos - prev).squaredNorm();\n  float angle = std::acos(pos.normalized().dot(prev.normalized()));\n  if (dist_sq > oscillation_reset_dist_squared_ || angle > oscillation_reset_angle_) {\n    oscillation_reset_counter_ = 0;\n    oscillation_reset_dist_squared_ = 0;\n    oscillation_reset_angle_ = 0;\n  }\n}", "CodeBleu_score": 38.442033248836914}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float x_diff = pos[0] - prev[0];\n  float y_diff = pos[1] - prev[1];\n  float sq_dist = x_diff * x_diff + y_diff * y_diff;\n  float angle_diff = atan2(y_diff, x_diff) - prev_angle_;\n  // normalize angle_diff to [-pi, pi]\n  angle_diff = fmod(angle_diff + M_PI, 2 * M_PI);\n  if (angle_diff > M_PI)\n    angle_diff -= 2 * M_PI;\n\n  if (sq_dist > oscillation_reset_dist_squared_ || fabs(angle_diff) > oscillation_reset_angle_) {\n    oscillation_reset_counter_ = 0;\n    oscillation_reset_dist_squared_ = 0.0;\n    oscillation_reset_angle_ = 0.0;\n    prev_angle_ = atan2(y_diff, x_diff);\n  }\n}", "CodeBleu_score": 64.24001344548095}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // find the grid cell coordinates of the point\n  int x, y;\n  if (!findCellCoordinates(pt, x, y))\n    return;\n\n  // find the grid cell index\n  int idx = findCellIndex(x, y);\n\n  // insert the point into the cell\n  insert(pt, idx);\n}", "CodeBleu_score": 39.64618963824115}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\n  // check if point is within the grid bounds\n  if (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_) {\n    return;\n  }\n\n  // check if point is too close to its nearest neighbor\n  // if it is, then ignore it\n  // TODO: this is a bit of a hack, but it's the easiest way to avoid\n  // inserting points too close together\n  // TODO: this should be made a parameter\n  if (tooClose(pt)) {\n    return;\n  }\n\n  // calculate the grid coordinates of the point\n  int x_cell = (int)((pt.x - min_x_) / cell_size_);\n  int y_cell = (int)((pt.y - min_y_) / cell_size_);\n\n  // calculate the index of the cell\n  int index = x_cell * num_y_cells_ + y_cell;\n\n  // insert the point into the cell\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 41.69562822523136}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // get grid coordinates\n  int x, y;\n  if (!getGridCoords(pt, x, y)) {\n    return;\n  }\n\n  // check if point is too close to its nearest neighbor\n  if (isNearNeighbor(pt, x, y)) {\n    return;\n  }\n\n  // get grid index\n  int idx = getGridIndex(x, y);\n\n  // insert point into cell\n  cells_[idx].push_back(pt);\n}", "CodeBleu_score": 55.06818808407662}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n  Eigen::Vector3f new_vel = vel;\n\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 80.47137421347077}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 78.51011259106136}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel(0.0, 0.0, 0.0);\n\n  // For each component of the velocity vector, increase or decrease the current velocity towards the target velocity within the acceleration limits.\n  for (int i = 0; i < 3; ++i) {\n    // Calculate the velocity change in this component.\n    double vel_change = sample_target_vel[i] - vel[i];\n\n    // If the velocity change is positive, increase the current velocity by the acceleration limit.\n    if (vel_change > 0.0) {\n      new_vel[i] = vel[i] + std::min(acclimits[i], vel_change);\n    }\n    // If the velocity change is negative, decrease the current velocity by the acceleration limit.\n    else if (vel_change < 0.0) {\n      new_vel[i] = vel[i] + std::max(-acclimits[i], vel_change);\n    }\n    // If the velocity change is zero, the current velocity is fine.\n    else {\n      new_vel[i] = vel[i];\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 59.03839490607571}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t    double diff = DBL_MAX;\n\n    // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n    for (int i = (int)global_plan_.size() - 1; i >= 0; i--) {\n        double dx = global_plan_[i].pose.position.x - x;\n        double dy = global_plan_[i].pose.position.y - y;\n\n        // If the distance between the robot and the current point is greater than the costmap's minimum clearance, check to see if the robot has a clear line of sight to the point\n        if (sqrt(dx * dx + dy * dy) > costmap_->getMinClearance()) {\n            // If the robot's current cell is in the same grid as the current point, it has a clear line of sight to the point\n            if (costmap_->getIndex(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y) == costmap_->getIndex(cell_x, cell_y)) {\n                // Convert the goal cell coordinates to world coordinates and return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n                diff = fabs(angles::normalize_angle(atan2(dy, dx) - heading));\n                break;\n            }\n        }\n    }\n\n    return diff;\n}", "CodeBleu_score": 51.49304557936264}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double angle = DBL_MAX;\n  double path_angle = 0.0;\n  double diff = 0.0;\n  double min_diff = DBL_MAX;\n\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    double gx = global_plan_[i].pose.position.x;\n    double gy = global_plan_[i].pose.position.y;\n    if (world_model_->footprintContains(gx, gy, cell_x, cell_y)) {\n      path_angle = atan2(gy - y, gx - x);\n      diff = angles::shortest_angular_distance(heading, path_angle);\n      if (diff < min_diff) {\n        min_diff = diff;\n        angle = path_angle;\n      }\n    }\n  }\n\n  return angle;\n}", "CodeBleu_score": 58.99715252848249}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\n    //get the angle of the robot's current position\n    double angle = angles::normalize_angle(heading);\n\n    //get the angle of the robot's current position\n    double angle_to_goal = angles::normalize_angle(atan2(y - cell_y, x - cell_x));\n\n    //get the angle of the robot's current position\n    double angle_diff = angles::normalize_angle(angle_to_goal - angle);\n\n    //return the shortest distance between the current angle and the goal angle\n    return fabs(angle_diff);\n\n}", "CodeBleu_score": 22.81304344403659}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost < 0.0) {\n    ROS_WARN(\"TrajectoryPlanner: cost %f is negative. Trajectory invalid. vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", cost, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 70.11932156729492}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost >= 0.0) {\n    return true;\n  }\n  else {\n    ROS_WARN_NAMED(\"trajectory_planner\",\n                   \"TrajectoryPlanner: checkTrajectory: cost: %f, vx: %f, vy: %f, vtheta: %f\", cost, vx_samp, vy_samp,\n                   vtheta_samp);\n    return false;\n  }\n}", "CodeBleu_score": 71.12697779158886}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost < 0.0) {\n    ROS_WARN(\"TrajectoryPlanner: cost is negative: cost = %f, vx_samp = %f, vy_samp = %f, vtheta_samp = %f\", cost, vx_samp,\n             vy_samp, vtheta_samp);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 73.63469050138411}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointer is null, make sure to call initialize() before runBehavior()\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside of the specified area\");\n  }\n\n  ros::Time start = ros::Time::now();\n  if (affected_maps_ & AFFECT_GLOBAL_COSTMAP) {\n    global_costmap_->clear(area_to_clear_, invert_area_to_clear_);\n  }\n\n  if (affected_maps_ & AFFECT_LOCAL_COSTMAP) {\n    local_costmap_->clear(area_to_clear_, invert_area_to_clear_);\n  }\n\n  if (force_update_) {\n    if (affected_maps_ & AFFECT_GLOBAL_COSTMAP) {\n      global_costmap_->updateMap();\n    }\n\n    if (affected_maps_ & AFFECT_LOCAL_COSTMAP) {\n      local_costmap_->updateMap();\n    }\n  }\n\n  ros::Time end = ros::Time::now();\n  ros::Duration d = end - start;\n  ROS_DEBUG(\"Clearing costmap took %f seconds\", d.toSec());\n}", "CodeBleu_score": 45.978238358973066}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointer is null, you must call setCostmap() before using this planner\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"This planner is configured to clear the costmap outside of the specified area, not inside it. This is not a common use case.\");\n  }\n\n  // If we're clearing the global costmap, we need to lock it, then clear it, then unlock it.\n  if (affected_maps_ & global_costmap_->getMapIndex()) {\n    global_costmap_->getCostmap()->lock();\n    const auto start_time = ros::Time::now();\n    global_costmap_->getCostmap()->clear(clearing_radius_, invert_area_to_clear_);\n    const auto end_time = ros::Time::now();\n    const auto time_taken = (end_time - start_time).toSec();\n    ROS_DEBUG_NAMED(\"clear_costmap_recovery\", \"Clearing the global costmap took %.3f seconds\", time_taken);\n    global_costmap_->getCostmap()->unlock();\n  }\n\n  // If we're clearing the local costmap, we need to lock it, then clear it, then unlock it.\n  if (affected_maps_ & local_costmap_->getMapIndex()) {\n    local_costmap_->getCostmap()->lock();\n    const auto start_time = ros::Time::now();\n    local_costmap_->getCostmap()->clear(clearing_radius_, invert_area_to_clear_);\n    const auto end_time = ros::Time::now();\n    const auto time_taken = (end_time - start_time).toSec();\n    ROS_DEBUG_NAMED(\"clear_costmap_recovery\", \"Clearing the local costmap", "CodeBleu_score": 45.59752885390026}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\n  ROS_INFO(\"ClearCostmapRecovery: Running behavior.\");\n\n  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery: This planner has not been initialized, please call initialize() before runBehavior().\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery: Global costmap pointer is NULL.\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery: Local costmap pointer is NULL.\");\n    return;\n  }\n\n  // Check if we are clearing inside or outside of an area\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"ClearCostmapRecovery: Clearing inside of area to clear.\");\n  } else {\n    ROS_WARN(\"ClearCostmapRecovery: Clearing outside of area to clear.\");\n  }\n\n  // Clear the global costmap\n  if (affected_maps_ & AFFECTED_GLOBAL_COSTMAP) {\n    ros::Time start = ros::Time::now();\n    global_costmap_->clearNonLethal(area_to_clear_, invert_area_to_clear_, force_update_);\n    ros::Time end = ros::Time::now();\n    ROS_INFO(\"ClearCostmapRecovery: Global costmap clearing took %f seconds.\", (end - start).toSec());\n  }\n\n  // Clear the local costmap\n  if (affected_maps_ & AFFECTED_LOCAL_COSTMAP) {\n    ros::Time start = ros::Time::now();\n    local_costmap_->clearNonLethal(area_to_clear_, invert_area_to_clear_, force_update_);\n    ros::Time end = ros::Time::now();\n    ROS_INFO(\"ClearCostmapRecovery: Local costmap clearing took %f seconds.\", (end - start).toSec());\n  }\n\n  // Clear the static costmap\n  if (affected_maps_ & AFFECTED_STATIC_COSTMAP) {\n    ros", "CodeBleu_score": 47.534136756643996}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    polygon_cells.clear();\n    if (polygon.size() < 3)\n        return;\n\n    // Iterate through the polygon vertices\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n    }\n\n    // Close the polygon\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells);\n}", "CodeBleu_score": 45.36179564140285}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells polygon_cells_obj;\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells_obj);\n  }\n\n  if (!polygon.empty()) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells_obj);\n  }\n\n  polygon_cells_obj.getPolygonOutlineCells(polygon_cells);\n}", "CodeBleu_score": 54.91336645805773}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cells;\n  polygonOutlineCells(polygon, cells);\n  polygon_cells = cells.cells_;\n}", "CodeBleu_score": 14.72168184022235}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  //we'll need to prepare the grid data\n  prepareGrid();\n\n  //publish the grid\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  if (publisher_->getNumSubscribers() > 1)\n    return;\n\n  Costmap2D* master = layered_costmap_->getCostmap();\n  unsigned int size_x = master->getSizeInCellsX(), size_y = master->getSizeInCellsY();\n  unsigned char* master_array = master->getCharMap();\n  unsigned int index = 0;\n\n  //copy the costmap into a 1d array\n  for (unsigned int i = 0; i < size_x; ++i) {\n    for (unsigned int j = 0; j < size_y; ++j) {\n      unsigned char cost = *(master_array + master->getIndex(i, j));\n      cost_array_[index] = cost;\n      ++index;\n    }\n  }\n\n  //publish the costmap\n  publisher_->publish(costmap_);\n}", "CodeBleu_score": 45.98503140932836}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // prepare grid\n  prepareGrid();\n\n  // publish grid\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  std::vector<signed char> temp_data;\n  std::vector<unsigned char> temp_data_uchar;\n  std::vector<unsigned char> temp_data_uchar_color;\n\n  bool publish_unknown_space;\n  bool publish_free_space;\n  bool publish_occupied_space;\n  bool publish_color_costmap;\n  bool publish_color_occupied;\n  bool publish_color_free;\n  bool publish_color_unknown;\n  unsigned char unknown_space_cost_value;\n  unsigned char free_space_cost_value;\n  unsigned char occupied_space_cost_value;\n  std::string unknown_space_color;\n  std::string free_space_color;\n  std::string occupied_space_color;\n  std::string unknown_space_color_str;\n  std::string free_space_color_str;\n  std::string occupied_space_color_str;\n  std::string unknown_space_color_str_color;\n  std::string free_space_color_str_color;\n  std::string occupied_space_color_str_color;\n\n  bool publish_voxel_grid;\n  bool publish_voxel_grid_color;\n  unsigned char unknown_space_cost_value_voxel;\n  unsigned char free_space_cost_value_voxel;\n  unsigned char occupied_space_cost_value_voxel;\n  std::string unknown_space_color_voxel;\n  std::string free_space_color_voxel;\n  std::string occupied_space_color_voxel;\n  std::string unknown_space_color_str_voxel;\n  std::string free_space_color_str_voxel;\n  std::string occupied_space_color_str_voxel;\n  std::string unknown_space_color_str_color_voxel;\n  std::string free_space_color_str_color_voxel;\n  std::string occupied_space_color_str_color_voxel;\n\n  bool publish_voxel_grid_markers;\n  bool publish_vox", "CodeBleu_score": 4.623426173313747}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t    //lock the costmap mutex\n    boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n    //get the current resolution\n    double resolution = costmap_->getResolution();\n\n    //update the grid's header\n    grid_.header.stamp = ros::Time::now();\n    grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n    //update the grid's size\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    //update the grid's origin\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    //save the origin coordinates\n    origin_x_ = grid_.info.origin.position.x;\n    origin_y_ = grid_.info.origin.position.y;\n\n    //resize the grid's data\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    //populate the grid data\n    unsigned int index = 0;\n    for(unsigned int i = 0; i < grid_.info.height; ++i){\n        for(unsigned int j = 0; j < grid_.info.width; ++j){\n            unsigned char cost = costmap_->getCost(j, i);\n            grid_.data[index] = cost;\n            ++index;\n        }\n    }\n}", "CodeBleu_score": 65.08716786802675}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double originX = costmap_->getOriginX(), originY = costmap_->getOriginY();\n  double wx, wy;\n  costmap_->mapToWorld(originX, originY, wx, wy);\n\n  // Set the origin's position and orientation\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  originX_ = originX;\n  originY_ = originY;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = costTranslationTable_[costmap_->getCharMap()[i]];\n  }\n}", "CodeBleu_score": 70.86217341477851}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    geometry_msgs::PolygonStamped new_footprint;\n    try {\n      new_footprint = parseFootprint(new_config.footprint);\n    } catch (std::runtime_error &ex) {\n      ROS_ERROR_NAMED(\"costmap\", \"Invalid robot footprint: %s\", ex.what());\n      return;\n    }\n\n    if (new_footprint.polygon.points.empty()) {\n      ROS_ERROR_NAMED(\"costmap\", \"Invalid robot footprint: no points\");\n      return;\n    }\n\n    footprint_clearing_enabled_ = true;\n    footprint_ = new_footprint;\n    return;\n  }\n\n  if (new_config.robot_radius > 0.0) {\n    footprint_clearing_enabled_ = true;\n    footprint_ = makeFootprintFromRadius(new_config.robot_radius);\n    return;\n  }\n\n  ROS_ERROR_NAMED(\"costmap\", \"No robot footprint or radius specified.\");\n}", "CodeBleu_score": 58.41606522214753}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n        return;\n    }\n    if (new_config.footprint.size() > 0) {\n        std::vector<geometry_msgs::Point> footprint;\n        try {\n            footprint = parseFootprint(new_config.footprint);\n        } catch (std::runtime_error &ex) {\n            ROS_ERROR(\"Invalid footprint: %s\", ex.what());\n            return;\n        }\n        std::transform(footprint.begin(), footprint.end(), footprint.begin(), tf2::toMsg);\n        costmap_->setFootprint(footprint);\n    } else {\n        costmap_->setFootprint(new_config.robot_radius);\n    }\n}", "CodeBleu_score": 63.333787086012116}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t    if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n        return;\n\n    std::vector<geometry_msgs::Point> footprint;\n    if (new_config.footprint.size() > 0) {\n        try {\n            footprint = parseFootprint(new_config.footprint);\n        } catch (std::runtime_error &e) {\n            ROS_ERROR(\"Invalid footprint string: %s\", e.what());\n            return;\n        }\n    } else {\n        footprint.push_back(geometry_msgs::Point());\n        footprint[0].x = 0.0;\n        footprint[0].y = 0.0;\n        footprint[0].z = 0.0;\n    }\n    costmap_->setFootprint(footprint, new_config.robot_radius);\n}", "CodeBleu_score": 60.37053036032376}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n    geometry_msgs::PoseStamped new_pose;\n\n    try {\n        if (!getRobotPose(new_pose)) {\n            ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n            return;\n        }\n    }\n    catch (tf::TransformException &ex) {\n        ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration: %s\", ex.what());\n        return;\n    }\n\n    /*\n     * If the new pose is the same as the old pose, then the robot has not moved.\n     */\n    if (new_pose.pose.position.x == old_pose_.pose.position.x &&\n        new_pose.pose.position.y == old_pose_.pose.position.y &&\n        new_pose.pose.orientation.x == old_pose_.pose.orientation.x &&\n        new_pose.pose.orientation.y == old_pose_.pose.orientation.y &&\n        new_pose.pose.orientation.z == old_pose_.pose.orientation.z &&\n        new_pose.pose.orientation.w == old_pose_.pose.orientation.w) {\n        return;\n    }\n\n    /*\n     * If the new pose is different from the old pose, then the robot has moved.\n     */\n    else {\n        /*\n         * Store the new pose in old_pose_.\n         */\n        old_pose_ = new_pose;\n\n        /*\n         * Update the costmap.\n         */\n        updateMap(new_pose.pose, true);\n    }\n}", "CodeBleu_score": 54.73582954243557}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  if (getRobotPose(new_pose, global_frame_)) {\n    reconfigure();\n  } else {\n    ROS_WARN(\"Could not get robot pose for reconfiguration, canceling reconfiguration.\");\n  }\n}", "CodeBleu_score": 28.078821381809565}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  if (enabled_) {\n    geometry_msgs::PoseStamped new_pose;\n    if (!getRobotPose(new_pose)) {\n      ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n      return;\n    }\n\n    /*\n     * If the robot has moved more than the threshold, we'll update the map\n     */\n    if (std::sqrt(std::pow(new_pose.pose.position.x - old_pose_.pose.position.x, 2) +\n                  std::pow(new_pose.pose.position.y - old_pose_.pose.position.y, 2)) >\n        reconfigure_threshold_) {\n      reconfigure();\n      old_pose_ = new_pose;\n    }\n  }\n}", "CodeBleu_score": 62.397508898667866}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t    std::vector<std::string> plugins = planner_->getPlugins();\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n        if (layered_costmap_->isStopped(plugins[i])) {\n            layered_costmap_->reactivePlugin(plugins[i]);\n            layered_costmap_->setStopped(plugins[i], false);\n        }\n    }\n    stop_updates_ = false;\n    while (!ros::ok() || !layered_costmap_->isInitialized() || !map_update_thread_->isActive()) {\n        ros::Duration(0.1).sleep();\n    }\n}", "CodeBleu_score": 47.134295192647166}, {"code": "void Costmap2DROS::start(){\n\t\n  // Retrieve the list of plugins and check if the costmap was stopped.\n  std::vector<layered_costmap_->getPlugins()> plugins = layered_costmap_->getPlugins();\n\n  // If stopped, re-subscribe to topics by activating each plugin.\n  if (stopped_) {\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      plugins[i]->activate();\n    }\n    stopped_ = false;\n  }\n\n  // Set stop_updates_ to false.\n  stop_updates_ = false;\n\n  // Wait until ROS is running, the costmap is initialized, and the map update thread is active.\n  while (!isRunning() && !layered_costmap_->isInitialized() && !layered_costmap_->isMapUpdateThreadActive()) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 54.1104291190646}, {"code": "void Costmap2DROS::start(){\n\t\n  std::vector<std::string> plugins = getPluginNames();\n\n  for (unsigned int i = 0; i < plugins.size(); ++i) {\n    std::string plugin = plugins[i];\n    if (layered_costmap_->isPluginStopped(plugin)) {\n      layered_costmap_->activatePlugin(plugin);\n      layered_costmap_->setStopped(plugin, false);\n    }\n  }\n\n  stop_updates_ = false;\n\n  while (!is_running_) {\n    ros::Duration(0.01).sleep();\n  }\n\n  while (!layered_costmap_->isMapInitialized()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  while (!map_update_thread_active_) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 50.295492151876886}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  // if we're keeping observations indefinitely, we don't have to do anything\n  if (observation_keep_time_ == ros::Duration(0.0))\n    return;\n\n  // if we have a recent observation, we don't have to do anything\n  if (observations_.size() > 0 && (ros::Time::now() - observations_.back().header.stamp) < observation_keep_time_)\n    return;\n\n  // otherwise, we have to remove observations until we find a recent one\n  while (observations_.size() > 0 && (ros::Time::now() - observations_.front().header.stamp) > observation_keep_time_) {\n    observations_.pop_front();\n  }\n}", "CodeBleu_score": 35.53344506646092}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    // only keep most recent observation\n    if (observations_.size() > 1) {\n      observations_.erase(observations_.begin(), observations_.end() - 1);\n    }\n    return;\n  }\n\n  // remove observations that are older than the keep time\n  ros::Time latest_allowed_time = ros::Time::now() - observation_keep_time_;\n  while (!observations_.empty() && observations_.front().header.stamp < latest_allowed_time) {\n    observations_.pop_front();\n  }\n}", "CodeBleu_score": 40.37747166373119}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    // only keep the most recent observation\n    while (observations_.size() > 1) {\n      observations_.pop_front();\n    }\n  } else {\n    // remove observations that are older than the specified keep time\n    ros::Time now = ros::Time::now();\n    while (observations_.size() > 1 && now - observations_.front().second > observation_keep_time_) {\n      observations_.pop_front();\n    }\n  }\n}", "CodeBleu_score": 33.81883389449036}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // Compute the yaw angle at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Compute the shortest angular distance between the start and end indices\n    double shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Compute the incremental change in angle for each pose\n    double incremental_change_in_angle = shortest_angular_distance / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index + 1; i < end_index; i++) {\n        double current_yaw = tf2::getYaw(path[i].pose.orientation);\n        double new_yaw = current_yaw + incremental_change_in_angle;\n        path[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), new_yaw));\n    }\n}", "CodeBleu_score": 60.28999255586614}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n  // Get the yaw angles of the start and end poses\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end poses\n  double delta = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Determine the incremental change in angle for each pose\n  double increment = delta / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    start_yaw += increment;\n    tf2::Quaternion q;\n    q.setRPY(0, 0, start_yaw);\n    path[i].pose.orientation = tf2::toMsg(q);\n  }\n}", "CodeBleu_score": 66.38838074572132}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    // Get the yaw angle of the start and end poses\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Compute the shortest angular distance between the start and end yaw angles\n    double yaw_increment = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Compute the incremental change in yaw angle for each pose in the path\n    double yaw_increment_step = yaw_increment / (end_index - start_index);\n\n    // Update the orientation of each pose in the path\n    for (int i = start_index; i < end_index; i++) {\n        // Get the current yaw angle of the pose\n        double current_yaw = tf2::getYaw(path[i].pose.orientation);\n\n        // Compute the new yaw angle of the pose\n        double new_yaw = current_yaw + yaw_increment_step;\n\n        // Update the yaw angle of the pose\n        path[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), new_yaw));\n    }\n}", "CodeBleu_score": 61.91953017571863}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    ROS_DEBUG(\"Got a request to make a plan from (%f, %f) to (%f, %f)\", req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y);\n    tf2::toMsg(this->global_frame_, req.start.header.frame_id);\n    tf2::toMsg(this->global_frame_, req.goal.header.frame_id);\n    req.start.pose.orientation.w = 1.0;\n    req.goal.pose.orientation.w = 1.0;\n    resp.plan.header.stamp = ros::Time::now();\n    tf2::toMsg(this->global_frame_, resp.plan.header.frame_id);\n    resp.plan.poses.resize(1);\n    resp.plan.poses[0] = req.start;\n\n    bool success = makePlan(req.start, req.goal, resp.plan);\n\n    resp.plan.poses.resize(resp.plan.poses.size() - 1);\n\n    return success;\n}", "CodeBleu_score": 45.09969462797746}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan_found = success;\n  resp.path = path;\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 76.75793603850659}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n\t//Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t//Call makePlan to generate a path\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tbool success = makePlan(req.start, req.goal, path);\n\n\t//Update the response with the success status and the generated path if a plan is found\n\tresp.plan_found = success;\n\tif(success) {\n\t\tresp.path = path;\n\t}\n\n\t//Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 82.72781591719725}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    tf_ = boost::make_shared<tf2_ros::Buffer>();\n    tf_listener_ = boost::make_shared<tf2_ros::TransformListener>(*tf_);\n}", "CodeBleu_score": 61.3092001494445}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~/\" + name);\n    ros::NodeHandle nh;\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = nh.subscribe(\"move_base_simple/goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 62.08378594798765}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    tf_ = boost::make_shared<tf2_ros::Buffer>();\n    tf_listener_ = boost::make_shared<tf2_ros::TransformListener>(*tf_);\n}", "CodeBleu_score": 61.3092001494445}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    // check if the world coordinate is within the bounds of the costmap\n    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n        return false;\n    }\n\n    // convert from world to map coordinates\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    // check if the map coordinate is within the bounds of the costmap\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 51.76228357611768}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\n    // Check if the world coordinates are within the bounds of the costmap's origin\n    if (wx < originX || wy < originY) {\n        ROS_WARN(\"[GlobalPlanner::worldToMap] World coordinates are outside the bounds of the costmap's origin.\");\n        return false;\n    }\n\n    // Calculate the map coordinates using the costmap's resolution and an offset\n    mx = (wx - originX) / resolution;\n    my = (wy - originY) / resolution;\n\n    // Check if the map coordinates are within the costmap's size limits\n    if (mx < 0 || my < 0 || mx > sizeX || my > sizeY) {\n        ROS_WARN(\"[GlobalPlanner::worldToMap] Map coordinates are outside the bounds of the costmap.\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 45.54648675454737}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\n    // Check if the world coordinates are within the bounds of the costmap's origin\n    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n        ROS_WARN(\"[GlobalPlanner::worldToMap] world coordinates are outside the bounds of the costmap's origin\");\n        return false;\n    }\n\n    // Calculate the map coordinates using the costmap's resolution and an offset\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    // Check if the map coordinates are within the costmap's size limits\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n        return true;\n    }\n    else {\n        ROS_WARN(\"[GlobalPlanner::worldToMap] map coordinates are outside the bounds of the costmap\");\n        return false;\n    }\n}", "CodeBleu_score": 50.32917985827338}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a path message\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 97.07520516691747}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\n    if(!initialized_)  {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for(unsigned int i = 0; i < path.size(); i++)  {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 93.37288390496124}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path plan;\n  plan.poses.resize(path.size());\n\n  //copy over the plan\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    plan.poses[i] = path[i];\n  }\n\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n\n  plan_pub_.publish(plan);\n}", "CodeBleu_score": 83.61347253772095}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in action message and publishing.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 79.70915976981901}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.74901562488363}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\n  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal in PoseStamped form\");\n\n  move_base_msgs::MoveBaseActionGoal action_goal;\n\n  action_goal.header.stamp = ros::Time::now();\n\n  action_goal.goal.target_pose = *goal;\n\n  action_goal_pub_.publish(action_goal);\n\n}", "CodeBleu_score": 77.03984833757754}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    double x_dist = robot_x_ - x_start_;\n    double y_dist = robot_y_ - y_start_;\n    double dist = x_dist * x_dist + y_dist * y_dist;\n\n    if (dist >= dist_limit_ * dist_limit_) {\n        ROS_INFO(\"Moved far enough, removing speed limit\");\n        distance_check_timer_.stop();\n        if (remove_limit_thread_ != NULL) {\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n        }\n        remove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeLimit, this);\n    }\n}", "CodeBleu_score": 64.37181442141608}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\n    // Check if the robot has moved far enough.\n    if (distance_squared_ >= limited_distance_squared_) {\n        ROS_INFO_STREAM(\"Moved far enough. Removing speed limit.\");\n\n        // Join and delete any existing remove limit thread.\n        if (remove_limit_thread_ != nullptr) {\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n        }\n\n        // Start a new thread to remove the speed limit.\n        remove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeLimit, this);\n\n        // Stop the distance check timer.\n        distance_check_timer_.stop();\n    }\n}", "CodeBleu_score": 53.10393035204826}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    if (distance_limit_sq_ > 0.0 && (distance_limit_sq_ <= (robot_pose_.x - last_pose_.x) * (robot_pose_.x - last_pose_.x) + (robot_pose_.y - last_pose_.y) * (robot_pose_.y - last_pose_.y))) {\n        ROS_INFO(\"[move_slow_and_clear]: The robot has moved far enough. Removing speed limit.\");\n        distance_limit_timer_.stop();\n        distance_limit_sq_ = 0.0;\n        if (remove_limit_thread_) {\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n        }\n        remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    }\n}", "CodeBleu_score": 69.15409091909875}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\n\t//get the global pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = getRobotPose();\n\n\t//generate a path from the global pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(global_pose, *goal, path);\n\n\t//publish the path for visualization purposes\n\tpublishPlan(path);\n\n}", "CodeBleu_score": 60.81472346881813}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    goal_pose_ = *goal;\n    makePlan(goal_pose_.pose, goal_pose_.pose, path_);\n}", "CodeBleu_score": 36.308554187444706}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  if (!initialized_)\n    return;\n\n  // get the global pose of the robot\n  tf::Stamped<tf::Pose> global_pose;\n  costmap_ros_->getRobotPose(global_pose);\n\n  // convert the goal to a Pose2D and compute a plan to it\n  tf::Stamped<tf::Pose> goal_pose;\n  tf::poseStampedMsgToTF(*goal, goal_pose);\n  geometry_msgs::PoseStamped goal_pose_in;\n  tf::poseStampedTFToMsg(goal_pose, goal_pose_in);\n  std::vector<geometry_msgs::PoseStamped> plan;\n  makePlan(global_pose, goal_pose_in, plan);\n\n  // publish the plan for visualization purposes\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(plan.size());\n\n  for (unsigned int i = 0; i < plan.size(); ++i) {\n    gui_path.poses[i] = plan[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 46.86640747355724}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create the request\n    mavros_msgs::ParamSet request;\n    request.param_id = param_set.param_id;\n    request.value.real = param_set.value;\n\n    // Call the service\n    param_set_client_.call(request);\n}", "CodeBleu_score": 62.118235140651294}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a new request\n    mavros_msgs::ParamSet request;\n\n    // Assign the parameter ID and value\n    request.param_id = param_set.param_id;\n    request.value.real = param_set.value;\n\n    // Call the service\n    param_set_client_.call(request);\n}", "CodeBleu_score": 62.118235140651294}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n  // Create a new request\n  mavros_msgs::ParamSet request;\n\n  // Assign the parameter ID and value to the request\n  request.param_id = param_set.param_id;\n  request.value.real = param_set.value;\n\n  // Call the service\n  param_set_client_.call(request);\n}", "CodeBleu_score": 60.802844659051814}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\n    // Initialize the server socket\n    boost::asio::io_service io_service;\n    tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v4(), port));\n\n    // Loop to accept incoming connections\n    while (true) {\n        boost::shared_ptr<tcp::socket> socket(new tcp::socket(io_service));\n        acceptor.accept(*socket);\n\n        // Receive the message from the client\n        boost::system::error_code error;\n        size_t length = socket->read_some(boost::asio::buffer(data, max_length), error);\n\n        if (error && error != boost::asio::error::message_size) {\n            throw boost::system::system_error(error);\n        }\n\n        // If the message length is zero or less, log an error and close the socket\n        if (length <= 0) {\n            std::cout << \"Error: Received message length is zero or less\" << std::endl;\n            socket->close();\n            continue;\n        }\n\n        // Decode the message and publish it\n        std::string message(data, length);\n        std::cout << \"Received message: \" << message << std::endl;\n        publish(message);\n\n        // Close the socket\n        socket->close();\n    }\n}", "CodeBleu_score": 42.26452492205649}, {"code": "void CommunicationBridge::serverFun(){\n\t    // 1. Create a socket\n    int server_socket_fd;\n    if ((server_socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"CommunicationBridge::serverFun: Failed to create a socket.\" << std::endl;\n        return;\n    }\n\n    // 2. Bind the socket to a port\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_address.sin_port = htons(this->server_port);\n    if (bind(server_socket_fd, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) {\n        std::cerr << \"CommunicationBridge::serverFun: Failed to bind the socket to a port.\" << std::endl;\n        return;\n    }\n\n    // 3. Listen for connections\n    if (listen(server_socket_fd, 10) < 0) {\n        std::cerr << \"CommunicationBridge::serverFun: Failed to listen for connections.\" << std::endl;\n        return;\n    }\n\n    // 4. Accept connections and receive data\n    int client_socket_fd;\n    struct sockaddr_in client_address;\n    socklen_t client_address_length = sizeof(client_address);\n    while (true) {\n        if ((client_socket_fd = accept(server_socket_fd, (struct sockaddr *)&client_address, &client_address_length)) < 0) {\n            std::cerr << \"CommunicationBridge::serverFun: Failed to accept a connection.\" << std::endl;\n            return;\n        }\n\n        char message[1000];\n        int message_length = recv(client_socket_fd, message, 1000, 0);\n        if (message_length > 0) {\n            std::string message_str(message, message_length);\n            std::cout", "CodeBleu_score": 45.00479416106327}, {"code": "void CommunicationBridge::serverFun(){\n\t    boost::asio::io_service io_service;\n    tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v4(), port));\n\n    while (true) {\n        std::shared_ptr<tcp::socket> socket(new tcp::socket(io_service));\n        acceptor.accept(*socket);\n\n        std::string message;\n        boost::system::error_code error;\n        size_t length = socket->read_some(boost::asio::buffer(data_, max_length), error);\n\n        if (error && error != boost::asio::error::message_size)\n            throw boost::system::system_error(error);\n\n        if (length > 0) {\n            message = std::string(data_, length);\n            std::cout << \"Received: \" << message << std::endl;\n            processMessage(message);\n        } else {\n            std::cout << \"Error: \" << error.message() << std::endl;\n            socket->close();\n        }\n    }\n}", "CodeBleu_score": 43.58454888159865}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    // Publish the command to the UAV\n    if (uav_cmd.uav_id == 0) {\n        uav_basic_.publishCommand(uav_cmd);\n    }\n    else {\n        swarm_control_simulation_.publishCommand(uav_cmd);\n    }\n}", "CodeBleu_score": 20.3188373144711}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!simulation_mode_) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\tboost::unique_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n\t\tfor (auto & uav : swarm_control_simulation_) {\n\t\t\tif (uav.second.id == uav_cmd.uav_id) {\n\t\t\t\tuav.second.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.90088325920392}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    //ROS_INFO(\"recvData: %d\", uav_cmd.uav_id);\n    if (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    } else {\n        boost::shared_lock<boost::shared_mutex> lock(swarm_control_simulation_mutex_);\n        if (swarm_control_simulation_.find(uav_cmd.uav_id) != swarm_control_simulation_.end()) {\n            swarm_control_simulation_[uav_cmd.uav_id]->publish(uav_cmd);\n        } else {\n            ROS_ERROR(\"recvData: Could not find UAV with ID %d\", uav_cmd.uav_id);\n        }\n    }\n}", "CodeBleu_score": 42.69011997640481}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    // If we are switching to a mode that is not the current mode, we need to handle that\n    if (mode_selection.use_mode != current_mode) {\n        // If we are switching to a mode that is not the current mode, we need to handle that\n        if (mode_selection.use_mode != current_mode) {\n            // If the current mode is not NONE, we need to delete it\n            if (current_mode != Mode::NONE) {\n                deleteMode(current_mode);\n            }\n\n            // If the new mode is not NONE, we need to create it\n            if (mode_selection.use_mode != Mode::NONE) {\n                createMode(mode_selection.use_mode);\n            }\n\n            // Set the current mode to the new mode\n            current_mode = mode_selection.use_mode;\n        }\n    }\n\n    // If we are in REBOOTNX mode, we need to reboot the system\n    if (mode_selection.use_mode == Mode::REBOOTNX) {\n        // Reboot the system\n        system(\"sudo reboot\");\n    }\n\n    // If we are in EXITNX mode, we need to exit the program\n    if (mode_selection.use_mode == Mode::EXITNX) {\n        // Exit the program\n        exit(0);\n    }\n}", "CodeBleu_score": 57.704407898676145}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\n\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse {\n\t\tdeleteMode(mode_selection);\n\t}\n\n}", "CodeBleu_score": 31.2957795196046}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch(mode_selection.use_mode) {\n        case ModeSelection::USE_MODE::REBOOTNX:\n            system(\"sudo /opt/retropie/supplementary/runcommand/runcommand.sh reboot\");\n            break;\n        case ModeSelection::USE_MODE::EXITNX:\n            system(\"sudo /opt/retropie/supplementary/runcommand/runcommand.sh exit\");\n            break;\n        case ModeSelection::USE_MODE::CREATE_MODE:\n            createMode(mode_selection.mode_name);\n            break;\n        case ModeSelection::USE_MODE::DELETE_MODE:\n            deleteMode(mode_selection.mode_name);\n            break;\n    }\n}", "CodeBleu_score": 37.66517673047377}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    if (this->heartbeat_count == 0) {\n        this->heartbeat_count++;\n    } else {\n        if (this->heartbeat_count >= this->heartbeat_threshold) {\n            ROS_ERROR(\"Heartbeat not received from %s\", this->vehicle_type.c_str());\n            if (this->vehicle_type == \"UGV\") {\n                this->disconnect_flag = true;\n            } else if (this->vehicle_type == \"UAV\") {\n                this->disconnect_flag = true;\n            } else if (this->vehicle_type == \"swarm\") {\n                this->disconnect_flag = true;\n            }\n            this->heartbeat_count = 0;\n        } else {\n            this->heartbeat_count++;\n        }\n    }\n}", "CodeBleu_score": 16.806445998003912}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n\tif (heartbeat_counter > 0) {\n\t\theartbeat_counter--;\n\t}\n\telse {\n\t\tif (heartbeat_counter == 0) {\n\t\t\tROS_ERROR(\"HEARTBEAT LOST\");\n\t\t}\n\t\theartbeat_counter--;\n\t\tif (heartbeat_counter == -10) {\n\t\t\tif (vehicle_type == 1) {\n\t\t\t\t//ROS_INFO(\"SWARM DISCONNECTED\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t\theartbeat_counter = 0;\n\t\t\t}\n\t\t\telse if (vehicle_type == 2) {\n\t\t\t\t//ROS_INFO(\"UAV DISCONNECTED\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t\theartbeat_counter = 0;\n\t\t\t}\n\t\t\telse if (vehicle_type == 3) {\n\t\t\t\t//ROS_INFO(\"UGV DISCONNECTED\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t\theartbeat_counter = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.49624599253781}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    // Check if the heartbeat count is unchanged for a specified number of attempts\n    if (heartbeat_counter_ >= heartbeat_max_attempts_) {\n        ROS_ERROR(\"[%s]: Heartbeat lost!\", vehicle_name_.c_str());\n        if (vehicle_type_ == \"UAV\") {\n            ROS_ERROR(\"[%s]: UAV disconnected!\", vehicle_name_.c_str());\n            disconnect_flag_ = true;\n        } else if (vehicle_type_ == \"UGV\") {\n            ROS_ERROR(\"[%s]: UGV disconnected!\", vehicle_name_.c_str());\n            disconnect_flag_ = true;\n        } else if (vehicle_type_ == \"swarm\") {\n            ROS_ERROR(\"[%s]: Swarm disconnected!\", vehicle_name_.c_str());\n            disconnect_flag_ = true;\n        } else {\n            ROS_ERROR(\"[%s]: Vehicle type not recognized!\", vehicle_name_.c_str());\n        }\n    }\n}", "CodeBleu_score": 38.26977921225657}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] msg received\");\n    int id = msg->id;\n    int num_trajs = msg->num_trajs;\n    int num_knots = msg->num_knots;\n    int num_points = msg->num_points;\n    int num_yaw_points = msg->num_yaw_points;\n    int num_ctrl_pts = msg->num_ctrl_pts;\n\n    Bspline bspline;\n    bspline.num_ctrl_pts = num_ctrl_pts;\n    bspline.num_knots = num_knots;\n    bspline.num_points = num_points;\n    bspline.num_yaw_points = num_yaw_points;\n    bspline.knots = msg->knots;\n    bspline.points = msg->points;\n    bspline.yaw_points = msg->yaw_points;\n    bspline.ctrl_pts = msg->ctrl_pts;\n\n    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] num_trajs: %d\", num_trajs);\n    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] num_knots: %d\", num_knots);\n    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] num_points: %d\", num_points);\n    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] num_yaw_points: %d\", num_yaw_points);\n    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] num_ctrl_pts: %d\", num_ctrl_pts);\n\n    // ROS_INFO(\"[EGOPlannerSwarm::multitrajSubTcpCb] bspline.num_ctrl_pts: %d\", bspline.num_ctrl_pts);\n    // ROS_INFO", "CodeBleu_score": 20.958093461309268}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // ROS_INFO(\"ego_planner_swarm_tcp: received multitraj message\");\n    // ROS_INFO(\"ego_planner_swarm_tcp: msg->traj_num = %d\", msg->traj_num);\n    // ROS_INFO(\"ego_planner_swarm_tcp: msg->drone_id = %d\", msg->drone_id);\n    // ROS_INFO(\"ego_planner_swarm_tcp: msg->traj_id = %d\", msg->traj_id);\n    // ROS_INFO(\"ego_planner_swarm_tcp: msg->traj_index = %d\", msg->traj_index);\n    // ROS_INFO(\"ego_planner_swarm_tcp: msg->traj_total = %d\", msg->traj_total);\n\n    // Create a Bspline struct for each trajectory\n    Bspline traj;\n    traj.set_d(3);\n    traj.set_order(3);\n    traj.set_num_ctrl_pts(msg->traj_index);\n    traj.set_dim(3);\n    traj.set_t_start(0.0);\n    traj.set_t_end(msg->traj_index);\n\n    // Initialize the knots vector\n    std::vector<double> knots;\n    knots.resize(msg->traj_index + 4);\n    for (int i = 0; i < msg->traj_index + 4; i++) {\n        knots[i] = i;\n    }\n    traj.set_knots(knots);\n\n    // Initialize the position points vector\n    std::vector<double> points;\n    points.resize(3 * msg->traj_index);\n    for (int i = 0; i < msg->traj_index; i++) {\n        points[3 * i] = msg->position[3 * i];\n        points[3 * i + 1] = msg->position[3 * i + 1];\n        points[3 * i + 2] = msg->position[3 * i +", "CodeBleu_score": 30.092454336630105}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    //ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb: msg received\");\n\n    // Extract drone ID\n    int drone_id = msg->drone_id;\n\n    // Extract trajectory data\n    int num_trajs = msg->num_trajs;\n    std::vector<std::vector<double>> traj_knots = msg->traj_knots;\n    std::vector<std::vector<double>> traj_points = msg->traj_points;\n    std::vector<std::vector<double>> traj_yaws = msg->traj_yaws;\n\n    // Initialize Bspline struct for each trajectory\n    std::vector<Bspline> trajs;\n    for (int i = 0; i < num_trajs; i++) {\n        Bspline traj;\n        traj.order = traj_knots[i].size() - traj_points[i].size() - 1;\n        traj.n_knots = traj_knots[i].size();\n        traj.n_points = traj_points[i].size() / 3;\n        traj.knots = traj_knots[i];\n        traj.points = traj_points[i];\n        traj.yaws = traj_yaws[i];\n        trajs.push_back(traj);\n    }\n\n    // Encode MultiBsplines data\n    std::vector<uint8_t> data = encodeMultiBsplines(drone_id, num_trajs, trajs);\n\n    // Send MultiBsplines data via TCP\n    comm_module.sendData(data);\n}", "CodeBleu_score": 30.78170429005661}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> *octree = new pcl::octree::OctreePointCloudCompression<pcl::PointXYZ>(0.005);\n    octree->setInputCloud(cloud);\n    octree->addPointsFromInputCloud();\n    octree->encodePointCloud();\n    std::vector<uint8_t> *data = new std::vector<uint8_t>();\n    octree->getSerializedTree(*data);\n\n    // Store the compressed data\n    compressed_data = *data;\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.is_bigendian = msg.is_bigendian;\n    compressed_msg.point_step = 1;\n    compressed_msg.row_step = compressed_msg.width;\n    compressed_msg.is_dense = msg.is_dense;\n    compressed_msg.data.resize(compressed_msg.row_step * compressed_msg.height);\n    memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.row_step * compressed_msg.height);\n\n    // Release dynamically allocated memory\n    delete data;\n    delete octree;\n\n    return compressed_msg;\n}", "CodeBleu_score": 51.25169166990619}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZRGB>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Create the filtering object\n  pcl::VoxelGrid<pcl::PointXYZRGB> sor;\n  sor.setInputCloud(cloud);\n  sor.setLeafSize(0.005f, 0.005f, 0.005f);\n  sor.filter(*cloud_filtered);\n\n  sensor_msgs::PointCloud2 msg_filtered;\n  pcl::toROSMsg(*cloud_filtered, msg_filtered);\n  msg_filtered.header.frame_id = msg.header.frame_id;\n  msg_filtered.header.stamp = msg.header.stamp;\n\n  return msg_filtered;\n}", "CodeBleu_score": 29.94063330750877}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Convert to pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(0.001);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    std::vector<uint8_t> compressedData;\n    octree.encodePointCloud(compressedData);\n\n    // Store compressed data\n    compressed_data = compressedData;\n\n    // Create new PointCloud2 message\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::toROSMsg(*cloud, compressed_msg);\n    compressed_msg.data = compressedData;\n\n    return compressed_msg;\n}", "CodeBleu_score": 34.50951512708212}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 51.19884106390078}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); it++) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n            return;\n        }\n    }\n}", "CodeBleu_score": 44.72200744646221}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < multi_uav_state_.uav_state_list.size(); i++) {\n    if (multi_uav_state_.uav_state_list[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_.uav_state_list[i] = uav_state;\n    }\n  }\n}", "CodeBleu_score": 60.62270604740829}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\n  // Initialize MultiUGVState message\n  ugv_msgs::MultiUGVState multi_ugv_state;\n\n  // Iterate through each UGV state\n  for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\n    // Initialize UGVState message\n    ugv_msgs::UGVState ugv_state;\n\n    // Populate UGVState message\n    ugv_state.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n    ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n    ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n    ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n    ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n    ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n    ugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n    ugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n    ugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n    ugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n    ugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n    ugv_state.attitude.w = m_multi_ugv_state.ugv_state[i].attitude.w;\n\n    // Add U", "CodeBleu_score": 39.88737367359664}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initializes a MultiUGVState message\n    swarm_control_msgs::MultiUGVState multi_ugv_state_msg;\n\n    // Iterates through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.num_ugv; i++) {\n        // Populates the UGVState message with ID, battery, position, velocity, and attitude data\n        swarm_control_msgs::UGVState ugv_state_msg;\n        ugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n        ugv_state_msg.battery_voltage = m_multi_ugv_state.ugv_state[i].battery_voltage;\n        ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position[0];\n        ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position[1];\n        ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position[2];\n        ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity[0];\n        ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity[1];\n        ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity[2];\n        ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude[0];\n        ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude[1];\n        ugv_state_msg.attitude.z = m_multi_ugv_state.ugv_", "CodeBleu_score": 39.31719467506898}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initializing the MultiUGVState message\n    MultiUGVState m_ugv_state_msg;\n\n    // Iterating through each UGV state in the MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n        // Initializing the UGVState message\n        UGVState ugv_state_msg;\n\n        // Populating the UGVState message with ID, battery, position, velocity, and attitude data\n        ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        ugv_state_msg.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n        ugv_state_msg.attitude", "CodeBleu_score": 38.737480659355484}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.cols(); i++) {\n\n    // Compute the predicted positions of moving objects\n    Eigen::Vector3d p_pred = q.col(i);\n    for (int j = 0; j < moving_objects_.size(); j++) {\n      // Get the predicted position of the object\n      Eigen::Vector3d p_obj_pred = moving_objects_[j]->getPredictedPos(t_total_, p_pred);\n      // Compute the distance between the control point and the object\n      double dist = (p_pred - p_obj_pred).norm();\n      // If the distance is less than a specified clearance, update the cost and gradient\n      if (dist < clearance_) {\n        // Update the cost\n        cost += pow(dist - clearance_, 2);\n        // Update the gradient\n        gradient.col(i) += 2 * (p_pred - p_obj_pred) / dist;\n      }\n    }\n  }\n}", "CodeBleu_score": 33.46486378223876}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    // Initialize the cost and gradient.\n    cost = 0;\n    gradient.setZero(q.rows(), q.cols());\n\n    // Iterate through control points of the B-spline.\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute the predicted position of moving objects.\n        Eigen::VectorXd pos_moving_obj = calcMovingObjPos(q(i, 0), q(i, 1));\n\n        // Compute the distance error between the control point and the predicted position of moving objects.\n        double dist_err = (q.row(i).segment(2, 2) - pos_moving_obj).norm();\n\n        // If the distance is less than the clearance, update the cost and gradient.\n        if (dist_err < clearance_) {\n            cost += dist_err * dist_err;\n            gradient.row(i) += 2 * dist_err * (q.row(i).segment(2, 2) - pos_moving_obj);\n        }\n    }\n}", "CodeBleu_score": 28.942691746934816}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  for (int i = 0; i < q.cols(); i++) {\n    // Predict the position of moving objects at the time of the control point.\n    Eigen::VectorXd pos = q.col(i);\n    double t = t_total_ * (double)i / (double)(q.cols() - 1);\n    Eigen::VectorXd pos_moving_obj = predictMovingObjects(t);\n\n    // Calculate the distance between the control point and the moving objects.\n    double dist = (pos - pos_moving_obj).norm();\n\n    // If the distance is less than the clearance, update the cost and gradient.\n    if (dist < clearance_) {\n      cost += (dist - clearance_) * (dist - clearance_);\n      gradient.col(i) = 2.0 * (dist - clearance_) * (pos - pos_moving_obj).transpose() / (double)q.rows();\n    }\n  }\n}", "CodeBleu_score": 35.6399219201286}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n  cost = 0.0;\n  gradient.setZero(q.rows(), q.cols());\n\n  for (int i = 0; i < q.cols(); ++i) {\n    Eigen::Vector3d q_i = q.col(i);\n    Eigen::Vector3d q_i_next = q.col((i + 1) % q.cols());\n    Eigen::Vector3d q_i_prev = q.col((i - 1 + q.cols()) % q.cols());\n\n    // compute the positional error\n    Eigen::Vector3d p_i = q_i - ref_points_.col(i);\n\n    // compute the velocity vector\n    Eigen::Vector3d v_i = (q_i_next - q_i_prev) / 2.0;\n\n    // compute the cost\n    cost += a2_ * p_i.dot(p_i) + b2_ * v_i.dot(v_i);\n\n    // compute the gradient\n    gradient.col(i) += 2.0 * a2_ * p_i + 2.0 * b2_ * v_i;\n  }\n}", "CodeBleu_score": 31.723587427854877}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    // Initialize the cost to zero\n    cost = 0.0;\n\n    // Initialize the gradient to zero\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Iterate through the control points\n    for (int i = 0; i < q.cols(); i++) {\n\n        // Get the position and velocity of the trajectory at the current control point\n        Eigen::Vector3d pos = getPos(i, q);\n        Eigen::Vector3d vel = getVel(i, q);\n\n        // Get the position and velocity of the reference trajectory at the current control point\n        Eigen::Vector3d pos_ref = getPos(i, q_ref_);\n        Eigen::Vector3d vel_ref = getVel(i, q_ref_);\n\n        // Compute the positional error\n        Eigen::Vector3d pos_error = pos - pos_ref;\n\n        // Compute the velocity error\n        Eigen::Vector3d vel_error = vel - vel_ref;\n\n        // Compute the cost\n        cost += pos_error.transpose() * pos_error * a2_ + vel_error.transpose() * vel_error * b2_;\n\n        // Compute the gradient\n        gradient.col(i) = 2 * pos_error.transpose() * a2_ * getPosGrad(i, q) + 2 * vel_error.transpose() * b2_ * getVelGrad(i, q);\n    }\n}", "CodeBleu_score": 33.351397072652325}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n    cost = 0;\n    gradient.setZero();\n\n    for (int i = 0; i < q.rows(); ++i) {\n        Eigen::Vector3d q_i = q.row(i);\n        Eigen::Vector3d q_i_dot = q_i_dot_list[i];\n        Eigen::Vector3d q_i_ddot = q_i_ddot_list[i];\n\n        Eigen::Vector3d q_i_ref = q_i_ref_list[i];\n        Eigen::Vector3d q_i_ref_dot = q_i_ref_dot_list[i];\n        Eigen::Vector3d q_i_ref_ddot = q_i_ref_ddot_list[i];\n\n        Eigen::Vector3d error = q_i - q_i_ref;\n        Eigen::Vector3d error_dot = q_i_dot - q_i_ref_dot;\n        Eigen::Vector3d error_ddot = q_i_ddot - q_i_ref_ddot;\n\n        double error_dot_norm = error_dot.norm();\n        double error_ddot_norm = error_ddot.norm();\n\n        cost += a2 * error.squaredNorm() + b2 * error_dot_norm * error_dot_norm + c2 * error_ddot_norm * error_ddot_norm;\n\n        Eigen::Vector3d error_dot_cross = error.cross(error_dot);\n        Eigen::Vector3d error_ddot_cross = error.cross(error_ddot);\n\n        Eigen::Matrix3d J_i = Eigen::Matrix3d::Zero();\n        J_i.block<3, 1>(0, 0) = error_dot_cross;\n        J_i.block<3, 1>(0, 1) = error_dot_cross.cross(error_dot);\n        J_i.block<3, 1>(0, 2) = error_dot;\n\n        Eigen::Matrix3d J_i_dot = Eigen::Matrix3d", "CodeBleu_score": 32.996829826718795}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  // Get the third derivative of the spline\n  UniformBspline jerk_spline = getDerivative(3);\n\n  // Get the knot times and control points of the jerk trajectory\n  std::vector<double> jerk_knot_times = jerk_spline.getKnotTimes();\n  std::vector<std::vector<double>> jerk_control_points = jerk_spline.getControlPoints();\n\n  // Initialize the jerk value\n  double jerk = 0.0;\n\n  // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n  for (int i = 0; i < jerk_control_points.size(); i++) {\n    for (int j = 0; j < jerk_control_points[i].size(); j++) {\n      jerk += pow(jerk_control_points[i][j], 2) * (jerk_knot_times[i+1] - jerk_knot_times[i]);\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 49.563519002001364}, {"code": "double UniformBspline::getJerk(){\n\t\n    // Create a vector to store the knot times of the jerk trajectory\n    std::vector<double> jerk_knot_times;\n\n    // Create a vector to store the control points of the jerk trajectory\n    std::vector<std::vector<double>> jerk_control_points;\n\n    // Create a vector to store the jerk values of each control point\n    std::vector<double> jerk_values;\n\n    // Create a vector to store the squared jerk values of each control point\n    std::vector<double> squared_jerk_values;\n\n    // Create a vector to store the differences in knot times of each control point\n    std::vector<double> knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared differences in knot times of each control point\n    std::vector<double> squared_knot_time_differences;\n\n    // Create a vector to store the squared", "CodeBleu_score": 7.300110068243387}, {"code": "double UniformBspline::getJerk(){\n\t  // Calculate jerk trajectory\n  UniformBspline jerk_traj = getDerivative(3);\n\n  // Get knot times and control points of jerk trajectory\n  std::vector<double> jerk_knot_times = jerk_traj.getKnotTimes();\n  std::vector<Eigen::VectorXd> jerk_control_points = jerk_traj.getControlPoints();\n\n  // Iterate through control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n  double jerk = 0;\n  for (int i = 0; i < jerk_control_points.size(); i++) {\n    for (int j = 0; j < jerk_control_points[i].size(); j++) {\n      jerk += pow(jerk_control_points[i][j], 2) * (jerk_knot_times[i + 1] - jerk_knot_times[i]);\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 51.31412463045017}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 49.315525916455506}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1.0;\n\treturn pos;\n}", "CodeBleu_score": 48.5261302368948}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\n    // Convert the 2D pixel coordinates into a 3D position vector in camera coordinates\n    double x = (u - cx_) * depth / fx_;\n    double y = (v - cy_) * depth / fy_;\n    double z = depth;\n    Eigen::Vector4d pos(x, y, z, 1);\n\n    return pos;\n}", "CodeBleu_score": 54.0010891343339}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, odom.child_frame_id.substr(0, odom.child_frame_id.find('/')));\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(\"Error extracting drone ID from odometry message: \" << e.what());\n    }\n}", "CodeBleu_score": 40.50247963595909}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n  } catch (std::exception& e) {\n    ROS_ERROR_STREAM(\"Exception caught in rcvDroneXOdomCallback: \" << e.what());\n  }\n}", "CodeBleu_score": 38.436051162857034}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n  } catch (const std::exception& e) {\n    ROS_ERROR_STREAM(e.what());\n  }\n}", "CodeBleu_score": 37.36849088588651}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Attempt to find the drone\n    DronePose drone_pose;\n    bool found = findDrone(drone_id, true_pixel, drone_pose);\n\n    // If the drone is found, compute the pose error\n    if (found) {\n        // Compute the pose error\n        Eigen::Vector3d pose_error = computePoseError(drone_pose);\n\n        // Publish the pose error\n        publishPoseError(pose_error);\n\n        // Update the debug result\n        updateDebugResult(drone_id, true_pixel, drone_pose, pose_error);\n    } else {\n        // Update the debug result\n        updateDebugResult(drone_id, true_pixel);\n    }\n}", "CodeBleu_score": 29.04753274559324}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Get the drone's ID and true pixel position\n    int drone_id_ = drone_id;\n    Eigen::Vector2i true_pixel_ = true_pixel;\n\n    // Get the drone's true pose in the world frame\n    Eigen::Vector3d true_pose_world = get_true_pose(drone_id_);\n\n    // Get the drone's true pose in the camera frame\n    Eigen::Vector3d true_pose_camera = get_true_pose_camera(drone_id_, true_pose_world);\n\n    // Get the drone's estimated pose in the camera frame\n    Eigen::Vector3d estimated_pose_camera = get_estimated_pose_camera(drone_id_, true_pixel_);\n\n    // Compute the pose error\n    Eigen::Vector3d pose_error = estimated_pose_camera - true_pose_camera;\n\n    // Update the debug result\n    update_debug_result(drone_id_, true_pose_world, estimated_pose_camera, pose_error);\n\n    // Publish the pose error\n    publish_pose_error(drone_id_, pose_error);\n}", "CodeBleu_score": 30.666902227139108}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Create a new Drone object\n    Drone drone(drone_id, true_pixel);\n\n    // Get the drone's true pose in the camera frame\n    Eigen::Vector3f true_pose_camera = drone.getPoseCamera();\n\n    // Check if the drone is in the camera frame\n    if (true_pose_camera[2] < 0) {\n\n        // If the drone is not in the camera frame, update the debug result and return\n        debug_result.drone_found = false;\n        debug_result.drone_id = drone_id;\n        debug_result.drone_pixel = true_pixel;\n        debug_result.drone_pose_camera = true_pose_camera;\n        debug_result.drone_pose_world = drone.getPoseWorld();\n        debug_result.drone_pose_error = drone.getPoseError();\n\n        // Publish the debug result\n        debug_result_pub.publish(debug_result);\n\n        return;\n    }\n\n    // If the drone is in the camera frame, update the debug result and publish it\n    debug_result.drone_found = true;\n    debug_result.drone_id = drone_id;\n    debug_result.drone_pixel = true_pixel;\n    debug_result.drone_pose_camera = true_pose_camera;\n    debug_result.drone_pose_world = drone.getPoseWorld();\n    debug_result.drone_pose_error = drone.getPoseError();\n\n    // Publish the debug result\n    debug_result_pub.publish(debug_result);\n\n    // Publish the pose error\n    pose_error_pub.publish(drone.getPoseError());\n\n    return;\n}", "CodeBleu_score": 31.714033807072717}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\n    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 94.15382155870053}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 78.86875382773461}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t  vector<GridNodePtr> path;\n  path.push_back(current);\n  while (current->cameFrom != nullptr) {\n    current = current->cameFrom;\n    path.push_back(current);\n  }\n  reverse(path.begin(), path.end());\n  return path;\n}", "CodeBleu_score": 84.98139592365212}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    // Convert the coordinates to indices\n    start_idx = grid.GetGridIndex(start_pt);\n    end_idx = grid.GetGridIndex(end_pt);\n\n    // If either point is inside an obstacle, adjust it\n    if (grid.GetGridValue(start_idx) > 0 || grid.GetGridValue(end_idx) > 0) {\n        if (!AdjustStartEndPoints(start_pt, end_pt, start_idx, end_idx)) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 23.44488712973927}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    // Convert the start and end points to grid indices\n    if (!grid_->GetIndex(start_pt, start_idx) || !grid_->GetIndex(end_pt, end_idx)) {\n        return false;\n    }\n\n    // If the start or end point is inside an obstacle, we need to adjust it\n    if (grid_->GetGridValue(start_idx) > 0 || grid_->GetGridValue(end_idx) > 0) {\n        // If the start point is inside an obstacle, we need to adjust it\n        if (grid_->GetGridValue(start_idx) > 0) {\n            // Get the direction to the end point\n            Vector3d direction_to_end = (end_pt - start_pt).normalized();\n\n            // Iteratively adjust the start point until it is no longer inside an obstacle\n            while (grid_->GetGridValue(start_idx) > 0) {\n                // Move the start point in the direction of the end point\n                start_pt += direction_to_end;\n\n                // Convert the new start point to an index\n                if (!grid_->GetIndex(start_pt, start_idx)) {\n                    return false;\n                }\n            }\n        }\n\n        // If the end point is inside an obstacle, we need to adjust it\n        if (grid_->GetGridValue(end_idx) > 0) {\n            // Get the direction to the start point\n            Vector3d direction_to_start = (start_pt - end_pt).normalized();\n\n            // Iteratively adjust the end point until it is no longer inside an obstacle\n            while (grid_->GetGridValue(end_idx) > 0) {\n                // Move the end point in the direction of the start point\n                end_pt += direction_to_start;\n\n                // Convert the new end point to an index\n                if (!grid_->GetIndex(end_pt, end_idx)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 46.76597906776802}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    // First, convert the coordinates to indices\n    if (!ConvertToIndex(start_pt, start_idx) || !ConvertToIndex(end_pt, end_idx)) {\n        return false;\n    }\n\n    // If the start or end point is inside an obstacle, iteratively adjust the point by moving it away from the other point until it is no longer in an obstacle\n    int adjustment_direction = 0;\n    int adjustment_direction_max = 2;\n    bool adjustment_successful = false;\n    while (!adjustment_successful) {\n        adjustment_successful = true;\n        if (IsInsideObstacle(start_idx)) {\n            adjustment_direction = (adjustment_direction + 1) % adjustment_direction_max;\n            if (adjustment_direction == 0) {\n                start_idx[0]++;\n            }\n            else if (adjustment_direction == 1) {\n                start_idx[1]++;\n            }\n            else {\n                start_idx[2]++;\n            }\n            adjustment_successful = !IsInsideObstacle(start_idx);\n        }\n        if (IsInsideObstacle(end_idx)) {\n            adjustment_direction = (adjustment_direction + 1) % adjustment_direction_max;\n            if (adjustment_direction == 0) {\n                end_idx[0]--;\n            }\n            else if (adjustment_direction == 1) {\n                end_idx[1]--;\n            }\n            else {\n                end_idx[2]--;\n            }\n            adjustment_successful = !IsInsideObstacle(end_idx);\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 38.36094625814864}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  int min_id[3];\n  int max_id[3];\n  for (int i = 0; i < 3; ++i) {\n    min_id[i] = floor((min_pos(i) - origin_(i)) / resolution_);\n    max_id[i] = floor((max_pos(i) - origin_(i)) / resolution_);\n  }\n  for (int i = min_id[0]; i <= max_id[0]; ++i) {\n    for (int j = min_id[1]; j <= max_id[1]; ++j) {\n      for (int k = min_id[2]; k <= max_id[2]; ++k) {\n        occupancy_buffer_inflate_(i, j, k) = 0;\n        distance_buffer_inflate_(i, j, k) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 37.990494667725315}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // cout << \"resetBuffer: \" << min_pos.transpose() << \" \" << max_pos.transpose() << endl;\n  // cout << \"min_id: \" << min_id.transpose() << \" \" << max_id.transpose() << endl;\n  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        Eigen::Vector3i idx(x, y, z);\n        // cout << \"idx: \" << idx.transpose() << endl;\n        // cout << \"occupancy_buffer_inflate_: \" << occupancy_buffer_inflate_(x, y, z) << endl;\n        occupancy_buffer_inflate_(x, y, z) = 0;\n        // cout << \"occupancy_buffer_inflate_: \" << occupancy_buffer_inflate_(x, y, z) << endl;\n      }\n}", "CodeBleu_score": 74.04922233795543}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n  for (int i = min_id(0); i <= max_id(0); ++i)\n    for (int j = min_id(1); j <= max_id(1); ++j)\n      for (int k = min_id(2); k <= max_id(2); ++k) {\n        if (isInMap(i, j, k)) {\n          occupancy_buffer_inflate_(i, j, k) = 0;\n          distance_buffer_inflate_(i, j, k) = 0;\n        }\n      }\n}", "CodeBleu_score": 54.91440006395128}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff_vec = pt - camera_pt;\n  double max_x = std::max(std::abs(diff_vec(0)), size_(0) / 2.0);\n  double max_y = std::max(std::abs(diff_vec(1)), size_(1) / 2.0);\n  double max_z = std::max(std::abs(diff_vec(2)), size_(2) / 2.0);\n\n  double min_x = std::min(std::abs(diff_vec(0)), size_(0) / 2.0);\n  double min_y = std::min(std::abs(diff_vec(1)), size_(1) / 2.0);\n  double min_z = std::min(std::abs(diff_vec(2)), size_(2) / 2.0);\n\n  double scale_x = 1.0;\n  double scale_y = 1.0;\n  double scale_z = 1.0;\n\n  if (diff_vec(0) > 0)\n    scale_x = max_x / diff_vec(0);\n  else\n    scale_x = min_x / diff_vec(0);\n\n  if (diff_vec(1) > 0)\n    scale_y = max_y / diff_vec(1);\n  else\n    scale_y = min_y / diff_vec(1);\n\n  if (diff_vec(2) > 0)\n    scale_z = max_z / diff_vec(2);\n  else\n    scale_z = min_z / diff_vec(2);\n\n  double scale = std::min(std::min(scale_x, scale_y), scale_z);\n\n  return camera_pt + scale * diff_vec;\n}", "CodeBleu_score": 33.8112404569589}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d scaled_diff;\n    Eigen::Vector3d scaled_pt;\n    double scale_factor = 1.0;\n    double min_scale_factor = 1.0;\n    double max_scale_factor = 1.0;\n    double max_diff = 0.0;\n    double min_diff = 0.0;\n\n    // Find the minimum and maximum translation coefficients along each axis\n    for (int i = 0; i < 3; ++i) {\n        if (diff[i] > 0) {\n            max_diff = diff[i];\n            min_diff = 0;\n        } else {\n            max_diff = 0;\n            min_diff = diff[i];\n        }\n\n        // Determine the maximum scaling factor that keeps the point within map boundaries\n        max_scale_factor = max_diff / (map_size_[i] - 1);\n        min_scale_factor = min_diff / (map_size_[i] - 1);\n        if (max_scale_factor < min_scale_factor) {\n            scale_factor = max_scale_factor;\n        } else {\n            scale_factor = min_scale_factor;\n        }\n\n        // Scale the difference vector\n        scaled_diff[i] = diff[i] * scale_factor;\n        scaled_pt[i] = camera_pt[i] + scaled_diff[i];\n    }\n\n    return scaled_pt;\n}", "CodeBleu_score": 51.05522430139327}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d min_pt = this->getMinPt();\n  Eigen::Vector3d max_pt = this->getMaxPt();\n  Eigen::Vector3d res(0, 0, 0);\n\n  for (int i = 0; i < 3; ++i) {\n    double min_coeff = (min_pt[i] - camera_pt[i]) / diff[i];\n    double max_coeff = (max_pt[i] - camera_pt[i]) / diff[i];\n    double coeff = 0;\n    if (diff[i] < 0) {\n      coeff = min_coeff;\n    } else if (diff[i] > 0) {\n      coeff = max_coeff;\n    }\n\n    if (coeff > 0) {\n      res[i] = coeff * diff[i];\n    }\n  }\n\n  return camera_pt + res;\n}", "CodeBleu_score": 57.90492315625262}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (!need_update_occupancy_)\n    return;\n\n  // Clear the local map\n  local_map_.clear();\n\n  // If the local map has been updated, clear and inflate it\n  if (need_update_local_map_) {\n    local_map_.clear();\n    inflateLocalMap();\n    need_update_local_map_ = false;\n  }\n\n  // Check if the odometry is timeout\n  if (ros::Time::now() - last_odom_update_time_ > ros::Duration(odom_timeout_)) {\n    ROS_WARN(\"Odometry timeout!\");\n    is_odom_valid_ = false;\n  }\n\n  // Check if the depth image is timeout\n  if (ros::Time::now() - last_depth_image_update_time_ > ros::Duration(depth_image_timeout_)) {\n    ROS_WARN(\"Depth image timeout!\");\n    is_depth_valid_ = false;\n  }\n\n  // If the odometry or depth image is timeout, return\n  if (!is_odom_valid_ || !is_depth_valid_) {\n    need_update_occupancy_ = false;\n    return;\n  }\n\n  // Project the depth image into points\n  std::vector<Eigen::Vector3d> points;\n  projectDepthImageIntoPoints(points);\n\n  // Process the points with raycasting\n  raycastProcess(points);\n\n  // Set the flag\n  need_update_occupancy_ = false;\n}", "CodeBleu_score": 42.94296488540888}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  if (map_updated_) {\n    map_updated_ = false;\n    clearInflateLocalMap();\n  }\n\n  if (depth_data_timeout_) {\n    ROS_WARN(\"Depth data timeout\");\n    depth_data_timeout_ = false;\n  }\n\n  if (odom_data_timeout_) {\n    ROS_WARN(\"Odom data timeout\");\n    odom_data_timeout_ = false;\n  }\n\n  if (depth_data_timeout_ || odom_data_timeout_) {\n    return;\n  }\n\n  if (depth_data_received_) {\n    last_depth_data_update_time_ = ros::Time::now();\n    depth_data_received_ = false;\n  }\n\n  if (odom_data_received_) {\n    last_odom_data_update_time_ = ros::Time::now();\n    odom_data_received_ = false;\n  }\n\n  if (last_depth_data_update_time_ < last_odom_data_update_time_) {\n    last_depth_data_update_time_ = last_odom_data_update_time_;\n  }\n\n  if (last_depth_data_update_time_ < last_map_update_time_) {\n    last_depth_data_update_time_ = last_map_update_time_;\n  }\n\n  if (last_depth_data_update_time_ < last_depth_data_update_time_) {\n    last_depth_data_update_time_ = last_depth_data_update_time_;\n  }\n\n  if (last_depth_data_update_time_ < last_depth_data_update_time_) {\n    last_depth_data_update_time_ = last_depth_data_update_time_;\n  }\n\n  if (last_depth_data_update_time_ < last_depth_data_update_time_) {\n    last_depth_data_update_time_ = last_depth_data_update_time_;\n  }\n\n  if (last_depth_data_update_time_ < last", "CodeBleu_score": 31.344978960133886}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // update occupancy\n  if (need_update_) {\n    // get depth image\n    cv_bridge::CvImagePtr cv_ptr;\n    try {\n      cv_ptr = cv_bridge::toCvCopy(depth_image_, depth_image_->encoding);\n    } catch (cv_bridge::Exception &e) {\n      ROS_ERROR(\"cv_bridge exception: %s\", e.what());\n      return;\n    }\n\n    // get camera info\n    sensor_msgs::CameraInfo camera_info = *depth_camera_info_;\n\n    // get transformation\n    tf::StampedTransform transform;\n    try {\n      tf_listener_.lookupTransform(world_frame_id_, depth_frame_id_, ros::Time(0), transform);\n    } catch (tf::TransformException ex) {\n      ROS_ERROR(\"%s\", ex.what());\n      return;\n    }\n\n    // project depth image into 3D points\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    cloud_ptr = projectDepthImageInto3DPointCloud(cv_ptr, camera_info, transform);\n\n    // process points with raycasting\n    raycastProcess(cloud_ptr);\n\n    // clear and inflate local map\n    if (need_update_local_map_) {\n      clearLocalMap();\n      inflateLocalMap();\n      need_update_local_map_ = false;\n    }\n\n    // set flags\n    depth_image_updated_ = false;\n    odom_updated_ = false;\n    need_update_ = false;\n  }\n}", "CodeBleu_score": 36.78155908740035}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n\t// accumulator for the average F-measure\n\tfloat f_measure_acc = 0.0f;\n\n\t// iterate through the image filenames\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\n\t\t// load the image\n\t\tMat image = imread(image_fns[i], 1);\n\n\t\t// load the ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses = load_ellipses(gt_fns[i], gt_angle_radians);\n\n\t\t// load the detected ellipses\n\t\tvector<Ellipse> dt_ellipses = load_ellipses(dt_fns[i], false);\n\n\t\t// evaluate the detection performance\n\t\tfloat f_measure = _ellipse_evaluate_image(image, gt_ellipses, dt_ellipses);\n\n\t\t// accumulate the F-measure\n\t\tf_measure_acc += f_measure;\n\t}\n\n\t// return the average F-measure\n\treturn f_measure_acc / image_fns.size();\n}", "CodeBleu_score": 60.25381690775179}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n\t// accumulator\n\tfloat avg_f = 0;\n\n\t// iterate through the images\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\n\t\t// load the image\n\t\tMat image = imread(image_fns[i]);\n\n\t\t// load the ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses = _ellipse_load_ellipses(gt_fns[i], gt_angle_radians);\n\n\t\t// load the detected ellipses\n\t\tvector<Ellipse> dt_ellipses = _ellipse_load_ellipses(dt_fns[i], false);\n\n\t\t// evaluate the detection performance\n\t\tfloat f = _ellipse_evaluate_image(image, gt_ellipses, dt_ellipses);\n\n\t\t// accumulate the F-measure\n\t\tavg_f += f;\n\t}\n\n\t// return the average F-measure\n\treturn avg_f / image_fns.size();\n}", "CodeBleu_score": 61.82574278181162}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    float avg_f = 0;\n\n    for(size_t i = 0; i < image_fns.size(); i++) {\n\n        // load image\n        Mat image = imread(image_fns[i], CV_LOAD_IMAGE_COLOR);\n\n        // load ground truth ellipses\n        vector<Ellipse> gt_ellipses = load_ellipses(gt_fns[i], gt_angle_radians);\n\n        // load detected ellipses\n        vector<Ellipse> dt_ellipses = load_ellipses(dt_fns[i], false);\n\n        // evaluate detection performance\n        float f = evaluate_detection(image, gt_ellipses, dt_ellipses);\n\n        avg_f += f;\n\n    }\n\n    return avg_f / image_fns.size();\n\n}", "CodeBleu_score": 60.77535017889184}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == nullptr) {\n\t\treturn 0.0f;\n\t}\n\n\tfloat angle_1 = atan2(foci[1] - y, foci[0] - x);\n\tfloat angle_2 = atan2(foci[3] - y, foci[2] - x);\n\tfloat angle_diff = angle_1 - angle_2;\n\tif (angle_diff > M_PI) {\n\t\tangle_diff -= 2 * M_PI;\n\t} else if (angle_diff < -M_PI) {\n\t\tangle_diff += 2 * M_PI;\n\t}\n\treturn angle_diff;\n}", "CodeBleu_score": 37.59802093437409}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = foci[0], b = foci[1], c = foci[2];\n\tfloat d1 = sqrt((x - a)*(x - a) + (y - b)*(y - b));\n\tfloat d2 = sqrt((x - c)*(x - c) + (y - b)*(y - b));\n\tfloat theta1 = atan2(y - b, x - a);\n\tfloat theta2 = atan2(y - b, x - c);\n\tfloat theta = theta2 - theta1;\n\tif (theta > M_PI) theta -= 2*M_PI;\n\telse if (theta < -M_PI) theta += 2*M_PI;\n\treturn theta;\n}", "CodeBleu_score": 43.330517128968}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float angle = angle1 - angle2;\n    if (angle < -M_PI) {\n        angle += 2 * M_PI;\n    } else if (angle > M_PI) {\n        angle -= 2 * M_PI;\n    }\n    return angle;\n}", "CodeBleu_score": 46.16066355612804}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t// find the min and max x and y coordinates\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\t// calculate the integral above and below the polygon section\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (double x = min_x; x <= max_x; x += 0.1) {\n\t\tfor (double y = min_y; y <= max_y; y += 0.1) {\n\t\t\tbool inside = false;\n\t\t\tfor (int i = start; i < end; i++) {\n\t\t\t\tif (((vp1[i].y > y) != (vp1[i + 1].y > y)) && (x < (vp1[i].x - vp1[i + 1].x) * (y - vp1[i + 1].y) / (vp1[i].y - vp1[i + 1].y) + vp1[i + 1].x)) {\n\t\t\t\t\tinside = !inside;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (inside) {\n\t\t\t\tintegral_above += 0.1 * 0.1", "CodeBleu_score": 39.5750021519788}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = std::numeric_limits<int>::max();\n\tint max_x = std::numeric_limits<int>::min();\n\tint min_y = std::numeric_limits<int>::max();\n\tint max_y = std::numeric_limits<int>::min();\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\n\tint area_above = 0;\n\tint area_below = 0;\n\n\tfor (int i = min_x; i <= max_x; i++) {\n\t\tint max_y_above = std::numeric_limits<int>::min();\n\t\tint min_y_below = std::numeric_limits<int>::max();\n\n\t\tfor (int j = start; j <= end; j++) {\n\t\t\tif (vp1[j].x <= i) {\n\t\t\t\tif (vp1[j].y > max_y_above)\n\t\t\t\t\tmax_y_above = vp1[j].y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (vp1[j].y < min_y_below)\n\t\t\t\t\tmin_y_below = vp1[j].y;\n\t\t\t}\n\t\t}\n\n\t\tarea_above += max_y_above - min_y;\n\t\tarea_below += min_y_below - min_y;\n\t}\n\n\treturn area_above < area_below;\n}", "CodeBleu_score": 39.29831991123328}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t// Find the minimum and maximum x and y coordinates of the points in the section\n\tfloat x_min = vp1[start].x;\n\tfloat x_max = vp1[start].x;\n\tfloat y_min = vp1[start].y;\n\tfloat y_max = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < x_min)\n\t\t\tx_min = vp1[i].x;\n\t\telse if (vp1[i].x > x_max)\n\t\t\tx_max = vp1[i].x;\n\t\tif (vp1[i].y < y_min)\n\t\t\ty_min = vp1[i].y;\n\t\telse if (vp1[i].y > y_max)\n\t\t\ty_max = vp1[i].y;\n\t}\n\t// Compute the integral above and below the polygon section\n\tfloat integral_above = 0;\n\tfloat integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].y >= y_min && vp1[i].y <= y_max) {\n\t\t\tif (vp1[i].y == y_min)\n\t\t\t\tintegral_above += (vp1[i].x - x_min) * (y_max - y_min);\n\t\t\telse if (vp1[i].y == y_max)\n\t\t\t\tintegral_above += (x_max - vp1[i].x) * (y_max - y_min);\n\t\t\telse\n\t\t\t\tintegral_above += (vp1[i].x - x_min) * (vp1[i].y - y_min);\n\t\t}\n\t\tif (vp1[i].y >= y_min && vp1[i].y <= y_max) {\n\t\t\tif (vp1[i].y == y_min)\n\t\t", "CodeBleu_score": 35.92911513024265}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    // ROS_INFO(\"[vision_node]: get a ellipse_det msg.\");\n    int num_det = msg->num_objs;\n    if (num_det > 0) {\n        for (int i = 0; i < num_det; i++) {\n            if (msg->objs[i].name == \"T\") {\n                ellipse_det.is_detected = true;\n                ellipse_det.num_regain++;\n                ellipse_det.num_lost = 0;\n                ellipse_det.position = msg->objs[i].position;\n                ellipse_det.sight_angle = msg->objs[i].sight_angle;\n                ellipse_det.sight_angle_hori = msg->objs[i].sight_angle_hori;\n                ellipse_det.sight_angle_vert = msg->objs[i].sight_angle_vert;\n                ellipse_det.size = msg->objs[i].size;\n                break;\n            }\n        }\n    } else {\n        ellipse_det.is_detected = false;\n        ellipse_det.num_lost++;\n        ellipse_det.num_regain = 0;\n    }\n    if (ellipse_det.num_lost > VISION_THRES) {\n        ellipse_det.is_detected = false;\n    }\n    if (ellipse_det.num_regain > VISION_THRES) {\n        ellipse_det.is_detected = true;\n    }\n    swap(ellipse_det.sight_angle_hori, ellipse_det.sight_angle_vert);\n}", "CodeBleu_score": 40.17525025567572}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    // \u83b7\u53d6\u68c0\u6d4b\u76ee\u6807\u4fe1\u606f\n    for (int i = 0; i < msg->detected_info.size(); i++) {\n        if (msg->detected_info[i].name == \"T\") {\n            if (ellipse_det.is_detected == false) {\n                num_regain++;\n                num_lost = 0;\n                if (num_regain > VISION_THRES) {\n                    ellipse_det.is_detected = true;\n                    ellipse_det.position[0] = msg->detected_info[i].position[0];\n                    ellipse_det.position[1] = msg->detected_info[i].position[1];\n                    ellipse_det.position[2] = msg->detected_info[i].position[2];\n                    ellipse_det.sight_angle[0] = msg->detected_info[i].sight_angle[0];\n                    ellipse_det.sight_angle[1] = msg->detected_info[i].sight_angle[1];\n                    ellipse_det.sight_angle[2] = msg->detected_info[i].sight_angle[2];\n                    ellipse_det.detect_num = msg->detected_info[i].detect_num;\n                    ellipse_det.detect_info = msg->detected_info[i].detect_info;\n                    // \u4ea4\u6362\u89c6\u89d2\n                    ellipse_det.sight_angle[0] = msg->detected_info[i].sight_angle[1];\n                    ellipse_det.sight_angle[1] = msg->detected_info[i].sight_angle[0];\n                    ellipse_det.sight_angle[2] = msg->detected_info[i].sight_angle[2];\n                }\n            }\n        } else {\n            if (ellipse_det.is_detected == true) {\n                num_regain = 0;\n                num_lost++;\n                if (num_lost > VISION_TH", "CodeBleu_score": 48.54313426749097}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    if (msg->detected_infos.size() == 0) {\n        return;\n    }\n    for (int i = 0; i < msg->detected_infos.size(); i++) {\n        if (msg->detected_infos[i].name == \"T\") {\n            if (ellipse_det.is_detected) {\n                ellipse_det.num_regain++;\n                ellipse_det.num_lost = 0;\n            } else {\n                ellipse_det.num_regain = 1;\n                ellipse_det.num_lost = 0;\n            }\n            ellipse_det.is_detected = true;\n            ellipse_det.position[0] = msg->detected_infos[i].position[0];\n            ellipse_det.position[1] = msg->detected_infos[i].position[1];\n            ellipse_det.position[2] = msg->detected_infos[i].position[2];\n            ellipse_det.sight_angle[0] = msg->detected_infos[i].sight_angle[0];\n            ellipse_det.sight_angle[1] = msg->detected_infos[i].sight_angle[1];\n            ellipse_det.sight_angle[2] = msg->detected_infos[i].sight_angle[2];\n            ellipse_det.detect_num = msg->detected_infos[i].detect_num;\n            ellipse_det.detect_info = msg->detected_infos[i].detect_info;\n            break;\n        }\n    }\n    if (!ellipse_det.is_detected) {\n        ellipse_det.num_lost++;\n        if (ellipse_det.num_lost > VISION_THRES) {\n            ellipse_det.is_detected = false;\n        }\n    }\n    if (ellipse_det.is_detected) {\n        ellipse_det.num_regain++;\n        if (ellipse_det.num_regain > VISION_", "CodeBleu_score": 34.878289896051506}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  Eigen::Vector3d cur_pos_grid;\n  cur_pos_grid = pos_checker_ptr_->posToOccupyGridIndex(cur_pos);\n  if (cur_pos_grid(0) >= 0 && cur_pos_grid(1) >= 0 && cur_pos_grid(0) < occupy_map_ptr_->getSizeX() && cur_pos_grid(1) < occupy_map_ptr_->getSizeY()) {\n    if (occupy_map_ptr_->getOccupancy(cur_pos_grid(0), cur_pos_grid(1))) {\n      return false;\n    }\n  }\n\n  for (double i = -safe_distance; i <= safe_distance; i += safe_distance / 5) {\n    for (double j = -safe_distance; j <= safe_distance; j += safe_distance / 5) {\n      cur_pos_grid(0) = cur_pos(0) + i;\n      cur_pos_grid(1) = cur_pos(1) + j;\n      cur_pos_grid(2) = cur_pos(2);\n      if (cur_pos_grid(0) >= 0 && cur_pos_grid(1) >= 0 && cur_pos_grid(0) < occupy_map_ptr_->getSizeX() && cur_pos_grid(1) < occupy_map_ptr_->getSizeY()) {\n        if (occupy_map_ptr_->getOccupancy(cur_pos_grid(0), cur_pos_grid(1))) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 39.429018272024194}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\n  double safe_distance_sq = safe_distance * safe_distance;\n  Eigen::Vector3d temp_vec;\n\n  for (int i = 0; i < 3; ++i) {\n    temp_vec(i) = cur_pos(i);\n  }\n\n  if (Occupy_map_ptr->check_safety(temp_vec, safe_distance_sq)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 44.79926952331004}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // check whether the current position is safe\n    // check the safety of the current position\n    bool is_safety = true;\n    // check the safety of the current position\n    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        is_safety = true;\n    } else {\n        is_safety = false;\n    }\n    return is_safety;\n}", "CodeBleu_score": 58.90317551996531}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node != start_node_) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->getParent();\n    }\n    path_nodes_.push_back(start_node_);\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.33214866175332}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    path_nodes_.clear();\n    path_nodes_.push_back(end_node);\n    while (end_node->parent != nullptr) {\n        end_node = end_node->parent;\n        path_nodes_.push_back(end_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 52.26396134982261}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent_ != nullptr) {\n        current_node = current_node->parent_;\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 66.99965731240896}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // Get the position and height of the neighboring UGV\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    // Check if the neighboring UGV is within 5 meters of the start position\n    if (simulation_mode) {\n        double distance = sqrt(pow(state_nei[id][0] - start_x, 2) + pow(state_nei[id][1] - start_y, 2));\n        if (distance > 5) {\n            get_nei_state = false;\n        }\n        else {\n            get_nei_state = true;\n        }\n    }\n\n}", "CodeBleu_score": 45.72030962241484}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    // Get the position and height of the neighboring UGV\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    // Check if the distance from the start position exceeds 5 meters\n    if (simulation_mode && (sqrt(pow(state_nei[id][0] - state_start[0], 2) + pow(state_nei[id][1] - state_start[1], 2)) > 5)) {\n        get_nei_state = false;\n    }\n    else {\n        get_nei_state = true;\n    }\n}", "CodeBleu_score": 41.867172383231704}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    if (simulation_mode) {\n        double distance = sqrt(pow(odom->pose.pose.position.x - start_x, 2) + pow(odom->pose.pose.position.y - start_y, 2));\n        if (distance > 5) {\n            get_nei_state = false;\n        }\n        else {\n            get_nei_state = true;\n        }\n    }\n}", "CodeBleu_score": 47.24746688162772}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_count++;\n    if (update_count % 5 == 0) {\n        update_count = 0;\n        astar_search.update_map(msg);\n    }\n}", "CodeBleu_score": 56.362741408034665}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_count++;\n    if (update_count < 5) {\n        return;\n    }\n    update_count = 0;\n    // Update the map\n    astar_planner.updateMap(msg);\n}", "CodeBleu_score": 56.97985490058923}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        update_counter = 0;\n        update_map(msg);\n    }\n}", "CodeBleu_score": 56.74881254350679}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n  if (get_gpcl) {\n    get_gpcl = false;\n    pcl::PointCloud<pcl::PointXYZ> latest_global_pcl;\n    pcl::fromROSMsg(*global_point, latest_global_pcl);\n    global_pcl = latest_global_pcl;\n    has_global_point = true;\n    inflate_global_pcl();\n  }\n}", "CodeBleu_score": 58.35692587483994}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::fromROSMsg(*global_point, *global_map_pcl);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_map_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::VoxelGrid<pcl::PointXYZ> sor;\n        sor.setInputCloud(global_map_pcl);\n        sor.setLeafSize(leaf_size, leaf_size, leaf_size);\n        sor.filter(*global_map_pcl_ptr);\n        global_map_pcl = global_map_pcl_ptr;\n        inflate_point_cloud(global_map_pcl, global_map_pcl, inflate_distance);\n    }\n}", "CodeBleu_score": 53.02044915786005}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n  if (!get_gpcl) {\n    get_gpcl = true;\n\n    pcl::PointCloud<pcl::PointXYZ> latest_global_pcl;\n    pcl::fromROSMsg(*global_point, latest_global_pcl);\n    global_pcl = latest_global_pcl;\n\n    global_pcl_inflate();\n  }\n}", "CodeBleu_score": 55.07318246216253}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // 1. convert laser scan to pointcloud\n    sensor_msgs::PointCloud2 cloud;\n    projector_.projectLaser(*local_point, cloud);\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_points;\n    pcl::fromROSMsg(cloud, latest_scan_points);\n\n    // 2. get robot pose\n    geometry_msgs::Pose robot_pose;\n    if (simulation_mode_) {\n        robot_pose = odom.pose.pose;\n    } else {\n        robot_pose = odom.pose.pose;\n    }\n\n    // 3. update occupancy map\n    pcl::PointXYZ p;\n    for (size_t i = 0; i < latest_scan_points.points.size(); ++i) {\n        p = latest_scan_points.points[i];\n        // 3.1 convert to map frame\n        p = map_util_.convert_to_map_frame(p, robot_pose);\n        // 3.2 update occupancy map\n        map_util_.update_occupancy_map(p, occupancy_buffer_, inflate_);\n    }\n\n}", "CodeBleu_score": 48.947475257082054}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    pcl::PointCloud<pcl::PointXYZ> local_map;\n    pcl::PointCloud<pcl::PointXYZ> cloud_temp;\n    pcl::PointXYZ point;\n\n    // Transform the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 cloud;\n    projector_.projectLaser(*local_point, cloud);\n\n    // Convert the PointCloud2 format to a pcl::PointCloud\n    pcl::PCLPointCloud2 pcl_pc2;\n    pcl_conversions::toPCL(cloud, pcl_pc2);\n    pcl::PointCloud<pcl::PointXYZ> cloud_in;\n    pcl::fromPCLPointCloud2(pcl_pc2, cloud_in);\n\n    // If not in simulation mode, merge the local map with the odometry data\n    if (!simulation_mode_) {\n        double theta = tf::getYaw(odom.pose.pose.orientation);\n        double x_odom = odom.pose.pose.position.x;\n        double y_odom = odom.pose.pose.position.y;\n\n        // Merge the local map with the odometry data\n        for (int i = 0; i < cloud_in.points.size(); ++i) {\n            point.x = cloud_in.points[i].x + x_odom;\n            point.y = cloud_in.points[i].y + y_odom;\n            point.z = cloud_in.points[i].z;\n            cloud_temp.points.push_back(point);\n        }\n\n        // Transform the point cloud into the map frame\n        pcl::PointCloud<pcl::PointXYZ> cloud_out;\n        pcl_ros::transformPointCloud(map_frame_, cloud_temp, cloud_out, listener_);\n\n        // Merge the local map with the global map\n        local_map += cloud_out;\n    }\n    else {\n        local_map = cloud_in;\n    }\n\n    // Update the occupancy map\n    map_update(local_map);\n}", "CodeBleu_score": 48.201040451709595}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    // ROS_INFO(\"Enter map_update_laser\");\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::PointXYZ pt;\n    // ROS_INFO(\"Enter map_update_laser\");\n    for (int i = 0; i < local_point->ranges.size(); i++) {\n        if (local_point->ranges[i] < local_point->range_min || local_point->ranges[i] > local_point->range_max)\n            continue;\n        double angle = local_point->angle_min + i * local_point->angle_increment;\n        pt.x = local_point->ranges[i] * cos(angle);\n        pt.y = local_point->ranges[i] * sin(angle);\n        pt.z = 0;\n        cloud.points.push_back(pt);\n    }\n    // ROS_INFO(\"Enter map_update_laser\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr map_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n    // ROS_INFO(\"Enter map_update_laser\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr map_ptr_transed(new pcl::PointCloud<pcl::PointXYZ>);\n    // ROS_INFO(\"Enter map_update_laser\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr map_ptr_transed_origin(new pcl::PointCloud<pcl::PointXYZ>);\n    // ROS_INFO(\"Enter map_update_laser\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr map_ptr_transed_origin_all(new pcl::PointCloud<pcl::PointXYZ>);\n    // ROS_INFO(\"Enter map_update_laser\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr map_ptr_transed_origin_all_downsample(new pcl::PointCloud<pcl::PointXYZ>);\n    // ROS_INFO(\"Enter map_update_laser\");\n   ", "CodeBleu_score": 42.03086353154449}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Publish the global map\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Publish the inflated global map\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 66.12705924365557}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n    // 1. Publish global point cloud\n    sensor_msgs::PointCloud2 global_pcl;\n    pcl::toROSMsg(*global_pcl_map, global_pcl);\n    global_pcl.header.frame_id = \"world\";\n    global_pcl.header.stamp = ros::Time::now();\n    global_pcl_pub.publish(global_pcl);\n\n    // 2. Publish inflated point cloud\n    sensor_msgs::PointCloud2 inflate_pcl;\n    pcl::toROSMsg(*inflate_pcl_map, inflate_pcl);\n    inflate_pcl.header.frame_id = \"world\";\n    inflate_pcl.header.stamp = ros::Time::now();\n    inflate_pcl_pub.publish(inflate_pcl);\n\n}", "CodeBleu_score": 60.37765311516517}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    sensor_msgs::PointCloud2 global_pcl;\n    sensor_msgs::PointCloud2 inflate_pcl;\n\n    pcl::toROSMsg(*global_map_pcl_, global_pcl);\n    global_pcl.header.frame_id = \"world\";\n    global_pcl.header.stamp = ros::Time::now();\n    global_pcl_pub_.publish(global_pcl);\n\n    pcl::toROSMsg(*inflate_map_pcl_, inflate_pcl);\n    inflate_pcl.header.frame_id = \"world\";\n    inflate_pcl.header.stamp = ros::Time::now();\n    inflate_pcl_pub_.publish(inflate_pcl);\n}", "CodeBleu_score": 60.312392500726084}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    // ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\n    if (sensor_ready) {\n        return;\n    }\n\n    // ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready = true\");\n    sensor_ready = true;\n\n    // ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: astar_ptr->update_map\");\n    astar_ptr->update_map(msg);\n}", "CodeBleu_score": 59.71591021758014}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    //ROS_INFO(\"Point cloud received\");\n    //ROS_INFO(\"Size of point cloud: %d\", msg->width);\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n\n    //ROS_INFO(\"Size of cloud: %d\", cloud->points.size());\n\n    if (sensor_ready) {\n\n        //ROS_INFO(\"Sensor ready\");\n\n        // Create a search tree, use KDTreee for non-organized data.\n        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);\n\n        // Set the input point cloud for the search tree\n        tree->setInputCloud(cloud);\n\n        // Initialize objects\n        pcl::PointXYZ searchPoint;\n        std::vector<int> pointIdxNKNSearch(1);\n        std::vector<float> pointNKNSquaredDistance(1);\n\n        // Initialize the map\n        if (map.size() == 0) {\n            for (int i = 0; i < 1000; i++) {\n                std::vector<int> temp;\n                map.push_back(temp);\n            }\n        }\n\n        // Iterate through point cloud\n        for (int i = 0; i < cloud->points.size(); i++) {\n\n            searchPoint.x = cloud->points[i].x;\n            searchPoint.y = cloud->points[i].y;\n            searchPoint.z = cloud->points[i].z;\n\n            // Find the nearest neighbor\n            tree->nearestKSearch(searchPoint, 1, pointIdxNKNSearch, pointNKNSquaredDistance);\n\n            // Get the index of the nearest neighbor\n            int index = pointIdxNKNSearch[0];\n\n            // Get the x, y, and z coordinates of the nearest neighbor\n            float x = cloud->points[index].x;\n            float y = cloud->points[index].", "CodeBleu_score": 39.232752755514746}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*msg, cloud);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_filtered_voxel(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_filtered_voxel_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_filtered_voxel_downsampled_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\n    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n    voxel_grid.setInputCloud(cloud_ptr);\n    voxel_grid.setLeafSize(0.05, 0.05, 0.05);\n    voxel_grid.filter(*cloud_ptr_filtered_voxel);\n\n    pcl::PassThrough<pcl::PointXYZ> pass;\n    pass.setInputCloud(cloud_ptr_filtered_voxel);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 1.0);\n    pass.filter(*cloud_ptr_filtered_voxel_downsampled);\n\n    pcl::PassThrough<pcl::PointXYZ> pass2;\n    pass2.setInputCloud(cloud_ptr_filtered_voxel_downsampled);\n    pass2.setFilterFieldName(\"y\");\n    pass2.setFilterLimits(-0.5, 0.5);\n    pass2.filter(*cloud_ptr_filtered", "CodeBleu_score": 36.08601552890055}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Get current time\n    ros::Time current_time = ros::Time::now();\n\n    // Get current joint positions\n    std::vector<double> joint_positions;\n    joint_positions.resize(12);\n    for (int i = 0; i < 12; i++) {\n        joint_positions[i] = joint_states_.position[i];\n    }\n\n    // Get current joint velocities\n    std::vector<double> joint_velocities;\n    joint_velocities.resize(12);\n    for (int i = 0; i < 12; i++) {\n        joint_velocities[i] = joint_states_.velocity[i];\n    }\n\n    // Get current base position\n    Eigen::Vector3d base_position;\n    base_position << base_state_.pose.position.x, base_state_.pose.position.y, base_state_.pose.position.z;\n\n    // Get current base orientation\n    Eigen::Quaterniond base_orientation;\n    base_orientation.w() = base_state_.pose.orientation.w;\n    base_orientation.x() = base_state_.pose.orientation.x;\n    base_orientation.y() = base_state_.pose.orientation.y;\n    base_orientation.z() = base_state_.pose.orientation.z;\n\n    // Get current base velocity\n    Eigen::Vector3d base_velocity;\n    base_velocity << base_state_.twist.linear.x, base_state_.twist.linear.y, base_state_.twist.linear.z;\n\n    // Get current base angular velocity\n    Eigen::Vector3d base_angular_velocity;\n    base_angular_velocity << base_state_.twist.angular.x, base_state_.twist.angular.y, base_state_.twist.angular.z;\n\n    // Get current base acceleration\n    Eigen::Vector3d base_acceleration;\n    base_acceleration << base_state_.accel.linear.x, base_state_.accel.linear.y, base_state_.accel.", "CodeBleu_score": 38.95557127193346}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n  // Get current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get current pose of the quadruped\n  quadruped_.getPose(current_position_);\n\n  // Calculate target foot positions based on desired pose\n  body_controller_.calculateTargetFootPositions(desired_position_, current_position_, target_foot_positions_);\n\n  // Calculate velocity commands for the legs\n  body_controller_.calculateVelocityCommands(target_foot_positions_, current_position_, current_time, velocity_commands_);\n\n  // Perform inverse kinematics to determine target joint positions\n  body_controller_.performInverseKinematics(target_foot_positions_, current_position_, current_time, target_joint_positions_);\n\n  // Publish foot contact information\n  quadruped_.publishFootContacts(current_position_);\n\n  // Publish joint positions\n  quadruped_.publishJointPositions(target_joint_positions_);\n\n}", "CodeBleu_score": 46.324133664671336}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n  // Get current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get current joint positions\n  joint_positions_ = joint_state_interface_.getPosition();\n\n  // Get current body pose\n  body_pose_ = body_pose_interface_.getPose();\n\n  // Get current body twist\n  body_twist_ = body_twist_interface_.getTwist();\n\n  // Get current foot positions\n  for (int i = 0; i < 4; i++) {\n    foot_positions_[i] = foot_pose_interface_[i].getPosition();\n  }\n\n  // Get current foot twists\n  for (int i = 0; i < 4; i++) {\n    foot_twists_[i] = foot_twist_interface_[i].getTwist();\n  }\n\n  // Get current foot contact states\n  for (int i = 0; i < 4; i++) {\n    foot_contact_states_[i] = foot_contact_interface_[i].getContactState();\n  }\n\n  // Get current foot force/torque measurements\n  for (int i = 0; i < 4; i++) {\n    foot_ft_[i] = foot_ft_interface_[i].getWrench();\n  }\n\n  // Get current imu measurement\n  imu_data_ = imu_interface_.getData();\n\n  // Get current joint velocities\n  joint_velocities_ = joint_velocity_interface_.getVelocity();\n\n  // Get current joint torques\n  joint_torques_ = joint_effort_interface_.getEffort();\n\n  // Get current leg length\n  leg_length_ = body_dimensions_interface_.getLegLength();\n\n  // Get current leg radius\n  leg_radius_ = body_dimensions_interface_.getLegRadius();\n\n  // Get current body dimensions\n  body_dimensions_ = body_dimensions_interface_.getBodyDimensions();\n\n  // Get current body mass\n  body_mass_ = body_dimensions_interface_.getBodyMass();\n\n  //", "CodeBleu_score": 34.80933645390157}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (foot_contacts_publisher_ && !gazebo_) {\n        contact_states_msg_.header.stamp = ros::Time::now();\n        contact_states_msg_.states.resize(4);\n        for (int i = 0; i < 4; i++) {\n            contact_states_msg_.states[i].state = foot_contacts[i];\n        }\n        foot_contacts_publisher_.publish(contact_states_msg_);\n    }\n}", "CodeBleu_score": 53.81453949108624}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0 && !gazebo_simulation_) {\n    quad_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = \"odom\";\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i] = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 58.27149482076358}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_ != NULL && !gazebo_) {\n    // Create the message\n    sensor_msgs::ContactsStamped contacts;\n    contacts.header.stamp = ros::Time::now();\n    contacts.header.frame_id = \"world\";\n    for (int i = 0; i < 4; i++) {\n      sensor_msgs::ContactState contact;\n      contact.header.stamp = ros::Time::now();\n      contact.header.frame_id = \"world\";\n      contact.collision_name = foot_contact_names_[i];\n      contact.contact_positions.resize(1);\n      contact.contact_normals.resize(1);\n      contact.contact_positions[0].x = 0.0;\n      contact.contact_positions[0].y = 0.0;\n      contact.contact_positions[0].z = 0.0;\n      contact.contact_normals[0].x = 0.0;\n      contact.contact_normals[0].y = 0.0;\n      contact.contact_normals[0].z = 0.0;\n      contact.depth = 0.0;\n      contact.state = foot_contacts[i];\n      contacts.states.push_back(contact);\n    }\n    // Publish the message\n    foot_contacts_publisher_.publish(contacts);\n  }\n}", "CodeBleu_score": 44.18002995877806}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t# Create a JointState message\n\tmsg = JointState()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.name = self.joint_names\n\tmsg.position = joints.positions\n\n\t# Publish the JointState message\n\tself.pub_joints.publish(msg)\n\n\t# Create a JointTrajectory message\n\ttraj_msg = JointTrajectory()\n\ttraj_msg.header.stamp = rospy.Time.now()\n\ttraj_msg.joint_names = self.joint_names\n\ttraj_msg.points.append(JointTrajectoryPoint())\n\ttraj_msg.points[0].positions = joints.positions\n\ttraj_msg.points[0].time_from_start = rospy.Duration(self.traj_duration)\n\n\t# Publish the JointTrajectory message\n\tself.pub_traj.publish(traj_msg)\n\n", "CodeBleu_score": 44.6543372164501}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create joints message\n    js_msg = JointState()\n    js_msg.header.stamp = rospy.Time.now()\n    js_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    js_msg.position = joints.position\n\n    # Publish joints message\n    self.pub_joints.publish(js_msg)\n\n    # Create joint trajectory message\n    jt_msg = JointTrajectory()\n    jt_msg.header.stamp = rospy.Time.now()\n    jt_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    jt_msg.points.append(JointTrajectoryPoint())\n    jt_msg.points[0].positions = joints.position\n    jt_msg.points[0].time_from_start = rospy.Duration(self.traj_duration)\n\n    # Publish joint trajectory message\n    self.pub_traj.publish(jt_msg)\n\n", "CodeBleu_score": 43.18858337661203}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create joints message\n    joints_msg = JointState()\n    joints_msg.name = joints.name\n    joints_msg.position = joints.position\n    joints_msg.header.stamp = rospy.Time.now()\n\n    # Publish joints message\n    self.joints_pub.publish(joints_msg)\n\n    # Create joint trajectory message\n    traj_msg = JointTrajectory()\n    traj_msg.header.stamp = rospy.Time.now()\n    traj_msg.joint_names = joints.name\n\n    # Create trajectory point\n    traj_pt = JointTrajectoryPoint()\n    traj_pt.positions = joints.position\n    traj_pt.time_from_start = rospy.Duration.from_sec(self.traj_duration)\n\n    # Add trajectory point to trajectory message\n    traj_msg.points.append(traj_pt)\n\n    # Publish trajectory message\n    self.traj_pub.publish(traj_msg)\n\n", "CodeBleu_score": 50.854467823976115}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    for (int i = 0; i < _msg->contact_size(); ++i) {\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n\n        std::vector<std::string> collision1_vec;\n        boost::split(collision1_vec, collision1, boost::is_any_of(\"::\"));\n\n        std::vector<std::string> collision2_vec;\n        boost::split(collision2_vec, collision2, boost::is_any_of(\"::\"));\n\n        if (collision1_vec.size() < 2 || collision2_vec.size() < 2) {\n            continue;\n        }\n\n        std::string collision1_link = collision1_vec[collision1_vec.size() - 1];\n        std::string collision2_link = collision2_vec[collision2_vec.size() - 1];\n\n        for (int j = 0; j < 4; ++j) {\n            if (collision1_link == \"foot_\" + std::to_string(j) + \"_collision\" ||\n                collision2_link == \"foot_\" + std::to_string(j) + \"_collision\") {\n                ROS_INFO(\"Foot %d is in contact\", j);\n            }\n        }\n    }\n}", "CodeBleu_score": 46.01675234945266}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n    for (int i = 0; i < _msg->contact_size(); ++i) {\n        std::string collision1_name = _msg->contact(i).collision1();\n        std::string collision2_name = _msg->contact(i).collision2();\n\n        std::vector<std::string> v1;\n        std::vector<std::string> v2;\n\n        boost::split(v1, collision1_name, boost::is_any_of(\"::\"));\n        boost::split(v2, collision2_name, boost::is_any_of(\"::\"));\n\n        std::string link1_name = v1[v1.size() - 1];\n        std::string link2_name = v2[v2.size() - 1];\n\n        if (link1_name.find(\"_foot\") != std::string::npos) {\n            if (link1_name.find(\"left\") != std::string::npos) {\n                left_contact = true;\n            } else {\n                right_contact = true;\n            }\n        }\n\n        if (link2_name.find(\"_foot\") != std::string::npos) {\n            if (link2_name.find(\"left\") != std::string::npos) {\n                left_contact = true;\n            } else {\n                right_contact = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 41.94091353543081}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // ROS_INFO(\"Gazebo callback\");\n    // ROS_INFO_STREAM(\"Gazebo callback, msg: \" << _msg->DebugString());\n\n    // initialize all foot contacts to false\n    for (int i = 0; i < 4; i++) {\n        foot_contacts_[i] = false;\n    }\n\n    // process contacts\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::string collision1_name = _msg->contact(i).collision1();\n        std::string collision2_name = _msg->contact(i).collision2();\n\n        std::vector<std::string> collision1_split;\n        std::vector<std::string> collision2_split;\n        boost::split(collision1_split, collision1_name, boost::is_any_of(\"::\"));\n        boost::split(collision2_split, collision2_name, boost::is_any_of(\"::\"));\n\n        std::string collision1_link_name = collision1_split[collision1_split.size() - 1];\n        std::string collision2_link_name = collision2_split[collision2_split.size() - 1];\n\n        // ROS_INFO_STREAM(\"Collision1: \" << collision1_link_name);\n        // ROS_INFO_STREAM(\"Collision2: \" << collision2_link_name);\n\n        // check if either collision is a foot link\n        for (int j = 0; j < 4; j++) {\n            if (collision1_link_name == foot_collision_names_[j] || collision2_link_name == foot_collision_names_[j]) {\n                foot_contacts_[j] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 61.68049984319809}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == kRotorQuantity_);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kRotorQuantity_);\n    return;\n  }\n\n  double thrust;\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d angular_acceleration;\n  Eigen::Vector3d thrust_vector;\n\n  CalculateDesiredAcceleration(&desired_acceleration);\n  CalculateAngularAcceleration(&angular_acceleration);\n  CalculateThrust(&thrust);\n  CalculateThrustVector(&thrust_vector, thrust);\n\n  Eigen::Vector3d total_force = thrust_vector + desired_acceleration + angular_acceleration;\n\n  Eigen::MatrixXd moment_of_inertia_matrix =\n      Eigen::MatrixXd::Zero(kRotorQuantity_, kRotorQuantity_);\n  Eigen::VectorXd moment_of_inertia_vector = Eigen::VectorXd::Zero(kRotorQuantity_);\n\n  CalculateMomentOfInertiaMatrix(&moment_of_inertia_matrix);\n  CalculateMomentOfInertiaVector(total_force, &moment_of_inertia_vector);\n\n  Eigen::VectorXd rotor_forces =\n      moment_of_inertia_matrix.colPivHouseholderQr().solve(moment_of_inertia_vector);\n\n  assert(!rotor_forces.hasNaN());\n  assert(rotor_forces.size() == kRotorQuantity_);\n\n  for (int i = 0; i < kRotorQuantity_; i++) {\n    if (rotor_forces(i) < 0.0) {\n      rotor_forces(i) = 0.0;\n    }\n  }\n\n  *rotor_velocities = rotor_forces.cwiseS", "CodeBleu_score": 47.54528497410412}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == 4);\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n  assert(std::isfinite(_vehicle_parameters.rotor_arm_length));\n ", "CodeBleu_score": 21.906438452044224}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == 4);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::Vector4d::Zero(4);\n    return;\n  }\n\n  assert(mass_ > 0);\n  assert(inertia_.x() > 0);\n  assert(inertia_.y() > 0);\n  assert(inertia_.z() > 0);\n\n  assert(arm_length_ > 0);\n  assert(rotor_force_constant_ > 0);\n  assert(rotor_moment_constant_ > 0);\n\n  assert(thrust_coefficient_ > 0);\n  assert(drag_coefficient_ > 0);\n  assert(angular_drag_coefficient_ > 0);\n\n  assert(max_rotor_thrust_ > 0);\n  assert(max_rotor_speed_ > 0);\n\n  assert(thrust_ > 0);\n\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n\n  desired_acceleration << 0, 0, -thrust_ / mass_;\n\n  desired_angular_acceleration << 0, 0, 0;\n\n  Eigen::Vector3d rotor_thrust;\n  rotor_thrust << 0, 0, thrust_;\n\n  Eigen::Vector3d rotor_torque;\n  rotor_torque << 0, 0, 0;\n\n  Eigen::Vector3d rotor_force;\n  rotor_force << 0, 0, 0;\n\n  Eigen::Vector3d rotor_moment;\n  rotor_moment << 0, 0, 0;\n\n  Eigen::Matrix3d rotor_force_matrix;\n  rotor_force_matrix << 0, -rotor_force_constant_, rotor_force_constant_,\n      rotor_force_constant_, 0, -rotor_force_", "CodeBleu_score": 43.73342932522979}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n\n  // Get the current vehicle position and velocity.\n  Eigen::Vector3d current_position;\n  Eigen::Vector3d current_velocity;\n  GetCurrentPositionAndVelocity(&current_position, &current_velocity);\n\n  // Get the current vehicle attitude.\n  Eigen::Quaterniond current_attitude;\n  GetCurrentAttitude(&current_attitude);\n\n  // Get the current vehicle angular velocity.\n  Eigen::Vector3d current_angular_velocity;\n  GetCurrentAngularVelocity(&current_angular_velocity);\n\n  // Get the current vehicle acceleration.\n  Eigen::Vector3d current_acceleration;\n  GetCurrentAcceleration(&current_acceleration);\n\n  // Get the current vehicle attitude.\n  Eigen::Quaterniond current_attitude;\n  GetCurrentAttitude(&current_attitude);\n\n  // Get the current vehicle angular velocity.\n  Eigen::Vector3d current_angular_velocity;\n  GetCurrentAngularVelocity(&current_angular_velocity);\n\n  // Get the current vehicle acceleration.\n  Eigen::Vector3d current_acceleration;\n  GetCurrentAcceleration(&current_acceleration);\n\n  // Get the current vehicle attitude.\n  Eigen::Quaterniond current_attitude;\n  GetCurrentAttitude(&current_attitude);\n\n  // Get the current vehicle angular velocity.\n  Eigen::Vector3d current_angular_velocity;\n  GetCurrentAngularVelocity(&current_angular_velocity);\n\n  // Get the current vehicle acceleration.\n  Eigen::Vector3d current_acceleration;\n  GetCurrentAcceleration(&current_acceleration);\n\n  // Get the current vehicle attitude.\n  Eigen::Quaterniond current_attitude;\n  GetCurrentAttitude(&current_attitude);\n\n  // Get the current vehicle angular velocity.\n  Eigen::Vector3d current_angular_velocity;\n  GetCurrentAngularVelocity(&current_angular_velocity);\n\n  // Get the current vehicle acceleration.\n", "CodeBleu_score": 34.91630700765443}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n\n  // Position error.\n  Eigen::Vector3d position_error = command_trajectory_.position_W - odometry_.position;\n\n  // Velocity error.\n  Eigen::Vector3d velocity_error_W = command_trajectory_.velocity_W - odometry_.velocity;\n\n  // Transform velocity error to world frame.\n  Eigen::Vector3d velocity_error_B = Eigen::Vector3d(rotor_velocities_[0], rotor_velocities_[1], rotor_velocities_[2]);\n  Eigen::Matrix3d rot = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_error = rot.transpose() * velocity_error_B;\n\n  // Desired acceleration.\n  Eigen::Vector3d desired_acceleration = position_gains_.asDiagonal() * position_error +\n                                        velocity_gains_.asDiagonal() * velocity_error +\n                                        mass_ * gravity_ +\n                                        command_trajectory_.acceleration_W;\n\n  // Desired acceleration in body frame.\n  Eigen::Vector3d desired_acceleration_B = rot * desired_acceleration;\n\n  // Desired acceleration in rotor frame.\n  Eigen::Vector3d desired_acceleration_R = Eigen::Vector3d(desired_acceleration_B[0] - rotor_velocities_[0] * rotor_velocities_[0] / 2.0,\n                                                          desired_acceleration_B[1] - rotor_velocities_[1] * rotor_velocities_[1] / 2.0,\n                                                          desired_acceleration_B[2] - rotor_velocities_[2] * rotor_velocities_[2] / 2.0);\n\n  // Desired acceleration in rotor frame.\n  *acceleration = desired_acceleration_R;\n}", "CodeBleu_score": 48.65225117996995}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n\n  // Position error.\n  Eigen::Vector3d position_error = command_trajectory_.GetPositionW() - odometry_.position_W;\n\n  // Velocity error.\n  Eigen::Vector3d velocity_error_W = command_trajectory_.GetVelocityW() - odometry_.velocity_W;\n\n  // Velocity error in the body frame.\n  Eigen::Vector3d velocity_error_B = odometry_.orientation_W_B.inverse() * velocity_error_W;\n\n  // Desired acceleration.\n  Eigen::Vector3d desired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_B;\n\n  // Adjust for mass, gravity, and the commanded acceleration.\n  *acceleration = (desired_acceleration + command_trajectory_.GetAccelerationW()) / mass_ - gravity_;\n}", "CodeBleu_score": 44.452741066004876}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(thrust_);\n  assert(angular_rates_);\n  assert(attitude_);\n\n  // Resize rotor_velocities.\n  rotor_velocities->resize(rotor_configuration_.getNumMotors());\n\n  // Calculate desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      AttitudeControllerSamy::CalculateDesiredAngularAcc(angular_rates_, thrust_, attitude_);\n\n  // Combine thrust and angular acceleration into a single vector.\n  Eigen::VectorXd thrust_and_desired_angular_acceleration(rotor_configuration_.getNumMotors());\n  thrust_and_desired_angular_acceleration << *thrust_, desired_angular_acceleration;\n\n  // Multiply with predefined matrix.\n  *rotor_velocities = rotor_configuration_.getRotorVelocitiesMatrix() *\n                      thrust_and_desired_angular_acceleration;\n\n  // Ensure that the rotor velocities are at least one.\n  for (int i = 0; i < rotor_configuration_.getNumMotors(); i++) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 1.0);\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 47.725666085956334}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(attitude_);\n  assert(angular_rates_);\n  assert(attitude_thrust_command_);\n\n  if (!attitude_ || !angular_rates_ || !attitude_thrust_command_) return;\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(actuators_.size());\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  angular_acceleration << 0, 0, 0;\n\n  // Compute the desired thrust.\n  double thrust = attitude_thrust_command_->thrust();\n\n  // Combine the desired thrust and angular acceleration into a single vector.\n  Eigen::Vector4d desired_rates;\n  desired_rates << angular_acceleration, thrust;\n\n  // Compute the rotor velocities.\n  *rotor_velocities = actuators_.transpose() * desired_rates;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 1.0);\n  }\n\n  // Compute the square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 49.80473653666233}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(attitude_);\n  assert(angular_rates_);\n  assert(angular_accelerations_);\n  assert(rotor_thrusts_);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(rotor_thrusts_->size());\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration;\n  desired_angular_acceleration << 0.0, 0.0, 0.0;\n  if (angular_accelerations_->norm() > 0.0001) {\n    desired_angular_acceleration = kPIDGainAngular_ * (*angular_accelerations_)\n        + kPIDGainAngularRate_ * (*angular_rates_);\n  }\n\n  // Combine the desired thrust and the desired angular acceleration into a single vector.\n  Eigen::Vector4d combined_desired_thrust_and_angular_acceleration;\n  combined_desired_thrust_and_angular_acceleration << (*rotor_thrusts_)(0),\n      (*rotor_thrusts_)(1), (*rotor_thrusts_)(2), desired_angular_acceleration(2);\n\n  // Compute the rotor velocities.\n  *rotor_velocities = rotor_thrust_to_omega_matrix_ * combined_desired_thrust_and_angular_acceleration;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)(i) < 1.0) {\n      (*rotor_velocities)(i) = 1.0;\n    }\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 50.40706487339992}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    new_object = copy.deepcopy(self)\n    new_object.time = self.time[start_index:end_index]\n    new_object.time_stamp = self.time_stamp[start_index:end_index]\n    new_object.pose_stamped = self.pose_stamped[start_index:end_index]\n    new_object.pose_x = self.pose_x[start_index:end_index]\n    new_object.pose_y = self.pose_y[start_index:end_index]\n    new_object.pose_z = self.pose_z[start_index:end_index]\n    new_object.pose_roll = self.pose_roll[start_index:end_index]\n    new_object.pose_pitch = self.pose_pitch[start_index:end_index]\n    new_object.pose_yaw = self.pose_yaw[start_index:end_index]\n    new_object.velocity_x = self.velocity_x[start_index:end_index]\n    new_object.velocity_y = self.velocity_y[start_index:end_index]\n    new_object.velocity_z = self.velocity_z[start_index:end_index]\n    new_object.angular_velocity_x = self.angular_velocity_x[start_index:end_index]\n    new_object.angular_velocity_y = self.angular_velocity_y[start_index:end_index]\n    new_object.angular_velocity_z = self.angular_velocity_z[start_index:end_index]\n    new_object.acceleration_x = self.acceleration_x[start_index:end_index]\n    new_object.acceleration_y = self.acceleration_y[start_index:end_index]\n    new_object.acceleration_z = self.accel", "CodeBleu_score": 13.211473498777366}, {"code": "def slice(self, start_time, end_time)\n\t\n\n    # Find the indices of the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Slice the attributes of the copied object\n    sliced_object.time = sliced_object.time[start_index:end_index]\n    sliced_object.position = sliced_object.position[start_index:end_index]\n    sliced_object.velocity = sliced_object.velocity[start_index:end_index]\n    sliced_object.acceleration = sliced_object.acceleration[start_index:end_index]\n    sliced_object.jerk = sliced_object.jerk[start_index:end_index]\n    sliced_object.snap = sliced_object.snap[start_index:end_index]\n    sliced_object.crackle = sliced_object.crackle[start_index:end_index]\n    sliced_object.pop = sliced_object.pop[start_index:end_index]\n    sliced_object.position_dot = sliced_object.position_dot[start_index:end_index]\n    sliced_object.velocity_dot = sliced_object.velocity_dot[start_index:end_index]\n    sliced_object.acceleration_dot = sliced_object.acceleration_dot[start_index:end_index]\n    sliced_object.jerk_dot = sliced_object.jerk_dot[start_index:end_index]\n    sliced_object.snap_dot = sliced_object.snap_dot[start_index:end_index]\n    sliced_object.crackle_dot = sliced_object.crackle_dot[start_index:end_index]\n    sliced_object.pop", "CodeBleu_score": 13.490115271955732}, {"code": "def slice(self, start_time, end_time)\n\t\n    if start_time > end_time:\n        raise ValueError('start_time must be less than or equal to end_time')\n    if start_time < self.start_time:\n        raise ValueError('start_time must be greater than or equal to the start_time of the object')\n    if end_time > self.end_time:\n        raise ValueError('end_time must be less than or equal to the end_time of the object')\n\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n\n    if start_index == end_index:\n        raise ValueError('start_time and end_time must be at different indices')\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update the start_time and end_time of the sliced object\n    sliced_object.start_time = start_time\n    sliced_object.end_time = end_time\n\n    # Update the attributes of the sliced object\n    for attribute in sliced_object.__dict__.keys():\n        if isinstance(getattr(sliced_object, attribute), numpy.ndarray):\n            setattr(sliced_object, attribute, getattr(sliced_object, attribute)[start_index:end_index])\n        elif isinstance(getattr(sliced_object, attribute), list):\n            setattr(sliced_object, attribute, getattr(sliced_object, attribute)[start_index:end_index])\n\n    return sliced_object\n\n", "CodeBleu_score": 38.83090871089996}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    quaternion = [rotation.x, rotation.y, rotation.z, rotation.w]\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    point = Point(position.x, position.y, position.z)\n    yaw = euler[2]\n    if (len(self.waypoints) == 0) or (self.waypoints[-1] != point) or (self.yaws[-1] != yaw):\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 28.82550783475446}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion((rotation.x, rotation.y, rotation.z, rotation.w))\n    # Create Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if current waypoint is different from last one\n    if self.waypoints == []:\n        # If no waypoints have been added yet, append waypoint\n        self.waypoints.append(point)\n        self.yaw.append(euler[2])\n        self.waypoint_msg_time.append(msg_time)\n        self.waypoint_bag_time.append(bag_time)\n    else:\n        # If waypoints have been added, compare current waypoint to last one\n        # If current waypoint is different, append waypoint\n        if (self.waypoints[-1].x != point.x or self.waypoints[-1].y != point.y or self.waypoints[-1].z != point.z) or (self.yaw[-1] != euler[2]):\n            self.waypoints.append(point)\n            self.yaw.append(euler[2])\n            self.waypoint_msg_time.append(msg_time)\n            self.waypoint_bag_time.append(bag_time)\n\n", "CodeBleu_score": 35.64568842521473}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion(\n        [rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None:\n        self.last_waypoint = point\n        self.last_yaw = euler[2]\n\n    elif self.last_waypoint.x != point.x or self.last_waypoint.y != point.y or self.last_waypoint.z != point.z or self.last_yaw != euler[2]:\n        self.last_waypoint = point\n        self.last_yaw = euler[2]\n\n        # Append position, yaw, and times to their respective arrays\n        self.waypoints.append(point)\n        self.yaw.append(euler[2])\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 30.924491891305507}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu_raw\":\n        self.imu_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_raw_x.append(msg.linear_acceleration.x)\n        self.imu_raw_y.append(msg.linear_acceleration.y)\n        self.imu_raw_z.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/data\":\n        self.imu_data_time.append(msg.header.stamp.to_sec())\n        self.imu_data_x.append(msg.linear_acceleration.x)\n        self.imu_data_y.append(msg.linear_acceleration.y)\n        self.imu_data_z.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.imu_data_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_data_raw_x.append(msg.linear_acceleration.x)\n        self.imu_data_raw_y.append(msg.linear_acceleration.y)\n        self.imu_data_raw_z.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw_mag\":\n        self.imu_data_raw_mag_time.append(msg.header.stamp.to_sec())\n        self.imu_data_raw_mag_x.append(msg.linear_acceleration.x)\n        self.imu_data_raw_mag_y.append(msg.linear_acceleration.y)\n        self.imu_data_raw_mag_z.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/mag\":\n        self.imu_mag_time.append(msg.header.stamp.to_sec())\n        self.imu_mag_x.append(msg.linear_accel", "CodeBleu_score": 23.880465874414313}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_time_bag.append(bag_time.to_sec())\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.177777637851182}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000)\n        self.imu_bag_time.append(bag_time)\n    elif topic == '/imu_2/data':\n        self.imu_2_accel_x.append(msg.linear_acceleration.x)\n        self.imu_2_accel_y.append(msg.linear_acceleration.y)\n        self.imu_2_accel_z.append(msg.linear_acceleration.z)\n        self.imu_2_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000)\n        self.imu_2_bag_time.append(bag_time)\n    elif topic == '/imu_3/data':\n        self.imu_3_accel_x.append(msg.linear_acceleration.x)\n        self.imu_3_accel_y.append(msg.linear_acceleration.y)\n        self.imu_3_accel_z.append(msg.linear_acceleration.z)\n        self.imu_3_time.append(msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000)\n        self.imu_3_bag_time.append(bag_time)\n    elif topic == '/imu_4/data':\n        self.imu_4_accel_x.append(msg.linear_acceleration.x)\n        self.imu_", "CodeBleu_score": 24.749452008402667}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure and a subplot\n    fig = pyplot.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # Set the title\n    ax.set_title('Accelerations')\n\n    # Set the x axis label\n    ax.set_xlabel('Time (s)')\n\n    # Set the y axis label\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for i, dataset in enumerate(self.accelerations):\n        # Get the x, y, and z components\n        x = dataset.data[:, 0]\n        y = dataset.data[:, 1]\n        z = dataset.data[:, 2]\n\n        # Plot the x component\n        ax.plot(dataset.times, x, label='x' + str(i), color=self.colors[i])\n\n        # Plot the y component\n        ax.plot(dataset.times, y, label='y' + str(i), color=self.colors[i], linestyle='--')\n\n        # Plot the z component\n        ax.plot(dataset.times, z, label='z' + str(i), color=self.colors[i], linestyle=':')\n\n    # Add a legend\n    ax.legend(loc='best')\n\n    # Save the figure\n    if self.save_plots:\n        if plot_suffix is not None:\n            filename = self.plot_prefix + plot_suffix + '.png'\n        else:\n            filename = self.plot_prefix + 'accelerations.png'\n        fig.savefig(filename)\n\n", "CodeBleu_score": 43.34303215732681}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title\n    fig = pyplot.figure()\n    pyplot.title(\"Acceleration Data\")\n    # Create a subplot for accelerations\n    ax = fig.add_subplot(111)\n    # Plot the x, y, and z components of the acceleration data\n    ax.plot(self.accel_x, label=\"x\", color=\"red\")\n    ax.plot(self.accel_y, label=\"y\", color=\"green\")\n    ax.plot(self.accel_z, label=\"z\", color=\"blue\")\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # Add a legend\n    ax.legend(loc=\"upper left\")\n    # If saving plots is enabled, construct a filename and save the plot\n    if self.save_plots:\n        if plot_suffix:\n            filename = self.plot_prefix + plot_suffix + \".png\"\n        else:\n            filename = self.plot_prefix + \".png\"\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 34.60285737943116}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Set the figure size\n    fig = pyplot.figure(figsize=(12, 6))\n\n    # Create the subplot for accelerations\n    ax = fig.add_subplot(111)\n\n    # Plot the acceleration data\n    for i in range(0, len(self.accelerations)):\n        ax.plot(self.accelerations[i].header.stamp.to_sec(), self.accelerations[i].linear.x, color='r', label='x')\n        ax.plot(self.accelerations[i].header.stamp.to_sec(), self.accelerations[i].linear.y, color='g', label='y')\n        ax.plot(self.accelerations[i].header.stamp.to_sec(), self.accelerations[i].linear.z, color='b', label='z')\n\n    # Set the title and labels for the axes\n    ax.set_title('Accelerations')\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Add a legend\n    ax.legend()\n\n    # Save the figure\n    if self.save_plots:\n        filename = self.plot_prefix + 'accelerations'\n        if plot_suffix is not None:\n            filename += plot_suffix\n        filename += '.png'\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 36.865969488230945}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) > 1:\n        for i in range(len(pose_indeces)-1):\n            for j in range(i+1, len(pose_indeces)):\n                self.compare_two_xyz(self.pose_array[pose_indeces[i]], self.pose_array[pose_indeces[j]])\n    else:\n        print(\"At least two pose indices are required to compare positions.\")\n\n", "CodeBleu_score": 35.73923991929426}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    print(\"Comparing positions...\")\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 19.084375767397248}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"ERROR: compare_positions requires at least two pose indeces\")\n        return\n    else:\n        for i in range(len(pose_indeces) - 1):\n            for j in range(i + 1, len(pose_indeces)):\n                compare_two_xyz(self, pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 26.998515557345403}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    if start_time is None:\n        start_time = self.start_time\n    if end_time is None:\n        end_time = self.end_time\n    for collision in self.wrench:\n        if start_time <= collision <= end_time:\n            collision_times.append(collision)\n    return collision_times\n\n", "CodeBleu_score": 42.49269542170392}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None and end_time is None:\n            collision_times.append(collision.time)\n        elif start_time is None and end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None and end_time is None:\n            if collision.time >= start_time:\n                collision_times.append(collision.time)\n        else:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 38.99289441215359}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None or end_time is None:\n            collision_times.append(collision.header.stamp.to_sec())\n        elif start_time < collision.header.stamp.to_sec() < end_time:\n            collision_times.append(collision.header.stamp.to_sec())\n    return collision_times\n\n", "CodeBleu_score": 42.84715980745387}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.45415835736383}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.45415835736383}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.45415835736383}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n\n  // Calculate multiplier\n  double multiplier = 1.0;\n  if (use_multiplier_) {\n    double fx = 1.0 / (tan(hfov_ / 2.0) * 2.0);\n    double fy = 1.0 / (tan(vfov_ / 2.0) * 2.0);\n    multiplier = fx * fy / (width * height);\n  }\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Calculate RMS noise and noise values\n  double rms_noise = multiplier * sqrt(stddev_ * stddev_ +\n                                      multiplier * mean_ * mean_);\n  double noise_values[width * height];\n  for (uint32_t i = 0; i < width * height; i++) {\n    noise_values[i] = gaussian_dist_(gen_);\n  }\n\n  // Add noise to data\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vec(i) > 0.0 && data_vec(i) < max_depth_) {\n      data_vec(i) += rms_noise * noise_values[i];\n    } else {\n      data_vec(i) = bad_point_;\n    }\n  }\n}", "CodeBleu_score": 45.92802003691001}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  const float multiplier = 1.0f / 1000.0f;\n  const Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1> > data_vec(data,\n                                                                      width * height);\n\n  const float rms_noise = ComputeRmsNoise(width, height);\n  const float noise_values = ComputeNoiseValues(width, height, rms_noise);\n\n  for (uint32_t i = 0; i < data_vec.size(); i++) {\n    if (data_vec(i) > 0.0f) {\n      data_vec(i) += noise_values;\n    } else {\n      data_vec(i) = bad_point;\n    }\n    data_vec(i) *= multiplier;\n  }\n}", "CodeBleu_score": 45.41972244752156}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier based on camera parameters\n  float multiplier = 1.0f / (focal_length_ * (float)width);\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Calculate RMS noise\n  float rms_noise = std::sqrt(\n      noise_factor_ * noise_factor_ * (1.0f / (12.0f * multiplier * multiplier))\n          + offset_factor_ * offset_factor_);\n\n  // Calculate noise values\n  Eigen::VectorXf noise_vec(width * height);\n  for (uint32_t i = 0; i < width * height; i++) {\n    noise_vec(i) = rms_noise * rand_normal_dist_(rand_gen_);\n  }\n\n  // Add noise to data and set bad points\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vec(i) > 0.0f && data_vec(i) < max_depth_) {\n      data_vec(i) += noise_vec(i);\n    } else {\n      data_vec(i) = bad_point_;\n    }\n  }\n}", "CodeBleu_score": 51.54783365020589}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time time_now = ros::Time::now();\n  ros::Duration sim_time_ros(world_->GetSimTime().Double());\n  time_now.fromSec(sim_time_ros.toSec());\n  bag_.write(waypoint_topic_, time_now, *trajectory_msg);\n}", "CodeBleu_score": 50.53049231219171}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time simulation_time = ros::Time::now();\n  ros::Time::waitForValid();\n  trajectory_msg->header.stamp = simulation_time;\n  trajectory_msg->header.frame_id = \"world\";\n  trajectory_bag_.write(waypoint_topic_, simulation_time, *trajectory_msg);\n}", "CodeBleu_score": 40.09301346106785}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time.\n  gazebo::common::Time gz_time_now = model_->GetWorld()->GetSimTime();\n\n  // Convert Gazebo time to ROS time.\n  ros::Time ros_time_now = gazebo_ros::Convert<ros::Time>(gz_time_now);\n\n  // Write the trajectory message to the bag file.\n  bag_.write(waypoint_topic_, ros_time_now, *trajectory_msg);\n}", "CodeBleu_score": 47.96634498783462}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time time_now = ros::Time(now.sec, now.nsec);\n\n  // Create a message for motor velocities\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n  actuator_msg->header.stamp = time_now;\n\n  // Iterate through motor joints\n  for (int i = 0; i < num_rotors_; i++) {\n    // Calculate slowed-down rotational velocity\n    double motor_velocity = motor_joints_[i]->GetVelocity(0) / slowdown_;\n\n    // Assign motor velocity to message\n    actuator_msg->angular_velocities.push_back(motor_velocity);\n  }\n\n  // Write data to bag file\n  motor_velocities_pub_.publish(actuator_msg);\n}", "CodeBleu_score": 36.97698661750724}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert the simulation time to ROS time.\n  ros::Time time = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for the motor velocities.\n  mav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators);\n  actuators_msg->header.stamp = time;\n  actuators_msg->angular_velocities.resize(motor_joints_.size());\n\n  // Iterate through the motor joints.\n  for (int i = 0; i < motor_joints_.size(); ++i) {\n    // Calculate the slowed-down rotational velocities.\n    double velocity = motor_joints_[i]->GetVelocity(0) / slow_down_;\n\n    // Assign the velocities to the message.\n    actuators_msg->angular_velocities[i] = velocity;\n  }\n\n  // Publish the message.\n  motor_velocities_pub_.publish(actuators_msg);\n}", "CodeBleu_score": 49.152354695442405}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time.\n  ros::Time time_now = ros::Time::now();\n\n  // Prepare a message for motor velocities.\n  mav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators);\n  actuators_msg->angular_velocities.resize(num_rotor_joints_);\n  actuators_msg->header.stamp = time_now;\n\n  // Iterate through the motor joints.\n  for (int i = 0; i < num_rotor_joints_; i++) {\n    // Get the motor joint.\n    physics::JointPtr joint = model_->GetJoints()[motor_joints_[i]];\n\n    // Calculate the slowed-down rotational velocity.\n    double rotational_velocity = joint->GetVelocity(0);\n\n    // Assign the rotational velocity to the message.\n    actuators_msg->angular_velocities[i] = rotational_velocity;\n  }\n\n  // Write the message to a bag file using the specified namespace and motor topic.\n  motor_velocities_bag_->write(motor_velocities_topic_, time_now, *actuators_msg);\n}", "CodeBleu_score": 45.05175194256304}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_)\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double aileron_cmd = roll * (aileron_max_angle_ - aileron_min_angle_) / 2.0;\n  double elevator_cmd = pitch * (elevator_max_angle_ - elevator_min_angle_) / 2.0;\n  double rudder_cmd = yaw_rate * (rudder_max_angle_ - rudder_min_angle_) / 2.0;\n\n  // Set the throttle value from the thrust message.\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n  double throttle = thrust / max_thrust_;\n\n  // Set the control surface angles and throttle.\n  aileron_left_joint_->SetParam(\"fmax\", 0, aileron_force_);\n  aileron_right_joint_->SetParam(\"fmax\", 0, aileron_force_);\n  aileron_left_joint_->SetParam(\"hi_stop\", 0, aileron_max_angle_);\n  aileron_right_joint_->SetParam(\"hi_stop\", 0, aileron_max_angle_);\n  aileron_left_joint_->SetParam(\"lo_stop\", 0, aileron_min_angle_);\n  aileron_right_joint_->SetParam(\"lo_stop\", 0, aileron_min_angle_);\n  aileron_left_joint_->SetParam(\"vel\", 0, aileron_cmd);\n  aileron_right_joint_->SetParam", "CodeBleu_score": 49.353602660227416}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_)\n    ROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\");\n\n  double roll_cmd = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch_cmd = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate_cmd = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust_cmd = roll_pitch_yawrate_thrust_msg->thrust();\n\n  double delta_aileron_cmd =\n      roll_cmd * (aileron_left_joint_->GetUpperLimit(0) -\n                  aileron_left_joint_->GetLowerLimit(0)) / 2.0;\n  double delta_elevator_cmd =\n      pitch_cmd * (elevator_joint_->GetUpperLimit(0) -\n                   elevator_joint_->GetLowerLimit(0)) / 2.0;\n  double delta_rudder_cmd =\n      yaw_rate_cmd * (rudder_joint_->GetUpperLimit(0) -\n                      rudder_joint_->GetLowerLimit(0)) / 2.0;\n\n  aileron_left_joint_->SetParam(\"fmax\", 0, delta_aileron_cmd);\n  aileron_right_joint_->SetParam(\"fmax\", 0, -delta_aileron_cmd);\n  elevator_joint_->SetParam(\"fmax\", 0, delta_elevator_cmd);\n  rudder_joint_->SetParam(\"fmax\", 0, delta_rudder_cmd);\n\n  double throttle_cmd = thrust_cmd / propeller_joint_->GetForceUpperLimit(0);\n  propeller_joint_->SetParam(\"fmax\", 0, throttle_cmd);\n}", "CodeBleu_score": 37.243243890281896}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Normalized input values for roll, pitch, and yaw rate.\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  double delta_aileron = roll * (max_aileron_ - min_aileron_) / 2.0 + (max_aileron_ + min_aileron_) / 2.0;\n  double delta_elevator = pitch * (max_elevator_ - min_elevator_) / 2.0 + (max_elevator_ + min_elevator_) / 2.0;\n  double delta_rudder = yaw_rate * (max_rudder_ - min_rudder_) / 2.0 + (max_rudder_ + min_rudder_) / 2.0;\n\n  // Set throttle value from thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set the control surface angles.\n  SetAilerons(delta_aileron);\n  SetElevator(delta_elevator);\n  SetRudder(delta_rudder);\n  SetThrottle(throttle);\n}", "CodeBleu_score": 55.55028772620669}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Poll for data on the serial port.\n  struct timeval tv;\n  fd_set fds;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n  FD_ZERO(&fds);\n  FD_SET(this->serial_fd_, &fds);\n  int ret = select(this->serial_fd_ + 1, &fds, NULL, NULL, &tv);\n  if (ret < 0) {\n    gzerr << \"Error while polling for data on serial port.\n\";\n    return;\n  }\n  if (ret == 0) {\n    // Timeout, no data available.\n    return;\n  }\n\n  // Receive data from the serial port.\n  uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n  int len = ::read(this->serial_fd_, buffer, sizeof(buffer));\n  if (len < 0) {\n    gzerr << \"Error while reading data from serial port.\n\";\n    return;\n  }\n\n  // Parse received data for MAVLink messages.\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  for (int i = 0; i < len; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n      // Handle message.\n      this->handle_mavlink_message(msg);\n    }\n  }\n}", "CodeBleu_score": 61.16025590262277}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for messages\n  struct timeval tv;\n  fd_set fds;\n  int ret;\n\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n  FD_ZERO(&fds);\n  FD_SET(this->hil_fd_, &fds);\n\n  ret = select(this->hil_fd_ + 1, &fds, NULL, NULL, &tv);\n\n  if (ret < 0) {\n    gzerr << \"select err: \" << strerror(errno) << \"\n\";\n  } else if (ret > 0) {\n    if (FD_ISSET(this->hil_fd_, &fds)) {\n      // receive message\n      int len = recvfrom(this->hil_fd_, this->buf_, sizeof(this->buf_), 0,\n                         (struct sockaddr *) &this->sender_address_,\n                         &this->sender_address_len_);\n\n      if (len > 0) {\n        this->parseMavlinkMessages(len);\n      }\n    }\n  }\n}", "CodeBleu_score": 48.786334708852245}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval tv;\n  tv.tv_sec = 0;\n  tv.tv_usec = _timeoutMs * 1000;\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->socket_fd_, &fds);\n  int ret = select(this->socket_fd_ + 1, &fds, NULL, NULL, &tv);\n  if (ret < 0) {\n    gzerr << \"Error in select() \" << errno << \"\n\";\n  } else if (ret > 0) {\n    if (FD_ISSET(this->socket_fd_, &fds)) {\n      int len = 0;\n      do {\n        len = recvfrom(this->socket_fd_, this->buf_, sizeof(this->buf_), 0,\n                       (struct sockaddr *) &this->fromAddr_, &this->fromAddrLen_);\n        if (len <= 0) {\n          break;\n        }\n        mavlink_message_t msg;\n        mavlink_status_t status;\n        for (unsigned i = 0; i < len; ++i) {\n          if (mavlink_parse_char(MAVLINK_COMM_0, this->buf_[i], &msg, &status)) {\n            this->handle_mavlink_message(msg);\n          }\n        }\n      } while (len > 0);\n    }\n  }\n}", "CodeBleu_score": 58.9980611215979}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  if (this->is_open_) {\n    this->is_open_ = false;\n    this->io_service_.stop();\n    this->serial_dev_.close();\n    if (this->io_thread_.joinable())\n      this->io_thread_.join();\n  }\n}", "CodeBleu_score": 34.37196021326108}, {"code": "void GazeboMavlinkInterface::close() {\n\t  std::unique_lock<std::mutex> guard(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n    is_open_ = false;\n  }\n}", "CodeBleu_score": 65.55729862994644}, {"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> guard(mutex_);\n  if (open_) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n    open_ = false;\n  }\n}", "CodeBleu_score": 66.12757417486296}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d position,\n  ignition::math::Vector3d value_1,\n  ignition::math::Vector3d value_2,\n  ignition::math::Vector3d position_1,\n  ignition::math::Vector3d position_2\n}", "CodeBleu_score": 17.78719699768011}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    // Function to perform linear interpolation between two points.\n    // Given a position, it returns the interpolated value between two points using their corresponding values.\n    // The function assumes that the value is uniformly distributed.\n    //\n    // @param position: the position to be interpolated.\n    // @param position_1: the first position.\n    // @param value_1: the value at the first position.\n    // @param position_2: the second position.\n    // @param value_2: the value at the second position.\n    // @return: the interpolated value.\n    ignition::math::Vector3d position, position_1, value_1, position_2, value_2;\n    double a, b;\n    ignition::math::Vector3d result;\n\n    a = (position_2.X() - position.X()) / (position_2.X() - position_1.X());\n    b = (position_2.Y() - position.Y()) / (position_2.Y() - position_1.Y());\n    result.X() = a * value_1.X() + (1 - a) * value_2.X();\n    result.Y() = b * value_1.Y() + (1 - b) * value_2.Y();\n    result.Z() = a * value_1.Z() + (1 - a) * value_2.Z();\n\n    return result;\n}", "CodeBleu_score": 36.61606384741814}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\n    // Get the index of the lower bound of the position\n    int i = (int) floor(pos);\n\n    // Get the index of the upper bound of the position\n    int j = (int) ceil(pos);\n\n    // Get the fraction between the two indexes\n    double frac = pos - i;\n\n    // Return the interpolated value\n    return (1 - frac) * values[i] + frac * values[j];\n}", "CodeBleu_score": 29.430900665338456}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  if (_time < 0.0) {\n    gzerr << \"Invalid animation time of [\" << _time << \"]\n\";\n    return;\n  }\n\n  if (this->loop) {\n    this->timePos = fmod(_time, this->length);\n  } else {\n    this->timePos = std::max(0.0, std::min(_time, this->length));\n  }\n}", "CodeBleu_score": 47.18529585600943}, {"code": "void Animation::SetTime(double _time){\n\t  if (this->loop) {\n    this->time = fmod(_time, this->Length());\n    if (this->time < 0) {\n      this->time += this->Length();\n    }\n  } else {\n    this->time = std::max(0.0, std::min(_time, this->Length()));\n  }\n}", "CodeBleu_score": 45.153582003804125}, {"code": "void Animation::SetTime(double _time){\n\t  // set the time position\n  this->timePos = _time;\n\n  // wrap time around if looping is enabled\n  if (this->loop) {\n    if (this->timePos > this->length)\n      this->timePos -= this->length;\n    else if (this->timePos < 0.0)\n      this->timePos += this->length;\n  }\n  // clamp time between 0 and animation length if looping is disabled\n  else {\n    if (this->timePos > this->length)\n      this->timePos = this->length;\n    else if (this->timePos < 0.0)\n      this->timePos = 0.0;\n  }\n}", "CodeBleu_score": 64.80930485773064}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.motion_type = 0\n    self.coordinate_frame = 1\n    self.target_motion = PositionTarget()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.coordinate_frame = self.coordinate_frame\n    self.target_motion.type_mask = self.motion_type\n    self.target_motion.position.x = self.local_pose.pose.position.x\n    self.target_motion.position.y = self.local_pose.pose.position.y\n    self.target_motion.position.z = self.local_pose.pose.position.z\n    self.target_motion.yaw = self.yaw\n    self.setpoint_publisher.publish(self.target_motion)\n    print(self.vehicle_type + \" \" + str(self.vehicle_id) + \" \" + self.flight_mode)\n\n", "CodeBleu_score": 35.59455965931053}, {"code": "def hover(self)\n\t\n    self.target_motion.coordinate_frame = 1\n    self.target_motion.type_mask = 0\n    self.target_motion.position.x = self.local_pose.pose.position.x\n    self.target_motion.position.y = self.local_pose.pose.position.y\n    self.target_motion.position.z = self.local_pose.pose.position.z\n    self.target_motion.yaw = self.yaw\n    self.motion_pub.publish(self.target_motion)\n    rospy.loginfo(\n        '\\033[94m' + \"Vehicle type: \"\n        + str(self.vehicle_type)\n        + \" Vehicle id: \"\n        + str(self.vehicle_id)\n        + \" Flight mode: \"\n        + str(self.flight_mode)\n        + \" Frame: \"\n        + str(self.target_motion.coordinate_frame)\n        + \" Type: \"\n        + str(self.target_motion.type_mask)\n        + \" X: \"\n        + str(self.target_motion.position.x)\n        + \" Y: \"\n        + str(self.target_motion.position.y)\n        + \" Z: \"\n        + str(self.target_motion.position.z)\n        + \" Yaw: \"\n        + str(self.target_motion.yaw)\n        + '\\033[0m'\n    )\n\n", "CodeBleu_score": 29.588432833076343}, {"code": "def hover(self)\n\t\n    self.target_motion.coordinate_frame = 1\n    self.target_motion.type_mask = 0\n    self.target_motion.position.x = self.current_pose.pose.position.x\n    self.target_motion.position.y = self.current_pose.pose.position.y\n    self.target_motion.position.z = self.current_pose.pose.position.z\n    self.target_motion.yaw = self.yaw\n    self.target_motion.yaw_rate = 0\n    self.target_motion.velocity.x = 0\n    self.target_motion.velocity.y = 0\n    self.target_motion.velocity.z = 0\n    self.target_motion.acceleration_or_force.x = 0\n    self.target_motion.acceleration_or_force.y = 0\n    self.target_motion.acceleration_or_force.z = 0\n    self.target_motion.thrust = 0\n\n    print(\"Vehicle type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 28.635541971626555}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo('Flight mode switched to ' + self.flightMode)\n            return True\n        except:\n            rospy.logwarn('Flight mode switch to ' + self.flightMode + ' failed')\n            return False\n\n", "CodeBleu_score": 33.747553129113335}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            rospy.wait_for_service('flightModeService', timeout=5)\n            flightModeService = rospy.ServiceProxy('flightModeService', SetMode)\n            flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo(\"Flight mode switched to: \" + self.flightMode)\n            return True\n        except rospy.ServiceException, e:\n            rospy.loginfo(\"Flight mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 50.59679078187776}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo('Flight mode switched to ' + self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.loginfo('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 53.041939834497164}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    # print('cmd_vel_enu_callback')\n    self.hover_flag = False\n    self.hold_flag = False\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PositionTarget()\n        self.target_motion.header.stamp = rospy.Time.now()\n        self.target_motion.coordinate_frame = self.coordinate_frame\n        self.target_motion.type_mask = self.motion_type\n        self.target_motion.velocity.x = msg.linear.x\n        self.target_motion.velocity.y = msg.linear.y\n        self.target_motion.velocity.z = msg.linear.z\n        self.target_motion.yaw_rate = msg.angular.z\n        self.target_motion.position.x = 0\n        self.target_motion.position.y = 0\n        self.target_motion.position.z = 0\n\n", "CodeBleu_score": 50.73844051002231}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = PositionTarget()\n        self.target_motion.type_mask = 1987\n        self.target_motion.coordinate_frame = self.coordinate_frame\n        self.target_motion.position.x = msg.linear.x\n        self.target_motion.position.y = msg.linear.y\n        self.target_motion.position.z = 0\n        self.target_motion.yaw = msg.angular.z\n        self.target_motion.yaw_rate = 0\n        self.target_motion.velocity.x = 0\n        self.target_motion.velocity.y = 0\n        self.target_motion.velocity.z = 0\n        self.target_motion.acceleration_or_force.x = 0\n        self.target_motion.acceleration_or_force.y = 0\n        self.target_motion.acceleration_or_force.z = 0\n        self.target_motion.yaw_acceleration_or_torque = 0\n        self.target_motion_pub.publish(self.target_motion)\n\n", "CodeBleu_score": 40.14382899578985}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_flag = False\n    self.hold_flag = False\n    self.vel_enu_flag = True\n    self.vel_ned_flag = False\n    self.vel_body_flag = False\n    self.pos_flag = False\n    self.yaw_flag = False\n    self.yaw_rate_flag = False\n    self.motion_type = 1\n    self.coordinate_frame = 1\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.target_motion = PositionTarget()\n        self.target_motion.coordinate_frame = self.coordinate_frame\n        self.target_motion.type_mask = self.motion_type\n        self.target_motion.velocity.x = msg.linear.x\n        self.target_motion.velocity.y = msg.linear.y\n        self.target_motion.velocity.z = msg.linear.z\n        self.target_motion.yaw_rate = msg.angular.z\n\n", "CodeBleu_score": 45.76700516730323}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode_client(base_mode=0, custom_mode=\"OFFBOARD\")\n    else:\n        if self.hover_flag == 0:\n            self.hover_flag = 1\n            self.set_mode_client(base_mode=0, custom_mode=\"HOVER\")\n\n", "CodeBleu_score": 36.405456100216824}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005) and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.set_mode_client(base_mode=0, custom_mode=\"OFFBOARD\")\n    elif (x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005) and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.set_mode_client(base_mode=0, custom_mode=\"HOVER\")\n\n", "CodeBleu_score": 35.621315832057064}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 1\n            self.set_mode_client(base_mode=0, custom_mode=\"HOVER\")\n    elif self.hover_flag == 1:\n        if abs(x) <= 0.02 and abs(y) <= 0.02 and abs(z) <= 0.02 and abs(w) <= 0.005:\n            self.hover_flag = 0\n            self.set_mode_client(base_mode=0, custom_mode=\"OFFBOARD\")\n\n", "CodeBleu_score": 58.24994950822321}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw_pitch_roll[0]\n    else:\n        yaw = Quaternion(q[0], q[1], q[2], q[3]).yaw_pitch_roll[0]\n    return yaw\n\n", "CodeBleu_score": 50.55122471176294}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 26.04957448605886}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 26.04957448605886}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = PositionTarget.IGNORE_PX\n    self.target_motion = PositionTarget()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.coordinate_frame = self.coordinate_frame\n    self.target_motion.type_mask = self.motion_type\n    self.target_motion.position.x = 0\n    self.target_motion.position.y = 0\n    self.target_motion.position.z = 0\n    self.target_motion.yaw = 0\n    self.target_motion.yaw_rate = 0\n    self.target_motion.z_speed = 0\n    self.target_motion.x_speed = 0\n    self.target_motion.y_speed = 0\n    self.target_motion.pitch = 0\n    self.target_motion.roll = 0\n    self.target_motion.thrust = 0\n    self.target_motion.acceleration_or_force.x = 0\n    self.target_motion.acceleration_or_force.y = 0\n    self.target_motion.acceleration_or_force.z = 0\n    self.target_motion.yaw_acceleration_or_angle = 0\n    self.target_motion.yaw_speed = 0\n    self.pub_setpoint.publish(self.target_motion)\n    self.flight_mode = \"HOVER\"\n    print(\"Vehicle Type:\", self.vehicle_type, \"", "CodeBleu_score": 19.184487995096625}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = PositionTarget.TYPE_POSITION\n    self.target_motion = PositionTarget()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.coordinate_frame = self.coordinate_frame\n    self.target_motion.type_mask = self.motion_type\n    self.target_motion.position.x = self.local_pose.pose.position.x\n    self.target_motion.position.y = self.local_pose.pose.position.y\n    self.target_motion.position.z = self.local_pose.pose.position.z\n    self.target_motion.yaw = self.yaw\n    self.target_motion.yaw_rate = 0\n    self.target_motion.z_speed = 0\n    self.target_motion.x_speed = 0\n    self.target_motion.y_speed = 0\n    self.target_motion.pitch = 0\n    self.target_motion.roll = 0\n    self.target_motion.afx = 0\n    self.target_motion.afy = 0\n    self.target_motion.afz = 0\n    self.target_motion.thrust = 0\n    self.local_pub.publish(self.target_motion)\n    print(self.vehicle_type + \" \" + str(self.vehicle_id) + \" is hovering\")\n\n", "CodeBleu_score": 22.349261011123772}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = PositionTarget.TYPE_POSITION\n    self.target_motion = PositionTarget()\n    self.target_motion.header.stamp = rospy.Time.now()\n    self.target_motion.coordinate_frame = self.coordinate_frame\n    self.target_motion.type_mask = self.motion_type\n    self.target_motion.position.x = self.current_position.pose.position.x\n    self.target_motion.position.y = self.current_position.pose.position.y\n    self.target_motion.position.z = self.current_position.pose.position.z\n    self.target_motion.yaw = self.yaw\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.velocity.x = 0.0\n    self.target_motion.velocity.y = 0.0\n    self.target_motion.velocity.z = 0.0\n    self.target_motion.acceleration_or_force.x = 0.0\n    self.target_motion.acceleration_or_force.y = 0.0\n    self.target_motion.acceleration_or_force.z = 0.0\n    self.target_motion.thrust = 0.0\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.yaw = self.yaw\n    self.target_motion.acceleration_or_force.z = 0.0\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.thrust = 0.0\n    self.target_motion.yaw_rate = 0.0\n    self.target_motion.yaw = self.yaw\n    self.target_motion.acceleration_or_force.z = 0.0\n    self.target_m", "CodeBleu_score": 15.671777051527535}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy('mavros/set_mode', SetMode)\n            flightModeService(custom_mode=self.flightMode)\n            print(\"Flight mode switched to: \" + self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service did not process request: \" + str(e))\n            return False\n\n", "CodeBleu_score": 34.43851272370203}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            flightModeService = rospy.ServiceProxy(\n                'mavros/set_mode', SetMode)\n            flightModeService(custom_mode=self.flightMode)\n            rospy.loginfo('Flight mode changed to ' + self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            rospy.loginfo(\"Service did not process request: \" + str(e))\n            return False\n\n", "CodeBleu_score": 43.624894435875476}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            res = self.flightModeService(custom_mode=self.flight_mode)\n            if res.mode_sent:\n                rospy.loginfo('Flight mode switched to ' + self.flight_mode)\n                return True\n            else:\n                rospy.loginfo('Flight mode did not switch.')\n                return False\n        except rospy.ServiceException, e:\n            rospy.loginfo('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 34.981252214474615}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.child_frame_id == self.uav_ids[i]:\n        self.local_poses[i] = msg\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_poses[i] = msg\n        elif self.gcs_command == \"hover\":\n            self.hover_target_poses[i] = msg\n        self.global_poses[i] = copy.deepcopy(self.local_poses[i])\n        self.global_poses[i].pose.position.x += self.bias_x\n        self.global_poses[i].pose.position.y += self.bias_y\n        self.global_poses[i].pose.position.z += self.bias_z\n\n", "CodeBleu_score": 33.19152375919327}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.child_frame_id == \"local_origin\" + str(i):\n        self.local_pose[i] = msg\n        if self.ground_control_station_command[i] == \"takeoff\":\n            self.takeoff_target_pose[i] = msg\n        elif self.ground_control_station_command[i] == \"hover\":\n            self.hover_target_pose[i] = msg\n    if msg.child_frame_id == \"global_origin\":\n        self.global_pose[i] = msg\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.global_pose_bias[i][0]\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.global_pose_bias[i][1]\n        self.global_pose[i].pose.position.z = msg.pose.position.z + self.global_pose_bias[i][2]\n\n", "CodeBleu_score": 32.6995112890474}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.uav_id[i]:\n        self.local_pose[i] = msg\n        if self.gcs_cmd[i] == 'takeoff':\n            self.takeoff_target_pose[i] = msg\n        elif self.gcs_cmd[i] == 'hover':\n            self.hover_target_pose[i] = msg\n        elif self.gcs_cmd[i] == 'land':\n            self.land_target_pose[i] = msg\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.bias[i][0]\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.bias[i][1]\n        self.global_pose[i].pose.position.z = msg.pose.position.z + self.bias[i][2]\n        self.global_pose[i].pose.orientation = msg.pose.orientation\n\n", "CodeBleu_score": 30.163242579788424}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.arm_state and self.altitude > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 57.29218114713974}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 70.13649723325177}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state and self.local_pose.pose.position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 63.74420584470499}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation_np = numpy.array(orig_formation)\n    change_formation_np = numpy.array(change_formation)\n    orig_formation_np_transpose = orig_formation_np.transpose()\n    change_formation_np_transpose = change_formation_np.transpose()\n    orig_formation_np_transpose_list = orig_formation_np_transpose.tolist()\n    change_formation_np_transpose_list = change_formation_np_transpose.tolist()\n    distance_matrix = []\n    for i in range(len(orig_formation_np_transpose_list)):\n        distance_matrix.append([])\n        for j in range(len(change_formation_np_transpose_list)):\n            distance_matrix[i].append(int(50 - numpy.linalg.norm(orig_formation_np_transpose_list[i] - change_formation_np_transpose_list[j])))\n    return distance_matrix\n\n", "CodeBleu_score": 16.357977639794168}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # get the number of UAVs in the formation\n    num_UAVs = len(orig_formation)\n\n    # create an empty distance matrix\n    distance_matrix = [[0 for i in range(num_UAVs)] for j in range(num_UAVs)]\n\n    # calculate the pairwise distances between UAVs in the original formation\n    for i in range(num_UAVs):\n        for j in range(i+1, num_UAVs):\n            # calculate the Euclidean distance between UAVs i and j\n            distance = numpy.linalg.norm(numpy.array(orig_formation[i]) - numpy.array(orig_formation[j]))\n            # adjust the distance by subtracting it from 50\n            distance = 50 - distance\n            # convert the distance to an integer\n            distance = int(distance)\n            # insert the distance into the distance matrix\n            distance_matrix[i][j] = distance\n            distance_matrix[j][i] = distance\n\n    # calculate the pairwise distances between UAVs in the changed formation\n    for i in range(num_UAVs):\n        for j in range(i+1, num_UAVs):\n            # calculate the Euclidean distance between UAVs i and j\n            distance = numpy.linalg.norm(numpy.array(change_formation[i]) - numpy.array(change_formation[j]))\n            # adjust the distance by subtracting it from 50\n            distance = 50 - distance\n            # convert the distance to an integer\n            distance = int(distance)\n            # insert the distance into the distance matrix\n            distance_matrix[i][j] = distance\n            distance_matrix[j][i] = distance\n\n    return distance_matrix\n", "CodeBleu_score": 28.653640749418724}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    num_uav = len(orig_formation)\n    graph = [[0 for i in range(num_uav)] for j in range(num_uav)]\n    for i in range(num_uav):\n        for j in range(num_uav):\n            graph[i][j] = int(50 - numpy.linalg.norm(orig_formation[i] - change_formation[j]))\n    return graph\n", "CodeBleu_score": 32.531069563386325}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.left_visited[i] = True\n    for j in range(self.n_right):\n        if self.right_visited[j]:\n            continue\n        gap = self.right_label[j] - self.left_label[i] - self.right_slack[j]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                self.right_match[j] = i\n                return True\n        elif self.right_slack[j] > 0:\n            self.slack[j] = gap\n    return False\n\n", "CodeBleu_score": 46.425514964463964}, {"code": "def find_path(self, i)\n\t\n    self.left_visited[i] = True\n    for j in range(self.right_size):\n        if self.right_visited[j] == False:\n            gap = self.left_label[i] + self.right_label[j] - self.match_weight[i][j]\n            if gap == 0:\n                self.right_visited[j] = True\n                if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                    self.right_match[j] = i\n                    self.left_match[i] = j\n                    return True\n            elif self.right_slack[j] > gap:\n                self.right_slack[j] = gap\n    return False\n\n", "CodeBleu_score": 43.01780359771138}, {"code": "def find_path(self, i)\n\t\n    # Mark left vertex as visited\n    self.left_visited[i] = True\n    # Iterate through adjacent right vertices\n    for j in range(self.n_right):\n        # If right vertex is already visited, continue\n        if self.right_visited[j]:\n            continue\n        # Calculate gap between labels\n        gap = self.right_labels[j] - self.left_labels[i]\n        # If gap is zero, mark right vertex as visited and check if it can either find a path or update the match\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                self.right_match[j] = i\n                self.left_match[i] = j\n                return True\n        # If gap is not zero, update slack value for right vertex\n        elif self.right_match[j] == -1 or gap < self.slack[self.right_match[j]]:\n            self.slack[j] = gap\n    return False\n\n", "CodeBleu_score": 43.98219887001166}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays\n    for i in range(self.N):\n        self.slack[i] = sys.maxsize\n        self.visited_left[i] = False\n        self.visited_right[i] = False\n    # Iterate over UAVs\n    for u in range(self.N):\n        # Initialize slack variables and visit arrays\n        for i in range(self.N):\n            self.slack[i] = sys.maxsize\n            self.visited_left[i] = False\n            self.visited_right[i] = False\n        # Find path starting from u\n        path = self.find_path(u)\n        # If no path is found, adjust labels\n        if path is None:\n            for i in range(self.N):\n                if self.visited_right[i]:\n                    self.label_right[i] = self.label_right[i] + self.slack[i]\n        # If path is found, update labels and return match\n        else:\n            for i in range(self.N):\n                if self.visited_right[i]:\n                    self.label_right[i] = self.label_right[i] + self.slack[i]\n            return path\n    return None\n\n", "CodeBleu_score": 27.790480532237595}, {"code": "def KM(self)\n\t\n    #Initialize slack variables and visit arrays\n    slack = [0 for i in range(self.num_uavs)]\n    visited_left = [0 for i in range(self.num_uavs)]\n    visited_right = [0 for i in range(self.num_targets)]\n\n    #Iterate over UAVs\n    for uav in range(self.num_uavs):\n        #Initialize path variables\n        path = [-1 for i in range(self.num_targets)]\n        #Set slack variables to 0\n        for i in range(self.num_targets):\n            slack[i] = 0\n        #Set path variables to 0\n        for i in range(self.num_targets):\n            path[i] = 0\n        #Set path variable for UAV to 1\n        path[uav] = 1\n        #Set slack variable for UAV to 1\n        slack[uav] = 1\n        #Set visited variables for UAV to 1\n        visited_left[uav] = 1\n        #Set visited variables for right side of bipartite graph to 0\n        visited_right = [0 for i in range(self.num_targets)]\n        #Set current UAV to current target\n        current = uav\n        #Initialize current target to UAV\n        current_target = uav\n        #Initialize target to UAV\n        target = uav\n        #Initialize found to 0\n        found = 0\n        #Initialize finished to 0\n        finished = 0\n        #While no path is found\n        while found == 0:\n            #If the current target is unvisited\n            if visited_right[current_target] == 0:\n                #Set current target to visited\n                visited_right[current_target] = 1\n                #If the current target is the UAV\n                if current_target == uav:\n                    #Set found to 1\n                    found = 1\n                #Else\n                else:\n                    #Set current to current target\n                    current = current_target\n                    #Set current target to path variable for", "CodeBleu_score": 24.4002252413245}, {"code": "def KM(self)\n\t\n    # Initialize slack variables\n    slack = numpy.zeros(self.num_uavs)\n    # Initialize visit arrays\n    visited_uavs = numpy.zeros(self.num_uavs)\n    visited_targets = numpy.zeros(self.num_targets)\n    # Iterate over UAVs\n    for uav in range(self.num_uavs):\n        # Initialize slack variables\n        slack = numpy.zeros(self.num_uavs)\n        # Initialize visit arrays\n        visited_uavs = numpy.zeros(self.num_uavs)\n        visited_targets = numpy.zeros(self.num_targets)\n        # Initialize path\n        path = []\n        # Initialize slack variables\n        slack = numpy.zeros(self.num_uavs)\n        # Initialize visit arrays\n        visited_uavs = numpy.zeros(self.num_uavs)\n        visited_targets = numpy.zeros(self.num_targets)\n        # Initialize path\n        path = []\n        # Initialize current UAV\n        current_uav = uav\n        # Initialize current target\n        current_target = self.labels[uav]\n        # Add current UAV to path\n        path.append(current_uav)\n        # Add current target to path\n        path.append(current_target)\n        # Set current UAV as visited\n        visited_uavs[current_uav] = 1\n        # Set current target as visited\n        visited_targets[current_target] = 1\n        # Initialize found path\n        found_path = False\n        # Initialize finished\n        finished = False\n        # Initialize slack\n        slack = numpy.zeros(self.num_uavs)\n        # Initialize slack\n        slack = numpy.zeros(self.num_uavs)\n        # Initialize slack\n        slack = numpy.zeros(self.num_uavs)\n        # Initialize slack\n        slack = numpy.zeros(self.num_uavs)\n        # Initialize slack\n        slack = numpy.zeros", "CodeBleu_score": 24.369833810851258}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.09532694324272}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([15, 150, 150])\n    upper_yellow = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.318885389038545}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    std::map<int, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN_STREAM(\"Standalone tag description for ID \" << id << \" not found\");\n        }\n        return false;\n    }\n    descriptionContainer = it->second;\n    return true;\n}", "CodeBleu_score": 48.61398673016175}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const auto it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN_STREAM(\"No standalone tag description found for ID \" << id << \". Using default.\");\n        }\n        descriptionContainer = defaultStandaloneTagDescription;\n        return false;\n    }\n    descriptionContainer = it->second;\n    return true;\n}", "CodeBleu_score": 48.90652790284244}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    std::map<int, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN(\"Standalone tag description not found for tag ID %d\", id);\n        }\n        return false;\n    }\n    descriptionContainer = it->second;\n    return true;\n}", "CodeBleu_score": 48.564686547447664}]}
